bk://kernel.bkbits.net/gregkh/linux/i2c-2.6
johnpol@2ka.mipt.ru|ChangeSet|20040929231412|58487 johnpol

# This is a BitKeeper generated diff -Nru style patch.
#
# ChangeSet
#   2004/09/29 16:14:12-07:00 johnpol@2ka.mipt.ru 
#   [PATCH] w1: schedule_timeout() issues.
#   
#   Need to set current state and check signals.
#   
#   Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/w1/w1_int.c
#   2004/09/28 10:33:01-07:00 johnpol@2ka.mipt.ru +9 -2
#   w1: schedule_timeout() issues.
# 
# drivers/w1/w1_family.c
#   2004/09/28 10:33:01-07:00 johnpol@2ka.mipt.ru +9 -2
#   w1: schedule_timeout() issues.
# 
# drivers/w1/w1.c
#   2004/09/28 10:33:01-07:00 johnpol@2ka.mipt.ru +15 -5
#   w1: schedule_timeout() issues.
# 
# drivers/w1/dscore.c
#   2004/09/28 10:30:33-07:00 johnpol@2ka.mipt.ru +10 -3
#   w1: schedule_timeout() issues.
# 
# ChangeSet
#   2004/09/29 13:41:52-07:00 mhoffman@lightlink.com 
#   [PATCH] i2c: kill some sensors driver macro abuse
#   
#   This patch kills a specific kind of ugly and ultimately useless macro
#   abuse found in many sensors chip drivers.  Compile tested only.
#   
#   Signed-off-by: Mark M. Hoffman <mhoffman@lightlink.com>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/chips/w83781d.c
#   2004/09/22 20:58:02-07:00 mhoffman@lightlink.com +9 -9
#   i2c: kill some sensors driver macro abuse
# 
# drivers/i2c/chips/w83627hf.c
#   2004/09/22 20:58:02-07:00 mhoffman@lightlink.com +9 -9
#   i2c: kill some sensors driver macro abuse
# 
# drivers/i2c/chips/via686a.c
#   2004/09/22 20:58:02-07:00 mhoffman@lightlink.com +15 -15
#   i2c: kill some sensors driver macro abuse
# 
# drivers/i2c/chips/smsc47m1.c
#   2004/09/22 20:58:02-07:00 mhoffman@lightlink.com +9 -9
#   i2c: kill some sensors driver macro abuse
# 
# drivers/i2c/chips/lm85.c
#   2004/09/22 20:58:02-07:00 mhoffman@lightlink.com +16 -16
#   i2c: kill some sensors driver macro abuse
# 
# drivers/i2c/chips/lm78.c
#   2004/09/22 20:58:02-07:00 mhoffman@lightlink.com +9 -9
#   i2c: kill some sensors driver macro abuse
# 
# drivers/i2c/chips/it87.c
#   2004/09/22 20:58:02-07:00 mhoffman@lightlink.com +17 -17
#   i2c: kill some sensors driver macro abuse
# 
# drivers/i2c/chips/asb100.c
#   2004/09/22 20:58:02-07:00 mhoffman@lightlink.com +5 -5
#   i2c: kill some sensors driver macro abuse
# 
# drivers/i2c/chips/adm1031.c
#   2004/09/22 20:58:02-07:00 mhoffman@lightlink.com +21 -21
#   i2c: kill some sensors driver macro abuse
# 
# ChangeSet
#   2004/09/29 13:37:26-07:00 mhoffman@lightlink.com 
#   [PATCH] i2c: sensors chip driver updates
#   
#   This patch modifies some sysfs file names for sensors chip drivers in
#   accordance with the standard interface proposed here [1] and refined
#   here [2].  The lm_sensors userspace tools have been modified to accept
#   both the new and old names.  This patch was tested for some drivers,
#   and at least compile tested for the rest.
#   
#   [1] http://archives.andrew.net.au/lm-sensors/msg08477.html
#   
#   [2] http://archives.andrew.net.au/lm-sensors/msg18391.html
#   
#   Signed-off-by: Mark M. Hoffman <mhoffman@lightlink.com>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/chips/w83781d.c
#   2004/09/22 20:31:15-07:00 mhoffman@lightlink.com +10 -6
#   i2c: sensors chip driver updates
# 
# drivers/i2c/chips/w83627hf.c
#   2004/09/22 20:31:15-07:00 mhoffman@lightlink.com +2 -2
#   i2c: sensors chip driver updates
# 
# drivers/i2c/chips/smsc47m1.c
#   2004/09/22 20:31:15-07:00 mhoffman@lightlink.com +20 -20
#   i2c: sensors chip driver updates
# 
# drivers/i2c/chips/lm85.c
#   2004/09/22 20:31:15-07:00 mhoffman@lightlink.com +9 -8
#   i2c: sensors chip driver updates
# 
# drivers/i2c/chips/asb100.c
#   2004/09/22 20:31:15-07:00 mhoffman@lightlink.com +4 -4
#   i2c: sensors chip driver updates
# 
# drivers/i2c/chips/adm1031.c
#   2004/09/22 20:31:15-07:00 mhoffman@lightlink.com +3 -3
#   i2c: sensors chip driver updates
# 
# Documentation/i2c/sysfs-interface
#   2004/09/22 20:31:15-07:00 mhoffman@lightlink.com +5 -2
#   i2c: sensors chip driver updates
# 
# ChangeSet
#   2004/09/29 13:29:06-07:00 khali@linux-fr.org 
#   [PATCH] I2C: Store lm83 and lm90 temperatures in signed
#   
#   Back when I wrote the lm83 and lm90 drivers, I decided to use unsigned
#   variables to store temperature values as mirrored from the chipset
#   registers. I wonder why, since the registers use signed values
#   themselves. The patch below changes the variables back to signed types,
#   so as to simplify the conversions made by the driver, making them faster
#   and easier to understand.
#   
#   Additionally, the lm90 driver was lacking boundary checkings and proper
#   rounding when writing temperature limits to the chipset, so I added
#   these. I also reworded the comments about internal temperature values
#   representation for all chipsets.
#   
#   Tested to work fine on my (LM90-compatible) ADM1032 chip. lm83 patch
#   untested, but it is more simple and directly copied from the lm90, so I
#   am confident it works fine too.
#   
#   
#   Signed-off-by: Jean Delvare <khali@linux-fr.org>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/chips/lm90.c
#   2004/09/26 01:52:09-07:00 khali@linux-fr.org +22 -17
#   I2C: Store lm83 and lm90 temperatures in signed
# 
# drivers/i2c/chips/lm83.c
#   2004/09/26 01:58:06-07:00 khali@linux-fr.org +9 -8
#   I2C: Store lm83 and lm90 temperatures in signed
# 
# ChangeSet
#   2004/09/29 11:03:48-07:00 greg@kroah.com 
#   I2C: convert scx200_acb driver to not use pci_find_device
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/busses/scx200_acb.c
#   2004/09/29 11:03:31-07:00 greg@kroah.com +7 -6
#   I2C: convert scx200_acb driver to not use pci_find_device
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# ChangeSet
#   2004/09/29 11:01:14-07:00 greg@kroah.com 
#   I2C: change i2c-elektor.c driver from using pci_find_device()
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/busses/i2c-elektor.c
#   2004/09/29 11:00:32-07:00 greg@kroah.com +4 -4
#   I2C: change i2c-elektor.c driver from using pci_find_device()
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# ChangeSet
#   2004/09/21 16:40:19-07:00 nacc@us.ibm.com 
#   [PATCH] i2c/i2c-mpc: replace schedule_timeout() with msleep_interruptible()
#   
#   Properly orders set_current_state() and add_wait_queue().  Uses
#   msleep_interruptible() in place of schedule_timeout() to guarantee the
#   task delays as expected. Uses set_current_state() instead of direct
#   assignment of current->state.
#   
#   Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/busses/i2c-mpc.c
#   2004/09/16 16:37:31-07:00 nacc@us.ibm.com +4 -3
#   i2c/i2c-mpc: replace schedule_timeout() with msleep_interruptible()
# 
# ChangeSet
#   2004/09/21 16:39:57-07:00 khali@linux-fr.org 
#   [PATCH] I2C: Cleanup lm78 init
#   
#   This patch cleans the init part of the lm78 driver.
#   
#   * Do not reset the chip.
#   
#   * Get rid of useless code, which was accidentally left in when we
#   removed the limit initialization from the driver.
#   
#   * Do not enable monitoring if it is already enabled (it wouldn't hurt,
#   but since we can avoid it at no cost...)
#   
#   Similar changes were applied to the Linux 2.4 driver, which I
#   successfully tested on my own LM78 chip.
#   
#   Signed-off-by: Jean Delvare <khali@linux-fr.org>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/chips/lm78.c
#   2004/09/20 10:52:06-07:00 khali@linux-fr.org +4 -18
#   I2C: Cleanup lm78 init
# 
# ChangeSet
#   2004/09/21 16:39:31-07:00 mhoffman@lightlink.com 
#   [PATCH] i2c: Add Intel VRD 10.0 and AMD Opteron VID support
#   
#   This patch adds support for Intel VRD 10.0 and AMD Opteron VID calculations.
#   It is based on the lm_sensors project CVS, r1.6.
#   
#   Signed-off-by: Mark M. Hoffman <mhoffman@lightlink.com>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# include/linux/i2c-vid.h
#   2004/09/15 19:50:26-07:00 mhoffman@lightlink.com +35 -1
#   i2c: Add Intel VRD 10.0 and AMD Opteron VID support
# 
# ChangeSet
#   2004/09/15 15:27:44-07:00 johnpol@2ka.mipt.ru 
#   [PATCH] w1_therm: more precise temperature calculation
#   
#   This patch will introduce new temperature calculation mechanism which
#   allows to use up to 9bit resolution(currently 3 digits after point).
#   Fixed timeout issues with multiple repeated reading.
#   
#   Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/w1/w1_therm.c
#   2004/09/15 01:04:38-07:00 johnpol@2ka.mipt.ru +43 -28
#   w1_therm: more precise temperature calculation
# 
# ChangeSet
#   2004/09/14 10:52:06-07:00 khali@linux-fr.org 
#   [PATCH] I2C: Update Documentation/i2c/writing-clients
#   
#   This is a very small an update to Documentation/i2c/writing-clients. The
#   changes are about i2c client driver ID. It used to say that chip driver
#   writers should ask for a unique ID. It now explains that such an ID is
#   not required and they can go without it. Until we get plain rid of it...
#   
#   The patch additionally features CodingStyle updates. We can't ask people
#   to respect it and at the same time ignore it in our own docs.
#   
#   I have made a similar change to the i2c (the project) documentation, and
#   will propose an update to Marcelo for Linux 2.4 (not sure he will accept
#   it though).
#   
#   Signed-off-by: Jean Delvare <khali@linux-fr.org>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# Documentation/i2c/writing-clients
#   2004/09/13 13:19:25-07:00 khali@linux-fr.org +14 -12
#   I2C: Update Documentation/i2c/writing-clients
# 
# ChangeSet
#   2004/09/14 10:50:58-07:00 khali@linux-fr.org 
#   [PATCH] I2C: More verbose debug in w83781d detection
#   
#   Quoting myself:
#   > As for me, I will propose my extra-debug patch (slightly cleaned up)
#   > for inclusion into the 2.6 kernel. It helped us once, so it could
#   > prove to be valuable in the future as well.
#   
#   Here is the patch. It makes the w83781d (mis)detection more verbose so
#   as to help debugging problems. The extra messages of course only show
#   when I2C chip debugging is enabled. It additionally features some code
#   refactoring, some CodingStyle cleanups and adds a missing white space in
#   one debug message.
#   
#   Signed-off-by: Jean Delvare <khali@linux-fr.org>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/chips/w83781d.c
#   2004/09/12 02:10:38-07:00 khali@linux-fr.org +27 -15
#   I2C: More verbose debug in w83781d detection
# 
# ChangeSet
#   2004/09/13 21:29:32-07:00 greg@kroah.com 
#   I2C: fix up __iomem marking for i2c bus drivers
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/busses/i2c-voodoo3.c
#   2004/09/13 21:29:06-07:00 greg@kroah.com +1 -1
#   I2C: fix up __iomem marking for i2c bus drivers
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/busses/i2c-savage4.c
#   2004/09/13 21:29:06-07:00 greg@kroah.com +1 -1
#   I2C: fix up __iomem marking for i2c bus drivers
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/busses/i2c-prosavage.c
#   2004/09/13 21:29:06-07:00 greg@kroah.com +3 -3
#   I2C: fix up __iomem marking for i2c bus drivers
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/busses/i2c-i810.c
#   2004/09/13 21:29:06-07:00 greg@kroah.com +1 -1
#   I2C: fix up __iomem marking for i2c bus drivers
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# ChangeSet
#   2004/09/09 10:02:27-07:00 johnpol@2ka.mipt.ru 
#   [PATCH] W1: let W1 select NET.
#   
#   On Wed, 2004-08-25 at 23:41, Greg KH wrote:
#   > On Wed, Aug 25, 2004 at 11:21:29PM +0400, Evgeniy Polyakov wrote:
#   > > On Wed, 25 Aug 2004 10:49:12 -0700
#   > > Greg KH <greg@kroah.com> wrote:
#   > >
#   > > > On Fri, Aug 13, 2004 at 02:35:40PM +0400, Evgeniy Polyakov wrote:
#   > > > > The patch below fixes this issue by letting W1 select NET.
#   > > > >
#   > > > > Patch was created by Adrian Bunk <bunk@fs.tum.de>.
#   > > >
#   > > > Nah, I'm going to hold off on this, it's not really needed (who
#   > > > doesn't build with NET enabled...)
#   > >
#   > > Hmmm, but someone really may want to build it without NET support.
#   > > I have an idea(I thought it out exactly for the case when you do not
#   > > apply it) to disable networking(netlink) support in compilation time if
#   > > CONFIG_NET is not defined.
#   > > And add some warning like:
#   > >
#   > > #ifndef CONFIG_NET
#   > > #warning Netlink support is disabled.
#   > > #endif
#   >
#   > That sounds like a good fix.
#   
#   
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/w1/w1_netlink.c
#   2004/08/25 20:52:51-07:00 johnpol@2ka.mipt.ru +8 -0
#   W1: let W1 select NET.
# 
# drivers/w1/Makefile
#   2004/08/25 20:57:26-07:00 johnpol@2ka.mipt.ru +4 -0
#   W1: let W1 select NET.
# 
# ChangeSet
#   2004/09/08 13:17:56-07:00 johnpol@2ka.mipt.ru 
#   [PATCH] w1: Added slave->ttl - time to live for the registered slave.
#   
#   Added slave->ttl - time to live for the registered slave.
#   When slave was not found we will not remove it immediately but wait until ->ttl attempts were done.
#   It prevents various debouncing effects(problems with pull-up, power).
#   
#   Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/w1/w1_int.h
#   2004/09/02 21:58:58-07:00 johnpol@2ka.mipt.ru +1 -1
#   w1: Added slave->ttl - time to live for the registered slave.
# 
# drivers/w1/w1_int.c
#   2004/09/02 21:58:58-07:00 johnpol@2ka.mipt.ru +4 -2
#   w1: Added slave->ttl - time to live for the registered slave.
# 
# drivers/w1/w1.h
#   2004/09/02 21:59:55-07:00 johnpol@2ka.mipt.ru +2 -0
#   w1: Added slave->ttl - time to live for the registered slave.
# 
# drivers/w1/w1.c
#   2004/09/02 21:59:55-07:00 johnpol@2ka.mipt.ru +7 -2
#   w1: Added slave->ttl - time to live for the registered slave.
# 
# ChangeSet
#   2004/09/08 12:36:05-07:00 khali@linux-fr.org 
#   [PATCH] I2C: Fix macro calls in chip drivers
#   
#   I noticed that some I2C chip drivers (all written or reviewed by me, I
#   feel ashamed to say) misuse macros. Passing function calls
#   (simple_strtol in this case) to macros evaluating their argument up to 4
#   times is certainly not wise and obviously performs poorly. It is not
#   critical in that it happens only when writing to the chips (setting
#   limits), which doesn't happen that often. However I'd say it's worth
#   fixing.
#   
#   Thus, the patch below fixes that, by moving the function calls outside
#   of the macro calls.
#   
#   
#   Signed-off-by: Jean Delvare <khali@linux-fr.org>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/chips/max1619.c
#   2004/08/24 10:34:41-07:00 khali@linux-fr.org +2 -1
#   I2C: Fix macro calls in chip drivers
# 
# drivers/i2c/chips/lm90.c
#   2004/08/24 10:37:50-07:00 khali@linux-fr.org +4 -2
#   I2C: Fix macro calls in chip drivers
# 
# drivers/i2c/chips/lm83.c
#   2004/08/24 10:39:16-07:00 khali@linux-fr.org +2 -1
#   I2C: Fix macro calls in chip drivers
# 
# drivers/i2c/chips/lm80.c
#   2004/08/24 10:41:08-07:00 khali@linux-fr.org +3 -2
#   I2C: Fix macro calls in chip drivers
# 
# drivers/i2c/chips/gl518sm.c
#   2004/08/24 10:44:40-07:00 khali@linux-fr.org +4 -2
#   I2C: Fix macro calls in chip drivers
# 
# drivers/i2c/chips/adm1025.c
#   2004/08/24 10:34:03-07:00 khali@linux-fr.org +8 -6
#   I2C: Fix macro calls in chip drivers
# 
# ChangeSet
#   2004/09/08 12:35:33-07:00 khali@linux-fr.org 
#   [PATCH] I2C: Do not init global variables to 0
#   
#   This trivial patch enforces the rule that global variables should not be
#   explicitely initialized to 0 for all i2c chip drivers.
#   
#   Signed-off-by: Jean Delvare <khali@linux-fr.org>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/chips/pcf8591.c
#   2004/08/24 12:19:34-07:00 khali@linux-fr.org +1 -1
#   I2C: Do not init global variables to 0
# 
# drivers/i2c/chips/pcf8574.c
#   2004/08/24 12:19:44-07:00 khali@linux-fr.org +1 -1
#   I2C: Do not init global variables to 0
# 
# drivers/i2c/chips/max1619.c
#   2004/08/24 12:19:50-07:00 khali@linux-fr.org +1 -1
#   I2C: Do not init global variables to 0
# 
# drivers/i2c/chips/lm90.c
#   2004/08/24 12:20:18-07:00 khali@linux-fr.org +1 -1
#   I2C: Do not init global variables to 0
# 
# drivers/i2c/chips/lm85.c
#   2004/08/24 12:20:24-07:00 khali@linux-fr.org +1 -1
#   I2C: Do not init global variables to 0
# 
# drivers/i2c/chips/lm83.c
#   2004/08/24 12:20:28-07:00 khali@linux-fr.org +1 -1
#   I2C: Do not init global variables to 0
# 
# drivers/i2c/chips/lm80.c
#   2004/08/24 12:20:34-07:00 khali@linux-fr.org +1 -1
#   I2C: Do not init global variables to 0
# 
# drivers/i2c/chips/lm77.c
#   2004/08/24 12:20:47-07:00 khali@linux-fr.org +1 -1
#   I2C: Do not init global variables to 0
# 
# drivers/i2c/chips/lm75.c
#   2004/08/24 12:20:54-07:00 khali@linux-fr.org +1 -1
#   I2C: Do not init global variables to 0
# 
# drivers/i2c/chips/it87.c
#   2004/08/24 12:20:59-07:00 khali@linux-fr.org +1 -1
#   I2C: Do not init global variables to 0
# 
# drivers/i2c/chips/gl518sm.c
#   2004/08/24 12:21:02-07:00 khali@linux-fr.org +1 -1
#   I2C: Do not init global variables to 0
# 
# drivers/i2c/chips/fscher.c
#   2004/08/24 12:21:07-07:00 khali@linux-fr.org +1 -1
#   I2C: Do not init global variables to 0
# 
# drivers/i2c/chips/eeprom.c
#   2004/08/24 12:21:11-07:00 khali@linux-fr.org +1 -1
#   I2C: Do not init global variables to 0
# 
# drivers/i2c/chips/ds1621.c
#   2004/08/24 12:21:14-07:00 khali@linux-fr.org +1 -1
#   I2C: Do not init global variables to 0
# 
# drivers/i2c/chips/adm1025.c
#   2004/08/24 12:21:17-07:00 khali@linux-fr.org +1 -1
#   I2C: Do not init global variables to 0
# 
# drivers/i2c/chips/adm1021.c
#   2004/08/24 12:21:34-07:00 khali@linux-fr.org +1 -1
#   I2C: Do not init global variables to 0
# 
# ChangeSet
#   2004/09/08 12:35:04-07:00 margitsw@t-online.de 
#   [PATCH] I2C: minor lm85 fix
#   
#   Jean scribeth :
#   > Except lm85, but this should be fixed
#   
#   Indeed, patch attached.
#   
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/chips/lm85.c
#   2004/08/26 10:45:23-07:00 margitsw@t-online.de +2 -0
#   I2C: minor lm85 fix
# 
# ChangeSet
#   2004/09/08 12:34:34-07:00 mhoffman@lightlink.com 
#   [PATCH] I2C/SMBus stub for driver testing
#   
#   * Greg KH <greg@kroah.com> [2004-08-24 16:44:32 -0700]:
#   > > > Why not?  It looks useful to me.  Care to send me a patch adding
#   > > > this to the main kernel tree?
#   
#   * Mark M. Hoffman <mhoffman@lightlink.com> [2004-08-25 10:25:02 -0400]:
#   > Later today, sure.
#   
#   Well here it is, one day later because I really didn't want to do this
#   with printk.  I spent some time looking around and relayfs seems like
#   a good fit.  Do you think relayfs will ever get merged?  Meanwhile...
#   
#   * * * * *
#   
#   This patch, applied to 2.6.9-rc1, adds an I2C/SMBus test stub that is useful
#   for developing sensors drivers.
#   
#   Signed-off-by: Mark M. Hoffman <mhoffman@lightlink.com>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/busses/i2c-stub.c
#   2004/08/26 18:43:10-07:00 mhoffman@lightlink.com +125 -0
#   I2C/SMBus stub for driver testing
# 
# drivers/i2c/busses/i2c-stub.c
#   2004/08/26 18:43:10-07:00 mhoffman@lightlink.com +0 -0
#   BitKeeper file /home/greg/linux/BK/i2c-2.6/drivers/i2c/busses/i2c-stub.c
# 
# drivers/i2c/busses/Makefile
#   2004/08/26 18:44:13-07:00 mhoffman@lightlink.com +1 -0
#   I2C/SMBus stub for driver testing
# 
# drivers/i2c/busses/Kconfig
#   2004/08/26 19:00:48-07:00 mhoffman@lightlink.com +13 -0
#   I2C/SMBus stub for driver testing
# 
# Documentation/i2c/i2c-stub
#   2004/08/26 19:29:43-07:00 mhoffman@lightlink.com +33 -0
#   I2C/SMBus stub for driver testing
# 
# Documentation/i2c/i2c-stub
#   2004/08/26 19:29:43-07:00 mhoffman@lightlink.com +0 -0
#   BitKeeper file /home/greg/linux/BK/i2c-2.6/Documentation/i2c/i2c-stub
# 
# ChangeSet
#   2004/09/08 12:34:06-07:00 castet.matthieu@free.fr 
#   [PATCH] use of MODULE_DEVICE_TABLE in i2c busses driver
#   
#   hello,
#   since you say your are interested of using MODULE_DEVICE_TABLE in
#   http://bugzilla.kernel.org/show_bug.cgi?id=3091 I did a patch (attach).
#   
#   Also I notice that some pci_device_id are marked __devinitdata that seem a bug
#   if I read Linux 2.6.0-test3 changelog.
#   To find them do a "grep pci_device_id  /usr/src/linux/drivers/i2c/busses/* |
#   grep __devinitdata"
#   
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/busses/i2c-voodoo3.c
#   2004/08/29 14:22:46-07:00 castet.matthieu@free.fr +2 -0
#   use of MODULE_DEVICE_TABLE in i2c busses driver
# 
# drivers/i2c/busses/i2c-viapro.c
#   2004/08/29 14:22:37-07:00 castet.matthieu@free.fr +2 -0
#   use of MODULE_DEVICE_TABLE in i2c busses driver
# 
# drivers/i2c/busses/i2c-via.c
#   2004/08/29 14:22:22-07:00 castet.matthieu@free.fr +2 -0
#   use of MODULE_DEVICE_TABLE in i2c busses driver
# 
# drivers/i2c/busses/i2c-sis96x.c
#   2004/08/29 14:22:10-07:00 castet.matthieu@free.fr +2 -0
#   use of MODULE_DEVICE_TABLE in i2c busses driver
# 
# drivers/i2c/busses/i2c-sis630.c
#   2004/08/29 14:21:59-07:00 castet.matthieu@free.fr +2 -0
#   use of MODULE_DEVICE_TABLE in i2c busses driver
# 
# drivers/i2c/busses/i2c-sis5595.c
#   2004/08/29 14:21:49-07:00 castet.matthieu@free.fr +2 -0
#   use of MODULE_DEVICE_TABLE in i2c busses driver
# 
# drivers/i2c/busses/i2c-savage4.c
#   2004/08/29 14:21:41-07:00 castet.matthieu@free.fr +2 -0
#   use of MODULE_DEVICE_TABLE in i2c busses driver
# 
# drivers/i2c/busses/i2c-prosavage.c
#   2004/08/29 14:21:33-07:00 castet.matthieu@free.fr +2 -0
#   use of MODULE_DEVICE_TABLE in i2c busses driver
# 
# drivers/i2c/busses/i2c-piix4.c
#   2004/08/29 14:21:21-07:00 castet.matthieu@free.fr +2 -0
#   use of MODULE_DEVICE_TABLE in i2c busses driver
# 
# drivers/i2c/busses/i2c-nforce2.c
#   2004/08/29 14:21:06-07:00 castet.matthieu@free.fr +3 -0
#   use of MODULE_DEVICE_TABLE in i2c busses driver
# 
# drivers/i2c/busses/i2c-i810.c
#   2004/08/29 14:20:48-07:00 castet.matthieu@free.fr +2 -0
#   use of MODULE_DEVICE_TABLE in i2c busses driver
# 
# drivers/i2c/busses/i2c-i801.c
#   2004/08/29 14:20:40-07:00 castet.matthieu@free.fr +2 -0
#   use of MODULE_DEVICE_TABLE in i2c busses driver
# 
# drivers/i2c/busses/i2c-hydra.c
#   2004/08/29 14:20:28-07:00 castet.matthieu@free.fr +2 -0
#   use of MODULE_DEVICE_TABLE in i2c busses driver
# 
# drivers/i2c/busses/i2c-amd8111.c
#   2004/08/29 14:20:17-07:00 castet.matthieu@free.fr +2 -0
#   use of MODULE_DEVICE_TABLE in i2c busses driver
# 
# drivers/i2c/busses/i2c-amd756.c
#   2004/08/29 14:20:07-07:00 castet.matthieu@free.fr +2 -0
#   use of MODULE_DEVICE_TABLE in i2c busses driver
# 
# drivers/i2c/busses/i2c-ali15x3.c
#   2004/08/29 14:19:57-07:00 castet.matthieu@free.fr +2 -0
#   use of MODULE_DEVICE_TABLE in i2c busses driver
# 
# drivers/i2c/busses/i2c-ali1563.c
#   2004/08/29 14:19:43-07:00 castet.matthieu@free.fr +2 -0
#   use of MODULE_DEVICE_TABLE in i2c busses driver
# 
# drivers/i2c/busses/i2c-ali1535.c
#   2004/08/29 14:19:26-07:00 castet.matthieu@free.fr +2 -0
#   use of MODULE_DEVICE_TABLE in i2c busses driver
# 
# ChangeSet
#   2004/09/08 12:33:40-07:00 nacc@us.ibm.com 
#   [PATCH] i2c-algo-ite: remove iic_sleep()
#   
#   Removes unused function iic_sleep().
#   
#   Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/algos/i2c-algo-ite.c
#   2004/09/01 15:10:04-07:00 nacc@us.ibm.com +0 -8
#   i2c-algo-ite: remove iic_sleep()
# 
diff -Nru a/Documentation/i2c/i2c-stub b/Documentation/i2c/i2c-stub
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/Documentation/i2c/i2c-stub	2004-10-10 22:31:04 -07:00
@@ -0,0 +1,33 @@
+MODULE: i2c-stub
+
+DESCRIPTION:
+
+This module is a very simple fake I2C/SMBus driver.  It implements three
+types of SMBus commands: write quick, (r/w) byte data, and (r/w) word data.
+
+No hardware is needed nor associated with this module.  It will accept write
+quick commands to all addresses; it will respond to the other commands (also
+to all addresses) by reading from or writing to an array in memory.  It will
+also spam the kernel logs for every command it handles.
+
+The typical use-case is like this:
+	1. load this module
+	2. use i2cset (from lm_sensors project) to pre-load some data
+	3. load the target sensors chip driver module
+	4. observe its behavior in the kernel log
+
+CAVEATS:
+
+There are independent arrays for byte/data and word/data commands.  Depending
+on if/how a target driver mixes them, you'll need to be careful.
+
+If your target driver polls some byte or word waiting for it to change, the
+stub could lock it up.  Use i2cset to unlock it.
+
+If the hardware for your driver has banked registers (e.g. Winbond sensors
+chips) this module will not work well - although it could be extended to
+support that pretty easily.
+
+If you spam it hard enough, printk can be lossy.  This module really wants
+something like relayfs.
+
diff -Nru a/Documentation/i2c/sysfs-interface b/Documentation/i2c/sysfs-interface
--- a/Documentation/i2c/sysfs-interface	2004-10-10 22:31:03 -07:00
+++ b/Documentation/i2c/sysfs-interface	2004-10-10 22:31:03 -07:00
@@ -135,12 +135,15 @@
 		Note that this is actually an internal clock divisor, which
 		affects the measurable speed range, not the read value.
 
-fan[1-3]_pwm	Pulse width modulation fan control.
+*******
+* PWM *
+*******
+pwm[1-3]	Pulse width modulation fan control.
 		Integer value in the range 0 to 255
 		Read/Write
 		255 is max or 100%.
 
-fan[1-3]_pwm_enable
+pwm[1-3]_enable
 		Switch PWM on and off.
 		Not always present even if fan*_pwm is.
 		0 to turn off
diff -Nru a/Documentation/i2c/writing-clients b/Documentation/i2c/writing-clients
--- a/Documentation/i2c/writing-clients	2004-10-10 22:31:03 -07:00
+++ b/Documentation/i2c/writing-clients	2004-10-10 22:31:03 -07:00
@@ -24,22 +24,24 @@
 routines, a client structure specific information like the actual I2C
 address.
 
-  static struct i2c_driver foo_driver = {
-    .owner          = THIS_MODULE,
-    .name           = "Foo version 2.3 driver",
-    .id             = I2C_DRIVERID_FOO, /* usually from i2c-id.h */
-    .flags          = I2C_DF_NOTIFY,
-    .attach_adapter = &foo_attach_adapter,
-    .detach_client  = &foo_detach_client,
-    .command        = &foo_command /* may be NULL */
-  }
+static struct i2c_driver foo_driver = {
+	.owner		= THIS_MODULE,
+	.name		= "Foo version 2.3 driver",
+	.id		= I2C_DRIVERID_FOO, /* from i2c-id.h, optional */
+	.flags		= I2C_DF_NOTIFY,
+	.attach_adapter	= &foo_attach_adapter,
+	.detach_client	= &foo_detach_client,
+	.command	= &foo_command /* may be NULL */
+}
  
 The name can be chosen freely, and may be upto 40 characters long. Please
 use something descriptive here.
 
-The id should be a unique ID. The range 0xf000 to 0xffff is reserved for
-local use, and you can use one of those until you start distributing the
-driver. Before you do that, contact the i2c authors to get your own ID(s).
+If used, the id should be a unique ID. The range 0xf000 to 0xffff is
+reserved for local use, and you can use one of those until you start
+distributing the driver, at which time you should contact the i2c authors
+to get your own ID(s). Note that most of the time you don't need an ID
+at all so you can just omit it.
 
 Don't worry about the flags field; just put I2C_DF_NOTIFY into it. This
 means that your driver will be notified when new adapters are found.
diff -Nru a/drivers/i2c/algos/i2c-algo-ite.c b/drivers/i2c/algos/i2c-algo-ite.c
--- a/drivers/i2c/algos/i2c-algo-ite.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/algos/i2c-algo-ite.c	2004-10-10 22:31:04 -07:00
@@ -107,14 +107,6 @@
 	return(timeout<=0);
 }
 
-/*
- * Puts this process to sleep for a period equal to timeout 
- */
-static inline void iic_sleep(unsigned long timeout)
-{
-	schedule_timeout( timeout * HZ);
-}
-
 /* After we issue a transaction on the IIC bus, this function
  * is called.  It puts this process to sleep until we get an interrupt from
  * from the controller telling us that the transaction we requested in complete.
diff -Nru a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
--- a/drivers/i2c/busses/Kconfig	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/busses/Kconfig	2004-10-10 22:31:04 -07:00
@@ -376,6 +376,19 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-sis96x.
 
+config I2C_STUB
+	tristate "I2C/SMBus Test Stub"
+	depends on I2C && EXPERIMENTAL && 'm'
+	default 'n'
+	help
+	  This module may be useful to developers of SMBus client drivers,
+	  especially for certain kinds of sensor chips.
+
+	  If you do build this module, be sure to read the notes and warnings
+	  in Documentation/i2c/i2c-stub.
+
+	  If you don't know what to do here, definitely say N.
+
 config I2C_VIA
 	tristate "VIA 82C586B"
 	depends on I2C && PCI && EXPERIMENTAL
diff -Nru a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
--- a/drivers/i2c/busses/Makefile	2004-10-10 22:31:03 -07:00
+++ b/drivers/i2c/busses/Makefile	2004-10-10 22:31:03 -07:00
@@ -30,6 +30,7 @@
 obj-$(CONFIG_I2C_SIS5595)	+= i2c-sis5595.o
 obj-$(CONFIG_I2C_SIS630)	+= i2c-sis630.o
 obj-$(CONFIG_I2C_SIS96X)	+= i2c-sis96x.o
+obj-$(CONFIG_I2C_STUB)		+= i2c-stub.o
 obj-$(CONFIG_I2C_VIA)		+= i2c-via.o
 obj-$(CONFIG_I2C_VIAPRO)	+= i2c-viapro.o
 obj-$(CONFIG_I2C_VOODOO3)	+= i2c-voodoo3.o
diff -Nru a/drivers/i2c/busses/i2c-ali1535.c b/drivers/i2c/busses/i2c-ali1535.c
--- a/drivers/i2c/busses/i2c-ali1535.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/busses/i2c-ali1535.c	2004-10-10 22:31:04 -07:00
@@ -496,6 +496,8 @@
 	{ },
 };
 
+MODULE_DEVICE_TABLE (pci, ali1535_ids);
+
 static int __devinit ali1535_probe(struct pci_dev *dev, const struct pci_device_id *id)
 {
 	if (ali1535_setup(dev)) {
diff -Nru a/drivers/i2c/busses/i2c-ali1563.c b/drivers/i2c/busses/i2c-ali1563.c
--- a/drivers/i2c/busses/i2c-ali1563.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/busses/i2c-ali1563.c	2004-10-10 22:31:04 -07:00
@@ -394,6 +394,8 @@
 	{},
 };
 
+MODULE_DEVICE_TABLE (pci, ali1563_id_table);
+
 static struct pci_driver ali1563_pci_driver = {
  	.name		= "ali1563_i2c",
 	.id_table	= ali1563_id_table,
diff -Nru a/drivers/i2c/busses/i2c-ali15x3.c b/drivers/i2c/busses/i2c-ali15x3.c
--- a/drivers/i2c/busses/i2c-ali15x3.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/busses/i2c-ali15x3.c	2004-10-10 22:31:04 -07:00
@@ -486,6 +486,8 @@
 	{ 0, }
 };
 
+MODULE_DEVICE_TABLE (pci, ali15x3_ids);
+
 static int __devinit ali15x3_probe(struct pci_dev *dev, const struct pci_device_id *id)
 {
 	if (ali15x3_setup(dev)) {
diff -Nru a/drivers/i2c/busses/i2c-amd756.c b/drivers/i2c/busses/i2c-amd756.c
--- a/drivers/i2c/busses/i2c-amd756.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/busses/i2c-amd756.c	2004-10-10 22:31:04 -07:00
@@ -320,6 +320,8 @@
 	{ 0, }
 };
 
+MODULE_DEVICE_TABLE (pci, amd756_ids);
+
 static int __devinit amd756_probe(struct pci_dev *pdev,
 				  const struct pci_device_id *id)
 {
diff -Nru a/drivers/i2c/busses/i2c-amd8111.c b/drivers/i2c/busses/i2c-amd8111.c
--- a/drivers/i2c/busses/i2c-amd8111.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/busses/i2c-amd8111.c	2004-10-10 22:31:04 -07:00
@@ -336,6 +336,8 @@
 	{ 0, }
 };
 
+MODULE_DEVICE_TABLE (pci, amd8111_ids);
+
 static int __devinit amd8111_probe(struct pci_dev *dev, const struct pci_device_id *id)
 {
 	struct amd_smbus *smbus;
diff -Nru a/drivers/i2c/busses/i2c-elektor.c b/drivers/i2c/busses/i2c-elektor.c
--- a/drivers/i2c/busses/i2c-elektor.c	2004-10-10 22:31:03 -07:00
+++ b/drivers/i2c/busses/i2c-elektor.c	2004-10-10 22:31:03 -07:00
@@ -180,11 +180,10 @@
 	/* check to see we have memory mapped PCF8584 connected to the 
 	Cypress cy82c693 PCI-ISA bridge as on UP2000 board */
 	if (base == 0) {
+		struct pci_dev *cy693_dev;
 		
-		struct pci_dev *cy693_dev =
-                    pci_find_device(PCI_VENDOR_ID_CONTAQ, 
-		                    PCI_DEVICE_ID_CONTAQ_82C693, NULL);
-
+		cy693_dev = pci_get_device(PCI_VENDOR_ID_CONTAQ, 
+					   PCI_DEVICE_ID_CONTAQ_82C693, NULL);
 		if (cy693_dev) {
 			char config;
 			/* yeap, we've found cypress, let's check config */
@@ -215,6 +214,7 @@
 					printk(KERN_INFO "i2c-elektor: found API UP2000 like board, will probe PCF8584 later.\n");
 				}
 			}
+			pci_dev_put(cy693_dev);
 		}
 	}
 #endif
diff -Nru a/drivers/i2c/busses/i2c-hydra.c b/drivers/i2c/busses/i2c-hydra.c
--- a/drivers/i2c/busses/i2c-hydra.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/busses/i2c-hydra.c	2004-10-10 22:31:04 -07:00
@@ -120,6 +120,8 @@
 	{ 0, }
 };
 
+MODULE_DEVICE_TABLE (pci, hydra_ids);
+
 static int __devinit hydra_probe(struct pci_dev *dev,
 				 const struct pci_device_id *id)
 {
diff -Nru a/drivers/i2c/busses/i2c-i801.c b/drivers/i2c/busses/i2c-i801.c
--- a/drivers/i2c/busses/i2c-i801.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/busses/i2c-i801.c	2004-10-10 22:31:04 -07:00
@@ -599,6 +599,8 @@
 	{ 0, }
 };
 
+MODULE_DEVICE_TABLE (pci, i801_ids);
+
 static int __devinit i801_probe(struct pci_dev *dev, const struct pci_device_id *id)
 {
 
diff -Nru a/drivers/i2c/busses/i2c-i810.c b/drivers/i2c/busses/i2c-i810.c
--- a/drivers/i2c/busses/i2c-i810.c	2004-10-10 22:31:03 -07:00
+++ b/drivers/i2c/busses/i2c-i810.c	2004-10-10 22:31:03 -07:00
@@ -70,7 +70,7 @@
 #define CYCLE_DELAY		10
 #define TIMEOUT			(HZ / 2)
 
-static void *ioaddr;
+static void __iomem *ioaddr;
 
 /* The i810 GPIO registers have individual masks for each bit
    so we never have to read before writing. Nice. */
@@ -200,6 +200,8 @@
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82845G_IG) },
 	{ 0, },
 };
+
+MODULE_DEVICE_TABLE (pci, i810_ids);
 
 static int __devinit i810_probe(struct pci_dev *dev, const struct pci_device_id *id)
 {
diff -Nru a/drivers/i2c/busses/i2c-mpc.c b/drivers/i2c/busses/i2c-mpc.c
--- a/drivers/i2c/busses/i2c-mpc.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/busses/i2c-mpc.c	2004-10-10 22:31:04 -07:00
@@ -23,6 +23,7 @@
 #include <asm/ocp.h>
 #include <linux/i2c.h>
 #include <linux/interrupt.h>
+#include <linux/delay.h>
 
 #define MPC_I2C_ADDR  0x00
 #define MPC_I2C_FDR 	0x04
@@ -91,9 +92,9 @@
 		x = readb(i2c->base + MPC_I2C_SR);
 		writeb(0, i2c->base + MPC_I2C_SR);
 	} else {
+		set_current_state(TASK_INTERRUPTIBLE);
 		add_wait_queue(&i2c->queue, &wait);
 		while (!(i2c->interrupt & CSR_MIF)) {
-			set_current_state(TASK_INTERRUPTIBLE);
 			if (signal_pending(current)) {
 				pr_debug("I2C: Interrupted\n");
 				result = -EINTR;
@@ -104,9 +105,9 @@
 				result = -EIO;
 				break;
 			}
-			schedule_timeout(timeout);
+			msleep_interruptible(jiffies_to_msecs(timeout));
 		}
-		current->state = TASK_RUNNING;
+		set_current_state(TASK_RUNNING);
 		remove_wait_queue(&i2c->queue, &wait);
 		x = i2c->interrupt;
 		i2c->interrupt = 0;
diff -Nru a/drivers/i2c/busses/i2c-nforce2.c b/drivers/i2c/busses/i2c-nforce2.c
--- a/drivers/i2c/busses/i2c-nforce2.c	2004-10-10 22:31:03 -07:00
+++ b/drivers/i2c/busses/i2c-nforce2.c	2004-10-10 22:31:03 -07:00
@@ -298,6 +298,9 @@
 };
 
 
+MODULE_DEVICE_TABLE (pci, nforce2_ids);
+
+
 static int __devinit nforce2_probe_smb (struct pci_dev *dev, int reg,
 	struct nforce2_smbus *smbus, char *name)
 {
diff -Nru a/drivers/i2c/busses/i2c-piix4.c b/drivers/i2c/busses/i2c-piix4.c
--- a/drivers/i2c/busses/i2c-piix4.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/busses/i2c-piix4.c	2004-10-10 22:31:04 -07:00
@@ -459,6 +459,8 @@
 	{ 0, }
 };
 
+MODULE_DEVICE_TABLE (pci, piix4_ids);
+
 static int __devinit piix4_probe(struct pci_dev *dev,
 				const struct pci_device_id *id)
 {
diff -Nru a/drivers/i2c/busses/i2c-prosavage.c b/drivers/i2c/busses/i2c-prosavage.c
--- a/drivers/i2c/busses/i2c-prosavage.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/busses/i2c-prosavage.c	2004-10-10 22:31:04 -07:00
@@ -68,7 +68,7 @@
 #define MAX_BUSSES	2
 
 struct s_i2c_bus {
-	void	*mmvga;
+	void __iomem *mmvga;
 	int	i2c_reg;
 	int	adap_ok;
 	struct i2c_adapter		adap;
@@ -76,7 +76,7 @@
 };
 
 struct s_i2c_chip {
-	void	*mmio;
+	void __iomem *mmio;
 	struct s_i2c_bus	i2c_bus[MAX_BUSSES];
 };
 
@@ -181,7 +181,7 @@
 /*
  * adapter initialisation
  */
-static int i2c_register_bus(struct pci_dev *dev, struct s_i2c_bus *p, u8 *mmvga, u32 i2c_reg)
+static int i2c_register_bus(struct pci_dev *dev, struct s_i2c_bus *p, void __iomem *mmvga, u32 i2c_reg)
 {
 	int ret;
 	p->adap.owner	  = THIS_MODULE;
@@ -312,6 +312,8 @@
 	{ PCI_DEVICE(PCI_VENDOR_ID_S3, PCI_DEVICE_ID_S3_PROSAVAGE8) },
 	{ 0, },
 };
+
+MODULE_DEVICE_TABLE (pci, prosavage_pci_tbl);
 
 static struct pci_driver prosavage_driver = {
 	.name		=	"prosavage_smbus",
diff -Nru a/drivers/i2c/busses/i2c-savage4.c b/drivers/i2c/busses/i2c-savage4.c
--- a/drivers/i2c/busses/i2c-savage4.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/busses/i2c-savage4.c	2004-10-10 22:31:04 -07:00
@@ -73,7 +73,7 @@
 #define TIMEOUT			(HZ / 2)
 
 
-static void *ioaddr;
+static void __iomem *ioaddr;
 
 /* The sav GPIO registers don't have individual masks for each bit
    so we always have to read before writing. */
@@ -156,6 +156,8 @@
 	{ PCI_DEVICE(PCI_VENDOR_ID_S3, PCI_CHIP_SAVAGE2000) },
 	{ 0, }
 };
+
+MODULE_DEVICE_TABLE (pci, savage4_ids);
 
 static int __devinit savage4_probe(struct pci_dev *dev, const struct pci_device_id *id)
 {
diff -Nru a/drivers/i2c/busses/i2c-sis5595.c b/drivers/i2c/busses/i2c-sis5595.c
--- a/drivers/i2c/busses/i2c-sis5595.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/busses/i2c-sis5595.c	2004-10-10 22:31:04 -07:00
@@ -371,6 +371,8 @@
 	{ 0, }
 };
 
+MODULE_DEVICE_TABLE (pci, sis5595_ids);
+
 static int __devinit sis5595_probe(struct pci_dev *dev, const struct pci_device_id *id)
 {
 	if (sis5595_setup(dev)) {
diff -Nru a/drivers/i2c/busses/i2c-sis630.c b/drivers/i2c/busses/i2c-sis630.c
--- a/drivers/i2c/busses/i2c-sis630.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/busses/i2c-sis630.c	2004-10-10 22:31:04 -07:00
@@ -468,6 +468,8 @@
 	{ 0, }
 };
 
+MODULE_DEVICE_TABLE (pci, sis630_ids);
+
 static int __devinit sis630_probe(struct pci_dev *dev, const struct pci_device_id *id)
 {
 	if (sis630_setup(dev)) {
diff -Nru a/drivers/i2c/busses/i2c-sis96x.c b/drivers/i2c/busses/i2c-sis96x.c
--- a/drivers/i2c/busses/i2c-sis96x.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/busses/i2c-sis96x.c	2004-10-10 22:31:04 -07:00
@@ -278,6 +278,8 @@
 	{ 0, }
 };
 
+MODULE_DEVICE_TABLE (pci, sis96x_ids);
+
 static int __devinit sis96x_probe(struct pci_dev *dev,
 				const struct pci_device_id *id)
 {
diff -Nru a/drivers/i2c/busses/i2c-stub.c b/drivers/i2c/busses/i2c-stub.c
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/drivers/i2c/busses/i2c-stub.c	2004-10-10 22:31:04 -07:00
@@ -0,0 +1,125 @@
+/*
+    i2c-stub.c - Part of lm_sensors, Linux kernel modules for hardware
+              monitoring
+
+    Copyright (c) 2004 Mark M. Hoffman <mhoffman@lightlink.com>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#define DEBUG 1
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/i2c.h>
+
+static u8  stub_bytes[256];
+static u16 stub_words[256];
+
+/* Return -1 on error. */
+static s32 stub_xfer(struct i2c_adapter * adap, u16 addr, unsigned short flags,
+	char read_write, u8 command, int size, union i2c_smbus_data * data)
+{
+	s32 ret;
+
+	switch (size) {
+
+	case I2C_SMBUS_QUICK:
+		dev_dbg(&adap->dev, "smbus quick - addr 0x%02x\n", addr);
+		ret = 0;
+		break;
+
+	case I2C_SMBUS_BYTE_DATA:
+		if (read_write == I2C_SMBUS_WRITE) {
+			stub_bytes[command] = data->byte;
+			dev_dbg(&adap->dev, "smbus byte data - addr 0x%02x, "
+					"wrote 0x%02x at 0x%02x.\n",
+					addr, data->byte, command);
+		} else {
+			data->byte = stub_bytes[command];
+			dev_dbg(&adap->dev, "smbus byte data - addr 0x%02x, "
+					"read  0x%02x at 0x%02x.\n",
+					addr, data->byte, command);
+		}
+
+		ret = 0;
+		break;
+
+	case I2C_SMBUS_WORD_DATA:
+		if (read_write == I2C_SMBUS_WRITE) {
+			stub_words[command] = data->word;
+			dev_dbg(&adap->dev, "smbus word data - addr 0x%02x, "
+					"wrote 0x%04x at 0x%02x.\n",
+					addr, data->word, command);
+		} else {
+			data->word = stub_words[command];
+			dev_dbg(&adap->dev, "smbus word data - addr 0x%02x, "
+					"read  0x%04x at 0x%02x.\n",
+					addr, data->word, command);
+		}
+
+		ret = 0;
+		break;
+
+	default:
+		dev_dbg(&adap->dev, "Unsupported I2C/SMBus command\n");
+		ret = -1;
+		break;
+	} /* switch (size) */
+
+	return ret;
+}
+
+static u32 stub_func(struct i2c_adapter *adapter)
+{
+	return I2C_FUNC_SMBUS_QUICK | I2C_FUNC_SMBUS_BYTE_DATA |
+		I2C_FUNC_SMBUS_WORD_DATA;
+}
+
+static struct i2c_algorithm smbus_algorithm = {
+	.name		= "Non-I2C SMBus adapter",
+	.id		= I2C_ALGO_SMBUS,
+	.functionality	= stub_func,
+	.smbus_xfer	= stub_xfer,
+};
+
+static struct i2c_adapter stub_adapter = {
+	.owner		= THIS_MODULE,
+	.class		= I2C_CLASS_HWMON,
+	.algo		= &smbus_algorithm,
+	.name		= "SMBus stub driver",
+};
+
+static int __init i2c_stub_init(void)
+{
+	printk(KERN_INFO "i2c-stub loaded\n");
+	return i2c_add_adapter(&stub_adapter);
+}
+
+static void __exit i2c_stub_exit(void)
+{
+	i2c_del_adapter(&stub_adapter);
+}
+
+MODULE_AUTHOR("Mark M. Hoffman <mhoffman@lightlink.com>");
+MODULE_DESCRIPTION("I2C stub driver");
+MODULE_LICENSE("GPL");
+
+module_init(i2c_stub_init);
+module_exit(i2c_stub_exit);
+
diff -Nru a/drivers/i2c/busses/i2c-via.c b/drivers/i2c/busses/i2c-via.c
--- a/drivers/i2c/busses/i2c-via.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/busses/i2c-via.c	2004-10-10 22:31:04 -07:00
@@ -99,6 +99,8 @@
 	{ 0, }
 };
 
+MODULE_DEVICE_TABLE (pci, vt586b_ids);
+
 static int __devinit vt586b_probe(struct pci_dev *dev, const struct pci_device_id *id)
 {
 	u16 base;
diff -Nru a/drivers/i2c/busses/i2c-viapro.c b/drivers/i2c/busses/i2c-viapro.c
--- a/drivers/i2c/busses/i2c-viapro.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/busses/i2c-viapro.c	2004-10-10 22:31:04 -07:00
@@ -454,6 +454,8 @@
 	{ 0, }
 };
 
+MODULE_DEVICE_TABLE (pci, vt596_ids);
+
 static struct pci_driver vt596_driver = {
 	.name		= "vt596_smbus",
 	.id_table	= vt596_ids,
diff -Nru a/drivers/i2c/busses/i2c-voodoo3.c b/drivers/i2c/busses/i2c-voodoo3.c
--- a/drivers/i2c/busses/i2c-voodoo3.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/busses/i2c-voodoo3.c	2004-10-10 22:31:04 -07:00
@@ -61,7 +61,7 @@
 #define TIMEOUT		(HZ / 2)
 
 
-static void *ioaddr;
+static void __iomem *ioaddr;
 
 /* The voo GPIO registers don't have individual masks for each bit
    so we always have to read before writing. */
@@ -194,6 +194,8 @@
 	{ PCI_DEVICE(PCI_VENDOR_ID_3DFX, PCI_DEVICE_ID_3DFX_BANSHEE) },
 	{ 0, }
 };
+
+MODULE_DEVICE_TABLE (pci, voodoo3_ids);
 
 static int __devinit voodoo3_probe(struct pci_dev *dev, const struct pci_device_id *id)
 {
diff -Nru a/drivers/i2c/busses/scx200_acb.c b/drivers/i2c/busses/scx200_acb.c
--- a/drivers/i2c/busses/scx200_acb.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/busses/scx200_acb.c	2004-10-10 22:31:04 -07:00
@@ -503,6 +503,12 @@
 	return rc;
 }
 
+static struct pci_device_id scx200[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_NS, PCI_DEVICE_ID_NS_SCx200_BRIDGE) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_NS, PCI_DEVICE_ID_NS_SC1100_BRIDGE) },
+	{ },
+};
+
 static int __init scx200_acb_init(void)
 {
 	int i;
@@ -511,12 +517,7 @@
 	pr_debug(NAME ": NatSemi SCx200 ACCESS.bus Driver\n");
 
 	/* Verify that this really is a SCx200 processor */
-	if (pci_find_device(PCI_VENDOR_ID_NS,
-			    PCI_DEVICE_ID_NS_SCx200_BRIDGE,
-			    NULL) == NULL
-	    && pci_find_device(PCI_VENDOR_ID_NS,
-			       PCI_DEVICE_ID_NS_SC1100_BRIDGE,
-			       NULL) == NULL)
+	if (pci_dev_present(scx200) == 0)
 		return -ENODEV;
 
 	rc = -ENXIO;
diff -Nru a/drivers/i2c/chips/adm1021.c b/drivers/i2c/chips/adm1021.c
--- a/drivers/i2c/chips/adm1021.c	2004-10-10 22:31:03 -07:00
+++ b/drivers/i2c/chips/adm1021.c	2004-10-10 22:31:03 -07:00
@@ -148,7 +148,7 @@
 	.detach_client	= adm1021_detach_client,
 };
 
-static int adm1021_id = 0;
+static int adm1021_id;
 
 #define show(value)	\
 static ssize_t show_##value(struct device *dev, char *buf)		\
diff -Nru a/drivers/i2c/chips/adm1025.c b/drivers/i2c/chips/adm1025.c
--- a/drivers/i2c/chips/adm1025.c	2004-10-10 22:31:03 -07:00
+++ b/drivers/i2c/chips/adm1025.c	2004-10-10 22:31:03 -07:00
@@ -153,7 +153,7 @@
  * Internal variables
  */
 
-static int adm1025_id = 0;
+static int adm1025_id;
 
 /*
  * Sysfs stuff
@@ -212,8 +212,8 @@
 { \
 	struct i2c_client *client = to_i2c_client(dev); \
 	struct adm1025_data *data = i2c_get_clientdata(client); \
-	data->in_min[offset] = IN_TO_REG(simple_strtol(buf, NULL, 10), \
-			       in_scale[offset]); \
+	long val = simple_strtol(buf, NULL, 10); \
+	data->in_min[offset] = IN_TO_REG(val, in_scale[offset]); \
 	i2c_smbus_write_byte_data(client, ADM1025_REG_IN_MIN(offset), \
 				  data->in_min[offset]); \
 	return count; \
@@ -223,8 +223,8 @@
 { \
 	struct i2c_client *client = to_i2c_client(dev); \
 	struct adm1025_data *data = i2c_get_clientdata(client); \
-	data->in_max[offset] = IN_TO_REG(simple_strtol(buf, NULL, 10), \
-			       in_scale[offset]); \
+	long val = simple_strtol(buf, NULL, 10); \
+	data->in_max[offset] = IN_TO_REG(val, in_scale[offset]); \
 	i2c_smbus_write_byte_data(client, ADM1025_REG_IN_MAX(offset), \
 				  data->in_max[offset]); \
 	return count; \
@@ -246,7 +246,8 @@
 { \
 	struct i2c_client *client = to_i2c_client(dev); \
 	struct adm1025_data *data = i2c_get_clientdata(client); \
-	data->temp_min[offset-1] = TEMP_TO_REG(simple_strtol(buf, NULL, 10)); \
+	long val = simple_strtol(buf, NULL, 10); \
+	data->temp_min[offset-1] = TEMP_TO_REG(val); \
 	i2c_smbus_write_byte_data(client, ADM1025_REG_TEMP_LOW(offset-1), \
 				  data->temp_min[offset-1]); \
 	return count; \
@@ -256,7 +257,8 @@
 { \
 	struct i2c_client *client = to_i2c_client(dev); \
 	struct adm1025_data *data = i2c_get_clientdata(client); \
-	data->temp_max[offset-1] = TEMP_TO_REG(simple_strtol(buf, NULL, 10)); \
+	long val = simple_strtol(buf, NULL, 10); \
+	data->temp_max[offset-1] = TEMP_TO_REG(val); \
 	i2c_smbus_write_byte_data(client, ADM1025_REG_TEMP_HIGH(offset-1), \
 				  data->temp_max[offset-1]); \
 	return count; \
diff -Nru a/drivers/i2c/chips/adm1031.c b/drivers/i2c/chips/adm1031.c
--- a/drivers/i2c/chips/adm1031.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/chips/adm1031.c	2004-10-10 22:31:04 -07:00
@@ -298,12 +298,12 @@
 #define fan_auto_channel_offset(offset)						\
 static ssize_t show_fan_auto_channel_##offset (struct device *dev, char *buf)	\
 {										\
-	return show_fan_auto_channel(dev, buf, 0x##offset - 1);			\
+	return show_fan_auto_channel(dev, buf, offset - 1);			\
 }										\
 static ssize_t set_fan_auto_channel_##offset (struct device *dev,		\
 	const char *buf, size_t count)						\
 {										\
-	return set_fan_auto_channel(dev, buf, count, 0x##offset - 1);		\
+	return set_fan_auto_channel(dev, buf, count, offset - 1);		\
 }										\
 static DEVICE_ATTR(auto_fan##offset##_channel, S_IRUGO | S_IWUSR,		\
 		   show_fan_auto_channel_##offset,				\
@@ -365,25 +365,25 @@
 #define auto_temp_reg(offset)							\
 static ssize_t show_auto_temp_##offset##_off (struct device *dev, char *buf)	\
 {										\
-	return show_auto_temp_off(dev, buf, 0x##offset - 1);			\
+	return show_auto_temp_off(dev, buf, offset - 1);			\
 }										\
 static ssize_t show_auto_temp_##offset##_min (struct device *dev, char *buf)	\
 {										\
-	return show_auto_temp_min(dev, buf, 0x##offset - 1);			\
+	return show_auto_temp_min(dev, buf, offset - 1);			\
 }										\
 static ssize_t show_auto_temp_##offset##_max (struct device *dev, char *buf)	\
 {										\
-	return show_auto_temp_max(dev, buf, 0x##offset - 1);			\
+	return show_auto_temp_max(dev, buf, offset - 1);			\
 }										\
 static ssize_t set_auto_temp_##offset##_min (struct device *dev,		\
 					     const char *buf, size_t count)	\
 {										\
-	return set_auto_temp_min(dev, buf, count, 0x##offset - 1);		\
+	return set_auto_temp_min(dev, buf, count, offset - 1);		\
 }										\
 static ssize_t set_auto_temp_##offset##_max (struct device *dev,		\
 					     const char *buf, size_t count)	\
 {										\
-	return set_auto_temp_max(dev, buf, count, 0x##offset - 1);		\
+	return set_auto_temp_max(dev, buf, count, offset - 1);		\
 }										\
 static DEVICE_ATTR(auto_temp##offset##_off, S_IRUGO,				\
 		   show_auto_temp_##offset##_off, NULL);			\
@@ -429,14 +429,14 @@
 #define pwm_reg(offset)							\
 static ssize_t show_pwm_##offset (struct device *dev, char *buf)	\
 {									\
-	return show_pwm(dev, buf, 0x##offset - 1);			\
+	return show_pwm(dev, buf, offset - 1);			\
 }									\
 static ssize_t set_pwm_##offset (struct device *dev,			\
 				 const char *buf, size_t count)		\
 {									\
-	return set_pwm(dev, buf, count, 0x##offset - 1);		\
+	return set_pwm(dev, buf, count, offset - 1);		\
 }									\
-static DEVICE_ATTR(fan##offset##_pwm, S_IRUGO | S_IWUSR,		\
+static DEVICE_ATTR(pwm##offset, S_IRUGO | S_IWUSR,			\
 		   show_pwm_##offset, set_pwm_##offset)
 
 pwm_reg(1);
@@ -565,25 +565,25 @@
 #define fan_offset(offset)						\
 static ssize_t show_fan_##offset (struct device *dev, char *buf)	\
 {									\
-	return show_fan(dev, buf, 0x##offset - 1);			\
+	return show_fan(dev, buf, offset - 1);			\
 }									\
 static ssize_t show_fan_##offset##_min (struct device *dev, char *buf)	\
 {									\
-	return show_fan_min(dev, buf, 0x##offset - 1);			\
+	return show_fan_min(dev, buf, offset - 1);			\
 }									\
 static ssize_t show_fan_##offset##_div (struct device *dev, char *buf)	\
 {									\
-	return show_fan_div(dev, buf, 0x##offset - 1);			\
+	return show_fan_div(dev, buf, offset - 1);			\
 }									\
 static ssize_t set_fan_##offset##_min (struct device *dev,		\
 	const char *buf, size_t count)					\
 {									\
-	return set_fan_min(dev, buf, count, 0x##offset - 1);		\
+	return set_fan_min(dev, buf, count, offset - 1);		\
 }									\
 static ssize_t set_fan_##offset##_div (struct device *dev,		\
 	const char *buf, size_t count)					\
 {									\
-	return set_fan_div(dev, buf, count, 0x##offset - 1);		\
+	return set_fan_div(dev, buf, count, offset - 1);		\
 }									\
 static DEVICE_ATTR(fan##offset##_input, S_IRUGO, show_fan_##offset,	\
 		   NULL);						\
@@ -675,34 +675,34 @@
 #define temp_reg(offset)							\
 static ssize_t show_temp_##offset (struct device *dev, char *buf)		\
 {										\
-	return show_temp(dev, buf, 0x##offset - 1);				\
+	return show_temp(dev, buf, offset - 1);				\
 }										\
 static ssize_t show_temp_##offset##_min (struct device *dev, char *buf)		\
 {										\
-	return show_temp_min(dev, buf, 0x##offset - 1);				\
+	return show_temp_min(dev, buf, offset - 1);				\
 }										\
 static ssize_t show_temp_##offset##_max (struct device *dev, char *buf)		\
 {										\
-	return show_temp_max(dev, buf, 0x##offset - 1);				\
+	return show_temp_max(dev, buf, offset - 1);				\
 }										\
 static ssize_t show_temp_##offset##_crit (struct device *dev, char *buf)	\
 {										\
-	return show_temp_crit(dev, buf, 0x##offset - 1);			\
+	return show_temp_crit(dev, buf, offset - 1);			\
 }										\
 static ssize_t set_temp_##offset##_min (struct device *dev,			\
 					const char *buf, size_t count)		\
 {										\
-	return set_temp_min(dev, buf, count, 0x##offset - 1);			\
+	return set_temp_min(dev, buf, count, offset - 1);			\
 }										\
 static ssize_t set_temp_##offset##_max (struct device *dev,			\
 					const char *buf, size_t count)		\
 {										\
-	return set_temp_max(dev, buf, count, 0x##offset - 1);			\
+	return set_temp_max(dev, buf, count, offset - 1);			\
 }										\
 static ssize_t set_temp_##offset##_crit (struct device *dev,			\
 					 const char *buf, size_t count)		\
 {										\
-	return set_temp_crit(dev, buf, count, 0x##offset - 1);			\
+	return set_temp_crit(dev, buf, count, offset - 1);			\
 }										\
 static DEVICE_ATTR(temp##offset##_input, S_IRUGO, show_temp_##offset,		\
 		   NULL);							\
@@ -799,7 +799,7 @@
 	device_create_file(&new_client->dev, &dev_attr_fan1_input);
 	device_create_file(&new_client->dev, &dev_attr_fan1_div);
 	device_create_file(&new_client->dev, &dev_attr_fan1_min);
-	device_create_file(&new_client->dev, &dev_attr_fan1_pwm);
+	device_create_file(&new_client->dev, &dev_attr_pwm1);
 	device_create_file(&new_client->dev, &dev_attr_auto_fan1_channel);
 	device_create_file(&new_client->dev, &dev_attr_temp1_input);
 	device_create_file(&new_client->dev, &dev_attr_temp1_min);
@@ -826,7 +826,7 @@
 		device_create_file(&new_client->dev, &dev_attr_fan2_input);
 		device_create_file(&new_client->dev, &dev_attr_fan2_div);
 		device_create_file(&new_client->dev, &dev_attr_fan2_min);
-		device_create_file(&new_client->dev, &dev_attr_fan2_pwm);
+		device_create_file(&new_client->dev, &dev_attr_pwm2);
 		device_create_file(&new_client->dev,
 				   &dev_attr_auto_fan2_channel);
 		device_create_file(&new_client->dev, &dev_attr_temp3_input);
diff -Nru a/drivers/i2c/chips/asb100.c b/drivers/i2c/chips/asb100.c
--- a/drivers/i2c/chips/asb100.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/chips/asb100.c	2004-10-10 22:31:04 -07:00
@@ -266,29 +266,29 @@
 static ssize_t \
 	show_in##offset (struct device *dev, char *buf) \
 { \
-	return show_in(dev, buf, 0x##offset); \
+	return show_in(dev, buf, offset); \
 } \
 static DEVICE_ATTR(in##offset##_input, S_IRUGO, \
 		show_in##offset, NULL); \
 static ssize_t \
 	show_in##offset##_min (struct device *dev, char *buf) \
 { \
-	return show_in_min(dev, buf, 0x##offset); \
+	return show_in_min(dev, buf, offset); \
 } \
 static ssize_t \
 	show_in##offset##_max (struct device *dev, char *buf) \
 { \
-	return show_in_max(dev, buf, 0x##offset); \
+	return show_in_max(dev, buf, offset); \
 } \
 static ssize_t set_in##offset##_min (struct device *dev, \
 		const char *buf, size_t count) \
 { \
-	return set_in_min(dev, buf, count, 0x##offset); \
+	return set_in_min(dev, buf, count, offset); \
 } \
 static ssize_t set_in##offset##_max (struct device *dev, \
 		const char *buf, size_t count) \
 { \
-	return set_in_max(dev, buf, count, 0x##offset); \
+	return set_in_max(dev, buf, count, offset); \
 } \
 static DEVICE_ATTR(in##offset##_min, S_IRUGO | S_IWUSR, \
 		show_in##offset##_min, set_in##offset##_min); \
@@ -591,12 +591,12 @@
 	return count;
 }
 
-static DEVICE_ATTR(fan1_pwm, S_IRUGO | S_IWUSR, show_pwm1, set_pwm1);
-static DEVICE_ATTR(fan1_pwm_enable, S_IRUGO | S_IWUSR,
+static DEVICE_ATTR(pwm1, S_IRUGO | S_IWUSR, show_pwm1, set_pwm1);
+static DEVICE_ATTR(pwm1_enable, S_IRUGO | S_IWUSR,
 		show_pwm_enable1, set_pwm_enable1);
 #define device_create_file_pwm1(client) do { \
-	device_create_file(&new_client->dev, &dev_attr_fan1_pwm); \
-	device_create_file(&new_client->dev, &dev_attr_fan1_pwm_enable); \
+	device_create_file(&new_client->dev, &dev_attr_pwm1); \
+	device_create_file(&new_client->dev, &dev_attr_pwm1_enable); \
 } while (0)
 
 /* This function is called when:
diff -Nru a/drivers/i2c/chips/ds1621.c b/drivers/i2c/chips/ds1621.c
--- a/drivers/i2c/chips/ds1621.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/chips/ds1621.c	2004-10-10 22:31:04 -07:00
@@ -96,7 +96,7 @@
 	.detach_client	= ds1621_detach_client,
 };
 
-static int ds1621_id = 0;
+static int ds1621_id;
 
 /* All registers are word-sized, except for the configuration register.
    DS1621 uses a high-byte first convention, which is exactly opposite to
diff -Nru a/drivers/i2c/chips/eeprom.c b/drivers/i2c/chips/eeprom.c
--- a/drivers/i2c/chips/eeprom.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/chips/eeprom.c	2004-10-10 22:31:04 -07:00
@@ -86,7 +86,7 @@
 	.detach_client	= eeprom_detach_client,
 };
 
-static int eeprom_id = 0;
+static int eeprom_id;
 
 static void eeprom_update_client(struct i2c_client *client, u8 slice)
 {
diff -Nru a/drivers/i2c/chips/fscher.c b/drivers/i2c/chips/fscher.c
--- a/drivers/i2c/chips/fscher.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/chips/fscher.c	2004-10-10 22:31:04 -07:00
@@ -156,7 +156,7 @@
  * Internal variables
  */
 
-static int fscher_id = 0;
+static int fscher_id;
 
 /*
  * Sysfs stuff
diff -Nru a/drivers/i2c/chips/gl518sm.c b/drivers/i2c/chips/gl518sm.c
--- a/drivers/i2c/chips/gl518sm.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/chips/gl518sm.c	2004-10-10 22:31:04 -07:00
@@ -164,7 +164,7 @@
  * Internal variables
  */
 
-static int gl518_id = 0;
+static int gl518_id;
 
 /*
  * Sysfs stuff
@@ -217,7 +217,8 @@
 {									\
 	struct i2c_client *client = to_i2c_client(dev);			\
 	struct gl518_data *data = i2c_get_clientdata(client);		\
-	data->value = type##_TO_REG(simple_strtol(buf, NULL, 10));	\
+	long val = simple_strtol(buf, NULL, 10);			\
+	data->value = type##_TO_REG(val);				\
 	gl518_write_value(client, reg, data->value);			\
 	return count;							\
 }
@@ -229,7 +230,8 @@
 	struct i2c_client *client = to_i2c_client(dev);			\
 	struct gl518_data *data = i2c_get_clientdata(client);		\
 	int regvalue = gl518_read_value(client, reg);			\
-	data->value = type##_TO_REG(simple_strtoul(buf, NULL, 10));	\
+	unsigned long val = simple_strtoul(buf, NULL, 10);		\
+	data->value = type##_TO_REG(val);				\
 	regvalue = (regvalue & ~mask) | (data->value << shift);		\
 	gl518_write_value(client, reg, regvalue);			\
 	return count;							\
diff -Nru a/drivers/i2c/chips/it87.c b/drivers/i2c/chips/it87.c
--- a/drivers/i2c/chips/it87.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/chips/it87.c	2004-10-10 22:31:04 -07:00
@@ -226,7 +226,7 @@
 	.detach_client	= it87_detach_client,
 };
 
-static int it87_id = 0;
+static int it87_id;
 
 static ssize_t show_in(struct device *dev, char *buf, int nr)
 {
@@ -273,7 +273,7 @@
 static ssize_t							\
 	show_in##offset (struct device *dev, char *buf)		\
 {								\
-	return show_in(dev, buf, 0x##offset);			\
+	return show_in(dev, buf, offset);			\
 }								\
 static DEVICE_ATTR(in##offset##_input, S_IRUGO, show_in##offset, NULL);
 
@@ -281,22 +281,22 @@
 static ssize_t							\
 	show_in##offset##_min (struct device *dev, char *buf)	\
 {								\
-	return show_in_min(dev, buf, 0x##offset);		\
+	return show_in_min(dev, buf, offset);			\
 }								\
 static ssize_t							\
 	show_in##offset##_max (struct device *dev, char *buf)	\
 {								\
-	return show_in_max(dev, buf, 0x##offset);		\
+	return show_in_max(dev, buf, offset);			\
 }								\
 static ssize_t set_in##offset##_min (struct device *dev, 	\
 		const char *buf, size_t count) 			\
 {								\
-	return set_in_min(dev, buf, count, 0x##offset);		\
+	return set_in_min(dev, buf, count, offset);		\
 }								\
 static ssize_t set_in##offset##_max (struct device *dev,	\
 			const char *buf, size_t count)		\
 {								\
-	return set_in_max(dev, buf, count, 0x##offset);		\
+	return set_in_max(dev, buf, count, offset);		\
 }								\
 static DEVICE_ATTR(in##offset##_min, S_IRUGO | S_IWUSR, 	\
 		show_in##offset##_min, set_in##offset##_min);	\
@@ -360,27 +360,27 @@
 #define show_temp_offset(offset)					\
 static ssize_t show_temp_##offset (struct device *dev, char *buf)	\
 {									\
-	return show_temp(dev, buf, 0x##offset - 1);			\
+	return show_temp(dev, buf, offset - 1);				\
 }									\
 static ssize_t								\
 show_temp_##offset##_max (struct device *dev, char *buf)		\
 {									\
-	return show_temp_max(dev, buf, 0x##offset - 1);			\
+	return show_temp_max(dev, buf, offset - 1);			\
 }									\
 static ssize_t								\
 show_temp_##offset##_min (struct device *dev, char *buf)		\
 {									\
-	return show_temp_min(dev, buf, 0x##offset - 1);			\
+	return show_temp_min(dev, buf, offset - 1);			\
 }									\
 static ssize_t set_temp_##offset##_max (struct device *dev, 		\
 		const char *buf, size_t count) 				\
 {									\
-	return set_temp_max(dev, buf, count, 0x##offset - 1);		\
+	return set_temp_max(dev, buf, count, offset - 1);		\
 }									\
 static ssize_t set_temp_##offset##_min (struct device *dev, 		\
 		const char *buf, size_t count) 				\
 {									\
-	return set_temp_min(dev, buf, count, 0x##offset - 1);		\
+	return set_temp_min(dev, buf, count, offset - 1);		\
 }									\
 static DEVICE_ATTR(temp##offset##_input, S_IRUGO, show_temp_##offset, NULL); \
 static DEVICE_ATTR(temp##offset##_max, S_IRUGO | S_IWUSR, 		\
@@ -423,12 +423,12 @@
 #define show_sensor_offset(offset)					\
 static ssize_t show_sensor_##offset (struct device *dev, char *buf)	\
 {									\
-	return show_sensor(dev, buf, 0x##offset - 1);			\
+	return show_sensor(dev, buf, offset - 1);			\
 }									\
 static ssize_t set_sensor_##offset (struct device *dev, 		\
 		const char *buf, size_t count) 				\
 {									\
-	return set_sensor(dev, buf, count, 0x##offset - 1);		\
+	return set_sensor(dev, buf, count, offset - 1);			\
 }									\
 static DEVICE_ATTR(temp##offset##_type, S_IRUGO | S_IWUSR, 		\
 		show_sensor_##offset, set_sensor_##offset);
@@ -505,25 +505,25 @@
 #define show_fan_offset(offset)						\
 static ssize_t show_fan_##offset (struct device *dev, char *buf)	\
 {									\
-	return show_fan(dev, buf, 0x##offset - 1);			\
+	return show_fan(dev, buf, offset - 1);				\
 }									\
 static ssize_t show_fan_##offset##_min (struct device *dev, char *buf)	\
 {									\
-	return show_fan_min(dev, buf, 0x##offset - 1);			\
+	return show_fan_min(dev, buf, offset - 1);			\
 }									\
 static ssize_t show_fan_##offset##_div (struct device *dev, char *buf)	\
 {									\
-	return show_fan_div(dev, buf, 0x##offset - 1);			\
+	return show_fan_div(dev, buf, offset - 1);			\
 }									\
 static ssize_t set_fan_##offset##_min (struct device *dev, 		\
 	const char *buf, size_t count) 					\
 {									\
-	return set_fan_min(dev, buf, count, 0x##offset - 1);		\
+	return set_fan_min(dev, buf, count, offset - 1);		\
 }									\
 static ssize_t set_fan_##offset##_div (struct device *dev, 		\
 		const char *buf, size_t count) 				\
 {									\
-	return set_fan_div(dev, buf, count, 0x##offset - 1);		\
+	return set_fan_div(dev, buf, count, offset - 1);		\
 }									\
 static DEVICE_ATTR(fan##offset##_input, S_IRUGO, show_fan_##offset, NULL); \
 static DEVICE_ATTR(fan##offset##_min, S_IRUGO | S_IWUSR, 		\
diff -Nru a/drivers/i2c/chips/lm75.c b/drivers/i2c/chips/lm75.c
--- a/drivers/i2c/chips/lm75.c	2004-10-10 22:31:03 -07:00
+++ b/drivers/i2c/chips/lm75.c	2004-10-10 22:31:03 -07:00
@@ -74,7 +74,7 @@
 	.detach_client	= lm75_detach_client,
 };
 
-static int lm75_id = 0;
+static int lm75_id;
 
 #define show(value)	\
 static ssize_t show_##value(struct device *dev, char *buf)		\
diff -Nru a/drivers/i2c/chips/lm77.c b/drivers/i2c/chips/lm77.c
--- a/drivers/i2c/chips/lm77.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/chips/lm77.c	2004-10-10 22:31:04 -07:00
@@ -83,7 +83,7 @@
 	.detach_client	= lm77_detach_client,
 };
 
-static int lm77_id = 0;
+static int lm77_id;
 
 /* straight from the datasheet */
 #define LM77_TEMP_MIN (-55000)
diff -Nru a/drivers/i2c/chips/lm78.c b/drivers/i2c/chips/lm78.c
--- a/drivers/i2c/chips/lm78.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/chips/lm78.c	2004-10-10 22:31:04 -07:00
@@ -229,29 +229,29 @@
 static ssize_t							\
 	show_in##offset (struct device *dev, char *buf)		\
 {								\
-	return show_in(dev, buf, 0x##offset);			\
+	return show_in(dev, buf, offset);			\
 }								\
 static DEVICE_ATTR(in##offset##_input, S_IRUGO, 		\
 		show_in##offset, NULL);				\
 static ssize_t							\
 	show_in##offset##_min (struct device *dev, char *buf)   \
 {								\
-	return show_in_min(dev, buf, 0x##offset);		\
+	return show_in_min(dev, buf, offset);			\
 }								\
 static ssize_t							\
 	show_in##offset##_max (struct device *dev, char *buf)   \
 {								\
-	return show_in_max(dev, buf, 0x##offset);		\
+	return show_in_max(dev, buf, offset);			\
 }								\
 static ssize_t set_in##offset##_min (struct device *dev,	\
 		const char *buf, size_t count)			\
 {								\
-	return set_in_min(dev, buf, count, 0x##offset);		\
+	return set_in_min(dev, buf, count, offset);		\
 }								\
 static ssize_t set_in##offset##_max (struct device *dev,	\
 		const char *buf, size_t count)			\
 {								\
-	return set_in_max(dev, buf, count, 0x##offset);		\
+	return set_in_max(dev, buf, count, offset);		\
 }								\
 static DEVICE_ATTR(in##offset##_min, S_IRUGO | S_IWUSR,		\
 		show_in##offset##_min, set_in##offset##_min);	\
@@ -375,20 +375,20 @@
 #define show_fan_offset(offset)						\
 static ssize_t show_fan_##offset (struct device *dev, char *buf)	\
 {									\
-	return show_fan(dev, buf, 0x##offset - 1);			\
+	return show_fan(dev, buf, offset - 1);				\
 }									\
 static ssize_t show_fan_##offset##_min (struct device *dev, char *buf)  \
 {									\
-	return show_fan_min(dev, buf, 0x##offset - 1);			\
+	return show_fan_min(dev, buf, offset - 1);			\
 }									\
 static ssize_t show_fan_##offset##_div (struct device *dev, char *buf)  \
 {									\
-	return show_fan_div(dev, buf, 0x##offset - 1);			\
+	return show_fan_div(dev, buf, offset - 1);			\
 }									\
 static ssize_t set_fan_##offset##_min (struct device *dev,		\
 		const char *buf, size_t count)				\
 {									\
-	return set_fan_min(dev, buf, count, 0x##offset - 1);		\
+	return set_fan_min(dev, buf, count, offset - 1);		\
 }									\
 static DEVICE_ATTR(fan##offset##_input, S_IRUGO, show_fan_##offset, NULL);\
 static DEVICE_ATTR(fan##offset##_min, S_IRUGO | S_IWUSR,		\
@@ -692,26 +692,12 @@
 /* Called when we have found a new LM78. It should set limits, etc. */
 static void lm78_init_client(struct i2c_client *client)
 {
-	struct lm78_data *data = i2c_get_clientdata(client);
-	int vid;
-
-	/* Reset all except Watchdog values and last conversion values
-	   This sets fan-divs to 2, among others */
-	lm78_write_value(client, LM78_REG_CONFIG, 0x80);
-
-	vid = lm78_read_value(client, LM78_REG_VID_FANDIV) & 0x0f;
-	if (data->type == lm79)
-		vid |=
-		    (lm78_read_value(client, LM78_REG_CHIPID) & 0x01) << 4;
-	else
-		vid |= 0x10;
-	vid = VID_FROM_REG(vid);
+	u8 config = lm78_read_value(client, LM78_REG_CONFIG);
 
 	/* Start monitoring */
-	lm78_write_value(client, LM78_REG_CONFIG,
-			 (lm78_read_value(client, LM78_REG_CONFIG) & 0xf7)
-			 | 0x01);
-
+	if (!(config & 0x01))
+		lm78_write_value(client, LM78_REG_CONFIG,
+				 (config & 0xf7) | 0x01);
 }
 
 static struct lm78_data *lm78_update_device(struct device *dev)
diff -Nru a/drivers/i2c/chips/lm80.c b/drivers/i2c/chips/lm80.c
--- a/drivers/i2c/chips/lm80.c	2004-10-10 22:31:03 -07:00
+++ b/drivers/i2c/chips/lm80.c	2004-10-10 22:31:03 -07:00
@@ -145,7 +145,7 @@
  * Internal variables
  */
 
-static int lm80_id = 0;
+static int lm80_id;
 
 /*
  * Driver data (common to all clients)
@@ -262,14 +262,15 @@
 {
 	struct i2c_client *client = to_i2c_client(dev);
 	struct lm80_data *data = i2c_get_clientdata(client);
-	unsigned long min;
+	unsigned long min, val;
 	u8 reg;
 
 	/* Save fan_min */
 	min = FAN_FROM_REG(data->fan_min[nr],
 			   DIV_FROM_REG(data->fan_div[nr]));
 
-	data->fan_div[nr] = DIV_TO_REG(simple_strtoul(buf, NULL, 10));
+	val = simple_strtoul(buf, NULL, 10);
+	data->fan_div[nr] = DIV_TO_REG(val);
 
 	reg = (lm80_read_value(client, LM80_REG_FANDIV) & ~(3 << (2 * (nr + 1))))
 	    | (data->fan_div[nr] << (2 * (nr + 1)));
diff -Nru a/drivers/i2c/chips/lm83.c b/drivers/i2c/chips/lm83.c
--- a/drivers/i2c/chips/lm83.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/chips/lm83.c	2004-10-10 22:31:04 -07:00
@@ -80,13 +80,14 @@
 
 /*
  * Conversions and various macros
- * The LM83 uses signed 8-bit values.
+ * The LM83 uses signed 8-bit values with LSB = 1 degree Celcius.
  */
 
-#define TEMP_FROM_REG(val)	(((val) > 127 ? (val) - 0x100 : (val)) * 1000)
-#define TEMP_TO_REG(val)	((val) <= -50000 ? -50 + 0x100 : (val) >= 127000 ? 127 : \
-				 (val) > -500 ? ((val)+500) / 1000 : \
-				 ((val)-500) / 1000 + 0x100)
+#define TEMP_FROM_REG(val)	((val) * 1000)
+#define TEMP_TO_REG(val)	((val) <= -128000 ? -128 : \
+				 (val) >= 127000 ? 127 : \
+				 (val) < 0 ? ((val) - 500) / 1000 : \
+				 ((val) + 500) / 1000)
 
 static const u8 LM83_REG_R_TEMP[] = {
 	LM83_REG_R_LOCAL_TEMP,
@@ -142,9 +143,9 @@
 	unsigned long last_updated; /* in jiffies */
 
 	/* registers values */
-	u8 temp_input[4];
-	u8 temp_high[4];
-	u8 temp_crit;
+	s8 temp_input[4];
+	s8 temp_high[4];
+	s8 temp_crit;
 	u16 alarms; /* bitvector, combined */
 };
 
@@ -152,7 +153,7 @@
  * Internal variables
  */
 
-static int lm83_id = 0;
+static int lm83_id;
 
 /*
  * Sysfs stuff
@@ -180,7 +181,8 @@
 { \
 	struct i2c_client *client = to_i2c_client(dev); \
 	struct lm83_data *data = i2c_get_clientdata(client); \
-	data->value = TEMP_TO_REG(simple_strtol(buf, NULL, 10)); \
+	long val = simple_strtol(buf, NULL, 10); \
+	data->value = TEMP_TO_REG(val); \
 	i2c_smbus_write_byte_data(client, reg, data->value); \
 	return count; \
 }
diff -Nru a/drivers/i2c/chips/lm85.c b/drivers/i2c/chips/lm85.c
--- a/drivers/i2c/chips/lm85.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/chips/lm85.c	2004-10-10 22:31:04 -07:00
@@ -405,7 +405,7 @@
 };
 
 /* Unique ID assigned to each LM85 detected */
-static int lm85_id = 0;
+static int lm85_id;
 
 
 /* 4 Fans */
@@ -437,16 +437,16 @@
 #define show_fan_offset(offset)						\
 static ssize_t show_fan_##offset (struct device *dev, char *buf)	\
 {									\
-	return show_fan(dev, buf, 0x##offset - 1);			\
+	return show_fan(dev, buf, offset - 1);				\
 }									\
 static ssize_t show_fan_##offset##_min (struct device *dev, char *buf)	\
 {									\
-	return show_fan_min(dev, buf, 0x##offset - 1);			\
+	return show_fan_min(dev, buf, offset - 1);			\
 }									\
 static ssize_t set_fan_##offset##_min (struct device *dev, 		\
 	const char *buf, size_t count) 					\
 {									\
-	return set_fan_min(dev, buf, count, 0x##offset - 1);		\
+	return set_fan_min(dev, buf, count, offset - 1);		\
 }									\
 static DEVICE_ATTR(fan##offset##_input, S_IRUGO, show_fan_##offset, NULL);\
 static DEVICE_ATTR(fan##offset##_min, S_IRUGO | S_IWUSR, 		\
@@ -527,20 +527,21 @@
 #define show_pwm_reg(offset)						\
 static ssize_t show_pwm_##offset (struct device *dev, char *buf)	\
 {									\
-	return show_pwm(dev, buf, 0x##offset - 1);			\
+	return show_pwm(dev, buf, offset - 1);				\
 }									\
 static ssize_t set_pwm_##offset (struct device *dev,			\
 				 const char *buf, size_t count)		\
 {									\
-	return set_pwm(dev, buf, count, 0x##offset - 1);		\
+	return set_pwm(dev, buf, count, offset - 1);			\
 }									\
 static ssize_t show_pwm_enable##offset (struct device *dev, char *buf)	\
 {									\
-	return show_pwm_enable(dev, buf, 0x##offset - 1);			\
+	return show_pwm_enable(dev, buf, offset - 1);			\
 }									\
-static DEVICE_ATTR(fan##offset##_pwm, S_IRUGO | S_IWUSR, 			\
+static DEVICE_ATTR(pwm##offset, S_IRUGO | S_IWUSR, 			\
 		show_pwm_##offset, set_pwm_##offset);			\
-static DEVICE_ATTR(fan##offset##_pwm_enable, S_IRUGO, show_pwm_enable##offset, NULL);
+static DEVICE_ATTR(pwm##offset##_enable, S_IRUGO, 			\
+		show_pwm_enable##offset, NULL);
 
 show_pwm_reg(1);
 show_pwm_reg(2);
@@ -594,25 +595,25 @@
 #define show_in_reg(offset)						\
 static ssize_t show_in_##offset (struct device *dev, char *buf)		\
 {									\
-	return show_in(dev, buf, 0x##offset);				\
+	return show_in(dev, buf, offset);				\
 }									\
 static ssize_t show_in_##offset##_min (struct device *dev, char *buf)	\
 {									\
-	return show_in_min(dev, buf, 0x##offset);			\
+	return show_in_min(dev, buf, offset);				\
 }									\
 static ssize_t show_in_##offset##_max (struct device *dev, char *buf)	\
 {									\
-	return show_in_max(dev, buf, 0x##offset);			\
+	return show_in_max(dev, buf, offset);				\
 }									\
 static ssize_t set_in_##offset##_min (struct device *dev, 		\
 	const char *buf, size_t count) 					\
 {									\
-	return set_in_min(dev, buf, count, 0x##offset);			\
+	return set_in_min(dev, buf, count, offset);			\
 }									\
 static ssize_t set_in_##offset##_max (struct device *dev, 		\
 	const char *buf, size_t count) 					\
 {									\
-	return set_in_max(dev, buf, count, 0x##offset);			\
+	return set_in_max(dev, buf, count, offset);			\
 }									\
 static DEVICE_ATTR(in##offset##_input, S_IRUGO, show_in_##offset, NULL);	\
 static DEVICE_ATTR(in##offset##_min, S_IRUGO | S_IWUSR, 		\
@@ -674,25 +675,25 @@
 #define show_temp_reg(offset)						\
 static ssize_t show_temp_##offset (struct device *dev, char *buf)	\
 {									\
-	return show_temp(dev, buf, 0x##offset - 1);			\
+	return show_temp(dev, buf, offset - 1);				\
 }									\
 static ssize_t show_temp_##offset##_min (struct device *dev, char *buf)	\
 {									\
-	return show_temp_min(dev, buf, 0x##offset - 1);			\
+	return show_temp_min(dev, buf, offset - 1);			\
 }									\
 static ssize_t show_temp_##offset##_max (struct device *dev, char *buf)	\
 {									\
-	return show_temp_max(dev, buf, 0x##offset - 1);			\
+	return show_temp_max(dev, buf, offset - 1);			\
 }									\
 static ssize_t set_temp_##offset##_min (struct device *dev, 		\
 	const char *buf, size_t count) 					\
 {									\
-	return set_temp_min(dev, buf, count, 0x##offset - 1);		\
+	return set_temp_min(dev, buf, count, offset - 1);		\
 }									\
 static ssize_t set_temp_##offset##_max (struct device *dev, 		\
 	const char *buf, size_t count) 					\
 {									\
-	return set_temp_max(dev, buf, count, 0x##offset - 1);		\
+	return set_temp_max(dev, buf, count, offset - 1);		\
 }									\
 static DEVICE_ATTR(temp##offset##_input, S_IRUGO, show_temp_##offset, NULL);	\
 static DEVICE_ATTR(temp##offset##_min, S_IRUGO | S_IWUSR, 		\
@@ -707,6 +708,8 @@
 
 int lm85_attach_adapter(struct i2c_adapter *adapter)
 {
+	if (!(adapter->class & I2C_CLASS_HWMON))
+		return 0;
 	return i2c_detect(adapter, &addr_data, lm85_detect);
 }
 
@@ -843,12 +846,12 @@
 	device_create_file(&new_client->dev, &dev_attr_fan2_min);
 	device_create_file(&new_client->dev, &dev_attr_fan3_min);
 	device_create_file(&new_client->dev, &dev_attr_fan4_min);
-	device_create_file(&new_client->dev, &dev_attr_fan1_pwm);
-	device_create_file(&new_client->dev, &dev_attr_fan2_pwm);
-	device_create_file(&new_client->dev, &dev_attr_fan3_pwm);
-	device_create_file(&new_client->dev, &dev_attr_fan1_pwm_enable);
-	device_create_file(&new_client->dev, &dev_attr_fan2_pwm_enable);
-	device_create_file(&new_client->dev, &dev_attr_fan3_pwm_enable);
+	device_create_file(&new_client->dev, &dev_attr_pwm1);
+	device_create_file(&new_client->dev, &dev_attr_pwm2);
+	device_create_file(&new_client->dev, &dev_attr_pwm3);
+	device_create_file(&new_client->dev, &dev_attr_pwm1_enable);
+	device_create_file(&new_client->dev, &dev_attr_pwm2_enable);
+	device_create_file(&new_client->dev, &dev_attr_pwm3_enable);
 	device_create_file(&new_client->dev, &dev_attr_in0_input);
 	device_create_file(&new_client->dev, &dev_attr_in1_input);
 	device_create_file(&new_client->dev, &dev_attr_in2_input);
diff -Nru a/drivers/i2c/chips/lm90.c b/drivers/i2c/chips/lm90.c
--- a/drivers/i2c/chips/lm90.c	2004-10-10 22:31:03 -07:00
+++ b/drivers/i2c/chips/lm90.c	2004-10-10 22:31:03 -07:00
@@ -127,19 +127,24 @@
 
 /*
  * Conversions and various macros
- * The LM90 uses signed 8-bit values for the local temperatures,
- * and signed 11-bit values for the remote temperatures (except
- * T_CRIT). Note that TEMP2_TO_REG does not round values, but
- * stick to the nearest lower value instead. Fixing it is just
- * not worth it.
- */
-
-#define TEMP1_FROM_REG(val)	((val & 0x80 ? val-0x100 : val) * 1000)
-#define TEMP1_TO_REG(val)	((val < 0 ? val+0x100*1000 : val) / 1000)
-#define TEMP2_FROM_REG(val)	(((val & 0x8000 ? val-0x10000 : val) >> 5) * 125)
-#define TEMP2_TO_REG(val)	((((val / 125) << 5) + (val < 0 ? 0x10000 : 0)) & 0xFFE0)
-#define HYST_FROM_REG(val)	(val * 1000)
-#define HYST_TO_REG(val)	(val <= 0 ? 0 : val >= 31000 ? 31 : val / 1000)
+ * For local temperatures and limits, critical limits and the hysteresis
+ * value, the LM90 uses signed 8-bit values with LSB = 1 degree Celcius.
+ * For remote temperatures and limits, it uses signed 11-bit values with
+ * LSB = 0.125 degree Celcius, left-justified in 16-bit registers.
+ */
+
+#define TEMP1_FROM_REG(val)	((val) * 1000)
+#define TEMP1_TO_REG(val)	((val) <= -128000 ? -128 : \
+				 (val) >= 127000 ? 127 : \
+				 (val) < 0 ? ((val) - 500) / 1000 : \
+				 ((val) + 500) / 1000)
+#define TEMP2_FROM_REG(val)	((val) / 32 * 125)
+#define TEMP2_TO_REG(val)	((val) <= -128000 ? 0x8000 : \
+				 (val) >= 127875 ? 0x7FE0 : \
+				 (val) < 0 ? ((val) - 62) / 125 * 32 : \
+				 ((val) + 62) / 125 * 32)
+#define HYST_TO_REG(val)	((val) <= 0 ? 0 : (val) >= 30500 ? 31 : \
+				 ((val) + 500) / 1000)
 
 /*
  * Functions declaration
@@ -176,9 +181,9 @@
 	unsigned long last_updated; /* in jiffies */
 
 	/* registers values */
-	u8 temp_input1, temp_low1, temp_high1; /* local */
-	u16 temp_input2, temp_low2, temp_high2; /* remote, combined */
-	u8 temp_crit1, temp_crit2;
+	s8 temp_input1, temp_low1, temp_high1; /* local */
+	s16 temp_input2, temp_low2, temp_high2; /* remote, combined */
+	s8 temp_crit1, temp_crit2;
 	u8 temp_hyst;
 	u16 alarms; /* bitvector, combined */
 };
@@ -187,7 +192,7 @@
  * Internal variables
  */
 
-static int lm90_id = 0;
+static int lm90_id;
 
 /*
  * Sysfs stuff
@@ -214,7 +219,8 @@
 { \
 	struct i2c_client *client = to_i2c_client(dev); \
 	struct lm90_data *data = i2c_get_clientdata(client); \
-	data->value = TEMP1_TO_REG(simple_strtol(buf, NULL, 10)); \
+	long val = simple_strtol(buf, NULL, 10); \
+	data->value = TEMP1_TO_REG(val); \
 	i2c_smbus_write_byte_data(client, reg, data->value); \
 	return count; \
 }
@@ -224,7 +230,8 @@
 { \
 	struct i2c_client *client = to_i2c_client(dev); \
 	struct lm90_data *data = i2c_get_clientdata(client); \
-	data->value = TEMP2_TO_REG(simple_strtol(buf, NULL, 10)); \
+	long val = simple_strtol(buf, NULL, 10); \
+	data->value = TEMP2_TO_REG(val); \
 	i2c_smbus_write_byte_data(client, regh, data->value >> 8); \
 	i2c_smbus_write_byte_data(client, regl, data->value & 0xff); \
 	return count; \
@@ -241,7 +248,7 @@
 { \
 	struct lm90_data *data = lm90_update_device(dev); \
 	return sprintf(buf, "%d\n", TEMP1_FROM_REG(data->basereg) \
-		       - HYST_FROM_REG(data->temp_hyst)); \
+		       - TEMP1_FROM_REG(data->temp_hyst)); \
 }
 show_temp_hyst(temp_hyst1, temp_crit1);
 show_temp_hyst(temp_hyst2, temp_crit2);
diff -Nru a/drivers/i2c/chips/max1619.c b/drivers/i2c/chips/max1619.c
--- a/drivers/i2c/chips/max1619.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/chips/max1619.c	2004-10-10 22:31:04 -07:00
@@ -120,7 +120,7 @@
  * Internal variables
  */
 
-static int max1619_id = 0;
+static int max1619_id;
 
 /*
  * Sysfs stuff
@@ -145,7 +145,8 @@
 { \
 	struct i2c_client *client = to_i2c_client(dev); \
 	struct max1619_data *data = i2c_get_clientdata(client); \
-	data->value = TEMP_TO_REG(simple_strtol(buf, NULL, 10)); \
+	long val = simple_strtol(buf, NULL, 10); \
+	data->value = TEMP_TO_REG(val); \
 	i2c_smbus_write_byte_data(client, reg, data->value); \
 	return count; \
 }
diff -Nru a/drivers/i2c/chips/pcf8574.c b/drivers/i2c/chips/pcf8574.c
--- a/drivers/i2c/chips/pcf8574.c	2004-10-10 22:31:03 -07:00
+++ b/drivers/i2c/chips/pcf8574.c	2004-10-10 22:31:03 -07:00
@@ -77,7 +77,7 @@
 	.detach_client	= pcf8574_detach_client,
 };
 
-static int pcf8574_id = 0;
+static int pcf8574_id;
 
 /* following are the sysfs callback functions */
 static ssize_t show_read(struct device *dev, char *buf)
diff -Nru a/drivers/i2c/chips/pcf8591.c b/drivers/i2c/chips/pcf8591.c
--- a/drivers/i2c/chips/pcf8591.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/chips/pcf8591.c	2004-10-10 22:31:04 -07:00
@@ -99,7 +99,7 @@
 	.detach_client	= pcf8591_detach_client,
 };
 
-static int pcf8591_id = 0;
+static int pcf8591_id;
 
 /* following are the sysfs callback functions */
 #define show_in_channel(channel)					\
diff -Nru a/drivers/i2c/chips/smsc47m1.c b/drivers/i2c/chips/smsc47m1.c
--- a/drivers/i2c/chips/smsc47m1.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/chips/smsc47m1.c	2004-10-10 22:31:04 -07:00
@@ -182,13 +182,13 @@
 	return sprintf(buf, "%d\n", DIV_FROM_REG(data->fan_div[nr]));
 }
 
-static ssize_t get_fan_pwm(struct device *dev, char *buf, int nr)
+static ssize_t get_pwm(struct device *dev, char *buf, int nr)
 {
 	struct smsc47m1_data *data = smsc47m1_update_device(dev, 0);
 	return sprintf(buf, "%d\n", PWM_FROM_REG(data->pwm[nr]));
 }
 
-static ssize_t get_fan_pwm_en(struct device *dev, char *buf, int nr)
+static ssize_t get_pwm_en(struct device *dev, char *buf, int nr)
 {
 	struct smsc47m1_data *data = smsc47m1_update_device(dev, 0);
 	return sprintf(buf, "%d\n", PWM_EN_FROM_REG(data->pwm[nr]));
@@ -256,7 +256,7 @@
 	return count;
 }
 
-static ssize_t set_fan_pwm(struct device *dev, const char *buf,
+static ssize_t set_pwm(struct device *dev, const char *buf,
 		size_t count, int nr)
 {
 	struct i2c_client *client = to_i2c_client(dev);
@@ -275,7 +275,7 @@
 	return count;
 }
 
-static ssize_t set_fan_pwm_en(struct device *dev, const char *buf,
+static ssize_t set_pwm_en(struct device *dev, const char *buf,
 		size_t count, int nr)
 {
 	struct i2c_client *client = to_i2c_client(dev);
@@ -298,43 +298,43 @@
 #define fan_present(offset)						\
 static ssize_t get_fan##offset (struct device *dev, char *buf)		\
 {									\
-	return get_fan(dev, buf, 0x##offset - 1);			\
+	return get_fan(dev, buf, offset - 1);				\
 }									\
 static ssize_t get_fan##offset##_min (struct device *dev, char *buf)	\
 {									\
-	return get_fan_min(dev, buf, 0x##offset - 1);			\
+	return get_fan_min(dev, buf, offset - 1);			\
 }									\
 static ssize_t set_fan##offset##_min (struct device *dev,		\
 		const char *buf, size_t count)				\
 {									\
-	return set_fan_min(dev, buf, count, 0x##offset - 1);		\
+	return set_fan_min(dev, buf, count, offset - 1);		\
 }									\
 static ssize_t get_fan##offset##_div (struct device *dev, char *buf)	\
 {									\
-	return get_fan_div(dev, buf, 0x##offset - 1);			\
+	return get_fan_div(dev, buf, offset - 1);			\
 }									\
 static ssize_t set_fan##offset##_div (struct device *dev,		\
 		const char *buf, size_t count)				\
 {									\
-	return set_fan_div(dev, buf, count, 0x##offset - 1);		\
+	return set_fan_div(dev, buf, count, offset - 1);		\
 }									\
-static ssize_t get_fan##offset##_pwm (struct device *dev, char *buf)	\
+static ssize_t get_pwm##offset (struct device *dev, char *buf)		\
 {									\
-	return get_fan_pwm(dev, buf, 0x##offset - 1);			\
+	return get_pwm(dev, buf, offset - 1);				\
 }									\
-static ssize_t set_fan##offset##_pwm (struct device *dev,		\
+static ssize_t set_pwm##offset (struct device *dev,			\
 		const char *buf, size_t count)				\
 {									\
-	return set_fan_pwm(dev, buf, count, 0x##offset - 1);		\
+	return set_pwm(dev, buf, count, offset - 1);			\
 }									\
-static ssize_t get_fan##offset##_pwm_en (struct device *dev, char *buf)	\
+static ssize_t get_pwm##offset##_en (struct device *dev, char *buf)	\
 {									\
-	return get_fan_pwm_en(dev, buf, 0x##offset - 1);		\
+	return get_pwm_en(dev, buf, offset - 1);			\
 }									\
-static ssize_t set_fan##offset##_pwm_en (struct device *dev,		\
+static ssize_t set_pwm##offset##_en (struct device *dev,		\
 		const char *buf, size_t count)				\
 {									\
-	return set_fan_pwm_en(dev, buf, count, 0x##offset - 1);		\
+	return set_pwm_en(dev, buf, count, offset - 1);			\
 }									\
 static DEVICE_ATTR(fan##offset##_input, S_IRUGO, get_fan##offset,	\
 		NULL);							\
@@ -342,10 +342,10 @@
 		get_fan##offset##_min, set_fan##offset##_min);		\
 static DEVICE_ATTR(fan##offset##_div, S_IRUGO | S_IWUSR,		\
 		get_fan##offset##_div, set_fan##offset##_div);		\
-static DEVICE_ATTR(fan##offset##_pwm, S_IRUGO | S_IWUSR,		\
-		get_fan##offset##_pwm, set_fan##offset##_pwm);		\
-static DEVICE_ATTR(fan##offset##_pwm_enable, S_IRUGO | S_IWUSR,		\
-		get_fan##offset##_pwm_en, set_fan##offset##_pwm_en);
+static DEVICE_ATTR(pwm##offset, S_IRUGO | S_IWUSR,			\
+		get_pwm##offset, set_pwm##offset);			\
+static DEVICE_ATTR(pwm##offset##_enable, S_IRUGO | S_IWUSR,		\
+		get_pwm##offset##_en, set_pwm##offset##_en);
 
 fan_present(1);
 fan_present(2);
@@ -462,15 +462,15 @@
 
 	if ((smsc47m1_read_value(new_client, SMSC47M1_REG_PPIN(0)) & 0x05)
 	    == 0x04) {
-		device_create_file(&new_client->dev, &dev_attr_fan1_pwm);
-		device_create_file(&new_client->dev, &dev_attr_fan1_pwm_enable);
+		device_create_file(&new_client->dev, &dev_attr_pwm1);
+		device_create_file(&new_client->dev, &dev_attr_pwm1_enable);
 	} else
 		dev_dbg(&new_client->dev, "PWM 1 not enabled by hardware, "
 			"skipping\n");
 	if ((smsc47m1_read_value(new_client, SMSC47M1_REG_PPIN(1)) & 0x05)
 	    == 0x04) {
-		device_create_file(&new_client->dev, &dev_attr_fan2_pwm);
-		device_create_file(&new_client->dev, &dev_attr_fan2_pwm_enable);
+		device_create_file(&new_client->dev, &dev_attr_pwm2);
+		device_create_file(&new_client->dev, &dev_attr_pwm2_enable);
 	} else
 		dev_dbg(&new_client->dev, "PWM 2 not enabled by hardware, "
 			"skipping\n");
diff -Nru a/drivers/i2c/chips/via686a.c b/drivers/i2c/chips/via686a.c
--- a/drivers/i2c/chips/via686a.c	2004-10-10 22:31:03 -07:00
+++ b/drivers/i2c/chips/via686a.c	2004-10-10 22:31:03 -07:00
@@ -383,27 +383,27 @@
 static ssize_t 							\
 	show_in##offset (struct device *dev, char *buf)		\
 {								\
-	return show_in(dev, buf, 0x##offset);			\
+	return show_in(dev, buf, offset);			\
 }								\
 static ssize_t 							\
 	show_in##offset##_min (struct device *dev, char *buf)	\
 {								\
-	return show_in_min(dev, buf, 0x##offset);		\
+	return show_in_min(dev, buf, offset);		\
 }								\
 static ssize_t 							\
 	show_in##offset##_max (struct device *dev, char *buf)	\
 {								\
-	return show_in_max(dev, buf, 0x##offset);		\
+	return show_in_max(dev, buf, offset);		\
 }								\
 static ssize_t set_in##offset##_min (struct device *dev, 	\
 		const char *buf, size_t count) 			\
 {								\
-	return set_in_min(dev, buf, count, 0x##offset);		\
+	return set_in_min(dev, buf, count, offset);		\
 }								\
 static ssize_t set_in##offset##_max (struct device *dev,	\
 			const char *buf, size_t count)		\
 {								\
-	return set_in_max(dev, buf, count, 0x##offset);		\
+	return set_in_max(dev, buf, count, offset);		\
 }								\
 static DEVICE_ATTR(in##offset##_input, S_IRUGO, show_in##offset, NULL);\
 static DEVICE_ATTR(in##offset##_min, S_IRUGO | S_IWUSR, 	\
@@ -451,27 +451,27 @@
 #define show_temp_offset(offset)					\
 static ssize_t show_temp_##offset (struct device *dev, char *buf)	\
 {									\
-	return show_temp(dev, buf, 0x##offset - 1);			\
+	return show_temp(dev, buf, offset - 1);				\
 }									\
 static ssize_t								\
 show_temp_##offset##_over (struct device *dev, char *buf)		\
 {									\
-	return show_temp_over(dev, buf, 0x##offset - 1);			\
+	return show_temp_over(dev, buf, offset - 1);			\
 }									\
 static ssize_t								\
 show_temp_##offset##_hyst (struct device *dev, char *buf)		\
 {									\
-	return show_temp_hyst(dev, buf, 0x##offset - 1);			\
+	return show_temp_hyst(dev, buf, offset - 1);			\
 }									\
 static ssize_t set_temp_##offset##_over (struct device *dev, 		\
 		const char *buf, size_t count) 				\
 {									\
-	return set_temp_over(dev, buf, count, 0x##offset - 1);		\
+	return set_temp_over(dev, buf, count, offset - 1);		\
 }									\
 static ssize_t set_temp_##offset##_hyst (struct device *dev, 		\
 		const char *buf, size_t count) 				\
 {									\
-	return set_temp_hyst(dev, buf, count, 0x##offset - 1);		\
+	return set_temp_hyst(dev, buf, count, offset - 1);		\
 }									\
 static DEVICE_ATTR(temp##offset##_input, S_IRUGO, show_temp_##offset, NULL);\
 static DEVICE_ATTR(temp##offset##_max, S_IRUGO | S_IWUSR, 		\
@@ -522,25 +522,25 @@
 #define show_fan_offset(offset)						\
 static ssize_t show_fan_##offset (struct device *dev, char *buf)	\
 {									\
-	return show_fan(dev, buf, 0x##offset - 1);			\
+	return show_fan(dev, buf, offset - 1);				\
 }									\
 static ssize_t show_fan_##offset##_min (struct device *dev, char *buf)	\
 {									\
-	return show_fan_min(dev, buf, 0x##offset - 1);			\
+	return show_fan_min(dev, buf, offset - 1);			\
 }									\
 static ssize_t show_fan_##offset##_div (struct device *dev, char *buf)	\
 {									\
-	return show_fan_div(dev, buf, 0x##offset - 1);			\
+	return show_fan_div(dev, buf, offset - 1);			\
 }									\
 static ssize_t set_fan_##offset##_min (struct device *dev, 		\
 	const char *buf, size_t count) 					\
 {									\
-	return set_fan_min(dev, buf, count, 0x##offset - 1);		\
+	return set_fan_min(dev, buf, count, offset - 1);		\
 }									\
 static ssize_t set_fan_##offset##_div (struct device *dev, 		\
 		const char *buf, size_t count) 				\
 {									\
-	return set_fan_div(dev, buf, count, 0x##offset - 1);		\
+	return set_fan_div(dev, buf, count, offset - 1);		\
 }									\
 static DEVICE_ATTR(fan##offset##_input, S_IRUGO, show_fan_##offset, NULL);\
 static DEVICE_ATTR(fan##offset##_min, S_IRUGO | S_IWUSR, 		\
diff -Nru a/drivers/i2c/chips/w83627hf.c b/drivers/i2c/chips/w83627hf.c
--- a/drivers/i2c/chips/w83627hf.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/i2c/chips/w83627hf.c	2004-10-10 22:31:04 -07:00
@@ -369,20 +369,20 @@
 static ssize_t \
 show_regs_in_##offset (struct device *dev, char *buf) \
 { \
-        return show_in(dev, buf, 0x##offset); \
+        return show_in(dev, buf, offset); \
 } \
 static DEVICE_ATTR(in##offset##_input, S_IRUGO, show_regs_in_##offset, NULL);
 
 #define sysfs_in_reg_offset(reg, offset) \
 static ssize_t show_regs_in_##reg##offset (struct device *dev, char *buf) \
 { \
-	return show_in_##reg (dev, buf, 0x##offset); \
+	return show_in_##reg (dev, buf, offset); \
 } \
 static ssize_t \
 store_regs_in_##reg##offset (struct device *dev, \
 			    const char *buf, size_t count) \
 { \
-	return store_in_##reg (dev, buf, count, 0x##offset); \
+	return store_in_##reg (dev, buf, count, offset); \
 } \
 static DEVICE_ATTR(in##offset##_##reg, S_IRUGO| S_IWUSR, \
 		  show_regs_in_##reg##offset, store_regs_in_##reg##offset);
@@ -521,19 +521,19 @@
 #define sysfs_fan_offset(offset) \
 static ssize_t show_regs_fan_##offset (struct device *dev, char *buf) \
 { \
-	return show_fan(dev, buf, 0x##offset); \
+	return show_fan(dev, buf, offset); \
 } \
 static DEVICE_ATTR(fan##offset##_input, S_IRUGO, show_regs_fan_##offset, NULL);
 
 #define sysfs_fan_min_offset(offset) \
 static ssize_t show_regs_fan_min##offset (struct device *dev, char *buf) \
 { \
-	return show_fan_min(dev, buf, 0x##offset); \
+	return show_fan_min(dev, buf, offset); \
 } \
 static ssize_t \
 store_regs_fan_min##offset (struct device *dev, const char *buf, size_t count) \
 { \
-	return store_fan_min(dev, buf, count, 0x##offset); \
+	return store_fan_min(dev, buf, count, offset); \
 } \
 static DEVICE_ATTR(fan##offset##_min, S_IRUGO | S_IWUSR, \
 		  show_regs_fan_min##offset, store_regs_fan_min##offset);
@@ -595,20 +595,20 @@
 static ssize_t \
 show_regs_temp_##offset (struct device *dev, char *buf) \
 { \
-	return show_temp(dev, buf, 0x##offset); \
+	return show_temp(dev, buf, offset); \
 } \
 static DEVICE_ATTR(temp##offset##_input, S_IRUGO, show_regs_temp_##offset, NULL);
 
 #define sysfs_temp_reg_offset(reg, offset) \
 static ssize_t show_regs_temp_##reg##offset (struct device *dev, char *buf) \
 { \
-	return show_temp_##reg (dev, buf, 0x##offset); \
+	return show_temp_##reg (dev, buf, offset); \
 } \
 static ssize_t \
 store_regs_temp_##reg##offset (struct device *dev, \
 			      const char *buf, size_t count) \
 { \
-	return store_temp_##reg (dev, buf, count, 0x##offset); \
+	return store_temp_##reg (dev, buf, count, offset); \
 } \
 static DEVICE_ATTR(temp##offset##_##reg, S_IRUGO| S_IWUSR, \
 		  show_regs_temp_##reg##offset, store_regs_temp_##reg##offset);
@@ -845,7 +845,7 @@
 { \
 	return store_pwm_reg(dev, buf, count, offset); \
 } \
-static DEVICE_ATTR(fan##offset##_pwm, S_IRUGO | S_IWUSR, \
+static DEVICE_ATTR(pwm##offset, S_IRUGO | S_IWUSR, \
 		  show_regs_pwm_##offset, store_regs_pwm_##offset);
 
 sysfs_pwm(1);
@@ -854,7 +854,7 @@
 
 #define device_create_file_pwm(client, offset) \
 do { \
-device_create_file(&client->dev, &dev_attr_fan##offset##_pwm); \
+device_create_file(&client->dev, &dev_attr_pwm##offset); \
 } while (0)
 
 static ssize_t
diff -Nru a/drivers/i2c/chips/w83781d.c b/drivers/i2c/chips/w83781d.c
--- a/drivers/i2c/chips/w83781d.c	2004-10-10 22:31:03 -07:00
+++ b/drivers/i2c/chips/w83781d.c	2004-10-10 22:31:03 -07:00
@@ -318,18 +318,18 @@
 static ssize_t \
 show_regs_in_##offset (struct device *dev, char *buf) \
 { \
-        return show_in(dev, buf, 0x##offset); \
+        return show_in(dev, buf, offset); \
 } \
 static DEVICE_ATTR(in##offset##_input, S_IRUGO, show_regs_in_##offset, NULL);
 
 #define sysfs_in_reg_offset(reg, offset) \
 static ssize_t show_regs_in_##reg##offset (struct device *dev, char *buf) \
 { \
-	return show_in_##reg (dev, buf, 0x##offset); \
+	return show_in_##reg (dev, buf, offset); \
 } \
 static ssize_t store_regs_in_##reg##offset (struct device *dev, const char *buf, size_t count) \
 { \
-	return store_in_##reg (dev, buf, count, 0x##offset); \
+	return store_in_##reg (dev, buf, count, offset); \
 } \
 static DEVICE_ATTR(in##offset##_##reg, S_IRUGO| S_IWUSR, show_regs_in_##reg##offset, store_regs_in_##reg##offset);
 
@@ -384,18 +384,18 @@
 #define sysfs_fan_offset(offset) \
 static ssize_t show_regs_fan_##offset (struct device *dev, char *buf) \
 { \
-	return show_fan(dev, buf, 0x##offset); \
+	return show_fan(dev, buf, offset); \
 } \
 static DEVICE_ATTR(fan##offset##_input, S_IRUGO, show_regs_fan_##offset, NULL);
 
 #define sysfs_fan_min_offset(offset) \
 static ssize_t show_regs_fan_min##offset (struct device *dev, char *buf) \
 { \
-	return show_fan_min(dev, buf, 0x##offset); \
+	return show_fan_min(dev, buf, offset); \
 } \
 static ssize_t store_regs_fan_min##offset (struct device *dev, const char *buf, size_t count) \
 { \
-	return store_fan_min(dev, buf, count, 0x##offset); \
+	return store_fan_min(dev, buf, count, offset); \
 } \
 static DEVICE_ATTR(fan##offset##_min, S_IRUGO | S_IWUSR, show_regs_fan_min##offset, store_regs_fan_min##offset);
 
@@ -464,18 +464,18 @@
 static ssize_t \
 show_regs_temp_##offset (struct device *dev, char *buf) \
 { \
-	return show_temp(dev, buf, 0x##offset); \
+	return show_temp(dev, buf, offset); \
 } \
 static DEVICE_ATTR(temp##offset##_input, S_IRUGO, show_regs_temp_##offset, NULL);
 
 #define sysfs_temp_reg_offset(reg, offset) \
 static ssize_t show_regs_temp_##reg##offset (struct device *dev, char *buf) \
 { \
-	return show_temp_##reg (dev, buf, 0x##offset); \
+	return show_temp_##reg (dev, buf, offset); \
 } \
 static ssize_t store_regs_temp_##reg##offset (struct device *dev, const char *buf, size_t count) \
 { \
-	return store_temp_##reg (dev, buf, count, 0x##offset); \
+	return store_temp_##reg (dev, buf, count, offset); \
 } \
 static DEVICE_ATTR(temp##offset##_##reg, S_IRUGO| S_IWUSR, show_regs_temp_##reg##offset, store_regs_temp_##reg##offset);
 
@@ -740,22 +740,26 @@
 { \
 	return show_pwm_reg(dev, buf, offset); \
 } \
-static ssize_t store_regs_pwm_##offset (struct device *dev, const char *buf, size_t count) \
+static ssize_t store_regs_pwm_##offset (struct device *dev, \
+		const char *buf, size_t count) \
 { \
 	return store_pwm_reg(dev, buf, count, offset); \
 } \
-static DEVICE_ATTR(fan##offset##_pwm, S_IRUGO | S_IWUSR, show_regs_pwm_##offset, store_regs_pwm_##offset);
+static DEVICE_ATTR(pwm##offset, S_IRUGO | S_IWUSR, \
+		show_regs_pwm_##offset, store_regs_pwm_##offset);
 
 #define sysfs_pwmenable(offset) \
 static ssize_t show_regs_pwmenable_##offset (struct device *dev, char *buf) \
 { \
 	return show_pwmenable_reg(dev, buf, offset); \
 } \
-static ssize_t store_regs_pwmenable_##offset (struct device *dev, const char *buf, size_t count) \
+static ssize_t store_regs_pwmenable_##offset (struct device *dev, \
+		const char *buf, size_t count) \
 { \
 	return store_pwmenable_reg(dev, buf, count, offset); \
 } \
-static DEVICE_ATTR(fan##offset##_pwm_enable, S_IRUGO | S_IWUSR, show_regs_pwmenable_##offset, store_regs_pwmenable_##offset);
+static DEVICE_ATTR(pwm##offset##_enable, S_IRUGO | S_IWUSR, \
+		show_regs_pwmenable_##offset, store_regs_pwmenable_##offset);
 
 sysfs_pwm(1);
 sysfs_pwm(2);
@@ -765,12 +769,12 @@
 
 #define device_create_file_pwm(client, offset) \
 do { \
-device_create_file(&client->dev, &dev_attr_fan##offset##_pwm); \
+device_create_file(&client->dev, &dev_attr_pwm##offset); \
 } while (0)
 
 #define device_create_file_pwmenable(client, offset) \
 do { \
-device_create_file(&client->dev, &dev_attr_fan##offset##_pwm_enable); \
+device_create_file(&client->dev, &dev_attr_pwm##offset##_enable); \
 } while (0)
 
 static ssize_t
@@ -1062,6 +1066,9 @@
 	
 	if (is_isa)
 		if (!request_region(address, W83781D_EXTENT, "w83781d")) {
+			dev_dbg(&adapter->dev, "Request of region "
+				"0x%x-0x%x for w83781d failed\n", address,
+				address + W83781D_EXTENT - 1);
 			err = -EBUSY;
 			goto ERROR0;
 		}
@@ -1075,15 +1082,11 @@
 			/* We need the timeouts for at least some LM78-like
 			   chips. But only if we read 'undefined' registers. */
 			i = inb_p(address + 1);
-			if (inb_p(address + 2) != i) {
-				err = -ENODEV;
-				goto ERROR1;
-			}
-			if (inb_p(address + 3) != i) {
-				err = -ENODEV;
-				goto ERROR1;
-			}
-			if (inb_p(address + 7) != i) {
+			if (inb_p(address + 2) != i
+			 || inb_p(address + 3) != i
+			 || inb_p(address + 7) != i) {
+				dev_dbg(&adapter->dev, "Detection of w83781d "
+					"chip failed at step 1\n");
 				err = -ENODEV;
 				goto ERROR1;
 			}
@@ -1092,8 +1095,13 @@
 			/* Let's just hope nothing breaks here */
 			i = inb_p(address + 5) & 0x7f;
 			outb_p(~i & 0x7f, address + 5);
-			if ((inb_p(address + 5) & 0x7f) != (~i & 0x7f)) {
+			val2 = inb_p(address + 5) & 0x7f;
+			if (val2 != (~i & 0x7f)) {
 				outb_p(i, address + 5);
+				dev_dbg(&adapter->dev, "Detection of w83781d "
+					"chip failed at step 2 (0x%x != "
+					"0x%x at 0x%x)\n", val2, ~i & 0x7f,
+					address + 5);
 				err = -ENODEV;
 				goto ERROR1;
 			}
@@ -1125,7 +1133,9 @@
 	   force_*=... parameter, and the Winbond will be reset to the right
 	   bank. */
 	if (kind < 0) {
-		if (w83781d_read_value(new_client, W83781D_REG_CONFIG) & 0x80){
+		if (w83781d_read_value(new_client, W83781D_REG_CONFIG) & 0x80) {
+			dev_dbg(&new_client->dev, "Detection failed at step "
+				"3\n");
 			err = -ENODEV;
 			goto ERROR2;
 		}
@@ -1135,6 +1145,8 @@
 		if ((!(val1 & 0x07)) &&
 		    (((!(val1 & 0x80)) && (val2 != 0xa3) && (val2 != 0xc3))
 		     || ((val1 & 0x80) && (val2 != 0x5c) && (val2 != 0x12)))) {
+			dev_dbg(&new_client->dev, "Detection failed at step "
+				"4\n");
 			err = -ENODEV;
 			goto ERROR2;
 		}
@@ -1144,6 +1156,8 @@
 				  ((val1 & 0x80) && (val2 == 0x5c)))) {
 			if (w83781d_read_value
 			    (new_client, W83781D_REG_I2C_ADDR) != address) {
+				dev_dbg(&new_client->dev, "Detection failed "
+					"at step 5\n");
 				err = -ENODEV;
 				goto ERROR2;
 			}
@@ -1166,6 +1180,8 @@
 		else if (val2 == 0x12)
 			vendid = asus;
 		else {
+			dev_dbg(&new_client->dev, "Chip was made by neither "
+				"Winbond nor Asus?\n");
 			err = -ENODEV;
 			goto ERROR2;
 		}
@@ -1186,10 +1202,10 @@
 			kind = w83697hf;
 		else {
 			if (kind == 0)
-				dev_warn(&new_client->dev,
-				       "Ignoring 'force' parameter for unknown chip at"
-				       "adapter %d, address 0x%02x\n",
-				       i2c_adapter_id(adapter), address);
+				dev_warn(&new_client->dev, "Ignoring 'force' "
+					 "parameter for unknown chip at "
+					 "adapter %d, address 0x%02x\n",
+					 i2c_adapter_id(adapter), address);
 			err = -EINVAL;
 			goto ERROR2;
 		}
diff -Nru a/drivers/w1/Makefile b/drivers/w1/Makefile
--- a/drivers/w1/Makefile	2004-10-10 22:31:04 -07:00
+++ b/drivers/w1/Makefile	2004-10-10 22:31:04 -07:00
@@ -2,6 +2,10 @@
 # Makefile for the Dallas's 1-wire bus.
 #
 
+ifneq ($(CONFIG_NET), y)
+EXTRA_CFLAGS	+= -DNETLINK_DISABLED
+endif
+
 obj-$(CONFIG_W1)	+= wire.o
 wire-objs		:= w1.o w1_int.o w1_family.o w1_netlink.o w1_io.o
 
diff -Nru a/drivers/w1/dscore.c b/drivers/w1/dscore.c
--- a/drivers/w1/dscore.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/w1/dscore.c	2004-10-10 22:31:04 -07:00
@@ -727,11 +727,18 @@
 {
 	struct ds_device *dev;
 	
-	dev = usb_get_intfdata (intf);
-	usb_set_intfdata (intf, NULL);
+	dev = usb_get_intfdata(intf);
+	usb_set_intfdata(intf, NULL);
 
-	while(atomic_read(&dev->refcnt))
+	while (atomic_read(&dev->refcnt)) {
+		printk(KERN_INFO "Waiting for DS to become free: refcnt=%d.\n",
+				atomic_read(&dev->refcnt));
+		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout(HZ);
+
+		if (signal_pending(current))
+			flush_signals(current);
+	}
 
 	usb_put_dev(dev->udev);
 	kfree(dev);
diff -Nru a/drivers/w1/w1.c b/drivers/w1/w1.c
--- a/drivers/w1/w1.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/w1/w1.c	2004-10-10 22:31:04 -07:00
@@ -47,9 +47,11 @@
 
 static int w1_timeout = 10;
 int w1_max_slave_count = 10;
+int w1_max_slave_ttl = 10;
 
 module_param_named(timeout, w1_timeout, int, 0);
 module_param_named(max_slave_count, w1_max_slave_count, int, 0);
+module_param_named(slave_ttl, w1_max_slave_ttl, int, 0);
 
 spinlock_t w1_mlock = SPIN_LOCK_UNLOCKED;
 LIST_HEAD(w1_masters);
@@ -431,6 +433,7 @@
 		return err;
 	}
 
+	sl->ttl = dev->slave_ttl;
 	dev->slave_count++;
 
 	memcpy(&msg.id.id, rn, sizeof(msg.id.id));
@@ -446,8 +449,15 @@
 	
 	dev_info(&sl->dev, "%s: detaching %s.\n", __func__, sl->name);
 
-	while (atomic_read(&sl->refcnt))
-		schedule_timeout(10);
+	while (atomic_read(&sl->refcnt)) {
+		printk(KERN_INFO "Waiting for %s to become free: refcnt=%d.\n",
+				sl->name, atomic_read(&sl->refcnt));
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(HZ);
+
+		if (signal_pending(current))
+			flush_signals(current);
+	}
 
 	sysfs_remove_bin_file (&sl->dev.kobj, &sl->attr_bin);
 	device_remove_file(&sl->dev, &sl->attr_name);
@@ -504,8 +514,8 @@
 			 * All who don't sleep must send ID bit and COMPLEMENT ID bit.
 			 * They actually are ANDed between all senders.
 			 */
-			id_bit = w1_read_bit(dev);
-			comp_bit = w1_read_bit(dev);
+			id_bit = w1_touch_bit(dev, 1);
+			comp_bit = w1_touch_bit(dev, 1);
 
 			if (id_bit && comp_bit)
 				break;
@@ -536,7 +546,10 @@
 			 * and make all who don't have "search_bit" in "i"'th position
 			 * in it's registration number sleep.
 			 */
-			w1_write_bit(dev, search_bit);
+			if (dev->bus_master->touch_bit)
+				w1_touch_bit(dev, search_bit);
+			else
+				w1_write_bit(dev, search_bit);
 
 		}
 #endif
@@ -569,7 +582,7 @@
 		}
 
 		if (slave_count == dev->slave_count &&
-		    ((rn >> 56) & 0xff) == w1_calc_crc8((u8 *)&rn, 7)) {
+			rn && ((rn >> 56) & 0xff) == w1_calc_crc8((u8 *)&rn, 7)) {
 			w1_attach_slave_device(dev, (struct w1_reg_num *) &rn);
 		}
 	}
@@ -718,7 +731,7 @@
 		list_for_each_safe(ent, n, &dev->slist) {
 			sl = list_entry(ent, struct w1_slave, w1_slave_entry);
 
-			if (sl && !test_bit(W1_SLAVE_ACTIVE, (unsigned long *)&sl->flags)) {
+			if (sl && !test_bit(W1_SLAVE_ACTIVE, (unsigned long *)&sl->flags) && !--sl->ttl) {
 				list_del (&sl->w1_slave_entry);
 
 				w1_slave_detach (sl);
@@ -726,6 +739,8 @@
 
 				dev->slave_count--;
 			}
+			else if (test_bit(W1_SLAVE_ACTIVE, (unsigned long *)&sl->flags))
+				sl->ttl = dev->slave_ttl;
 		}
 		up(&dev->mutex);
 	}
diff -Nru a/drivers/w1/w1.h b/drivers/w1/w1.h
--- a/drivers/w1/w1.h	2004-10-10 22:31:04 -07:00
+++ b/drivers/w1/w1.h	2004-10-10 22:31:04 -07:00
@@ -63,6 +63,7 @@
 	atomic_t		refcnt;
 	u8			rom[9];
 	u32			flags;
+	int			ttl;
 
 	struct w1_master	*master;
 	struct w1_family 	*family;
@@ -99,6 +100,7 @@
 	struct list_head	slist;
 	int			max_slave_count, slave_count;
 	unsigned long		attempts;
+	int			slave_ttl;
 	int			initialized;
 	u32			id;
 
diff -Nru a/drivers/w1/w1_family.c b/drivers/w1/w1_family.c
--- a/drivers/w1/w1_family.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/w1/w1_family.c	2004-10-10 22:31:04 -07:00
@@ -84,8 +84,15 @@
 
 	spin_unlock(&w1_flock);
 
-	while (atomic_read(&fent->refcnt))
-		schedule_timeout(10);
+	while (atomic_read(&fent->refcnt)) {
+		printk(KERN_INFO "Waiting for family %u to become free: refcnt=%d.\n",
+				fent->fid, atomic_read(&fent->refcnt));
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(HZ);
+
+		if (signal_pending(current))
+			flush_signals(current);
+	}
 }
 
 /*
diff -Nru a/drivers/w1/w1_int.c b/drivers/w1/w1_int.c
--- a/drivers/w1/w1_int.c	2004-10-10 22:31:04 -07:00
+++ b/drivers/w1/w1_int.c	2004-10-10 22:31:04 -07:00
@@ -32,12 +32,13 @@
 extern struct bus_type w1_bus_type;
 extern struct device w1_device;
 extern int w1_max_slave_count;
+extern int w1_max_slave_ttl;
 extern struct list_head w1_masters;
 extern spinlock_t w1_mlock;
 
 extern int w1_process(void *);
 
-struct w1_master * w1_alloc_dev(u32 id, int slave_count,
+struct w1_master * w1_alloc_dev(u32 id, int slave_count, int slave_ttl,
 	      struct device_driver *driver, struct device *device)
 {
 	struct w1_master *dev;
@@ -65,6 +66,7 @@
 	dev->kpid 		= -1;
 	dev->initialized 	= 0;
 	dev->id 		= id;
+	dev->slave_ttl		= slave_ttl;
 
 	atomic_set(&dev->refcnt, 2);
 
@@ -121,7 +123,7 @@
 	int retval = 0;
 	struct w1_netlink_msg msg;
 
-	dev = w1_alloc_dev(w1_ids++, w1_max_slave_count, &w1_driver, &w1_device);
+	dev = w1_alloc_dev(w1_ids++, w1_max_slave_count, w1_max_slave_ttl, &w1_driver, &w1_device);
 	if (!dev)
 		return -ENOMEM;
 
@@ -179,8 +181,15 @@
 			 "%s: Failed to send signal to w1 kernel thread %d.\n",
 			 __func__, dev->kpid);
 
-	while (atomic_read(&dev->refcnt))
-		schedule_timeout(10);
+	while (atomic_read(&dev->refcnt)) {
+		printk(KERN_INFO "Waiting for %s to become free: refcnt=%d.\n",
+				dev->name, atomic_read(&dev->refcnt));
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(HZ);
+
+		if (signal_pending(current))
+			flush_signals(current);
+	}
 
 	msg.id.mst.id = dev->id;
 	msg.id.mst.pid = dev->kpid;
diff -Nru a/drivers/w1/w1_int.h b/drivers/w1/w1_int.h
--- a/drivers/w1/w1_int.h	2004-10-10 22:31:03 -07:00
+++ b/drivers/w1/w1_int.h	2004-10-10 22:31:03 -07:00
@@ -27,7 +27,7 @@
 
 #include "w1.h"
 
-struct w1_master * w1_alloc_dev(int, struct device_driver *, struct device *);
+struct w1_master * w1_alloc_dev(u32, int, int, struct device_driver *, struct device *);
 void w1_free_dev(struct w1_master *dev);
 int w1_add_master_device(struct w1_bus_master *);
 void w1_remove_master_device(struct w1_bus_master *);
diff -Nru a/drivers/w1/w1_netlink.c b/drivers/w1/w1_netlink.c
--- a/drivers/w1/w1_netlink.c	2004-10-10 22:31:03 -07:00
+++ b/drivers/w1/w1_netlink.c	2004-10-10 22:31:03 -07:00
@@ -26,6 +26,7 @@
 #include "w1_log.h"
 #include "w1_netlink.h"
 
+#ifndef NETLINK_DISABLED
 void w1_netlink_send(struct w1_master *dev, struct w1_netlink_msg *msg)
 {
 	unsigned int size;
@@ -53,3 +54,10 @@
 nlmsg_failure:
 	return;
 }
+#else
+#warning Netlink support is disabled. Please compile with NET support enabled.
+
+void w1_netlink_send(struct w1_master *dev, struct w1_netlink_msg *msg)
+{
+}
+#endif
diff -Nru a/drivers/w1/w1_therm.c b/drivers/w1/w1_therm.c
--- a/drivers/w1/w1_therm.c	2004-10-10 22:31:03 -07:00
+++ b/drivers/w1/w1_therm.c	2004-10-10 22:31:03 -07:00
@@ -59,19 +59,28 @@
 	return sprintf(buf, "%s\n", sl->name);
 }
 
+static inline int w1_convert_temp(u8 rom[9])
+{
+	int t, h;
+	
+	if (rom[1] == 0)
+		t = ((s32)rom[0] >> 1)*1000;
+	else
+		t = 1000*(-1*(s32)(0x100-rom[0]) >> 1);
+	
+	t -= 250;
+	h = 1000*((s32)rom[7] - (s32)rom[6]);
+	h /= (s32)rom[7];
+	t += h;
+
+	return t;
+}
+
 static ssize_t w1_therm_read_temp(struct device *dev, char *buf)
 {
 	struct w1_slave *sl = container_of(dev, struct w1_slave, dev);
-	s16 temp;
-
-	/* 
-	 * Must be more precise.
-	 */
-	temp = 0;
-	temp <<= sl->rom[1] / 2;
-	temp |= sl->rom[0] / 2;
 
-	return sprintf(buf, "%d\n", temp * 1000);
+	return sprintf(buf, "%d\n", w1_convert_temp(sl->rom));
 }
 
 static int w1_therm_check_rom(u8 rom[9])
@@ -92,7 +101,6 @@
 	struct w1_master *dev = sl->master;
 	u8 rom[9], crc, verdict;
 	int i, max_trying = 10;
-	u16 temp;
 
 	atomic_inc(&sl->refcnt);
 	if (down_interruptible(&sl->master->mutex)) {
@@ -120,6 +128,7 @@
 		if (!w1_reset_bus (dev)) {
 			int count = 0;
 			u8 match[9] = {W1_MATCH_ROM, };
+			unsigned long tm;
 
 			memcpy(&match[1], (u64 *) & sl->reg_num, 8);
 			
@@ -127,24 +136,29 @@
 
 			w1_write_8(dev, W1_CONVERT_TEMP);
 
-			if (count < 10) {
-				if (!w1_reset_bus(dev)) {
-					w1_write_block(dev, match, 9);
-
-					w1_write_8(dev, W1_READ_SCRATCHPAD);
-					if ((count = w1_read_block(dev, rom, 9)) != 9) {
-						dev_warn(&dev->dev, "w1_read_block() returned %d instead of 9.\n", count);
-					}
+			tm = jiffies + msecs_to_jiffies(750);
+			while(time_before(jiffies, tm)) {
+				set_current_state(TASK_INTERRUPTIBLE);
+				schedule_timeout(tm-jiffies);
 
-					crc = w1_calc_crc8(rom, 8);
+				if (signal_pending(current))
+					flush_signals(current);
+			}
 
-					if (rom[8] == crc && rom[0])
-						verdict = 1;
+			if (!w1_reset_bus (dev)) {
+				w1_write_block(dev, match, 9);
+				
+				w1_write_8(dev, W1_READ_SCRATCHPAD);
+				if ((count = w1_read_block(dev, rom, 9)) != 9) {
+					dev_warn(&dev->dev, "w1_read_block() returned %d instead of 9.\n", count);
 				}
+
+				crc = w1_calc_crc8(rom, 8);
+
+				if (rom[8] == crc && rom[0])
+					verdict = 1;
+
 			}
-			else
-				dev_warn(&dev->dev,
-					  "18S20 doesn't respond to CONVERT_TEMP.\n");
 		}
 
 		if (!w1_therm_check_rom(rom))
@@ -157,12 +171,13 @@
 			   crc, (verdict) ? "YES" : "NO");
 	if (verdict)
 		memcpy(sl->rom, rom, sizeof(sl->rom));
+	else
+		dev_warn(&dev->dev, "18S20 doesn't respond to CONVERT_TEMP.\n");
+
 	for (i = 0; i < 9; ++i)
 		count += sprintf(buf + count, "%02x ", sl->rom[i]);
-	temp = 0;
-	temp <<= sl->rom[1] / 2;
-	temp |= sl->rom[0] / 2;
-	count += sprintf(buf + count, "t=%u\n", temp);
+	
+	count += sprintf(buf + count, "t=%d\n", w1_convert_temp(rom));
 out:
 	up(&dev->mutex);
 out_dec:
diff -Nru a/include/linux/i2c-vid.h b/include/linux/i2c-vid.h
--- a/include/linux/i2c-vid.h	2004-10-10 22:31:03 -07:00
+++ b/include/linux/i2c-vid.h	2004-10-10 22:31:03 -07:00
@@ -29,7 +29,22 @@
 */
 
 /*
-    Legal val values 00 - 1F.
+    AMD Opteron processors don't follow the Intel VRM spec.
+    I'm going to "make up" 2.4 as the VRM spec for the Opterons.
+    No good reason just a mnemonic for the 24x Opteron processor
+    series
+
+    Opteron VID encoding is:
+
+       00000  =  1.550 V
+       00001  =  1.525 V
+        . . . .
+       11110  =  0.800 V
+       11111  =  0.000 V (off)
+ */
+
+/*
+    Legal val values 0x00 - 0x1f; except for VRD 10.0, 0x00 - 0x3f.
     vrm is the Intel VRM document version.
     Note: vrm version is scaled by 10 and the return value is scaled by 1000
     to avoid floating point in the kernel.
@@ -41,9 +56,28 @@
 
 static inline int vid_from_reg(int val, int vrm)
 {
+	int vid;
+
 	switch(vrm) {
+
 	case  0:
 		return 0;
+
+	case 100:               /* VRD 10.0 */
+		if((val & 0x1f) == 0x1f)
+			return 0;
+		if((val & 0x1f) <= 0x09 || val == 0x0a)
+			vid = 10875 - (val & 0x1f) * 250;
+		else
+			vid = 18625 - (val & 0x1f) * 250;
+		if(val & 0x20)
+			vid -= 125;
+		vid /= 10;      /* only return 3 dec. places for now */
+		return vid;
+
+	case 24:                /* Opteron processor */
+		return(val == 0x1f ? 0 : 1550 - val * 25);
+
 	case 91:		/* VRM 9.1 */
 	case 90:		/* VRM 9.0 */
 		return(val == 0x1f ? 0 :
