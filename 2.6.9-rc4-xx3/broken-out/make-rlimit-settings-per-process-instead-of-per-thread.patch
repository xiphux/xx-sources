
From: Roland McGrath <roland@redhat.com>

POSIX specifies that the limit settings provided by getrlimit/setrlimit are
shared by the whole process, not specific to individual threads.  This
patch changes the behavior of those calls to comply with POSIX.  

I've moved the struct rlimit array from task_struct to signal_struct, as it
has the correct sharing properties.  (This reduces kernel memory usage per
thread in multithreaded processes by around 100/200 bytes for 32/64
machines respectively.)  I took a fairly minimal approach to the locking
issues with the newly shared struct rlimit array.  It turns out that all
the code that is checking limits really just needs to look at one word at a
time (one rlim_cur field, usually).  It's only the few places like
getrlimit itself (and fork), that require atomicity in accessing a whole
struct rlimit, so I just used a spin lock for them and no locking for most
of the checks.  If it turns out that readers of struct rlimit need more
atomicity where they are now cheap, or less overhead where they are now
atomic (e.g. fork), then seqcount is certainly the right thing to use for
them instead of readers using the spin lock.  Though it's in signal_struct,
I didn't use siglock since the access to rlimits never needs to disable
irqs and doesn't overlap with other siglock uses.  Instead of adding
something new, I overloaded task_lock(task->group_leader) for this; it is
used for other things that are not likely to happen simultaneously with
limit tweaking.  To me that seems preferable to adding a word, but it would
be trivial (and arguably cleaner) to add a separate lock for these users
(or e.g. just use seqlock, which adds two words but is optimal for readers).

Most of the changes here are just the trivial s/->rlim/->signal->rlim/. 

I stumbled across what must be a long-standing bug, in reparent_to_init.
It does:
	memcpy(current->rlim, init_task.rlim, sizeof(*(current->rlim)));
when surely it was intended to be:
	memcpy(current->rlim, init_task.rlim, sizeof(current->rlim));
As rlim is an array, the * in the sizeof expression gets the size of the
first element, so this just changes the first limit (RLIMIT_CPU).  This is
for kernel threads, where it's clear that resetting all the rlimits is what
you want.  With that fixed, the setting of RLIMIT_FSIZE in nfsd is
superfluous since it will now already have been reset to RLIM_INFINITY.

The other subtlety is removing:
	tsk->rlim[RLIMIT_CPU].rlim_cur = RLIM_INFINITY;
in exit_notify, which was to avoid a race signalling during self-reaping
exit.  As the limit is now shared, a dying thread should not change it for
others.  Instead, I avoid that race by checking current->state before the
RLIMIT_CPU check.  (Adding one new conditional in that path is now required
one way or another, since if not for this check there would also be a new
race with self-reaping exit later on clearing current->signal that would
have to be checked for.)

The one loose end left by this patch is with process accounting.
do_acct_process temporarily resets the RLIMIT_FSIZE limit while writing the
accounting record.  I left this as it was, but it is now changing a limit
that might be shared by other threads still running.  I left this in a
dubious state because it seems to me that processing accounting may already
be more generally a dubious state when it comes to NPTL threads.  I would
think you would want one record per process, with aggregate data about all
threads that ever lived in it, not a separate record for each thread.  
I don't use process accounting myself, but if anyone is interested in
testing it out I could provide a patch to change it this way.

One final note, this is not 100% to POSIX compliance in regards to rlimits.
POSIX specifies that RLIMIT_CPU refers to a whole process in aggregate, not
to each individual thread.  I will provide patches later on to achieve that
change, assuming this patch goes in first.

Signed-off-by: Roland McGrath <roland@redhat.com>
Signed-off-by: Andrew Morton <akpm@osdl.org>
---

 25-akpm/arch/i386/mm/mmap.c                 |    4 ++--
 25-akpm/arch/ia64/kernel/perfmon.c          |    3 ++-
 25-akpm/arch/ia64/kernel/sys_ia64.c         |    2 +-
 25-akpm/arch/ia64/mm/fault.c                |    4 ++--
 25-akpm/arch/ia64/mm/init.c                 |    2 +-
 25-akpm/arch/mips/kernel/irixelf.c          |    2 +-
 25-akpm/arch/mips/kernel/sysirix.c          |   19 ++++++++++++-------
 25-akpm/arch/ppc64/mm/mmap.c                |    4 ++--
 25-akpm/arch/s390/mm/mmap.c                 |    4 ++--
 25-akpm/arch/sparc/kernel/sys_sunos.c       |    2 +-
 25-akpm/arch/sparc64/kernel/binfmt_aout32.c |    6 +++---
 25-akpm/arch/sparc64/kernel/sys_sunos32.c   |    2 +-
 25-akpm/arch/sparc64/solaris/fs.c           |   16 ++++++++--------
 25-akpm/arch/x86_64/ia32/ia32_aout.c        |    6 +++---
 25-akpm/fs/binfmt_aout.c                    |   10 +++++-----
 25-akpm/fs/binfmt_elf.c                     |    2 +-
 25-akpm/fs/binfmt_flat.c                    |    2 +-
 25-akpm/fs/buffer.c                         |    2 +-
 25-akpm/fs/exec.c                           |    4 ++--
 25-akpm/fs/fcntl.c                          |    6 +++---
 25-akpm/fs/nfs/direct.c                     |    2 +-
 25-akpm/fs/nfsd/nfssvc.c                    |    1 -
 25-akpm/fs/open.c                           |    2 +-
 25-akpm/fs/proc/array.c                     |    4 +++-
 25-akpm/include/linux/init_task.h           |    2 +-
 25-akpm/include/linux/mm.h                  |    2 +-
 25-akpm/include/linux/sched.h               |   13 +++++++++++--
 25-akpm/include/linux/security.h            |    2 +-
 25-akpm/ipc/mqueue.c                        |    2 +-
 25-akpm/kernel/acct.c                       |    6 +++---
 25-akpm/kernel/exit.c                       |    4 ++--
 25-akpm/kernel/fork.c                       |   10 +++++++---
 25-akpm/kernel/signal.c                     |    4 ++--
 25-akpm/kernel/sys.c                        |   27 ++++++++++++++++-----------
 25-akpm/kernel/timer.c                      |    5 +++--
 25-akpm/mm/filemap.c                        |    2 +-
 25-akpm/mm/memory.c                         |    2 +-
 25-akpm/mm/mlock.c                          |    6 +++---
 25-akpm/mm/mmap.c                           |   18 +++++++++---------
 25-akpm/mm/mremap.c                         |    4 ++--
 25-akpm/mm/nommu.c                          |    2 +-
 25-akpm/security/selinux/hooks.c            |    6 +++---
 42 files changed, 127 insertions(+), 101 deletions(-)

diff -puN arch/i386/mm/mmap.c~make-rlimit-settings-per-process-instead-of-per-thread arch/i386/mm/mmap.c
--- 25/arch/i386/mm/mmap.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.142800688 -0700
+++ 25-akpm/arch/i386/mm/mmap.c	2004-10-01 20:15:09.207790808 -0700
@@ -37,7 +37,7 @@
 
 static inline unsigned long mmap_base(struct mm_struct *mm)
 {
-	unsigned long gap = current->rlim[RLIMIT_STACK].rlim_cur;
+	unsigned long gap = current->signal->rlim[RLIMIT_STACK].rlim_cur;
 
 	if (gap < MIN_GAP)
 		gap = MIN_GAP;
@@ -59,7 +59,7 @@ void arch_pick_mmap_layout(struct mm_str
 	 */
 	if (sysctl_legacy_va_layout ||
 			(current->personality & ADDR_COMPAT_LAYOUT) ||
-			current->rlim[RLIMIT_STACK].rlim_cur == RLIM_INFINITY) {
+			current->signal->rlim[RLIMIT_STACK].rlim_cur == RLIM_INFINITY) {
 		mm->mmap_base = TASK_UNMAPPED_BASE;
 		mm->get_unmapped_area = arch_get_unmapped_area;
 		mm->unmap_area = arch_unmap_area;
diff -puN arch/ia64/kernel/perfmon.c~make-rlimit-settings-per-process-instead-of-per-thread arch/ia64/kernel/perfmon.c
--- 25/arch/ia64/kernel/perfmon.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.145800232 -0700
+++ 25-akpm/arch/ia64/kernel/perfmon.c	2004-10-01 20:15:09.212790048 -0700
@@ -2286,7 +2286,8 @@ pfm_smpl_buffer_alloc(struct task_struct
 	 * if ((mm->total_vm << PAGE_SHIFT) + len> task->rlim[RLIMIT_AS].rlim_cur)
 	 * 	return -ENOMEM;
 	 */
-	if (size > task->rlim[RLIMIT_MEMLOCK].rlim_cur) return -ENOMEM;
+	if (size > task->signal->rlim[RLIMIT_MEMLOCK].rlim_cur)
+		return -EAGAIN;
 
 	/*
 	 * We do the easy to undo allocations first.
diff -puN arch/ia64/kernel/sys_ia64.c~make-rlimit-settings-per-process-instead-of-per-thread arch/ia64/kernel/sys_ia64.c
--- 25/arch/ia64/kernel/sys_ia64.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.147799928 -0700
+++ 25-akpm/arch/ia64/kernel/sys_ia64.c	2004-10-01 20:15:09.212790048 -0700
@@ -138,7 +138,7 @@ ia64_brk (unsigned long brk)
 		goto out;
 
 	/* Check against rlimit.. */
-	rlim = current->rlim[RLIMIT_DATA].rlim_cur;
+	rlim = current->signal->rlim[RLIMIT_DATA].rlim_cur;
 	if (rlim < RLIM_INFINITY && brk - mm->start_data > rlim)
 		goto out;
 
diff -puN arch/ia64/mm/fault.c~make-rlimit-settings-per-process-instead-of-per-thread arch/ia64/mm/fault.c
--- 25/arch/ia64/mm/fault.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.148799776 -0700
+++ 25-akpm/arch/ia64/mm/fault.c	2004-10-01 20:15:09.213789896 -0700
@@ -32,8 +32,8 @@ expand_backing_store (struct vm_area_str
 	unsigned long grow;
 
 	grow = PAGE_SIZE >> PAGE_SHIFT;
-	if (address - vma->vm_start > current->rlim[RLIMIT_STACK].rlim_cur
-	    || (((vma->vm_mm->total_vm + grow) << PAGE_SHIFT) > current->rlim[RLIMIT_AS].rlim_cur))
+	if (address - vma->vm_start > current->signal->rlim[RLIMIT_STACK].rlim_cur
+	    || (((vma->vm_mm->total_vm + grow) << PAGE_SHIFT) > current->signal->rlim[RLIMIT_AS].rlim_cur))
 		return -ENOMEM;
 	vma->vm_end += PAGE_SIZE;
 	vma->vm_mm->total_vm += grow;
diff -puN arch/ia64/mm/init.c~make-rlimit-settings-per-process-instead-of-per-thread arch/ia64/mm/init.c
--- 25/arch/ia64/mm/init.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.149799624 -0700
+++ 25-akpm/arch/ia64/mm/init.c	2004-10-01 20:15:09.214789744 -0700
@@ -98,7 +98,7 @@ update_mmu_cache (struct vm_area_struct 
 inline void
 ia64_set_rbs_bot (void)
 {
-	unsigned long stack_size = current->rlim[RLIMIT_STACK].rlim_max & -16;
+	unsigned long stack_size = current->signal->rlim[RLIMIT_STACK].rlim_max & -16;
 
 	if (stack_size > MAX_USER_STACK_SIZE)
 		stack_size = MAX_USER_STACK_SIZE;
diff -puN arch/mips/kernel/irixelf.c~make-rlimit-settings-per-process-instead-of-per-thread arch/mips/kernel/irixelf.c
--- 25/arch/mips/kernel/irixelf.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.151799320 -0700
+++ 25-akpm/arch/mips/kernel/irixelf.c	2004-10-01 20:15:09.215789592 -0700
@@ -1055,7 +1055,7 @@ static int irix_core_dump(long signr, st
 	struct vm_area_struct *vma;
 	struct elfhdr elf;
 	off_t offset = 0, dataoff;
-	int limit = current->rlim[RLIMIT_CORE].rlim_cur;
+	int limit = current->signal->rlim[RLIMIT_CORE].rlim_cur;
 	int numnote = 4;
 	struct memelfnote notes[4];
 	struct elf_prstatus prstatus;	/* NT_PRSTATUS */
diff -puN arch/mips/kernel/sysirix.c~make-rlimit-settings-per-process-instead-of-per-thread arch/mips/kernel/sysirix.c
--- 25/arch/mips/kernel/sysirix.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.152799168 -0700
+++ 25-akpm/arch/mips/kernel/sysirix.c	2004-10-01 20:15:09.216789440 -0700
@@ -128,16 +128,21 @@ asmlinkage int irix_prctl(struct pt_regs
 		if (value > RLIM_INFINITY)
 			value = RLIM_INFINITY;
 		if (capable(CAP_SYS_ADMIN)) {
-			current->rlim[RLIMIT_STACK].rlim_max =
-				current->rlim[RLIMIT_STACK].rlim_cur = value;
+			task_lock(current->group_leader);
+			current->signal->rlim[RLIMIT_STACK].rlim_max =
+				current->signal->rlim[RLIMIT_STACK].rlim_cur = value;
+			task_unlock(current->group_leader);
 			error = value;
 			break;
 		}
-		if (value > current->rlim[RLIMIT_STACK].rlim_max) {
+		task_lock(current->group_leader);
+		if (value > current->signal->rlim[RLIMIT_STACK].rlim_max) {
 			error = -EINVAL;
+			task_unlock(current->group_leader);
 			break;
 		}
-		current->rlim[RLIMIT_STACK].rlim_cur = value;
+		current->signal->rlim[RLIMIT_STACK].rlim_cur = value;
+		task_unlock(current->group_leader);
 		error = value;
 		break;
 	}
@@ -145,7 +150,7 @@ asmlinkage int irix_prctl(struct pt_regs
 	case PR_GETSTACKSIZE:
 		printk("irix_prctl[%s:%d]: Wants PR_GETSTACKSIZE\n",
 		       current->comm, current->pid);
-		error = current->rlim[RLIMIT_STACK].rlim_cur;
+		error = current->signal->rlim[RLIMIT_STACK].rlim_cur;
 		break;
 
 	case PR_MAXPPROCS:
@@ -558,7 +563,7 @@ asmlinkage int irix_brk(unsigned long br
 	/*
 	 * Check against rlimit and stack..
 	 */
-	rlim = current->rlim[RLIMIT_DATA].rlim_cur;
+	rlim = current->signal->rlim[RLIMIT_DATA].rlim_cur;
 	if (rlim >= RLIM_INFINITY)
 		rlim = ~0;
 	if (brk - mm->end_code > rlim) {
@@ -2132,7 +2137,7 @@ asmlinkage int irix_ulimit(int cmd, int 
 		retval = -EINVAL;
 		goto out;
 #endif
-		retval = current->rlim[RLIMIT_NOFILE].rlim_cur;
+		retval = current->signal->rlim[RLIMIT_NOFILE].rlim_cur;
 		goto out;
 
 	case 5:
diff -puN arch/ppc64/mm/mmap.c~make-rlimit-settings-per-process-instead-of-per-thread arch/ppc64/mm/mmap.c
--- 25/arch/ppc64/mm/mmap.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.154798864 -0700
+++ 25-akpm/arch/ppc64/mm/mmap.c	2004-10-01 20:15:09.217789288 -0700
@@ -37,7 +37,7 @@
 
 static inline unsigned long mmap_base(void)
 {
-	unsigned long gap = current->rlim[RLIMIT_STACK].rlim_cur;
+	unsigned long gap = current->signal->rlim[RLIMIT_STACK].rlim_cur;
 
 	if (gap < MIN_GAP)
 		gap = MIN_GAP;
@@ -58,7 +58,7 @@ static inline int mmap_is_legacy(void)
 	if (current->personality & ADDR_COMPAT_LAYOUT)
 		return 1;
 
-	if (current->rlim[RLIMIT_STACK].rlim_cur == RLIM_INFINITY)
+	if (current->signal->rlim[RLIMIT_STACK].rlim_cur == RLIM_INFINITY)
 		return 1;
 
 	return sysctl_legacy_va_layout;
diff -puN arch/s390/mm/mmap.c~make-rlimit-settings-per-process-instead-of-per-thread arch/s390/mm/mmap.c
--- 25/arch/s390/mm/mmap.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.155798712 -0700
+++ 25-akpm/arch/s390/mm/mmap.c	2004-10-01 20:15:09.217789288 -0700
@@ -37,7 +37,7 @@
 
 static inline unsigned long mmap_base(void)
 {
-	unsigned long gap = current->rlim[RLIMIT_STACK].rlim_cur;
+	unsigned long gap = current->signal->rlim[RLIMIT_STACK].rlim_cur;
 
 	if (gap < MIN_GAP)
 		gap = MIN_GAP;
@@ -58,7 +58,7 @@ static inline int mmap_is_legacy(void)
 #endif
 	return sysctl_legacy_va_layout ||
 	    (current->personality & ADDR_COMPAT_LAYOUT) ||
-	    current->rlim[RLIMIT_STACK].rlim_cur == RLIM_INFINITY;
+	    current->signal->rlim[RLIMIT_STACK].rlim_cur == RLIM_INFINITY;
 }
 
 /*
diff -puN arch/sparc64/kernel/binfmt_aout32.c~make-rlimit-settings-per-process-instead-of-per-thread arch/sparc64/kernel/binfmt_aout32.c
--- 25/arch/sparc64/kernel/binfmt_aout32.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.156798560 -0700
+++ 25-akpm/arch/sparc64/kernel/binfmt_aout32.c	2004-10-01 20:15:09.218789136 -0700
@@ -102,12 +102,12 @@ static int aout32_core_dump(long signr, 
 /* If the size of the dump file exceeds the rlimit, then see what would happen
    if we wrote the stack, but not the data area.  */
 	if ((dump.u_dsize+dump.u_ssize) >
-	    current->rlim[RLIMIT_CORE].rlim_cur)
+	    current->signal->rlim[RLIMIT_CORE].rlim_cur)
 		dump.u_dsize = 0;
 
 /* Make sure we have enough room to write the stack and data areas. */
 	if ((dump.u_ssize) >
-	    current->rlim[RLIMIT_CORE].rlim_cur)
+	    current->signal->rlim[RLIMIT_CORE].rlim_cur)
 		dump.u_ssize = 0;
 
 /* make sure we actually have a data and stack area to dump */
@@ -218,7 +218,7 @@ static int load_aout32_binary(struct lin
 	 * size limits imposed on them by creating programs with large
 	 * arrays in the data or bss.
 	 */
-	rlim = current->rlim[RLIMIT_DATA].rlim_cur;
+	rlim = current->signal->rlim[RLIMIT_DATA].rlim_cur;
 	if (rlim >= RLIM_INFINITY)
 		rlim = ~0;
 	if (ex.a_data + ex.a_bss > rlim)
diff -puN arch/sparc64/kernel/sys_sunos32.c~make-rlimit-settings-per-process-instead-of-per-thread arch/sparc64/kernel/sys_sunos32.c
--- 25/arch/sparc64/kernel/sys_sunos32.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.158798256 -0700
+++ 25-akpm/arch/sparc64/kernel/sys_sunos32.c	2004-10-01 20:15:09.219788984 -0700
@@ -142,7 +142,7 @@ asmlinkage int sunos_brk(u32 baddr)
 	}
 	/* Check against rlimit and stack.. */
 	retval = -ENOMEM;
-	rlim = current->rlim[RLIMIT_DATA].rlim_cur;
+	rlim = current->signal->rlim[RLIMIT_DATA].rlim_cur;
 	if (rlim >= RLIM_INFINITY)
 		rlim = ~0;
 	if (brk - current->mm->end_code > rlim)
diff -puN arch/sparc64/solaris/fs.c~make-rlimit-settings-per-process-instead-of-per-thread arch/sparc64/solaris/fs.c
--- 25/arch/sparc64/solaris/fs.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.159798104 -0700
+++ 25-akpm/arch/sparc64/solaris/fs.c	2004-10-01 20:15:09.220788832 -0700
@@ -600,23 +600,23 @@ asmlinkage int solaris_ulimit(int cmd, i
 {
 	switch (cmd) {
 	case 1: /* UL_GETFSIZE - in 512B chunks */
-		return current->rlim[RLIMIT_FSIZE].rlim_cur >> 9;
+		return current->signal->rlim[RLIMIT_FSIZE].rlim_cur >> 9;
 	case 2: /* UL_SETFSIZE */
 		if ((unsigned long)val > (LONG_MAX>>9)) return -ERANGE;
 		val <<= 9;
-		lock_kernel();
-		if (val > current->rlim[RLIMIT_FSIZE].rlim_max) {
+		task_lock(current->group_leader);
+		if (val > current->signal->rlim[RLIMIT_FSIZE].rlim_max) {
 			if (!capable(CAP_SYS_RESOURCE)) {
-				unlock_kernel();
+				task_unlock(current->group_leader);
 				return -EPERM;
 			}
-			current->rlim[RLIMIT_FSIZE].rlim_max = val;
+			current->signal->rlim[RLIMIT_FSIZE].rlim_max = val;
 		}
-		current->rlim[RLIMIT_FSIZE].rlim_cur = val;
-		unlock_kernel();
+		current->signal->rlim[RLIMIT_FSIZE].rlim_cur = val;
+		task_unlock(current->group_leader);
 		return 0;
 	case 3: /* UL_GMEMLIM */
-		return current->rlim[RLIMIT_DATA].rlim_cur;
+		return current->signal->rlim[RLIMIT_DATA].rlim_cur;
 	case 4: /* UL_GDESLIM */
 		return NR_OPEN;
 	}
diff -puN arch/sparc/kernel/sys_sunos.c~make-rlimit-settings-per-process-instead-of-per-thread arch/sparc/kernel/sys_sunos.c
--- 25/arch/sparc/kernel/sys_sunos.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.161797800 -0700
+++ 25-akpm/arch/sparc/kernel/sys_sunos.c	2004-10-01 20:15:09.221788680 -0700
@@ -178,7 +178,7 @@ asmlinkage int sunos_brk(unsigned long b
 	 * Check against rlimit and stack..
 	 */
 	retval = -ENOMEM;
-	rlim = current->rlim[RLIMIT_DATA].rlim_cur;
+	rlim = current->signal->rlim[RLIMIT_DATA].rlim_cur;
 	if (rlim >= RLIM_INFINITY)
 		rlim = ~0;
 	if (brk - current->mm->end_code > rlim)
diff -puN arch/x86_64/ia32/ia32_aout.c~make-rlimit-settings-per-process-instead-of-per-thread arch/x86_64/ia32/ia32_aout.c
--- 25/arch/x86_64/ia32/ia32_aout.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.162797648 -0700
+++ 25-akpm/arch/x86_64/ia32/ia32_aout.c	2004-10-01 20:15:09.221788680 -0700
@@ -168,12 +168,12 @@ static int aout_core_dump(long signr, st
 /* If the size of the dump file exceeds the rlimit, then see what would happen
    if we wrote the stack, but not the data area.  */
 	if ((dump.u_dsize+dump.u_ssize+1) * PAGE_SIZE >
-	    current->rlim[RLIMIT_CORE].rlim_cur)
+	    current->signal->rlim[RLIMIT_CORE].rlim_cur)
 		dump.u_dsize = 0;
 
 /* Make sure we have enough room to write the stack and data areas. */
 	if ((dump.u_ssize+1) * PAGE_SIZE >
-	    current->rlim[RLIMIT_CORE].rlim_cur)
+	    current->signal->rlim[RLIMIT_CORE].rlim_cur)
 		dump.u_ssize = 0;
 
 /* make sure we actually have a data and stack area to dump */
@@ -281,7 +281,7 @@ static int load_aout_binary(struct linux
 	 * size limits imposed on them by creating programs with large
 	 * arrays in the data or bss.
 	 */
-	rlim = current->rlim[RLIMIT_DATA].rlim_cur;
+	rlim = current->signal->rlim[RLIMIT_DATA].rlim_cur;
 	if (rlim >= RLIM_INFINITY)
 		rlim = ~0;
 	if (ex.a_data + ex.a_bss > rlim)
diff -puN fs/binfmt_aout.c~make-rlimit-settings-per-process-instead-of-per-thread fs/binfmt_aout.c
--- 25/fs/binfmt_aout.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.164797344 -0700
+++ 25-akpm/fs/binfmt_aout.c	2004-10-01 20:15:09.222788528 -0700
@@ -118,22 +118,22 @@ static int aout_core_dump(long signr, st
    if we wrote the stack, but not the data area.  */
 #ifdef __sparc__
 	if ((dump.u_dsize+dump.u_ssize) >
-	    current->rlim[RLIMIT_CORE].rlim_cur)
+	    current->signal->rlim[RLIMIT_CORE].rlim_cur)
 		dump.u_dsize = 0;
 #else
 	if ((dump.u_dsize+dump.u_ssize+1) * PAGE_SIZE >
-	    current->rlim[RLIMIT_CORE].rlim_cur)
+	    current->signal->rlim[RLIMIT_CORE].rlim_cur)
 		dump.u_dsize = 0;
 #endif
 
 /* Make sure we have enough room to write the stack and data areas. */
 #ifdef __sparc__
 	if ((dump.u_ssize) >
-	    current->rlim[RLIMIT_CORE].rlim_cur)
+	    current->signal->rlim[RLIMIT_CORE].rlim_cur)
 		dump.u_ssize = 0;
 #else
 	if ((dump.u_ssize+1) * PAGE_SIZE >
-	    current->rlim[RLIMIT_CORE].rlim_cur)
+	    current->signal->rlim[RLIMIT_CORE].rlim_cur)
 		dump.u_ssize = 0;
 #endif
 
@@ -278,7 +278,7 @@ static int load_aout_binary(struct linux
 	 * size limits imposed on them by creating programs with large
 	 * arrays in the data or bss.
 	 */
-	rlim = current->rlim[RLIMIT_DATA].rlim_cur;
+	rlim = current->signal->rlim[RLIMIT_DATA].rlim_cur;
 	if (rlim >= RLIM_INFINITY)
 		rlim = ~0;
 	if (ex.a_data + ex.a_bss > rlim)
diff -puN fs/binfmt_elf.c~make-rlimit-settings-per-process-instead-of-per-thread fs/binfmt_elf.c
--- 25/fs/binfmt_elf.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.165797192 -0700
+++ 25-akpm/fs/binfmt_elf.c	2004-10-01 20:15:09.223788376 -0700
@@ -1314,7 +1314,7 @@ static int elf_core_dump(long signr, str
 	struct vm_area_struct *vma;
 	struct elfhdr *elf = NULL;
 	off_t offset = 0, dataoff;
-	unsigned long limit = current->rlim[RLIMIT_CORE].rlim_cur;
+	unsigned long limit = current->signal->rlim[RLIMIT_CORE].rlim_cur;
 	int numnote;
 	struct memelfnote *notes = NULL;
 	struct elf_prstatus *prstatus = NULL;	/* NT_PRSTATUS */
diff -puN fs/binfmt_flat.c~make-rlimit-settings-per-process-instead-of-per-thread fs/binfmt_flat.c
--- 25/fs/binfmt_flat.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.167796888 -0700
+++ 25-akpm/fs/binfmt_flat.c	2004-10-01 20:15:09.224788224 -0700
@@ -486,7 +486,7 @@ static int load_flat_file(struct linux_b
 	 * size limits imposed on them by creating programs with large
 	 * arrays in the data or bss.
 	 */
-	rlim = current->rlim[RLIMIT_DATA].rlim_cur;
+	rlim = current->signal->rlim[RLIMIT_DATA].rlim_cur;
 	if (rlim >= RLIM_INFINITY)
 		rlim = ~0;
 	if (data_len + bss_len > rlim)
diff -puN fs/buffer.c~make-rlimit-settings-per-process-instead-of-per-thread fs/buffer.c
--- 25/fs/buffer.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.168796736 -0700
+++ 25-akpm/fs/buffer.c	2004-10-01 20:15:09.226787920 -0700
@@ -2232,7 +2232,7 @@ int generic_cont_expand(struct inode *in
 	int err;
 
 	err = -EFBIG;
-        limit = current->rlim[RLIMIT_FSIZE].rlim_cur;
+        limit = current->signal->rlim[RLIMIT_FSIZE].rlim_cur;
 	if (limit != RLIM_INFINITY && size > (loff_t)limit) {
 		send_sig(SIGXFSZ, current, 0);
 		goto out;
diff -puN fs/exec.c~make-rlimit-settings-per-process-instead-of-per-thread fs/exec.c
--- 25/fs/exec.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.170796432 -0700
+++ 25-akpm/fs/exec.c	2004-10-01 20:15:09.228787616 -0700
@@ -377,7 +377,7 @@ int setup_arg_pages(struct linux_binprm 
 	bprm->p = PAGE_SIZE * i - offset;
 
 	/* Limit stack size to 1GB */
-	stack_base = current->rlim[RLIMIT_STACK].rlim_max;
+	stack_base = current->signal->rlim[RLIMIT_STACK].rlim_max;
 	if (stack_base > (1 << 30))
 		stack_base = 1 << 30;
 	stack_base = PAGE_ALIGN(STACK_TOP - stack_base);
@@ -1393,7 +1393,7 @@ int do_coredump(long signr, int exit_cod
 	current->signal->group_exit_code = exit_code;
 	coredump_wait(mm);
 
-	if (current->rlim[RLIMIT_CORE].rlim_cur < binfmt->min_coredump)
+	if (current->signal->rlim[RLIMIT_CORE].rlim_cur < binfmt->min_coredump)
 		goto fail_unlock;
 
 	/*
diff -puN fs/fcntl.c~make-rlimit-settings-per-process-instead-of-per-thread fs/fcntl.c
--- 25/fs/fcntl.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.171796280 -0700
+++ 25-akpm/fs/fcntl.c	2004-10-01 20:15:09.228787616 -0700
@@ -86,7 +86,7 @@ static int locate_fd(struct files_struct
 	int error;
 
 	error = -EINVAL;
-	if (orig_start >= current->rlim[RLIMIT_NOFILE].rlim_cur)
+	if (orig_start >= current->signal->rlim[RLIMIT_NOFILE].rlim_cur)
 		goto out;
 
 repeat:
@@ -105,7 +105,7 @@ repeat:
 	}
 	
 	error = -EMFILE;
-	if (newfd >= current->rlim[RLIMIT_NOFILE].rlim_cur)
+	if (newfd >= current->signal->rlim[RLIMIT_NOFILE].rlim_cur)
 		goto out;
 
 	error = expand_files(files, newfd);
@@ -161,7 +161,7 @@ asmlinkage long sys_dup2(unsigned int ol
 	if (newfd == oldfd)
 		goto out_unlock;
 	err = -EBADF;
-	if (newfd >= current->rlim[RLIMIT_NOFILE].rlim_cur)
+	if (newfd >= current->signal->rlim[RLIMIT_NOFILE].rlim_cur)
 		goto out_unlock;
 	get_file(file);			/* We are now finished with oldfd */
 
diff -puN fs/nfs/direct.c~make-rlimit-settings-per-process-instead-of-per-thread fs/nfs/direct.c
--- 25/fs/nfs/direct.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.173795976 -0700
+++ 25-akpm/fs/nfs/direct.c	2004-10-01 20:15:09.229787464 -0700
@@ -545,7 +545,7 @@ nfs_file_direct_write(struct kiocb *iocb
 {
 	ssize_t retval = -EINVAL;
 	loff_t *ppos = &iocb->ki_pos;
-	unsigned long limit = current->rlim[RLIMIT_FSIZE].rlim_cur;
+	unsigned long limit = current->signal->rlim[RLIMIT_FSIZE].rlim_cur;
 	struct file *file = iocb->ki_filp;
 	struct nfs_open_context *ctx =
 			(struct nfs_open_context *) file->private_data;
diff -puN fs/nfsd/nfssvc.c~make-rlimit-settings-per-process-instead-of-per-thread fs/nfsd/nfssvc.c
--- 25/fs/nfsd/nfssvc.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.174795824 -0700
+++ 25-akpm/fs/nfsd/nfssvc.c	2004-10-01 20:15:09.229787464 -0700
@@ -180,7 +180,6 @@ nfsd(struct svc_rqst *rqstp)
 	/* Lock module and set up kernel thread */
 	lock_kernel();
 	daemonize("nfsd");
-	current->rlim[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;
 
 	/* After daemonize() this kernel thread shares current->fs
 	 * with the init process. We need to create files with a
diff -puN fs/open.c~make-rlimit-settings-per-process-instead-of-per-thread fs/open.c
--- 25/fs/open.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.175795672 -0700
+++ 25-akpm/fs/open.c	2004-10-01 20:15:09.230787312 -0700
@@ -852,7 +852,7 @@ repeat:
 	 * N.B. For clone tasks sharing a files structure, this test
 	 * will limit the total number of files that can be opened.
 	 */
-	if (fd >= current->rlim[RLIMIT_NOFILE].rlim_cur)
+	if (fd >= current->signal->rlim[RLIMIT_NOFILE].rlim_cur)
 		goto out;
 
 	/* Do we need to expand the fdset array? */
diff -puN fs/proc/array.c~make-rlimit-settings-per-process-instead-of-per-thread fs/proc/array.c
--- 25/fs/proc/array.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.177795368 -0700
+++ 25-akpm/fs/proc/array.c	2004-10-01 20:15:09.231787160 -0700
@@ -313,6 +313,7 @@ int proc_pid_stat(struct task_struct *ta
 	struct mm_struct *mm;
 	unsigned long long start_time;
 	unsigned long cmin_flt = 0, cmaj_flt = 0, cutime = 0, cstime = 0;
+	unsigned long rsslim = 0;
 	char tcomm[sizeof(task->comm)];
 
 	state = *get_task_state(task);
@@ -347,6 +348,7 @@ int proc_pid_stat(struct task_struct *ta
 		cmaj_flt = task->signal->cmaj_flt;
 		cutime = task->signal->cutime;
 		cstime = task->signal->cstime;
+		rsslim = task->signal->rlim[RLIMIT_RSS].rlim_cur;
 	}
 	read_unlock(&tasklist_lock);
 
@@ -389,7 +391,7 @@ int proc_pid_stat(struct task_struct *ta
 		start_time,
 		vsize,
 		mm ? mm->rss : 0, /* you might want to shift this left 3 */
-		task->rlim[RLIMIT_RSS].rlim_cur,
+	        rsslim,
 		mm ? mm->start_code : 0,
 		mm ? mm->end_code : 0,
 		mm ? mm->start_stack : 0,
diff -puN include/linux/init_task.h~make-rlimit-settings-per-process-instead-of-per-thread include/linux/init_task.h
--- 25/include/linux/init_task.h~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.178795216 -0700
+++ 25-akpm/include/linux/init_task.h	2004-10-01 20:15:09.231787160 -0700
@@ -50,6 +50,7 @@
 		.list = LIST_HEAD_INIT(sig.shared_pending.list),	\
 		.signal =  {{0}}}, \
 	.posix_timers	 = LIST_HEAD_INIT(sig.posix_timers),		\
+	.rlim		= INIT_RLIMITS,					\
 }
 
 #define INIT_SIGHAND(sighand) {	\
@@ -96,7 +97,6 @@ extern struct group_info init_groups;
 	.cap_inheritable = CAP_INIT_INH_SET,				\
 	.cap_permitted	= CAP_FULL_SET,					\
 	.keep_capabilities = 0,						\
-	.rlim		= INIT_RLIMITS,					\
 	.user		= INIT_USER,					\
 	.comm		= "swapper",					\
 	.thread		= INIT_THREAD,					\
diff -puN include/linux/mm.h~make-rlimit-settings-per-process-instead-of-per-thread include/linux/mm.h
--- 25/include/linux/mm.h~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.179795064 -0700
+++ 25-akpm/include/linux/mm.h	2004-10-01 20:15:09.232787008 -0700
@@ -540,7 +540,7 @@ static inline int can_do_mlock(void)
 {
 	if (capable(CAP_IPC_LOCK))
 		return 1;
-	if (current->rlim[RLIMIT_MEMLOCK].rlim_cur != 0)
+	if (current->signal->rlim[RLIMIT_MEMLOCK].rlim_cur != 0)
 		return 1;
 	return 0;
 }
diff -puN include/linux/sched.h~make-rlimit-settings-per-process-instead-of-per-thread include/linux/sched.h
--- 25/include/linux/sched.h~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.181794760 -0700
+++ 25-akpm/include/linux/sched.h	2004-10-01 20:15:09.233786856 -0700
@@ -312,6 +312,17 @@ struct signal_struct {
 	unsigned long utime, stime, cutime, cstime;
 	unsigned long nvcsw, nivcsw, cnvcsw, cnivcsw;
 	unsigned long min_flt, maj_flt, cmin_flt, cmaj_flt;
+
+	/*
+	 * We don't bother to synchronize most readers of this at all,
+	 * because there is no reader checking a limit that actually needs
+	 * to get both rlim_cur and rlim_max atomically, and either one
+	 * alone is a single word that can safely be read normally.
+	 * getrlimit/setrlimit use task_lock(current->group_leader) to
+	 * protect this instead of the siglock, because they really
+	 * have no need to disable irqs.
+	 */
+	struct rlimit rlim[RLIM_NLIMITS];
 };
 
 /*
@@ -518,8 +529,6 @@ struct task_struct {
 	kernel_cap_t   cap_effective, cap_inheritable, cap_permitted;
 	unsigned keep_capabilities:1;
 	struct user_struct *user;
-/* limits */
-	struct rlimit rlim[RLIM_NLIMITS];
 	unsigned short used_math;
 	char comm[16];
 /* file system info */
diff -puN include/linux/security.h~make-rlimit-settings-per-process-instead-of-per-thread include/linux/security.h
--- 25/include/linux/security.h~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.183794456 -0700
+++ 25-akpm/include/linux/security.h	2004-10-01 20:15:09.235786552 -0700
@@ -582,7 +582,7 @@ struct swap_info_struct;
  * @task_setrlimit:
  *	Check permission before setting the resource limits of the current
  *	process for @resource to @new_rlim.  The old resource limit values can
- *	be examined by dereferencing (current->rlim + resource).
+ *	be examined by dereferencing (current->signal->rlim + resource).
  *	@resource contains the resource whose limit is being set.
  *	@new_rlim contains the new limits for @resource.
  *	Return 0 if permission is granted.
diff -puN ipc/mqueue.c~make-rlimit-settings-per-process-instead-of-per-thread ipc/mqueue.c
--- 25/ipc/mqueue.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.184794304 -0700
+++ 25-akpm/ipc/mqueue.c	2004-10-01 20:15:09.236786400 -0700
@@ -145,7 +145,7 @@ static struct inode *mqueue_get_inode(st
 			spin_lock(&mq_lock);
 			if (u->mq_bytes + mq_bytes < u->mq_bytes ||
 		 	    u->mq_bytes + mq_bytes >
-			    p->rlim[RLIMIT_MSGQUEUE].rlim_cur) {
+			    p->signal->rlim[RLIMIT_MSGQUEUE].rlim_cur) {
 				spin_unlock(&mq_lock);
 				goto out_inode;
 			}
diff -puN kernel/acct.c~make-rlimit-settings-per-process-instead-of-per-thread kernel/acct.c
--- 25/kernel/acct.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.186794000 -0700
+++ 25-akpm/kernel/acct.c	2004-10-01 20:15:09.237786248 -0700
@@ -480,11 +480,11 @@ static void do_acct_process(long exitcod
 	/*
  	 * Accounting records are not subject to resource limits.
  	 */
-	flim = current->rlim[RLIMIT_FSIZE].rlim_cur;
-	current->rlim[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;
+	flim = current->signal->rlim[RLIMIT_FSIZE].rlim_cur;
+	current->signal->rlim[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;
 	file->f_op->write(file, (char *)&ac,
 			       sizeof(acct_t), &file->f_pos);
-	current->rlim[RLIMIT_FSIZE].rlim_cur = flim;
+	current->signal->rlim[RLIMIT_FSIZE].rlim_cur = flim;
 	set_fs(fs);
 }
 
diff -puN kernel/exit.c~make-rlimit-settings-per-process-instead-of-per-thread kernel/exit.c
--- 25/kernel/exit.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.187793848 -0700
+++ 25-akpm/kernel/exit.c	2004-10-01 20:15:09.238786096 -0700
@@ -237,7 +237,8 @@ void reparent_to_init(void)
 	/* rt_priority? */
 	/* signals? */
 	security_task_reparent_to_init(current);
-	memcpy(current->rlim, init_task.rlim, sizeof(*(current->rlim)));
+	memcpy(current->signal->rlim, init_task.signal->rlim,
+	       sizeof(current->signal->rlim));
 	atomic_inc(&(INIT_USER->__count));
 	switch_uid(INIT_USER);
 
@@ -761,7 +762,6 @@ static void exit_notify(struct task_stru
 	 */
 	tsk->it_virt_value = 0;
 	tsk->it_prof_value = 0;
-	tsk->rlim[RLIMIT_CPU].rlim_cur = RLIM_INFINITY;
 
 	write_unlock_irq(&tasklist_lock);
 
diff -puN kernel/fork.c~make-rlimit-settings-per-process-instead-of-per-thread kernel/fork.c
--- 25/kernel/fork.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.188793696 -0700
+++ 25-akpm/kernel/fork.c	2004-10-01 20:15:09.239785944 -0700
@@ -249,8 +249,8 @@ void __init fork_init(unsigned long memp
 	if(max_threads < 20)
 		max_threads = 20;
 
-	init_task.rlim[RLIMIT_NPROC].rlim_cur = max_threads/2;
-	init_task.rlim[RLIMIT_NPROC].rlim_max = max_threads/2;
+	init_task.signal->rlim[RLIMIT_NPROC].rlim_cur = max_threads/2;
+	init_task.signal->rlim[RLIMIT_NPROC].rlim_max = max_threads/2;
 }
 
 static struct task_struct *dup_task_struct(struct task_struct *orig)
@@ -872,6 +872,10 @@ static inline int copy_signal(unsigned l
 	sig->nvcsw = sig->nivcsw = sig->cnvcsw = sig->cnivcsw = 0;
 	sig->min_flt = sig->maj_flt = sig->cmin_flt = sig->cmaj_flt = 0;
 
+	task_lock(current->group_leader);
+	memcpy(sig->rlim, current->signal->rlim, sizeof sig->rlim);
+	task_unlock(current->group_leader);
+
 	return 0;
 }
 
@@ -941,7 +945,7 @@ static task_t *copy_process(unsigned lon
 
 	retval = -EAGAIN;
 	if (atomic_read(&p->user->processes) >=
-			p->rlim[RLIMIT_NPROC].rlim_cur) {
+			p->signal->rlim[RLIMIT_NPROC].rlim_cur) {
 		if (!capable(CAP_SYS_ADMIN) && !capable(CAP_SYS_RESOURCE) &&
 				p->user != &root_user)
 			goto bad_fork_free;
diff -puN kernel/signal.c~make-rlimit-settings-per-process-instead-of-per-thread kernel/signal.c
--- 25/kernel/signal.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.190793392 -0700
+++ 25-akpm/kernel/signal.c	2004-10-01 20:15:09.241785640 -0700
@@ -269,7 +269,7 @@ static struct sigqueue *__sigqueue_alloc
 	struct sigqueue *q = NULL;
 
 	if (atomic_read(&current->user->sigpending) <
-			current->rlim[RLIMIT_SIGPENDING].rlim_cur)
+			current->signal->rlim[RLIMIT_SIGPENDING].rlim_cur)
 		q = kmem_cache_alloc(sigqueue_cachep, GFP_ATOMIC);
 	if (q) {
 		INIT_LIST_HEAD(&q->list);
@@ -764,7 +764,7 @@ static int send_signal(int sig, struct s
 	   pass on the info struct.  */
 
 	if (atomic_read(&t->user->sigpending) <
-			t->rlim[RLIMIT_SIGPENDING].rlim_cur)
+			t->signal->rlim[RLIMIT_SIGPENDING].rlim_cur)
 		q = kmem_cache_alloc(sigqueue_cachep, GFP_ATOMIC);
 
 	if (q) {
diff -puN kernel/sys.c~make-rlimit-settings-per-process-instead-of-per-thread kernel/sys.c
--- 25/kernel/sys.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.192793088 -0700
+++ 25-akpm/kernel/sys.c	2004-10-01 20:15:09.243785336 -0700
@@ -649,7 +649,7 @@ static int set_user(uid_t new_ruid, int 
 		return -EAGAIN;
 
 	if (atomic_read(&new_user->processes) >=
-				current->rlim[RLIMIT_NPROC].rlim_cur &&
+				current->signal->rlim[RLIMIT_NPROC].rlim_cur &&
 			new_user != &root_user) {
 		free_uid(new_user);
 		return -EAGAIN;
@@ -1496,9 +1496,13 @@ asmlinkage long sys_getrlimit(unsigned i
 {
 	if (resource >= RLIM_NLIMITS)
 		return -EINVAL;
-	else
-		return copy_to_user(rlim, current->rlim + resource, sizeof(*rlim))
-			? -EFAULT : 0;
+	else {
+		struct rlimit value;
+		task_lock(current->group_leader);
+		value = current->signal->rlim[resource];
+		task_unlock(current->group_leader);
+		return copy_to_user(rlim, &value, sizeof(*rlim)) ? -EFAULT : 0;
+	}
 }
 
 #ifdef __ARCH_WANT_SYS_OLD_GETRLIMIT
@@ -1513,7 +1517,9 @@ asmlinkage long sys_old_getrlimit(unsign
 	if (resource >= RLIM_NLIMITS)
 		return -EINVAL;
 
-	memcpy(&x, current->rlim + resource, sizeof(*rlim));
+	task_lock(current->group_leader);
+	x = current->signal->rlim[resource];
+	task_unlock(current->group_leader);
 	if(x.rlim_cur > 0x7FFFFFFF)
 		x.rlim_cur = 0x7FFFFFFF;
 	if(x.rlim_max > 0x7FFFFFFF)
@@ -1534,21 +1540,20 @@ asmlinkage long sys_setrlimit(unsigned i
 		return -EFAULT;
        if (new_rlim.rlim_cur > new_rlim.rlim_max)
                return -EINVAL;
-	old_rlim = current->rlim + resource;
-	if (((new_rlim.rlim_cur > old_rlim->rlim_max) ||
-	     (new_rlim.rlim_max > old_rlim->rlim_max)) &&
+	old_rlim = current->signal->rlim + resource;
+	if ((new_rlim.rlim_max > old_rlim->rlim_max) &&
 	    !capable(CAP_SYS_RESOURCE))
 		return -EPERM;
-	if (resource == RLIMIT_NOFILE) {
-		if (new_rlim.rlim_cur > NR_OPEN || new_rlim.rlim_max > NR_OPEN)
+	if (resource == RLIMIT_NOFILE && new_rlim.rlim_max > NR_OPEN)
 			return -EPERM;
-	}
 
 	retval = security_task_setrlimit(resource, &new_rlim);
 	if (retval)
 		return retval;
 
+	task_lock(current->group_leader);
 	*old_rlim = new_rlim;
+	task_unlock(current->group_leader);
 	return 0;
 }
 
diff -puN kernel/timer.c~make-rlimit-settings-per-process-instead-of-per-thread kernel/timer.c
--- 25/kernel/timer.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.193792936 -0700
+++ 25-akpm/kernel/timer.c	2004-10-01 20:15:09.244785184 -0700
@@ -805,12 +805,13 @@ static inline void do_process_times(stru
 
 	psecs = (p->utime += user);
 	psecs += (p->stime += system);
-	if (psecs / HZ >= p->rlim[RLIMIT_CPU].rlim_cur) {
+	if (!unlikely(p->state & (TASK_DEAD|TASK_ZOMBIE)) &&
+	    psecs / HZ >= p->signal->rlim[RLIMIT_CPU].rlim_cur) {
 		/* Send SIGXCPU every second.. */
 		if (!(psecs % HZ))
 			send_sig(SIGXCPU, p, 1);
 		/* and SIGKILL when we go over max.. */
-		if (psecs / HZ >= p->rlim[RLIMIT_CPU].rlim_max)
+		if (psecs / HZ >= p->signal->rlim[RLIMIT_CPU].rlim_max)
 			send_sig(SIGKILL, p, 1);
 	}
 }
diff -puN mm/filemap.c~make-rlimit-settings-per-process-instead-of-per-thread mm/filemap.c
--- 25/mm/filemap.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.195792632 -0700
+++ 25-akpm/mm/filemap.c	2004-10-01 20:15:09.246784880 -0700
@@ -1804,7 +1804,7 @@ filemap_set_next_iovec(const struct iove
 inline int generic_write_checks(struct file *file, loff_t *pos, size_t *count, int isblk)
 {
 	struct inode *inode = file->f_mapping->host;
-	unsigned long limit = current->rlim[RLIMIT_FSIZE].rlim_cur;
+	unsigned long limit = current->signal->rlim[RLIMIT_FSIZE].rlim_cur;
 
         if (unlikely(*pos < 0))
                 return -EINVAL;
diff -puN mm/memory.c~make-rlimit-settings-per-process-instead-of-per-thread mm/memory.c
--- 25/mm/memory.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.196792480 -0700
+++ 25-akpm/mm/memory.c	2004-10-01 20:15:09.247784728 -0700
@@ -1236,7 +1236,7 @@ int vmtruncate(struct inode * inode, lof
 	goto out_truncate;
 
 do_expand:
-	limit = current->rlim[RLIMIT_FSIZE].rlim_cur;
+	limit = current->signal->rlim[RLIMIT_FSIZE].rlim_cur;
 	if (limit != RLIM_INFINITY && offset > limit)
 		goto out_sig;
 	if (offset > inode->i_sb->s_maxbytes)
diff -puN mm/mlock.c~make-rlimit-settings-per-process-instead-of-per-thread mm/mlock.c
--- 25/mm/mlock.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.197792328 -0700
+++ 25-akpm/mm/mlock.c	2004-10-01 20:15:09.248784576 -0700
@@ -115,7 +115,7 @@ asmlinkage long sys_mlock(unsigned long 
 	locked = len >> PAGE_SHIFT;
 	locked += current->mm->locked_vm;
 
-	lock_limit = current->rlim[RLIMIT_MEMLOCK].rlim_cur;
+	lock_limit = current->signal->rlim[RLIMIT_MEMLOCK].rlim_cur;
 	lock_limit >>= PAGE_SHIFT;
 
 	/* check against resource limits */
@@ -176,7 +176,7 @@ asmlinkage long sys_mlockall(int flags)
 
 	down_write(&current->mm->mmap_sem);
 
-	lock_limit = current->rlim[RLIMIT_MEMLOCK].rlim_cur;
+	lock_limit = current->signal->rlim[RLIMIT_MEMLOCK].rlim_cur;
 	lock_limit >>= PAGE_SHIFT;
 
 	ret = -ENOMEM;
@@ -211,7 +211,7 @@ int user_shm_lock(size_t size, struct us
 
 	spin_lock(&shmlock_user_lock);
 	locked = size >> PAGE_SHIFT;
-	lock_limit = current->rlim[RLIMIT_MEMLOCK].rlim_cur;
+	lock_limit = current->signal->rlim[RLIMIT_MEMLOCK].rlim_cur;
 	lock_limit >>= PAGE_SHIFT;
 	if (locked + user->locked_shm > lock_limit && !capable(CAP_IPC_LOCK))
 		goto out;
diff -puN mm/mmap.c~make-rlimit-settings-per-process-instead-of-per-thread mm/mmap.c
--- 25/mm/mmap.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.199792024 -0700
+++ 25-akpm/mm/mmap.c	2004-10-01 20:15:09.250784272 -0700
@@ -136,7 +136,7 @@ asmlinkage unsigned long sys_brk(unsigne
 	}
 
 	/* Check against rlimit.. */
-	rlim = current->rlim[RLIMIT_DATA].rlim_cur;
+	rlim = current->signal->rlim[RLIMIT_DATA].rlim_cur;
 	if (rlim < RLIM_INFINITY && brk - mm->start_data > rlim)
 		goto out;
 
@@ -831,7 +831,7 @@ unsigned long do_mmap_pgoff(struct file 
 	if (vm_flags & VM_LOCKED) {
 		unsigned long locked, lock_limit;
 		locked = mm->locked_vm << PAGE_SHIFT;
-		lock_limit = current->rlim[RLIMIT_MEMLOCK].rlim_cur;
+		lock_limit = current->signal->rlim[RLIMIT_MEMLOCK].rlim_cur;
 		locked += len;
 		if (locked > lock_limit && !capable(CAP_IPC_LOCK))
 			return -EAGAIN;
@@ -903,7 +903,7 @@ munmap_back:
 
 	/* Check against address space limit. */
 	if ((mm->total_vm << PAGE_SHIFT) + len
-	    > current->rlim[RLIMIT_AS].rlim_cur)
+	    > current->signal->rlim[RLIMIT_AS].rlim_cur)
 		return -ENOMEM;
 
 	if (accountable && (!(flags & MAP_NORESERVE) ||
@@ -1348,9 +1348,9 @@ int expand_stack(struct vm_area_struct *
 		return -ENOMEM;
 	}
 	
-	if (address - vma->vm_start > current->rlim[RLIMIT_STACK].rlim_cur ||
+	if (address - vma->vm_start > current->signal->rlim[RLIMIT_STACK].rlim_cur ||
 			((vma->vm_mm->total_vm + grow) << PAGE_SHIFT) >
-			current->rlim[RLIMIT_AS].rlim_cur) {
+			current->signal->rlim[RLIMIT_AS].rlim_cur) {
 		anon_vma_unlock(vma);
 		vm_unacct_memory(grow);
 		return -ENOMEM;
@@ -1410,9 +1410,9 @@ int expand_stack(struct vm_area_struct *
 		return -ENOMEM;
 	}
 	
-	if (vma->vm_end - address > current->rlim[RLIMIT_STACK].rlim_cur ||
+	if (vma->vm_end - address > current->signal->rlim[RLIMIT_STACK].rlim_cur ||
 			((vma->vm_mm->total_vm + grow) << PAGE_SHIFT) >
-			current->rlim[RLIMIT_AS].rlim_cur) {
+			current->signal->rlim[RLIMIT_AS].rlim_cur) {
 		anon_vma_unlock(vma);
 		vm_unacct_memory(grow);
 		return -ENOMEM;
@@ -1758,7 +1758,7 @@ unsigned long do_brk(unsigned long addr,
 	if (mm->def_flags & VM_LOCKED) {
 		unsigned long locked, lock_limit;
 		locked = mm->locked_vm << PAGE_SHIFT;
-		lock_limit = current->rlim[RLIMIT_MEMLOCK].rlim_cur;
+		lock_limit = current->signal->rlim[RLIMIT_MEMLOCK].rlim_cur;
 		locked += len;
 		if (locked > lock_limit && !capable(CAP_IPC_LOCK))
 			return -EAGAIN;
@@ -1777,7 +1777,7 @@ unsigned long do_brk(unsigned long addr,
 
 	/* Check against address space limits *after* clearing old maps... */
 	if ((mm->total_vm << PAGE_SHIFT) + len
-	    > current->rlim[RLIMIT_AS].rlim_cur)
+	    > current->signal->rlim[RLIMIT_AS].rlim_cur)
 		return -ENOMEM;
 
 	if (mm->map_count > sysctl_max_map_count)
diff -puN mm/mremap.c~make-rlimit-settings-per-process-instead-of-per-thread mm/mremap.c
--- 25/mm/mremap.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.200791872 -0700
+++ 25-akpm/mm/mremap.c	2004-10-01 20:15:09.250784272 -0700
@@ -327,7 +327,7 @@ unsigned long do_mremap(unsigned long ad
 	if (vma->vm_flags & VM_LOCKED) {
 		unsigned long locked, lock_limit;
 		locked = current->mm->locked_vm << PAGE_SHIFT;
-		lock_limit = current->rlim[RLIMIT_MEMLOCK].rlim_cur;
+		lock_limit = current->signal->rlim[RLIMIT_MEMLOCK].rlim_cur;
 		locked += new_len - old_len;
 		ret = -EAGAIN;
 		if (locked > lock_limit && !capable(CAP_IPC_LOCK))
@@ -335,7 +335,7 @@ unsigned long do_mremap(unsigned long ad
 	}
 	ret = -ENOMEM;
 	if ((current->mm->total_vm << PAGE_SHIFT) + (new_len - old_len)
-	    > current->rlim[RLIMIT_AS].rlim_cur)
+	    > current->signal->rlim[RLIMIT_AS].rlim_cur)
 		goto out;
 
 	if (vma->vm_flags & VM_ACCOUNT) {
diff -puN mm/nommu.c~make-rlimit-settings-per-process-instead-of-per-thread mm/nommu.c
--- 25/mm/nommu.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.202791568 -0700
+++ 25-akpm/mm/nommu.c	2004-10-01 20:15:09.251784120 -0700
@@ -57,7 +57,7 @@ int vmtruncate(struct inode *inode, loff
 	goto out_truncate;
 
 do_expand:
-	limit = current->rlim[RLIMIT_FSIZE].rlim_cur;
+	limit = current->signal->rlim[RLIMIT_FSIZE].rlim_cur;
 	if (limit != RLIM_INFINITY && offset > limit)
 		goto out_sig;
 	if (offset > inode->i_sb->s_maxbytes)
diff -puN security/selinux/hooks.c~make-rlimit-settings-per-process-instead-of-per-thread security/selinux/hooks.c
--- 25/security/selinux/hooks.c~make-rlimit-settings-per-process-instead-of-per-thread	2004-10-01 20:15:09.203791416 -0700
+++ 25-akpm/security/selinux/hooks.c	2004-10-01 20:15:09.254783664 -0700
@@ -1909,8 +1909,8 @@ static void selinux_bprm_apply_creds(str
 				  PROCESS__RLIMITINH, NULL, NULL);
 		if (rc) {
 			for (i = 0; i < RLIM_NLIMITS; i++) {
-				rlim = current->rlim + i;
-				initrlim = init_task.rlim+i;
+				rlim = current->signal->rlim + i;
+				initrlim = init_task.signal->rlim+i;
 				rlim->rlim_cur = min(rlim->rlim_max,initrlim->rlim_cur);
 			}
 		}
@@ -2689,7 +2689,7 @@ static int selinux_task_setnice(struct t
 
 static int selinux_task_setrlimit(unsigned int resource, struct rlimit *new_rlim)
 {
-	struct rlimit *old_rlim = current->rlim + resource;
+	struct rlimit *old_rlim = current->signal->rlim + resource;
 	int rc;
 
 	rc = secondary_ops->task_setrlimit(resource, new_rlim);
_
