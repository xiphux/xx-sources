bk://bart.bkbits.net/ide-dev-2.6
bzolnier@trik.(none)|ChangeSet|20041010182512|48254 bzolnier

# This is a BitKeeper generated diff -Nru style patch.
#
# ChangeSet
#   2004/10/10 20:25:12+02:00 bzolnier@trik.(none) 
#   Merge
# 
# drivers/ide/ide-taskfile.c
#   2004/10/10 20:25:08+02:00 bzolnier@trik.(none) +0 -0
#   SCCS merged
# 
# drivers/ide/pci/pdc202xx_old.h
#   2004/10/10 20:23:01+02:00 bzolnier@trik.(none) +0 -0
#   Auto merged
# 
# drivers/ide/pci/pdc202xx_old.c
#   2004/10/10 20:23:01+02:00 bzolnier@trik.(none) +0 -0
#   Auto merged
# 
# drivers/ide/pci/cmd64x.c
#   2004/10/10 20:23:01+02:00 bzolnier@trik.(none) +0 -0
#   Auto merged
# 
# drivers/ide/ide-dma.c
#   2004/10/10 20:23:01+02:00 bzolnier@trik.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/10/10 15:31:47+02:00 bzolnier@trik.(none) 
#   [ide] hpt34x: kill hpt34x.h
# 
# drivers/ide/pci/hpt34x.c
#   2004/10/10 15:31:30+02:00 bzolnier@trik.(none) +12 -2
#   [ide] hpt34x: kill hpt34x.h
# 
# BitKeeper/deleted/.del-hpt34x.h~28b22a2b22be8c55
#   2004/10/10 15:27:29+02:00 bzolnier@trik.(none) +0 -0
#   Delete: drivers/ide/pci/hpt34x.h
# 
# ChangeSet
#   2004/10/10 15:24:38+02:00 bzolnier@trik.(none) 
#   [ide] hpt34x: kill SPLIT_BYTE()
# 
# drivers/ide/pci/hpt34x.h
#   2004/10/10 15:24:21+02:00 bzolnier@trik.(none) +0 -4
#   [ide] hpt34x: kill SPLIT_BYTE()
# 
# drivers/ide/pci/hpt34x.c
#   2004/10/10 15:24:21+02:00 bzolnier@trik.(none) +2 -1
#   [ide] hpt34x: kill SPLIT_BYTE()
# 
# ChangeSet
#   2004/10/10 15:12:17+02:00 bzolnier@trik.(none) 
#   [ide] atiixp: simplify atiixp_config_drive_for_dma()
# 
# drivers/ide/pci/atiixp.c
#   2004/10/10 15:11:59+02:00 bzolnier@trik.(none) +2 -4
#   [ide] atiixp: simplify atiixp_config_drive_for_dma()
# 
# ChangeSet
#   2004/10/10 02:58:31+02:00 bzolnier@trik.(none) 
#   [ide] triflex: simplify triflex_config_drive_for_dma()
# 
# drivers/ide/pci/triflex.c
#   2004/10/10 02:58:09+02:00 bzolnier@trik.(none) +3 -5
#   [ide] triflex: simplify triflex_config_drive_for_dma()
# 
# ChangeSet
#   2004/10/10 02:53:12+02:00 bzolnier@trik.(none) 
#   [ide] triflex: use ide_use_dma()
# 
# drivers/ide/pci/triflex.c
#   2004/10/10 02:52:52+02:00 bzolnier@trik.(none) +8 -17
#   [ide] triflex: use ide_use_dma()
# 
# ChangeSet
#   2004/10/08 22:21:48+02:00 bzolnier@trik.(none) 
#   [ide] kill /proc/ide/hd?/settings:lun
#   
#   The only user of drive->lun (ide-probe) always got value of zero.
# 
# include/linux/ide.h
#   2004/10/08 22:21:26+02:00 bzolnier@trik.(none) +0 -1
#   [ide] kill /proc/ide/hd?/settings:lun
# 
# drivers/ide/ide-probe.c
#   2004/10/08 22:21:26+02:00 bzolnier@trik.(none) +2 -2
#   [ide] kill /proc/ide/hd?/settings:lun
# 
# drivers/ide/ide-disk.c
#   2004/10/08 22:21:26+02:00 bzolnier@trik.(none) +0 -1
#   [ide] kill /proc/ide/hd?/settings:lun
# 
# ChangeSet
#   2004/10/08 22:10:29+02:00 bzolnier@trik.(none) 
#   [ide] kill /proc/ide/hd?/settings:address & HDIO_[GET,SET]_ADDRESS ioctls
#   
#   ide-disk driver always uses LBA48 when available so messing with
#   drive->addressing should be prohibited.
# 
# include/linux/hdreg.h
#   2004/10/08 22:10:07+02:00 bzolnier@trik.(none) +4 -2
#   [ide] kill /proc/ide/hd?/settings:address & HDIO_[GET,SET]_ADDRESS ioctls
# 
# drivers/ide/ide-disk.c
#   2004/10/08 22:10:07+02:00 bzolnier@trik.(none) +0 -1
#   [ide] kill /proc/ide/hd?/settings:address & HDIO_[GET,SET]_ADDRESS ioctls
# 
# ChangeSet
#   2004/10/08 22:00:09+02:00 bzolnier@trik.(none) 
#   [ide] kill /proc/ide/hd?/settings:number
#   
#   drive->dn is used mainly for programming timings and shouldn't be touched.
# 
# drivers/ide/ide.c
#   2004/10/08 21:59:48+02:00 bzolnier@trik.(none) +0 -1
#   [ide] kill /proc/ide/hd?/settings:number
# 
# ChangeSet
#   2004/10/08 19:25:00+02:00 bzolnier@trik.(none) 
#   [ide] pmac: kill CONFIG_BLK_DEV_IDEDMA_PMAC_AUTO
#   
#   This option is a NOP because pmac driver always enables DMA
#   (hwif->autodma and drive->autodma are never checked).
# 
# drivers/ide/ppc/pmac.c
#   2004/10/08 19:24:36+02:00 bzolnier@trik.(none) +0 -11
#   [ide] pmac: kill CONFIG_BLK_DEV_IDEDMA_PMAC_AUTO
# 
# drivers/ide/Kconfig
#   2004/10/08 19:24:36+02:00 bzolnier@trik.(none) +1 -12
#   [ide] pmac: kill CONFIG_BLK_DEV_IDEDMA_PMAC_AUTO
# 
# ChangeSet
#   2004/10/08 00:40:14+02:00 bzolnier@trik.(none) 
#   [ide] add ide_use_dma() helper
# 
# include/linux/ide.h
#   2004/10/08 00:40:05+02:00 bzolnier@trik.(none) +1 -0
#   [ide] add ide_use_dma() helper
# 
# drivers/ide/pci/slc90e66.c
#   2004/10/08 00:38:33+02:00 bzolnier@trik.(none) +6 -27
#   [ide] add ide_use_dma() helper
# 
# drivers/ide/pci/sis5513.c
#   2004/10/08 00:38:33+02:00 bzolnier@trik.(none) +7 -27
#   [ide] add ide_use_dma() helper
# 
# drivers/ide/pci/siimage.c
#   2004/10/08 00:38:33+02:00 bzolnier@trik.(none) +6 -27
#   [ide] add ide_use_dma() helper
# 
# drivers/ide/pci/serverworks.c
#   2004/10/08 00:38:33+02:00 bzolnier@trik.(none) +7 -29
#   [ide] add ide_use_dma() helper
# 
# drivers/ide/pci/piix.c
#   2004/10/08 00:38:33+02:00 bzolnier@trik.(none) +1 -15
#   [ide] add ide_use_dma() helper
# 
# drivers/ide/pci/pdc202xx_old.c
#   2004/10/08 00:38:33+02:00 bzolnier@trik.(none) +7 -28
#   [ide] add ide_use_dma() helper
# 
# drivers/ide/pci/pdc202xx_new.c
#   2004/10/08 00:38:33+02:00 bzolnier@trik.(none) +7 -28
#   [ide] add ide_use_dma() helper
# 
# drivers/ide/pci/it8172.c
#   2004/10/08 00:38:33+02:00 bzolnier@trik.(none) +7 -27
#   [ide] add ide_use_dma() helper
# 
# drivers/ide/pci/hpt366.c
#   2004/10/08 00:38:33+02:00 bzolnier@trik.(none) +7 -26
#   [ide] add ide_use_dma() helper
# 
# drivers/ide/pci/hpt34x.c
#   2004/10/08 00:38:33+02:00 bzolnier@trik.(none) +9 -29
#   [ide] add ide_use_dma() helper
# 
# drivers/ide/pci/cmd64x.c
#   2004/10/08 00:38:33+02:00 bzolnier@trik.(none) +7 -27
#   [ide] add ide_use_dma() helper
# 
# drivers/ide/pci/atiixp.c
#   2004/10/08 00:38:33+02:00 bzolnier@trik.(none) +7 -27
#   [ide] add ide_use_dma() helper
# 
# drivers/ide/pci/aec62xx.c
#   2004/10/08 00:38:33+02:00 bzolnier@trik.(none) +7 -27
#   [ide] add ide_use_dma() helper
# 
# drivers/ide/ide-lib.c
#   2004/10/08 00:38:33+02:00 bzolnier@trik.(none) +32 -0
#   [ide] add ide_use_dma() helper
# 
# ChangeSet
#   2004/10/07 20:55:50+02:00 bzolnier@trik.(none) 
#   [ide] pdc202xx_old: kill /proc/ide/pdc202xx
# 
# drivers/ide/pci/pdc202xx_old.h
#   2004/10/07 20:55:42+02:00 bzolnier@trik.(none) +0 -37
#   [ide] pdc202xx_old: kill /proc/ide/pdc202xx
# 
# drivers/ide/pci/pdc202xx_old.c
#   2004/10/07 20:55:42+02:00 bzolnier@trik.(none) +3 -127
#   [ide] pdc202xx_old: kill /proc/ide/pdc202xx
# 
# ChangeSet
#   2004/10/07 20:04:28+02:00 bzolnier@trik.(none) 
#   [ide] serverworks: kill /proc/ide/svwks
# 
# drivers/ide/pci/serverworks.h
#   2004/10/07 20:04:19+02:00 bzolnier@trik.(none) +0 -2
#   [ide] serverworks: kill /proc/ide/svwks
# 
# drivers/ide/pci/serverworks.c
#   2004/10/07 20:04:19+02:00 bzolnier@trik.(none) +0 -168
#   [ide] serverworks: kill /proc/ide/svwks
# 
# ChangeSet
#   2004/10/06 00:36:14+02:00 bzolnier@trik.(none) 
#   [ide] merge ide_diag_taskfile() into ide_raw_taskfile()
# 
# drivers/ide/ide-taskfile.c
#   2004/10/06 00:35:52+02:00 bzolnier@trik.(none) +8 -13
#   [ide] merge ide_diag_taskfile() into ide_raw_taskfile()
# 
# ChangeSet
#   2004/10/06 00:27:15+02:00 bzolnier@trik.(none) 
#   [ide] add data_len to ide_task_t
#   
#   From: Jens Axboe <axboe@suse.de>
# 
# include/linux/ide.h
#   2004/10/04 09:25:43+02:00 bzolnier@trik.(none) +1 -0
#   [ide] add data_len to ide_task_t
# 
# drivers/ide/ide-taskfile.c
#   2004/10/04 09:34:00+02:00 bzolnier@trik.(none) +17 -14
#   [ide] add data_len to ide_task_t
# 
# drivers/ide/ide-disk.c
#   2004/10/04 09:26:45+02:00 bzolnier@trik.(none) +2 -2
#   [ide] add data_len to ide_task_t
# 
# ChangeSet
#   2004/10/02 17:27:09+02:00 bzolnier@trik.(none) 
#   merge with linux-2.6
# 
# drivers/ide/pci/aec62xx.c
#   2004/10/02 17:26:51+02:00 bzolnier@trik.(none) +0 -2
#   hand merge with linux-2.6
# 
# drivers/ide/ide-taskfile.c
#   2004/10/02 17:26:51+02:00 bzolnier@trik.(none) +2 -0
#   hand merge with linux-2.6
# 
# include/linux/ide.h
#   2004/10/02 17:22:29+02:00 bzolnier@trik.(none) +0 -0
#   Auto merged
# 
# drivers/ide/pci/triflex.c
#   2004/10/02 17:22:29+02:00 bzolnier@trik.(none) +0 -0
#   Auto merged
# 
# drivers/ide/pci/piix.c
#   2004/10/02 17:22:29+02:00 bzolnier@trik.(none) +0 -19
#   Auto merged
# 
# drivers/ide/pci/cmd640.c
#   2004/10/02 17:22:29+02:00 bzolnier@trik.(none) +0 -4
#   Auto merged
# 
# drivers/ide/pci/aec62xx.h
#   2004/10/02 17:22:28+02:00 bzolnier@trik.(none) +0 -0
#   Auto merged
# 
# drivers/ide/ide-proc.c
#   2004/10/02 17:22:28+02:00 bzolnier@trik.(none) +0 -6
#   Auto merged
# 
# drivers/ide/ide-probe.c
#   2004/10/02 17:22:28+02:00 bzolnier@trik.(none) +0 -0
#   Auto merged
# 
# drivers/ide/arm/Makefile
#   2004/10/02 17:22:28+02:00 bzolnier@trik.(none) +0 -1
#   Auto merged
# 
# drivers/ide/Kconfig
#   2004/10/02 17:22:28+02:00 bzolnier@trik.(none) +0 -7
#   Auto merged
# 
# BitKeeper/deleted/.del-bast-ide.c
#   2004/10/02 17:22:28+02:00 bzolnier@trik.(none) +0 -0
#   Delete: drivers/ide/arm/bast-ide.c
# 
# ChangeSet
#   2004/10/01 20:26:26+02:00 bzolnier@trik.(none) 
#   Cset exclude: bzolnier@trik.(none)|ChangeSet|20040930235021|52364
# 
# BitKeeper/etc/config
#   2004/10/01 20:26:20+02:00 bzolnier@trik.(none) +0 -0
#   Exclude
# 
# ChangeSet
#   2004/10/01 18:46:00+02:00 bzolnier@trik.(none) 
#   merge with ide-2.6
# 
# drivers/ide/pci/aec62xx.c
#   2004/10/01 18:45:42+02:00 bzolnier@trik.(none) +0 -2
#   hand merge with ide-2.6
# 
# drivers/ide/ide-taskfile.c
#   2004/10/01 18:45:42+02:00 bzolnier@trik.(none) +0 -0
#   hand merge with ide-2.6
# 
# include/linux/ide.h
#   2004/10/01 18:23:27+02:00 bzolnier@trik.(none) +0 -0
#   Auto merged
# 
# drivers/ide/ppc/pmac.c
#   2004/10/01 18:23:27+02:00 bzolnier@trik.(none) +0 -0
#   Auto merged
# 
# drivers/ide/pci/triflex.c
#   2004/10/01 18:23:27+02:00 bzolnier@trik.(none) +0 -0
#   Auto merged
# 
# drivers/ide/pci/piix.c
#   2004/10/01 18:23:27+02:00 bzolnier@trik.(none) +0 -0
#   Auto merged
# 
# drivers/ide/pci/cmd640.c
#   2004/10/01 18:23:27+02:00 bzolnier@trik.(none) +0 -4
#   Auto merged
# 
# drivers/ide/pci/aec62xx.h
#   2004/10/01 18:23:27+02:00 bzolnier@trik.(none) +0 -0
#   Auto merged
# 
# drivers/ide/ide-proc.c
#   2004/10/01 18:23:27+02:00 bzolnier@trik.(none) +0 -6
#   Auto merged
# 
# drivers/ide/ide-probe.c
#   2004/10/01 18:23:27+02:00 bzolnier@trik.(none) +0 -0
#   Auto merged
# 
# drivers/ide/Kconfig
#   2004/10/01 18:23:27+02:00 bzolnier@trik.(none) +0 -0
#   Auto merged
# 
# BitKeeper/etc/config
#   2004/10/01 18:23:27+02:00 bzolnier@trik.(none) +0 -2
#   Auto merged
# 
# ChangeSet
#   2004/10/01 17:29:37+02:00 bzolnier@trik.(none) 
#   [ide] Simtec BAST (EB2410ITX) / Thorcom VR1000 driver
#   
#   Patch to provide support for the following two boards:
#   
#   	- Simtec BAST (EB2410ITX)
#   	- Thorcom VR1000
#   
#   Signed-off-by: Ben Dooks <ben@simtec.co.uk>
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
# 
# drivers/ide/arm/bast-ide.c
#   2004/10/01 17:23:09+02:00 bzolnier@trik.(none) +71 -0
#   [ide] Simtec BAST (EB2410ITX) / Thorcom VR1000 driver
# 
# drivers/ide/arm/Makefile
#   2004/10/01 17:23:09+02:00 bzolnier@trik.(none) +1 -0
#   [ide] Simtec BAST (EB2410ITX) / Thorcom VR1000 driver
# 
# drivers/ide/Kconfig
#   2004/10/01 17:23:09+02:00 bzolnier@trik.(none) +7 -0
#   [ide] Simtec BAST (EB2410ITX) / Thorcom VR1000 driver
# 
# drivers/ide/arm/bast-ide.c
#   2004/10/01 17:23:09+02:00 bzolnier@trik.(none) +0 -0
#   BitKeeper file /home/bzolnier/bk/ide-2.6/drivers/ide/arm/bast-ide.c
# 
# ChangeSet
#   2004/10/01 17:04:34+02:00 bzolnier@trik.(none) 
#   [ide] piix: fix wrong DMA mode selected
#   
#   From: Carsten Haustein <chaus@cs.uni-potsdam.de>
#   
#   A bug in function piix_config_drive_xfer_rate() allows a call of
#   hwif->ide_dma_on(drive) without prior call of piix_config_drive_for_dma().
#   This results in harddisk configured for UDMA (default?) whereas the highest
#   DMA mode supported by PIIX3 is MWORD2.
#   
#   This bug is supposed to be present in any 2.6.x kernel release and any
#   2.4.x kernel release since 2.4.21.
#   
#   bart: this should also fix the same bug for PIIXa and PIIXb
#   
#   Fixes bugzilla bug #3473.
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
# 
# drivers/ide/pci/piix.c
#   2004/10/01 17:04:15+02:00 bzolnier@trik.(none) +19 -24
#   [ide] piix: fix wrong DMA mode selected
# 
# ChangeSet
#   2004/10/01 02:12:43+02:00 bzolnier@trik.(none) 
#   [ide] aec62xx: remove dead DEBUG_AEC_REGS code
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
# 
# drivers/ide/pci/aec62xx.h
#   2004/10/01 02:12:30+02:00 bzolnier@trik.(none) +0 -7
#   [ide] aec62xx: remove dead DEBUG_AEC_REGS code
# 
# drivers/ide/pci/aec62xx.c
#   2004/10/01 02:12:30+02:00 bzolnier@trik.(none) +2 -45
#   [ide] aec62xx: remove dead DEBUG_AEC_REGS code
# 
# ChangeSet
#   2004/10/01 02:09:43+02:00 bzolnier@trik.(none) 
#   [ide] remove stale comment from ide-proc.c
#   
#   ide-default driver was added long time ago.
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
# 
# drivers/ide/ide-proc.c
#   2004/10/01 02:09:28+02:00 bzolnier@trik.(none) +6 -19
#   [ide] remove stale comment from ide-proc.c
# 
# ChangeSet
#   2004/10/01 02:03:23+02:00 bzolnier@trik.(none) 
#   [ide] remove dead debugging code from ide-taskfile.c
#   
#   - CONFIG_IDE_TASK_IOCTL_DEBUG cannot be defined
#   - function declarations are used instead of calls
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
# 
# drivers/ide/ide-taskfile.c
#   2004/10/01 02:03:06+02:00 bzolnier@trik.(none) +0 -33
#   [ide] remove dead debugging code from ide-taskfile.c
# 
# ChangeSet
#   2004/10/01 01:59:23+02:00 bzolnier@trik.(none) 
#   [ide] remove dead CMD640 debugging from ide-probe.c
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
# 
# include/linux/ide.h
#   2004/10/01 01:59:07+02:00 bzolnier@trik.(none) +0 -7
#   [ide] remove dead CMD640 debugging from ide-probe.c
# 
# drivers/ide/pci/cmd640.c
#   2004/10/01 01:59:07+02:00 bzolnier@trik.(none) +4 -2
#   [ide] remove dead CMD640 debugging from ide-probe.c
# 
# drivers/ide/ide-probe.c
#   2004/10/01 01:59:07+02:00 bzolnier@trik.(none) +0 -9
#   [ide] remove dead CMD640 debugging from ide-probe.c
# 
# ChangeSet
#   2004/10/01 01:54:38+02:00 bzolnier@trik.(none) 
#   [ide] triflex: kill /proc/ide/triflex
#   
#   Fixes OOPS on two single channel controllers.
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
# 
# drivers/ide/pci/triflex.c
#   2004/10/01 01:54:16+02:00 bzolnier@trik.(none) +0 -62
#   [ide] triflex: kill /proc/ide/triflex
# 
# ChangeSet
#   2004/09/28 21:17:49+02:00 bzolnier@trik.(none) 
#   [ide] obsolete "noautotune"/"autotune" command line parameters
#   
#   - host drivers should handle them
#   - ideally they shouldn't be needed et all
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
# 
# drivers/ide/ide.c
#   2004/09/28 21:17:30+02:00 bzolnier@trik.(none) +4 -4
#   [ide] obsolete "noautotune"/"autotune" command line parameters
# 
# ChangeSet
#   2004/09/28 16:45:46+02:00 bzolnier@trik.(none) 
#   [ide] aec62xx: kill /proc/ide/aec62xx
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/pci/aec62xx.h
#   2004/09/28 16:45:25+02:00 bzolnier@trik.(none) +0 -2
#   [ide] aec62xx: kill /proc/ide/aec62xx
# 
# drivers/ide/pci/aec62xx.c
#   2004/09/28 16:45:25+02:00 bzolnier@trik.(none) +2 -108
#   [ide] aec62xx: kill /proc/ide/aec62xx
# 
# ChangeSet
#   2004/09/28 15:41:33+02:00 bzolnier@trik.(none) 
#   [ide] aec62xx: remove dead DEBUG_AEC_REGS code
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/pci/aec62xx.h
#   2004/09/28 15:41:12+02:00 bzolnier@trik.(none) +0 -7
#   [ide] aec62xx: remove dead DEBUG_AEC_REGS code
# 
# drivers/ide/pci/aec62xx.c
#   2004/09/28 15:41:12+02:00 bzolnier@trik.(none) +2 -45
#   [ide] aec62xx: remove dead DEBUG_AEC_REGS code
# 
# ChangeSet
#   2004/09/28 01:09:24+02:00 bzolnier@trik.(none) 
#   [ide] hpt366: kill /proc/ide/hpt366
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/pci/hpt366.h
#   2004/09/28 01:09:04+02:00 bzolnier@trik.(none) +0 -2
#   [ide] hpt366: kill /proc/ide/hpt366
# 
# drivers/ide/pci/hpt366.c
#   2004/09/28 01:09:04+02:00 bzolnier@trik.(none) +1 -71
#   [ide] hpt366: kill /proc/ide/hpt366
# 
# ChangeSet
#   2004/09/28 00:33:57+02:00 bzolnier@trik.(none) 
#   [ide] atiixp: kill /proc/ide/atiixp
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/pci/atiixp.c
#   2004/09/28 00:33:35+02:00 bzolnier@trik.(none) +0 -118
#   [ide] atiixp: kill /proc/ide/atiixp
# 
# ChangeSet
#   2004/09/27 03:39:53+02:00 bzolnier@trik.(none) 
#   [ide] cs5520: kill /proc/ide/cs5520
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/pci/cs5520.c
#   2004/09/27 03:39:34+02:00 bzolnier@trik.(none) +5 -69
#   [ide] cs5520: kill /proc/ide/cs5520
# 
# ChangeSet
#   2004/09/27 03:23:15+02:00 bzolnier@trik.(none) 
#   [ide] slc90e66: kill /proc/ide/slc90e66
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/pci/slc90e66.c
#   2004/09/27 03:22:57+02:00 bzolnier@trik.(none) +1 -110
#   [ide] slc90e66: kill /proc/ide/slc90e66
# 
# ChangeSet
#   2004/09/27 01:41:58+02:00 bzolnier@trik.(none) 
#   [ide] piix: kill /proc/ide/piix
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/pci/piix.h
#   2004/09/27 01:41:38+02:00 bzolnier@trik.(none) +0 -4
#   [ide] piix: kill /proc/ide/piix
# 
# drivers/ide/pci/piix.c
#   2004/09/27 01:41:38+02:00 bzolnier@trik.(none) +0 -167
#   [ide] piix: kill /proc/ide/piix
# 
# ChangeSet
#   2004/09/27 01:05:32+02:00 bzolnier@trik.(none) 
#   [ide] remove stale comment from ide-proc.c
#   
#   ide-default driver was added long time ago.
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide-proc.c
#   2004/09/27 01:05:12+02:00 bzolnier@trik.(none) +6 -19
#   [ide] remove stale comment from ide-proc.c
# 
# ChangeSet
#   2004/09/27 00:14:22+02:00 bzolnier@trik.(none) 
#   [ide] kill CONFIG_IDE_TASKFILE_IO
#   
#   It is not needed any longer:
#   - PIO code is unified and converted to use scatterlists
#   - taskfile code doesn't support falling back to PIO
#   - it is much easier to convert non-taskfile version of
#     __ide_do_rw_disk() to something sane than taskfile one
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide-disk.c
#   2004/09/27 00:14:01+02:00 bzolnier@trik.(none) +1 -159
#   [ide] kill CONFIG_IDE_TASKFILE_IO
# 
# drivers/ide/Kconfig
#   2004/09/27 00:14:01+02:00 bzolnier@trik.(none) +0 -9
#   [ide] kill CONFIG_IDE_TASKFILE_IO
# 
# ChangeSet
#   2004/09/26 22:08:49+02:00 bzolnier@trik.(none) 
#   [ide] remove dead debugging code from ide-taskfile.c
#   
#   - CONFIG_IDE_TASK_IOCTL_DEBUG cannot be defined
#   - function declarations are used instead of calls
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide-taskfile.c
#   2004/09/26 22:08:27+02:00 bzolnier@trik.(none) +0 -33
#   [ide] remove dead debugging code from ide-taskfile.c
# 
# ChangeSet
#   2004/09/26 19:40:50+02:00 bzolnier@trik.(none) 
#   [ide] remove dead CMD640 debugging from ide-probe.c
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# include/linux/ide.h
#   2004/09/26 19:40:33+02:00 bzolnier@trik.(none) +0 -7
#   [ide] remove dead CMD640 debugging from ide-probe.c
# 
# drivers/ide/pci/cmd640.c
#   2004/09/26 19:40:32+02:00 bzolnier@trik.(none) +4 -2
#   [ide] remove dead CMD640 debugging from ide-probe.c
# 
# drivers/ide/ide-probe.c
#   2004/09/26 19:40:32+02:00 bzolnier@trik.(none) +0 -9
#   [ide] remove dead CMD640 debugging from ide-probe.c
# 
# ChangeSet
#   2004/09/26 18:47:33+02:00 bzolnier@trik.(none) 
#   [ide] kill ide_hwif_t->ide_dma_verbose
#   
#   - make __ide_dma_verbose() void and drop "__" prefix
#   - ide_dma_verbose() is always available now
#   - use it instead of ide_hwif_t->ide_dma_verbose
#   - sgiioc4.c version reported wrong mode
#   - icside.c version repeated info given by ->ide_dma_check()
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# include/linux/ide.h
#   2004/09/26 18:47:12+02:00 bzolnier@trik.(none) +2 -2
#   [ide] kill ide_hwif_t->ide_dma_verbose
# 
# drivers/ide/ppc/pmac.c
#   2004/09/26 18:47:12+02:00 bzolnier@trik.(none) +0 -1
#   [ide] kill ide_hwif_t->ide_dma_verbose
# 
# drivers/ide/pci/siimage.c
#   2004/09/26 18:47:12+02:00 bzolnier@trik.(none) +0 -7
#   [ide] kill ide_hwif_t->ide_dma_verbose
# 
# drivers/ide/pci/sgiioc4.c
#   2004/09/26 18:47:12+02:00 bzolnier@trik.(none) +0 -12
#   [ide] kill ide_hwif_t->ide_dma_verbose
# 
# drivers/ide/ide.c
#   2004/09/26 18:47:12+02:00 bzolnier@trik.(none) +0 -1
#   [ide] kill ide_hwif_t->ide_dma_verbose
# 
# drivers/ide/ide-dma.c
#   2004/09/26 18:47:12+02:00 bzolnier@trik.(none) +12 -14
#   [ide] kill ide_hwif_t->ide_dma_verbose
# 
# drivers/ide/ide-disk.c
#   2004/09/26 18:47:12+02:00 bzolnier@trik.(none) +1 -1
#   [ide] kill ide_hwif_t->ide_dma_verbose
# 
# drivers/ide/ide-cd.c
#   2004/09/26 18:47:12+02:00 bzolnier@trik.(none) +2 -3
#   [ide] kill ide_hwif_t->ide_dma_verbose
# 
# drivers/ide/arm/icside.c
#   2004/09/26 18:47:12+02:00 bzolnier@trik.(none) +0 -9
#   [ide] kill ide_hwif_t->ide_dma_verbose
# 
# ChangeSet
#   2004/09/26 17:12:01+02:00 bzolnier@trik.(none) 
#   [ide] fix build for sgiioc4.c
# 
# drivers/ide/pci/sgiioc4.c
#   2004/09/26 17:11:44+02:00 bzolnier@trik.(none) +0 -1
#   [ide] fix build for sgiioc4.c
# 
# ChangeSet
#   2004/09/26 17:08:04+02:00 bzolnier@trik.(none) 
#   [ide] remove needless EXPORTs from ide-taskfile.c
#   
#   Also remove unused MAX_DMA define.
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# include/linux/ide.h
#   2004/09/26 17:07:46+02:00 bzolnier@trik.(none) +0 -5
#   [ide] remove needless EXPORTs from ide-taskfile.c
# 
# drivers/ide/ide-taskfile.c
#   2004/09/26 17:07:46+02:00 bzolnier@trik.(none) +4 -29
#   [ide] remove needless EXPORTs from ide-taskfile.c
# 
# ChangeSet
#   2004/09/26 16:17:19+02:00 bzolnier@trik.(none) 
#   [ide] remove pdc4030 driver
#   
#   Sigh, I broke it by accident 16 months ago and nobody has noticed
#   (I suspect that it was non-functional even earlier).
#   
#   Also:
#   - it should be converted to use scatterlist PIO
#   - it has verbose debugging enabled by default
#   - it needs hacks all over IDE code
#   - it is guilty of crimes against ide_hwifs[]
#   
#   Just remove it for now.
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# include/linux/ide.h
#   2004/09/26 16:16:58+02:00 bzolnier@trik.(none) +1 -3
#   [ide] remove pdc4030 driver
# 
# drivers/ide/legacy/Makefile
#   2004/09/26 16:16:58+02:00 bzolnier@trik.(none) +0 -1
#   [ide] remove pdc4030 driver
# 
# drivers/ide/ide.c
#   2004/09/26 16:16:58+02:00 bzolnier@trik.(none) +1 -17
#   [ide] remove pdc4030 driver
# 
# drivers/ide/ide-proc.c
#   2004/09/26 16:16:58+02:00 bzolnier@trik.(none) +0 -1
#   [ide] remove pdc4030 driver
# 
# drivers/ide/ide-probe.c
#   2004/09/26 16:16:58+02:00 bzolnier@trik.(none) +3 -16
#   [ide] remove pdc4030 driver
# 
# drivers/ide/ide-io.c
#   2004/09/26 16:16:58+02:00 bzolnier@trik.(none) +0 -12
#   [ide] remove pdc4030 driver
# 
# drivers/ide/ide-disk.c
#   2004/09/26 16:16:58+02:00 bzolnier@trik.(none) +2 -4
#   [ide] remove pdc4030 driver
# 
# drivers/ide/Kconfig
#   2004/09/26 16:16:58+02:00 bzolnier@trik.(none) +0 -13
#   [ide] remove pdc4030 driver
# 
# Documentation/ide.txt
#   2004/09/26 16:16:58+02:00 bzolnier@trik.(none) +2 -2
#   [ide] remove pdc4030 driver
# 
# BitKeeper/deleted/.del-pdc4030.c~d79b3498c203ca5
#   2004/09/26 15:18:33+02:00 bzolnier@trik.(none) +0 -0
#   Delete: drivers/ide/legacy/pdc4030.c
# 
# BitKeeper/deleted/.del-pdc4030.h~a2af7ad84a5d755b
#   2004/09/26 13:33:19+02:00 bzolnier@trik.(none) +0 -0
#   Delete: drivers/ide/legacy/pdc4030.h
# 
# ChangeSet
#   2004/09/26 02:45:43+02:00 bzolnier@trik.(none) 
#   [ide] alim15x3: fix ali15x3_dma_setup()
# 
# drivers/ide/pci/alim15x3.c
#   2004/09/26 02:45:34+02:00 bzolnier@trik.(none) +4 -2
#   [ide] alim15x3: fix ali15x3_dma_setup()
# 
# ChangeSet
#   2004/09/26 02:37:26+02:00 bzolnier@trik.(none) 
#   Cset exclude: bzolnier@trik.(none)|ChangeSet|20040925175146|28966
# 
# drivers/ide/pci/alim15x3.c
#   2004/09/26 02:37:24+02:00 bzolnier@trik.(none) +0 -0
#   Exclude
# 
# ChangeSet
#   2004/09/26 00:30:02+02:00 bzolnier@trik.(none) 
#   [ide] setup-pci: small ide_get_or_set_dma_base() cleanup
#   
#   - hwif->dma_base is set in ->init_iops() for MMIO
#   - if !dma_base then dma_base is really equal to zero
#   - remove dead code from simplex check
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/setup-pci.c
#   2004/09/26 00:29:52+02:00 bzolnier@trik.(none) +5 -21
#   [ide] setup-pci: small ide_get_or_set_dma_base() cleanup
# 
# ChangeSet
#   2004/09/25 21:41:42+02:00 bzolnier@trik.(none) 
#   [ide] ide-scsi: simplify+speedup DMA support
#   
#   - add hwif->sg_mapped flag
#   - add idescsi_map_sg() converting scsi_cmd->sg into
#     hwif->sg_table (this removes need for rq->bio)
#   - remove code (de)allocating rq->bio
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# include/linux/ide.h
#   2004/09/25 21:41:25+02:00 bzolnier@trik.(none) +1 -0
#   [ide] ide-scsi: simplify+speedup DMA support
# 
# drivers/scsi/ide-scsi.c
#   2004/09/25 21:41:25+02:00 bzolnier@trik.(none) +49 -92
#   [ide] ide-scsi: simplify+speedup DMA support
# 
# drivers/ide/ide-io.c
#   2004/09/25 21:41:25+02:00 bzolnier@trik.(none) +9 -3
#   [ide] ide-scsi: simplify+speedup DMA support
# 
# ChangeSet
#   2004/09/25 15:51:28+02:00 bzolnier@trik.(none) 
#   [ide] obsolete "enable DMA by default" config options
#   
#   CONFIG_IDEDMA_ICS_AUTO
#   CONFIG_BLK_DEV_IDEDMA_PMAC_AUTO
#   CONFIG_IDEDMA_PCI_AUTO
#   
#   We should always enable DMA by default nowadays and if
#   DMA can't be used "ide=nodma" parameter should be used.
#   Warn if DMA support is enabled but autodma is disabled.
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/setup-pci.c
#   2004/09/25 15:51:03+02:00 bzolnier@trik.(none) +5 -0
#   [ide] obsolete "enable DMA by default" config options
# 
# drivers/ide/ppc/pmac.c
#   2004/09/25 15:51:03+02:00 bzolnier@trik.(none) +4 -0
#   [ide] obsolete "enable DMA by default" config options
# 
# drivers/ide/arm/icside.c
#   2004/09/25 15:51:03+02:00 bzolnier@trik.(none) +5 -0
#   [ide] obsolete "enable DMA by default" config options
# 
# ChangeSet
#   2004/09/25 15:18:30+02:00 bzolnier@trik.(none) 
#   [ide] obsolete some command line parameters
#   
#   "idex=ata66":
#   - not needed by most of drivers
#   - should be moved to a drivers really needing it
#   
#   "idex=dma":
#   - only accepted by cs5220.c, generic.c, hpt366.c,
#     triflex.c and pmac.c
#   - autodma should be used instead
#   
#   "idex=reset" and "idex=serialize":
#   - drivers should take care of these settings
#   
#   "idex=base[,ctl[,irq]]":
#   - drivers should detect correct settings
#   - ordering should be controlled by user-space
#   
#   "ide0=four":
#   - should be handled ide-generic.c driver
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide.c
#   2004/09/25 15:18:03+02:00 bzolnier@trik.(none) +8 -5
#   [ide] obsolete some command line parameters
# 
# ChangeSet
#   2004/09/25 14:47:13+02:00 bzolnier@trik.(none) 
#   [ide] obsolete /proc/ide/hd?/settings
#   
#   The most important settings are available also through ioctls.
#   I will deal with the rest during deprecation period.
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide-proc.c
#   2004/09/25 14:46:53+02:00 bzolnier@trik.(none) +6 -0
#   [ide] obsolete /proc/ide/hd?/settings
# 
# ChangeSet
#   2004/09/25 01:11:49+02:00 bzolnier@trik.(none) 
#   [ide] ignore BIOS enable bits for Promise controllers
#   
#   There are no Promise binary drivers for 2.6.x kernels so:
#   - ignore BIOS enable bits completely
#   - remove CONFIG_PDC202XX_FORCE
#   - kill IDEPCI_FLAG_FORCE_PDC hack
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# include/linux/ide.h
#   2004/09/25 01:11:26+02:00 bzolnier@trik.(none) +0 -1
#   [ide] ignore BIOS enable bits for Promise controllers
# 
# drivers/ide/setup-pci.c
#   2004/09/25 01:11:26+02:00 bzolnier@trik.(none) +1 -14
#   [ide] ignore BIOS enable bits for Promise controllers
# 
# drivers/ide/pci/pdc202xx_old.h
#   2004/09/25 01:11:26+02:00 bzolnier@trik.(none) +0 -17
#   [ide] ignore BIOS enable bits for Promise controllers
# 
# drivers/ide/pci/pdc202xx_new.h
#   2004/09/25 01:11:26+02:00 bzolnier@trik.(none) +0 -6
#   [ide] ignore BIOS enable bits for Promise controllers
# 
# drivers/ide/Kconfig
#   2004/09/25 01:11:26+02:00 bzolnier@trik.(none) +0 -7
#   [ide] ignore BIOS enable bits for Promise controllers
# 
# ChangeSet
#   2004/09/24 23:14:29+02:00 bzolnier@trik.(none) 
#   [ide] kill IDEPCI_FLAG_FORCE_MASTER
#   
#   cs5530 overrides hwif->autodma anyway.
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# include/linux/ide.h
#   2004/09/24 23:14:11+02:00 bzolnier@trik.(none) +1 -3
#   [ide] kill IDEPCI_FLAG_FORCE_MASTER
# 
# drivers/ide/setup-pci.c
#   2004/09/24 23:14:11+02:00 bzolnier@trik.(none) +2 -7
#   [ide] kill IDEPCI_FLAG_FORCE_MASTER
# 
# drivers/ide/pci/cs5530.c
#   2004/09/24 23:14:11+02:00 bzolnier@trik.(none) +0 -1
#   [ide] kill IDEPCI_FLAG_FORCE_MASTER
# 
# ChangeSet
#   2004/09/24 21:52:22+02:00 bzolnier@trik.(none) 
#   [ide] simplify autodma logic in setup-pci.c
#   
#   Do not set hwif->autodma in ide_pci_setup_ports().
#   All DMA capable chipset drivers override this setting.
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# include/linux/ide.h
#   2004/09/24 21:51:59+02:00 bzolnier@trik.(none) +1 -1
#   [ide] simplify autodma logic in setup-pci.c
# 
# drivers/ide/setup-pci.c
#   2004/09/24 21:51:59+02:00 bzolnier@trik.(none) +5 -17
#   [ide] simplify autodma logic in setup-pci.c
# 
# drivers/ide/pci/cs5520.c
#   2004/09/24 21:51:59+02:00 bzolnier@trik.(none) +1 -1
#   [ide] simplify autodma logic in setup-pci.c
# 
# ChangeSet
#   2004/09/24 15:37:30+02:00 bzolnier@trik.(none) 
#   [ide] ide-disk: enable stroke by default
#   
#   From: Jens Axboe <axboe@suse.de>
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# include/linux/ide.h
#   2004/09/22 15:52:27+02:00 bzolnier@trik.(none) +0 -1
#   [ide] ide-disk: enable stroke by default
# 
# drivers/ide/ide.c
#   2004/09/22 16:34:00+02:00 bzolnier@trik.(none) +1 -4
#   [ide] ide-disk: enable stroke by default
# 
# drivers/ide/ide-disk.c
#   2004/09/22 15:53:22+02:00 bzolnier@trik.(none) +0 -3
#   [ide] ide-disk: enable stroke by default
# 
# Documentation/ide.txt
#   2004/09/22 15:53:43+02:00 bzolnier@trik.(none) +0 -7
#   [ide] ide-disk: enable stroke by default
# 
# ChangeSet
#   2004/09/24 15:15:33+02:00 bzolnier@trik.(none) 
#   [ide] fix typo in pmac.c
#   
#   From: Santiago Gala <sgala@apache.org>
# 
# drivers/ide/ppc/pmac.c
#   2004/09/24 12:40:07+02:00 bzolnier@trik.(none) +1 -1
#   [ide] fix typo in pmac.c
# 
# ChangeSet
#   2004/09/23 23:25:39+02:00 bzolnier@trik.(none) 
#   [ide] fix ide-dma.c build warning
# 
# drivers/ide/ide-dma.c
#   2004/09/23 23:25:19+02:00 bzolnier@trik.(none) +0 -1
#   [ide] fix ide-dma.c build warning
# 
# ChangeSet
#   2004/09/23 22:24:27+02:00 bzolnier@trik.(none) 
#   [ide] remap hwif->sg_table only when needed
#   
#   ->dma_setup() can also fail when DMA is not supported
#   for some reason so remap hwif->sg_table only if it could
#   have been changed
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ppc/pmac.c
#   2004/09/22 17:16:48+02:00 bzolnier@trik.(none) +3 -1
#   [ide] remap hwif->sg_table only when needed
# 
# drivers/ide/pci/sgiioc4.c
#   2004/09/22 17:16:48+02:00 bzolnier@trik.(none) +1 -0
#   [ide] remap hwif->sg_table only when needed
# 
# drivers/ide/ide-io.c
#   2004/09/22 17:16:48+02:00 bzolnier@trik.(none) +1 -2
#   [ide] remap hwif->sg_table only when needed
# 
# drivers/ide/ide-dma.c
#   2004/09/22 17:16:48+02:00 bzolnier@trik.(none) +3 -1
#   [ide] remap hwif->sg_table only when needed
# 
# drivers/ide/ide-disk.c
#   2004/09/22 17:16:48+02:00 bzolnier@trik.(none) +6 -2
#   [ide] remap hwif->sg_table only when needed
# 
# arch/cris/arch-v10/drivers/ide.c
#   2004/09/22 17:16:48+02:00 bzolnier@trik.(none) +3 -1
#   [ide] remap hwif->sg_table only when needed
# 
# ChangeSet
#   2004/09/23 22:16:42+02:00 bzolnier@trik.(none) 
#   [ide] kill ide_raw_build_sglist()
#   
#   ide_build_sglist() can be now used for REQ_DRIVE_TASKFILE requests.
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# include/linux/ide.h
#   2004/09/22 17:16:10+02:00 bzolnier@trik.(none) +0 -1
#   [ide] kill ide_raw_build_sglist()
# 
# drivers/ide/ppc/pmac.c
#   2004/09/22 17:16:10+02:00 bzolnier@trik.(none) +2 -5
#   [ide] kill ide_raw_build_sglist()
# 
# drivers/ide/pci/sgiioc4.c
#   2004/09/22 17:16:10+02:00 bzolnier@trik.(none) +1 -4
#   [ide] kill ide_raw_build_sglist()
# 
# drivers/ide/ide-dma.c
#   2004/09/22 17:16:10+02:00 bzolnier@trik.(none) +4 -35
#   [ide] kill ide_raw_build_sglist()
# 
# ChangeSet
#   2004/09/23 22:11:13+02:00 bzolnier@trik.(none) 
#   [ide] split off ide_map_sg() from ide_init_sg_cmd()
#   
#   Also:
#   - fix sg->length for PIO-multi REQ_DRIVE_TASKFILE requests
#     (I somehow missed multiply by SECTOR_SIZE)
#   - in ide-dma.c use one sg for REQ_DRIVE_TASKFILE requests
#     (no reason for 128 sectors per sg limit)
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# include/linux/ide.h
#   2004/09/22 17:15:59+02:00 bzolnier@trik.(none) +1 -0
#   [ide] split off ide_map_sg() from ide_init_sg_cmd()
# 
# drivers/ide/ide-io.c
#   2004/09/22 17:15:59+02:00 bzolnier@trik.(none) +16 -6
#   [ide] split off ide_map_sg() from ide_init_sg_cmd()
# 
# drivers/ide/ide-dma.c
#   2004/09/23 22:10:44+02:00 bzolnier@trik.(none) +7 -22
#   [ide] split off ide_map_sg() from ide_init_sg_cmd()
# 
# drivers/ide/arm/icside.c
#   2004/09/22 17:15:59+02:00 bzolnier@trik.(none) +4 -8
#   [ide] split off ide_map_sg() from ide_init_sg_cmd()
# 
# arch/cris/arch-v10/drivers/ide.c
#   2004/09/22 17:15:59+02:00 bzolnier@trik.(none) +2 -8
#   [ide] split off ide_map_sg() from ide_init_sg_cmd()
# 
# ChangeSet
#   2004/09/23 22:01:16+02:00 bzolnier@trik.(none) 
#   [ide] pmac: kill pmac_ide_[raw_]build_sglist()
#   
#   Just use ide_dma_[raw_]build_sglist() from ide-dma.c.
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ppc/pmac.c
#   2004/09/23 22:00:55+02:00 bzolnier@trik.(none) +2 -52
#   [ide] pmac: kill pmac_ide_[raw_]build_sglist()
# 
# ChangeSet
#   2004/09/23 21:55:26+02:00 bzolnier@trik.(none) 
#   [ide] pmac: use more ide_hwif_t fields
#   
#   Use dmatable_dma, sg_table, sg_nents and sg_dma_direction fields
#   of ide_hwif_t and remove their equivalents from pmac_ide_hwif_t.
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ppc/pmac.c
#   2004/09/23 21:55:00+02:00 bzolnier@trik.(none) +26 -40
#   [ide] pmac: use more ide_hwif_t fields
# 
# ChangeSet
#   2004/09/23 21:37:02+02:00 bzolnier@trik.(none) 
#   Merge trik.(none):/home/bzolnier/bk/ide-2.6
#   into trik.(none):/home/bzolnier/bk/ide-dev-2.6
# 
# drivers/ide/ide-io.c
#   2004/09/23 21:36:57+02:00 bzolnier@trik.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/09/23 21:16:43+02:00 bzolnier@trik.(none) 
#   [ide] cs5530: kill /proc/ide/cs5530
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/pci/cs5530.c
#   2004/09/23 21:16:21+02:00 bzolnier@trik.(none) +0 -58
#   [ide] cs5530: kill /proc/ide/cs5530
# 
# ChangeSet
#   2004/09/23 21:11:35+02:00 bzolnier@trik.(none) 
#   [ide] sc1200: kill /proc/ide/sc1200
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/pci/sc1200.c
#   2004/09/22 17:17:10+02:00 bzolnier@trik.(none) +0 -65
#   [ide] sc1200: kill /proc/ide/sc1200
# 
# ChangeSet
#   2004/09/23 21:08:39+02:00 bzolnier@trik.(none) 
#   [ide] pdc202xx_new: kill /proc/ide/pdcnew
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/pci/pdc202xx_new.h
#   2004/09/22 17:15:00+02:00 bzolnier@trik.(none) +0 -2
#   [ide] pdc202xx_new: kill /proc/ide/pdcnew
# 
# drivers/ide/pci/pdc202xx_new.c
#   2004/09/22 17:15:00+02:00 bzolnier@trik.(none) +0 -64
#   [ide] pdc202xx_new: kill /proc/ide/pdcnew
# 
# ChangeSet
#   2004/09/23 21:02:26+02:00 bzolnier@trik.(none) 
#   [ide] triflex: kill /proc/ide/triflex
#   
#   It fixes OOPS on two single channel controllers.
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/pci/triflex.c
#   2004/09/22 17:14:16+02:00 bzolnier@trik.(none) +0 -62
#   [ide] triflex: kill /proc/ide/triflex
# 
# ChangeSet
#   2004/09/23 20:54:22+02:00 bzolnier@trik.(none) 
#   Merge trik.(none):/home/bzolnier/bk/ide-2.6
#   into trik.(none):/home/bzolnier/bk/ide-dev-2.6
# 
# include/linux/ide.h
#   2004/09/23 20:54:18+02:00 bzolnier@trik.(none) +0 -0
#   Auto merged
# 
# drivers/ide/ppc/pmac.c
#   2004/09/23 20:54:18+02:00 bzolnier@trik.(none) +0 -0
#   Auto merged
# 
# drivers/ide/pci/sgiioc4.c
#   2004/09/23 20:54:18+02:00 bzolnier@trik.(none) +0 -0
#   Auto merged
# 
# drivers/ide/arm/icside.c
#   2004/09/23 20:54:18+02:00 bzolnier@trik.(none) +0 -0
#   Auto merged
# 
# drivers/ide/ide-dma.c
#   2004/09/23 20:54:17+02:00 bzolnier@trik.(none) +0 -0
#   Auto merged
# 
# BitKeeper/etc/config
#   2004/09/23 17:00:58+02:00 bzolnier@trik.(none) +2 -0
#   enable auto-checkout
# 
# ChangeSet
#   2004/09/17 14:49:54+02:00 bzolnier@trik.(none) 
#   [ide] kill /proc/ide/ide?/config
#    
#   I first wanted to deprecate it but after discovering that:
#   - writes to PCI config space are non-functional since 2.4.21
#   - reads of full PCI config space are allowed for normal users
#   I think that there we are better off removing it immediately.
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide-proc.c
#   2004/09/16 23:08:34+02:00 bzolnier@trik.(none) +0 -257
#   [ide] kill /proc/ide/ide?/config
#    
#   I first wanted to deprecate it but after discovering that:
#   - writes to PCI config space are non-functional since 2.4.21
#   - reads of full PCI config space are allowed for normal users
#   I think that there we are better off removing it immediately.
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# ChangeSet
#   2004/09/17 14:44:21+02:00 bzolnier@trik.(none) 
#   [ide] convert ide_hwif_t->ide_dma_begin() to ->dma_start()
#   
#   Make ->ide_dma_begin() functions void and rename them to ->dma_start().
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# include/linux/ide.h
#   2004/09/16 22:30:30+02:00 bzolnier@trik.(none) +2 -2
#   [ide] convert ide_hwif_t->ide_dma_begin() to ->dma_start()
#   
#   Make ->ide_dma_begin() functions void and rename them to ->dma_start().
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/scsi/ide-scsi.c
#   2004/09/16 22:30:30+02:00 bzolnier@trik.(none) +2 -1
#   [ide] convert ide_hwif_t->ide_dma_begin() to ->dma_start()
#   
#   Make ->ide_dma_begin() functions void and rename them to ->dma_start().
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ppc/pmac.c
#   2004/09/16 22:30:30+02:00 bzolnier@trik.(none) +3 -5
#   [ide] convert ide_hwif_t->ide_dma_begin() to ->dma_start()
#   
#   Make ->ide_dma_begin() functions void and rename them to ->dma_start().
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/pci/trm290.c
#   2004/09/16 22:30:30+02:00 bzolnier@trik.(none) +2 -3
#   [ide] convert ide_hwif_t->ide_dma_begin() to ->dma_start()
#   
#   Make ->ide_dma_begin() functions void and rename them to ->dma_start().
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/pci/sl82c105.c
#   2004/09/16 22:30:30+02:00 bzolnier@trik.(none) +3 -5
#   [ide] convert ide_hwif_t->ide_dma_begin() to ->dma_start()
#   
#   Make ->ide_dma_begin() functions void and rename them to ->dma_start().
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/pci/sgiioc4.c
#   2004/09/16 22:30:30+02:00 bzolnier@trik.(none) +2 -5
#   [ide] convert ide_hwif_t->ide_dma_begin() to ->dma_start()
#   
#   Make ->ide_dma_begin() functions void and rename them to ->dma_start().
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/pci/pdc202xx_old.c
#   2004/09/16 22:30:30+02:00 bzolnier@trik.(none) +3 -3
#   [ide] convert ide_hwif_t->ide_dma_begin() to ->dma_start()
#   
#   Make ->ide_dma_begin() functions void and rename them to ->dma_start().
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/pci/hpt366.c
#   2004/09/16 22:30:30+02:00 bzolnier@trik.(none) +4 -4
#   [ide] convert ide_hwif_t->ide_dma_begin() to ->dma_start()
#   
#   Make ->ide_dma_begin() functions void and rename them to ->dma_start().
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide.c
#   2004/09/16 22:30:30+02:00 bzolnier@trik.(none) +1 -1
#   [ide] convert ide_hwif_t->ide_dma_begin() to ->dma_start()
#   
#   Make ->ide_dma_begin() functions void and rename them to ->dma_start().
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide-taskfile.c
#   2004/09/16 22:30:30+02:00 bzolnier@trik.(none) +2 -2
#   [ide] convert ide_hwif_t->ide_dma_begin() to ->dma_start()
#   
#   Make ->ide_dma_begin() functions void and rename them to ->dma_start().
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide-tape.c
#   2004/09/16 22:30:30+02:00 bzolnier@trik.(none) +1 -1
#   [ide] convert ide_hwif_t->ide_dma_begin() to ->dma_start()
#   
#   Make ->ide_dma_begin() functions void and rename them to ->dma_start().
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide-floppy.c
#   2004/09/16 22:30:30+02:00 bzolnier@trik.(none) +1 -1
#   [ide] convert ide_hwif_t->ide_dma_begin() to ->dma_start()
#   
#   Make ->ide_dma_begin() functions void and rename them to ->dma_start().
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide-dma.c
#   2004/09/16 22:30:30+02:00 bzolnier@trik.(none) +4 -5
#   [ide] convert ide_hwif_t->ide_dma_begin() to ->dma_start()
#   
#   Make ->ide_dma_begin() functions void and rename them to ->dma_start().
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide-disk.c
#   2004/09/16 22:30:30+02:00 bzolnier@trik.(none) +1 -1
#   [ide] convert ide_hwif_t->ide_dma_begin() to ->dma_start()
#   
#   Make ->ide_dma_begin() functions void and rename them to ->dma_start().
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide-cd.c
#   2004/09/16 22:30:30+02:00 bzolnier@trik.(none) +2 -1
#   [ide] convert ide_hwif_t->ide_dma_begin() to ->dma_start()
#   
#   Make ->ide_dma_begin() functions void and rename them to ->dma_start().
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/arm/icside.c
#   2004/09/16 22:30:30+02:00 bzolnier@trik.(none) +2 -3
#   [ide] convert ide_hwif_t->ide_dma_begin() to ->dma_start()
#   
#   Make ->ide_dma_begin() functions void and rename them to ->dma_start().
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# arch/cris/arch-v10/drivers/ide.c
#   2004/09/16 22:30:30+02:00 bzolnier@trik.(none) +3 -4
#   [ide] convert ide_hwif_t->ide_dma_begin() to ->dma_start()
#   
#   Make ->ide_dma_begin() functions void and rename them to ->dma_start().
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# ChangeSet
#   2004/09/17 14:42:26+02:00 bzolnier@trik.(none) 
#   [ide] add ide_hwif_t->dma_exec_cmd()
#   
#   - split off ->dma_exec_cmd() from ->ide_dma_[read,write] functions
#   - choose command to execute by ->dma_exec_cmd() in higher layers
#     and remove ->ide_dma_[read,write]
#   
#   Some real bugs are also fixed:
#   - in Etrax ide.c driver REQ_DRIVE_TASKFILE requests weren't
#     handled properly for drive->addressing == 0
#   - in trm290.c read and write commands were interchanged
#   - in sgiioc4.c commands weren't sent to disk devices
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# include/linux/ide.h
#   2004/09/16 22:30:16+02:00 bzolnier@trik.(none) +1 -2
#   [ide] add ide_hwif_t->dma_exec_cmd()
#   
#   - split off ->dma_exec_cmd() from ->ide_dma_[read,write] functions
#   - choose command to execute by ->dma_exec_cmd() in higher layers
#     and remove ->ide_dma_[read,write]
#   
#   Some real bugs are also fixed:
#   - in Etrax ide.c driver REQ_DRIVE_TASKFILE requests weren't
#     handled properly for drive->addressing == 0
#   - in trm290.c read and write commands were interchanged
#   - in sgiioc4.c commands weren't sent to disk devices
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ppc/pmac.c
#   2004/09/16 22:30:16+02:00 bzolnier@trik.(none) +3 -48
#   [ide] add ide_hwif_t->dma_exec_cmd()
#   
#   - split off ->dma_exec_cmd() from ->ide_dma_[read,write] functions
#   - choose command to execute by ->dma_exec_cmd() in higher layers
#     and remove ->ide_dma_[read,write]
#   
#   Some real bugs are also fixed:
#   - in Etrax ide.c driver REQ_DRIVE_TASKFILE requests weren't
#     handled properly for drive->addressing == 0
#   - in trm290.c read and write commands were interchanged
#   - in sgiioc4.c commands weren't sent to disk devices
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/pci/trm290.c
#   2004/09/16 22:30:16+02:00 bzolnier@trik.(none) +2 -52
#   [ide] add ide_hwif_t->dma_exec_cmd()
#   
#   - split off ->dma_exec_cmd() from ->ide_dma_[read,write] functions
#   - choose command to execute by ->dma_exec_cmd() in higher layers
#     and remove ->ide_dma_[read,write]
#   
#   Some real bugs are also fixed:
#   - in Etrax ide.c driver REQ_DRIVE_TASKFILE requests weren't
#     handled properly for drive->addressing == 0
#   - in trm290.c read and write commands were interchanged
#   - in sgiioc4.c commands weren't sent to disk devices
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/pci/sgiioc4.c
#   2004/09/16 22:30:16+02:00 bzolnier@trik.(none) +0 -7
#   [ide] add ide_hwif_t->dma_exec_cmd()
#   
#   - split off ->dma_exec_cmd() from ->ide_dma_[read,write] functions
#   - choose command to execute by ->dma_exec_cmd() in higher layers
#     and remove ->ide_dma_[read,write]
#   
#   Some real bugs are also fixed:
#   - in Etrax ide.c driver REQ_DRIVE_TASKFILE requests weren't
#     handled properly for drive->addressing == 0
#   - in trm290.c read and write commands were interchanged
#   - in sgiioc4.c commands weren't sent to disk devices
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide.c
#   2004/09/16 22:30:16+02:00 bzolnier@trik.(none) +1 -2
#   [ide] add ide_hwif_t->dma_exec_cmd()
#   
#   - split off ->dma_exec_cmd() from ->ide_dma_[read,write] functions
#   - choose command to execute by ->dma_exec_cmd() in higher layers
#     and remove ->ide_dma_[read,write]
#   
#   Some real bugs are also fixed:
#   - in Etrax ide.c driver REQ_DRIVE_TASKFILE requests weren't
#     handled properly for drive->addressing == 0
#   - in trm290.c read and write commands were interchanged
#   - in sgiioc4.c commands weren't sent to disk devices
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide-taskfile.c
#   2004/09/16 22:30:16+02:00 bzolnier@trik.(none) +4 -11
#   [ide] add ide_hwif_t->dma_exec_cmd()
#   
#   - split off ->dma_exec_cmd() from ->ide_dma_[read,write] functions
#   - choose command to execute by ->dma_exec_cmd() in higher layers
#     and remove ->ide_dma_[read,write]
#   
#   Some real bugs are also fixed:
#   - in Etrax ide.c driver REQ_DRIVE_TASKFILE requests weren't
#     handled properly for drive->addressing == 0
#   - in trm290.c read and write commands were interchanged
#   - in sgiioc4.c commands weren't sent to disk devices
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide-dma.c
#   2004/09/16 22:30:16+02:00 bzolnier@trik.(none) +3 -43
#   [ide] add ide_hwif_t->dma_exec_cmd()
#   
#   - split off ->dma_exec_cmd() from ->ide_dma_[read,write] functions
#   - choose command to execute by ->dma_exec_cmd() in higher layers
#     and remove ->ide_dma_[read,write]
#   
#   Some real bugs are also fixed:
#   - in Etrax ide.c driver REQ_DRIVE_TASKFILE requests weren't
#     handled properly for drive->addressing == 0
#   - in trm290.c read and write commands were interchanged
#   - in sgiioc4.c commands weren't sent to disk devices
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide-disk.c
#   2004/09/16 22:30:16+02:00 bzolnier@trik.(none) +8 -2
#   [ide] add ide_hwif_t->dma_exec_cmd()
#   
#   - split off ->dma_exec_cmd() from ->ide_dma_[read,write] functions
#   - choose command to execute by ->dma_exec_cmd() in higher layers
#     and remove ->ide_dma_[read,write]
#   
#   Some real bugs are also fixed:
#   - in Etrax ide.c driver REQ_DRIVE_TASKFILE requests weren't
#     handled properly for drive->addressing == 0
#   - in trm290.c read and write commands were interchanged
#   - in sgiioc4.c commands weren't sent to disk devices
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/arm/icside.c
#   2004/09/16 22:30:16+02:00 bzolnier@trik.(none) +2 -60
#   [ide] add ide_hwif_t->dma_exec_cmd()
#   
#   - split off ->dma_exec_cmd() from ->ide_dma_[read,write] functions
#   - choose command to execute by ->dma_exec_cmd() in higher layers
#     and remove ->ide_dma_[read,write]
#   
#   Some real bugs are also fixed:
#   - in Etrax ide.c driver REQ_DRIVE_TASKFILE requests weren't
#     handled properly for drive->addressing == 0
#   - in trm290.c read and write commands were interchanged
#   - in sgiioc4.c commands weren't sent to disk devices
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# arch/cris/arch-v10/drivers/ide.c
#   2004/09/16 22:30:16+02:00 bzolnier@trik.(none) +12 -65
#   [ide] add ide_hwif_t->dma_exec_cmd()
#   
#   - split off ->dma_exec_cmd() from ->ide_dma_[read,write] functions
#   - choose command to execute by ->dma_exec_cmd() in higher layers
#     and remove ->ide_dma_[read,write]
#   
#   Some real bugs are also fixed:
#   - in Etrax ide.c driver REQ_DRIVE_TASKFILE requests weren't
#     handled properly for drive->addressing == 0
#   - in trm290.c read and write commands were interchanged
#   - in sgiioc4.c commands weren't sent to disk devices
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# ChangeSet
#   2004/09/17 14:40:58+02:00 bzolnier@trik.(none) 
#   [ide] add ide_hwif_t->dma_setup()
#   
#   - tag REQ_DRIVE_TASKFILE write requests with REQ_RW
#   - split off ->dma_setup() from ->ide_dma_[read,write] functions
#   - use ->dma_setup() directly in ATAPI drivers and remove media
#     checks from ->ide_dma_[read,write]
#   - ->ide_dma_[read,write,begin] cannot fail now
#   - in Etrax ide.c setup DMA for ATAPI devices before sending
#     command to drive (so setup order is the same as for disks)
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# include/linux/ide.h
#   2004/09/16 22:29:51+02:00 bzolnier@trik.(none) +2 -3
#   [ide] add ide_hwif_t->dma_setup()
#   
#   - tag REQ_DRIVE_TASKFILE write requests with REQ_RW
#   - split off ->dma_setup() from ->ide_dma_[read,write] functions
#   - use ->dma_setup() directly in ATAPI drivers and remove media
#     checks from ->ide_dma_[read,write]
#   - ->ide_dma_[read,write,begin] cannot fail now
#   - in Etrax ide.c setup DMA for ATAPI devices before sending
#     command to drive (so setup order is the same as for disks)
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/scsi/ide-scsi.c
#   2004/09/16 22:29:51+02:00 bzolnier@trik.(none) +3 -6
#   [ide] add ide_hwif_t->dma_setup()
#   
#   - tag REQ_DRIVE_TASKFILE write requests with REQ_RW
#   - split off ->dma_setup() from ->ide_dma_[read,write] functions
#   - use ->dma_setup() directly in ATAPI drivers and remove media
#     checks from ->ide_dma_[read,write]
#   - ->ide_dma_[read,write,begin] cannot fail now
#   - in Etrax ide.c setup DMA for ATAPI devices before sending
#     command to drive (so setup order is the same as for disks)
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ppc/pmac.c
#   2004/09/16 22:29:51+02:00 bzolnier@trik.(none) +3 -16
#   [ide] add ide_hwif_t->dma_setup()
#   
#   - tag REQ_DRIVE_TASKFILE write requests with REQ_RW
#   - split off ->dma_setup() from ->ide_dma_[read,write] functions
#   - use ->dma_setup() directly in ATAPI drivers and remove media
#     checks from ->ide_dma_[read,write]
#   - ->ide_dma_[read,write,begin] cannot fail now
#   - in Etrax ide.c setup DMA for ATAPI devices before sending
#     command to drive (so setup order is the same as for disks)
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/pci/trm290.c
#   2004/09/16 22:29:51+02:00 bzolnier@trik.(none) +31 -35
#   [ide] add ide_hwif_t->dma_setup()
#   
#   - tag REQ_DRIVE_TASKFILE write requests with REQ_RW
#   - split off ->dma_setup() from ->ide_dma_[read,write] functions
#   - use ->dma_setup() directly in ATAPI drivers and remove media
#     checks from ->ide_dma_[read,write]
#   - ->ide_dma_[read,write,begin] cannot fail now
#   - in Etrax ide.c setup DMA for ATAPI devices before sending
#     command to drive (so setup order is the same as for disks)
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/pci/sgiioc4.c
#   2004/09/16 22:29:51+02:00 bzolnier@trik.(none) +21 -20
#   [ide] add ide_hwif_t->dma_setup()
#   
#   - tag REQ_DRIVE_TASKFILE write requests with REQ_RW
#   - split off ->dma_setup() from ->ide_dma_[read,write] functions
#   - use ->dma_setup() directly in ATAPI drivers and remove media
#     checks from ->ide_dma_[read,write]
#   - ->ide_dma_[read,write,begin] cannot fail now
#   - in Etrax ide.c setup DMA for ATAPI devices before sending
#     command to drive (so setup order is the same as for disks)
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/pci/ns87415.c
#   2004/09/16 22:29:51+02:00 bzolnier@trik.(none) +3 -15
#   [ide] add ide_hwif_t->dma_setup()
#   
#   - tag REQ_DRIVE_TASKFILE write requests with REQ_RW
#   - split off ->dma_setup() from ->ide_dma_[read,write] functions
#   - use ->dma_setup() directly in ATAPI drivers and remove media
#     checks from ->ide_dma_[read,write]
#   - ->ide_dma_[read,write,begin] cannot fail now
#   - in Etrax ide.c setup DMA for ATAPI devices before sending
#     command to drive (so setup order is the same as for disks)
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/pci/alim15x3.c
#   2004/09/16 22:29:51+02:00 bzolnier@trik.(none) +7 -8
#   [ide] add ide_hwif_t->dma_setup()
#   
#   - tag REQ_DRIVE_TASKFILE write requests with REQ_RW
#   - split off ->dma_setup() from ->ide_dma_[read,write] functions
#   - use ->dma_setup() directly in ATAPI drivers and remove media
#     checks from ->ide_dma_[read,write]
#   - ->ide_dma_[read,write,begin] cannot fail now
#   - in Etrax ide.c setup DMA for ATAPI devices before sending
#     command to drive (so setup order is the same as for disks)
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide.c
#   2004/09/16 22:29:51+02:00 bzolnier@trik.(none) +1 -0
#   [ide] add ide_hwif_t->dma_setup()
#   
#   - tag REQ_DRIVE_TASKFILE write requests with REQ_RW
#   - split off ->dma_setup() from ->ide_dma_[read,write] functions
#   - use ->dma_setup() directly in ATAPI drivers and remove media
#     checks from ->ide_dma_[read,write]
#   - ->ide_dma_[read,write,begin] cannot fail now
#   - in Etrax ide.c setup DMA for ATAPI devices before sending
#     command to drive (so setup order is the same as for disks)
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide-taskfile.c
#   2004/09/16 22:29:51+02:00 bzolnier@trik.(none) +11 -2
#   [ide] add ide_hwif_t->dma_setup()
#   
#   - tag REQ_DRIVE_TASKFILE write requests with REQ_RW
#   - split off ->dma_setup() from ->ide_dma_[read,write] functions
#   - use ->dma_setup() directly in ATAPI drivers and remove media
#     checks from ->ide_dma_[read,write]
#   - ->ide_dma_[read,write,begin] cannot fail now
#   - in Etrax ide.c setup DMA for ATAPI devices before sending
#     command to drive (so setup order is the same as for disks)
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide-tape.c
#   2004/09/16 22:29:51+02:00 bzolnier@trik.(none) +2 -6
#   [ide] add ide_hwif_t->dma_setup()
#   
#   - tag REQ_DRIVE_TASKFILE write requests with REQ_RW
#   - split off ->dma_setup() from ->ide_dma_[read,write] functions
#   - use ->dma_setup() directly in ATAPI drivers and remove media
#     checks from ->ide_dma_[read,write]
#   - ->ide_dma_[read,write,begin] cannot fail now
#   - in Etrax ide.c setup DMA for ATAPI devices before sending
#     command to drive (so setup order is the same as for disks)
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide-floppy.c
#   2004/09/16 22:29:51+02:00 bzolnier@trik.(none) +3 -7
#   [ide] add ide_hwif_t->dma_setup()
#   
#   - tag REQ_DRIVE_TASKFILE write requests with REQ_RW
#   - split off ->dma_setup() from ->ide_dma_[read,write] functions
#   - use ->dma_setup() directly in ATAPI drivers and remove media
#     checks from ->ide_dma_[read,write]
#   - ->ide_dma_[read,write,begin] cannot fail now
#   - in Etrax ide.c setup DMA for ATAPI devices before sending
#     command to drive (so setup order is the same as for disks)
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide-dma.c
#   2004/09/16 22:29:51+02:00 bzolnier@trik.(none) +15 -28
#   [ide] add ide_hwif_t->dma_setup()
#   
#   - tag REQ_DRIVE_TASKFILE write requests with REQ_RW
#   - split off ->dma_setup() from ->ide_dma_[read,write] functions
#   - use ->dma_setup() directly in ATAPI drivers and remove media
#     checks from ->ide_dma_[read,write]
#   - ->ide_dma_[read,write,begin] cannot fail now
#   - in Etrax ide.c setup DMA for ATAPI devices before sending
#     command to drive (so setup order is the same as for disks)
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide-disk.c
#   2004/09/16 22:29:51+02:00 bzolnier@trik.(none) +8 -6
#   [ide] add ide_hwif_t->dma_setup()
#   
#   - tag REQ_DRIVE_TASKFILE write requests with REQ_RW
#   - split off ->dma_setup() from ->ide_dma_[read,write] functions
#   - use ->dma_setup() directly in ATAPI drivers and remove media
#     checks from ->ide_dma_[read,write]
#   - ->ide_dma_[read,write,begin] cannot fail now
#   - in Etrax ide.c setup DMA for ATAPI devices before sending
#     command to drive (so setup order is the same as for disks)
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide-cd.c
#   2004/09/16 22:29:51+02:00 bzolnier@trik.(none) +3 -9
#   [ide] add ide_hwif_t->dma_setup()
#   
#   - tag REQ_DRIVE_TASKFILE write requests with REQ_RW
#   - split off ->dma_setup() from ->ide_dma_[read,write] functions
#   - use ->dma_setup() directly in ATAPI drivers and remove media
#     checks from ->ide_dma_[read,write]
#   - ->ide_dma_[read,write,begin] cannot fail now
#   - in Etrax ide.c setup DMA for ATAPI devices before sending
#     command to drive (so setup order is the same as for disks)
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/arm/icside.c
#   2004/09/16 22:29:51+02:00 bzolnier@trik.(none) +9 -15
#   [ide] add ide_hwif_t->dma_setup()
#   
#   - tag REQ_DRIVE_TASKFILE write requests with REQ_RW
#   - split off ->dma_setup() from ->ide_dma_[read,write] functions
#   - use ->dma_setup() directly in ATAPI drivers and remove media
#     checks from ->ide_dma_[read,write]
#   - ->ide_dma_[read,write,begin] cannot fail now
#   - in Etrax ide.c setup DMA for ATAPI devices before sending
#     command to drive (so setup order is the same as for disks)
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# arch/cris/arch-v10/drivers/ide.c
#   2004/09/16 22:29:51+02:00 bzolnier@trik.(none) +25 -37
#   [ide] add ide_hwif_t->dma_setup()
#   
#   - tag REQ_DRIVE_TASKFILE write requests with REQ_RW
#   - split off ->dma_setup() from ->ide_dma_[read,write] functions
#   - use ->dma_setup() directly in ATAPI drivers and remove media
#     checks from ->ide_dma_[read,write]
#   - ->ide_dma_[read,write,begin] cannot fail now
#   - in Etrax ide.c setup DMA for ATAPI devices before sending
#     command to drive (so setup order is the same as for disks)
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# ChangeSet
#   2004/09/17 14:35:32+02:00 bzolnier@trik.(none) 
#   [ide] unify PIO code
#   
#   Use PIO code from ide-taskfile.c in ide-disk.c so:
#   - drive status is checked after PIO read
#   - request is failed if invalid data phase
#     is detected during PIO write
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# include/linux/ide.h
#   2004/09/16 22:29:44+02:00 bzolnier@trik.(none) +0 -5
#   [ide] unify PIO code
#   
#   Use PIO code from ide-taskfile.c in ide-disk.c so:
#   - drive status is checked after PIO read
#   - request is failed if invalid data phase
#     is detected during PIO write
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide-taskfile.c
#   2004/09/16 22:29:44+02:00 bzolnier@trik.(none) +5 -10
#   [ide] unify PIO code
#   
#   Use PIO code from ide-taskfile.c in ide-disk.c so:
#   - drive status is checked after PIO read
#   - request is failed if invalid data phase
#     is detected during PIO write
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide-disk.c
#   2004/09/16 22:29:44+02:00 bzolnier@trik.(none) +2 -84
#   [ide] unify PIO code
#   
#   Use PIO code from ide-taskfile.c in ide-disk.c so:
#   - drive status is checked after PIO read
#   - request is failed if invalid data phase
#     is detected during PIO write
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# ChangeSet
#   2004/09/17 14:34:04+02:00 bzolnier@trik.(none) 
#   [ide] merge PIO write/multiwrite code (ide-disk.c)
#   
#   Merge multwrite_intr() into write_intr().
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide-disk.c
#   2004/09/10 23:50:32+02:00 bzolnier@trik.(none) +6 -34
#   [ide] merge PIO write/multiwrite code (ide-disk.c)
#   
#   Merge multwrite_intr() into write_intr().
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# ChangeSet
#   2004/09/17 14:31:58+02:00 bzolnier@trik.(none) 
#   [ide] sg PIO for fs requests
#   
#   Convert CONFIG_IDE_TASKFILE_IO=n code to use
#   scatterlist for PIO transfers.
#   
#   Fixes longstanding 'data integrity on error' issue.
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# include/linux/ide.h
#   2004/09/16 22:29:37+02:00 bzolnier@trik.(none) +5 -21
#   [ide] sg PIO for fs requests
#   
#   Convert CONFIG_IDE_TASKFILE_IO=n code to use
#   scatterlist for PIO transfers.
#   
#   Fixes longstanding 'data integrity on error' issue.
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide-taskfile.c
#   2004/09/16 22:29:37+02:00 bzolnier@trik.(none) +10 -8
#   [ide] sg PIO for fs requests
#   
#   Convert CONFIG_IDE_TASKFILE_IO=n code to use
#   scatterlist for PIO transfers.
#   
#   Fixes longstanding 'data integrity on error' issue.
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide-disk.c
#   2004/09/16 22:29:37+02:00 bzolnier@trik.(none) +60 -164
#   [ide] sg PIO for fs requests
#   
#   Convert CONFIG_IDE_TASKFILE_IO=n code to use
#   scatterlist for PIO transfers.
#   
#   Fixes longstanding 'data integrity on error' issue.
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# Documentation/block/biodoc.txt
#   2004/09/16 22:29:37+02:00 bzolnier@trik.(none) +1 -2
#   [ide] sg PIO for fs requests
#   
#   Convert CONFIG_IDE_TASKFILE_IO=n code to use
#   scatterlist for PIO transfers.
#   
#   Fixes longstanding 'data integrity on error' issue.
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# ChangeSet
#   2004/09/17 14:29:19+02:00 bzolnier@trik.(none) 
#   [ide] sg PIO for taskfile requests
#   
#   Use scatterlist for taskfile based PIO transfers
#   instead of directly walking rq->bio/cbio list.
#   
#   This code can be also used for fs requests
#   but only if CONFIG_IDE_TASKFILE_IO is defined.
#   
#   ide-taskfile.c:ide_pio_sector() is based on
#   libata-core.c:ata_pio_sector() so kudos to Jeff!
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# include/linux/ide.h
#   2004/09/16 22:29:30+02:00 bzolnier@trik.(none) +7 -29
#   [ide] sg PIO for taskfile requests
#   
#   Use scatterlist for taskfile based PIO transfers
#   instead of directly walking rq->bio/cbio list.
#   
#   This code can be also used for fs requests
#   but only if CONFIG_IDE_TASKFILE_IO is defined.
#   
#   ide-taskfile.c:ide_pio_sector() is based on
#   libata-core.c:ata_pio_sector() so kudos to Jeff!
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide-taskfile.c
#   2004/09/16 22:29:30+02:00 bzolnier@trik.(none) +64 -80
#   [ide] sg PIO for taskfile requests
#   
#   Use scatterlist for taskfile based PIO transfers
#   instead of directly walking rq->bio/cbio list.
#   
#   This code can be also used for fs requests
#   but only if CONFIG_IDE_TASKFILE_IO is defined.
#   
#   ide-taskfile.c:ide_pio_sector() is based on
#   libata-core.c:ata_pio_sector() so kudos to Jeff!
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide-io.c
#   2004/09/16 22:29:30+02:00 bzolnier@trik.(none) +28 -0
#   [ide] sg PIO for taskfile requests
#   
#   Use scatterlist for taskfile based PIO transfers
#   instead of directly walking rq->bio/cbio list.
#   
#   This code can be also used for fs requests
#   but only if CONFIG_IDE_TASKFILE_IO is defined.
#   
#   ide-taskfile.c:ide_pio_sector() is based on
#   libata-core.c:ata_pio_sector() so kudos to Jeff!
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide-disk.c
#   2004/09/16 22:29:30+02:00 bzolnier@trik.(none) +3 -4
#   [ide] sg PIO for taskfile requests
#   
#   Use scatterlist for taskfile based PIO transfers
#   instead of directly walking rq->bio/cbio list.
#   
#   This code can be also used for fs requests
#   but only if CONFIG_IDE_TASKFILE_IO is defined.
#   
#   ide-taskfile.c:ide_pio_sector() is based on
#   libata-core.c:ata_pio_sector() so kudos to Jeff!
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# ChangeSet
#   2004/09/17 14:25:21+02:00 bzolnier@trik.(none) 
#   [ide] always allocate hwif->sg_table
#   
#   Allocate hwif->sg_table in hwif_init() so it can also be used for PIO.
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# include/linux/ide.h
#   2004/09/16 22:09:48+02:00 bzolnier@trik.(none) +1 -0
#   [ide] always allocate hwif->sg_table
#   
#   Allocate hwif->sg_table in hwif_init() so it can also be used for PIO.
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/pci/sgiioc4.c
#   2004/09/16 22:29:04+02:00 bzolnier@trik.(none) +1 -8
#   [ide] always allocate hwif->sg_table
#   
#   Allocate hwif->sg_table in hwif_init() so it can also be used for PIO.
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide.c
#   2004/09/16 22:04:26+02:00 bzolnier@trik.(none) +1 -0
#   [ide] always allocate hwif->sg_table
#   
#   Allocate hwif->sg_table in hwif_init() so it can also be used for PIO.
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide-probe.c
#   2004/09/16 22:25:48+02:00 bzolnier@trik.(none) +10 -0
#   [ide] always allocate hwif->sg_table
#   
#   Allocate hwif->sg_table in hwif_init() so it can also be used for PIO.
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide-dma.c
#   2004/09/16 22:04:26+02:00 bzolnier@trik.(none) +2 -9
#   [ide] always allocate hwif->sg_table
#   
#   Allocate hwif->sg_table in hwif_init() so it can also be used for PIO.
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/arm/icside.c
#   2004/09/16 22:15:38+02:00 bzolnier@trik.(none) +1 -26
#   [ide] always allocate hwif->sg_table
#   
#   Allocate hwif->sg_table in hwif_init() so it can also be used for PIO.
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# ChangeSet
#   2004/09/17 14:15:21+02:00 bzolnier@trik.(none) 
#   [ide] add sg_init_one() helper and teach ide about it
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ppc/pmac.c
#   2004/09/10 23:15:28+02:00 bzolnier@trik.(none) +3 -8
#   [ide] add sg_init_one() helper and teach ide about it
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/ide-dma.c
#   2004/09/10 23:15:03+02:00 bzolnier@trik.(none) +3 -8
#   [ide] add sg_init_one() helper and teach ide about it
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# drivers/ide/arm/icside.c
#   2004/09/10 23:14:45+02:00 bzolnier@trik.(none) +2 -4
#   [ide] add sg_init_one() helper and teach ide about it
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# arch/cris/arch-v10/drivers/ide.c
#   2004/09/10 23:14:20+02:00 bzolnier@trik.(none) +2 -6
#   [ide] add sg_init_one() helper and teach ide about it
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# include/linux/scatterlist.h
#   2004/09/10 23:20:55+02:00 bzolnier@trik.(none) +14 -0
#   [ide] add sg_init_one() helper and teach ide about it
#   
#   Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@elka.pw.edu.pl>
# 
# include/linux/scatterlist.h
#   2004/09/10 23:20:55+02:00 bzolnier@trik.(none) +0 -0
#   BitKeeper file /home/bzolnier/bk/ide-dev-2.6/include/linux/scatterlist.h
# 
diff -Nru a/Documentation/block/biodoc.txt b/Documentation/block/biodoc.txt
--- a/Documentation/block/biodoc.txt	2004-10-10 23:09:59 -07:00
+++ b/Documentation/block/biodoc.txt	2004-10-10 23:09:59 -07:00
@@ -1172,8 +1172,7 @@
 while (IDE for example)), where the CPU is doing the actual data
 transfer a virtual mapping is needed. If the driver supports highmem I/O,
 (Sec 1.1, (ii) ) it needs to use __bio_kmap_atomic and bio_kmap_irq to
-temporarily map a bio into the virtual address space. See how IDE handles
-this with ide_map_buffer.
+temporarily map a bio into the virtual address space.
 
 
 8. Prior/Related/Impacted patches
diff -Nru a/Documentation/ide.txt b/Documentation/ide.txt
--- a/Documentation/ide.txt	2004-10-10 23:09:59 -07:00
+++ b/Documentation/ide.txt	2004-10-10 23:09:59 -07:00
@@ -248,13 +248,6 @@
  			  allowing ide-floppy, ide-tape, and ide-cdrom|writers
  			  to use ide-scsi emulation on a device specific option.
 
- "hdx=stroke"		: Should you have a system w/ an AWARD Bios and your
-			  drives are larger than 32GB and it will not boot,
-			  one is required to perform a few OEM operations first.
-			  The option is called "stroke" because it allows one
-			  to "soft clip" the drive to work around a barrier
-			  limit.
-
  "idebus=xx"		: inform IDE driver of VESA/PCI bus speed in MHz,
 			  where "xx" is between 20 and 66 inclusive,
 			  used when tuning chipset PIO modes.
@@ -304,7 +297,7 @@
 
  "ide=reverse"		: formerly called to pci sub-system, but now local.
 
-The following are valid ONLY on ide0 (except dc4030), which usually corresponds
+The following are valid ONLY on ide0, which usually corresponds
 to the first ATA interface found on the particular host, and the defaults for
 the base,ctl ports must not be altered.
 
@@ -315,7 +308,7 @@
  "ide0=qd65xx"		: probe/support qd65xx interface
  "ide0=ali14xx"		: probe/support ali14xx chipsets (ALI M1439/M1443/M1445)
  "ide0=umc8672"		: probe/support umc8672 chipsets
- "idex=dc4030"		: probe/support Promise DC4030VL interface
+
  "ide=doubler"		: probe/support IDE doublers on Amiga
 
 There may be more options than shown -- use the source, Luke!
diff -Nru a/arch/cris/arch-v10/drivers/ide.c b/arch/cris/arch-v10/drivers/ide.c
--- a/arch/cris/arch-v10/drivers/ide.c	2004-10-10 23:09:59 -07:00
+++ b/arch/cris/arch-v10/drivers/ide.c	2004-10-10 23:09:59 -07:00
@@ -30,6 +30,7 @@
 #include <linux/hdreg.h>
 #include <linux/ide.h>
 #include <linux/init.h>
+#include <linux/scatterlist.h>
 
 #include <asm/io.h>
 #include <asm/arch/svinto.h>
@@ -207,10 +208,8 @@
 #define ATA_PIO0_HOLD    4
 
 static int e100_dma_check (ide_drive_t *drive);
-static int e100_dma_begin (ide_drive_t *drive);
+static void e100_dma_start(ide_drive_t *drive);
 static int e100_dma_end (ide_drive_t *drive);
-static int e100_dma_read (ide_drive_t *drive);
-static int e100_dma_write (ide_drive_t *drive);
 static void e100_ide_input_data (ide_drive_t *drive, void *, unsigned int);
 static void e100_ide_output_data (ide_drive_t *drive, void *, unsigned int);
 static void e100_atapi_input_bytes(ide_drive_t *drive, void *, unsigned int);
@@ -281,6 +280,40 @@
 	}
 }
 
+static int e100_dma_setup(ide_drive_t *drive)
+{
+	struct request *rq = drive->hwif->hwgroup->rq;
+
+	if (rq_data_dir(rq)) {
+		e100_read_command = 0;
+
+		RESET_DMA(ATA_TX_DMA_NBR); /* sometimes the DMA channel get stuck so we need to do this */
+		WAIT_DMA(ATA_TX_DMA_NBR);
+	} else {
+		e100_read_command = 1;
+
+		RESET_DMA(ATA_RX_DMA_NBR); /* sometimes the DMA channel get stuck so we need to do this */
+		WAIT_DMA(ATA_RX_DMA_NBR);
+	}
+
+	/* set up the Etrax DMA descriptors */
+	if (e100_ide_build_dmatable(drive)) {
+		ide_map_sg(drive, rq);
+		return 1;
+	}
+
+	return 0;
+}
+
+static void e100_dma_exec_cmd(ide_drive_t *drive, u8 command)
+{
+	/* set the irq handler which will finish the request when DMA is done */
+	ide_set_handler(drive, &etrax_dma_intr, WAIT_CMD, NULL);
+
+	/* issue cmd to drive */
+	etrax100_ide_outb(command, IDE_COMMAND_REG);
+}
+
 void __init
 init_e100_ide (void)
 {
@@ -302,9 +335,9 @@
                 hwif->atapi_output_bytes = &e100_atapi_output_bytes;
                 hwif->ide_dma_check = &e100_dma_check;
                 hwif->ide_dma_end = &e100_dma_end;
-		hwif->ide_dma_write = &e100_dma_write;
-		hwif->ide_dma_read = &e100_dma_read;
-		hwif->ide_dma_begin = &e100_dma_begin;
+		hwif->dma_setup = &e100_dma_setup;
+		hwif->dma_exec_cmd = &e100_dma_exec_cmd;
+		hwif->dma_start = &e100_dma_start;
 		hwif->OUTB = &etrax100_ide_outb;
 		hwif->OUTW = &etrax100_ide_outw;
 		hwif->OUTBSYNC = &etrax100_ide_outbsync;
@@ -623,20 +656,9 @@
 
 	ata_tot_size = 0;
 
-	if (HWGROUP(drive)->rq->flags & REQ_DRIVE_TASKFILE) {
-		u8 *virt_addr = rq->buffer;
-		int sector_count = rq->nr_sectors;
-		memset(&sg[0], 0, sizeof(*sg));
-		sg[0].page = virt_to_page(virt_addr);
-		sg[0].offset = offset_in_page(virt_addr);
-		sg[0].length =  sector_count  * SECTOR_SIZE;
-		hwif->sg_nents = i = 1;
-	}
-	else
-	{
-		hwif->sg_nents = i = blk_rq_map_sg(drive->queue, rq, hwif->sg_table);
-	}
+	ide_map_sg(drive, rq);
 
+	i = hwif->sg_nents;
 
 	while(i) {
 		/*
@@ -773,10 +795,6 @@
  * sector address using CHS or LBA.  All that remains is to prepare for DMA
  * and then issue the actual read/write DMA/PIO command to the drive.
  *
- * For ATAPI devices, we just prepare for DMA and return. The caller should
- * then issue the packet command to the drive and call us again with
- * ide_dma_begin afterwards.
- *
  * Returns 0 if all went well.
  * Returns 1 if DMA read/write could not be started, in which case
  * the caller should revert to PIO for the current request.
@@ -793,35 +811,9 @@
 	return 0;
 }
 
-static int e100_start_dma(ide_drive_t *drive, int atapi, int reading)
+static void e100_dma_start(ide_drive_t *drive)
 {
-	if(reading) {
-
-		RESET_DMA(ATA_RX_DMA_NBR); /* sometimes the DMA channel get stuck so we need to do this */
-		WAIT_DMA(ATA_RX_DMA_NBR);
-
-		/* set up the Etrax DMA descriptors */
-
-		if(e100_ide_build_dmatable (drive))
-			return 1;
-
-		if(!atapi) {
-			/* set the irq handler which will finish the request when DMA is done */
-
-			ide_set_handler(drive, &etrax_dma_intr, WAIT_CMD, NULL);
-
-			/* issue cmd to drive */
-                        if ((HWGROUP(drive)->rq->cmd == IDE_DRIVE_TASKFILE) &&
-			    (drive->addressing == 1)) {
-				ide_task_t *args = HWGROUP(drive)->rq->special;
-				etrax100_ide_outb(args->tfRegister[IDE_COMMAND_OFFSET], IDE_COMMAND_REG);
-			} else if (drive->addressing) {
-				etrax100_ide_outb(WIN_READDMA_EXT, IDE_COMMAND_REG);
-			} else {
-				etrax100_ide_outb(WIN_READDMA, IDE_COMMAND_REG);
-			}
-		}
-
+	if (e100_read_command) {
 		/* begin DMA */
 
 		/* need to do this before RX DMA due to a chip bug
@@ -854,32 +846,6 @@
 
 	} else {
 		/* writing */
-
-		RESET_DMA(ATA_TX_DMA_NBR); /* sometimes the DMA channel get stuck so we need to do this */
-		WAIT_DMA(ATA_TX_DMA_NBR);
-
-		/* set up the Etrax DMA descriptors */
-
-		if(e100_ide_build_dmatable (drive))
-			return 1;
-
-		if(!atapi) {
-			/* set the irq handler which will finish the request when DMA is done */
-
-			ide_set_handler(drive, &etrax_dma_intr, WAIT_CMD, NULL);
-
-			/* issue cmd to drive */
-			if ((HWGROUP(drive)->rq->cmd == IDE_DRIVE_TASKFILE) &&
-			    (drive->addressing == 1)) {
-				ide_task_t *args = HWGROUP(drive)->rq->special;
-				etrax100_ide_outb(args->tfRegister[IDE_COMMAND_OFFSET], IDE_COMMAND_REG);
-			} else if (drive->addressing) {
-				etrax100_ide_outb(WIN_WRITEDMA_EXT, IDE_COMMAND_REG);
-			} else {
-				etrax100_ide_outb(WIN_WRITEDMA, IDE_COMMAND_REG);
-			}
-		}
-
 		/* begin DMA */
 
 		*R_DMA_CH2_FIRST = virt_to_phys(ata_descrs);
@@ -902,44 +868,4 @@
 
 		D(printk("dma write of %d bytes.\n", ata_tot_size));
 	}
-	return 0;
-}
-
-static int e100_dma_write(ide_drive_t *drive)
-{
-	e100_read_command = 0;
-	/* ATAPI-devices (not disks) first call ide_dma_read/write to set the direction
-	 * then they call ide_dma_begin after they have issued the appropriate drive command
-	 * themselves to actually start the chipset DMA. so we just return here if we're
-	 * not a diskdrive.
-	 */
-	if (drive->media != ide_disk)
-                return 0;
-	return e100_start_dma(drive, 0, 0);
-}
-
-static int e100_dma_read(ide_drive_t *drive)
-{
-	e100_read_command = 1;
-	/* ATAPI-devices (not disks) first call ide_dma_read/write to set the direction
-	 * then they call ide_dma_begin after they have issued the appropriate drive command
-	 * themselves to actually start the chipset DMA. so we just return here if we're
-	 * not a diskdrive.
-	 */
-	if (drive->media != ide_disk)
-                return 0;
-	return e100_start_dma(drive, 0, 1);
-}
-
-static int e100_dma_begin(ide_drive_t *drive)
-{
-	/* begin DMA, used by ATAPI devices which want to issue the
-	 * appropriate IDE command themselves.
-	 *
-	 * they have already called ide_dma_read/write to set the
-	 * static reading flag, now they call ide_dma_begin to do
-	 * the real stuff. we tell our code below not to issue
-	 * any IDE commands itself and jump into it.
-	 */
-	 return e100_start_dma(drive, 1, e100_read_command);
 }
diff -Nru a/drivers/ide/Kconfig b/drivers/ide/Kconfig
--- a/drivers/ide/Kconfig	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/Kconfig	2004-10-10 23:09:59 -07:00
@@ -273,15 +273,6 @@
 
 	  If you are unsure, say N here.
 
-config IDE_TASKFILE_IO
-	bool 'IDE Taskfile IO (EXPERIMENTAL)'
-	depends on EXPERIMENTAL
-	default n
-	---help---
-	  Use new taskfile IO code.
-
-	  It is safe to say Y to this question, in most cases.
-
 comment "IDE chipset support/bugfixes"
 
 config IDE_GENERIC
@@ -668,13 +659,6 @@
 config BLK_DEV_PDC202XX_NEW
 	tristate "PROMISE PDC202{68|69|70|71|75|76|77} support"
 
-# FIXME - probably wants to be one for old and for new
-config PDC202XX_FORCE
-	bool "Enable controller even if disabled by BIOS"
-	depends on BLK_DEV_PDC202XX_NEW
-	help
-	  Enable the PDC202xx controller even if it has been disabled in the BIOS setup.
-
 config BLK_DEV_SVWKS
 	tristate "ServerWorks OSB4/CSB5/CSB6 chipsets support"
 	help
@@ -781,17 +765,6 @@
 	  This option enables the use of the sleep LED as a hard drive
 	  activity LED.
 
-config BLK_DEV_IDEDMA_PMAC_AUTO
-	bool "Use DMA by default"
-	depends on BLK_DEV_IDEDMA_PMAC
-	help
-	  This option allows the driver for the built-in IDE controller on
-	  Power Macintoshes and PowerBooks to use DMA automatically, without
-	  it having to be explicitly enabled.  This option is provided because
-	  of concerns about a couple of cases where using DMA on buggy PC
-	  hardware may have caused damage.  Saying Y should be safe on all
-	  Apple machines.
-
 config IDE_ARM
 	def_bool ARM && (ARCH_A5K || ARCH_CLPS7500 || ARCH_RPC || ARCH_SHARK)
 
@@ -1007,19 +980,6 @@
 	  See the <file:Documentation/ide.txt> and
 	  <file:drivers/ide/legacy/ht6560b.c> files for more info.
 
-config BLK_DEV_PDC4030
-	tristate "PROMISE DC4030 support (EXPERIMENTAL)"
-	depends on BLK_DEV_IDEDISK && EXPERIMENTAL
-	help
-	  This driver provides support for the secondary IDE interface and
-	  cache of the original Promise IDE chipsets, e.g. DC4030 and DC5030.
-	  It is nothing to do with the later range of Promise UDMA chipsets -
-	  see the PDC_202XX support for these. CD-ROM and TAPE devices are not
-	  supported (and probably never will be since I don't think the cards
-	  support them). This driver is enabled at runtime using the "ide0=dc4030"
-	  or "ide1=dc4030" kernel boot parameter. See the
-	  <file:drivers/ide/legacy/pdc4030.c> file for more info.
-
 config BLK_DEV_QD65XX
 	tristate "QDI QD65xx support"
 	help
@@ -1059,7 +1019,7 @@
 	  It is normally safe to answer Y; however, the default is N.
 
 config IDEDMA_AUTO
-	def_bool IDEDMA_PCI_AUTO || BLK_DEV_IDEDMA_PMAC_AUTO || IDEDMA_ICS_AUTO
+	def_bool IDEDMA_PCI_AUTO || IDEDMA_ICS_AUTO
 
 endif
 
diff -Nru a/drivers/ide/arm/icside.c b/drivers/ide/arm/icside.c
--- a/drivers/ide/arm/icside.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/arm/icside.c	2004-10-10 23:09:59 -07:00
@@ -16,6 +16,7 @@
 #include <linux/dma-mapping.h>
 #include <linux/device.h>
 #include <linux/init.h>
+#include <linux/scatterlist.h>
 
 #include <asm/dma.h>
 #include <asm/ecard.h>
@@ -196,6 +197,11 @@
 }
 
 #ifdef CONFIG_BLK_DEV_IDEDMA_ICS
+
+#ifndef CONFIG_IDEDMA_ICS_AUTO
+#warning CONFIG_IDEDMA_ICS_AUTO option is obsolete, and will be removed soon.
+#endif
+
 /*
  * SG-DMA support.
  *
@@ -205,15 +211,12 @@
  * here, but we rely on the main IDE driver spotting that both
  * interfaces use the same IRQ, which should guarantee this.
  */
-#define NR_ENTRIES 256
-#define TABLE_SIZE (NR_ENTRIES * 8)
 
 static void icside_build_sglist(ide_drive_t *drive, struct request *rq)
 {
 	ide_hwif_t *hwif = drive->hwif;
 	struct icside_state *state = hwif->hwif_data;
 	struct scatterlist *sg = hwif->sg_table;
-	int nents;
 
 	if (rq->flags & REQ_DRIVE_TASKFILE) {
 		ide_task_t *args = rq->special;
@@ -223,13 +226,9 @@
 		else
 			hwif->sg_dma_direction = DMA_FROM_DEVICE;
 
-		memset(sg, 0, sizeof(*sg));
-		sg->page   = virt_to_page(rq->buffer);
-		sg->offset = offset_in_page(rq->buffer);
-		sg->length = rq->nr_sectors * SECTOR_SIZE;
-		nents = 1;
+		ide_map_sg(drive, rq);
 	} else {
-		nents = blk_rq_map_sg(drive->queue, rq, sg);
+		ide_map_sg(drive, rq);
 
 		if (rq_data_dir(rq) == READ)
 			hwif->sg_dma_direction = DMA_FROM_DEVICE;
@@ -237,12 +236,10 @@
 			hwif->sg_dma_direction = DMA_TO_DEVICE;
 	}
 
-	nents = dma_map_sg(state->dev, sg, nents, hwif->sg_dma_direction);
-
-	hwif->sg_nents = nents;
+	hwif->sg_nents = dma_map_sg(state->dev, sg, hwif->sg_nents,
+				    hwif->sg_dma_direction);
 }
 
-
 /*
  * Configure the IOMD to give the appropriate timings for the transfer
  * mode being requested.  We take the advice of the ATA standards, and
@@ -402,14 +399,13 @@
 	return get_dma_residue(hwif->hw.dma) != 0;
 }
 
-static int icside_dma_begin(ide_drive_t *drive)
+static void icside_dma_start(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif = HWIF(drive);
 
 	/* We can not enable DMA on both channels simultaneously. */
 	BUG_ON(dma_channel_active(hwif->hw.dma));
 	enable_dma(hwif->hw.dma);
-	return 0;
 }
 
 /*
@@ -441,11 +437,16 @@
 	return DRIVER(drive)->error(drive, __FUNCTION__, stat);
 }
 
-static int
-icside_dma_common(ide_drive_t *drive, struct request *rq,
-		  unsigned int dma_mode)
+static int icside_dma_setup(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif = HWIF(drive);
+	struct request *rq = hwif->hwgroup->rq;
+	unsigned int dma_mode;
+
+	if (rq_data_dir(rq))
+		dma_mode = DMA_MODE_WRITE;
+	else
+		dma_mode = DMA_MODE_READ;
 
 	/*
 	 * We can not enable DMA on both channels.
@@ -481,79 +482,10 @@
 	return 0;
 }
 
-static int icside_dma_read(ide_drive_t *drive)
-{
-	struct request *rq = HWGROUP(drive)->rq;
-	task_ioreg_t cmd;
-
-	if (icside_dma_common(drive, rq, DMA_MODE_READ))
-		return 1;
-
-	if (drive->media != ide_disk)
-		return 0;
-
-	BUG_ON(HWGROUP(drive)->handler != NULL);
-
-	/*
-	 * FIX ME to use only ACB ide_task_t args Struct
-	 */
-#if 0
-	{
-		ide_task_t *args = rq->special;
-		cmd = args->tfRegister[IDE_COMMAND_OFFSET];
-	}
-#else
-	if (rq->flags & REQ_DRIVE_TASKFILE) {
-		ide_task_t *args = rq->special;
-		cmd = args->tfRegister[IDE_COMMAND_OFFSET];
-	} else if (drive->addressing == 1) {
-		cmd = WIN_READDMA_EXT;
-	} else {
-		cmd = WIN_READDMA;
-	}
-#endif
-	/* issue cmd to drive */
-	ide_execute_command(drive, cmd, icside_dmaintr, 2*WAIT_CMD, NULL);
-
-	return icside_dma_begin(drive);
-}
-
-static int icside_dma_write(ide_drive_t *drive)
+static void icside_dma_exec_cmd(ide_drive_t *drive, u8 command)
 {
-	struct request *rq = HWGROUP(drive)->rq;
-	task_ioreg_t cmd;
-
-	if (icside_dma_common(drive, rq, DMA_MODE_WRITE))
-		return 1;
-
-	if (drive->media != ide_disk)
-		return 0;
-
-	BUG_ON(HWGROUP(drive)->handler != NULL);
-
-	/*
-	 * FIX ME to use only ACB ide_task_t args Struct
-	 */
-#if 0
-	{
-		ide_task_t *args = rq->special;
-		cmd = args->tfRegister[IDE_COMMAND_OFFSET];
-	}
-#else
-	if (rq->flags & REQ_DRIVE_TASKFILE) {
-		ide_task_t *args = rq->special;
-		cmd = args->tfRegister[IDE_COMMAND_OFFSET];
-	} else if (drive->addressing == 1) {
-		cmd = WIN_WRITEDMA_EXT;
-	} else {
-		cmd = WIN_WRITEDMA;
-	}
-#endif
-
 	/* issue cmd to drive */
 	ide_execute_command(drive, cmd, icside_dmaintr, 2*WAIT_CMD, NULL);
-
-	return icside_dma_begin(drive);
 }
 
 static int icside_dma_test_irq(ide_drive_t *drive)
@@ -567,14 +499,6 @@
 			ICS_ARCIN_V6_INTRSTAT_1)) & 1;
 }
 
-static int icside_dma_verbose(ide_drive_t *drive)
-{
-	printk(", %s (peak %dMB/s)",
-		ide_xfer_verbose(drive->current_speed),
-		2000 / drive->drive_data);
-	return 1;
-}
-
 static int icside_dma_timeout(ide_drive_t *drive)
 {
 	printk(KERN_ERR "%s: DMA timeout occurred: ", drive->name);
@@ -594,7 +518,7 @@
 	return 1;
 }
 
-static int icside_dma_init(ide_hwif_t *hwif)
+static void icside_dma_init(ide_hwif_t *hwif)
 {
 	int autodma = 0;
 
@@ -604,11 +528,6 @@
 
 	printk("    %s: SG-DMA", hwif->name);
 
-	hwif->sg_table = kmalloc(sizeof(struct scatterlist) * NR_ENTRIES,
-				 GFP_KERNEL);
-	if (!hwif->sg_table)
-		goto failed;
-
 	hwif->atapi_dma		= 1;
 	hwif->mwdma_mask	= 7; /* MW0..2 */
 	hwif->swdma_mask	= 7; /* SW0..2 */
@@ -623,12 +542,11 @@
 	hwif->ide_dma_off_quietly = icside_dma_off_quietly;
 	hwif->ide_dma_host_on	= icside_dma_host_on;
 	hwif->ide_dma_on	= icside_dma_on;
-	hwif->ide_dma_read	= icside_dma_read;
-	hwif->ide_dma_write	= icside_dma_write;
-	hwif->ide_dma_begin	= icside_dma_begin;
+	hwif->dma_setup		= icside_dma_setup;
+	hwif->dma_exec_cmd	= icside_dma_exec_cmd;
+	hwif->dma_start		= icside_dma_start;
 	hwif->ide_dma_end	= icside_dma_end;
 	hwif->ide_dma_test_irq	= icside_dma_test_irq;
-	hwif->ide_dma_verbose	= icside_dma_verbose;
 	hwif->ide_dma_timeout	= icside_dma_timeout;
 	hwif->ide_dma_lostirq	= icside_dma_lostirq;
 
@@ -636,24 +554,9 @@
 	hwif->drives[1].autodma = hwif->autodma;
 
 	printk(" capable%s\n", hwif->autodma ? ", auto-enable" : "");
-
-	return 1;
-
-failed:
-	printk(" disabled, unable to allocate DMA table\n");
-	return 0;
-}
-
-static void icside_dma_exit(ide_hwif_t *hwif)
-{
-	if (hwif->sg_table) {
-		kfree(hwif->sg_table);
-		hwif->sg_table = NULL;
-	}
 }
 #else
 #define icside_dma_init(hwif)	(0)
-#define icside_dma_exit(hwif)	do { } while (0)
 #endif
 
 static ide_hwif_t *icside_find_hwif(unsigned long dataport)
@@ -878,9 +781,6 @@
 
 	case ICS_TYPE_V6:
 		/* FIXME: tell IDE to stop using the interface */
-		icside_dma_exit(state->hwif[1]);
-		icside_dma_exit(state->hwif[0]);
-
 		if (ec->dma != NO_DMA)
 			free_dma(ec->dma);
 
diff -Nru a/drivers/ide/ide-cd.c b/drivers/ide/ide-cd.c
--- a/drivers/ide/ide-cd.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/ide-cd.c	2004-10-10 23:09:59 -07:00
@@ -865,20 +865,14 @@
 {
 	ide_startstop_t startstop;
 	struct cdrom_info *info = drive->driver_data;
+	ide_hwif_t *hwif = drive->hwif;
 
 	/* Wait for the controller to be idle. */
 	if (ide_wait_stat(&startstop, drive, 0, BUSY_STAT, WAIT_READY))
 		return startstop;
 
-	if (info->dma) {
-		if (info->cmd == READ) {
-			info->dma = !HWIF(drive)->ide_dma_read(drive);
-		} else if (info->cmd == WRITE) {
-			info->dma = !HWIF(drive)->ide_dma_write(drive);
-		} else {
-			printk("ide-cd: DMA set, but not allowed\n");
-		}
-	}
+	if (info->dma)
+		info->dma = !hwif->dma_setup(drive);
 
 	/* Set up the controller registers. */
 	/* FIXME: for Virtual DMA we must check harder */
@@ -916,6 +910,7 @@
 					  struct request *rq,
 					  ide_handler_t *handler)
 {
+	ide_hwif_t *hwif = drive->hwif;
 	int cmd_len;
 	struct cdrom_info *info = drive->driver_data;
 	ide_startstop_t startstop;
@@ -947,7 +942,7 @@
 
 	/* Start the DMA if need be */
 	if (info->dma)
-		(void) HWIF(drive)->ide_dma_begin(drive);
+		hwif->dma_start(drive);
 
 	return ide_started;
 }
@@ -3040,10 +3035,9 @@
 
 	printk(", %dkB Cache", be16_to_cpu(cap.buffer_size));
 
-#ifdef CONFIG_BLK_DEV_IDEDMA
 	if (drive->using_dma)
-		(void) HWIF(drive)->ide_dma_verbose(drive);
-#endif /* CONFIG_BLK_DEV_IDEDMA */
+		ide_dma_verbose(drive);
+
 	printk("\n");
 
 	return nslots;
diff -Nru a/drivers/ide/ide-disk.c b/drivers/ide/ide-disk.c
--- a/drivers/ide/ide-disk.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/ide-disk.c	2004-10-10 23:09:59 -07:00
@@ -71,10 +71,6 @@
 #include <asm/io.h>
 #include <asm/div64.h>
 
-/* FIXME: some day we shouldn't need to look in here! */
-
-#include "legacy/pdc4030.h"
-
 /*
  * lba_capacity_is_ok() performs a sanity check on the claimed "lba_capacity"
  * value for this drive (from its reported identification information).
@@ -120,218 +116,6 @@
 	return 0;	/* lba_capacity value may be bad */
 }
 
-#ifndef CONFIG_IDE_TASKFILE_IO
-
-/*
- * read_intr() is the handler for disk read/multread interrupts
- */
-static ide_startstop_t read_intr (ide_drive_t *drive)
-{
-	ide_hwif_t *hwif	= HWIF(drive);
-	u32 i = 0, nsect	= 0, msect = drive->mult_count;
-	struct request *rq;
-	unsigned long flags;
-	u8 stat;
-	char *to;
-
-	/* new way for dealing with premature shared PCI interrupts */
-	if (!OK_STAT(stat=hwif->INB(IDE_STATUS_REG),DATA_READY,BAD_R_STAT)) {
-		if (stat & (ERR_STAT|DRQ_STAT)) {
-			return DRIVER(drive)->error(drive, "read_intr", stat);
-		}
-		/* no data yet, so wait for another interrupt */
-		ide_set_handler(drive, &read_intr, WAIT_CMD, NULL);
-		return ide_started;
-	}
-	
-read_next:
-	rq = HWGROUP(drive)->rq;
-	if (msect) {
-		if ((nsect = rq->current_nr_sectors) > msect)
-			nsect = msect;
-		msect -= nsect;
-	} else
-		nsect = 1;
-	to = ide_map_buffer(rq, &flags);
-	taskfile_input_data(drive, to, nsect * SECTOR_WORDS);
-#ifdef DEBUG
-	printk("%s:  read: sectors(%ld-%ld), buffer=0x%08lx, remaining=%ld\n",
-		drive->name, rq->sector, rq->sector+nsect-1,
-		(unsigned long) rq->buffer+(nsect<<9), rq->nr_sectors-nsect);
-#endif
-	ide_unmap_buffer(rq, to, &flags);
-	rq->sector += nsect;
-	rq->errors = 0;
-	i = (rq->nr_sectors -= nsect);
-	if (((long)(rq->current_nr_sectors -= nsect)) <= 0)
-		ide_end_request(drive, 1, rq->hard_cur_sectors);
-	/*
-	 * Another BH Page walker and DATA INTEGRITY Questioned on ERROR.
-	 * If passed back up on multimode read, BAD DATA could be ACKED
-	 * to FILE SYSTEMS above ...
-	 */
-	if (i > 0) {
-		if (msect)
-			goto read_next;
-		ide_set_handler(drive, &read_intr, WAIT_CMD, NULL);
-                return ide_started;
-	}
-        return ide_stopped;
-}
-
-/*
- * write_intr() is the handler for disk write interrupts
- */
-static ide_startstop_t write_intr (ide_drive_t *drive)
-{
-	ide_hwgroup_t *hwgroup	= HWGROUP(drive);
-	ide_hwif_t *hwif	= HWIF(drive);
-	struct request *rq	= hwgroup->rq;
-	u32 i = 0;
-	u8 stat;
-
-	if (!OK_STAT(stat = hwif->INB(IDE_STATUS_REG),
-			DRIVE_READY, drive->bad_wstat)) {
-		printk("%s: write_intr error1: nr_sectors=%ld, stat=0x%02x\n",
-			drive->name, rq->nr_sectors, stat);
-        } else {
-#ifdef DEBUG
-		printk("%s: write: sector %ld, buffer=0x%08lx, remaining=%ld\n",
-			drive->name, rq->sector, (unsigned long) rq->buffer,
-			rq->nr_sectors-1);
-#endif
-		if ((rq->nr_sectors == 1) ^ ((stat & DRQ_STAT) != 0)) {
-			rq->sector++;
-			rq->errors = 0;
-			i = --rq->nr_sectors;
-			--rq->current_nr_sectors;
-			if (((long)rq->current_nr_sectors) <= 0)
-				ide_end_request(drive, 1, rq->hard_cur_sectors);
-			if (i > 0) {
-				unsigned long flags;
-				char *to = ide_map_buffer(rq, &flags);
-				taskfile_output_data(drive, to, SECTOR_WORDS);
-				ide_unmap_buffer(rq, to, &flags);
-				ide_set_handler(drive, &write_intr, WAIT_CMD, NULL);
-                                return ide_started;
-			}
-                        return ide_stopped;
-		}
-		/* the original code did this here (?) */
-		return ide_stopped;
-	}
-	return DRIVER(drive)->error(drive, "write_intr", stat);
-}
-
-/*
- * ide_multwrite() transfers a block of up to mcount sectors of data
- * to a drive as part of a disk multiple-sector write operation.
- *
- * Note that we may be called from two contexts - __ide_do_rw_disk() context
- * and IRQ context. The IRQ can happen any time after we've output the
- * full "mcount" number of sectors, so we must make sure we update the
- * state _before_ we output the final part of the data!
- *
- * The update and return to BH is a BLOCK Layer Fakey to get more data
- * to satisfy the hardware atomic segment.  If the hardware atomic segment
- * is shorter or smaller than the BH segment then we should be OKAY.
- * This is only valid if we can rewind the rq->current_nr_sectors counter.
- */
-static void ide_multwrite(ide_drive_t *drive, unsigned int mcount)
-{
- 	ide_hwgroup_t *hwgroup	= HWGROUP(drive);
- 	struct request *rq	= &hwgroup->wrq;
- 
-  	do {
-  		char *buffer;
-  		int nsect = rq->current_nr_sectors;
-		unsigned long flags;
- 
-		if (nsect > mcount)
-			nsect = mcount;
-		mcount -= nsect;
-		buffer = ide_map_buffer(rq, &flags);
-
-		rq->sector += nsect;
-		rq->nr_sectors -= nsect;
-		rq->current_nr_sectors -= nsect;
-
-		/* Do we move to the next bh after this? */
-		if (!rq->current_nr_sectors) {
-			struct bio *bio = rq->bio;
-
-			/*
-			 * only move to next bio, when we have processed
-			 * all bvecs in this one.
-			 */
-			if (++bio->bi_idx >= bio->bi_vcnt) {
-				bio->bi_idx = bio->bi_vcnt - rq->nr_cbio_segments;
-				bio = bio->bi_next;
-			}
-
-			/* end early early we ran out of requests */
-			if (!bio) {
-				mcount = 0;
-			} else {
-				rq->bio = bio;
-				rq->nr_cbio_segments = bio_segments(bio);
-				rq->current_nr_sectors = bio_cur_sectors(bio);
-				rq->hard_cur_sectors = rq->current_nr_sectors;
-			}
-		}
-
-		/*
-		 * Ok, we're all setup for the interrupt
-		 * re-entering us on the last transfer.
-		 */
-		taskfile_output_data(drive, buffer, nsect<<7);
-		ide_unmap_buffer(rq, buffer, &flags);
-	} while (mcount);
-}
-
-/*
- * multwrite_intr() is the handler for disk multwrite interrupts
- */
-static ide_startstop_t multwrite_intr (ide_drive_t *drive)
-{
-	ide_hwgroup_t *hwgroup	= HWGROUP(drive);
-	ide_hwif_t *hwif	= HWIF(drive);
-	struct request *rq	= &hwgroup->wrq;
-	struct bio *bio		= rq->bio;
-	u8 stat;
-
-	stat = hwif->INB(IDE_STATUS_REG);
-	if (OK_STAT(stat, DRIVE_READY, drive->bad_wstat)) {
-		if (stat & DRQ_STAT) {
-			/*
-			 *	The drive wants data. Remember rq is the copy
-			 *	of the request
-			 */
-			if (rq->nr_sectors) {
-				ide_multwrite(drive, drive->mult_count);
-				ide_set_handler(drive, &multwrite_intr, WAIT_CMD, NULL);
-				return ide_started;
-			}
-		} else {
-			/*
-			 *	If the copy has all the blocks completed then
-			 *	we can end the original request.
-			 */
-			if (!rq->nr_sectors) {	/* all done? */
-				bio->bi_idx = bio->bi_vcnt - rq->nr_cbio_segments;
-				rq = hwgroup->rq;
-				ide_end_request(drive, 1, rq->nr_sectors);
-				return ide_stopped;
-			}
-		}
-		bio->bi_idx = bio->bi_vcnt - rq->nr_cbio_segments;
-		/* the original code did this here (?) */
-		return ide_stopped;
-	}
-	bio->bi_idx = bio->bi_vcnt - rq->nr_cbio_segments;
-	return DRIVER(drive)->error(drive, "multwrite_intr", stat);
-}
-
 /*
  * __ide_do_rw_disk() issues READ and WRITE commands to a disk,
  * using LBA if supported, or CHS otherwise, to address sectors.
@@ -352,6 +136,11 @@
 			dma = 0;
 	}
 
+	if (!dma) {
+		ide_init_sg_cmd(drive, rq);
+		ide_map_sg(drive, rq);
+	}
+
 	if (IDE_CONTROL_REG)
 		hwif->OUTB(drive->ctl, IDE_CONTROL_REG);
 
@@ -419,172 +208,54 @@
 		hwif->OUTB(head|drive->select.all,IDE_SELECT_REG);
 	}
 
-	if (rq_data_dir(rq) == READ) {
-		if (dma && !hwif->ide_dma_read(drive))
-			return ide_started;
-
-		command = ((drive->mult_count) ?
-			   ((lba48) ? WIN_MULTREAD_EXT : WIN_MULTREAD) :
-			   ((lba48) ? WIN_READ_EXT : WIN_READ));
-		ide_execute_command(drive, command, &read_intr, WAIT_CMD, NULL);
-		return ide_started;
-	} else {
-		ide_startstop_t startstop;
-
-		if (dma && !hwif->ide_dma_write(drive))
+	if (dma) {
+		if (!hwif->dma_setup(drive)) {
+			if (rq_data_dir(rq)) {
+				command = lba48 ? WIN_WRITEDMA_EXT : WIN_WRITEDMA;
+				if (drive->vdma)
+					command = lba48 ? WIN_WRITE_EXT: WIN_WRITE;
+			} else {
+				command = lba48 ? WIN_READDMA_EXT : WIN_READDMA;
+				if (drive->vdma)
+					command = lba48 ? WIN_READ_EXT: WIN_READ;
+			}
+			hwif->dma_exec_cmd(drive, command);
+			hwif->dma_start(drive);
 			return ide_started;
-
-		command = ((drive->mult_count) ?
-			   ((lba48) ? WIN_MULTWRITE_EXT : WIN_MULTWRITE) :
-			   ((lba48) ? WIN_WRITE_EXT : WIN_WRITE));
-		hwif->OUTB(command, IDE_COMMAND_REG);
-
-		if (ide_wait_stat(&startstop, drive, DATA_READY,
-				drive->bad_wstat, WAIT_DRQ)) {
-			printk(KERN_ERR "%s: no DRQ after issuing %s\n",
-				drive->name,
-				drive->mult_count ? "MULTWRITE" : "WRITE");
-			return startstop;
 		}
-		if (!drive->unmask)
-			local_irq_disable();
-		if (drive->mult_count) {
-			ide_hwgroup_t *hwgroup = HWGROUP(drive);
-
-			hwgroup->wrq = *rq; /* scratchpad */
-			ide_set_handler(drive, &multwrite_intr, WAIT_CMD, NULL);
-			ide_multwrite(drive, drive->mult_count);
-		} else {
-			unsigned long flags;
-			char *to = ide_map_buffer(rq, &flags);
-			ide_set_handler(drive, &write_intr, WAIT_CMD, NULL);
-			taskfile_output_data(drive, to, SECTOR_WORDS);
-			ide_unmap_buffer(rq, to, &flags);
-		}
-		return ide_started;
-	}
-}
-EXPORT_SYMBOL_GPL(__ide_do_rw_disk);
-
-#else /* CONFIG_IDE_TASKFILE_IO */
-
-static ide_startstop_t chs_rw_disk(ide_drive_t *, struct request *, unsigned long);
-static ide_startstop_t lba_28_rw_disk(ide_drive_t *, struct request *, unsigned long);
-static ide_startstop_t lba_48_rw_disk(ide_drive_t *, struct request *, unsigned long long);
-
-/*
- * __ide_do_rw_disk() issues READ and WRITE commands to a disk,
- * using LBA if supported, or CHS otherwise, to address sectors.
- * It also takes care of issuing special DRIVE_CMDs.
- */
-ide_startstop_t __ide_do_rw_disk (ide_drive_t *drive, struct request *rq, sector_t block)
-{
-	/*
-	 * 268435455  == 137439 MB or 28bit limit
-	 *
-	 * need to add split taskfile operations based on 28bit threshold.
-	 */
-	if (drive->addressing == 1)		/* 48-bit LBA */
-		return lba_48_rw_disk(drive, rq, (unsigned long long) block);
-	if (drive->select.b.lba)		/* 28-bit LBA */
-		return lba_28_rw_disk(drive, rq, (unsigned long) block);
-
-	/* 28-bit CHS : DIE DIE DIE piece of legacy crap!!! */
-	return chs_rw_disk(drive, rq, (unsigned long) block);
-}
-EXPORT_SYMBOL_GPL(__ide_do_rw_disk);
-
-static u8 get_command(ide_drive_t *drive, struct request *rq, ide_task_t *task)
-{
-	unsigned int lba48 = (drive->addressing == 1) ? 1 : 0;
-	unsigned int dma = drive->using_dma;
-
-	if (drive->hwif->no_lba48_dma && lba48 && dma) {
-		if (rq->sector + rq->nr_sectors > 1ULL << 28)
-			dma = 0;
+		/* fallback to PIO */
+		ide_init_sg_cmd(drive, rq);
 	}
 
 	if (rq_data_dir(rq) == READ) {
-		task->command_type = IDE_DRIVE_TASK_IN;
-		if (dma)
-			return lba48 ? WIN_READDMA_EXT : WIN_READDMA;
-		task->handler = &task_in_intr;
+
 		if (drive->mult_count) {
-			task->data_phase = TASKFILE_MULTI_IN;
-			return lba48 ? WIN_MULTREAD_EXT : WIN_MULTREAD;
+			hwif->data_phase = TASKFILE_MULTI_IN;
+			command = lba48 ? WIN_MULTREAD_EXT : WIN_MULTREAD;
+		} else {
+			hwif->data_phase = TASKFILE_IN;
+			command = lba48 ? WIN_READ_EXT : WIN_READ;
 		}
-		task->data_phase = TASKFILE_IN;
-		return lba48 ? WIN_READ_EXT : WIN_READ;
+
+		ide_execute_command(drive, command, &task_in_intr, WAIT_CMD, NULL);
+		return ide_started;
 	} else {
-		task->command_type = IDE_DRIVE_TASK_RAW_WRITE;
-		if (dma)
-			return lba48 ? WIN_WRITEDMA_EXT : WIN_WRITEDMA;
-		task->prehandler = &pre_task_out_intr;
-		task->handler = &task_out_intr;
 		if (drive->mult_count) {
-			task->data_phase = TASKFILE_MULTI_OUT;
-			return lba48 ? WIN_MULTWRITE_EXT : WIN_MULTWRITE;
+			hwif->data_phase = TASKFILE_MULTI_OUT;
+			command = lba48 ? WIN_MULTWRITE_EXT : WIN_MULTWRITE;
+		} else {
+			hwif->data_phase = TASKFILE_OUT;
+			command = lba48 ? WIN_WRITE_EXT : WIN_WRITE;
 		}
-		task->data_phase = TASKFILE_OUT;
-		return lba48 ? WIN_WRITE_EXT : WIN_WRITE;
-	}
-}
-
-static ide_startstop_t chs_rw_disk (ide_drive_t *drive, struct request *rq, unsigned long block)
-{
-	ide_task_t		args;
-	int			sectors;
-	ata_nsector_t		nsectors;
-	unsigned int track	= (block / drive->sect);
-	unsigned int sect	= (block % drive->sect) + 1;
-	unsigned int head	= (track % drive->head);
-	unsigned int cyl	= (track / drive->head);
-
-	nsectors.all = (u16) rq->nr_sectors;
-
-	pr_debug("%s: CHS=%u/%u/%u\n", drive->name, cyl, head, sect);
-
-	memset(&args, 0, sizeof(ide_task_t));
-
-	sectors	= (rq->nr_sectors == 256) ? 0x00 : rq->nr_sectors;
 
-	args.tfRegister[IDE_NSECTOR_OFFSET]	= sectors;
-	args.tfRegister[IDE_SECTOR_OFFSET]	= sect;
-	args.tfRegister[IDE_LCYL_OFFSET]	= cyl;
-	args.tfRegister[IDE_HCYL_OFFSET]	= (cyl>>8);
-	args.tfRegister[IDE_SELECT_OFFSET]	= head;
-	args.tfRegister[IDE_SELECT_OFFSET]	|= drive->select.all;
-	args.tfRegister[IDE_COMMAND_OFFSET]	= get_command(drive, rq, &args);
-	args.rq					= (struct request *) rq;
-	rq->special				= (ide_task_t *)&args;
-	drive->hwif->data_phase = args.data_phase;
-	return do_rw_taskfile(drive, &args);
-}
-
-static ide_startstop_t lba_28_rw_disk (ide_drive_t *drive, struct request *rq, unsigned long block)
-{
-	ide_task_t		args;
-	int			sectors;
-	ata_nsector_t		nsectors;
-
-	nsectors.all = (u16) rq->nr_sectors;
-
-	memset(&args, 0, sizeof(ide_task_t));
-
-	sectors = (rq->nr_sectors == 256) ? 0x00 : rq->nr_sectors;
+		/* FIXME: ->OUTBSYNC ? */
+		hwif->OUTB(command, IDE_COMMAND_REG);
 
-	args.tfRegister[IDE_NSECTOR_OFFSET]	= sectors;
-	args.tfRegister[IDE_SECTOR_OFFSET]	= block;
-	args.tfRegister[IDE_LCYL_OFFSET]	= (block>>=8);
-	args.tfRegister[IDE_HCYL_OFFSET]	= (block>>=8);
-	args.tfRegister[IDE_SELECT_OFFSET]	= ((block>>8)&0x0f);
-	args.tfRegister[IDE_SELECT_OFFSET]	|= drive->select.all;
-	args.tfRegister[IDE_COMMAND_OFFSET]	= get_command(drive, rq, &args);
-	args.rq					= (struct request *) rq;
-	rq->special				= (ide_task_t *)&args;
-	drive->hwif->data_phase = args.data_phase;
-	return do_rw_taskfile(drive, &args);
+		pre_task_out_intr(drive, rq);
+		return ide_started;
+	}
 }
+EXPORT_SYMBOL_GPL(__ide_do_rw_disk);
 
 /*
  * 268435455  == 137439 MB or 28bit limit
@@ -592,38 +263,6 @@
  * 1073741822 == 549756 MB or 48bit addressing fake drive
  */
 
-static ide_startstop_t lba_48_rw_disk (ide_drive_t *drive, struct request *rq, unsigned long long block)
-{
-	ide_task_t		args;
-	int			sectors;
-	ata_nsector_t		nsectors;
-
-	nsectors.all = (u16) rq->nr_sectors;
-
-	memset(&args, 0, sizeof(ide_task_t));
-
-	sectors = (rq->nr_sectors == 65536) ? 0 : rq->nr_sectors;
-
-	args.tfRegister[IDE_NSECTOR_OFFSET]	= sectors;
-	args.hobRegister[IDE_NSECTOR_OFFSET]	= sectors >> 8;
-	args.tfRegister[IDE_SECTOR_OFFSET]	= block;	/* low lba */
-	args.tfRegister[IDE_LCYL_OFFSET]	= (block>>=8);	/* mid lba */
-	args.tfRegister[IDE_HCYL_OFFSET]	= (block>>=8);	/* hi  lba */
-	args.tfRegister[IDE_SELECT_OFFSET]	= drive->select.all;
-	args.tfRegister[IDE_COMMAND_OFFSET]	= get_command(drive, rq, &args);
-	args.hobRegister[IDE_SECTOR_OFFSET]	= (block>>=8);	/* low lba */
-	args.hobRegister[IDE_LCYL_OFFSET]	= (block>>=8);	/* mid lba */
-	args.hobRegister[IDE_HCYL_OFFSET]	= (block>>=8);	/* hi  lba */
-	args.hobRegister[IDE_SELECT_OFFSET]	= drive->select.all;
-	args.hobRegister[IDE_CONTROL_OFFSET_HOB]= (drive->ctl|0x80);
-	args.rq					= (struct request *) rq;
-	rq->special				= (ide_task_t *)&args;
-	drive->hwif->data_phase = args.data_phase;
-	return do_rw_taskfile(drive, &args);
-}
-
-#endif /* CONFIG_IDE_TASKFILE_IO */
-
 static ide_startstop_t ide_do_rw_disk (ide_drive_t *drive, struct request *rq, sector_t block)
 {
 	ide_hwif_t *hwif = HWIF(drive);
@@ -767,10 +406,6 @@
 		ide_end_drive_cmd(drive, stat, err);
 		return ide_stopped;
 	}
-#ifdef CONFIG_IDE_TASKFILE_IO
-	/* make rq completion pointers new submission pointers */
-	blk_rq_prep_restart(rq);
-#endif
 
 	if (stat & BUSY_STAT || ((stat & WRERR_STAT) && !drive->nowerr)) {
 		/* other bits are useless when BUSY */
@@ -1006,9 +641,6 @@
 			 capacity, sectors_to_MB(capacity),
 			 set_max, sectors_to_MB(set_max));
 
-	if (!drive->stroke)
-		return;
-
 	if (lba48)
 		set_max = idedisk_set_max_address_ext(drive, set_max);
 	else
@@ -1066,6 +698,8 @@
 	return drive->capacity64 - drive->sect0;
 }
 
+#define IS_PDC4030_DRIVE	0
+
 static ide_startstop_t idedisk_special (ide_drive_t *drive)
 {
 	special_t *s = &drive->special;
@@ -1155,10 +789,10 @@
 
 	memset(&args, 0, sizeof(ide_task_t));
 	args.tfRegister[IDE_FEATURE_OFFSET]	= SMART_READ_VALUES;
-	args.tfRegister[IDE_NSECTOR_OFFSET]	= 0x01;
 	args.tfRegister[IDE_LCYL_OFFSET]	= SMART_LCYL_PASS;
 	args.tfRegister[IDE_HCYL_OFFSET]	= SMART_HCYL_PASS;
 	args.tfRegister[IDE_COMMAND_OFFSET]	= WIN_SMART;
+	args.data_len				= 1;
 	args.command_type			= IDE_DRIVE_TASK_IN;
 	args.data_phase				= TASKFILE_IN;
 	args.handler				= &task_in_intr;
@@ -1171,10 +805,10 @@
 	ide_task_t args;
 	memset(&args, 0, sizeof(ide_task_t));
 	args.tfRegister[IDE_FEATURE_OFFSET]	= SMART_READ_THRESHOLDS;
-	args.tfRegister[IDE_NSECTOR_OFFSET]	= 0x01;
 	args.tfRegister[IDE_LCYL_OFFSET]	= SMART_LCYL_PASS;
 	args.tfRegister[IDE_HCYL_OFFSET]	= SMART_HCYL_PASS;
 	args.tfRegister[IDE_COMMAND_OFFSET]	= WIN_SMART;
+	args.data_len				= 1;
 	args.command_type			= IDE_DRIVE_TASK_IN;
 	args.handler				= &task_in_intr;
 	(void) smart_enable(drive);
@@ -1390,11 +1024,9 @@
 	ide_add_setting(drive,	"bios_cyl",		SETTING_RW,					-1,			-1,			TYPE_INT,	0,	65535,				1,	1,	&drive->bios_cyl,		NULL);
 	ide_add_setting(drive,	"bios_head",		SETTING_RW,					-1,			-1,			TYPE_BYTE,	0,	255,				1,	1,	&drive->bios_head,		NULL);
 	ide_add_setting(drive,	"bios_sect",		SETTING_RW,					-1,			-1,			TYPE_BYTE,	0,	63,				1,	1,	&drive->bios_sect,		NULL);
-	ide_add_setting(drive,	"address",		SETTING_RW,					HDIO_GET_ADDRESS,	HDIO_SET_ADDRESS,	TYPE_INTA,	0,	2,				1,	1,	&drive->addressing,	set_lba_addressing);
 	ide_add_setting(drive,	"bswap",		SETTING_READ,					-1,			-1,			TYPE_BYTE,	0,	1,				1,	1,	&drive->bswap,			NULL);
 	ide_add_setting(drive,	"multcount",		id ? SETTING_RW : SETTING_READ,			HDIO_GET_MULTCOUNT,	HDIO_SET_MULTCOUNT,	TYPE_BYTE,	0,	id ? id->max_multsect : 0,	1,	1,	&drive->mult_count,		set_multcount);
 	ide_add_setting(drive,	"nowerr",		SETTING_RW,					HDIO_GET_NOWERR,	HDIO_SET_NOWERR,	TYPE_BYTE,	0,	1,				1,	1,	&drive->nowerr,			set_nowerr);
-	ide_add_setting(drive,	"lun",			SETTING_RW,					-1,			-1,			TYPE_INT,	0,	7,				1,	1,	&drive->lun,			NULL);
 	ide_add_setting(drive,	"wcache",		SETTING_RW,					HDIO_GET_WCACHE,	HDIO_SET_WCACHE,	TYPE_BYTE,	0,	1,				1,	1,	&drive->wcache,			write_cache);
 	ide_add_setting(drive,	"acoustic",		SETTING_RW,					HDIO_GET_ACOUSTIC,	HDIO_SET_ACOUSTIC,	TYPE_BYTE,	0,	254,				1,	1,	&drive->acoustic,		set_acoustic);
  	ide_add_setting(drive,	"failures",		SETTING_RW,					-1,			-1,			TYPE_INT,	0,	65535,				1,	1,	&drive->failures,		NULL);
@@ -1605,7 +1237,7 @@
 	printk(", CHS=%d/%d/%d", 
 	       drive->bios_cyl, drive->bios_head, drive->bios_sect);
 	if (drive->using_dma)
-		(void) HWIF(drive)->ide_dma_verbose(drive);
+		ide_dma_verbose(drive);
 	printk("\n");
 
 	drive->mult_count = 0;
diff -Nru a/drivers/ide/ide-dma.c b/drivers/ide/ide-dma.c
--- a/drivers/ide/ide-dma.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/ide-dma.c	2004-10-10 23:09:59 -07:00
@@ -85,6 +85,7 @@
 #include <linux/init.h>
 #include <linux/ide.h>
 #include <linux/delay.h>
+#include <linux/scatterlist.h>
 
 #include <asm/io.h>
 #include <asm/irq.h>
@@ -206,73 +207,23 @@
 {
 	ide_hwif_t *hwif = HWIF(drive);
 	struct scatterlist *sg = hwif->sg_table;
-	int nents;
 
-	nents = blk_rq_map_sg(drive->queue, rq, hwif->sg_table);
-		
+	if ((rq->flags & REQ_DRIVE_TASKFILE) && rq->nr_sectors > 256)
+		BUG();
+
+	ide_map_sg(drive, rq);
+
 	if (rq_data_dir(rq) == READ)
 		hwif->sg_dma_direction = PCI_DMA_FROMDEVICE;
 	else
 		hwif->sg_dma_direction = PCI_DMA_TODEVICE;
 
-	return pci_map_sg(hwif->pci_dev, sg, nents, hwif->sg_dma_direction);
+	return pci_map_sg(hwif->pci_dev, sg, hwif->sg_nents, hwif->sg_dma_direction);
 }
 
 EXPORT_SYMBOL_GPL(ide_build_sglist);
 
 /**
- *	ide_raw_build_sglist	-	map IDE scatter gather for DMA
- *	@drive: the drive to build the DMA table for
- *	@rq: the request holding the sg list
- *
- *	Perform the PCI mapping magic necessary to access the source or
- *	target buffers of a taskfile request via PCI DMA. The lower layers 
- *	of the  kernel provide the necessary cache management so that we can
- *	operate in a portable fashion
- */
-
-int ide_raw_build_sglist(ide_drive_t *drive, struct request *rq)
-{
-	ide_hwif_t *hwif = HWIF(drive);
-	struct scatterlist *sg = hwif->sg_table;
-	int nents = 0;
-	ide_task_t *args = rq->special;
-	u8 *virt_addr = rq->buffer;
-	int sector_count = rq->nr_sectors;
-
-	if (args->command_type == IDE_DRIVE_TASK_RAW_WRITE)
-		hwif->sg_dma_direction = PCI_DMA_TODEVICE;
-	else
-		hwif->sg_dma_direction = PCI_DMA_FROMDEVICE;
-
-#if 1
-	if (sector_count > 256)
-		BUG();
-
-	if (sector_count > 128) {
-#else
-	while (sector_count > 128) {
-#endif
-		memset(&sg[nents], 0, sizeof(*sg));
-		sg[nents].page = virt_to_page(virt_addr);
-		sg[nents].offset = offset_in_page(virt_addr);
-		sg[nents].length = 128  * SECTOR_SIZE;
-		nents++;
-		virt_addr = virt_addr + (128 * SECTOR_SIZE);
-		sector_count -= 128;
-	}
-	memset(&sg[nents], 0, sizeof(*sg));
-	sg[nents].page = virt_to_page(virt_addr);
-	sg[nents].offset = offset_in_page(virt_addr);
-	sg[nents].length =  sector_count  * SECTOR_SIZE;
-	nents++;
-
-	return pci_map_sg(hwif->pci_dev, sg, nents, hwif->sg_dma_direction);
-}
-
-EXPORT_SYMBOL_GPL(ide_raw_build_sglist);
-
-/**
  *	ide_build_dmatable	-	build IDE DMA table
  *
  *	ide_build_dmatable() prepares a dma request. We map the command
@@ -293,10 +244,7 @@
 	int i;
 	struct scatterlist *sg;
 
-	if (HWGROUP(drive)->rq->flags & REQ_DRIVE_TASKFILE)
-		hwif->sg_nents = i = ide_raw_build_sglist(drive, rq);
-	else
-		hwif->sg_nents = i = ide_build_sglist(drive, rq);
+	hwif->sg_nents = i = ide_build_sglist(drive, rq);
 
 	if (!i)
 		return 0;
@@ -590,10 +538,8 @@
 EXPORT_SYMBOL(__ide_dma_check);
 
 /**
- *	ide_start_dma	-	begin a DMA phase
- *	@hwif: interface
+ *	ide_dma_setup	-	begin a DMA phase
  *	@drive: target device
- *	@reading: set if reading, clear if writing
  *
  *	Build an IDE DMA PRD (IDE speak for scatter gather table)
  *	and then set up the DMA transfer registers for a device
@@ -603,15 +549,24 @@
  *	Returns 0 on success. If a PIO fallback is required then 1
  *	is returned. 
  */
- 
-int ide_start_dma(ide_hwif_t *hwif, ide_drive_t *drive, int reading)
+
+int ide_dma_setup(ide_drive_t *drive)
 {
+	ide_hwif_t *hwif = drive->hwif;
 	struct request *rq = HWGROUP(drive)->rq;
+	unsigned int reading;
 	u8 dma_stat;
 
+	if (rq_data_dir(rq))
+		reading = 0;
+	else
+		reading = 1 << 3;
+
 	/* fall back to pio! */
-	if (!ide_build_dmatable(drive, rq))
+	if (!ide_build_dmatable(drive, rq)) {
+		ide_map_sg(drive, rq);
 		return 1;
+	}
 
 	/* PRD table */
 	hwif->OUTL(hwif->dmatable_dma, hwif->dma_prdtable);
@@ -628,73 +583,15 @@
 	return 0;
 }
 
-EXPORT_SYMBOL(ide_start_dma);
+EXPORT_SYMBOL_GPL(ide_dma_setup);
 
-int __ide_dma_read (ide_drive_t *drive /*, struct request *rq */)
+static void ide_dma_exec_cmd(ide_drive_t *drive, u8 command)
 {
-	ide_hwif_t *hwif	= HWIF(drive);
-	struct request *rq	= HWGROUP(drive)->rq;
-	unsigned int reading	= 1 << 3;
-	u8 lba48		= (drive->addressing == 1) ? 1 : 0;
-	task_ioreg_t command	= WIN_NOP;
-
-	/* try pio */
-	if (ide_start_dma(hwif, drive, reading))
-		return 1;
-
-	if (drive->media != ide_disk)
-		return 0;
-
-	command = (lba48) ? WIN_READDMA_EXT : WIN_READDMA;
-	
-	if (drive->vdma)
-		command = (lba48) ? WIN_READ_EXT: WIN_READ;
-		
-	if (rq->flags & REQ_DRIVE_TASKFILE) {
-		ide_task_t *args = rq->special;
-		command = args->tfRegister[IDE_COMMAND_OFFSET];
-	}
-
-	/* issue cmd to drive */
-	ide_execute_command(drive, command, &ide_dma_intr, 2*WAIT_CMD, dma_timer_expiry);
-	return hwif->ide_dma_begin(drive);
-}
-
-EXPORT_SYMBOL(__ide_dma_read);
-
-int __ide_dma_write (ide_drive_t *drive /*, struct request *rq */)
-{
-	ide_hwif_t *hwif	= HWIF(drive);
-	struct request *rq	= HWGROUP(drive)->rq;
-	unsigned int reading	= 0;
-	u8 lba48		= (drive->addressing == 1) ? 1 : 0;
-	task_ioreg_t command	= WIN_NOP;
-
-	/* try PIO instead of DMA */
-	if (ide_start_dma(hwif, drive, reading))
-		return 1;
-
-	if (drive->media != ide_disk)
-		return 0;
-
-	command = (lba48) ? WIN_WRITEDMA_EXT : WIN_WRITEDMA;
-	if (drive->vdma)
-		command = (lba48) ? WIN_WRITE_EXT: WIN_WRITE;
-		
-	if (rq->flags & REQ_DRIVE_TASKFILE) {
-		ide_task_t *args = rq->special;
-		command = args->tfRegister[IDE_COMMAND_OFFSET];
-	}
-
 	/* issue cmd to drive */
 	ide_execute_command(drive, command, &ide_dma_intr, 2*WAIT_CMD, dma_timer_expiry);
-
-	return hwif->ide_dma_begin(drive);
 }
 
-EXPORT_SYMBOL(__ide_dma_write);
-
-int __ide_dma_begin (ide_drive_t *drive)
+void ide_dma_start(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif	= HWIF(drive);
 	u8 dma_cmd		= hwif->INB(hwif->dma_command);
@@ -708,10 +605,9 @@
 	hwif->OUTB(dma_cmd|1, hwif->dma_command);
 	hwif->dma = 1;
 	wmb();
-	return 0;
 }
 
-EXPORT_SYMBOL(__ide_dma_begin);
+EXPORT_SYMBOL_GPL(ide_dma_start);
 
 /* returns 1 on error, 0 otherwise */
 int __ide_dma_end (ide_drive_t *drive)
@@ -785,17 +681,14 @@
 
 EXPORT_SYMBOL(__ide_dma_good_drive);
 
-#ifdef CONFIG_BLK_DEV_IDEDMA_PCI
-int __ide_dma_verbose (ide_drive_t *drive)
+void ide_dma_verbose(ide_drive_t *drive)
 {
 	struct hd_driveid *id	= drive->id;
 	ide_hwif_t *hwif	= HWIF(drive);
 
 	if (id->field_valid & 4) {
-		if ((id->dma_ultra >> 8) && (id->dma_mword >> 8)) {
-			printk(", BUG DMA OFF");
-			return hwif->ide_dma_off_quietly(drive);
-		}
+		if ((id->dma_ultra >> 8) && (id->dma_mword >> 8))
+			goto bug_dma_off;
 		if (id->dma_ultra & ((id->dma_ultra >> 8) & hwif->ultra_mask)) {
 			if (((id->dma_ultra >> 11) & 0x1F) &&
 			    eighty_ninty_three(drive)) {
@@ -825,19 +718,22 @@
 			printk(", (U)DMA");	/* Can be BIOS-enabled! */
 		}
 	} else if (id->field_valid & 2) {
-		if ((id->dma_mword >> 8) && (id->dma_1word >> 8)) {
-			printk(", BUG DMA OFF");
-			return hwif->ide_dma_off_quietly(drive);
-		}
+		if ((id->dma_mword >> 8) && (id->dma_1word >> 8))
+			goto bug_dma_off;
 		printk(", DMA");
 	} else if (id->field_valid & 1) {
 		printk(", BUG");
 	}
-	return 1;
+	return;
+bug_dma_off:
+	printk(", BUG DMA OFF");
+	hwif->ide_dma_off_quietly(drive);
+	return;
 }
 
-EXPORT_SYMBOL(__ide_dma_verbose);
+EXPORT_SYMBOL(ide_dma_verbose);
 
+#ifdef CONFIG_BLK_DEV_IDEDMA_PCI
 int __ide_dma_lostirq (ide_drive_t *drive)
 {
 	printk("%s: DMA interrupt recovery\n", drive->name);
@@ -869,10 +765,6 @@
 				    hwif->dmatable_dma);
 		hwif->dmatable_cpu = NULL;
 	}
-	if (hwif->sg_table) {
-		kfree(hwif->sg_table);
-		hwif->sg_table = NULL;
-	}
 	return 1;
 }
 
@@ -905,15 +797,12 @@
 	hwif->dmatable_cpu = pci_alloc_consistent(hwif->pci_dev,
 						  PRD_ENTRIES * PRD_BYTES,
 						  &hwif->dmatable_dma);
-	hwif->sg_table = kmalloc(sizeof(struct scatterlist) * PRD_ENTRIES,
-				GFP_KERNEL);
 
-	if ((hwif->dmatable_cpu) && (hwif->sg_table))
+	if (hwif->dmatable_cpu)
 		return 0;
 
-	printk(KERN_ERR "%s: -- Error, unable to allocate%s%s table(s).\n",
+	printk(KERN_ERR "%s: -- Error, unable to allocate%s DMA table(s).\n",
 		(hwif->dmatable_cpu == NULL) ? " CPU" : "",
-		(hwif->sg_table == NULL) ?  " SG DMA" : " DMA",
 		hwif->cds->name);
 
 	ide_release_dma_engine(hwif);
@@ -1009,18 +898,16 @@
 		hwif->ide_dma_host_on = &__ide_dma_host_on;
 	if (!hwif->ide_dma_check)
 		hwif->ide_dma_check = &__ide_dma_check;
-	if (!hwif->ide_dma_read)
-		hwif->ide_dma_read = &__ide_dma_read;
-	if (!hwif->ide_dma_write)
-		hwif->ide_dma_write = &__ide_dma_write;
-	if (!hwif->ide_dma_begin)
-		hwif->ide_dma_begin = &__ide_dma_begin;
+	if (!hwif->dma_setup)
+		hwif->dma_setup = &ide_dma_setup;
+	if (!hwif->dma_exec_cmd)
+		hwif->dma_exec_cmd = &ide_dma_exec_cmd;
+	if (!hwif->dma_start)
+		hwif->dma_start = &ide_dma_start;
 	if (!hwif->ide_dma_end)
 		hwif->ide_dma_end = &__ide_dma_end;
 	if (!hwif->ide_dma_test_irq)
 		hwif->ide_dma_test_irq = &__ide_dma_test_irq;
-	if (!hwif->ide_dma_verbose)
-		hwif->ide_dma_verbose = &__ide_dma_verbose;
 	if (!hwif->ide_dma_timeout)
 		hwif->ide_dma_timeout = &__ide_dma_timeout;
 	if (!hwif->ide_dma_lostirq)
diff -Nru a/drivers/ide/ide-floppy.c b/drivers/ide/ide-floppy.c
--- a/drivers/ide/ide-floppy.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/ide-floppy.c	2004-10-10 23:09:59 -07:00
@@ -995,6 +995,7 @@
 static ide_startstop_t idefloppy_issue_pc (ide_drive_t *drive, idefloppy_pc_t *pc)
 {
 	idefloppy_floppy_t *floppy = drive->driver_data;
+	ide_hwif_t *hwif = drive->hwif;
 	atapi_feature_t feature;
 	atapi_bcount_t bcount;
 	ide_handler_t *pkt_xfer_routine;
@@ -1049,13 +1050,8 @@
 	}
 	feature.all = 0;
 
-	if (test_bit(PC_DMA_RECOMMENDED, &pc->flags) && drive->using_dma) {
-		if (test_bit(PC_WRITING, &pc->flags)) {
-			feature.b.dma = !HWIF(drive)->ide_dma_write(drive);
-		} else {
-			feature.b.dma = !HWIF(drive)->ide_dma_read(drive);
-		}
-	}
+	if (test_bit(PC_DMA_RECOMMENDED, &pc->flags) && drive->using_dma)
+		feature.b.dma = !hwif->dma_setup(drive);
 
 	if (IDE_CONTROL_REG)
 		HWIF(drive)->OUTB(drive->ctl, IDE_CONTROL_REG);
@@ -1067,7 +1063,7 @@
 
 	if (feature.b.dma) {	/* Begin DMA, if necessary */
 		set_bit(PC_DMA_IN_PROGRESS, &pc->flags);
-		(void) (HWIF(drive)->ide_dma_begin(drive));
+		hwif->dma_start(drive);
 	}
 
 	/* Can we transfer the packet when we get the interrupt or wait? */
diff -Nru a/drivers/ide/ide-io.c b/drivers/ide/ide-io.c
--- a/drivers/ide/ide-io.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/ide-io.c	2004-10-10 23:09:59 -07:00
@@ -47,6 +47,7 @@
 #include <linux/seq_file.h>
 #include <linux/device.h>
 #include <linux/kmod.h>
+#include <linux/scatterlist.h>
 
 #include <asm/byteorder.h>
 #include <asm/irq.h>
@@ -674,6 +675,34 @@
 
 EXPORT_SYMBOL(do_special);
 
+void ide_map_sg(ide_drive_t *drive, struct request *rq)
+{
+	ide_hwif_t *hwif = drive->hwif;
+	struct scatterlist *sg = hwif->sg_table;
+
+	if (hwif->sg_mapped)	/* needed by ide-scsi */
+		return;
+
+	if ((rq->flags & REQ_DRIVE_TASKFILE) == 0) {
+		hwif->sg_nents = blk_rq_map_sg(drive->queue, rq, sg);
+	} else {
+		sg_init_one(sg, rq->buffer, rq->nr_sectors * SECTOR_SIZE);
+		hwif->sg_nents = 1;
+	}
+}
+
+EXPORT_SYMBOL_GPL(ide_map_sg);
+
+void ide_init_sg_cmd(ide_drive_t *drive, struct request *rq)
+{
+	ide_hwif_t *hwif = drive->hwif;
+
+	hwif->nsect = hwif->nleft = rq->nr_sectors;
+	hwif->cursg = hwif->cursg_ofs = 0;
+}
+
+EXPORT_SYMBOL_GPL(ide_init_sg_cmd);
+
 /**
  *	execute_drive_command	-	issue special drive command
  *	@drive: the drive to issue th command on
@@ -697,6 +726,17 @@
 
 		hwif->data_phase = args->data_phase;
 
+		switch (hwif->data_phase) {
+		case TASKFILE_MULTI_OUT:
+		case TASKFILE_OUT:
+		case TASKFILE_MULTI_IN:
+		case TASKFILE_IN:
+			ide_init_sg_cmd(drive, rq);
+			ide_map_sg(drive, rq);
+		default:
+			break;
+		}
+
 		if (args->tf_out_flags.all != 0) 
 			return flagged_taskfile(drive, args);
 		return do_rw_taskfile(drive, args);
@@ -1182,12 +1222,15 @@
 	HWGROUP(drive)->rq = NULL;
 
 	rq->errors = 0;
+
+	if (!rq->bio)
+		goto out;
+
 	rq->sector = rq->bio->bi_sector;
 	rq->current_nr_sectors = bio_iovec(rq->bio)->bv_len >> 9;
 	rq->hard_cur_sectors = rq->current_nr_sectors;
-	if (rq->bio)
-		rq->buffer = NULL;
-
+	rq->buffer = NULL;
+out:
 	return ret;
 }
 
@@ -1550,18 +1593,6 @@
 	int where = ELEVATOR_INSERT_BACK, err;
 	int must_wait = (action == ide_wait || action == ide_head_wait);
 
-#ifdef CONFIG_BLK_DEV_PDC4030
-	/*
-	 *	FIXME: there should be a drive or hwif->special
-	 *	handler that points here by default, not hacks
-	 *	in the ide-io.c code
-	 *
-	 *	FIXME2: That code breaks power management if used with
-	 *	this chipset, that really doesn't belong here !
-	 */
-	if (HWIF(drive)->chipset == ide_pdc4030 && rq->buffer != NULL)
-		return -ENOSYS;  /* special drive cmds not supported */
-#endif
 	rq->errors = 0;
 	rq->rq_status = RQ_ACTIVE;
 
diff -Nru a/drivers/ide/ide-lib.c b/drivers/ide/ide-lib.c
--- a/drivers/ide/ide-lib.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/ide-lib.c	2004-10-10 23:09:59 -07:00
@@ -69,6 +69,38 @@
 
 EXPORT_SYMBOL(ide_xfer_verbose);
 
+int ide_use_dma(ide_drive_t *drive)
+{
+	struct hd_driveid *id = drive->id;
+	ide_hwif_t *hwif = drive->hwif;
+
+	/* consult the list of known "bad" drives */
+	if (__ide_dma_bad_drive(drive))
+		return 0;
+
+	/* capable of UltraDMA modes */
+	if (id->field_valid & 4) {
+		if (hwif->ultra_mask & id->dma_ultra)
+			return 1;
+	}
+
+	/* capable of regular DMA modes */
+	if (id->field_valid & 2) {
+		if (hwif->mwdma_mask & id->dma_mword)
+			return 1;
+		if (hwif->swdma_mask & id->dma_1word)
+			return 1;
+	}
+
+	/* consult the list of known "good" drives */
+	if (__ide_dma_good_drive(drive) && id->eide_dma_time < 150)
+		return 1;
+
+	return 0;
+}
+
+EXPORT_SYMBOL_GPL(ide_use_dma);
+
 /**
  *	ide_dma_speed	-	compute DMA speed
  *	@drive: drive
diff -Nru a/drivers/ide/ide-probe.c b/drivers/ide/ide-probe.c
--- a/drivers/ide/ide-probe.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/ide-probe.c	2004-10-10 23:09:59 -07:00
@@ -180,12 +180,6 @@
 	if (cmd == WIN_PIDENTIFY) {
 		u8 type = (id->config >> 8) & 0x1f;
 		printk("ATAPI ");
-#ifdef CONFIG_BLK_DEV_PDC4030
-		if (hwif->channel == 1 && hwif->chipset == ide_pdc4030) {
-			printk(" -- not supported on 2nd Promise port\n");
-			goto err_misc;
-		}
-#endif /* CONFIG_BLK_DEV_PDC4030 */
 		switch (type) {
 			case ide_floppy:
 				if (!strstr(id->model, "CD-ROM")) {
@@ -297,13 +291,9 @@
 		/* disable dma & overlap */
 		hwif->OUTB(0, IDE_FEATURE_REG);
 
-	if (hwif->identify != NULL) {
-		if (hwif->identify(drive))
-			return 1;
-	} else {
-		/* ask drive for ID */
-		hwif->OUTB(cmd, IDE_COMMAND_REG);
-	}
+	/* ask drive for ID */
+	hwif->OUTB(cmd, IDE_COMMAND_REG);
+
 	timeout = ((cmd == WIN_IDENTIFY) ? WAIT_WORSTCASE : WAIT_PIDENTIFY) / 2;
 	timeout += jiffies;
 	do {
@@ -676,9 +666,6 @@
 		return;
 
 	if ((hwif->chipset != ide_4drives || !hwif->mate || !hwif->mate->present) &&
-#ifdef CONFIG_BLK_DEV_PDC4030
-	    (hwif->chipset != ide_pdc4030 || hwif->channel == 0) &&
-#endif /* CONFIG_BLK_DEV_PDC4030 */
 	    (ide_hwif_request_regions(hwif))) {
 		u16 msgout = 0;
 		for (unit = 0; unit < MAX_DRIVES; ++unit) {
@@ -1208,10 +1195,10 @@
 		drive->gendev.release = drive_release_dev;
 		if (drive->present) {
 			device_register(&drive->gendev);
-			sprintf(drive->devfs_name, "ide/host%d/bus%d/target%d/lun%d",
+			sprintf(drive->devfs_name, "ide/host%d/bus%d/target%d/lun0",
 				(hwif->channel && hwif->mate) ?
 				hwif->mate->index : hwif->index,
-				hwif->channel, unit, drive->lun);
+				hwif->channel, unit);
 		}
 	}
 	blk_register_region(MKDEV(hwif->major, 0), MAX_DRIVES << PARTN_BITS,
@@ -1245,6 +1232,16 @@
 
 	if (register_blkdev(hwif->major, hwif->name))
 		return 0;
+
+	if (!hwif->sg_max_nents)
+		hwif->sg_max_nents = PRD_ENTRIES;
+
+	hwif->sg_table = kmalloc(sizeof(struct scatterlist)*hwif->sg_max_nents,
+				 GFP_KERNEL);
+	if (!hwif->sg_table) {
+		printk(KERN_ERR "%s: unable to allocate SG table.\n", hwif->name);
+		goto out;
+	}
 
 	if (alloc_disks(hwif) < 0)
 		goto out;
diff -Nru a/drivers/ide/ide-proc.c b/drivers/ide/ide-proc.c
--- a/drivers/ide/ide-proc.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/ide-proc.c	2004-10-10 23:09:59 -07:00
@@ -8,37 +8,6 @@
 /*
  * This is the /proc/ide/ filesystem implementation.
  *
- * The major reason this exists is to provide sufficient access
- * to driver and config data, such that user-mode programs can
- * be developed to handle chipset tuning for most PCI interfaces.
- * This should provide better utilities, and less kernel bloat.
- *
- * The entire pci config space for a PCI interface chipset can be
- * retrieved by just reading it.  e.g.    "cat /proc/ide3/config"
- *
- * To modify registers *safely*, do something like:
- *   echo "P40:88" >/proc/ide/ide3/config
- * That expression writes 0x88 to pci config register 0x40
- * on the chip which controls ide3.  Multiple tuples can be issued,
- * and the writes will be completed as an atomic set:
- *   echo "P40:88 P41:35 P42:00 P43:00" >/proc/ide/ide3/config
- *
- * All numbers must be specified using pairs of ascii hex digits.
- * It is important to note that these writes will be performed
- * after waiting for the IDE controller (both interfaces)
- * to be completely idle, to ensure no corruption of I/O in progress.
- *
- * Non-PCI registers can also be written, using "R" in place of "P"
- * in the above examples.  The size of the port transfer is determined
- * by the number of pairs of hex digits given for the data.  If a two
- * digit value is given, the write will be a byte operation; if four
- * digits are used, the write will be performed as a 16-bit operation;
- * and if eight digits are specified, a 32-bit "dword" write will be
- * performed.  Odd numbers of digits are not permitted.
- *
- * If there is an error *anywhere* in the string of registers/data
- * then *none* of the writes will be performed.
- *
  * Drive/Driver settings can be retrieved by reading the drive's
  * "settings" files.  e.g.    "cat /proc/ide0/hda/settings"
  * To write a new value "val" into a specific setting "name", use:
@@ -51,10 +20,6 @@
  * returned data as 256 16-bit words.  The "hdparm" utility will
  * be updated someday soon to use this mechanism.
  *
- * Feel free to develop and distribute fancy GUI configuration
- * utilities for your favorite PCI chipsets.  I'll be working on
- * one for the Promise 20246 someday soon.  -ml
- *
  */
 
 #include <linux/config.h>
@@ -74,227 +39,6 @@
 
 #include <asm/io.h>
 
-static int proc_ide_write_config(struct file *file, const char __user *buffer,
-				 unsigned long count, void *data)
-{
-	ide_hwif_t	*hwif = (ide_hwif_t *)data;
-	ide_hwgroup_t *mygroup = (ide_hwgroup_t *)(hwif->hwgroup);
-	ide_hwgroup_t *mategroup = NULL;
-	unsigned long timeout;
-	unsigned long flags;
-	const char *start = NULL, *msg = NULL;
-	struct entry { u32 val; u16 reg; u8 size; u8 pci; } *prog, *q, *r;
-	int want_pci = 0;
-	char *buf, *s;
-	int err;
-
-	if (hwif->mate && hwif->mate->hwgroup)
-		mategroup = (ide_hwgroup_t *)(hwif->mate->hwgroup);
-
-	if (!capable(CAP_SYS_ADMIN) || !capable(CAP_SYS_RAWIO))
-		return -EACCES;
-
-	if (count >= PAGE_SIZE)
-		return -EINVAL;
-
-	s = buf = (char *)__get_free_page(GFP_USER);
-	if (!buf)
-		return -ENOMEM;
-
-	err = -ENOMEM;
-	q = prog = (struct entry *)__get_free_page(GFP_USER);
-	if (!prog)
-		goto out;
-
-	err = -EFAULT;
-	if (copy_from_user(buf, buffer, count))
-		goto out1;
-
-	buf[count] = '\0';
-
-	while (isspace(*s))
-		s++;
-
-	while (*s) {
-		char *p;
-		int digits;
-
-		start = s;
-
-		if ((char *)(q + 1) > (char *)prog + PAGE_SIZE) {
-			msg = "too many entries";
-			goto parse_error;
-		}
-
-		switch (*s++) {
-			case 'R':	q->pci = 0;
-					break;
-			case 'P':	q->pci = 1;
-					want_pci = 1;
-					break;
-			default:	msg = "expected 'R' or 'P'";
-					goto parse_error;
-		}
-
-		q->reg = simple_strtoul(s, &p, 16);
-		digits = p - s;
-		if (!digits || digits > 4 || (q->pci && q->reg > 0xff)) {
-			msg = "bad/missing register number";
-			goto parse_error;
-		}
-		if (*p++ != ':') {
-			msg = "missing ':'";
-			goto parse_error;
-		}
-		q->val = simple_strtoul(p, &s, 16);
-		digits = s - p;
-		if (digits != 2 && digits != 4 && digits != 8) {
-			msg = "bad data, 2/4/8 digits required";
-			goto parse_error;
-		}
-		q->size = digits / 2;
-
-		if (q->pci) {
-#ifdef CONFIG_BLK_DEV_IDEPCI
-			if (q->reg & (q->size - 1)) {
-				msg = "misaligned access";
-				goto parse_error;
-			}
-#else
-			msg = "not a PCI device";
-			goto parse_error;
-#endif	/* CONFIG_BLK_DEV_IDEPCI */
-		}
-
-		q++;
-
-		if (*s && !isspace(*s++)) {
-			msg = "expected whitespace after data";
-			goto parse_error;
-		}
-		while (isspace(*s))
-			s++;
-	}
-
-	/*
-	 * What follows below is fucking insane, even for IDE people.
-	 * For now I've dealt with the obvious problems on the parsing
-	 * side, but IMNSHO we should simply remove the write access
-	 * to /proc/ide/.../config, killing that FPOS completely.
-	 */
-
-	err = -EBUSY;
-	timeout = jiffies + (3 * HZ);
-	spin_lock_irqsave(&ide_lock, flags);
-	while (mygroup->busy ||
-	       (mategroup && mategroup->busy)) {
-		spin_unlock_irqrestore(&ide_lock, flags);
-		if (time_after(jiffies, timeout)) {
-			printk("/proc/ide/%s/config: channel(s) busy, cannot write\n", hwif->name);
-			goto out1;
-		}
-		spin_lock_irqsave(&ide_lock, flags);
-	}
-
-#ifdef CONFIG_BLK_DEV_IDEPCI
-	if (want_pci && (!hwif->pci_dev || hwif->pci_dev->vendor)) {
-		spin_unlock_irqrestore(&ide_lock, flags);
-		printk("proc_ide: PCI registers not accessible for %s\n",
-			hwif->name);
-		err = -EINVAL;
-		goto out1;
-	}
-#endif	/* CONFIG_BLK_DEV_IDEPCI */
-
-	for (r = prog; r < q; r++) {
-		unsigned int reg = r->reg, val = r->val;
-		if (r->pci) {
-#ifdef CONFIG_BLK_DEV_IDEPCI
-			int rc = 0;
-			struct pci_dev *dev = hwif->pci_dev;
-			switch (q->size) {
-				case 1:	msg = "byte";
-					rc = pci_write_config_byte(dev, reg, val);
-					break;
-				case 2:	msg = "word";
-					rc = pci_write_config_word(dev, reg, val);
-					break;
-				case 4:	msg = "dword";
-					rc = pci_write_config_dword(dev, reg, val);
-					break;
-			}
-			if (rc) {
-				spin_unlock_irqrestore(&ide_lock, flags);
-				printk("proc_ide_write_config: error writing %s at bus %02x dev %02x reg 0x%x value 0x%x\n",
-					msg, dev->bus->number, dev->devfn, reg, val);
-				printk("proc_ide_write_config: error %d\n", rc);
-				err = -EIO;
-				goto out1;
-			}
-#endif	/* CONFIG_BLK_DEV_IDEPCI */
-		} else {	/* not pci */
-			switch (r->size) {
-				case 1:	hwif->OUTB(val, reg);
-					break;
-				case 2:	hwif->OUTW(val, reg);
-					break;
-				case 4:	hwif->OUTL(val, reg);
-					break;
-			}
-		}
-	}
-	spin_unlock_irqrestore(&ide_lock, flags);
-	err = count;
-out1:
-	free_page((unsigned long)prog);
-out:
-	free_page((unsigned long)buf);
-	return err;
-
-parse_error:
-	printk("parse error\n");
-	printk("proc_ide: error: %s: '%s'\n", msg, start);
-	err = -EINVAL;
-	goto out1;
-}
-
-static int proc_ide_read_config
-	(char *page, char **start, off_t off, int count, int *eof, void *data)
-{
-	char		*out = page;
-	int		len;
-
-#ifdef CONFIG_BLK_DEV_IDEPCI
-	ide_hwif_t	*hwif = (ide_hwif_t *)data;
-	struct pci_dev	*dev = hwif->pci_dev;
-	if ((hwif->pci_dev && hwif->pci_dev->vendor) && dev && dev->bus) {
-		int reg = 0;
-
-		out += sprintf(out, "pci bus %02x device %02x vendor %04x "
-				"device %04x channel %d\n",
-			dev->bus->number, dev->devfn,
-			hwif->pci_dev->vendor, hwif->pci_dev->device,
-			hwif->channel);
-		do {
-			u8 val;
-			int rc = pci_read_config_byte(dev, reg, &val);
-			if (rc) {
-				printk("proc_ide_read_config: error %d reading"
-					" bus %02x dev %02x reg 0x%02x\n",
-					rc, dev->bus->number, dev->devfn, reg);
-				out += sprintf(out, "??%c",
-					(++reg & 0xf) ? ' ' : '\n');
-			} else
-				out += sprintf(out, "%02x%c",
-					val, (++reg & 0xf) ? ' ' : '\n');
-		} while (reg < 0x100);
-	} else
-#endif	/* CONFIG_BLK_DEV_IDEPCI */
-		out += sprintf(out, "(none)\n");
-	len = out - page;
-	PROC_IDE_READ_RETURN(page,start,off,count,eof,len);
-}
-
 static int proc_ide_read_imodel
 	(char *page, char **start, off_t off, int count, int *eof, void *data)
 {
@@ -314,7 +58,6 @@
 		case ide_qd65xx:	name = "qd65xx";	break;
 		case ide_umc8672:	name = "umc8672";	break;
 		case ide_ht6560b:	name = "ht6560b";	break;
-		case ide_pdc4030:	name = "pdc4030";	break;
 		case ide_rz1000:	name = "rz1000";	break;
 		case ide_trm290:	name = "trm290";	break;
 		case ide_cmd646:	name = "cmd646";	break;
@@ -389,6 +132,9 @@
 	char		*out = page;
 	int		len, rc, mul_factor, div_factor;
 
+	printk(KERN_WARNING "Warning: /proc/ide/hd?/settings interface is "
+			    "obsolete, and will be removed soon!\n");
+
 	down(&ide_setting_sem);
 	out += sprintf(out, "name\t\t\tvalue\t\tmin\t\tmax\t\tmode\n");
 	out += sprintf(out, "----\t\t\t-----\t\t---\t\t---\t\t----\n");
@@ -425,6 +171,9 @@
 	ide_settings_t	*setting;
 	char *buf, *s;
 
+	printk(KERN_WARNING "Warning: /proc/ide/hd?/settings interface is "
+			    "obsolete, and will be removed soon!\n");
+
 	if (!capable(CAP_SYS_ADMIN))
 		return -EACCES;
 
@@ -688,7 +437,6 @@
 
 static ide_proc_entry_t hwif_entries[] = {
 	{ "channel",	S_IFREG|S_IRUGO,	proc_ide_read_channel,	NULL },
-	{ "config",	S_IFREG|S_IRUGO|S_IWUSR,proc_ide_read_config,	proc_ide_write_config },
 	{ "mate",	S_IFREG|S_IRUGO,	proc_ide_read_mate,	NULL },
 	{ "model",	S_IFREG|S_IRUGO,	proc_ide_read_imodel,	NULL },
 	{ NULL,	0, NULL, NULL }
diff -Nru a/drivers/ide/ide-tape.c b/drivers/ide/ide-tape.c
--- a/drivers/ide/ide-tape.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/ide-tape.c	2004-10-10 23:09:59 -07:00
@@ -2067,7 +2067,7 @@
 #ifdef CONFIG_BLK_DEV_IDEDMA
 	/* Begin DMA, if necessary */
 	if (test_bit(PC_DMA_IN_PROGRESS, &pc->flags))
-		(void) (HWIF(drive)->ide_dma_begin(drive));
+		hwif->dma_start(drive);
 #endif
 	/* Send the actual packet */
 	HWIF(drive)->atapi_output_bytes(drive, pc->c, 12);
@@ -2135,12 +2135,8 @@
 				"reverting to PIO\n");
 		(void)__ide_dma_off(drive);
 	}
-	if (test_bit(PC_DMA_RECOMMENDED, &pc->flags) && drive->using_dma) {
-		if (test_bit(PC_WRITING, &pc->flags))
-			dma_ok = !HWIF(drive)->ide_dma_write(drive);
-		else
-			dma_ok = !HWIF(drive)->ide_dma_read(drive);
-	}
+	if (test_bit(PC_DMA_RECOMMENDED, &pc->flags) && drive->using_dma)
+		dma_ok = !hwif->dma_setup(drive);
 
 	if (IDE_CONTROL_REG)
 		hwif->OUTB(drive->ctl, IDE_CONTROL_REG);
diff -Nru a/drivers/ide/ide-taskfile.c b/drivers/ide/ide-taskfile.c
--- a/drivers/ide/ide-taskfile.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/ide-taskfile.c	2004-10-10 23:09:59 -07:00
@@ -5,7 +5,7 @@
  *  Copyright (C) 2000-2002	Andre Hedrick <andre@linux-ide.org>
  *  Copyright (C) 2001-2002	Klaus Smolin
  *					IBM Storage Technology Division
- *  Copyright (C) 2003		Bartlomiej Zolnierkiewicz
+ *  Copyright (C) 2003-2004	Bartlomiej Zolnierkiewicz
  *
  *  The big the bad and the ugly.
  *
@@ -63,17 +63,14 @@
 	}
 }
 
-
-void taskfile_input_data (ide_drive_t *drive, void *buffer, u32 wcount)
+static void taskfile_input_data(ide_drive_t *drive, void *buffer, u32 wcount)
 {
 	HWIF(drive)->ata_input_data(drive, buffer, wcount);
 	if (drive->bswap)
 		ata_bswap_data(buffer, wcount);
 }
 
-EXPORT_SYMBOL(taskfile_input_data);
-
-void taskfile_output_data (ide_drive_t *drive, void *buffer, u32 wcount)
+static void taskfile_output_data(ide_drive_t *drive, void *buffer, u32 wcount)
 {
 	if (drive->bswap) {
 		ata_bswap_data(buffer, wcount);
@@ -84,17 +81,15 @@
 	}
 }
 
-EXPORT_SYMBOL(taskfile_output_data);
-
 int taskfile_lib_get_identify (ide_drive_t *drive, u8 *buf)
 {
 	ide_task_t args;
 	memset(&args, 0, sizeof(ide_task_t));
-	args.tfRegister[IDE_NSECTOR_OFFSET]	= 0x01;
 	if (drive->media == ide_disk)
 		args.tfRegister[IDE_COMMAND_OFFSET]	= WIN_IDENTIFY;
 	else
 		args.tfRegister[IDE_COMMAND_OFFSET]	= WIN_PIDENTIFY;
+	args.data_len = 1;
 	args.command_type = IDE_DRIVE_TASK_IN;
 	args.data_phase   = TASKFILE_IN;
 	args.handler	  = &task_in_intr;
@@ -150,15 +145,15 @@
 		case WIN_WRITEDMA_ONCE:
 		case WIN_WRITEDMA:
 		case WIN_WRITEDMA_EXT:
-			if (!hwif->ide_dma_write(drive))
-				return ide_started;
-			break;
 		case WIN_READDMA_ONCE:
 		case WIN_READDMA:
 		case WIN_READDMA_EXT:
 		case WIN_IDENTIFY_DMA:
-			if (!hwif->ide_dma_read(drive))
+			if (!hwif->dma_setup(drive)) {
+				hwif->dma_exec_cmd(drive, taskfile->command);
+				hwif->dma_start(drive);
 				return ide_started;
+			}
 			break;
 		default:
 			if (task->handler == NULL)
@@ -253,73 +248,6 @@
 
 EXPORT_SYMBOL(task_no_data_intr);
 
-static void task_buffer_sectors(ide_drive_t *drive, struct request *rq,
-				unsigned nsect, unsigned rw)
-{
-	char *buf = rq->buffer + blk_rq_offset(rq);
-
-	rq->sector += nsect;
-	rq->current_nr_sectors -= nsect;
-	rq->nr_sectors -= nsect;
-	__task_sectors(drive, buf, nsect, rw);
-}
-
-static inline void task_buffer_multi_sectors(ide_drive_t *drive,
-					     struct request *rq, unsigned rw)
-{
-	unsigned int msect = drive->mult_count, nsect;
-
-	nsect = rq->current_nr_sectors;
-	if (nsect > msect)
-		nsect = msect;
-
-	task_buffer_sectors(drive, rq, nsect, rw);
-}
-
-#ifdef CONFIG_IDE_TASKFILE_IO
-static void task_sectors(ide_drive_t *drive, struct request *rq,
-			 unsigned nsect, unsigned rw)
-{
-	if (rq->cbio) {	/* fs request */
-		rq->errors = 0;
-		task_bio_sectors(drive, rq, nsect, rw);
-	} else		/* task request */
-		task_buffer_sectors(drive, rq, nsect, rw);
-}
-
-static inline void task_bio_multi_sectors(ide_drive_t *drive,
-					  struct request *rq, unsigned rw)
-{
-	unsigned int nsect, msect = drive->mult_count;
-
-	do {
-		nsect = rq->current_nr_sectors;
-		if (nsect > msect)
-			nsect = msect;
-
-		task_bio_sectors(drive, rq, nsect, rw);
-
-		if (!rq->nr_sectors)
-			msect = 0;
-		else
-			msect -= nsect;
-	} while (msect);
-}
-
-static void task_multi_sectors(ide_drive_t *drive,
-			       struct request *rq, unsigned rw)
-{
-	if (rq->cbio) {	/* fs request */
-		rq->errors = 0;
-		task_bio_multi_sectors(drive, rq, rw);
-	} else		/* task request */
-		task_buffer_multi_sectors(drive, rq, rw);
-}
-#else
-# define task_sectors(d, rq, nsect, rw)	task_buffer_sectors(d, rq, nsect, rw)
-# define task_multi_sectors(d, rq, rw)	task_buffer_multi_sectors(d, rq, rw)
-#endif /* CONFIG_IDE_TASKFILE_IO */
-
 static u8 wait_drive_not_busy(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif = HWIF(drive);
@@ -340,37 +268,86 @@
 	return stat;
 }
 
+static void ide_pio_sector(ide_drive_t *drive, unsigned int write)
+{
+	ide_hwif_t *hwif = drive->hwif;
+	struct scatterlist *sg = hwif->sg_table;
+	struct page *page;
+#ifdef CONFIG_HIGHMEM
+	unsigned long flags;
+#endif
+	u8 *buf;
+
+	page = sg[hwif->cursg].page;
+#ifdef CONFIG_HIGHMEM
+	local_irq_save(flags);
+#endif
+	buf = kmap_atomic(page, KM_BIO_SRC_IRQ) +
+	      sg[hwif->cursg].offset + (hwif->cursg_ofs * SECTOR_SIZE);
+
+	hwif->nleft--;
+	hwif->cursg_ofs++;
+
+	if ((hwif->cursg_ofs * SECTOR_SIZE) == sg[hwif->cursg].length) {
+		hwif->cursg++;
+		hwif->cursg_ofs = 0;
+	}
+
+	/* do the actual data transfer */
+	if (write)
+		taskfile_output_data(drive, buf, SECTOR_WORDS);
+	else
+		taskfile_input_data(drive, buf, SECTOR_WORDS);
+
+	kunmap_atomic(page, KM_BIO_SRC_IRQ);
+#ifdef CONFIG_HIGHMEM
+	local_irq_restore(flags);
+#endif
+}
+
+static void ide_pio_multi(ide_drive_t *drive, unsigned int write)
+{
+	unsigned int nsect;
+
+	nsect = min_t(unsigned int, drive->hwif->nleft, drive->mult_count);
+	while (nsect--)
+		ide_pio_sector(drive, write);
+}
+
 static inline void ide_pio_datablock(ide_drive_t *drive, struct request *rq,
 				     unsigned int write)
 {
+	if (rq->bio)	/* fs request */
+		rq->errors = 0;
+
 	switch (drive->hwif->data_phase) {
 	case TASKFILE_MULTI_IN:
 	case TASKFILE_MULTI_OUT:
-		task_multi_sectors(drive, rq, write);
+		ide_pio_multi(drive, write);
 		break;
 	default:
-		task_sectors(drive, rq, 1, write);
+		ide_pio_sector(drive, write);
 		break;
 	}
 }
 
-#ifdef CONFIG_IDE_TASKFILE_IO
 static ide_startstop_t task_error(ide_drive_t *drive, struct request *rq,
 				  const char *s, u8 stat)
 {
 	if (rq->bio) {
-		int sectors = rq->hard_nr_sectors - rq->nr_sectors;
+		ide_hwif_t *hwif = drive->hwif;
+		int sectors = hwif->nsect - hwif->nleft;
 
-		switch (drive->hwif->data_phase) {
+		switch (hwif->data_phase) {
 		case TASKFILE_IN:
-			if (rq->nr_sectors)
+			if (hwif->nleft)
 				break;
 			/* fall through */
 		case TASKFILE_OUT:
 			sectors--;
 			break;
 		case TASKFILE_MULTI_IN:
-			if (rq->nr_sectors)
+			if (hwif->nleft)
 				break;
 			/* fall through */
 		case TASKFILE_MULTI_OUT:
@@ -384,9 +361,6 @@
 	}
 	return drive->driver->error(drive, s, stat);
 }
-#else
-# define task_error(d, rq, s, stat) drive->driver->error(d, s, stat)
-#endif
 
 static void task_end_request(ide_drive_t *drive, struct request *rq, u8 stat)
 {
@@ -407,9 +381,11 @@
  */
 ide_startstop_t task_in_intr (ide_drive_t *drive)
 {
+	ide_hwif_t *hwif = drive->hwif;
 	struct request *rq = HWGROUP(drive)->rq;
-	u8 stat = HWIF(drive)->INB(IDE_STATUS_REG);
+	u8 stat = hwif->INB(IDE_STATUS_REG);
 
+	/* new way for dealing with premature shared PCI interrupts */
 	if (!OK_STAT(stat, DATA_READY, BAD_R_STAT)) {
 		if (stat & (ERR_STAT | DRQ_STAT))
 			return task_error(drive, rq, __FUNCTION__, stat);
@@ -421,7 +397,7 @@
 	ide_pio_datablock(drive, rq, 0);
 
 	/* If it was the last datablock check status and finish transfer. */
-	if (!rq->nr_sectors) {
+	if (!hwif->nleft) {
 		stat = wait_drive_not_busy(drive);
 		if (!OK_STAT(stat, 0, BAD_R_STAT))
 			return task_error(drive, rq, __FUNCTION__, stat);
@@ -441,18 +417,18 @@
  */
 ide_startstop_t task_out_intr (ide_drive_t *drive)
 {
+	ide_hwif_t *hwif = drive->hwif;
 	struct request *rq = HWGROUP(drive)->rq;
-	u8 stat;
+	u8 stat = hwif->INB(IDE_STATUS_REG);
 
-	stat = HWIF(drive)->INB(IDE_STATUS_REG);
 	if (!OK_STAT(stat, DRIVE_READY, drive->bad_wstat))
 		return task_error(drive, rq, __FUNCTION__, stat);
 
 	/* Deal with unexpected ATA data phase. */
-	if (((stat & DRQ_STAT) == 0) ^ !rq->nr_sectors)
+	if (((stat & DRQ_STAT) == 0) ^ !hwif->nleft)
 		return task_error(drive, rq, __FUNCTION__, stat);
 
-	if (!rq->nr_sectors) {
+	if (!hwif->nleft) {
 		task_end_request(drive, rq, stat);
 		return ide_stopped;
 	}
@@ -489,7 +465,7 @@
 }
 EXPORT_SYMBOL(pre_task_out_intr);
 
-int ide_diag_taskfile (ide_drive_t *drive, ide_task_t *args, unsigned long data_size, u8 *buf)
+int ide_raw_taskfile(ide_drive_t *drive, ide_task_t *args, u8 *buf)
 {
 	struct request rq;
 
@@ -504,10 +480,7 @@
 	 * To support special commands like READ LONG.
 	 */
 	if (args->command_type != IDE_DRIVE_TASK_NO_DATA) {
-		if (data_size == 0)
-			rq.nr_sectors = (args->hobRegister[IDE_NSECTOR_OFFSET] << 8) | args->tfRegister[IDE_NSECTOR_OFFSET];
-		else
-			rq.nr_sectors = data_size / SECTOR_SIZE;
+		rq.nr_sectors = args->data_len;
 
 		if (!rq.nr_sectors) {
 			printk(KERN_ERR "%s: in/out command without data\n",
@@ -517,25 +490,17 @@
 
 		rq.hard_nr_sectors = rq.nr_sectors;
 		rq.hard_cur_sectors = rq.current_nr_sectors = rq.nr_sectors;
+
+		if (args->command_type == IDE_DRIVE_TASK_RAW_WRITE)
+			rq.flags |= REQ_RW;
 	}
 
 	rq.special = args;
 	return ide_do_drive_cmd(drive, &rq, ide_wait);
 }
 
-EXPORT_SYMBOL(ide_diag_taskfile);
-
-int ide_raw_taskfile (ide_drive_t *drive, ide_task_t *args, u8 *buf)
-{
-	return ide_diag_taskfile(drive, args, 0, buf);
-}
-
 EXPORT_SYMBOL(ide_raw_taskfile);
 
-#define MAX_DMA		(256*SECTOR_WORDS)
-
-ide_startstop_t flagged_taskfile(ide_drive_t *, ide_task_t *);
-
 int ide_taskfile_ioctl (ide_drive_t *drive, unsigned int cmd, unsigned long arg)
 {
 	ide_task_request_t	*req_task;
@@ -605,11 +570,13 @@
 	switch(req_task->data_phase) {
 		case TASKFILE_OUT_DMAQ:
 		case TASKFILE_OUT_DMA:
-			err = ide_diag_taskfile(drive, &args, taskout, outbuf);
+			args.data_len = taskout;
+			err = ide_raw_taskfile(drive, &args, outbuf);
 			break;
 		case TASKFILE_IN_DMAQ:
 		case TASKFILE_IN_DMA:
-			err = ide_diag_taskfile(drive, &args, taskin, inbuf);
+			args.data_len = taskin;
+			err = ide_raw_taskfile(drive, &args, inbuf);
 			break;
 		case TASKFILE_MULTI_OUT:
 			if (!drive->mult_count) {
@@ -624,7 +591,8 @@
 		case TASKFILE_OUT:
 			args.prehandler = &pre_task_out_intr;
 			args.handler = &task_out_intr;
-			err = ide_diag_taskfile(drive, &args, taskout, outbuf);
+			args.data_len = taskout;
+			err = ide_raw_taskfile(drive, &args, outbuf);
 			break;
 		case TASKFILE_MULTI_IN:
 			if (!drive->mult_count) {
@@ -638,11 +606,12 @@
 			/* fall through */
 		case TASKFILE_IN:
 			args.handler = &task_in_intr;
-			err = ide_diag_taskfile(drive, &args, taskin, inbuf);
+			args.data_len = taskin;
+			err = ide_raw_taskfile(drive, &args, inbuf);
 			break;
 		case TASKFILE_NO_DATA:
 			args.handler = &task_no_data_intr;
-			err = ide_diag_taskfile(drive, &args, 0, NULL);
+			err = ide_raw_taskfile(drive, &args, NULL);
 			break;
 		default:
 			err = -EFAULT;
@@ -686,8 +655,6 @@
 	return err;
 }
 
-EXPORT_SYMBOL(ide_taskfile_ioctl);
-
 int ide_wait_cmd (ide_drive_t *drive, u8 cmd, u8 nsect, u8 feature, u8 sectors, u8 *buf)
 {
 	struct request rq;
@@ -705,8 +672,6 @@
 	return ide_do_drive_cmd(drive, &rq, ide_wait);
 }
 
-EXPORT_SYMBOL(ide_wait_cmd);
-
 /*
  * FIXME : this needs to map into at taskfile. <andre@linux-ide.org>
  */
@@ -764,9 +729,7 @@
 	return err;
 }
 
-EXPORT_SYMBOL(ide_cmd_ioctl);
-
-int ide_wait_cmd_task (ide_drive_t *drive, u8 *buf)
+static int ide_wait_cmd_task(ide_drive_t *drive, u8 *buf)
 {
 	struct request rq;
 
@@ -776,8 +739,6 @@
 	return ide_do_drive_cmd(drive, &rq, ide_wait);
 }
 
-EXPORT_SYMBOL(ide_wait_cmd_task);
-
 /*
  * FIXME : this needs to map into at taskfile. <andre@linux-ide.org>
  */
@@ -796,8 +757,6 @@
 	return err;
 }
 
-EXPORT_SYMBOL(ide_task_ioctl);
-
 /*
  * NOTICE: This is additions from IBM to provide a discrete interface,
  * for selective taskregister access operations.  Nice JOB Klaus!!!
@@ -896,12 +855,11 @@
 
    	        case TASKFILE_OUT_DMAQ:
 		case TASKFILE_OUT_DMA:
-			hwif->ide_dma_write(drive);
-			break;
-
 		case TASKFILE_IN_DMAQ:
 		case TASKFILE_IN_DMA:
-			hwif->ide_dma_read(drive);
+			hwif->dma_setup(drive);
+			hwif->dma_exec_cmd(drive, taskfile->command);
+			hwif->dma_start(drive);
 			break;
 
 	        default:
@@ -919,5 +877,3 @@
 
 	return ide_started;
 }
-
-EXPORT_SYMBOL(flagged_taskfile);
diff -Nru a/drivers/ide/ide.c b/drivers/ide/ide.c
--- a/drivers/ide/ide.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/ide.c	2004-10-10 23:09:59 -07:00
@@ -668,7 +668,6 @@
 	hwif->cds			= tmp_hwif->cds;
 #endif
 
-	hwif->identify			= tmp_hwif->identify;
 	hwif->tuneproc			= tmp_hwif->tuneproc;
 	hwif->speedproc			= tmp_hwif->speedproc;
 	hwif->selectproc		= tmp_hwif->selectproc;
@@ -685,9 +684,9 @@
 	hwif->atapi_input_bytes		= tmp_hwif->atapi_input_bytes;
 	hwif->atapi_output_bytes	= tmp_hwif->atapi_output_bytes;
 
-	hwif->ide_dma_read		= tmp_hwif->ide_dma_read;
-	hwif->ide_dma_write		= tmp_hwif->ide_dma_write;
-	hwif->ide_dma_begin		= tmp_hwif->ide_dma_begin;
+	hwif->dma_setup			= tmp_hwif->dma_setup;
+	hwif->dma_exec_cmd		= tmp_hwif->dma_exec_cmd;
+	hwif->dma_start			= tmp_hwif->dma_start;
 	hwif->ide_dma_end		= tmp_hwif->ide_dma_end;
 	hwif->ide_dma_check		= tmp_hwif->ide_dma_check;
 	hwif->ide_dma_on		= tmp_hwif->ide_dma_on;
@@ -695,7 +694,6 @@
 	hwif->ide_dma_test_irq		= tmp_hwif->ide_dma_test_irq;
 	hwif->ide_dma_host_on		= tmp_hwif->ide_dma_host_on;
 	hwif->ide_dma_host_off		= tmp_hwif->ide_dma_host_off;
-	hwif->ide_dma_verbose		= tmp_hwif->ide_dma_verbose;
 	hwif->ide_dma_lostirq		= tmp_hwif->ide_dma_lostirq;
 	hwif->ide_dma_timeout		= tmp_hwif->ide_dma_timeout;
 
@@ -900,6 +898,7 @@
 		hwif->drives[i].disk = NULL;
 		put_disk(disk);
 	}
+	kfree(hwif->sg_table);
 	unregister_blkdev(hwif->major, hwif->name);
 	spin_lock_irq(&ide_lock);
 
@@ -1415,7 +1414,6 @@
 	ide_add_setting(drive,	"using_dma",		SETTING_RW,					HDIO_GET_DMA,		HDIO_SET_DMA,		TYPE_BYTE,	0,	1,				1,		1,		&drive->using_dma,		set_using_dma);
 	ide_add_setting(drive,	"init_speed",		SETTING_RW,					-1,			-1,			TYPE_BYTE,	0,	70,				1,		1,		&drive->init_speed,		NULL);
 	ide_add_setting(drive,	"current_speed",	SETTING_RW,					-1,			-1,			TYPE_BYTE,	0,	70,				1,		1,		&drive->current_speed,		set_xfer_rate);
-	ide_add_setting(drive,	"number",		SETTING_RW,					-1,			-1,			TYPE_BYTE,	0,	3,				1,		1,		&drive->dn,			NULL);
 }
 
 /**
@@ -1775,9 +1773,6 @@
 	return 0;	/* zero = nothing matched */
 }
 
-#ifdef CONFIG_BLK_DEV_PDC4030
-static int __initdata probe_pdc4030;
-#endif
 #ifdef CONFIG_BLK_DEV_ALI14XX
 static int __initdata probe_ali14xx;
 extern int ali14xx_init(void);
@@ -1856,7 +1851,7 @@
 	if (s[0] == 'h' && s[1] == 'd' && s[2] >= 'a' && s[2] <= max_drive) {
 		const char *hd_words[] = {
 			"none", "noprobe", "nowerr", "cdrom", "serialize",
-			"autotune", "noautotune", "stroke", "swapdata", "bswap",
+			"autotune", "noautotune", "minus8", "swapdata", "bswap",
 			"minus11", "remap", "remap63", "scsi", NULL };
 		unit = s[2] - 'a';
 		hw   = unit / MAX_DRIVES;
@@ -1886,13 +1881,10 @@
 				goto do_serialize;
 			case -6: /* "autotune" */
 				drive->autotune = IDE_TUNE_AUTO;
-				goto done;
+				goto obsolete_option;
 			case -7: /* "noautotune" */
 				drive->autotune = IDE_TUNE_NOAUTO;
-				goto done;
-			case -8: /* stroke */
-				drive->stroke = 1;
-				goto done;
+				goto obsolete_option;
 			case -9: /* "swapdata" */
 			case -10: /* "bswap" */
 				drive->bswap = 1;
@@ -1946,7 +1938,7 @@
 			"noprobe", "serialize", "autotune", "noautotune", 
 			"reset", "dma", "ata66", "minus8", "minus9",
 			"minus10", "four", "qd65xx", "ht6560b", "cmd640_vlb",
-			"dtc2278", "umc8672", "ali14xx", "dc4030", NULL };
+			"dtc2278", "umc8672", "ali14xx", NULL };
 		hw = s[3] - '0';
 		hwif = &ide_hwifs[hw];
 		i = match_parm(&s[4], ide_words, vals, 3);
@@ -1972,11 +1964,6 @@
 		}
 
 		switch (i) {
-#ifdef CONFIG_BLK_DEV_PDC4030
-			case -18: /* "dc4030" */
-				probe_pdc4030 = 1;
-				goto done;
-#endif
 #ifdef CONFIG_BLK_DEV_ALI14XX
 			case -17: /* "ali14xx" */
 				probe_ali14xx = 1;
@@ -2029,30 +2016,30 @@
 			case -7: /* ata66 */
 #ifdef CONFIG_BLK_DEV_IDEPCI
 				hwif->udma_four = 1;
-				goto done;
+				goto obsolete_option;
 #else
 				goto bad_hwif;
 #endif
 			case -6: /* dma */
 				hwif->autodma = 1;
-				goto done;
+				goto obsolete_option;
 			case -5: /* "reset" */
 				hwif->reset = 1;
-				goto done;
+				goto obsolete_option;
 			case -4: /* "noautotune" */
 				hwif->drives[0].autotune = IDE_TUNE_NOAUTO;
 				hwif->drives[1].autotune = IDE_TUNE_NOAUTO;
-				goto done;
+				goto obsolete_option;
 			case -3: /* "autotune" */
 				hwif->drives[0].autotune = IDE_TUNE_AUTO;
 				hwif->drives[1].autotune = IDE_TUNE_AUTO;
-				goto done;
+				goto obsolete_option;
 			case -2: /* "serialize" */
 			do_serialize:
 				hwif->mate = &ide_hwifs[hw^1];
 				hwif->mate->mate = hwif;
 				hwif->serialized = hwif->mate->serialized = 1;
-				goto done;
+				goto obsolete_option;
 
 			case -1: /* "noprobe" */
 				hwif->noprobe = 1;
@@ -2069,7 +2056,7 @@
 				hwif->irq      = vals[2];
 				hwif->noprobe  = 0;
 				hwif->chipset  = ide_forced;
-				goto done;
+				goto obsolete_option;
 
 			case 0: goto bad_option;
 			default:
@@ -2080,6 +2067,9 @@
 bad_option:
 	printk(" -- BAD OPTION\n");
 	return 1;
+obsolete_option:
+	printk(" -- OBSOLETE OPTION, WILL BE REMOVED SOON!\n");
+	return 1;
 bad_hwif:
 	printk("-- NOT SUPPORTED ON ide%d", hw);
 done:
@@ -2111,13 +2101,6 @@
 		ide_probe_for_cmd640x();
 	}
 #endif /* CONFIG_BLK_DEV_CMD640 */
-#ifdef CONFIG_BLK_DEV_PDC4030
-	{
-		extern int pdc4030_init(void);
-		if (probe_pdc4030)
-			(void)pdc4030_init();
-	}
-#endif /* CONFIG_BLK_DEV_PDC4030 */
 #ifdef CONFIG_BLK_DEV_IDE_PMAC
 	{
 		extern void pmac_ide_probe(void);
diff -Nru a/drivers/ide/legacy/Makefile b/drivers/ide/legacy/Makefile
--- a/drivers/ide/legacy/Makefile	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/legacy/Makefile	2004-10-10 23:09:59 -07:00
@@ -2,7 +2,6 @@
 obj-$(CONFIG_BLK_DEV_ALI14XX)		+= ali14xx.o
 obj-$(CONFIG_BLK_DEV_DTC2278)		+= dtc2278.o
 obj-$(CONFIG_BLK_DEV_HT6560B)		+= ht6560b.o
-obj-$(CONFIG_BLK_DEV_PDC4030)		+= pdc4030.o
 obj-$(CONFIG_BLK_DEV_QD65XX)		+= qd65xx.o
 obj-$(CONFIG_BLK_DEV_UMC8672)		+= umc8672.o
 
diff -Nru a/drivers/ide/legacy/pdc4030.c b/drivers/ide/legacy/pdc4030.c
--- a/drivers/ide/legacy/pdc4030.c	2004-10-10 23:09:59 -07:00
+++ /dev/null	Wed Dec 31 16:00:00 196900
@@ -1,679 +0,0 @@
-/*  -*- linux-c -*-
- *  linux/drivers/ide/legacy/pdc4030.c		Version 0.90  May 27, 1999
- *
- *  Copyright (C) 1995-2002  Linus Torvalds & authors (see below)
- */
-
-/*
- *  Principal Author/Maintainer:  Peter Denison <promise@pnd-pc.demon.co.uk>
- *
- *  This file provides support for the second port and cache of Promise
- *  IDE interfaces, e.g. DC4030VL, DC4030VL-1 and DC4030VL-2.
- *
- *  Thanks are due to Mark Lord for advice and patiently answering stupid
- *  questions, and all those mugs^H^H^H^Hbrave souls who've tested this,
- *  especially Andre Hedrick.
- *
- *  Version 0.01	Initial version, #include'd in ide.c rather than
- *                      compiled separately.
- *                      Reads use Promise commands, writes as before. Drives
- *                      on second channel are read-only.
- *  Version 0.02        Writes working on second channel, reads on both
- *                      channels. Writes fail under high load. Suspect
- *			transfers of >127 sectors don't work.
- *  Version 0.03        Brought into line with ide.c version 5.27.
- *                      Other minor changes.
- *  Version 0.04        Updated for ide.c version 5.30
- *                      Changed initialization strategy
- *  Version 0.05	Kernel integration.  -ml
- *  Version 0.06	Ooops. Add hwgroup to direct call of ide_intr() -ml
- *  Version 0.07	Added support for DC4030 variants
- *			Secondary interface autodetection
- *  Version 0.08	Renamed to pdc4030.c
- *  Version 0.09	Obsolete - never released - did manual write request
- *			splitting before max_sectors[major][minor] available.
- *  Version 0.10	Updated for 2.1 series of kernels
- *  Version 0.11	Updated for 2.3 series of kernels
- *			Autodetection code added.
- *
- *  Version 0.90	Transition to BETA code. No lost/unexpected interrupts
- */
-
-/*
- * Once you've compiled it in, you'll have to also enable the interface
- * setup routine from the kernel command line, as in 
- *
- *	'linux ide0=dc4030' or 'linux ide1=dc4030'
- *
- * It should now work as a second controller also ('ide1=dc4030') but only
- * if you DON'T have BIOS V4.44, which has a bug. If you have this version
- * and EPROM programming facilities, you need to fix 4 bytes:
- * 	2496:	81	81
- *	2497:	3E	3E
- *	2498:	22	98	*
- *	2499:	06	05	*
- *	249A:	F0	F0
- *	249B:	01	01
- *	...
- *	24A7:	81	81
- *	24A8:	3E	3E
- *	24A9:	22	98	*
- *	24AA:	06	05	*
- *	24AB:	70	70
- *	24AC:	01	01
- *
- * As of January 1999, Promise Technology Inc. have finally supplied me with
- * some technical information which has shed a glimmer of light on some of the
- * problems I was having, especially with writes. 
- *
- * There are still potential problems with the robustness and efficiency of
- * this driver because I still don't understand what the card is doing with
- * interrupts, however, it has been stable for a while with no reports of ill
- * effects.
- */
-
-#define DEBUG_READ
-#define DEBUG_WRITE
-#define __PROMISE_4030
-
-#include <linux/module.h>
-#include <linux/config.h>
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/timer.h>
-#include <linux/mm.h>
-#include <linux/ioport.h>
-#include <linux/blkdev.h>
-#include <linux/hdreg.h>
-#include <linux/ide.h>
-#include <linux/init.h>
-
-#include <asm/io.h>
-#include <asm/irq.h>
-
-#include "pdc4030.h"
-
-static ide_startstop_t promise_rw_disk (ide_drive_t *drive, struct request *rq, sector_t block);
-
-/*
- * promise_selectproc() is invoked by ide.c
- * in preparation for access to the specified drive.
- */
-static void promise_selectproc (ide_drive_t *drive)
-{
-	unsigned int number;
-
-	number = (HWIF(drive)->channel << 1) + drive->select.b.unit;
-	HWIF(drive)->OUTB(number, IDE_FEATURE_REG);
-}
-
-/*
- * pdc4030_cmd handles the set of vendor specific commands that are initiated
- * by command F0. They all have the same success/failure notification -
- * 'P' (=0x50) on success, 'p' (=0x70) on failure.
- */
-int pdc4030_cmd(ide_drive_t *drive, u8 cmd)
-{
-	unsigned long timeout;
-	u8 status_val;
-
-	promise_selectproc(drive);	/* redundant? */
-	HWIF(drive)->OUTB(0xF3, IDE_SECTOR_REG);
-	HWIF(drive)->OUTB(cmd, IDE_SELECT_REG);
-	HWIF(drive)->OUTB(PROMISE_EXTENDED_COMMAND, IDE_COMMAND_REG);
-	timeout = HZ * 10;
-	timeout += jiffies;
-	do {
-		if(time_after(jiffies, timeout)) {
-			return 2; /* device timed out */
-		}
-		/* Delays at least 10ms to give interface a chance */
-		mdelay(10);
-		status_val = HWIF(drive)->INB(IDE_SECTOR_REG);
-	} while (status_val != 0x50 && status_val != 0x70);
-
-	if(status_val == 0x50)
-		return 0; /* device returned success */
-	else
-		return 1; /* device returned failure */
-}
-
-/*
- * pdc4030_identify sends a vendor-specific IDENTIFY command to the drive
- */
-int pdc4030_identify(ide_drive_t *drive)
-{
-	return pdc4030_cmd(drive, PROMISE_IDENTIFY);
-}
-
-/*
- * setup_pdc4030()
- * Completes the setup of a Promise DC4030 controller card, once found.
- */
-int __init setup_pdc4030(ide_hwif_t *hwif)
-{
-        ide_drive_t *drive;
-	ide_hwif_t *hwif2;
-	struct dc_ident ident;
-	int i;
-	ide_startstop_t startstop;
-	
-	if (!hwif) return 0;
-
-	drive = &hwif->drives[0];
-	hwif2 = &ide_hwifs[hwif->index+1];
-	if (hwif->chipset == ide_pdc4030) /* we've already been found ! */
-		return 1;
-
-	if (hwif->INB(IDE_NSECTOR_REG) == 0xFF ||
-	    hwif->INB(IDE_SECTOR_REG) == 0xFF) {
-		return 0;
-	}
-	if (IDE_CONTROL_REG)
-		hwif->OUTB(0x08, IDE_CONTROL_REG);
-	if (pdc4030_cmd(drive,PROMISE_GET_CONFIG)) {
-		return 0;
-	}
-	if (ide_wait_stat(&startstop, drive,DATA_READY,BAD_W_STAT,WAIT_DRQ)) {
-		printk(KERN_INFO
-			"%s: Failed Promise read config!\n",hwif->name);
-		return 0;
-	}
-	hwif->ata_input_data(drive, &ident, SECTOR_WORDS);
-	if (ident.id[1] != 'P' || ident.id[0] != 'T') {
-		return 0;
-	}
-	printk(KERN_INFO "%s: Promise caching controller, ",hwif->name);
-	switch(ident.type) {
-		case 0x43:	printk("DC4030VL-2, "); break;
-		case 0x41:	printk("DC4030VL-1, "); break;
-		case 0x40:	printk("DC4030VL, "); break;
-		default:
-			printk("unknown - type 0x%02x - please report!\n"
-			       ,ident.type);
-			printk("Please e-mail the following data to "
-			       "promise@pnd-pc.demon.co.uk along with\n"
-			       "a description of your card and drives:\n");
-			for (i=0; i < 0x90; i++) {
-				printk("%02x ", ((unsigned char *)&ident)[i]);
-				if ((i & 0x0f) == 0x0f) printk("\n");
-			}
-			return 0;
-	}
-	printk("%dKB cache, ",(int)ident.cache_mem);
-	switch(ident.irq) {
-            case 0x00: hwif->irq = 14; break;
-            case 0x01: hwif->irq = 12; break;
-            default:   hwif->irq = 15; break;
-	}
-	printk("on IRQ %d\n",hwif->irq);
-
-	/*
-	 * Once found and identified, we set up the next hwif in the array
-	 * (hwif2 = ide_hwifs[hwif->index+1]) with the same io ports, irq
-	 * and other settings as the main hwif. This gives us two "mated"
-	 * hwifs pointing to the Promise card.
-	 *
-	 * We also have to shift the default values for the remaining
-	 * interfaces "up by one" to make room for the second interface on the
-	 * same set of values.
-	 */
-
-	hwif->chipset	= hwif2->chipset = ide_pdc4030;
-	hwif->mate	= hwif2;
-	hwif2->mate	= hwif;
-	hwif2->channel	= 1;
-	hwif->rqsize	= hwif2->rqsize = 127;
-	hwif->no_lba48 = hwif2->no_lba48 = 1;
-	hwif->selectproc = hwif2->selectproc = &promise_selectproc;
-	hwif->serialized = hwif2->serialized = 1;
-	/* DC4030 hosted drives need their own identify... */
-	hwif->identify = hwif2->identify = &pdc4030_identify;
-
-	/* Override the normal ide disk read/write. */
-	hwif->rw_disk = promise_rw_disk;
-	hwif2->rw_disk = promise_rw_disk;
-
-	/* Shift the remaining interfaces up by one */
-	for (i=MAX_HWIFS-1 ; i > hwif->index+1 ; i--) {
-		ide_hwif_t *h = &ide_hwifs[i];
-
-#ifdef DEBUG
-		printk(KERN_DEBUG "pdc4030: Shifting i/f %d values to i/f %d\n",i-1,i);
-#endif /* DEBUG */
-		ide_init_hwif_ports(&h->hw, (h-1)->io_ports[IDE_DATA_OFFSET], 0, NULL);
-		memcpy(h->io_ports, h->hw.io_ports, sizeof(h->io_ports));
-		h->noprobe = (h-1)->noprobe;
-	}
-	ide_init_hwif_ports(&hwif2->hw, hwif->io_ports[IDE_DATA_OFFSET], 0, NULL);
-	memcpy(hwif2->io_ports, hwif->hw.io_ports, sizeof(hwif2->io_ports));
-	hwif2->irq = hwif->irq;
-	hwif2->hw.irq = hwif->hw.irq = hwif->irq;
-	for (i=0; i<2 ; i++) {
-		hwif->drives[i].io_32bit = 3;
-		hwif2->drives[i].io_32bit = 3;
-		hwif->drives[i].keep_settings = 1;
-		hwif2->drives[i].keep_settings = 1;
-		if (!ident.current_tm[i].cyl)
-			hwif->drives[i].noprobe = 1;
-		if (!ident.current_tm[i+2].cyl)
-			hwif2->drives[i].noprobe = 1;
-	}
-
-	probe_hwif_init(&ide_hwifs[hwif->index]);
-	probe_hwif_init(&ide_hwifs[hwif2->index]);
-
-	return 1;
-}
-
-/*
- * detect_pdc4030()
- * Tests for the presence of a DC4030 Promise card on this interface
- * Returns: 1 if found, 0 if not found
- */
-int __init detect_pdc4030(ide_hwif_t *hwif)
-{
-	ide_drive_t *drive = &hwif->drives[0];
-
-	if (IDE_DATA_REG == 0) { /* Skip test for non-existent interface */
-		return 0;
-	}
-	hwif->OUTB(0xF3, IDE_SECTOR_REG);
-	hwif->OUTB(0x14, IDE_SELECT_REG);
-	hwif->OUTB(PROMISE_EXTENDED_COMMAND, IDE_COMMAND_REG);
-
-	msleep(50);
-
-	if (hwif->INB(IDE_ERROR_REG) == 'P' &&
-	    hwif->INB(IDE_NSECTOR_REG) == 'T' &&
-	    hwif->INB(IDE_SECTOR_REG) == 'I') {
-		return 1;
-	} else {
-		return 0;
-	}
-}
-
-int __init pdc4030_init(void)
-{
-	unsigned int	index;
-	ide_hwif_t	*hwif;
-
-	for (index = 0; index < MAX_HWIFS; index++) {
-		hwif = &ide_hwifs[index];
-		if (hwif->chipset == ide_unknown && detect_pdc4030(hwif)) {
-			if (!setup_pdc4030(hwif))
-				return -ENODEV;
-			return 0;
-		}
-	}
-	return -ENODEV;
-}
-
-#ifdef MODULE
-module_init(pdc4030_init);
-#endif
-
-MODULE_AUTHOR("Peter Denison");
-MODULE_DESCRIPTION("Support of Promise 4030 VLB series IDE chipsets");
-MODULE_LICENSE("GPL");
-
-/*
- * promise_read_intr() is the handler for disk read/multread interrupts
- */
-static ide_startstop_t promise_read_intr (ide_drive_t *drive)
-{
-	unsigned int sectors_left, sectors_avail, nsect;
-	struct request *rq = HWGROUP(drive)->rq;
-	ata_status_t status;
-
-	status.all = HWIF(drive)->INB(IDE_STATUS_REG);
-	if (!OK_STAT(status.all, DATA_READY, BAD_R_STAT))
-		return DRIVER(drive)->error(drive, __FUNCTION__, status.all);
-
-read_again:
-	do {
-		sectors_left = HWIF(drive)->INB(IDE_NSECTOR_REG);
-		HWIF(drive)->INB(IDE_SECTOR_REG);
-	} while (HWIF(drive)->INB(IDE_NSECTOR_REG) != sectors_left);
-	sectors_avail = rq->nr_sectors - sectors_left;
-	if (!sectors_avail)
-		goto read_again;
-
-read_next:
-	nsect = rq->current_nr_sectors;
-	if (nsect > sectors_avail)
-		nsect = sectors_avail;
-	sectors_avail -= nsect;
-
-#ifdef DEBUG_READ
-	printk(KERN_DEBUG "%s: %s: sectors(%lu-%lu), rem=%lu\n",
-			  drive->name, __FUNCTION__,
-			  (unsigned long)rq->sector,
-			  (unsigned long)rq->sector + nsect - 1,
-			  (unsigned long)rq->nr_sectors - nsect);
-#endif /* DEBUG_READ */
-
-	HWIF(drive)->ata_input_data(drive, rq->buffer, nsect * SECTOR_WORDS);
-	rq->buffer += nsect<<9;
-	rq->sector += nsect;
-	rq->errors = 0;
-	rq->nr_sectors -= nsect;
-	if (!rq->current_nr_sectors)
-		DRIVER(drive)->end_request(drive, 1, 0);
-
-/*
- * Now the data has been read in, do the following:
- * 
- * if there are still sectors left in the request, 
- *   if we know there are still sectors available from the interface,
- *     go back and read the next bit of the request.
- *   else if DRQ is asserted, there are more sectors available, so
- *     go back and find out how many, then read them in.
- *   else if BUSY is asserted, we are going to get an interrupt, so
- *     set the handler for the interrupt and just return
- */
-	if (rq->nr_sectors > 0) {
-		if (sectors_avail)
-			goto read_next;
-		status.all = HWIF(drive)->INB(IDE_STATUS_REG);
-		if (status.b.drq)
-			goto read_again;
-		if (status.b.bsy) {
-			if (HWGROUP(drive)->handler != NULL)
-				BUG();
-			ide_set_handler(drive,
-					&promise_read_intr,
-					WAIT_CMD,
-					NULL);
-#ifdef DEBUG_READ
-			printk(KERN_DEBUG "%s: promise_read: waiting for"
-			       "interrupt\n", drive->name);
-#endif /* DEBUG_READ */
-			return ide_started;
-		}
-		printk(KERN_ERR "%s: Eeek! promise_read_intr: sectors left "
-		       "!DRQ !BUSY\n", drive->name);
-		return DRIVER(drive)->error(drive,
-				"promise read intr", status.all);
-	}
-	return ide_stopped;
-}
-
-/*
- * promise_complete_pollfunc()
- * This is the polling function for waiting (nicely!) until drive stops
- * being busy. It is invoked at the end of a write, after the previous poll
- * has finished.
- *
- * Once not busy, the end request is called.
- */
-static ide_startstop_t promise_complete_pollfunc(ide_drive_t *drive)
-{
-	ide_hwgroup_t *hwgroup = HWGROUP(drive);
-	struct request *rq = &hwgroup->wrq;
-	struct bio *bio = rq->bio;
-
-	if ((HWIF(drive)->INB(IDE_STATUS_REG)) & BUSY_STAT) {
-		if (time_before(jiffies, hwgroup->poll_timeout)) {
-			if (hwgroup->handler != NULL)
-				BUG();
-			ide_set_handler(drive,
-					&promise_complete_pollfunc,
-					HZ/100,
-					NULL);
-			return ide_started; /* continue polling... */
-		}
-		hwgroup->poll_timeout = 0;
-		printk(KERN_ERR "%s: completion timeout - still busy!\n",
-		       drive->name);
-		return DRIVER(drive)->error(drive, "busy timeout",
-				HWIF(drive)->INB(IDE_STATUS_REG));
-	}
-
-	hwgroup->poll_timeout = 0;
-#ifdef DEBUG_WRITE
-	printk(KERN_DEBUG "%s: Write complete - end_request\n", drive->name);
-#endif /* DEBUG_WRITE */
-
-	bio->bi_idx = bio->bi_vcnt - rq->nr_cbio_segments;
-	rq = hwgroup->rq;
-	DRIVER(drive)->end_request(drive, 1, rq->hard_nr_sectors);
-
-	return ide_stopped;
-}
-
-/*
- * promise_multwrite() transfers a block of up to mcount sectors of data
- * to a drive as part of a disk multiple-sector write operation.
- */
-static void promise_multwrite (ide_drive_t *drive, unsigned int mcount)
-{
-	ide_hwgroup_t *hwgroup	= HWGROUP(drive);
-	struct request *rq	= &hwgroup->wrq;
-
-	do {
-		char *buffer;
-		int nsect = rq->current_nr_sectors;
-
-		if (nsect > mcount)
-			nsect = mcount;
-		mcount -= nsect;
-		buffer = rq->buffer;
-
-		rq->sector += nsect;
-		rq->buffer += nsect << 9;
-		rq->nr_sectors -= nsect;
-		rq->current_nr_sectors -= nsect;
-
-		/* Do we move to the next bh after this? */
-		if (!rq->current_nr_sectors) {
-			struct bio *bio = rq->bio;
-
-			/*
-			 * only move to next bio, when we have processed
-			 * all bvecs in this one.
-			 */
-			if (++bio->bi_idx >= bio->bi_vcnt) {
-				bio->bi_idx = bio->bi_vcnt - rq->nr_cbio_segments;
-				bio = bio->bi_next;
-			}
-
-			/* end early early we ran out of requests */
-			if (!bio) {
-				mcount = 0;
-			} else {
-				rq->bio = bio;
-				rq->nr_cbio_segments = bio_segments(bio);
-				rq->current_nr_sectors = bio_cur_sectors(bio);
-				rq->hard_cur_sectors = rq->current_nr_sectors;
-			}
-		}
-
-		/*
-		 * Ok, we're all setup for the interrupt
-		 * re-entering us on the last transfer.
-		 */
-		taskfile_output_data(drive, buffer, nsect<<7);
-	} while (mcount);
-}
-
-/*
- * promise_write_pollfunc() is the handler for disk write completion polling.
- */
-static ide_startstop_t promise_write_pollfunc (ide_drive_t *drive)
-{
-	ide_hwgroup_t *hwgroup = HWGROUP(drive);
-	struct request *rq = &hwgroup->wrq;
-	struct bio *bio = rq->bio;
-
-	if (HWIF(drive)->INB(IDE_NSECTOR_REG) != 0) {
-		if (time_before(jiffies, hwgroup->poll_timeout)) {
-			if (hwgroup->handler != NULL)
-				BUG();
-			ide_set_handler(drive,
-					&promise_write_pollfunc,
-					HZ/100,
-					NULL);
-			return ide_started; /* continue polling... */
-		}
-		hwgroup->poll_timeout = 0;
-		printk(KERN_ERR "%s: write timed-out!\n",drive->name);
-		bio->bi_idx = bio->bi_vcnt - rq->nr_cbio_segments;
-		return DRIVER(drive)->error(drive, "write timeout",
-				HWIF(drive)->INB(IDE_STATUS_REG));
-	}
-
-	/*
-	 * Now write out last 4 sectors and poll for not BUSY
-	 */
-	promise_multwrite(drive, 4);
-	hwgroup->poll_timeout = jiffies + WAIT_WORSTCASE;
-	if (hwgroup->handler != NULL)
-		BUG();
-	ide_set_handler(drive, &promise_complete_pollfunc, HZ/100, NULL);
-#ifdef DEBUG_WRITE
-	printk(KERN_DEBUG "%s: Done last 4 sectors - status = %02x\n",
-		drive->name, HWIF(drive)->INB(IDE_STATUS_REG));
-#endif /* DEBUG_WRITE */
-	return ide_started;
-}
-
-/*
- * promise_write() transfers a block of one or more sectors of data to a
- * drive as part of a disk write operation. All but 4 sectors are transferred
- * in the first attempt, then the interface is polled (nicely!) for completion
- * before the final 4 sectors are transferred. There is no interrupt generated
- * on writes (at least on the DC4030VL-2), we just have to poll for NOT BUSY.
- */
-static ide_startstop_t promise_write (ide_drive_t *drive)
-{
-	ide_hwgroup_t *hwgroup = HWGROUP(drive);
-	struct request *rq = &hwgroup->wrq;
-
-#ifdef DEBUG_WRITE
-	printk(KERN_DEBUG "%s: %s: sectors(%lu-%lu)\n",
-			  drive->name, __FUNCTION__,
-			  (unsigned long)rq->sector,
-			  (unsigned long)rq->sector + rq->nr_sectors - 1);
-#endif /* DEBUG_WRITE */
-
-	/*
-	 * If there are more than 4 sectors to transfer, do n-4 then go into
-	 * the polling strategy as defined above.
-	 */
-	if (rq->nr_sectors > 4) {
-		promise_multwrite(drive, rq->nr_sectors - 4);
-		hwgroup->poll_timeout = jiffies + WAIT_WORSTCASE;
-		if (hwgroup->handler != NULL)	/* paranoia check */
-			BUG();
-		ide_set_handler (drive, &promise_write_pollfunc, HZ/100, NULL);
-		return ide_started;
-	} else {
-	/*
-	 * There are 4 or fewer sectors to transfer, do them all in one go
-	 * and wait for NOT BUSY.
-	 */
-		promise_multwrite(drive, rq->nr_sectors);
-		hwgroup->poll_timeout = jiffies + WAIT_WORSTCASE;
-		if (hwgroup->handler != NULL)
-			BUG();
-		ide_set_handler(drive,
-				&promise_complete_pollfunc,
-				HZ/100,
-				NULL);
-
-#ifdef DEBUG_WRITE
-		printk(KERN_DEBUG "%s: promise_write: <= 4 sectors, "
-			"status = %02x\n", drive->name,
-			HWIF(drive)->INB(IDE_STATUS_REG));
-#endif /* DEBUG_WRITE */
-		return ide_started;
-	}
-}
-
-/*
- * do_pdc4030_io() is called from promise_rw_disk, having had the block number
- * already set up. It issues a READ or WRITE command to the Promise
- * controller, assuming LBA has been used to set up the block number.
- */
-ide_startstop_t do_pdc4030_io (ide_drive_t *drive, struct request *rq)
-{
-	ide_startstop_t startstop;
-	unsigned long timeout;
-	u8 stat = 0;
-
-	if (rq_data_dir(rq) == READ) {
-		HWIF(drive)->OUTB(PROMISE_READ, IDE_COMMAND_REG);
-/*
- * The card's behaviour is odd at this point. If the data is
- * available, DRQ will be true, and no interrupt will be
- * generated by the card. If this is the case, we need to call the 
- * "interrupt" handler (promise_read_intr) directly. Otherwise, if
- * an interrupt is going to occur, bit0 of the SELECT register will
- * be high, so we can set the handler the just return and be interrupted.
- * If neither of these is the case, we wait for up to 50ms (badly I'm
- * afraid!) until one of them is.
- */
-		timeout = jiffies + HZ/20; /* 50ms wait */
-		do {
-			stat = HWIF(drive)->INB(IDE_STATUS_REG);
-			if (stat & DRQ_STAT) {
-				udelay(1);
-				return promise_read_intr(drive);
-			}
-			if (HWIF(drive)->INB(IDE_SELECT_REG) & 0x01) {
-#ifdef DEBUG_READ
-				printk(KERN_DEBUG "%s: read: waiting for "
-						"interrupt\n", drive->name);
-#endif /* DEBUG_READ */
-				ide_set_handler(drive,
-						&promise_read_intr,
-						WAIT_CMD,
-						NULL);
-				return ide_started;
-			}
-			udelay(1);
-		} while (time_before(jiffies, timeout));
-
-		printk(KERN_ERR "%s: reading: No DRQ and not "
-				"waiting - Odd!\n", drive->name);
-		return ide_stopped;
-	} else {
-		HWIF(drive)->OUTB(PROMISE_WRITE, IDE_COMMAND_REG);
-		if (ide_wait_stat(&startstop, drive, DATA_READY,
-				drive->bad_wstat, WAIT_DRQ)) {
-			printk(KERN_ERR "%s: no DRQ after issuing "
-				"PROMISE_WRITE\n", drive->name);
-			return startstop;
-	    	}
-		if (!drive->unmask)
-			local_irq_disable();
-		HWGROUP(drive)->wrq = *rq; /* scratchpad */
-		return promise_write(drive);
-	}
-}
-
-static ide_startstop_t promise_rw_disk (ide_drive_t *drive, struct request *rq, sector_t block)
-{
-	/* The four drives on the two logical (one physical) interfaces
-	   are distinguished by writing the drive number (0-3) to the
-	   Feature register.
-	   FIXME: Is promise_selectproc now redundant??
-	*/
-	ide_hwif_t *hwif = HWIF(drive);
-	int drive_number = (hwif->channel << 1) + drive->select.b.unit;
-
-	BUG_ON(rq->nr_sectors > 127);
-
-	if (IDE_CONTROL_REG)
-		hwif->OUTB(drive->ctl, IDE_CONTROL_REG);
-	hwif->OUTB(drive_number, IDE_FEATURE_REG);
-	hwif->OUTB(rq->nr_sectors, IDE_NSECTOR_REG);
-	hwif->OUTB(block,IDE_SECTOR_REG);
-	hwif->OUTB(block>>=8,IDE_LCYL_REG);
-	hwif->OUTB(block>>=8,IDE_HCYL_REG);
-	hwif->OUTB(((block>>8)&0x0f)|drive->select.all,IDE_SELECT_REG);
-
-	return do_pdc4030_io(drive, rq);
-}
diff -Nru a/drivers/ide/legacy/pdc4030.h b/drivers/ide/legacy/pdc4030.h
--- a/drivers/ide/legacy/pdc4030.h	2004-10-10 23:09:59 -07:00
+++ /dev/null	Wed Dec 31 16:00:00 196900
@@ -1,70 +0,0 @@
-/*
- *  linux/drivers/ide/legacy/pdc4030.h
- *
- *  Copyright (C) 1995-1998  Linus Torvalds & authors
- */
-
-/*
- * Principal author: Peter Denison <peterd@pnd-pc.demon.co.uk>
- */
-
-#ifndef IDE_PROMISE_H
-#define IDE_PROMISE_H
-
-#include <linux/config.h>
-
-#ifndef CONFIG_BLK_DEV_PDC4030
-# ifdef _IDE_DISK
-
-# define IS_PDC4030_DRIVE (0)	/* auto-NULLs out pdc4030 code */
-
-ide_startstop_t promise_rw_disk(ide_drive_t *, struct request *, unsigned long);
-
-ide_startstop_t promise_rw_disk(ide_drive_t *drive, struct request *rq, unsigned long block)
-{
-        return ide_stopped;
-}
-# endif /* _IDE_DISK */
-#else /* CONFIG_BLK_DEV_PDC4030 */
-# ifdef _IDE_DISK
-#  define IS_PDC4030_DRIVE (HWIF(drive)->chipset == ide_pdc4030)
-
-ide_startstop_t promise_rw_disk(ide_drive_t *, struct request *, unsigned long);
-
-# endif /* _IDE_DISK */
-#endif /* CONFIG_BLK_DEV_PDC4030 */
-
-#ifdef __PROMISE_4030
-#define	PROMISE_EXTENDED_COMMAND	0xF0
-#define	PROMISE_READ			0xF2
-#define	PROMISE_WRITE			0xF3
-/* Extended commands - main command code = 0xf0 */
-#define	PROMISE_GET_CONFIG		0x10
-#define	PROMISE_IDENTIFY		0x20
-
-struct translation_mode {
-	u16	cyl;
-	u8	head;
-	u8	sect;
-};
-
-struct dc_ident {
-	u8	type;
-	u8	unknown1;
-	u8	hw_revision;
-	u8	firmware_major;
-	u8	firmware_minor;
-	u8	bios_address;
-	u8	irq;
-	u8	unknown2;
-	u16	cache_mem;
-	u16	unknown3;
-	u8	id[2];
-	u16	info;
-	struct translation_mode current_tm[4];
-	u8	pad[SECTOR_WORDS*4 - 32];
-};
-
-#endif /* __PROMISE_4030 */
-
-#endif /* IDE_PROMISE_H */
diff -Nru a/drivers/ide/pci/aec62xx.c b/drivers/ide/pci/aec62xx.c
--- a/drivers/ide/pci/aec62xx.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/pci/aec62xx.c	2004-10-10 23:09:59 -07:00
@@ -18,52 +18,7 @@
 
 #include "aec62xx.h"
 
-#if defined(DISPLAY_AEC62XX_TIMINGS) && defined(CONFIG_PROC_FS)
-#include <linux/stat.h>
-#include <linux/proc_fs.h>
-
-static u8 aec62xx_proc = 0;
-
-#define AEC_MAX_DEVS		5
-
-static struct pci_dev *aec_devs[AEC_MAX_DEVS];
-static int n_aec_devs;
-
-static int aec62xx_get_info (char *buffer, char **addr, off_t offset, int count)
-{
-	char *p = buffer;
-	char *chipset_nums[] = {"error", "error", "error", "error",
-				"error", "error", "850UF",   "860",
-				 "860R",   "865",  "865R", "error"  };
-	int len;
-	int i;
-
-	for (i = 0; i < n_aec_devs; i++) {
-		struct pci_dev *dev	= aec_devs[i];
-		unsigned long iobase = pci_resource_start(dev, 4);
-		u8 c0 = 0, c1 = 0, art	= 0;
-
-		c0 = inb(iobase + 0x02);
-		c1 = inb(iobase + 0x0a);
-
-		p += sprintf(p, "\nController: %d\n", i);
-		p += sprintf(p, "Chipset: AEC%s\n", chipset_nums[dev->device]);
-
-		p += sprintf(p, "--------------- Primary Channel "
-				"---------------- Secondary Channel "
-				"-------------\n");
-		(void) pci_read_config_byte(dev, 0x4a, &art);
-		p += sprintf(p, "                %sabled ",
-			(art&0x02)?" en":"dis");
-		p += sprintf(p, "                        %sabled\n",
-			(art&0x04)?" en":"dis");
-		p += sprintf(p, "--------------- drive0 --------- drive1 "
-				"-------- drive0 ---------- drive1 ------\n");
-		p += sprintf(p, "DMA enabled:    %s              %s ",
-			(c0&0x20)?"yes":"no ",(c0&0x40)?"yes":"no ");
-		p += sprintf(p, "            %s               %s\n",
-			(c1&0x20)?"yes":"no ",(c1&0x40)?"yes":"no ");
-
+#if 0
 		if (dev->device == PCI_DEVICE_ID_ARTOP_ATP850UF) {
 			(void) pci_read_config_byte(dev, 0x54, &art);
 			p += sprintf(p, "DMA Mode:       %s(%s)",
@@ -79,59 +34,7 @@
 				(c1&0x40)?((art&0xc0)?"UDMA":" DMA"):" PIO",
 				(art&0x80)?"2":(art&0x40)?"1":"0");
 		} else {
-			/*
-			 * case PCI_DEVICE_ID_ARTOP_ATP860:
-			 * case PCI_DEVICE_ID_ARTOP_ATP860R:
-			 * case PCI_DEVICE_ID_ARTOP_ATP865:
-			 * case PCI_DEVICE_ID_ARTOP_ATP865R:
-			 */
-			(void) pci_read_config_byte(dev, 0x44, &art);
-			p += sprintf(p, "DMA Mode:       %s(%s)",
-				(c0&0x20)?((art&0x07)?"UDMA":" DMA"):" PIO",
-				((art&0x07)==0x07)?"6":
-				((art&0x06)==0x06)?"5":
-				((art&0x05)==0x05)?"4":
-				((art&0x04)==0x04)?"3":
-				((art&0x03)==0x03)?"2":
-				((art&0x02)==0x02)?"1":
-				((art&0x01)==0x01)?"0":"?");
-			p += sprintf(p, "          %s(%s)",
-				(c0&0x40)?((art&0x70)?"UDMA":" DMA"):" PIO",
-				((art&0x70)==0x70)?"6":
-				((art&0x60)==0x60)?"5":
-				((art&0x50)==0x50)?"4":
-				((art&0x40)==0x40)?"3":
-				((art&0x30)==0x30)?"2":
-				((art&0x20)==0x20)?"1":
-				((art&0x10)==0x10)?"0":"?");
-			(void) pci_read_config_byte(dev, 0x45, &art);
-			p += sprintf(p, "         %s(%s)",
-				(c1&0x20)?((art&0x07)?"UDMA":" DMA"):" PIO",
-				((art&0x07)==0x07)?"6":
-				((art&0x06)==0x06)?"5":
-				((art&0x05)==0x05)?"4":
-				((art&0x04)==0x04)?"3":
-				((art&0x03)==0x03)?"2":
-				((art&0x02)==0x02)?"1":
-				((art&0x01)==0x01)?"0":"?");
-			p += sprintf(p, "           %s(%s)\n",
-				(c1&0x40)?((art&0x70)?"UDMA":" DMA"):" PIO",
-				((art&0x70)==0x70)?"6":
-				((art&0x60)==0x60)?"5":
-				((art&0x50)==0x50)?"4":
-				((art&0x40)==0x40)?"3":
-				((art&0x30)==0x30)?"2":
-				((art&0x20)==0x20)?"1":
-				((art&0x10)==0x10)?"0":"?");
-		}
-	}
-	/* p - buffer must be less than 4k! */
-	len = (p - buffer) - offset;
-	*addr = buffer + offset;
-	
-	return len > count ? count : len;
-}
-#endif	/* defined(DISPLAY_AEC62xx_TIMINGS) && defined(CONFIG_PROC_FS) */
+#endif
 
 /*
  * TO DO: active tuning and correction of cards without a bios.
@@ -286,36 +189,16 @@
 	struct hd_driveid *id	= drive->id;
 
 	if ((id->capability & 1) && drive->autodma) {
-		/* Consult the list of known "bad" drives */
-		if (__ide_dma_bad_drive(drive))
-			goto fast_ata_pio;
-		if (id->field_valid & 4) {
-			if (id->dma_ultra & hwif->ultra_mask) {
-				/* Force if Capable UltraDMA */
-				int dma = config_chipset_for_dma(drive);
-				if ((id->field_valid & 2) && !dma)
-					goto try_dma_modes;
-			}
-		} else if (id->field_valid & 2) {
-try_dma_modes:
-			if ((id->dma_mword & hwif->mwdma_mask) ||
-			    (id->dma_1word & hwif->swdma_mask)) {
-				/* Force if Capable regular DMA modes */
-				if (!config_chipset_for_dma(drive))
-					goto no_dma_set;
-			}
-		} else if (__ide_dma_good_drive(drive) &&
-			   (id->eide_dma_time < 150)) {
-			/* Consult the list of known "good" drives */
-			if (!config_chipset_for_dma(drive))
-				goto no_dma_set;
-		} else {
-			goto fast_ata_pio;
+
+		if (ide_use_dma(drive)) {
+			if (config_chipset_for_dma(drive))
+				return hwif->ide_dma_on(drive);
 		}
-		return hwif->ide_dma_on(drive);
+
+		goto fast_ata_pio;
+
 	} else if ((id->capability & 8) || (id->field_valid & 2)) {
 fast_ata_pio:
-no_dma_set:
 		aec62xx_tune_drive(drive, 5);
 		return hwif->ide_dma_off_quietly(drive);
 	}
@@ -374,15 +257,6 @@
 		pci_write_config_dword(dev, PCI_ROM_ADDRESS, dev->resource[PCI_ROM_RESOURCE].start | PCI_ROM_ADDRESS_ENABLE);
 		printk(KERN_INFO "%s: ROM enabled at 0x%08lx\n", name, dev->resource[PCI_ROM_RESOURCE].start);
 	}
-
-#if defined(DISPLAY_AEC62XX_TIMINGS) && defined(CONFIG_PROC_FS)
-	aec_devs[n_aec_devs++] = dev;
-
-	if (!aec62xx_proc) {
-		aec62xx_proc = 1;
-		ide_pci_create_host_proc("aec62xx", aec62xx_get_info);
-	}
-#endif /* DISPLAY_AEC62XX_TIMINGS && CONFIG_PROC_FS */
 
 	if (bus_speed <= 33)
 		pci_set_drvdata(dev, (void *) aec6xxx_33_base);
diff -Nru a/drivers/ide/pci/aec62xx.h b/drivers/ide/pci/aec62xx.h
--- a/drivers/ide/pci/aec62xx.h	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/pci/aec62xx.h	2004-10-10 23:09:59 -07:00
@@ -5,8 +5,6 @@
 #include <linux/pci.h>
 #include <linux/ide.h>
 
-#define DISPLAY_AEC62XX_TIMINGS
-
 struct chipset_bus_clock_list_entry {
 	byte		xfer_speed;
 	byte		chipset_settings;
diff -Nru a/drivers/ide/pci/alim15x3.c b/drivers/ide/pci/alim15x3.c
--- a/drivers/ide/pci/alim15x3.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/pci/alim15x3.c	2004-10-10 23:09:59 -07:00
@@ -558,18 +558,19 @@
 }
 
 /**
- *	ali15x3_dma_write	-	do a DMA IDE write
- *	@drive:	drive to issue write for
+ *	ali15x3_dma_setup	-	begin a DMA phase
+ *	@drive:	target device
  *
- *	Returns 1 if the DMA write cannot be performed, zero on 
- *	success.
+ *	Returns 1 if the DMA cannot be performed, zero on success.
  */
- 
-static int ali15x3_dma_write (ide_drive_t *drive)
+
+static int ali15x3_dma_setup(ide_drive_t *drive)
 {
-	if ((m5229_revision < 0xC2) && (drive->media != ide_disk))
-		return 1;	/* try PIO instead of DMA */
-	return __ide_dma_write(drive);
+	if (m5229_revision < 0xC2 && drive->media != ide_disk) {
+		if (rq_data_dir(drive->hwif->hwgroup->rq))
+			return 1;	/* try PIO instead of DMA */
+	}
+	return ide_dma_setup(drive);
 }
 
 /**
@@ -773,7 +774,7 @@
                  * M1543C or newer for DMAing
                  */
                 hwif->ide_dma_check = &ali15x3_config_drive_for_dma;
-                hwif->ide_dma_write = &ali15x3_dma_write;
+		hwif->dma_setup = &ali15x3_dma_setup;
 		if (!noautodma)
 			hwif->autodma = 1;
 		if (!(hwif->udma_four))
diff -Nru a/drivers/ide/pci/atiixp.c b/drivers/ide/pci/atiixp.c
--- a/drivers/ide/pci/atiixp.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/pci/atiixp.c	2004-10-10 23:09:59 -07:00
@@ -47,102 +47,6 @@
 
 static int save_mdma_mode[4];
 
-#define DISPLAY_ATIIXP_TIMINGS
-
-#if defined(DISPLAY_ATIIXP_TIMINGS) && defined(CONFIG_PROC_FS)
-
-#include <linux/stat.h>
-#include <linux/proc_fs.h>
-
-static u8 atiixp_proc;
-static struct pci_dev *bmide_dev;
-
-/**
- *	atiixp_get_info		-	fill in /proc for ATIIXP IDE
- *	@buffer: buffer to fill
- *	@addr: address of user start in buffer
- *	@offset: offset into 'file'
- *	@count: buffer count
- *
- *	Output summary data on the tuning.
- */
-
-static int atiixp_get_info(char *buffer, char **addr, off_t offset, int count)
-{
-	char *p = buffer;
-	struct pci_dev *dev = bmide_dev;
-	unsigned long bibma = pci_resource_start(dev, 4);
-	u32 mdma_timing = 0;
-	u16 udma_mode = 0, pio_mode = 0;
-	u8 c0, c1, udma_control = 0;
-
-	p += sprintf(p, "\n                          ATI ");
-	p += sprintf(p, "ATIIXP Ultra100 IDE Chipset.\n");
-
-	pci_read_config_byte(dev, ATIIXP_IDE_UDMA_CONTROL, &udma_control);
-	pci_read_config_word(dev, ATIIXP_IDE_UDMA_MODE, &udma_mode);
-	pci_read_config_word(dev, ATIIXP_IDE_PIO_MODE, &pio_mode);
-	pci_read_config_dword(dev, ATIIXP_IDE_MDMA_TIMING, &mdma_timing);
-
-	/*
-	 * at that point bibma+0x2 et bibma+0xa are byte registers
-	 * to investigate:
-	 */
-	c0 = inb(bibma + 0x02);
-	c1 = inb(bibma + 0x0a);
-
-	p += sprintf(p, "--------------- Primary Channel "
-			"---------------- Secondary Channel "
-			"-------------\n");
-	p += sprintf(p, "                %sabled "
-			"                        %sabled\n",
-			(c0 & 0x80) ? "dis" : " en",
-			(c1 & 0x80) ? "dis" : " en");
-	p += sprintf(p, "--------------- drive0 --------- drive1 "
-			"-------- drive0 ---------- drive1 ------\n");
-	p += sprintf(p, "DMA enabled:    %s              %s "
-			"            %s               %s\n",
-			(c0 & 0x20) ? "yes" : "no ",
-			(c0 & 0x40) ? "yes" : "no ",
-			(c1 & 0x20) ? "yes" : "no ",
-			(c1 & 0x40) ? "yes" : "no " );
-	p += sprintf(p, "UDMA enabled:   %s              %s "
-			"            %s               %s\n",
-			(udma_control & 0x01) ? "yes" : "no ",
-			(udma_control & 0x02) ? "yes" : "no ",
-			(udma_control & 0x04) ? "yes" : "no ",
-			(udma_control & 0x08) ? "yes" : "no " );
-	p += sprintf(p, "UDMA mode:      %c                %c "
-			"              %c                 %c\n",
-			(udma_control & 0x01) ?
-			((udma_mode & 0x07) + 48) : 'X',
-			(udma_control & 0x02) ?
-			(((udma_mode >> 4) & 0x07) + 48) : 'X',
-			(udma_control & 0x04) ?
-			(((udma_mode >> 8) & 0x07) + 48) : 'X',
-			(udma_control & 0x08) ?
-			(((udma_mode >> 12) & 0x07) + 48) : 'X');
-	p += sprintf(p, "MDMA mode:      %c                %c "
-			"              %c                 %c\n",
-			(save_mdma_mode[0] && (c0 & 0x20)) ?
-			((save_mdma_mode[0] & 0xf) + 48) : 'X',
-			(save_mdma_mode[1] && (c0 & 0x40)) ?
-			((save_mdma_mode[1] & 0xf) + 48) : 'X',
-			(save_mdma_mode[2] && (c1 & 0x20)) ?
-			((save_mdma_mode[2] & 0xf) + 48) : 'X',
-			(save_mdma_mode[3] && (c1 & 0x40)) ?
-			((save_mdma_mode[3] & 0xf) + 48) : 'X');
-	p += sprintf(p, "PIO mode:       %c                %c "
-			"              %c                 %c\n",
-			(c0 & 0x20) ? 'X' : ((pio_mode & 0x07) + 48),
-			(c0 & 0x40) ? 'X' : (((pio_mode >> 4) & 0x07) + 48),
-			(c1 & 0x20) ? 'X' : (((pio_mode >> 8) & 0x07) + 48),
-			(c1 & 0x40) ? 'X' : (((pio_mode >> 12) & 0x07) + 48));
-
-	return p - buffer;	/* => must be less than 4k! */
-}
-#endif  /* defined(DISPLAY_ATIIXP_TIMINGS) && defined(CONFIG_PROC_FS) */
-
 /**
  *	atiixp_ratemask		-	compute rate mask for ATIIXP IDE
  *	@drive: IDE drive to compute for
@@ -331,10 +235,8 @@
 	u8 speed = ide_dma_speed(drive, atiixp_ratemask(drive));
 
 	/* If no DMA speed was available then disable DMA and use PIO. */
-	if (!speed) {
-		u8 tspeed = ide_get_best_pio_mode(drive, 255, 5, NULL);
-		speed = atiixp_dma_2_pio(XFER_PIO_0 + tspeed) + XFER_PIO_0;
-	}
+	if (!speed)
+		return 0;
 
 	(void) atiixp_speedproc(drive, speed);
 	return ide_dma_enable(drive);
@@ -357,36 +259,16 @@
 	drive->init_speed = 0;
 
 	if ((id->capability & 1) && drive->autodma) {
-		/* Consult the list of known "bad" drives */
-		if (__ide_dma_bad_drive(drive))
-			goto fast_ata_pio;
-		if (id->field_valid & 4) {
-			if (id->dma_ultra & hwif->ultra_mask) {
-				/* Force if Capable UltraDMA */
-				if ((id->field_valid & 2) &&
-				    (!atiixp_config_drive_for_dma(drive)))
-					goto try_dma_modes;
-			}
-		} else if (id->field_valid & 2) {
-try_dma_modes:
-			if ((id->dma_mword & hwif->mwdma_mask) ||
-			    (id->dma_1word & hwif->swdma_mask)) {
-				/* Force if Capable regular DMA modes */
-				if (!atiixp_config_drive_for_dma(drive))
-					goto no_dma_set;
-			}
-		} else if (__ide_dma_good_drive(drive) &&
-			   (id->eide_dma_time < 150)) {
-			/* Consult the list of known "good" drives */
-			if (!atiixp_config_drive_for_dma(drive))
-				goto no_dma_set;
-		} else {
-			goto fast_ata_pio;
+
+		if (ide_use_dma(drive)) {
+			if (atiixp_config_drive_for_dma(drive))
+				return hwif->ide_dma_on(drive);
 		}
-		return hwif->ide_dma_on(drive);
+
+		goto fast_ata_pio;
+
 	} else if ((id->capability & 8) || (id->field_valid & 2)) {
 fast_ata_pio:
-no_dma_set:
 		tspeed = ide_get_best_pio_mode(drive, 255, 5, NULL);
 		speed = atiixp_dma_2_pio(XFER_PIO_0 + tspeed) + XFER_PIO_0;
 		hwif->speedproc(drive, speed);
@@ -397,27 +279,6 @@
 }
 
 /**
- *	init_chipset_atiixp	-	set up the ATIIXP chipset
- *	@dev: PCI device to set up
- *	@name: Name of the device
- *
- *	Initialize the PCI device as required. For the ATIIXP this turns
- *	out to be nice and simple
- */
-
-static unsigned int __devinit init_chipset_atiixp(struct pci_dev *dev, const char *name)
-{
-#if defined(DISPLAY_ATIIXP_TIMINGS) && defined(CONFIG_PROC_FS)
-	if (!atiixp_proc) {
-		atiixp_proc = 1;
-		bmide_dev = dev;
-		ide_pci_create_host_proc("atiixp", atiixp_get_info);
-	}
-#endif /* DISPLAY_ATIIXP_TIMINGS && CONFIG_PROC_FS */
-	return 0;
-}
-
-/**
  *	init_hwif_atiixp		-	fill in the hwif for the ATIIXP
  *	@hwif: IDE interface
  *
@@ -459,7 +320,6 @@
 static ide_pci_device_t atiixp_pci_info[] __devinitdata = {
 	{	/* 0 */
 		.name		= "ATIIXP",
-		.init_chipset	= init_chipset_atiixp,
 		.init_hwif	= init_hwif_atiixp,
 		.channels	= 2,
 		.autodma	= AUTODMA,
diff -Nru a/drivers/ide/pci/cmd64x.c b/drivers/ide/pci/cmd64x.c
--- a/drivers/ide/pci/cmd64x.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/pci/cmd64x.c	2004-10-10 23:09:59 -07:00
@@ -441,36 +441,16 @@
 	struct hd_driveid *id	= drive->id;
 
 	if ((id != NULL) && ((id->capability & 1) != 0) && drive->autodma) {
-		/* Consult the list of known "bad" drives */
-		if (__ide_dma_bad_drive(drive))
-			goto fast_ata_pio;
-		if ((id->field_valid & 4) && cmd64x_ratemask(drive)) {
-			if (id->dma_ultra & hwif->ultra_mask) {
-				/* Force if Capable UltraDMA */
-				int dma = config_chipset_for_dma(drive);
-				if ((id->field_valid & 2) && !dma)
-					goto try_dma_modes;
-			}
-		} else if (id->field_valid & 2) {
-try_dma_modes:
-			if ((id->dma_mword & hwif->mwdma_mask) ||
-			    (id->dma_1word & hwif->swdma_mask)) {
-				/* Force if Capable regular DMA modes */
-				if (!config_chipset_for_dma(drive))
-					goto no_dma_set;
-			}
-		} else if (__ide_dma_good_drive(drive) &&
-			   (id->eide_dma_time < 150)) {
-			/* Consult the list of known "good" drives */
-			if (!config_chipset_for_dma(drive))
-				goto no_dma_set;
-		} else {
-			goto fast_ata_pio;
+
+		if (ide_use_dma(drive)) {
+			if (config_chipset_for_dma(drive))
+				return hwif->ide_dma_on(drive);
 		}
-		return hwif->ide_dma_on(drive);
+
+		goto fast_ata_pio;
+
 	} else if ((id->capability & 8) || (id->field_valid & 2)) {
 fast_ata_pio:
-no_dma_set:
 		config_chipset_for_pio(drive, 1);
 		return hwif->ide_dma_off_quietly(drive);
 	}
diff -Nru a/drivers/ide/pci/cs5520.c b/drivers/ide/pci/cs5520.c
--- a/drivers/ide/pci/cs5520.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/pci/cs5520.c	2004-10-10 23:09:59 -07:00
@@ -51,57 +51,6 @@
 #include <asm/io.h>
 #include <asm/irq.h>
 
-#define DISPLAY_CS5520_TIMINGS
-
-#if defined(DISPLAY_CS5520_TIMINGS) && defined(CONFIG_PROC_FS)
-#include <linux/stat.h>
-#include <linux/proc_fs.h>
-
-static u8 cs5520_proc = 0;
-static struct pci_dev *bmide_dev;
-
-static int cs5520_get_info(char *buffer, char **addr, off_t offset, int count)
-{
-	char *p = buffer;
-	unsigned long bmiba = pci_resource_start(bmide_dev, 2);
-	int len;
-	u8 c0 = 0, c1 = 0;
-	u16 reg16;
-	u32 reg32;
-
-	/*
-	 * at that point bibma+0x2 et bibma+0xa are byte registers
-	 * to investigate:
-	 */
-	c0 = inb(bmiba + 0x02);
-	c1 = inb(bmiba + 0x0a);
-	
-	p += sprintf(p, "\nCyrix CS55x0 IDE\n");
-	p += sprintf(p, "--------------- Primary Channel "
-			"---------------- Secondary Channel "
-			"-------------\n");
-	p += sprintf(p, "                %sabled "
-			"                        %sabled\n",
-			(c0&0x80) ? "dis" : " en",
-			(c1&0x80) ? "dis" : " en");
-			
-	p += sprintf(p, "\n\nTimings: \n");
-	
-	pci_read_config_word(bmide_dev, 0x62, &reg16);
-	p += sprintf(p, "8bit CAT/CRT   : %04x\n", reg16);
-	pci_read_config_dword(bmide_dev, 0x64, &reg32);
-	p += sprintf(p, "16bit Primary  : %08x\n", reg32);
-	pci_read_config_dword(bmide_dev, 0x68, &reg32);
-	p += sprintf(p, "16bit Secondary: %08x\n", reg32);
-	
-	len = (p - buffer) - offset;
-	*addr = buffer + offset;
-	
-	return len > count ? count : len;
-}
-
-#endif
-
 struct pio_clocks
 {
 	int address;
@@ -144,12 +93,14 @@
 	printk("PIO clocking = %d\n", pio);
 	
 	/* FIXME: if DMA = 1 do we need to set the DMA bit here ? */
-	
-	/* 8bit command timing for channel */
+
+	/* 8bit CAT/CRT - 8bit command timing for channel */
 	pci_write_config_byte(pdev, 0x62 + controller, 
 		(cs5520_pio_clocks[pio].recovery << 4) |
 		(cs5520_pio_clocks[pio].assert));
-		
+
+	/* 0x64 - 16bit Primary, 0x68 - 16bit Secondary */
+
 	/* FIXME: should these use address ? */
 	/* Data read timing */
 	pci_write_config_byte(pdev, 0x64 + 4*controller + (drive->dn&1),
@@ -188,19 +139,6 @@
 	/* Then tell the core to use DMA operations */
 	return hwif->ide_dma_on(drive);
 }
-	
-	
-static unsigned int __devinit init_chipset_cs5520(struct pci_dev *dev, const char *name)
-{
-#if defined(DISPLAY_CS5520_TIMINGS) && defined(CONFIG_PROC_FS)
-	if (!cs5520_proc) {
-		cs5520_proc = 1;
-		bmide_dev = dev;
-		ide_pci_create_host_proc("cs5520", cs5520_get_info);
-	}
-#endif /* DISPLAY_CS5520_TIMINGS && CONFIG_PROC_FS */
-	return 0;
-}
 
 /*
  *	We provide a callback for our nonstandard DMA location
@@ -255,7 +193,6 @@
 #define DECLARE_CS_DEV(name_str)				\
 	{							\
 		.name		= name_str,			\
-		.init_chipset	= init_chipset_cs5520,		\
 		.init_setup_dma = cs5520_init_setup_dma,	\
 		.init_hwif	= init_hwif_cs5520,		\
 		.channels	= 2,				\
@@ -294,7 +231,6 @@
 		printk(KERN_WARNING "cs5520: No suitable DMA available.\n");
 		return -ENODEV;
 	}
-	init_chipset_cs5520(dev, d->name);
 
 	index.all = 0xf0f0;
 
@@ -303,7 +239,7 @@
 	 *	do all the device setup for us
 	 */
 
-	ide_pci_setup_ports(dev, d, 1, 14, &index);
+	ide_pci_setup_ports(dev, d, 14, &index);
 
 	printk("Index.b %d %d\n", index.b.low, index.b.high);
 	mdelay(2000);
diff -Nru a/drivers/ide/pci/cs5530.c b/drivers/ide/pci/cs5530.c
--- a/drivers/ide/pci/cs5530.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/pci/cs5530.c	2004-10-10 23:09:59 -07:00
@@ -31,56 +31,6 @@
 #include <asm/io.h>
 #include <asm/irq.h>
 
-#define DISPLAY_CS5530_TIMINGS
-
-#if defined(DISPLAY_CS5530_TIMINGS) && defined(CONFIG_PROC_FS)
-#include <linux/stat.h>
-#include <linux/proc_fs.h>
-
-static u8 cs5530_proc = 0;
-
-static struct pci_dev *bmide_dev;
-
-static int cs5530_get_info (char *buffer, char **addr, off_t offset, int count)
-{
-	char *p = buffer;
-	unsigned long bibma = pci_resource_start(bmide_dev, 4);
-	u8  c0 = 0, c1 = 0;
-
-	/*
-	 * at that point bibma+0x2 et bibma+0xa are byte registers
-	 * to investigate:
-	 */
-
-	c0 = inb_p((u16)bibma + 0x02);
-	c1 = inb_p((u16)bibma + 0x0a);
-
-	p += sprintf(p, "\n                                "
-			"Cyrix 5530 Chipset.\n");
-	p += sprintf(p, "--------------- Primary Channel "
-			"---------------- Secondary Channel "
-			"-------------\n");
-	p += sprintf(p, "                %sabled "
-			"                        %sabled\n",
-			(c0&0x80) ? "dis" : " en",
-			(c1&0x80) ? "dis" : " en");
-	p += sprintf(p, "--------------- drive0 --------- drive1 "
-			"-------- drive0 ---------- drive1 ------\n");
-	p += sprintf(p, "DMA enabled:    %s              %s "
-			"            %s               %s\n",
-			(c0&0x20) ? "yes" : "no ",
-			(c0&0x40) ? "yes" : "no ",
-			(c1&0x20) ? "yes" : "no ",
-			(c1&0x40) ? "yes" : "no " );
-
-	p += sprintf(p, "UDMA\n");
-	p += sprintf(p, "DMA\n");
-	p += sprintf(p, "PIO\n");
-
-	return p-buffer;
-}
-#endif /* DISPLAY_CS5530_TIMINGS && CONFIG_PROC_FS */
-
 /**
  *	cs5530_xfer_set_mode	-	set a new transfer mode at the drive
  *	@drive: drive to tune
@@ -272,14 +222,6 @@
 	struct pci_dev *master_0 = NULL, *cs5530_0 = NULL;
 	unsigned long flags;
 
-#if defined(DISPLAY_CS5530_TIMINGS) && defined(CONFIG_PROC_FS)
-	if (!cs5530_proc) {
-		cs5530_proc = 1;
-		bmide_dev = dev;
-		ide_pci_create_host_proc("cs5530", cs5530_get_info);
-	}
-#endif /* DISPLAY_CS5530_TIMINGS && CONFIG_PROC_FS */
-
 	dev = NULL;
 	while ((dev = pci_find_device(PCI_VENDOR_ID_CYRIX, PCI_ANY_ID, dev)) != NULL) {
 		switch (dev->device) {
@@ -411,7 +353,6 @@
 	.channels	= 2,
 	.autodma	= AUTODMA,
 	.bootable	= ON_BOARD,
-	.flags		= IDEPCI_FLAG_FORCE_MASTER,
 };
 
 static int __devinit cs5530_init_one(struct pci_dev *dev, const struct pci_device_id *id)
diff -Nru a/drivers/ide/pci/hpt34x.c b/drivers/ide/pci/hpt34x.c
--- a/drivers/ide/pci/hpt34x.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/pci/hpt34x.c	2004-10-10 23:09:59 -07:00
@@ -42,7 +42,7 @@
 #include <asm/io.h>
 #include <asm/irq.h>
 
-#include "hpt34x.h"
+#define HPT343_DEBUG_DRIVE_INFO		0
 
 static u8 hpt34x_ratemask (ide_drive_t *drive)
 {
@@ -69,7 +69,8 @@
 	u32 reg1= 0, tmp1 = 0, reg2 = 0, tmp2 = 0;
 	u8			hi_speed, lo_speed;
 
-	SPLIT_BYTE(speed, hi_speed, lo_speed);
+	hi_speed = speed >> 4;
+	lo_speed = speed & 0x0f;
 
 	if (hi_speed & 7) {
 		hi_speed = (hi_speed & 4) ? 0x01 : 0x10;
@@ -130,40 +131,20 @@
 	drive->init_speed = 0;
 
 	if (id && (id->capability & 1) && drive->autodma) {
-		/* Consult the list of known "bad" drives */
-		if (__ide_dma_bad_drive(drive))
-			goto fast_ata_pio;
-		if (id->field_valid & 4) {
-			if (id->dma_ultra & hwif->ultra_mask) {
-				/* Force if Capable UltraDMA */
-				int dma = config_chipset_for_dma(drive);
-				if ((id->field_valid & 2) && dma)
-					goto try_dma_modes;
-			}
-		} else if (id->field_valid & 2) {
-try_dma_modes:
-			if ((id->dma_mword & hwif->mwdma_mask) ||
-			    (id->dma_1word & hwif->swdma_mask)) {
-				/* Force if Capable regular DMA modes */
-				if (!config_chipset_for_dma(drive))
-					goto no_dma_set;
-			}
-		} else if (__ide_dma_good_drive(drive) &&
-			   (id->eide_dma_time < 150)) {
-			/* Consult the list of known "good" drives */
-			if (!config_chipset_for_dma(drive))
-				goto no_dma_set;
-		} else {
-			goto fast_ata_pio;
-		}
+
+		if (ide_use_dma(drive)) {
+			if (config_chipset_for_dma(drive))
 #ifndef CONFIG_HPT34X_AUTODMA
-		return hwif->ide_dma_off_quietly(drive);
+				return hwif->ide_dma_off_quietly(drive);
 #else
-		return hwif->ide_dma_on(drive);
+				return hwif->ide_dma_on(drive);
 #endif
+		}
+
+		goto fast_ata_pio;
+
 	} else if ((id->capability & 8) || (id->field_valid & 2)) {
 fast_ata_pio:
-no_dma_set:
 		hpt34x_tune_drive(drive, 255);
 		return hwif->ide_dma_off_quietly(drive);
 	}
@@ -249,9 +230,19 @@
 	hwif->drives[1].autodma = hwif->autodma;
 }
 
+static ide_pci_device_t hpt34x_chipset __devinitdata = {
+	.name		= "HPT34X",
+	.init_chipset	= init_chipset_hpt34x,
+	.init_hwif	= init_hwif_hpt34x,
+	.channels	= 2,
+	.autodma	= NOAUTODMA,
+	.bootable	= NEVER_BOARD,
+	.extra		= 16
+};
+
 static int __devinit hpt34x_init_one(struct pci_dev *dev, const struct pci_device_id *id)
 {
-	ide_pci_device_t *d = &hpt34x_chipsets[id->driver_data];
+	ide_pci_device_t *d = &hpt34x_chipset;
 	static char *chipset_names[] = {"HPT343", "HPT345"};
 	u16 pcicmd = 0;
 
diff -Nru a/drivers/ide/pci/hpt34x.h b/drivers/ide/pci/hpt34x.h
--- a/drivers/ide/pci/hpt34x.h	2004-10-10 23:09:59 -07:00
+++ /dev/null	Wed Dec 31 16:00:00 196900
@@ -1,29 +0,0 @@
-#ifndef HPT34X_H
-#define HPT34X_H
-
-#include <linux/config.h>
-#include <linux/pci.h>
-#include <linux/ide.h>
-
-#define HPT343_DEBUG_DRIVE_INFO		0
-
-#ifndef SPLIT_BYTE
-#define SPLIT_BYTE(B,H,L)	((H)=(B>>4), (L)=(B-((B>>4)<<4)))
-#endif
-
-static unsigned int init_chipset_hpt34x(struct pci_dev *, const char *);
-static void init_hwif_hpt34x(ide_hwif_t *);
-
-static ide_pci_device_t hpt34x_chipsets[] __devinitdata = {
-	{	/* 0 */
-		.name		= "HPT34X",
-		.init_chipset	= init_chipset_hpt34x,
-		.init_hwif	= init_hwif_hpt34x,
-		.channels	= 2,
-		.autodma	= NOAUTODMA,
-		.bootable	= NEVER_BOARD,
-		.extra		= 16
-	}
-};
-
-#endif /* HPT34X_H */
diff -Nru a/drivers/ide/pci/hpt366.c b/drivers/ide/pci/hpt366.c
--- a/drivers/ide/pci/hpt366.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/pci/hpt366.c	2004-10-10 23:09:59 -07:00
@@ -72,49 +72,6 @@
 
 #include "hpt366.h"
 
-#if defined(DISPLAY_HPT366_TIMINGS) && defined(CONFIG_PROC_FS)
-#include <linux/stat.h>
-#include <linux/proc_fs.h>
-#endif  /* defined(DISPLAY_HPT366_TIMINGS) && defined(CONFIG_PROC_FS) */
-
-static unsigned int hpt_revision(struct pci_dev *dev);
-static unsigned int hpt_minimum_revision(struct pci_dev *dev, int revision);
-
-#if defined(DISPLAY_HPT366_TIMINGS) && defined(CONFIG_PROC_FS)
-
-static u8 hpt366_proc = 0;
-static struct pci_dev *hpt_devs[HPT366_MAX_DEVS];
-static int n_hpt_devs;
-
-static int hpt366_get_info (char *buffer, char **addr, off_t offset, int count)
-{
-	char *p	= buffer;
-	char *chipset_nums[] = {"366", "366",  "368",
-				"370", "370A", "372",
-				"302", "371",  "374" };
-	int i, len;
-
-	p += sprintf(p, "\n                             "
-		"HighPoint HPT366/368/370/372/374\n");
-	for (i = 0; i < n_hpt_devs; i++) {
-		struct pci_dev *dev = hpt_devs[i];
-		unsigned long iobase = dev->resource[4].start;
-		u32 class_rev = hpt_revision(dev);
-		u8 c0, c1;
-
-		p += sprintf(p, "\nController: %d\n", i);
-		p += sprintf(p, "Chipset: HPT%s\n", chipset_nums[class_rev]);
-		p += sprintf(p, "--------------- Primary Channel "
-				"--------------- Secondary Channel "
-				"--------------\n");
-
-		/* get the bus master status registers */
-		c0 = inb(iobase + 0x2);
-		c1 = inb(iobase + 0xa);
-		p += sprintf(p, "Enabled:        %s"
-				"                             %s\n",
-			(c0 & 0x80) ? "no" : "yes",
-			(c1 & 0x80) ? "no" : "yes");
 #if 0
 		if (hpt_minimum_revision(dev, 3)) {
 			u8 cbl;
@@ -128,16 +85,6 @@
 				(cbl & 0x01) ? 33 : 66);
 			p += sprintf(p, "\n");
 		}
-#endif
-		p += sprintf(p, "--------------- drive0 --------- drive1 "
-				"------- drive0 ---------- drive1 -------\n");
-		p += sprintf(p, "DMA capable:    %s              %s" 
-				"            %s               %s\n",
-			(c0 & 0x20) ? "yes" : "no ", 
-			(c0 & 0x40) ? "yes" : "no ",
-			(c1 & 0x20) ? "yes" : "no ", 
-			(c1 & 0x40) ? "yes" : "no ");
-
 		{
 			u8 c2, c3;
 			/* older revs don't have these registers mapped 
@@ -159,15 +106,7 @@
 					(c3 & 0x80) ? "PIO " : "off ");
 		}
 	}
-	p += sprintf(p, "\n");
-
-	/* p - buffer must be less than 4k! */
-	len = (p - buffer) - offset;
-	*addr = buffer + offset;
-	
-	return len > count ? count : len;
-}
-#endif  /* defined(DISPLAY_HPT366_TIMINGS) && defined(CONFIG_PROC_FS) */
+#endif
 
 static u32 hpt_revision (struct pci_dev *dev)
 {
@@ -521,35 +460,16 @@
 	drive->init_speed = 0;
 
 	if (id && (id->capability & 1) && drive->autodma) {
-		/* Consult the list of known "bad" drives */
-		if (__ide_dma_bad_drive(drive))
-			goto fast_ata_pio;
-		if (id->field_valid & 4) {
-			if (id->dma_ultra & hwif->ultra_mask) {
-				/* Force if Capable UltraDMA */
-				int dma = config_chipset_for_dma(drive);
-				if ((id->field_valid & 2) && !dma)
-					goto try_dma_modes;
-			}
-		} else if (id->field_valid & 2) {
-try_dma_modes:
-			if (id->dma_mword & hwif->mwdma_mask) {
-				/* Force if Capable regular DMA modes */
-				if (!config_chipset_for_dma(drive))
-					goto no_dma_set;
-			}
-		} else if (__ide_dma_good_drive(drive) &&
-			   (id->eide_dma_time < 150)) {
-			/* Consult the list of known "good" drives */
-			if (!config_chipset_for_dma(drive))
-				goto no_dma_set;
-		} else {
-			goto fast_ata_pio;
+
+		if (ide_use_dma(drive)) {
+			if (config_chipset_for_dma(drive))
+				return hwif->ide_dma_on(drive);
 		}
-		return hwif->ide_dma_on(drive);
+
+		goto fast_ata_pio;
+
 	} else if ((id->capability & 8) || (id->field_valid & 2)) {
 fast_ata_pio:
-no_dma_set:
 		hpt3xx_tune_drive(drive, 5);
 		return hwif->ide_dma_off_quietly(drive);
 	}
@@ -577,7 +497,7 @@
 	/* how about we flush and reset, mmmkay? */
 	pci_write_config_byte(dev, 0x51, 0x1F);
 	/* fall through to a reset */
-	case ide_dma_begin:
+	case dma_start:
 	case ide_dma_end:
 	/* reset the chips state over and over.. */
 	pci_write_config_byte(dev, 0x51, 0x13);
@@ -592,12 +512,12 @@
 	udelay(10);
 }
 
-static int hpt370_ide_dma_begin (ide_drive_t *drive)
+static void hpt370_ide_dma_start(ide_drive_t *drive)
 {
 #ifdef HPT_RESET_STATE_ENGINE
 	hpt370_clear_engine(drive);
 #endif
-	return __ide_dma_begin(drive);
+	ide_dma_start(drive);
 }
 
 static int hpt370_ide_dma_end (ide_drive_t *drive)
@@ -1105,15 +1025,6 @@
 	}
 	if (ret)
 		return ret;
-	
-#if defined(DISPLAY_HPT366_TIMINGS) && defined(CONFIG_PROC_FS)
-	hpt_devs[n_hpt_devs++] = dev;
-
-	if (!hpt366_proc) {
-		hpt366_proc = 1;
-		ide_pci_create_host_proc("hpt366", hpt366_get_info);
-	}
-#endif /* DISPLAY_HPT366_TIMINGS && CONFIG_PROC_FS */
 
 	return dev->irq;
 }
@@ -1230,7 +1141,7 @@
 		hwif->ide_dma_test_irq = &hpt374_ide_dma_test_irq;
 		hwif->ide_dma_end = &hpt374_ide_dma_end;
 	} else if (hpt_minimum_revision(dev,3)) {
-		hwif->ide_dma_begin = &hpt370_ide_dma_begin;
+		hwif->dma_start = &hpt370_ide_dma_start;
 		hwif->ide_dma_end = &hpt370_ide_dma_end;
 		hwif->ide_dma_timeout = &hpt370_ide_dma_timeout;
 		hwif->ide_dma_lostirq = &hpt370_ide_dma_lostirq;
diff -Nru a/drivers/ide/pci/hpt366.h b/drivers/ide/pci/hpt366.h
--- a/drivers/ide/pci/hpt366.h	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/pci/hpt366.h	2004-10-10 23:09:59 -07:00
@@ -5,8 +5,6 @@
 #include <linux/pci.h>
 #include <linux/ide.h>
 
-#define DISPLAY_HPT366_TIMINGS
-
 /* various tuning parameters */
 #define HPT_RESET_STATE_ENGINE
 #undef HPT_DELAY_INTERRUPT
diff -Nru a/drivers/ide/pci/it8172.c b/drivers/ide/pci/it8172.c
--- a/drivers/ide/pci/it8172.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/pci/it8172.c	2004-10-10 23:09:59 -07:00
@@ -201,36 +201,16 @@
 	drive->init_speed = 0;
 
 	if (id && (id->capability & 1) && drive->autodma) {
-		/* Consult the list of known "bad" drives */
-		if (__ide_dma_bad_drive(drive))
-			goto fast_ata_pio;
-		if (id->field_valid & 4) {
-			if (id->dma_ultra & hwif->ultra_mask) {
-				/* Force if Capable UltraDMA */
-				int dma = it8172_config_chipset_for_dma(drive);
-				if ((id->field_valid & 2) && !dma)
-					goto try_dma_modes;
-			}
-		} else if (id->field_valid & 2) {
-try_dma_modes:
-			if ((id->dma_mword & hwif->mwdma_mask) ||
-			    (id->dma_1word & hwif->swdma_mask)) {
-				/* Force if Capable regular DMA modes */
-				if (!it8172_config_chipset_for_dma(drive))
-					goto no_dma_set;
-			}
-		} else if (__ide_dma_good_drive(drive) &&
-			   (id->eide_dma_time < 150)) {
-			/* Consult the list of known "good" drives */
-			if (!it8172_config_chipset_for_dma(drive))
-				goto no_dma_set;
-		} else {
-			goto fast_ata_pio;
+
+		if (ide_use_dma(drive)) {
+			if (it8172_config_chipset_for_dma(drive))
+				return hwif->ide_dma_on(drive);
 		}
-		return hwif->ide_dma_on(drive);
+
+		goto fast_ata_pio;
+
 	} else if ((id->capability & 8) || (id->field_valid & 2)) {
 fast_ata_pio:
-no_dma_set:
 		it8172_tune_drive(drive, 5);
 		return hwif->ide_dma_off_quietly(drive);
 	}
diff -Nru a/drivers/ide/pci/ns87415.c b/drivers/ide/pci/ns87415.c
--- a/drivers/ide/pci/ns87415.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/pci/ns87415.c	2004-10-10 23:09:59 -07:00
@@ -101,22 +101,11 @@
 	return (dma_stat & 7) != 4;
 }
 
-static int ns87415_ide_dma_read (ide_drive_t *drive)
+static int ns87415_ide_dma_setup(ide_drive_t *drive)
 {
 	/* select DMA xfer */
 	ns87415_prepare_drive(drive, 1);
-	if (!(__ide_dma_read(drive)))
-		return 0;
-	/* DMA failed: select PIO xfer */
-	ns87415_prepare_drive(drive, 0);
-	return 1;
-}
-
-static int ns87415_ide_dma_write (ide_drive_t *drive)
-{
-	/* select DMA xfer */
-	ns87415_prepare_drive(drive, 1);
-	if (!(__ide_dma_write(drive)))
+	if (!ide_dma_setup(drive))
 		return 0;
 	/* DMA failed: select PIO xfer */
 	ns87415_prepare_drive(drive, 0);
@@ -204,8 +193,7 @@
 		return;
 
 	hwif->OUTB(0x60, hwif->dma_status);
-	hwif->ide_dma_read = &ns87415_ide_dma_read;
-	hwif->ide_dma_write = &ns87415_ide_dma_write;
+	hwif->dma_setup = &ns87415_ide_dma_setup;
 	hwif->ide_dma_check = &ns87415_ide_dma_check;
 	hwif->ide_dma_end = &ns87415_ide_dma_end;
 
diff -Nru a/drivers/ide/pci/pdc202xx_new.c b/drivers/ide/pci/pdc202xx_new.c
--- a/drivers/ide/pci/pdc202xx_new.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/pci/pdc202xx_new.c	2004-10-10 23:09:59 -07:00
@@ -41,61 +41,6 @@
 
 #define PDC202_DEBUG_CABLE	0
 
-#if defined(DISPLAY_PDC202XX_TIMINGS) && defined(CONFIG_PROC_FS)
-#include <linux/stat.h>
-#include <linux/proc_fs.h>
-
-static u8 pdcnew_proc = 0;
-#define PDC202_MAX_DEVS		5
-static struct pci_dev *pdc202_devs[PDC202_MAX_DEVS];
-static int n_pdc202_devs;
-
-static char * pdcnew_info(char *buf, struct pci_dev *dev)
-{
-	char *p = buf;
-
-	p += sprintf(p, "\n                                ");
-	switch(dev->device) {
-		case PCI_DEVICE_ID_PROMISE_20277:
-			p += sprintf(p, "SBFastTrak 133 Lite"); break;
-		case PCI_DEVICE_ID_PROMISE_20276:
-			p += sprintf(p, "MBFastTrak 133 Lite"); break;
-		case PCI_DEVICE_ID_PROMISE_20275:
-			p += sprintf(p, "MBUltra133"); break;
-		case PCI_DEVICE_ID_PROMISE_20271:
-			p += sprintf(p, "FastTrak TX2000"); break;
-		case PCI_DEVICE_ID_PROMISE_20270:
-			p += sprintf(p, "FastTrak LP/TX2/TX4"); break;
-		case PCI_DEVICE_ID_PROMISE_20269:
-			p += sprintf(p, "Ultra133 TX2"); break;
-		case PCI_DEVICE_ID_PROMISE_20268:
-			p += sprintf(p, "Ultra100 TX2"); break;
-		default:
-			p += sprintf(p, "Ultra series"); break;
-			break;
-	}
-	p += sprintf(p, " Chipset.\n");
-	return (char *)p;
-}
-
-static int pdcnew_get_info (char *buffer, char **addr, off_t offset, int count)
-{
-	char *p = buffer;
-	int i, len;
-
-	for (i = 0; i < n_pdc202_devs; i++) {
-		struct pci_dev *dev	= pdc202_devs[i];
-		p = pdcnew_info(buffer, dev);
-	}
-	/* p - buffer must be less than 4k! */
-	len = (p - buffer) - offset;
-	*addr = buffer + offset;
-	
-	return len > count ? count : len;
-}
-#endif  /* defined(DISPLAY_PDC202XX_TIMINGS) && defined(CONFIG_PROC_FS) */
-
-
 static u8 pdcnew_ratemask (ide_drive_t *drive)
 {
 	u8 mode;
@@ -244,37 +189,16 @@
 	drive->init_speed = 0;
 
 	if (id && (id->capability & 1) && drive->autodma) {
-		/* Consult the list of known "bad" drives */
-		if (__ide_dma_bad_drive(drive))
-			goto fast_ata_pio;
-		if (id->field_valid & 4) {
-			if (id->dma_ultra & hwif->ultra_mask) {
-				/* Force if Capable UltraDMA */
-				int dma = config_chipset_for_dma(drive);
-				if ((id->field_valid & 2) && !dma)
-					goto try_dma_modes;
-			}
-		} else if (id->field_valid & 2) {
-try_dma_modes:
-			if ((id->dma_mword & hwif->mwdma_mask) ||
-			    (id->dma_1word & hwif->swdma_mask)) {
-				/* Force if Capable regular DMA modes */
-				if (!config_chipset_for_dma(drive))
-					goto no_dma_set;
-			}
-		} else if (__ide_dma_good_drive(drive) &&
-			    (id->eide_dma_time < 150)) {
-				goto no_dma_set;
-			/* Consult the list of known "good" drives */
-			if (!config_chipset_for_dma(drive))
-				goto no_dma_set;
-		} else {
-			goto fast_ata_pio;
+
+		if (ide_use_dma(drive)) {
+			if (config_chipset_for_dma(drive))
+				return hwif->ide_dma_on(drive);
 		}
-		return hwif->ide_dma_on(drive);
+
+		goto fast_ata_pio;
+
 	} else if ((id->capability & 8) || (id->field_valid & 2)) {
 fast_ata_pio:
-no_dma_set:
 		hwif->tuneproc(drive, 5);
 		return hwif->ide_dma_off_quietly(drive);
 	}
@@ -416,15 +340,6 @@
 #ifdef CONFIG_PPC_PMAC
 	apple_kiwi_init(dev);
 #endif
-
-#if defined(DISPLAY_PDC202XX_TIMINGS) && defined(CONFIG_PROC_FS)
-	pdc202_devs[n_pdc202_devs++] = dev;
-
-	if (!pdcnew_proc) {
-		pdcnew_proc = 1;
-		ide_pci_create_host_proc("pdcnew", pdcnew_get_info);
-	}
-#endif /* DISPLAY_PDC202XX_TIMINGS && CONFIG_PROC_FS */
 
 	return dev->irq;
 }
diff -Nru a/drivers/ide/pci/pdc202xx_new.h b/drivers/ide/pci/pdc202xx_new.h
--- a/drivers/ide/pci/pdc202xx_new.h	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/pci/pdc202xx_new.h	2004-10-10 23:09:59 -07:00
@@ -43,8 +43,6 @@
 		set_2regs(0x13,(c));			\
 	} while(0)
 
-#define DISPLAY_PDC202XX_TIMINGS
-
 static void init_setup_pdcnew(struct pci_dev *, ide_pci_device_t *);
 static void init_setup_pdc20270(struct pci_dev *, ide_pci_device_t *);
 static void init_setup_pdc20276(struct pci_dev *dev, ide_pci_device_t *d);
@@ -75,9 +73,6 @@
 		.init_hwif	= init_hwif_pdc202new,
 		.channels	= 2,
 		.autodma	= AUTODMA,
-#ifndef CONFIG_PDC202XX_FORCE
-		.enablebits	= {{0x50,0x02,0x02}, {0x50,0x04,0x04}},
-#endif
 		.bootable	= OFF_BOARD,
 	},{	/* 3 */
 		.name		= "PDC20271",
@@ -102,9 +97,6 @@
 		.init_hwif	= init_hwif_pdc202new,
 		.channels	= 2,
 		.autodma	= AUTODMA,
-#ifndef CONFIG_PDC202XX_FORCE
-		.enablebits	= {{0x50,0x02,0x02}, {0x50,0x04,0x04}},
-#endif
 		.bootable	= OFF_BOARD,
 	},{	/* 6 */
 		.name		= "PDC20277",
diff -Nru a/drivers/ide/pci/pdc202xx_old.c b/drivers/ide/pci/pdc202xx_old.c
--- a/drivers/ide/pci/pdc202xx_old.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/pci/pdc202xx_old.c	2004-10-10 23:09:59 -07:00
@@ -50,68 +50,14 @@
 
 #define PDC202_DEBUG_CABLE	0
 
-#if defined(DISPLAY_PDC202XX_TIMINGS) && defined(CONFIG_PROC_FS)
-#include <linux/stat.h>
-#include <linux/proc_fs.h>
-
-static u8 pdc202xx_proc = 0;
-#define PDC202_MAX_DEVS		5
-static struct pci_dev *pdc202_devs[PDC202_MAX_DEVS];
-static int n_pdc202_devs;
-
-static char * pdc202xx_info (char *buf, struct pci_dev *dev)
-{
-	char *p = buf;
-
+#if 0
 	unsigned long bibma  = pci_resource_start(dev, 4);
-	u32 reg60h = 0, reg64h = 0, reg68h = 0, reg6ch = 0;
-	u16 reg50h = 0, pmask = (1<<10), smask = (1<<11);
 	u8 hi = 0, lo = 0;
 
-        /*
-         * at that point bibma+0x2 et bibma+0xa are byte registers
-         * to investigate:
-         */
-	u8 c0	= inb_p((u16)bibma + 0x02);
-	u8 c1	= inb_p((u16)bibma + 0x0a);
-
-	u8 sc11	= inb_p((u16)bibma + 0x11);
-	u8 sc1a	= inb_p((u16)bibma + 0x1a);
-	u8 sc1b	= inb_p((u16)bibma + 0x1b);
 	u8 sc1c	= inb_p((u16)bibma + 0x1c); 
-	u8 sc1d	= inb_p((u16)bibma + 0x1d);
 	u8 sc1e	= inb_p((u16)bibma + 0x1e);
 	u8 sc1f	= inb_p((u16)bibma + 0x1f);
 
-	pci_read_config_word(dev, 0x50, &reg50h);
-	pci_read_config_dword(dev, 0x60, &reg60h);
-	pci_read_config_dword(dev, 0x64, &reg64h);
-	pci_read_config_dword(dev, 0x68, &reg68h);
-	pci_read_config_dword(dev, 0x6c, &reg6ch);
-
-	p += sprintf(p, "\n                                ");
-	switch(dev->device) {
-		case PCI_DEVICE_ID_PROMISE_20267:
-			p += sprintf(p, "Ultra100"); break;
-		case PCI_DEVICE_ID_PROMISE_20265:
-			p += sprintf(p, "Ultra100 on M/B"); break;
-		case PCI_DEVICE_ID_PROMISE_20263:
-			p += sprintf(p, "FastTrak 66"); break;
-		case PCI_DEVICE_ID_PROMISE_20262:
-			p += sprintf(p, "Ultra66"); break;
-		case PCI_DEVICE_ID_PROMISE_20246:
-			p += sprintf(p, "Ultra33");
-			reg50h |= 0x0c00;
-			break;
-		default:
-			p += sprintf(p, "Ultra Series"); break;
-	}
-	p += sprintf(p, " Chipset.\n");
-
-	p += sprintf(p, "------------------------------- General Status "
-			"---------------------------------\n");
-	p += sprintf(p, "Burst Mode                           : %sabled\n",
-		(sc1f & 0x01) ? "en" : "dis");
 	p += sprintf(p, "Host Mode                            : %s\n",
 		(sc1f & 0x08) ? "Tri-Stated" : "Normal");
 	p += sprintf(p, "Bus Clocking                         : %s\n",
@@ -126,70 +72,7 @@
 	SPLIT_BYTE(sc1e, hi, lo);
 	p += sprintf(p, "Status Polling Period                : %d\n", hi);
 	p += sprintf(p, "Interrupt Check Status Polling Delay : %d\n", lo);
-	p += sprintf(p, "--------------- Primary Channel "
-			"---------------- Secondary Channel "
-			"-------------\n");
-	p += sprintf(p, "                %s                         %s\n",
-		(c0&0x80)?"disabled":"enabled ",
-		(c1&0x80)?"disabled":"enabled ");
-	p += sprintf(p, "66 Clocking     %s                         %s\n",
-		(sc11&0x02)?"enabled ":"disabled",
-		(sc11&0x08)?"enabled ":"disabled");
-	p += sprintf(p, "           Mode %s                      Mode %s\n",
-		(sc1a & 0x01) ? "MASTER" : "PCI   ",
-		(sc1b & 0x01) ? "MASTER" : "PCI   ");
-	p += sprintf(p, "                %s                     %s\n",
-		(sc1d & 0x08) ? "Error       " :
-		((sc1d & 0x05) == 0x05) ? "Not My INTR " :
-		(sc1d & 0x04) ? "Interrupting" :
-		(sc1d & 0x02) ? "FIFO Full   " :
-		(sc1d & 0x01) ? "FIFO Empty  " : "????????????",
-		(sc1d & 0x80) ? "Error       " :
-		((sc1d & 0x50) == 0x50) ? "Not My INTR " :
-		(sc1d & 0x40) ? "Interrupting" :
-		(sc1d & 0x20) ? "FIFO Full   " :
-		(sc1d & 0x10) ? "FIFO Empty  " : "????????????");
-	p += sprintf(p, "--------------- drive0 --------- drive1 "
-			"-------- drive0 ---------- drive1 ------\n");
-	p += sprintf(p, "DMA enabled:    %s              %s "
-			"            %s               %s\n",
-		(c0&0x20)?"yes":"no ", (c0&0x40)?"yes":"no ",
-		(c1&0x20)?"yes":"no ", (c1&0x40)?"yes":"no ");
-	p += sprintf(p, "DMA Mode:       %s           %s "
-			"         %s            %s\n",
-		pdc202xx_ultra_verbose(reg60h, (reg50h & pmask)),
-		pdc202xx_ultra_verbose(reg64h, (reg50h & pmask)),
-		pdc202xx_ultra_verbose(reg68h, (reg50h & smask)),
-		pdc202xx_ultra_verbose(reg6ch, (reg50h & smask)));
-	p += sprintf(p, "PIO Mode:       %s            %s "
-			"          %s            %s\n",
-		pdc202xx_pio_verbose(reg60h),
-		pdc202xx_pio_verbose(reg64h),
-		pdc202xx_pio_verbose(reg68h),
-		pdc202xx_pio_verbose(reg6ch));
-#if 0
-	p += sprintf(p, "--------------- Can ATAPI DMA ---------------\n");
 #endif
-	return (char *)p;
-}
-
-static int pdc202xx_get_info (char *buffer, char **addr, off_t offset, int count)
-{
-	char *p = buffer;
-	int i, len;
-
-	for (i = 0; i < n_pdc202_devs; i++) {
-		struct pci_dev *dev	= pdc202_devs[i];
-		p = pdc202xx_info(buffer, dev);
-	}
-	/* p - buffer must be less than 4k! */
-	len = (p - buffer) - offset;
-	*addr = buffer + offset;
-	
-	return len > count ? count : len;
-}
-#endif  /* defined(DISPLAY_PDC202XX_TIMINGS) && defined(CONFIG_PROC_FS) */
-
 
 static u8 pdc202xx_ratemask (ide_drive_t *drive)
 {
@@ -451,37 +334,16 @@
 	drive->init_speed = 0;
 
 	if (id && (id->capability & 1) && drive->autodma) {
-		/* Consult the list of known "bad" drives */
-		if (__ide_dma_bad_drive(drive))
-			goto fast_ata_pio;
-		if (id->field_valid & 4) {
-			if (id->dma_ultra & hwif->ultra_mask) {
-				/* Force if Capable UltraDMA */
-				int dma = config_chipset_for_dma(drive);
-				if ((id->field_valid & 2) && !dma)
-					goto try_dma_modes;
-			}
-		} else if (id->field_valid & 2) {
-try_dma_modes:
-			if ((id->dma_mword & hwif->mwdma_mask) ||
-			    (id->dma_1word & hwif->swdma_mask)) {
-				/* Force if Capable regular DMA modes */
-				if (!config_chipset_for_dma(drive))
-					goto no_dma_set;
-			}
-		} else if (__ide_dma_good_drive(drive) &&
-			    (id->eide_dma_time < 150)) {
-				goto no_dma_set;
-			/* Consult the list of known "good" drives */
-			if (!config_chipset_for_dma(drive))
-				goto no_dma_set;
-		} else {
-			goto fast_ata_pio;
+
+		if (ide_use_dma(drive)) {
+			if (config_chipset_for_dma(drive))
+				return hwif->ide_dma_on(drive);
 		}
-		return hwif->ide_dma_on(drive);
+
+		goto fast_ata_pio;
+
 	} else if ((id->capability & 8) || (id->field_valid & 2)) {
 fast_ata_pio:
-no_dma_set:
 		hwif->tuneproc(drive, 5);
 		return hwif->ide_dma_off_quietly(drive);
 	}
@@ -494,7 +356,7 @@
 	return ((int) check_in_drive_lists(drive, pdc_quirk_drives));
 }
 
-static int pdc202xx_old_ide_dma_begin(ide_drive_t *drive)
+static void pdc202xx_old_ide_dma_start(ide_drive_t *drive)
 {
 	if (drive->current_speed > XFER_UDMA_2)
 		pdc_old_enable_66MHz_clock(drive->hwif);
@@ -515,7 +377,7 @@
 					word_count | 0x06000000;
 		hwif->OUTL(word_count, atapi_reg);
 	}
-	return __ide_dma_begin(drive);
+	ide_dma_start(drive);
 }
 
 static int pdc202xx_old_ide_dma_end(ide_drive_t *drive)
@@ -546,11 +408,13 @@
 	u8 sc1d			= hwif->INB((high_16 + 0x001d));
 
 	if (hwif->channel) {
+		/* bit7: Error, bit6: Interrupting, bit5: FIFO Full, bit4: FIFO Empty */
 		if ((sc1d & 0x50) == 0x50)
 			goto somebody_else;
 		else if ((sc1d & 0x40) == 0x40)
 			return (dma_stat & 4) == 4;
 	} else {
+		/* bit3: Error, bit2: Interrupting, bit1: FIFO Full, bit0: FIFO Empty */
 		if ((sc1d & 0x05) == 0x05)
 			goto somebody_else;
 		else if ((sc1d & 0x04) == 0x04)
@@ -668,15 +532,6 @@
 			name, dev->resource[PCI_ROM_RESOURCE].start);
 	}
 
-#if defined(DISPLAY_PDC202XX_TIMINGS) && defined(CONFIG_PROC_FS)
-	pdc202_devs[n_pdc202_devs++] = dev;
-
-	if (!pdc202xx_proc) {
-		pdc202xx_proc = 1;
-		ide_pci_create_host_proc("pdc202xx", pdc202xx_get_info);
-	}
-#endif /* DISPLAY_PDC202XX_TIMINGS && CONFIG_PROC_FS */
-
 	/*
 	 * software reset -  this is required because the bios
 	 * will set UDMA timing on if the hdd supports it. The
@@ -736,7 +591,7 @@
 	if (hwif->pci_dev->device != PCI_DEVICE_ID_PROMISE_20246) {
 		if (!(hwif->udma_four))
 			hwif->udma_four = (pdc202xx_old_cable_detect(hwif)) ? 0 : 1;
-		hwif->ide_dma_begin = &pdc202xx_old_ide_dma_begin;
+		hwif->dma_start = &pdc202xx_old_ide_dma_start;
 		hwif->ide_dma_end = &pdc202xx_old_ide_dma_end;
 	} 
 	hwif->ide_dma_test_irq = &pdc202xx_old_ide_dma_test_irq;
diff -Nru a/drivers/ide/pci/pdc202xx_old.h b/drivers/ide/pci/pdc202xx_old.h
--- a/drivers/ide/pci/pdc202xx_old.h	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/pci/pdc202xx_old.h	2004-10-10 23:09:59 -07:00
@@ -23,41 +23,6 @@
 	NULL
 };
 
-static inline u8 *pdc202xx_pio_verbose (u32 drive_pci)
-{
-	if ((drive_pci & 0x000ff000) == 0x000ff000) return("NOTSET");
-	if ((drive_pci & 0x00000401) == 0x00000401) return("PIO 4");
-	if ((drive_pci & 0x00000602) == 0x00000602) return("PIO 3");
-	if ((drive_pci & 0x00000803) == 0x00000803) return("PIO 2");
-	if ((drive_pci & 0x00000C05) == 0x00000C05) return("PIO 1");
-	if ((drive_pci & 0x00001309) == 0x00001309) return("PIO 0");
-	return("PIO ?");
-}
-
-static inline u8 *pdc202xx_dma_verbose (u32 drive_pci)
-{
-	if ((drive_pci & 0x00036000) == 0x00036000) return("MWDMA 2");
-	if ((drive_pci & 0x00046000) == 0x00046000) return("MWDMA 1");
-	if ((drive_pci & 0x00056000) == 0x00056000) return("MWDMA 0");
-	if ((drive_pci & 0x00056000) == 0x00056000) return("SWDMA 2");
-	if ((drive_pci & 0x00068000) == 0x00068000) return("SWDMA 1");
-	if ((drive_pci & 0x000BC000) == 0x000BC000) return("SWDMA 0");
-	return("PIO---");
-}
-
-static inline u8 *pdc202xx_ultra_verbose (u32 drive_pci, u16 slow_cable)
-{
-	if ((drive_pci & 0x000ff000) == 0x000ff000)
-		return("NOTSET");
-	if ((drive_pci & 0x00012000) == 0x00012000)
-		return((slow_cable) ? "UDMA 2" : "UDMA 4");
-	if ((drive_pci & 0x00024000) == 0x00024000)
-		return((slow_cable) ? "UDMA 1" : "UDMA 3");
-	if ((drive_pci & 0x00036000) == 0x00036000)
-		return("UDMA 0");
-	return(pdc202xx_dma_verbose(drive_pci));
-}
-
 /* A Register */
 #define	SYNC_ERRDY_EN	0xC0
 
@@ -98,8 +63,6 @@
 #define	MC1		0x02	/* DMA"C" timing */
 #define	MC0		0x01	/* DMA"C" timing */
 
-#define DISPLAY_PDC202XX_TIMINGS
-
 static void init_setup_pdc202ata4(struct pci_dev *dev, ide_pci_device_t *d);
 static void init_setup_pdc20265(struct pci_dev *, ide_pci_device_t *);
 static void init_setup_pdc202xx(struct pci_dev *, ide_pci_device_t *);
@@ -116,9 +79,6 @@
 		.init_dma	= init_dma_pdc202xx,
 		.channels	= 2,
 		.autodma	= AUTODMA,
-#ifndef CONFIG_PDC202XX_FORCE
-		.enablebits	= {{0x50,0x02,0x02}, {0x50,0x04,0x04}},
-#endif
 		.bootable	= OFF_BOARD,
 		.extra		= 16,
 	},{	/* 1 */
@@ -129,12 +89,8 @@
 		.init_dma	= init_dma_pdc202xx,
 		.channels	= 2,
 		.autodma	= AUTODMA,
-#ifndef CONFIG_PDC202XX_FORCE
-		.enablebits	= {{0x50,0x02,0x02}, {0x50,0x04,0x04}},
-#endif
 		.bootable	= OFF_BOARD,
 		.extra		= 48,
-		.flags		= IDEPCI_FLAG_FORCE_PDC,
 	},{	/* 2 */
 		.name		= "PDC20263",
 		.init_setup	= init_setup_pdc202ata4,
@@ -143,9 +99,6 @@
 		.init_dma	= init_dma_pdc202xx,
 		.channels	= 2,
 		.autodma	= AUTODMA,
-#ifndef CONFIG_PDC202XX_FORCE
-		.enablebits	= {{0x50,0x02,0x02}, {0x50,0x04,0x04}},
-#endif
 		.bootable	= OFF_BOARD,
 		.extra		= 48,
 	},{	/* 3 */
@@ -156,12 +109,8 @@
 		.init_dma	= init_dma_pdc202xx,
 		.channels	= 2,
 		.autodma	= AUTODMA,
-#ifndef CONFIG_PDC202XX_FORCE
-		.enablebits	= {{0x50,0x02,0x02}, {0x50,0x04,0x04}},
-#endif
 		.bootable	= OFF_BOARD,
 		.extra		= 48,
-		.flags		= IDEPCI_FLAG_FORCE_PDC,
 	},{	/* 4 */
 		.name		= "PDC20267",
 		.init_setup	= init_setup_pdc202xx,
@@ -170,9 +119,6 @@
 		.init_dma	= init_dma_pdc202xx,
 		.channels	= 2,
 		.autodma	= AUTODMA,
-#ifndef CONFIG_PDC202XX_FORCE
-		.enablebits	= {{0x50,0x02,0x02}, {0x50,0x04,0x04}},
-#endif
 		.bootable	= OFF_BOARD,
 		.extra		= 48,
 	}
diff -Nru a/drivers/ide/pci/piix.c b/drivers/ide/pci/piix.c
--- a/drivers/ide/pci/piix.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/pci/piix.c	2004-10-10 23:09:59 -07:00
@@ -106,165 +106,6 @@
 #include "piix.h"
 
 static int no_piix_dma;
-#if defined(DISPLAY_PIIX_TIMINGS) && defined(CONFIG_PROC_FS)
-#include <linux/stat.h>
-#include <linux/proc_fs.h>
-
-static u8 piix_proc = 0;
-#define PIIX_MAX_DEVS		5
-static struct pci_dev *piix_devs[PIIX_MAX_DEVS];
-static int n_piix_devs;
-
-/**
- *	piix_get_info		-	fill in /proc for PIIX ide
- *	@buffer: buffer to fill
- *	@addr: address of user start in buffer
- *	@offset: offset into 'file'
- *	@count: buffer count
- *
- *	Walks the PIIX devices and outputs summary data on the tuning and
- *	anything else that will help with debugging
- */
- 
-static int piix_get_info (char *buffer, char **addr, off_t offset, int count)
-{
-	char *p = buffer;
-	int i;
-
-	for (i = 0; i < n_piix_devs; i++) {
-		struct pci_dev *dev	= piix_devs[i];
-		unsigned long bibma = pci_resource_start(dev, 4);
-	        u16 reg40 = 0, psitre = 0, reg42 = 0, ssitre = 0;
-		u8  c0 = 0, c1 = 0, reg54 = 0, reg55 = 0;
-		u8  reg44 = 0, reg48 = 0, reg4a = 0, reg4b = 0;
-
-		p += sprintf(p, "\nController: %d\n", i);
-		p += sprintf(p, "\n                                Intel ");
-		switch(dev->device) {
-			case PCI_DEVICE_ID_INTEL_82801EB_1:
-				p += sprintf(p, "PIIX4 SATA 150 ");
-				break;
-			case PCI_DEVICE_ID_INTEL_82801BA_8:
-			case PCI_DEVICE_ID_INTEL_82801BA_9:
-			case PCI_DEVICE_ID_INTEL_82801CA_10:
-			case PCI_DEVICE_ID_INTEL_82801CA_11:
-			case PCI_DEVICE_ID_INTEL_82801DB_10:
-			case PCI_DEVICE_ID_INTEL_82801DB_11:
-			case PCI_DEVICE_ID_INTEL_82801EB_11:
-			case PCI_DEVICE_ID_INTEL_82801E_11:
-			case PCI_DEVICE_ID_INTEL_ESB_2:
-			case PCI_DEVICE_ID_INTEL_ICH6_19:
-				p += sprintf(p, "PIIX4 Ultra 100 ");
-				break;
-			case PCI_DEVICE_ID_INTEL_82372FB_1:
-			case PCI_DEVICE_ID_INTEL_82801AA_1:
-				p += sprintf(p, "PIIX4 Ultra 66 ");
-				break;
-			case PCI_DEVICE_ID_INTEL_82451NX:
-			case PCI_DEVICE_ID_INTEL_82801AB_1:
-			case PCI_DEVICE_ID_INTEL_82443MX_1:
-			case PCI_DEVICE_ID_INTEL_82371AB:
-				p += sprintf(p, "PIIX4 Ultra 33 ");
-				break;
-			case PCI_DEVICE_ID_INTEL_82371SB_1:
-				p += sprintf(p, "PIIX3 ");
-				break;
-			case PCI_DEVICE_ID_INTEL_82371MX:
-				p += sprintf(p, "MPIIX ");
-				break;
-			case PCI_DEVICE_ID_INTEL_82371FB_1:
-			case PCI_DEVICE_ID_INTEL_82371FB_0:
-			default:
-				p += sprintf(p, "PIIX ");
-				break;
-		}
-		p += sprintf(p, "Chipset.\n");
-
-		if (dev->device == PCI_DEVICE_ID_INTEL_82371MX)
-			continue;
-
-		pci_read_config_word(dev, 0x40, &reg40);
-		pci_read_config_word(dev, 0x42, &reg42);
-		pci_read_config_byte(dev, 0x44, &reg44);
-		pci_read_config_byte(dev, 0x48, &reg48);
-		pci_read_config_byte(dev, 0x4a, &reg4a);
-		pci_read_config_byte(dev, 0x4b, &reg4b);
-		pci_read_config_byte(dev, 0x54, &reg54);
-		pci_read_config_byte(dev, 0x55, &reg55);
-
-		psitre = (reg40 & 0x4000) ? 1 : 0;
-		ssitre = (reg42 & 0x4000) ? 1 : 0;
-
-		/*
-		 * at that point bibma+0x2 et bibma+0xa are byte registers
-		 * to investigate:
-		 */
-		c0 = inb(bibma + 0x02);
-		c1 = inb(bibma + 0x0a);
-
-		p += sprintf(p, "--------------- Primary Channel "
-				"---------------- Secondary Channel "
-				"-------------\n");
-		p += sprintf(p, "                %sabled "
-				"                        %sabled\n",
-				(c0&0x80) ? "dis" : " en",
-				(c1&0x80) ? "dis" : " en");
-		p += sprintf(p, "--------------- drive0 --------- drive1 "
-				"-------- drive0 ---------- drive1 ------\n");
-		p += sprintf(p, "DMA enabled:    %s              %s "
-				"            %s               %s\n",
-				(c0&0x20) ? "yes" : "no ",
-				(c0&0x40) ? "yes" : "no ",
-				(c1&0x20) ? "yes" : "no ",
-				(c1&0x40) ? "yes" : "no " );
-		p += sprintf(p, "UDMA enabled:   %s              %s "
-				"            %s               %s\n",
-				(reg48&0x01) ? "yes" : "no ",
-				(reg48&0x02) ? "yes" : "no ",
-				(reg48&0x04) ? "yes" : "no ",
-				(reg48&0x08) ? "yes" : "no " );
-		p += sprintf(p, "UDMA enabled:   %s                %s "
-				"              %s                 %s\n",
-				((reg54&0x11) &&
-				 (reg55&0x10) && (reg4a&0x01)) ? "5" :
-				((reg54&0x11) && (reg4a&0x02)) ? "4" :
-				((reg54&0x11) && (reg4a&0x01)) ? "3" :
-				(reg4a&0x02) ? "2" :
-				(reg4a&0x01) ? "1" :
-				(reg4a&0x00) ? "0" : "X",
-				((reg54&0x22) &&
-				 (reg55&0x20) && (reg4a&0x10)) ? "5" :
-				((reg54&0x22) && (reg4a&0x20)) ? "4" :
-				((reg54&0x22) && (reg4a&0x10)) ? "3" :
-				(reg4a&0x20) ? "2" :
-				(reg4a&0x10) ? "1" :
-				(reg4a&0x00) ? "0" : "X",
-				((reg54&0x44) &&
-				 (reg55&0x40) && (reg4b&0x03)) ? "5" :
-				((reg54&0x44) && (reg4b&0x02)) ? "4" :
-				((reg54&0x44) && (reg4b&0x01)) ? "3" :
-				(reg4b&0x02) ? "2" :
-				(reg4b&0x01) ? "1" :
-				(reg4b&0x00) ? "0" : "X",
-				((reg54&0x88) &&
-				 (reg55&0x80) && (reg4b&0x30)) ? "5" :
-				((reg54&0x88) && (reg4b&0x20)) ? "4" :
-				((reg54&0x88) && (reg4b&0x10)) ? "3" :
-				(reg4b&0x20) ? "2" :
-				(reg4b&0x10) ? "1" :
-				(reg4b&0x00) ? "0" : "X");
-
-		p += sprintf(p, "UDMA\n");
-		p += sprintf(p, "DMA\n");
-		p += sprintf(p, "PIO\n");
-
-		/*
-		 * FIXME.... Add configuration junk data....blah blah......
-		 */
-	}
-	return p-buffer;	 /* => must be less than 4k! */
-}
-#endif  /* defined(DISPLAY_PIIX_TIMINGS) && defined(CONFIG_PROC_FS) */
 
 /**
  *	piix_ratemask		-	compute rate mask for PIIX IDE
@@ -562,25 +403,11 @@
 
 	if ((id->capability & 1) && drive->autodma) {
 
-		/* Consult the list of known "bad" drives */
-		if (__ide_dma_bad_drive(drive))
-			goto fast_ata_pio;
-
-		/**
-		 * Try to turn DMA on if:
-		 *  - UDMA or EIDE modes are supported or
-		 *  - drive is a known "good" drive
-		 *
-		 * Checks for best mode supported are down later by
-		 * piix_config_drive_for_dma() -> ide_dma_speed()
-		 */
-		if ((id->field_valid & (4 | 2)) ||
-		    (__ide_dma_good_drive(drive) && id->eide_dma_time < 150)) {
+		if (ide_use_dma(drive)) {
 			if (piix_config_drive_for_dma(drive))
 				return hwif->ide_dma_on(drive);
 		}
 
-		/* For some reason DMA wasn't turned on, so try PIO. */
 		goto fast_ata_pio;
 
 	} else if ((id->capability & 8) || (id->field_valid & 2)) {
@@ -627,14 +454,6 @@
 			break;
 	}
 
-#if defined(DISPLAY_PIIX_TIMINGS) && defined(CONFIG_PROC_FS)
-	piix_devs[n_piix_devs++] = dev;
-
-	if (!piix_proc) {
-		piix_proc = 1;
-		ide_pci_create_host_proc("piix", piix_get_info);
-	}
-#endif /* DISPLAY_PIIX_TIMINGS && CONFIG_PROC_FS */
 	return 0;
 }
 
diff -Nru a/drivers/ide/pci/piix.h b/drivers/ide/pci/piix.h
--- a/drivers/ide/pci/piix.h	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/pci/piix.h	2004-10-10 23:09:59 -07:00
@@ -5,10 +5,6 @@
 #include <linux/pci.h>
 #include <linux/ide.h>
 
-#define PIIX_DEBUG_DRIVE_INFO		0
-
-#define DISPLAY_PIIX_TIMINGS
-
 static void init_setup_piix(struct pci_dev *, ide_pci_device_t *);
 static unsigned int __devinit init_chipset_piix(struct pci_dev *, const char *);
 static void init_hwif_piix(ide_hwif_t *);
diff -Nru a/drivers/ide/pci/sc1200.c b/drivers/ide/pci/sc1200.c
--- a/drivers/ide/pci/sc1200.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/pci/sc1200.c	2004-10-10 23:09:59 -07:00
@@ -67,55 +67,6 @@
 	return pci_clock;
 }
 
-#define DISPLAY_SC1200_TIMINGS
-
-#if defined(DISPLAY_SC1200_TIMINGS) && defined(CONFIG_PROC_FS)
-#include <linux/stat.h>
-#include <linux/proc_fs.h>
-
-static int sc1200_get_info(char *, char **, off_t, int);
-extern int (*sc1200_display_info)(char *, char **, off_t, int); /* ide-proc.c */
-extern char *ide_media_verbose(ide_drive_t *);
-static u8 sc1200_proc = 0;
-
-static struct pci_dev *bmide_dev;
-
-static int sc1200_get_info (char *buffer, char **addr, off_t offset, int count)
-{
-	char *p = buffer;
-	unsigned long bibma = pci_resource_start(bmide_dev, 4);
-	int len;
-	u8  c0 = 0, c1 = 0;
-
-	/*
-	 * at that point bibma+0x2 et bibma+0xa are byte registers
-	 * to investigate:
-	 */
-
-	c0 = inb_p(bibma + 0x02);
-	c1 = inb_p(bibma + 0x0a);
-
-	p += sprintf(p, "\n                               National SCx200 Chipset.\n");
-	p += sprintf(p, "--------------- Primary Channel ---------------- Secondary Channel -------------\n");
-	p += sprintf(p, "                %sabled                         %sabled\n",
-			(c0&0x80) ? "dis" : " en",
-			(c1&0x80) ? "dis" : " en");
-	p += sprintf(p, "--------------- drive0 --------- drive1 -------- drive0 ---------- drive1 ------\n");
-	p += sprintf(p, "DMA enabled:    %s              %s             %s               %s\n",
-			(c0&0x20) ? "yes" : "no ", (c0&0x40) ? "yes" : "no ",
-			(c1&0x20) ? "yes" : "no ", (c1&0x40) ? "yes" : "no " );
-
-	p += sprintf(p, "UDMA\n");
-	p += sprintf(p, "DMA\n");
-	p += sprintf(p, "PIO\n");
-
-	len = (p - buffer) - offset;
-	*addr = buffer + offset;
-	
-	return len > count ? count : len;
-}
-#endif /* DISPLAY_SC1200_TIMINGS && CONFIG_PROC_FS */
-
 extern char *ide_xfer_verbose (byte xfer_rate);
 
 /*
@@ -505,21 +456,6 @@
 }
 
 /*
- * Initialize the sc1200 bridge for reliable IDE DMA operation.
- */
-static unsigned int __init init_chipset_sc1200 (struct pci_dev *dev, const char *name)
-{
-#if defined(DISPLAY_SC1200_TIMINGS) && defined(CONFIG_PROC_FS)
-	if (!bmide_dev) {
-		sc1200_proc = 1;
-		bmide_dev = dev;
-		ide_pci_create_host_proc("sc1200", sc1200_get_info);
-	}
-#endif /* DISPLAY_SC1200_TIMINGS && CONFIG_PROC_FS */
-	return 0;
-}
-
-/*
  * This gets invoked by the IDE driver once for each channel,
  * and performs channel-specific pre-initialization before drive probing.
  */
@@ -545,7 +481,6 @@
 
 static ide_pci_device_t sc1200_chipset __devinitdata = {
 	.name		= "SC1200",
-	.init_chipset	= init_chipset_sc1200,
 	.init_hwif	= init_hwif_sc1200,
 	.channels	= 2,
 	.autodma	= AUTODMA,
diff -Nru a/drivers/ide/pci/serverworks.c b/drivers/ide/pci/serverworks.c
--- a/drivers/ide/pci/serverworks.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/pci/serverworks.c	2004-10-10 23:09:59 -07:00
@@ -44,164 +44,6 @@
 static u8 svwks_revision = 0;
 static struct pci_dev *isa_dev;
 
-#if defined(DISPLAY_SVWKS_TIMINGS) && defined(CONFIG_PROC_FS)
-#include <linux/stat.h>
-#include <linux/proc_fs.h>
-
-static u8 svwks_proc = 0;
-#define SVWKS_MAX_DEVS		2
-static struct pci_dev *svwks_devs[SVWKS_MAX_DEVS];
-static int n_svwks_devs;
-
-static int svwks_get_info (char *buffer, char **addr, off_t offset, int count)
-{
-	char *p = buffer;
-	int i, len;
-
-	p += sprintf(p, "\n                             "
-			"ServerWorks OSB4/CSB5/CSB6\n");
-
-	for (i = 0; i < n_svwks_devs; i++) {
-		struct pci_dev *dev = svwks_devs[i];
-		unsigned long bibma = pci_resource_start(dev, 4);
-		u32 reg40, reg44;
-		u16 reg48, reg56;
-		u8  reg54, c0=0, c1=0;
-
-		pci_read_config_dword(dev, 0x40, &reg40);
-		pci_read_config_dword(dev, 0x44, &reg44);
-		pci_read_config_word(dev, 0x48, &reg48);
-		pci_read_config_byte(dev, 0x54, &reg54);
-		pci_read_config_word(dev, 0x56, &reg56);
-
-		/*
-		 * at that point bibma+0x2 et bibma+0xa are byte registers
-		 * to investigate:
-		 */
-		c0 = inb_p(bibma + 0x02);
-		c1 = inb_p(bibma + 0x0a);
-
-		p += sprintf(p, "\n                            ServerWorks ");
-		switch(dev->device) {
-			case PCI_DEVICE_ID_SERVERWORKS_CSB6IDE2:
-			case PCI_DEVICE_ID_SERVERWORKS_CSB6IDE:
-				p += sprintf(p, "CSB6 ");
-				break;
-			case PCI_DEVICE_ID_SERVERWORKS_CSB5IDE:
-				p += sprintf(p, "CSB5 ");
-				break;
-			case PCI_DEVICE_ID_SERVERWORKS_OSB4IDE:
-				p += sprintf(p, "OSB4 ");
-				break;
-			default:
-				p += sprintf(p, "%04x ", dev->device);
-				break;
-		}
-		p += sprintf(p, "Chipset (rev %02x)\n", svwks_revision);
-
-		p += sprintf(p, "------------------------------- "
-				"General Status "
-				"---------------------------------\n");
-		p += sprintf(p, "--------------- Primary Channel "
-				"---------------- Secondary Channel "
-				"-------------\n");
-		p += sprintf(p, "                %sabled"
-				"                         %sabled\n",
-				(c0&0x80) ? "dis" : " en",
-				(c1&0x80) ? "dis" : " en");
-		p += sprintf(p, "--------------- drive0 --------- drive1 "
-				"-------- drive0 ---------- drive1 ------\n");
-		p += sprintf(p, "DMA enabled:    %s              %s"
-				"             %s               %s\n",
-			(c0&0x20) ? "yes" : "no ",
-			(c0&0x40) ? "yes" : "no ",
-			(c1&0x20) ? "yes" : "no ",
-			(c1&0x40) ? "yes" : "no " );
-		p += sprintf(p, "UDMA enabled:   %s              %s"
-				"             %s               %s\n",
-			(reg54 & 0x01) ? "yes" : "no ",
-			(reg54 & 0x02) ? "yes" : "no ",
-			(reg54 & 0x04) ? "yes" : "no ",
-			(reg54 & 0x08) ? "yes" : "no " );
-		p += sprintf(p, "UDMA enabled:   %s                %s"
-				"               %s                 %s\n",
-			((reg56&0x0005)==0x0005)?"5":
-				((reg56&0x0004)==0x0004)?"4":
-				((reg56&0x0003)==0x0003)?"3":
-				((reg56&0x0002)==0x0002)?"2":
-				((reg56&0x0001)==0x0001)?"1":
-				((reg56&0x000F))?"?":"0",
-			((reg56&0x0050)==0x0050)?"5":
-				((reg56&0x0040)==0x0040)?"4":
-				((reg56&0x0030)==0x0030)?"3":
-				((reg56&0x0020)==0x0020)?"2":
-				((reg56&0x0010)==0x0010)?"1":
-				((reg56&0x00F0))?"?":"0",
-			((reg56&0x0500)==0x0500)?"5":
-				((reg56&0x0400)==0x0400)?"4":
-				((reg56&0x0300)==0x0300)?"3":
-				((reg56&0x0200)==0x0200)?"2":
-				((reg56&0x0100)==0x0100)?"1":
-				((reg56&0x0F00))?"?":"0",
-			((reg56&0x5000)==0x5000)?"5":
-				((reg56&0x4000)==0x4000)?"4":
-				((reg56&0x3000)==0x3000)?"3":
-				((reg56&0x2000)==0x2000)?"2":
-				((reg56&0x1000)==0x1000)?"1":
-				((reg56&0xF000))?"?":"0");
-		p += sprintf(p, "DMA enabled:    %s                %s"
-				"               %s                 %s\n",
-			((reg44&0x00002000)==0x00002000)?"2":
-				((reg44&0x00002100)==0x00002100)?"1":
-				((reg44&0x00007700)==0x00007700)?"0":
-				((reg44&0x0000FF00)==0x0000FF00)?"X":"?",
-			((reg44&0x00000020)==0x00000020)?"2":
-				((reg44&0x00000021)==0x00000021)?"1":
-				((reg44&0x00000077)==0x00000077)?"0":
-				((reg44&0x000000FF)==0x000000FF)?"X":"?",
-			((reg44&0x20000000)==0x20000000)?"2":
-				((reg44&0x21000000)==0x21000000)?"1":
-				((reg44&0x77000000)==0x77000000)?"0":
-				((reg44&0xFF000000)==0xFF000000)?"X":"?",
-			((reg44&0x00200000)==0x00200000)?"2":
-				((reg44&0x00210000)==0x00210000)?"1":
-				((reg44&0x00770000)==0x00770000)?"0":
-				((reg44&0x00FF0000)==0x00FF0000)?"X":"?");
-
-		p += sprintf(p, "PIO  enabled:   %s                %s"
-				"               %s                 %s\n",
-			((reg40&0x00002000)==0x00002000)?"4":
-				((reg40&0x00002200)==0x00002200)?"3":
-				((reg40&0x00003400)==0x00003400)?"2":
-				((reg40&0x00004700)==0x00004700)?"1":
-				((reg40&0x00005D00)==0x00005D00)?"0":"?",
-			((reg40&0x00000020)==0x00000020)?"4":
-				((reg40&0x00000022)==0x00000022)?"3":
-				((reg40&0x00000034)==0x00000034)?"2":
-				((reg40&0x00000047)==0x00000047)?"1":
-				((reg40&0x0000005D)==0x0000005D)?"0":"?",
-			((reg40&0x20000000)==0x20000000)?"4":
-				((reg40&0x22000000)==0x22000000)?"3":
-				((reg40&0x34000000)==0x34000000)?"2":
-				((reg40&0x47000000)==0x47000000)?"1":
-				((reg40&0x5D000000)==0x5D000000)?"0":"?",
-			((reg40&0x00200000)==0x00200000)?"4":
-				((reg40&0x00220000)==0x00220000)?"3":
-				((reg40&0x00340000)==0x00340000)?"2":
-				((reg40&0x00470000)==0x00470000)?"1":
-				((reg40&0x005D0000)==0x005D0000)?"0":"?");
-
-	}
-	p += sprintf(p, "\n");
-
-	/* p - buffer must be less than 4k! */
-	len = (p - buffer) - offset;
-	*addr = buffer + offset;
-	
-	return len > count ? count : len;
-}
-#endif  /* defined(DISPLAY_SVWKS_TIMINGS) && defined(CONFIG_PROC_FS) */
-
 static int check_in_drive_lists (ide_drive_t *drive, const char **list)
 {
 	while (*list)
@@ -463,38 +305,16 @@
 	drive->init_speed = 0;
 
 	if ((id->capability & 1) && drive->autodma) {
-		/* Consult the list of known "bad" drives */
-		if (__ide_dma_bad_drive(drive))
-			goto fast_ata_pio;
-		if (id->field_valid & 4) {
-			if (id->dma_ultra & hwif->ultra_mask) {
-				/* Force if Capable UltraDMA */
-				int dma = config_chipset_for_dma(drive);
-				if ((id->field_valid & 2) && !dma)
-					goto try_dma_modes;
-			} else
-				/* UDMA disabled by mask, try other DMA modes */
-				goto try_dma_modes;
-		} else if (id->field_valid & 2) {
-try_dma_modes:
-			if ((id->dma_mword & hwif->mwdma_mask) ||
-			    (id->dma_1word & hwif->swdma_mask)) {
-				/* Force if Capable regular DMA modes */
-				if (!config_chipset_for_dma(drive))
-					goto no_dma_set;
-			}
-		} else if (__ide_dma_good_drive(drive) &&
-			   (id->eide_dma_time < 150)) {
-			/* Consult the list of known "good" drives */
-			if (!config_chipset_for_dma(drive))
-				goto no_dma_set;
-		} else {
-			goto no_dma_set;
+
+		if (ide_use_dma(drive)) {
+			if (config_chipset_for_dma(drive))
+				return hwif->ide_dma_on(drive);
 		}
-		return hwif->ide_dma_on(drive);
+
+		goto fast_ata_pio;
+
 	} else if ((id->capability & 8) || (id->field_valid & 2)) {
 fast_ata_pio:
-no_dma_set:
 		config_chipset_for_pio(drive);
 		//	hwif->tuneproc(drive, 5);
 		return hwif->ide_dma_off_quietly(drive);
@@ -616,16 +436,6 @@
 			btr |= (svwks_revision >= SVWKS_CSB5_REVISION_NEW) ? 0x3 : 0x2;
 		pci_write_config_byte(dev, 0x5A, btr);
 	}
-
-
-#if defined(DISPLAY_SVWKS_TIMINGS) && defined(CONFIG_PROC_FS)
-	svwks_devs[n_svwks_devs++] = dev;
-
-	if (!svwks_proc) {
-		svwks_proc = 1;
-		ide_pci_create_host_proc("svwks", svwks_get_info);
-	}
-#endif /* DISPLAY_SVWKS_TIMINGS && CONFIG_PROC_FS */
 
 	return (dev->irq) ? dev->irq : 0;
 }
diff -Nru a/drivers/ide/pci/serverworks.h b/drivers/ide/pci/serverworks.h
--- a/drivers/ide/pci/serverworks.h	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/pci/serverworks.h	2004-10-10 23:09:59 -07:00
@@ -21,8 +21,6 @@
 	NULL
 };
 
-#define DISPLAY_SVWKS_TIMINGS	1
-
 static void init_setup_svwks(struct pci_dev *, ide_pci_device_t *);
 static void init_setup_csb6(struct pci_dev *, ide_pci_device_t *);
 static unsigned int init_chipset_svwks(struct pci_dev *, const char *);
diff -Nru a/drivers/ide/pci/sgiioc4.c b/drivers/ide/pci/sgiioc4.c
--- a/drivers/ide/pci/sgiioc4.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/pci/sgiioc4.c	2004-10-10 23:09:59 -07:00
@@ -192,16 +192,13 @@
 	return intr_reg & 3;
 }
 
-static int
-sgiioc4_ide_dma_begin(ide_drive_t * drive)
+static void sgiioc4_ide_dma_start(ide_drive_t * drive)
 {
 	ide_hwif_t *hwif = HWIF(drive);
 	unsigned int reg = hwif->INL(hwif->dma_base + IOC4_DMA_CTRL * 4);
 	unsigned int temp_reg = reg | IOC4_S_DMA_START;
 
 	hwif->OUTL(temp_reg, hwif->dma_base + IOC4_DMA_CTRL * 4);
-
-	return 0;
 }
 
 static u32
@@ -335,17 +332,6 @@
 }
 
 static int
-sgiioc4_ide_dma_verbose(ide_drive_t * drive)
-{
-	if (drive->using_dma == 1)
-		printk(", UDMA(16)");
-	else
-		printk(", PIO");
-
-	return 1;
-}
-
-static int
 sgiioc4_ide_dma_lostirq(ide_drive_t * drive)
 {
 	HWIF(drive)->resetproc(drive);
@@ -407,11 +393,7 @@
 	if (!hwif->dmatable_cpu)
 		goto dma_alloc_failure;
 
-	hwif->sg_table =
-	    kmalloc(sizeof (struct scatterlist) * IOC4_PRD_ENTRIES, GFP_KERNEL);
-
-	if (!hwif->sg_table)
-		goto dma_sgalloc_failure;
+	hwif->sg_max_nents = IOC4_PRD_ENTRIES;
 
 	hwif->dma_base2 = (unsigned long)
 		pci_alloc_consistent(hwif->pci_dev,
@@ -424,9 +406,6 @@
 	return;
 
 dma_base2alloc_failure:
-	kfree(hwif->sg_table);
-
-dma_sgalloc_failure:
 	pci_free_consistent(hwif->pci_dev,
 			    IOC4_PRD_ENTRIES * IOC4_PRD_BYTES,
 			    hwif->dmatable_cpu, hwif->dmatable_dma);
@@ -511,10 +490,7 @@
 	unsigned int count = 0, i = 1;
 	struct scatterlist *sg;
 
-	if (HWGROUP(drive)->rq->flags & REQ_DRIVE_TASKFILE)
-		hwif->sg_nents = i = ide_raw_build_sglist(drive, rq);
-	else
-		hwif->sg_nents = i = ide_build_sglist(drive, rq);
+	hwif->sg_nents = i = ide_build_sglist(drive, rq);
 
 	if (!i)
 		return 0;	/* sglist of length Zero */
@@ -574,35 +550,31 @@
 	return 0;		/* revert to PIO for this request */
 }
 
-static int
-sgiioc4_ide_dma_read(ide_drive_t * drive)
+static int sgiioc4_ide_dma_setup(ide_drive_t *drive)
 {
 	struct request *rq = HWGROUP(drive)->rq;
 	unsigned int count = 0;
+	int ddir;
 
-	if (!(count = sgiioc4_build_dma_table(drive, rq, PCI_DMA_FROMDEVICE))) {
-		/* try PIO instead of DMA */
-		return 1;
-	}
-	/* Writes FROM the IOC4 TO Main Memory */
-	sgiioc4_configure_for_dma(IOC4_DMA_WRITE, drive);
-
-	return 0;
-}
-
-static int
-sgiioc4_ide_dma_write(ide_drive_t * drive)
-{
-	struct request *rq = HWGROUP(drive)->rq;
-	unsigned int count = 0;
+	if (rq_data_dir(rq))
+		ddir = PCI_DMA_TODEVICE;
+	else
+		ddir = PCI_DMA_FROMDEVICE;
 
-	if (!(count = sgiioc4_build_dma_table(drive, rq, PCI_DMA_TODEVICE))) {
+	if (!(count = sgiioc4_build_dma_table(drive, rq, ddir))) {
 		/* try PIO instead of DMA */
+		ide_map_sg(drive, rq);
 		return 1;
 	}
 
-	sgiioc4_configure_for_dma(IOC4_DMA_READ, drive);
-	/* Writes TO the IOC4 FROM Main Memory */
+	if (rq_data_dir(rq))
+		/* Writes TO the IOC4 FROM Main Memory */
+		ddir = IOC4_DMA_READ;
+	else
+		/* Writes FROM the IOC4 TO Main Memory */
+		ddir = IOC4_DMA_WRITE;
+
+	sgiioc4_configure_for_dma(ddir, drive);
 
 	return 0;
 }
@@ -616,7 +588,6 @@
 	hwif->ultra_mask = 0x0;	/* Disable Ultra DMA */
 	hwif->mwdma_mask = 0x2;	/* Multimode-2 DMA  */
 	hwif->swdma_mask = 0x2;
-	hwif->identify = NULL;
 	hwif->tuneproc = NULL;	/* Sets timing for PIO mode */
 	hwif->speedproc = NULL;	/* Sets timing for DMA &/or PIO modes */
 	hwif->selectproc = NULL;/* Use the default routine to select drive */
@@ -629,9 +600,8 @@
 	hwif->quirkproc = NULL;
 	hwif->busproc = NULL;
 
-	hwif->ide_dma_read = &sgiioc4_ide_dma_read;
-	hwif->ide_dma_write = &sgiioc4_ide_dma_write;
-	hwif->ide_dma_begin = &sgiioc4_ide_dma_begin;
+	hwif->dma_setup = &sgiioc4_ide_dma_setup;
+	hwif->dma_start = &sgiioc4_ide_dma_start;
 	hwif->ide_dma_end = &sgiioc4_ide_dma_end;
 	hwif->ide_dma_check = &sgiioc4_ide_dma_check;
 	hwif->ide_dma_on = &sgiioc4_ide_dma_on;
@@ -639,7 +609,6 @@
 	hwif->ide_dma_test_irq = &sgiioc4_ide_dma_test_irq;
 	hwif->ide_dma_host_on = &sgiioc4_ide_dma_host_on;
 	hwif->ide_dma_host_off = &sgiioc4_ide_dma_host_off;
-	hwif->ide_dma_verbose = &sgiioc4_ide_dma_verbose;
 	hwif->ide_dma_lostirq = &sgiioc4_ide_dma_lostirq;
 	hwif->ide_dma_timeout = &__ide_dma_timeout;
 	hwif->INB = &sgiioc4_INB;
diff -Nru a/drivers/ide/pci/siimage.c b/drivers/ide/pci/siimage.c
--- a/drivers/ide/pci/siimage.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/pci/siimage.c	2004-10-10 23:09:59 -07:00
@@ -420,37 +420,16 @@
 	struct hd_driveid *id	= drive->id;
 
 	if ((id->capability & 1) != 0 && drive->autodma) {
-		/* Consult the list of known "bad" drives */
-		if (__ide_dma_bad_drive(drive))
-			goto fast_ata_pio;
-
-		if ((id->field_valid & 4) && siimage_ratemask(drive)) {
-			if (id->dma_ultra & hwif->ultra_mask) {
-				/* Force if Capable UltraDMA */
-				int dma = config_chipset_for_dma(drive);
-				if ((id->field_valid & 2) && !dma)
-					goto try_dma_modes;
-			}
-		} else if (id->field_valid & 2) {
-try_dma_modes:
-			if ((id->dma_mword & hwif->mwdma_mask) ||
-			    (id->dma_1word & hwif->swdma_mask)) {
-				/* Force if Capable regular DMA modes */
-				if (!config_chipset_for_dma(drive))
-					goto no_dma_set;
-			}
-		} else if (__ide_dma_good_drive(drive) &&
-			   (id->eide_dma_time < 150)) {
-			/* Consult the list of known "good" drives */
-			if (!config_chipset_for_dma(drive))
-				goto no_dma_set;
-		} else {
-			goto fast_ata_pio;
+
+		if (ide_use_dma(drive)) {
+			if (config_chipset_for_dma(drive))
+				return hwif->ide_dma_on(drive);
 		}
-		return hwif->ide_dma_on(drive);
+
+		goto fast_ata_pio;
+
 	} else if ((id->capability & 8) || (id->field_valid & 2)) {
 fast_ata_pio:
-no_dma_set:
 		config_chipset_for_pio(drive, 1);
 		return hwif->ide_dma_off_quietly(drive);
 	}
@@ -554,12 +533,6 @@
 	return 0;
 }
 
-static int siimage_mmio_ide_dma_verbose (ide_drive_t *drive)
-{
-	int temp = __ide_dma_verbose(drive);
-	return temp;
-}
-
 /**
  *	siimage_busproc		-	bus isolation ioctl
  *	@drive: drive to isolate/restore
@@ -1077,7 +1050,6 @@
 
 	if (hwif->mmio) {
 		hwif->ide_dma_test_irq = &siimage_mmio_ide_dma_test_irq;
-		hwif->ide_dma_verbose = &siimage_mmio_ide_dma_verbose;
 	} else {
 		hwif->ide_dma_test_irq = & siimage_io_ide_dma_test_irq;
 	}
diff -Nru a/drivers/ide/pci/sis5513.c b/drivers/ide/pci/sis5513.c
--- a/drivers/ide/pci/sis5513.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/pci/sis5513.c	2004-10-10 23:09:59 -07:00
@@ -671,36 +671,16 @@
 	drive->init_speed = 0;
 
 	if (id && (id->capability & 1) && drive->autodma) {
-		/* Consult the list of known "bad" drives */
-		if (__ide_dma_bad_drive(drive))
-			goto fast_ata_pio;
-		if (id->field_valid & 4) {
-			if (id->dma_ultra & hwif->ultra_mask) {
-				/* Force if Capable UltraDMA */
-				int dma = config_chipset_for_dma(drive);
-				if ((id->field_valid & 2) && !dma)
-					goto try_dma_modes;
-			}
-		} else if (id->field_valid & 2) {
-try_dma_modes:
-			if ((id->dma_mword & hwif->mwdma_mask) ||
-			    (id->dma_1word & hwif->swdma_mask)) {
-				/* Force if Capable regular DMA modes */
-				if (!config_chipset_for_dma(drive))
-					goto no_dma_set;
-			}
-		} else if (__ide_dma_good_drive(drive) &&
-			   (id->eide_dma_time < 150)) {
-			/* Consult the list of known "good" drives */
-			if (!config_chipset_for_dma(drive))
-				goto no_dma_set;
-		} else {
-			goto fast_ata_pio;
+
+		if (ide_use_dma(drive)) {
+			if (config_chipset_for_dma(drive))
+				return hwif->ide_dma_on(drive);
 		}
-		return hwif->ide_dma_on(drive);
+
+		goto fast_ata_pio;
+
 	} else if ((id->capability & 8) || (id->field_valid & 2)) {
 fast_ata_pio:
-no_dma_set:
 		sis5513_tune_drive(drive, 5);
 		return hwif->ide_dma_off_quietly(drive);
 	}
diff -Nru a/drivers/ide/pci/sl82c105.c b/drivers/ide/pci/sl82c105.c
--- a/drivers/ide/pci/sl82c105.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/pci/sl82c105.c	2004-10-10 23:09:59 -07:00
@@ -236,15 +236,13 @@
  * The generic IDE core will have disabled the BMEN bit before this
  * function is called.
  */
-static int sl82c105_ide_dma_begin(ide_drive_t *drive)
+static void sl82c105_ide_dma_start(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif = HWIF(drive);
 	struct pci_dev *dev = hwif->pci_dev;
 
-//	DBG(("sl82c105_ide_dma_begin(drive:%s)\n", drive->name));
-
 	sl82c105_reset_host(dev);
-	return __ide_dma_begin(drive);
+	ide_dma_start(drive);
 }
 
 static int sl82c105_ide_dma_timeout(ide_drive_t *drive)
@@ -469,7 +467,7 @@
 	hwif->ide_dma_on = &sl82c105_ide_dma_on;
 	hwif->ide_dma_off_quietly = &sl82c105_ide_dma_off_quietly;
 	hwif->ide_dma_lostirq = &sl82c105_ide_dma_lost_irq;
-	hwif->ide_dma_begin = &sl82c105_ide_dma_begin;
+	hwif->dma_start = &sl82c105_ide_dma_start;
 	hwif->ide_dma_timeout = &sl82c105_ide_dma_timeout;
 
 	if (!noautodma)
diff -Nru a/drivers/ide/pci/slc90e66.c b/drivers/ide/pci/slc90e66.c
--- a/drivers/ide/pci/slc90e66.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/pci/slc90e66.c	2004-10-10 23:09:59 -07:00
@@ -21,103 +21,6 @@
 
 #include <asm/io.h>
 
-#define DISPLAY_SLC90E66_TIMINGS
-
-#if defined(DISPLAY_SLC90E66_TIMINGS) && defined(CONFIG_PROC_FS)
-#include <linux/stat.h>
-#include <linux/proc_fs.h>
-
-static u8 slc90e66_proc = 0;
-static struct pci_dev *bmide_dev;
-
-static int slc90e66_get_info (char *buffer, char **addr, off_t offset, int count)
-{
-	char *p = buffer;
-	int len;
-	unsigned long bibma = pci_resource_start(bmide_dev, 4);
-	u16 reg40 = 0, psitre = 0, reg42 = 0, ssitre = 0;
-	u8  c0 = 0, c1 = 0;
-	u8  reg44 = 0, reg47 = 0, reg48 = 0, reg4a = 0, reg4b = 0;
-
-	pci_read_config_word(bmide_dev, 0x40, &reg40);
-	pci_read_config_word(bmide_dev, 0x42, &reg42);
-	pci_read_config_byte(bmide_dev, 0x44, &reg44);
-	pci_read_config_byte(bmide_dev, 0x47, &reg47);
-	pci_read_config_byte(bmide_dev, 0x48, &reg48);
-	pci_read_config_byte(bmide_dev, 0x4a, &reg4a);
-	pci_read_config_byte(bmide_dev, 0x4b, &reg4b);
-
-	psitre = (reg40 & 0x4000) ? 1 : 0;
-	ssitre = (reg42 & 0x4000) ? 1 : 0;
-
-        /*
-         * at that point bibma+0x2 et bibma+0xa are byte registers
-         * to investigate:
-         */
-	c0 = inb_p(bibma + 0x02);
-	c1 = inb_p(bibma + 0x0a);
-
-	p += sprintf(p, "                                SLC90E66 Chipset.\n");
-	p += sprintf(p, "--------------- Primary Channel "
-			"---------------- Secondary Channel "
-			"-------------\n");
-	p += sprintf(p, "                %sabled "
-			"                        %sabled\n",
-			(c0&0x80) ? "dis" : " en",
-			(c1&0x80) ? "dis" : " en");
-	p += sprintf(p, "--------------- drive0 --------- drive1 "
-			"-------- drive0 ---------- drive1 ------\n");
-	p += sprintf(p, "DMA enabled:    %s              %s "
-			"            %s               %s\n",
-			(c0&0x20) ? "yes" : "no ",
-			(c0&0x40) ? "yes" : "no ",
-			(c1&0x20) ? "yes" : "no ",
-			(c1&0x40) ? "yes" : "no " );
-	p += sprintf(p, "UDMA enabled:   %s              %s "
-			"            %s               %s\n",
-			(reg48&0x01) ? "yes" : "no ",
-			(reg48&0x02) ? "yes" : "no ",
-			(reg48&0x04) ? "yes" : "no ",
-			(reg48&0x08) ? "yes" : "no " );
-	p += sprintf(p, "UDMA enabled:   %s                %s "
-			"              %s                 %s\n",
-			((reg4a&0x04)==0x04) ? "4" :
-			((reg4a&0x03)==0x03) ? "3" :
-			(reg4a&0x02) ? "2" :
-			(reg4a&0x01) ? "1" :
-			(reg4a&0x00) ? "0" : "X",
-			((reg4a&0x40)==0x40) ? "4" :
-			((reg4a&0x30)==0x30) ? "3" :
-			(reg4a&0x20) ? "2" :
-			(reg4a&0x10) ? "1" :
-			(reg4a&0x00) ? "0" : "X",
-			((reg4b&0x04)==0x04) ? "4" :
-			((reg4b&0x03)==0x03) ? "3" :
-			(reg4b&0x02) ? "2" :
-			(reg4b&0x01) ? "1" :
-			(reg4b&0x00) ? "0" : "X",
-			((reg4b&0x40)==0x40) ? "4" :
-			((reg4b&0x30)==0x30) ? "3" :
-			(reg4b&0x20) ? "2" :
-			(reg4b&0x10) ? "1" :
-			(reg4b&0x00) ? "0" : "X");
-
-	p += sprintf(p, "UDMA\n");
-	p += sprintf(p, "DMA\n");
-	p += sprintf(p, "PIO\n");
-
-/*
- *	FIXME.... Add configuration junk data....blah blah......
- */
-
-	/* p - buffer must be less than 4k! */
-	len = (p - buffer) - offset;
-	*addr = buffer + offset;
-	
-	return len > count ? count : len;
-}
-#endif  /* defined(DISPLAY_SLC90E66_TIMINGS) && defined(CONFIG_PROC_FS) */
-
 static u8 slc90e66_ratemask (ide_drive_t *drive)
 {
 	u8 mode	= 2;
@@ -236,6 +139,7 @@
 	if (speed >= XFER_UDMA_0) {
 		if (!(reg48 & u_flag))
 			pci_write_config_word(dev, 0x48, reg48|u_flag);
+		/* FIXME: (reg4a & a_speed) ? */
 		if ((reg4a & u_speed) != u_speed) {
 			pci_write_config_word(dev, 0x4a, reg4a & ~a_speed);
 			pci_read_config_word(dev, 0x4a, &reg4a);
@@ -274,37 +178,16 @@
 	drive->init_speed = 0;
 
 	if (id && (id->capability & 1) && drive->autodma) {
-		/* Consult the list of known "bad" drives */
-		if (__ide_dma_bad_drive(drive))
-			goto fast_ata_pio;
-
-		if (id->field_valid & 4) {
-			if (id->dma_ultra & hwif->ultra_mask) {
-				/* Force if Capable UltraDMA */
-				int dma = slc90e66_config_drive_for_dma(drive);
-				if ((id->field_valid & 2) && !dma)
-					goto try_dma_modes;
-			}
-		} else if (id->field_valid & 2) {
-try_dma_modes:
-			if ((id->dma_mword & hwif->mwdma_mask) ||
-			    (id->dma_1word & hwif->swdma_mask)) {
-				/* Force if Capable regular DMA modes */
-				if (!slc90e66_config_drive_for_dma(drive))
-					goto no_dma_set;
-			}
-		} else if (__ide_dma_good_drive(drive) &&
-			   (id->eide_dma_time < 150)) {
-			/* Consult the list of known "good" drives */
-			if (!slc90e66_config_drive_for_dma(drive))
-				goto no_dma_set;
-		} else {
-			goto fast_ata_pio;
+
+		if (ide_use_dma(drive)) {
+			if (slc90e66_config_drive_for_dma(drive))
+				return hwif->ide_dma_on(drive);
 		}
-		return hwif->ide_dma_on(drive);
+
+		goto fast_ata_pio;
+
 	} else if ((id->capability & 8) || (id->field_valid & 2)) {
 fast_ata_pio:
-no_dma_set:
 		hwif->tuneproc(drive, 5);
 		return hwif->ide_dma_off_quietly(drive);
 	}
@@ -313,18 +196,6 @@
 }
 #endif /* CONFIG_BLK_DEV_IDEDMA */
 
-static unsigned int __init init_chipset_slc90e66 (struct pci_dev *dev, const char *name)
-{
-#if defined(DISPLAY_SLC90E66_TIMINGS) && defined(CONFIG_PROC_FS)
-	if (!slc90e66_proc) {
-		slc90e66_proc = 1;
-		bmide_dev = dev;
-		ide_pci_create_host_proc("slc90e66", slc90e66_get_info);
-	}
-#endif /* DISPLAY_SLC90E66_TIMINGS && CONFIG_PROC_FS */
-	return 0;
-}
-
 static void __init init_hwif_slc90e66 (ide_hwif_t *hwif)
 {
 	u8 reg47 = 0;
@@ -366,7 +237,6 @@
 
 static ide_pci_device_t slc90e66_chipset __devinitdata = {
 	.name		= "SLC90E66",
-	.init_chipset	= init_chipset_slc90e66,
 	.init_hwif	= init_hwif_slc90e66,
 	.channels	= 2,
 	.autodma	= AUTODMA,
diff -Nru a/drivers/ide/pci/triflex.c b/drivers/ide/pci/triflex.c
--- a/drivers/ide/pci/triflex.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/pci/triflex.c	2004-10-10 23:09:59 -07:00
@@ -105,11 +105,9 @@
 {
 	int speed = ide_dma_speed(drive, 0); /* No ultra speeds */
 
-	if (!speed) { 
-		u8 pspeed = ide_get_best_pio_mode(drive, 255, 4, NULL);
-		speed = XFER_PIO_0 + pspeed;
-	}
-	
+	if (!speed)
+		return 0;
+
 	(void) triflex_tune_chipset(drive, speed);
 	 return ide_dma_enable(drive);
 }
@@ -118,25 +116,16 @@
 {
 	ide_hwif_t *hwif	= HWIF(drive);
 	struct hd_driveid *id	= drive->id;
-	
-	if (id && (id->capability & 1) && drive->autodma) {
-		if (__ide_dma_bad_drive(drive))
-			goto tune_pio;
-		if (id->field_valid & 2) {
-			if ((id->dma_mword & hwif->mwdma_mask) ||
-				(id->dma_1word & hwif->swdma_mask)) {
-				if (!triflex_config_drive_for_dma(drive))
-					goto tune_pio;
-			}
-		} else 
-			goto tune_pio;
-	} else {
-tune_pio:
-		hwif->tuneproc(drive, 255);
-		return hwif->ide_dma_off_quietly(drive);
+
+	if ((id->capability & 1) && drive->autodma) {
+		if (ide_use_dma(drive)) {
+			if (triflex_config_drive_for_dma(drive))
+				return hwif->ide_dma_on(drive);
+		}
 	}
 
-	return hwif->ide_dma_on(drive);
+	hwif->tuneproc(drive, 255);
+	return hwif->ide_dma_off_quietly(drive);
 }
 
 static void __init init_hwif_triflex(ide_hwif_t *hwif)
diff -Nru a/drivers/ide/pci/trm290.c b/drivers/ide/pci/trm290.c
--- a/drivers/ide/pci/trm290.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/pci/trm290.c	2004-10-10 23:09:59 -07:00
@@ -179,64 +179,32 @@
 }
 
 #ifdef CONFIG_BLK_DEV_IDEDMA
-static int trm290_ide_dma_write (ide_drive_t *drive /*, struct request *rq */)
+static void trm290_ide_dma_exec_cmd(ide_drive_t *drive, u8 command)
 {
 	ide_hwif_t *hwif	= HWIF(drive);
-	struct request *rq	= HWGROUP(drive)->rq;
-//	ide_task_t *args	= rq->special;
-	task_ioreg_t command	= WIN_NOP;
-	unsigned int count, reading = 2, writing = 0;
 
-	reading = 0;
-	writing = 1;
-#ifdef TRM290_NO_DMA_WRITES
-	/* always use PIO for writes */
-	trm290_prepare_drive(drive, 0);	/* select PIO xfer */
-	return 1;
-#endif
-	if (!(count = ide_build_dmatable(drive, rq))) {
-		/* try PIO instead of DMA */
-		trm290_prepare_drive(drive, 0); /* select PIO xfer */
-		return 1;
-	}
-	/* select DMA xfer */
-	trm290_prepare_drive(drive, 1);
-	hwif->OUTL(hwif->dmatable_dma|reading|writing, hwif->dma_command);
-	drive->waiting_for_dma = 1;
-	/* start DMA */
-	hwif->OUTW((count * 2) - 1, hwif->dma_status);
-	if (drive->media != ide_disk)
-		return 0;
 	if (HWGROUP(drive)->handler != NULL)	/* paranoia check */
 		BUG();
 	ide_set_handler(drive, &ide_dma_intr, WAIT_CMD, NULL);
-	/*
-	 * FIX ME to use only ACB ide_task_t args Struct
-	 */
-#if 0
-	{
-		ide_task_t *args = rq->special;
-		command = args->tfRegister[IDE_COMMAND_OFFSET];
-	}
-#else
-	command = /* (lba48) ? WIN_READDMA_EXT : */ WIN_READDMA;
-	if (rq->flags & REQ_DRIVE_TASKFILE) {
-		ide_task_t *args = rq->special;
-		command = args->tfRegister[IDE_COMMAND_OFFSET];
-	}
-#endif
 	/* issue cmd to drive */
 	hwif->OUTB(command, IDE_COMMAND_REG);
-	return hwif->ide_dma_begin(drive);
 }
 
-static int trm290_ide_dma_read (ide_drive_t *drive  /*, struct request *rq */)
+static int trm290_ide_dma_setup(ide_drive_t *drive)
 {
-	ide_hwif_t *hwif	= HWIF(drive);
-	struct request *rq	= HWGROUP(drive)->rq;
-//	ide_task_t *args	= rq->special;
-	task_ioreg_t command	= WIN_NOP;
-	unsigned int count, reading = 2, writing = 0;
+	ide_hwif_t *hwif = drive->hwif;
+	struct request *rq = hwif->hwgroup->rq;
+	unsigned int count, rw;
+
+	if (rq_data_dir(rq)) {
+#ifdef TRM290_NO_DMA_WRITES
+		/* always use PIO for writes */
+		trm290_prepare_drive(drive, 0);	/* select PIO xfer */
+		return 1;
+#endif
+		rw = 1;
+	} else
+		rw = 2;
 
 	if (!(count = ide_build_dmatable(drive, rq))) {
 		/* try PIO instead of DMA */
@@ -245,38 +213,15 @@
 	}
 	/* select DMA xfer */
 	trm290_prepare_drive(drive, 1);
-	hwif->OUTL(hwif->dmatable_dma|reading|writing, hwif->dma_command);
+	hwif->OUTL(hwif->dmatable_dma|rw, hwif->dma_command);
 	drive->waiting_for_dma = 1;
 	/* start DMA */
 	hwif->OUTW((count * 2) - 1, hwif->dma_status);
-	if (drive->media != ide_disk)
-		return 0;
-	if (HWGROUP(drive)->handler != NULL)	/* paranoia check */
-		BUG();
-	ide_set_handler(drive, &ide_dma_intr, WAIT_CMD, NULL);
-	/*
-	 * FIX ME to use only ACB ide_task_t args Struct
-	 */
-#if 0
-	{
-		ide_task_t *args = rq->special;
-		command = args->tfRegister[IDE_COMMAND_OFFSET];
-	}
-#else
-	command = /* (lba48) ? WIN_WRITEDMA_EXT : */ WIN_WRITEDMA;
-	if (rq->flags & REQ_DRIVE_TASKFILE) {
-		ide_task_t *args = rq->special;
-		command = args->tfRegister[IDE_COMMAND_OFFSET];
-	}
-#endif
-	/* issue cmd to drive */
-	hwif->OUTB(command, IDE_COMMAND_REG);
-	return hwif->ide_dma_begin(drive);
+	return 0;
 }
 
-static int trm290_ide_dma_begin (ide_drive_t *drive)
+static void trm290_ide_dma_start(ide_drive_t *drive)
 {
-	return 0;
 }
 
 static int trm290_ide_dma_end (ide_drive_t *drive)
@@ -347,9 +292,9 @@
 	ide_setup_dma(hwif, (hwif->config_data + 4) ^ (hwif->channel ? 0x0080 : 0x0000), 3);
 
 #ifdef CONFIG_BLK_DEV_IDEDMA
-	hwif->ide_dma_write = &trm290_ide_dma_write;
-	hwif->ide_dma_read = &trm290_ide_dma_read;
-	hwif->ide_dma_begin = &trm290_ide_dma_begin;
+	hwif->dma_setup = &trm290_ide_dma_setup;
+	hwif->dma_exec_cmd = &trm290_ide_dma_exec_cmd;
+	hwif->dma_start = &trm290_ide_dma_start;
 	hwif->ide_dma_end = &trm290_ide_dma_end;
 	hwif->ide_dma_test_irq = &trm290_ide_dma_test_irq;
 #endif /* CONFIG_BLK_DEV_IDEDMA */
diff -Nru a/drivers/ide/ppc/pmac.c b/drivers/ide/ppc/pmac.c
--- a/drivers/ide/ppc/pmac.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/ppc/pmac.c	2004-10-10 23:09:59 -07:00
@@ -34,6 +34,7 @@
 #include <linux/pci.h>
 #include <linux/adb.h>
 #include <linux/pmu.h>
+#include <linux/scatterlist.h>
 
 #include <asm/prom.h>
 #include <asm/io.h>
@@ -77,10 +78,6 @@
 	 */
 	volatile struct dbdma_regs __iomem *	dma_regs;
 	struct dbdma_cmd*		dma_table_cpu;
-	dma_addr_t			dma_table_dma;
-	struct scatterlist*		sg_table;
-	int				sg_nents;
-	int				sg_dma_direction;
 #endif
 	
 } pmac_ide_hwif_t;
@@ -361,7 +358,6 @@
 static void pmac_ide_tuneproc(ide_drive_t *drive, u8 pio);
 static void pmac_ide_selectproc(ide_drive_t *drive);
 static void pmac_ide_kauai_selectproc(ide_drive_t *drive);
-static int pmac_ide_dma_begin (ide_drive_t *drive);
 
 #endif /* CONFIG_BLK_DEV_IDEDMA_PMAC */
 
@@ -1245,6 +1241,8 @@
 		hwif->noprobe = 0;
 #endif /* CONFIG_PMAC_PBOOK */
 
+	hwif->sg_max_nents = MAX_DCMDS;
+
 #ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
 	/* has a DBDMA controller channel */
 	if (pmif->dma_regs)
@@ -1562,66 +1560,6 @@
 #ifdef CONFIG_BLK_DEV_IDEDMA_PMAC
 
 /*
- * This is very close to the generic ide-dma version of the function except
- * that we don't use the fields in the hwif but our own copies for sg_table
- * and friends. We build & map the sglist for a given request
- */
-static int __pmac
-pmac_ide_build_sglist(ide_drive_t *drive, struct request *rq)
-{
-	ide_hwif_t *hwif = HWIF(drive);
-	pmac_ide_hwif_t *pmif = (pmac_ide_hwif_t *)hwif->hwif_data;
-	struct scatterlist *sg = pmif->sg_table;
-	int nents;
-
-	nents = blk_rq_map_sg(drive->queue, rq, sg);
-		
-	if (rq_data_dir(rq) == READ)
-		pmif->sg_dma_direction = PCI_DMA_FROMDEVICE;
-	else
-		pmif->sg_dma_direction = PCI_DMA_TODEVICE;
-
-	return pci_map_sg(hwif->pci_dev, sg, nents, pmif->sg_dma_direction);
-}
-
-/*
- * Same as above but for a "raw" taskfile request
- */
-static int __pmac
-pmac_ide_raw_build_sglist(ide_drive_t *drive, struct request *rq)
-{
-	ide_hwif_t *hwif = HWIF(drive);
-	pmac_ide_hwif_t *pmif = (pmac_ide_hwif_t *)hwif->hwif_data;
-	struct scatterlist *sg = pmif->sg_table;
-	int nents = 0;
-	ide_task_t *args = rq->special;
-	unsigned char *virt_addr = rq->buffer;
-	int sector_count = rq->nr_sectors;
-
-	if (args->command_type == IDE_DRIVE_TASK_RAW_WRITE)
-		pmif->sg_dma_direction = PCI_DMA_TODEVICE;
-	else
-		pmif->sg_dma_direction = PCI_DMA_FROMDEVICE;
-	
-	if (sector_count > 128) {
-		memset(&sg[nents], 0, sizeof(*sg));
-		sg[nents].page = virt_to_page(virt_addr);
-		sg[nents].offset = offset_in_page(virt_addr);
-		sg[nents].length = 128  * SECTOR_SIZE;
-		nents++;
-		virt_addr = virt_addr + (128 * SECTOR_SIZE);
-		sector_count -= 128;
-	}
-	memset(&sg[nents], 0, sizeof(*sg));
-	sg[nents].page = virt_to_page(virt_addr);
-	sg[nents].offset = offset_in_page(virt_addr);
-	sg[nents].length =  sector_count  * SECTOR_SIZE;
-	nents++;
-   
-	return pci_map_sg(hwif->pci_dev, sg, nents, pmif->sg_dma_direction);
-}
-
-/*
  * pmac_ide_build_dmatable builds the DBDMA command list
  * for a transfer and sets the DBDMA channel to point to it.
  */
@@ -1644,16 +1582,13 @@
 	while (readl(&dma->status) & RUN)
 		udelay(1);
 
-	/* Build sglist */
-	if (HWGROUP(drive)->rq->flags & REQ_DRIVE_TASKFILE)
-		pmif->sg_nents = i = pmac_ide_raw_build_sglist(drive, rq);
-	else
-		pmif->sg_nents = i = pmac_ide_build_sglist(drive, rq);
+	hwif->sg_nents = i = ide_build_sglist(drive, rq);
+
 	if (!i)
 		return 0;
 
 	/* Build DBDMA commands list */
-	sg = pmif->sg_table;
+	sg = hwif->sg_table;
 	while (i && sg_dma_len(sg)) {
 		u32 cur_addr;
 		u32 cur_len;
@@ -1698,16 +1633,16 @@
 		memset(table, 0, sizeof(struct dbdma_cmd));
 		st_le16(&table->command, DBDMA_STOP);
 		mb();
-		writel(pmif->dma_table_dma, &dma->cmdptr);
+		writel(hwif->dmatable_dma, &dma->cmdptr);
 		return 1;
 	}
 
 	printk(KERN_DEBUG "%s: empty DMA table?\n", drive->name);
  use_pio_instead:
 	pci_unmap_sg(hwif->pci_dev,
-		     pmif->sg_table,
-		     pmif->sg_nents,
-		     pmif->sg_dma_direction);
+		     hwif->sg_table,
+		     hwif->sg_nents,
+		     hwif->sg_dma_direction);
 	return 0; /* revert to PIO for this request */
 }
 
@@ -1715,14 +1650,14 @@
 static void __pmac
 pmac_ide_destroy_dmatable (ide_drive_t *drive)
 {
+	ide_hwif_t *hwif = drive->hwif;
 	struct pci_dev *dev = HWIF(drive)->pci_dev;
-	pmac_ide_hwif_t* pmif = (pmac_ide_hwif_t *)HWIF(drive)->hwif_data;
-	struct scatterlist *sg = pmif->sg_table;
-	int nents = pmif->sg_nents;
+	struct scatterlist *sg = hwif->sg_table;
+	int nents = hwif->sg_nents;
 
 	if (nents) {
-		pci_unmap_sg(dev, sg, nents, pmif->sg_dma_direction);
-		pmif->sg_nents = 0;
+		pci_unmap_sg(dev, sg, nents, hwif->sg_dma_direction);
+		hwif->sg_nents = 0;
 	}
 }
 
@@ -1885,7 +1820,7 @@
  * a read on KeyLargo ATA/66 and mark us as waiting for DMA completion
  */
 static int __pmac
-pmac_ide_dma_start(ide_drive_t *drive, int reading)
+pmac_ide_dma_setup(ide_drive_t *drive)
 {
 	ide_hwif_t *hwif = HWIF(drive);
 	pmac_ide_hwif_t* pmif = (pmac_ide_hwif_t *)hwif->hwif_data;
@@ -1897,12 +1832,14 @@
 		return 1;
 	ata4 = (pmif->kind == controller_kl_ata4);	
 
-	if (!pmac_ide_build_dmatable(drive, rq))
+	if (!pmac_ide_build_dmatable(drive, rq)) {
+		ide_map_sg(drive, rq);
 		return 1;
+	}
 
 	/* Apple adds 60ns to wrDataSetup on reads */
 	if (ata4 && (pmif->timings[unit] & TR_66_UDMA_EN)) {
-		writel(pmif->timings[unit] + (reading ? 0x00800000UL : 0),
+		writel(pmif->timings[unit] + (!rq_data_dir(rq) ? 0x00800000UL : 0),
 			PMAC_IDE_REG(IDE_TIMING_CONFIG));
 		(void)readl(PMAC_IDE_REG(IDE_TIMING_CONFIG));
 	}
@@ -1912,87 +1849,28 @@
 	return 0;
 }
 
-/*
- * Start a DMA READ command
- */
-static int __pmac
-pmac_ide_dma_read(ide_drive_t *drive)
-{
-	struct request *rq = HWGROUP(drive)->rq;
-	u8 lba48 = (drive->addressing == 1) ? 1 : 0;
-	task_ioreg_t command = WIN_NOP;
-
-	if (pmac_ide_dma_start(drive, 1))
-		return 1;
-
-	if (drive->media != ide_disk)
-		return 0;
-
-	command = (lba48) ? WIN_READDMA_EXT : WIN_READDMA;
-	
-	if (drive->vdma)
-		command = (lba48) ? WIN_READ_EXT: WIN_READ;
-		
-	if (rq->flags & REQ_DRIVE_TASKFILE) {
-		ide_task_t *args = rq->special;
-		command = args->tfRegister[IDE_COMMAND_OFFSET];
-	}
-
-	/* issue cmd to drive */
-	ide_execute_command(drive, command, &ide_dma_intr, 2*WAIT_CMD, NULL);
-
-	return pmac_ide_dma_begin(drive);
-}
-
-/*
- * Start a DMA WRITE command
- */
-static int __pmac
-pmac_ide_dma_write (ide_drive_t *drive)
+static void __pmac
+pmac_ide_dma_exec_cmd(ide_drive_t *drive, u8 command)
 {
-	struct request *rq = HWGROUP(drive)->rq;
-	u8 lba48 = (drive->addressing == 1) ? 1 : 0;
-	task_ioreg_t command = WIN_NOP;
-
-	if (pmac_ide_dma_start(drive, 0))
-		return 1;
-
-	if (drive->media != ide_disk)
-		return 0;
-
-	command = (lba48) ? WIN_WRITEDMA_EXT : WIN_WRITEDMA;
-	if (drive->vdma)
-		command = (lba48) ? WIN_WRITE_EXT: WIN_WRITE;
-		
-	if (rq->flags & REQ_DRIVE_TASKFILE) {
-		ide_task_t *args = rq->special;
-		command = args->tfRegister[IDE_COMMAND_OFFSET];
-	}
-
 	/* issue cmd to drive */
 	ide_execute_command(drive, command, &ide_dma_intr, 2*WAIT_CMD, NULL);
-
-	return pmac_ide_dma_begin(drive);
 }
 
 /*
  * Kick the DMA controller into life after the DMA command has been issued
  * to the drive.
  */
-static int __pmac
-pmac_ide_dma_begin (ide_drive_t *drive)
+static void __pmac
+pmac_ide_dma_start(ide_drive_t *drive)
 {
 	pmac_ide_hwif_t* pmif = (pmac_ide_hwif_t *)HWIF(drive)->hwif_data;
 	volatile struct dbdma_regs __iomem *dma;
 
-	if (pmif == NULL)
-		return 1;
 	dma = pmif->dma_regs;
 
 	writel((RUN << 16) | RUN, &dma->control);
 	/* Make sure it gets to the controller right now */
 	(void)readl(&dma->control);
-	return 0;
 }
 
 /*
@@ -2130,41 +2008,25 @@
 	pmif->dma_table_cpu = (struct dbdma_cmd*)pci_alloc_consistent(
 		hwif->pci_dev,
 		(MAX_DCMDS + 2) * sizeof(struct dbdma_cmd),
-		&pmif->dma_table_dma);
+		&hwif->dmatable_dma);
 	if (pmif->dma_table_cpu == NULL) {
 		printk(KERN_ERR "%s: unable to allocate DMA command list\n",
 		       hwif->name);
 		return;
 	}
 
-	pmif->sg_table = kmalloc(sizeof(struct scatterlist) * MAX_DCMDS,
-				 GFP_KERNEL);
-	if (pmif->sg_table == NULL) {
-		pci_free_consistent(	hwif->pci_dev,
-					(MAX_DCMDS + 2) * sizeof(struct dbdma_cmd),
-				    	pmif->dma_table_cpu, pmif->dma_table_dma);
-		return;
-	}
 	hwif->ide_dma_off_quietly = &__ide_dma_off_quietly;
 	hwif->ide_dma_on = &__ide_dma_on;
 	hwif->ide_dma_check = &pmac_ide_dma_check;
-	hwif->ide_dma_read = &pmac_ide_dma_read;
-	hwif->ide_dma_write = &pmac_ide_dma_write;
-	hwif->ide_dma_begin = &pmac_ide_dma_begin;
+	hwif->dma_setup = &pmac_ide_dma_setup;
+	hwif->dma_exec_cmd = &pmac_ide_dma_exec_cmd;
+	hwif->dma_start = &pmac_ide_dma_start;
 	hwif->ide_dma_end = &pmac_ide_dma_end;
 	hwif->ide_dma_test_irq = &pmac_ide_dma_test_irq;
 	hwif->ide_dma_host_off = &pmac_ide_dma_host_off;
 	hwif->ide_dma_host_on = &pmac_ide_dma_host_on;
-	hwif->ide_dma_verbose = &__ide_dma_verbose;
 	hwif->ide_dma_timeout = &__ide_dma_timeout;
 	hwif->ide_dma_lostirq = &pmac_ide_dma_lostirq;
-
-#ifdef CONFIG_BLK_DEV_IDEDMA_PMAC_AUTO
-	if (!noautodma)
-		hwif->autodma = 1;
-#endif
-	hwif->drives[0].autodma = hwif->autodma;
-	hwif->drives[1].autodma = hwif->autodma;
 
 	hwif->atapi_dma = 1;
 	switch(pmif->kind) {
diff -Nru a/drivers/ide/setup-pci.c b/drivers/ide/setup-pci.c
--- a/drivers/ide/setup-pci.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/ide/setup-pci.c	2004-10-10 23:09:59 -07:00
@@ -185,20 +185,15 @@
 second_chance_to_dma:
 #endif /* CONFIG_BLK_DEV_IDEDMA_FORCED */
 
-	if ((hwif->mmio) && (hwif->dma_base))
+	if (hwif->mmio)
 		return hwif->dma_base;
 
 	if (hwif->mate && hwif->mate->dma_base) {
 		dma_base = hwif->mate->dma_base - (hwif->channel ? 0 : 8);
 	} else {
-		dma_base = (hwif->mmio) ?
-			((unsigned long) hwif->hwif_data) :
-			(pci_resource_start(dev, 4));
-		if (!dma_base) {
-			printk(KERN_ERR "%s: dma_base is invalid (0x%04lx)\n",
-				hwif->cds->name, dma_base);
-			dma_base = 0;
-		}
+		dma_base = pci_resource_start(dev, 4);
+		if (!dma_base)
+			printk(KERN_ERR "%s: dma_base is invalid\n", hwif->cds->name);
 	}
 
 #ifdef CONFIG_BLK_DEV_IDEDMA_FORCED
@@ -251,24 +246,13 @@
 				simplex_stat = hwif->INB(dma_base + 2);
 				if (simplex_stat & 0x80) {
 					/* simplex device? */
-#if 0					
 /*
  *	At this point we haven't probed the drives so we can't make the
  *	appropriate decision. Really we should defer this problem
  *	until we tune the drive then try to grab DMA ownership if we want
  *	to be the DMA end. This has to be become dynamic to handle hot
  *	plug.
- */
-					/* Don't enable DMA on a simplex channel with no drives */
-					if (!hwif->drives[0].present && !hwif->drives[1].present)
-					{
-						printk(KERN_INFO "%s: simplex device with no drives: DMA disabled\n",
-								hwif->cds->name);
-						dma_base = 0;
-					}
-					/* If our other channel has DMA then we cannot */
-					else 
-#endif					
+ */					
 					if(hwif->mate && hwif->mate->dma_base) 
 					{
 						printk(KERN_INFO "%s: simplex device: "
@@ -488,13 +472,8 @@
  			 * Set up BM-DMA capability
 			 * (PnP BIOS should have done this)
  			 */
-			if ((d->flags & IDEPCI_FLAG_FORCE_MASTER) == 0) {
-				/*
-				 * default DMA off if we had to
-				 * configure it here
-				 */
-				hwif->autodma = 0;
-			}
+			/* default DMA off if we had to configure it here */
+			hwif->autodma = 0;
 			pci_set_master(dev);
 			if (pci_read_config_word(dev, PCI_COMMAND, &pcicmd) || !(pcicmd & PCI_COMMAND_MASTER)) {
 				printk(KERN_ERR "%s: %s error updating PCICMD\n",
@@ -514,6 +493,11 @@
 		}
 	}
 }
+
+#ifndef CONFIG_IDEDMA_PCI_AUTO
+#warning CONFIG_IDEDMA_PCI_AUTO option is obsolete, and will be removed soon.
+#endif
+
 #endif /* CONFIG_BLK_DEV_IDEDMA_PCI*/
 
 /**
@@ -530,13 +514,9 @@
  
 static int ide_setup_pci_controller(struct pci_dev *dev, ide_pci_device_t *d, int noisy, int *config)
 {
-	int ret = 0;
 	u32 class_rev;
 	u16 pcicmd;
 
-	if (!noautodma)
-		ret = 1;
-
 	if (noisy)
 		ide_setup_pci_noise(dev, d);
 
@@ -550,8 +530,6 @@
 	if (!(pcicmd & PCI_COMMAND_IO)) {	/* is device disabled? */
 		if (ide_pci_configure(dev, d))
 			return -ENODEV;
-		/* default DMA off if we had to configure it here */
-		ret = 0;
 		*config = 1;
 		printk(KERN_INFO "%s: device enabled (Linux)\n", d->name);
 	}
@@ -560,14 +538,13 @@
 	class_rev &= 0xff;
 	if (noisy)
 		printk(KERN_INFO "%s: chipset revision %d\n", d->name, class_rev);
-	return ret;
+	return 0;
 }
 
 /**
  *	ide_pci_setup_ports	-	configure ports/devices on PCI IDE
  *	@dev: PCI device
  *	@d: IDE pci device info
- *	@autodma: Should we enable DMA
  *	@pciirq: IRQ line
  *	@index: ata index to update
  *
@@ -580,12 +557,11 @@
  *	where the chipset setup is not the default PCI IDE one.
  */
  
-void ide_pci_setup_ports(struct pci_dev *dev, ide_pci_device_t *d, int autodma, int pciirq, ata_index_t *index)
+void ide_pci_setup_ports(struct pci_dev *dev, ide_pci_device_t *d, int pciirq, ata_index_t *index)
 {
 	int port;
 	int at_least_one_hwif_enabled = 0;
 	ide_hwif_t *hwif, *mate = NULL;
-	static int secondpdc = 0;
 	u8 tmp;
 
 	index->all = 0xf0f0;
@@ -596,22 +572,10 @@
 	 
 	for (port = 0; port <= 1; ++port) {
 		ide_pci_enablebit_t *e = &(d->enablebits[port]);
-	
-		/* 
-		 * If this is a Promise FakeRaid controller,
-		 * the 2nd controller will be marked as 
-		 * disabled while it is actually there and enabled
-		 * by the bios for raid purposes. 
-		 * Skip the normal "is it enabled" test for those.
-		 */
-		if ((d->flags & IDEPCI_FLAG_FORCE_PDC) &&
-		    (secondpdc++==1) && (port==1))
-			goto controller_ok;
-			
+
 		if (e->reg && (pci_read_config_byte(dev, e->reg, &tmp) ||
 		    (tmp & e->mask) != e->val))
 			continue;	/* port not enabled */
-controller_ok:
 
 		if (d->channels	<= port)
 			break;
@@ -634,11 +598,7 @@
 
 		if (d->autodma == NODMA)
 			goto bypass_legacy_dma;
-		if (d->autodma == NOAUTODMA)
-			autodma = 0;
-		if (autodma)
-			hwif->autodma = 1;
-			
+
 		if(d->init_setup_dma)
 			d->init_setup_dma(dev, d, hwif);
 		else
@@ -671,12 +631,11 @@
  */
 static ata_index_t do_ide_setup_pci_device (struct pci_dev *dev, ide_pci_device_t *d, u8 noisy)
 {
-	int autodma = 0;
 	int pciirq = 0;
 	int tried_config = 0;
 	ata_index_t index = { .b = { .low = 0xff, .high = 0xff } };
 
-	if((autodma = ide_setup_pci_controller(dev, d, noisy, &tried_config)) < 0)
+	if (ide_setup_pci_controller(dev, d, noisy, &tried_config) < 0)
 		return index;
 
 	/*
@@ -724,7 +683,7 @@
 	if(pciirq < 0)		/* Error not an IRQ */
 		return index;
 
-	ide_pci_setup_ports(dev, d, autodma, pciirq, &index);
+	ide_pci_setup_ports(dev, d, pciirq, &index);
 
 	return index;
 }
diff -Nru a/drivers/scsi/ide-scsi.c b/drivers/scsi/ide-scsi.c
--- a/drivers/scsi/ide-scsi.c	2004-10-10 23:09:59 -07:00
+++ b/drivers/scsi/ide-scsi.c	2004-10-10 23:09:59 -07:00
@@ -45,6 +45,7 @@
 #include <linux/hdreg.h>
 #include <linux/slab.h>
 #include <linux/ide.h>
+#include <linux/scatterlist.h>
 
 #include <asm/io.h>
 #include <asm/bitops.h>
@@ -250,17 +251,6 @@
 		kfree(atapi_buf);
 }
 
-static inline void idescsi_free_bio (struct bio *bio)
-{
-	struct bio *bhp;
-
-	while (bio) {
-		bhp = bio;
-		bio = bio->bi_next;
-		bio_put(bhp);
-	}
-}
-
 static void hexdump(u8 *x, int len)
 {
 	int i;
@@ -418,7 +408,6 @@
 	spin_lock_irqsave(host->host_lock, flags);
 	pc->done(pc->scsi_cmd);
 	spin_unlock_irqrestore(host->host_lock, flags);
-	idescsi_free_bio(rq->bio);
 	kfree(pc);
 	kfree(rq);
 	scsi->pc = NULL;
@@ -552,6 +541,7 @@
 
 static ide_startstop_t idescsi_transfer_pc(ide_drive_t *drive)
 {
+	ide_hwif_t *hwif = drive->hwif;
 	idescsi_scsi_t *scsi = drive_to_idescsi(drive);
 	idescsi_pc_t *pc = scsi->pc;
 	atapi_ireason_t ireason;
@@ -576,20 +566,64 @@
 	atapi_output_bytes(drive, scsi->pc->c, 12);
 	if (test_bit (PC_DMA_OK, &pc->flags)) {
 		set_bit (PC_DMA_IN_PROGRESS, &pc->flags);
-		(void) (HWIF(drive)->ide_dma_begin(drive));
+		hwif->dma_start(drive);
 	}
 	return ide_started;
 }
 
+static inline int idescsi_set_direction(idescsi_pc_t *pc)
+{
+	switch (pc->c[0]) {
+		case READ_6: case READ_10: case READ_12:
+			clear_bit(PC_WRITING, &pc->flags);
+			return 0;
+		case WRITE_6: case WRITE_10: case WRITE_12:
+			set_bit(PC_WRITING, &pc->flags);
+			return 0;
+		default:
+			return 1;
+	}
+}
+
+static int idescsi_map_sg(ide_drive_t *drive, idescsi_pc_t *pc)
+{
+	ide_hwif_t *hwif = drive->hwif;
+	struct scatterlist *sg, *scsi_sg;
+	int segments;
+
+	if (!pc->request_transfer || pc->request_transfer % 1024)
+		return 1;
+
+	if (idescsi_set_direction(pc))
+		return 1;
+
+	sg = hwif->sg_table;
+	scsi_sg = pc->scsi_cmd->request_buffer;
+	segments = pc->scsi_cmd->use_sg;
+
+	if (segments > hwif->sg_max_nents)
+		return 1;
+
+	if (!segments) {
+		hwif->sg_nents = 1;
+		sg_init_one(sg, pc->scsi_cmd->request_buffer, pc->request_transfer);
+	} else {
+		hwif->sg_nents = segments;
+		memcpy(sg, scsi_sg, sizeof(*sg) * segments);
+	}
+
+	return 0;
+}
+
 /*
  *	Issue a packet command
  */
 static ide_startstop_t idescsi_issue_pc (ide_drive_t *drive, idescsi_pc_t *pc)
 {
 	idescsi_scsi_t *scsi = drive_to_idescsi(drive);
+	ide_hwif_t *hwif = drive->hwif;
 	atapi_feature_t feature;
 	atapi_bcount_t bcount;
-	struct request *rq = pc->rq;
 
 	scsi->pc=pc;							/* Set the current packet command */
 	pc->actually_transferred=0;					/* We haven't transferred any data yet */
@@ -597,11 +631,10 @@
 	bcount.all = min(pc->request_transfer, 63 * 1024);		/* Request to transfer the entire buffer at once */
 
 	feature.all = 0;
-	if (drive->using_dma && rq->bio) {
-		if (test_bit(PC_WRITING, &pc->flags))
-			feature.b.dma = !HWIF(drive)->ide_dma_write(drive);
-		else
-			feature.b.dma = !HWIF(drive)->ide_dma_read(drive);
+	if (drive->using_dma && !idescsi_map_sg(drive, pc)) {
+		hwif->sg_mapped = 1;
+		feature.b.dma = !hwif->dma_setup(drive);
+		hwif->sg_mapped = 0;
 	}
 
 	SELECT_DRIVE(drive);
@@ -774,81 +807,6 @@
 	return -EINVAL;
 }
 
-static inline struct bio *idescsi_kmalloc_bio (int count)
-{
-	struct bio *bh, *bhp, *first_bh;
-
-	if ((first_bh = bhp = bh = bio_alloc(GFP_ATOMIC, 1)) == NULL)
-		goto abort;
-	bio_init(bh);
-	bh->bi_vcnt = 1;
-	while (--count) {
-		if ((bh = bio_alloc(GFP_ATOMIC, 1)) == NULL)
-			goto abort;
-		bio_init(bh);
-		bh->bi_vcnt = 1;
-		bhp->bi_next = bh;
-		bhp = bh;
-		bh->bi_next = NULL;
-	}
-	return first_bh;
-abort:
-	idescsi_free_bio (first_bh);
-	return NULL;
-}
-
-static inline int idescsi_set_direction (idescsi_pc_t *pc)
-{
-	switch (pc->c[0]) {
-		case READ_6: case READ_10: case READ_12:
-			clear_bit (PC_WRITING, &pc->flags);
-			return 0;
-		case WRITE_6: case WRITE_10: case WRITE_12:
-			set_bit (PC_WRITING, &pc->flags);
-			return 0;
-		default:
-			return 1;
-	}
-}
-
-static inline struct bio *idescsi_dma_bio(ide_drive_t *drive, idescsi_pc_t *pc)
-{
-	struct bio *bh = NULL, *first_bh = NULL;
-	int segments = pc->scsi_cmd->use_sg;
-	struct scatterlist *sg = pc->scsi_cmd->request_buffer;
-
-	if (!drive->using_dma || !pc->request_transfer || pc->request_transfer % 1024)
-		return NULL;
-	if (idescsi_set_direction(pc))
-		return NULL;
-	if (segments) {
-		if ((first_bh = bh = idescsi_kmalloc_bio (segments)) == NULL)
-			return NULL;
-#if IDESCSI_DEBUG_LOG
-		printk ("ide-scsi: %s: building DMA table, %d segments, %dkB total\n", drive->name, segments, pc->request_transfer >> 10);
-#endif /* IDESCSI_DEBUG_LOG */
-		while (segments--) {
-			bh->bi_io_vec[0].bv_page = sg->page;
-			bh->bi_io_vec[0].bv_len = sg->length;
-			bh->bi_io_vec[0].bv_offset = sg->offset;
-			bh->bi_size = sg->length;
-			bh = bh->bi_next;
-			sg++;
-		}
-	} else {
-		if ((first_bh = bh = idescsi_kmalloc_bio (1)) == NULL)
-			return NULL;
-#if IDESCSI_DEBUG_LOG
-		printk ("ide-scsi: %s: building DMA table for a single buffer (%dkB)\n", drive->name, pc->request_transfer >> 10);
-#endif /* IDESCSI_DEBUG_LOG */
-		bh->bi_io_vec[0].bv_page = virt_to_page(pc->scsi_cmd->request_buffer);
-		bh->bi_io_vec[0].bv_offset = offset_in_page(pc->scsi_cmd->request_buffer);
-		bh->bi_io_vec[0].bv_len = pc->request_transfer;
-		bh->bi_size = pc->request_transfer;
-	}
-	return first_bh;
-}
-
 static inline int should_transform(ide_drive_t *drive, Scsi_Cmnd *cmd)
 {
 	idescsi_scsi_t *scsi = drive_to_idescsi(drive);
@@ -919,7 +877,6 @@
 
 	ide_init_drive_cmd (rq);
 	rq->special = (char *) pc;
-	rq->bio = idescsi_dma_bio (drive, pc);
 	rq->flags = REQ_SPECIAL;
 	spin_unlock_irq(host->host_lock);
 	(void) ide_do_drive_cmd (drive, rq, ide_end);
@@ -973,7 +930,6 @@
 		 */
 		printk (KERN_ERR "ide-scsi: cmd aborted!\n");
 
-		idescsi_free_bio(scsi->pc->rq->bio);
 		if (scsi->pc->rq->flags & REQ_SENSE)
 			kfree(scsi->pc->buffer);
 		kfree(scsi->pc->rq);
@@ -1022,7 +978,6 @@
 	/* kill current request */
 	blkdev_dequeue_request(req);
 	end_that_request_last(req);
-	idescsi_free_bio(req->bio);
 	if (req->flags & REQ_SENSE)
 		kfree(scsi->pc->buffer);
 	kfree(scsi->pc);
diff -Nru a/include/linux/hdreg.h b/include/linux/hdreg.h
--- a/include/linux/hdreg.h	2004-10-10 23:09:59 -07:00
+++ b/include/linux/hdreg.h	2004-10-10 23:09:59 -07:00
@@ -412,7 +412,8 @@
 #define HDIO_GET_IDENTITY	0x030d	/* get IDE identification info */
 #define HDIO_GET_WCACHE		0x030e	/* get write cache mode on|off */
 #define HDIO_GET_ACOUSTIC	0x030f	/* get acoustic value */
-#define	HDIO_GET_ADDRESS	0x0310	/* */
+
+/* 0x310 is reserved - used to be HDIO_GET_ADDRESS */
 
 #define HDIO_GET_BUSSTATE	0x031a	/* get the bus state of the hwif */
 #define HDIO_TRISTATE_HWIF	0x031b	/* execute a channel tristate */
@@ -437,7 +438,8 @@
 #define HDIO_SET_ACOUSTIC	0x032c	/* change acoustic behavior */
 #define HDIO_SET_BUSSTATE	0x032d	/* set the bus state of the hwif */
 #define HDIO_SET_QDMA		0x032e	/* change use-qdma flag */
-#define HDIO_SET_ADDRESS	0x032f	/* change lba addressing modes */
+
+/* 0x32f is reserved - used to be HDIO_SET_ADDRESS */
 
 /* bus states */
 enum {
diff -Nru a/include/linux/ide.h b/include/linux/ide.h
--- a/include/linux/ide.h	2004-10-10 23:09:59 -07:00
+++ b/include/linux/ide.h	2004-10-10 23:09:59 -07:00
@@ -242,7 +242,7 @@
 typedef enum {	ide_unknown,	ide_generic,	ide_pci,
 		ide_cmd640,	ide_dtc2278,	ide_ali14xx,
 		ide_qd65xx,	ide_umc8672,	ide_ht6560b,
-		ide_pdc4030,	ide_rz1000,	ide_trm290,
+		ide_rz1000,	ide_trm290,
 		ide_cmd646,	ide_cy82c693,	ide_4drives,
 		ide_pmac,	ide_etrax100,	ide_acorn,
 		ide_forced
@@ -739,7 +739,6 @@
 	unsigned remap_0_to_1	: 1;	/* 0=noremap, 1=remap 0->1 (for EZDrive) */
 	unsigned blocked        : 1;	/* 1=powermanagment told us not to do anything, so sleep nicely */
 	unsigned vdma		: 1;	/* 1=doing PIO over DMA 0=doing normal DMA */
-	unsigned stroke		: 1;	/* from:  hdx=stroke */
 	unsigned addressing;		/*      : 3;
 					 *  0=28-bit
 					 *  1=48-bit
@@ -781,7 +780,6 @@
 
 	u64		capacity64;	/* total number of sectors */
 
-	int		lun;		/* logical unit */
 	int		crc_count;	/* crc counter to reduce drive speed */
 	struct list_head list;
 	struct device	gendev;
@@ -789,27 +787,6 @@
 	struct gendisk *disk;
 } ide_drive_t;
 
-/*
- * mapping stuff, prepare for highmem...
- * 
- * temporarily mapping a (possible) highmem bio for PIO transfer
- */
-#ifndef CONFIG_IDE_TASKFILE_IO
-
-#define ide_rq_offset(rq) \
-	(((rq)->hard_cur_sectors - (rq)->current_nr_sectors) << 9)
-
-static inline void *ide_map_buffer(struct request *rq, unsigned long *flags)
-{
-	return bio_kmap_irq(rq->bio, flags) + ide_rq_offset(rq);
-}
-
-static inline void ide_unmap_buffer(struct request *rq, char *buffer, unsigned long *flags)
-{
-	bio_kunmap_irq(buffer, flags);
-}
-#endif /* !CONFIG_IDE_TASKFILE_IO */
-
 #define IDE_CHIPSET_PCI_MASK	\
     ((1<<ide_pci)|(1<<ide_cmd646)|(1<<ide_ali14xx))
 #define IDE_CHIPSET_IS_PCI(c)	((IDE_CHIPSET_PCI_MASK >> (c)) & 1)
@@ -853,8 +830,6 @@
 #if 0
 	ide_hwif_ops_t	*hwifops;
 #else
-	/* routine is for HBA specific IDENTITY operations */
-	int	(*identify)(ide_drive_t *);
 	/* routine to tune PIO mode for drives */
 	void	(*tuneproc)(ide_drive_t *, u8);
 	/* routine to retune DMA modes for drives */
@@ -887,9 +862,9 @@
 	void (*atapi_input_bytes)(ide_drive_t *, void *, u32);
 	void (*atapi_output_bytes)(ide_drive_t *, void *, u32);
 
-	int (*ide_dma_read)(ide_drive_t *drive);
-	int (*ide_dma_write)(ide_drive_t *drive);
-	int (*ide_dma_begin)(ide_drive_t *drive);
+	int (*dma_setup)(ide_drive_t *);
+	void (*dma_exec_cmd)(ide_drive_t *, u8);
+	void (*dma_start)(ide_drive_t *);
 	int (*ide_dma_end)(ide_drive_t *drive);
 	int (*ide_dma_check)(ide_drive_t *drive);
 	int (*ide_dma_on)(ide_drive_t *drive);
@@ -897,7 +872,6 @@
 	int (*ide_dma_test_irq)(ide_drive_t *drive);
 	int (*ide_dma_host_on)(ide_drive_t *drive);
 	int (*ide_dma_host_off)(ide_drive_t *drive);
-	int (*ide_dma_verbose)(ide_drive_t *drive);
 	int (*ide_dma_lostirq)(ide_drive_t *drive);
 	int (*ide_dma_timeout)(ide_drive_t *drive);
 
@@ -920,12 +894,18 @@
 	dma_addr_t	dmatable_dma;
 	/* Scatter-gather list used to build the above */
 	struct scatterlist *sg_table;
+	int sg_max_nents;		/* Maximum number of entries in it */
 	int sg_nents;			/* Current number of entries in it */
 	int sg_dma_direction;		/* dma transfer direction */
 
 	/* data phase of the active command (currently only valid for PIO/DMA) */
 	int		data_phase;
 
+	unsigned int nsect;
+	unsigned int nleft;
+	unsigned int cursg;
+	unsigned int cursg_ofs;
+
 	int		mmio;		/* hosts iomio (0) or custom (2) select */
 	int		rqsize;		/* max sectors per request */
 	int		irq;		/* our irq number */
@@ -955,6 +935,7 @@
 	unsigned	no_lba48_dma : 1; /* 1 = cannot do LBA48 DMA */
 	unsigned	no_dsc     : 1;	/* 0 default, 1 dsc_overlap disabled */
 	unsigned	auto_poll  : 1; /* supports nop auto-poll */
+	unsigned	sg_mapped  : 1;	/* sg_table and sg_nents are ready */
 
 	struct device	gendev;
 	struct semaphore gendev_rel_sem; /* To deal with device release() */
@@ -1319,9 +1300,6 @@
  */
 extern int ide_wait_cmd(ide_drive_t *, u8, u8, u8, u8, u8 *);
 
-/* (ide_drive_t *drive, u8 *buf) */
-extern int ide_wait_cmd_task(ide_drive_t *, u8 *);
-
 typedef struct ide_task_s {
 /*
  *	struct hd_drive_task_hdr	tf;
@@ -1334,6 +1312,7 @@
 	ide_reg_valid_t		tf_out_flags;
 	ide_reg_valid_t		tf_in_flags;
 	int			data_phase;
+	unsigned int		data_len;
 	int			command_type;
 	ide_pre_handler_t	*prehandler;
 	ide_handler_t		*handler;
@@ -1366,37 +1345,6 @@
 extern void ata_output_data(ide_drive_t *, void *, u32);
 extern void atapi_input_bytes(ide_drive_t *, void *, u32);
 extern void atapi_output_bytes(ide_drive_t *, void *, u32);
-extern void taskfile_input_data(ide_drive_t *, void *, u32);
-extern void taskfile_output_data(ide_drive_t *, void *, u32);
-
-#define IDE_PIO_IN	0
-#define IDE_PIO_OUT	1
-
-static inline void __task_sectors(ide_drive_t *drive, char *buf,
-				  unsigned nsect, unsigned rw)
-{
-	/*
-	 * IRQ can happen instantly after reading/writing
-	 * last sector of the datablock.
-	 */
-	if (rw == IDE_PIO_OUT)
-		taskfile_output_data(drive, buf, nsect * SECTOR_WORDS);
-	else
-		taskfile_input_data(drive, buf, nsect * SECTOR_WORDS);
-}
-
-#ifdef CONFIG_IDE_TASKFILE_IO
-static inline void task_bio_sectors(ide_drive_t *drive, struct request *rq,
-				    unsigned nsect, unsigned rw)
-{
-	unsigned long flags;
-	char *buf = rq_map_buffer(rq, &flags);
-
-	process_that_request_first(rq, nsect);
-	__task_sectors(drive, buf, nsect, rw);
-	rq_unmap_buffer(buf, &flags);
-}
-#endif /* CONFIG_IDE_TASKFILE_IO */
 
 extern int drive_is_ready(ide_drive_t *);
 extern int wait_for_ready(ide_drive_t *, int /* timeout */);
@@ -1468,7 +1416,7 @@
 extern void ide_scan_pcibus(int scan_direction) __init;
 extern int ide_pci_register_driver(struct pci_driver *driver);
 extern void ide_pci_unregister_driver(struct pci_driver *driver);
-extern void ide_pci_setup_ports(struct pci_dev *dev, struct ide_pci_device_s *d, int autodma, int pciirq, ata_index_t *index);
+void ide_pci_setup_ports(struct pci_dev *, struct ide_pci_device_s *, int, ata_index_t *);
 extern void ide_setup_pci_noise (struct pci_dev *dev, struct ide_pci_device_s *d);
 
 extern void default_hwif_iops(ide_hwif_t *);
@@ -1503,9 +1451,6 @@
 enum {
 	/* Uses ISA control ports not PCI ones. */
 	IDEPCI_FLAG_ISA_PORTS		= (1 << 0),
-
-	IDEPCI_FLAG_FORCE_MASTER	= (1 << 1),
-	IDEPCI_FLAG_FORCE_PDC		= (1 << 2),
 };
 
 typedef struct ide_pci_device_s {
@@ -1528,6 +1473,9 @@
 extern void ide_setup_pci_device(struct pci_dev *, ide_pci_device_t *);
 extern void ide_setup_pci_devices(struct pci_dev *, struct pci_dev *, ide_pci_device_t *);
 
+extern void ide_init_sg_cmd(ide_drive_t *, struct request *);
+void ide_map_sg(ide_drive_t *, struct request *);
+
 #define BAD_DMA_DRIVE		0
 #define GOOD_DMA_DRIVE		1
 
@@ -1535,34 +1483,32 @@
 int __ide_dma_bad_drive(ide_drive_t *);
 int __ide_dma_good_drive(ide_drive_t *);
 int __ide_dma_off(ide_drive_t *);
+void ide_dma_verbose(ide_drive_t *);
 
 #ifdef CONFIG_BLK_DEV_IDEDMA_PCI
 extern int ide_build_sglist(ide_drive_t *, struct request *);
-extern int ide_raw_build_sglist(ide_drive_t *, struct request *);
 extern int ide_build_dmatable(ide_drive_t *, struct request *);
 extern void ide_destroy_dmatable(ide_drive_t *);
 extern ide_startstop_t ide_dma_intr(ide_drive_t *);
 extern int ide_release_dma(ide_hwif_t *);
 extern void ide_setup_dma(ide_hwif_t *, unsigned long, unsigned int);
-extern int ide_start_dma(ide_hwif_t *, ide_drive_t *, int);
 
 extern int __ide_dma_host_off(ide_drive_t *);
 extern int __ide_dma_off_quietly(ide_drive_t *);
 extern int __ide_dma_host_on(ide_drive_t *);
 extern int __ide_dma_on(ide_drive_t *);
 extern int __ide_dma_check(ide_drive_t *);
-extern int __ide_dma_read(ide_drive_t *);
-extern int __ide_dma_write(ide_drive_t *);
-extern int __ide_dma_begin(ide_drive_t *);
+extern int ide_dma_setup(ide_drive_t *);
+extern void ide_dma_start(ide_drive_t *);
 extern int __ide_dma_end(ide_drive_t *);
 extern int __ide_dma_test_irq(ide_drive_t *);
-extern int __ide_dma_verbose(ide_drive_t *);
 extern int __ide_dma_lostirq(ide_drive_t *);
 extern int __ide_dma_timeout(ide_drive_t *);
 #endif /* CONFIG_BLK_DEV_IDEDMA_PCI */
 
 #else
 static inline int __ide_dma_off(ide_drive_t *drive) { return 0; }
+static inline void ide_dma_verbose(ide_drive_t *drive) { ; }
 #endif /* CONFIG_BLK_DEV_IDEDMA */
 
 #ifndef CONFIG_BLK_DEV_IDEDMA_PCI
@@ -1586,6 +1532,7 @@
 }
 
 /* ide-lib.c */
+int ide_use_dma(ide_drive_t *);
 extern u8 ide_dma_speed(ide_drive_t *drive, u8 mode);
 extern u8 ide_rate_filter(u8 mode, u8 speed); 
 extern int ide_dma_enable(ide_drive_t *drive);
diff -Nru a/include/linux/scatterlist.h b/include/linux/scatterlist.h
--- /dev/null	Wed Dec 31 16:00:00 196900
+++ b/include/linux/scatterlist.h	2004-10-10 23:09:59 -07:00
@@ -0,0 +1,14 @@
+#ifndef _LINUX_SCATTERLIST_H
+#define _LINUX_SCATTERLIST_H
+
+static inline void sg_init_one(struct scatterlist *sg,
+			       u8 *buf, unsigned int buflen)
+{
+	memset(sg, 0, sizeof(*sg));
+
+	sg->page = virt_to_page(buf);
+	sg->offset = offset_in_page(buf);
+	sg->length = buflen;
+}
+
+#endif /* _LINUX_SCATTERLIST_H */
