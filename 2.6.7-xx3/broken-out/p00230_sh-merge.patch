
From: Paul Mundt <lethal@Linux-SH.ORG>

This merges the remaining sh changes, random bug fixes, added syscalls, cache
fixups, etc.  Nothing really eventful.

Signed-off-by: Paul Mundt <lethal@linux-sh.org>
Signed-off-by: Andrew Morton <akpm@osdl.org>
---

 25-akpm/Documentation/sh/new-machine.txt |    8 -
 25-akpm/arch/sh/Kconfig                  |  126 ++++++++++++++++++--
 25-akpm/arch/sh/Makefile                 |   28 +++-
 25-akpm/arch/sh/boot/compressed/Makefile |    4 
 25-akpm/arch/sh/boot/compressed/misc.c   |   34 ++---
 25-akpm/arch/sh/kernel/cpu/Makefile      |    2 
 25-akpm/arch/sh/kernel/cpu/bus.c         |  195 +++++++++++++++++++++++++++++++
 25-akpm/arch/sh/kernel/cpu/init.c        |   60 +++++----
 25-akpm/arch/sh/kernel/entry.S           |   10 +
 25-akpm/arch/sh/kernel/io_generic.c      |   58 ++++++++-
 25-akpm/arch/sh/kernel/irq.c             |   43 ++++++
 25-akpm/arch/sh/kernel/process.c         |   35 ++++-
 25-akpm/arch/sh/kernel/ptrace.c          |    9 -
 25-akpm/arch/sh/kernel/setup.c           |  159 +++----------------------
 25-akpm/arch/sh/kernel/sh_ksyms.c        |    4 
 25-akpm/arch/sh/kernel/traps.c           |    6 
 25-akpm/arch/sh/kernel/vmlinux.lds.S     |    8 +
 25-akpm/arch/sh/lib/delay.c              |    6 
 25-akpm/arch/sh/mm/cache-sh3.c           |   14 +-
 25-akpm/arch/sh/mm/cache-sh4.c           |   56 +++-----
 25-akpm/arch/sh/mm/tlb-sh3.c             |    2 
 25-akpm/arch/sh/ramdisk/Makefile         |   19 +++
 25-akpm/arch/sh/ramdisk/ld.script        |    9 +
 25-akpm/arch/sh/tools/mach-types         |    3 
 25-akpm/include/asm-sh/bus-sh.h          |   65 ++++++++++
 25-akpm/include/asm-sh/cache.h           |    3 
 25-akpm/include/asm-sh/cpu-sh3/dac.h     |    7 -
 25-akpm/include/asm-sh/processor.h       |    3 
 25-akpm/include/asm-sh/serial.h          |    3 
 25-akpm/include/asm-sh/sigcontext.h      |   22 +++
 25-akpm/include/asm-sh/unistd.h          |   12 +
 31 files changed, 732 insertions(+), 281 deletions(-)

diff -puN arch/sh/boot/compressed/Makefile~sh-merge arch/sh/boot/compressed/Makefile
--- 25/arch/sh/boot/compressed/Makefile~sh-merge	2004-06-23 20:00:21.205466304 -0700
+++ 25-akpm/arch/sh/boot/compressed/Makefile	2004-06-23 20:00:21.249459616 -0700
@@ -15,7 +15,11 @@ endif
 
 #
 # IMAGE_OFFSET is the load offset of the compression loader
+# Assign dummy values if these 2 variables are not defined,
+# in order to suppress error message.
 #
+CONFIG_MEMORY_START     ?= 0x0c000000
+CONFIG_BOOT_LINK_OFFSET ?= 0x00800000
 IMAGE_OFFSET := $(shell printf "0x%8x" $$[0x80000000+$(CONFIG_MEMORY_START)+$(CONFIG_BOOT_LINK_OFFSET)])
 
 LDFLAGS_vmlinux := -Ttext $(IMAGE_OFFSET) -e startup -T $(obj)/../../kernel/vmlinux.lds.s
diff -puN arch/sh/boot/compressed/misc.c~sh-merge arch/sh/boot/compressed/misc.c
--- 25/arch/sh/boot/compressed/misc.c~sh-merge	2004-06-23 20:00:21.207466000 -0700
+++ 25-akpm/arch/sh/boot/compressed/misc.c	2004-06-23 20:00:21.250459464 -0700
@@ -1,7 +1,7 @@
 /*
  * arch/sh/boot/compressed/misc.c
- * 
- * This is a collection of several routines from gzip-1.0.3 
+ *
+ * This is a collection of several routines from gzip-1.0.3
  * adapted for Linux.
  *
  * malloc by Hannu Savolainen 1993 and Matthias Urlichs 1994
@@ -52,7 +52,7 @@ static unsigned outcnt = 0;  /* bytes in
 #define RESERVED     0xC0 /* bit 6,7:   reserved */
 
 #define get_byte()  (inptr < insize ? inbuf[inptr++] : fill_inbuf())
-		
+
 /* Diagnostic functions */
 #ifdef DEBUG
 #  define Assert(cond,msg) {if(!(cond)) error(msg);}
@@ -75,7 +75,7 @@ static void flush_window(void);
 static void error(char *m);
 static void gzip_mark(void **);
 static void gzip_release(void **);
-  
+
 extern char input_data[];
 extern int input_len;
 
@@ -83,20 +83,19 @@ static long bytes_out = 0;
 static uch *output_data;
 static unsigned long output_ptr = 0;
 
- 
 static void *malloc(int size);
 static void free(void *where);
 static void error(char *m);
 static void gzip_mark(void **);
 static void gzip_release(void **);
- 
-static void puts(const char *);
-  
+
+int puts(const char *);
+
 extern int _text;		/* Defined in vmlinux.lds.S */
 extern int _end;
 static unsigned long free_mem_ptr;
 static unsigned long free_mem_end_ptr;
- 
+
 #define HEAP_SIZE             0x10000
 
 #include "../../../../lib/inflate.c"
@@ -134,7 +133,7 @@ static void gzip_release(void **ptr)
 }
 
 #ifdef CONFIG_SH_STANDARD_BIOS
-static int strlen(const char *s)
+size_t strlen(const char *s)
 {
 	int i = 0;
 
@@ -143,14 +142,17 @@ static int strlen(const char *s)
 	return i;
 }
 
-void puts(const char *s)
+int puts(const char *s)
 {
-	sh_bios_console_write(s, strlen(s));
+	int len = strlen(s);
+	sh_bios_console_write(s, len);
+	return len;
 }
 #else
-void puts(const char *s)
+int puts(const char *s)
 {
-  /* This should be updated to use the sh-sci routines */
+	/* This should be updated to use the sh-sci routines */
+	return 0;
 }
 #endif
 
@@ -198,9 +200,9 @@ static void flush_window(void)
     ulg c = crc;         /* temporary variable */
     unsigned n;
     uch *in, *out, ch;
-    
+
     in = window;
-    out = &output_data[output_ptr]; 
+    out = &output_data[output_ptr];
     for (n = 0; n < outcnt; n++) {
 	    ch = *out++ = *in++;
 	    c = crc_32_tab[((int)c ^ ch) & 0xff] ^ (c >> 8);
diff -puN arch/sh/Kconfig~sh-merge arch/sh/Kconfig
--- 25/arch/sh/Kconfig~sh-merge	2004-06-23 20:00:21.209465696 -0700
+++ 25-akpm/arch/sh/Kconfig	2004-06-23 20:00:21.252459160 -0700
@@ -45,6 +45,12 @@ config SH_7751_SOLUTION_ENGINE
 	  Select 7751 SolutionEngine if configuring for a Hitachi SH7751
 	  evalutation board.
 
+config SH_7300_SOLUTION_ENGINE
+	bool "SolutionEngine7300"
+	help
+	  Select 7300 SolutionEngine if configuring for a Hitachi SH7300(SH-Mobile V)
+	  evalutation board.
+
 config SH_7751_SYSTEMH
 	bool "SystemH7751R"
 	help
@@ -138,6 +144,18 @@ config SH_SECUREEDGE5410
 	  This includes both the OEM SecureEdge products as well as the
 	  SME product line.
 
+config SH_HS7751RVOIP
+	bool "HS7751RVOIP"
+	help
+	  Select HS7751RVOIP if configuring for a Renesas Technology
+	  Sales VoIP board.
+
+config SH_RTS7751R2D
+	bool "RTS7751R2D"
+	help
+	  Select RTS7751R2D if configuring for a Renesas Technology
+	  Sales SH-Graphics board.
+
 config SH_UNKNOWN
 	bool "BareCPU"
 	help
@@ -186,7 +204,11 @@ config CPU_SUBTYPE_SH7604
 config CPU_SUBTYPE_SH7300
 	bool "SH7300"
 	depends on CPU_SH3
-	  
+
+config CPU_SUBTYPE_SH7705
+	bool "SH7705"
+	depends on CPU_SH3
+
 config CPU_SUBTYPE_SH7707
 	bool "SH7707"
 	depends on CPU_SH3
@@ -224,10 +246,17 @@ config CPU_SUBTYPE_SH7760
 	depends on CPU_SH4
 
 config CPU_SUBTYPE_ST40STB1
-	bool "ST40STB1"
-	depends on CPU_SH4
-	help
-	  Select ST40STB1 if you have a ST40STB1 CPU.
+       bool "ST40STB1 / ST40RA"
+       depends on CPU_SH4
+       help
+         Select ST40STB1 if you have a ST40RA CPU.
+         This was previously called the ST40STB1, hence the option name.
+
+config CPU_SUBTYPE_ST40GX1
+       bool "ST40GX1"
+       depends on CPU_SH4
+       help
+         Select ST40GX1 if you have a ST40GX1 CPU.
 
 endchoice
 
@@ -268,7 +297,7 @@ config CMDLINE
 config MEMORY_START
 	hex "Physical memory start address" if !MEMORY_SET || MEMORY_OVERRIDE
 	default "0x08000000" if !MEMORY_SET || MEMORY_OVERRIDE || !MEMORY_OVERRIDE && SH_ADX || SH_MPC1211 || SH_SECUREEDGE5410
-	default "0x0c000000" if !MEMORY_OVERRIDE && (SH_DREAMCAST || SH_HP600 || SH_BIGSUR || SH_SH2000 || SH_7751_SOLUTION_ENGINE || SH_SOLUTION_ENGINE)
+	default "0x0c000000" if !MEMORY_OVERRIDE && (SH_DREAMCAST || SH_HP600 || SH_BIGSUR || SH_SH2000 || SH_7751_SOLUTION_ENGINE || SH_SOLUTION_ENGINE || SH_HS7751RVOIP || SH_RTS7751R2D)
 	---help---
 	  Computers built with Hitachi SuperH processors always
 	  map the ROM starting at address zero.  But the processor
@@ -287,7 +316,7 @@ config MEMORY_SIZE
 	hex "Physical memory size" if !MEMORY_SET || MEMORY_OVERRIDE
 	default "0x00400000" if !MEMORY_SET || MEMORY_OVERRIDE || !MEMORY_OVERRIDE && SH_ADX || !MEMORY_OVERRIDE && (SH_HP600 || SH_BIGSUR || SH_SH2000)
 	default "0x01000000" if !MEMORY_OVERRIDE && SH_DREAMCAST || SH_SECUREEDGE5410
-	default "0x04000000" if !MEMORY_OVERRIDE && SH_7751_SOLUTION_ENGINE
+	default "0x04000000" if !MEMORY_OVERRIDE && (SH_7751_SOLUTION_ENGINE || SH_HS7751RVOIP || SH_RTS7751R2D)
 	default "0x02000000" if !MEMORY_OVERRIDE && SH_SOLUTION_ENGINE
 	default "0x08000000" if SH_MPC1211
 	help
@@ -299,7 +328,7 @@ config MEMORY_SIZE
 
 config MEMORY_SET
 	bool
-	depends on !MEMORY_OVERRIDE && (SH_MPC1211 || SH_ADX || SH_DREAMCAST || SH_HP600 || SH_BIGSUR || SH_SH2000 || SH_7751_SOLUTION_ENGINE || SH_SOLUTION_ENGINE || SH_SECUREEDGE5410)
+	depends on !MEMORY_OVERRIDE && (SH_MPC1211 || SH_ADX || SH_DREAMCAST || SH_HP600 || SH_BIGSUR || SH_SH2000 || SH_7751_SOLUTION_ENGINE || SH_SOLUTION_ENGINE || SH_SECUREEDGE5410 || SH_HS7751RVOIP || SH_RTS7751R2D)
 	default y
 	help
 	  This is an option about which you will never be asked a question.
@@ -358,7 +387,7 @@ config CF_BASE_ADDR
 # The SH7750 RTC module is disabled in the Dreamcast
 config SH_RTC
 	bool
-	depends on !SH_DREAMCAST && !SH_SATURN
+	depends on !SH_DREAMCAST && !SH_SATURN && !SH_7300_SOLUTION_ENGINE
 	default y
 	help
 	  Selecting this option will allow the Linux kernel to emulate
@@ -377,11 +406,26 @@ config SH_DSP
 
 	  This option must be set in order to enable the DSP.
 
+config SH_ADC
+	bool "ADC support"
+	depends on CPU_SH3
+	default y
+	help
+	  Selecting this option will allow the Linux kernel to use SH3 on-chip
+	  ADC module.
+
+	  If unsure, say N.
+
 config SH_HP600
 	bool
 	depends on SH_HP620 || SH_HP680 || SH_HP690
 	default y
 
+config CPU_SUBTYPE_ST40
+       bool
+       depends on CPU_SUBTYPE_ST40STB1 || CPU_SUBTYPE_ST40GX1
+       default y
+
 config DISCONTIGMEM
 	bool
 	depends on SH_HP690
@@ -514,10 +558,32 @@ config NR_CPUS
 	  This is purely to save memory - each supported CPU adds
 	  approximately eight kilobytes to the kernel image.
 
+config HS7751RVOIP_CODEC
+	bool "Support VoIP Codec section"
+	depends on SH_HS7751RVOIP
+	help
+	  Selecting this option will support CODEC section.
+
+config RTS7751R2D_REV11
+	bool "RTS7751R2D Rev. 1.1 board support"
+	depends on SH_RTS7751R2D
+	help
+	  Selecting this option will support version rev. 1.1.
+
+config SH_PCLK_CALC
+	bool
+	default n if CPU_SUBTYPE_SH7300
+	default y
+	help
+	  This option will cause the PCLK value to be probed at run-time. It
+	  will display a notification if the probed value has greater than a
+	  1% variance of the hardcoded CONFIG_SH_PCLK_FREQ.
+
 config SH_PCLK_FREQ
 	int "Peripheral clock frequency (in Hz)"
 	default "49876504" if CPU_SUBTYPE_SH7750
 	default "60013568" if CPU_SUBTYPE_SH7751
+	default "33333333" if CPU_SUBTYPE_SH7300
 	default "1193182"
 	help
 	  This option is used to specify the peripheral clock frequency. This
@@ -570,12 +636,18 @@ source "arch/sh/cchips/Kconfig"
 
 config HEARTBEAT
 	bool "Heartbeat LED"
-	depends on SH_MPC1211 || SH_CAT68701 || SH_STB1_HARP || SH_STB1_OVERDRIVE || SH_BIGSUR || SH_7751_SOLUTION_ENGINE || SH_SOLUTION_ENGINE
+	depends on SH_MPC1211 || SH_CAT68701 || SH_STB1_HARP || SH_STB1_OVERDRIVE || SH_BIGSUR || SH_7751_SOLUTION_ENGINE || SH_7300_SOLUTION_ENGINE || SH_SOLUTION_ENGINE || SH_RTS7751R2D
 	help
 	  Use the power-on LED on your machine as a load meter.  The exact
 	  behavior is platform-dependent, but normally the flash frequency is
 	  a hyperbolic function of the 5-minute load average.
 
+config RTC_9701JE
+	tristate "EPSON RTC-9701JE support"
+	depends on SH_RTS7751R2D
+	help
+	  Selecting this option will support EPSON RTC-9701JE.
+
 endmenu
 
 
@@ -646,6 +718,24 @@ source "fs/Kconfig.binfmt"
 
 endmenu
 
+menu "SH initrd options"
+	depends on BLK_DEV_INITRD
+
+config EMBEDDED_RAMDISK
+	bool "Embed root filesystem ramdisk into the kernel"
+
+config EMBEDDED_RAMDISK_IMAGE
+	string "Filename of gziped ramdisk image"
+	depends on EMBEDDED_RAMDISK
+	default "ramdisk.gz"
+	help
+	  This is the filename of the ramdisk image to be built into the
+	  kernel.  Relative pathnames are relative to arch/mips/ramdisk/.
+	  The ramdisk image is not part of the kernel distribution; you must
+	  provide one yourself.
+
+endmenu
+
 source "drivers/Kconfig"
 
 source "fs/Kconfig"
@@ -675,6 +765,14 @@ config DEBUG_SPINLOCK
 	  best used in conjunction with the NMI watchdog so that spinlock
 	  deadlocks are also debuggable.
 
+config DEBUG_INFO
+        bool "Compile the kernel with debug info"
+        help
+          If you say Y here the resulting kernel image will include
+          debugging info resulting in a larger kernel image.
+          Say Y here only if you plan to use gdb to debug the kernel.
+          If you don't debug the kernel, you can say N.
+
 config SH_STANDARD_BIOS
 	bool "Use LinuxSH standard BIOS"
 	help
@@ -688,9 +786,13 @@ config SH_STANDARD_BIOS
 	  mask ROM and no flash (WindowsCE machines fall in this category).
 	  If unsure, say N.
 
-config SH_EARLY_PRINTK
+config EARLY_SCIF_CONSOLE
+	bool "Use early SCIF console"
+	depends on CPU_SH4
+
+config EARLY_PRINTK
 	bool "Early printk support"
-	depends on SH_STANDARD_BIOS
+	depends on SH_STANDARD_BIOS || EARLY_SCIF_CONSOLE
 	help
 	  Say Y here to redirect kernel printk messages to the serial port
 	  used by the SH-IPL bootloader, starting very early in the boot
diff -puN /dev/null arch/sh/kernel/cpu/bus.c
--- /dev/null	2003-09-15 06:40:47.000000000 -0700
+++ 25-akpm/arch/sh/kernel/cpu/bus.c	2004-06-23 20:00:21.253459008 -0700
@@ -0,0 +1,195 @@
+/*
+ * arch/sh/kernel/cpu/bus.c
+ *
+ * Virtual bus for SuperH.
+ *
+ * Copyright (C) 2004 Paul Mundt
+ *
+ * Shamelessly cloned from arch/arm/mach-omap/bus.c, which was written
+ * by:
+ *
+ *  	Copyright (C) 2003 - 2004 Nokia Corporation
+ *  	Written by Tony Lindgren <tony@atomide.com>
+ *  	Portions of code based on sa1111.c.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ */
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <asm/bus-sh.h>
+
+static int sh_bus_match(struct device *dev, struct device_driver *drv)
+{
+	struct sh_driver *shdrv = to_sh_driver(drv);
+	struct sh_dev *shdev = to_sh_dev(dev);
+
+	return shdev->dev_id == shdrv->dev_id;
+}
+
+static int sh_bus_suspend(struct device *dev, u32 state)
+{
+	struct sh_dev *shdev = to_sh_dev(dev);
+	struct sh_driver *shdrv = to_sh_driver(dev->driver);
+
+	if (shdrv && shdrv->suspend)
+		return shdrv->suspend(shdev, state);
+
+	return 0;
+}
+
+static int sh_bus_resume(struct device *dev)
+{
+	struct sh_dev *shdev = to_sh_dev(dev);
+	struct sh_driver *shdrv = to_sh_driver(dev->driver);
+
+	if (shdrv && shdrv->resume)
+		return shdrv->resume(shdev);
+
+	return 0;
+}
+
+static struct device sh_bus_devices[SH_NR_BUSES] = {
+	{
+		.bus_id		= SH_BUS_NAME_VIRT,
+	},
+};
+
+struct bus_type sh_bus_types[SH_NR_BUSES] = {
+	{
+		.name		= SH_BUS_NAME_VIRT,
+		.match		= sh_bus_match,
+		.suspend	= sh_bus_suspend,
+		.resume		= sh_bus_resume,
+	},
+};
+
+static int sh_device_probe(struct device *dev)
+{
+	struct sh_dev *shdev = to_sh_dev(dev);
+	struct sh_driver *shdrv = to_sh_driver(dev->driver);
+
+	if (shdrv && shdrv->probe)
+		return shdrv->probe(shdev);
+
+	return -ENODEV;
+}
+
+static int sh_device_remove(struct device *dev)
+{
+	struct sh_dev *shdev = to_sh_dev(dev);
+	struct sh_driver *shdrv = to_sh_driver(dev->driver);
+
+	if (shdrv && shdrv->remove)
+		return shdrv->remove(shdev);
+
+	return 0;
+}
+
+int sh_device_register(struct sh_dev *dev)
+{
+	if (!dev)
+		return -EINVAL;
+
+	if (dev->bus_id < 0 || dev->bus_id >= SH_NR_BUSES) {
+		printk(KERN_ERR "%s: bus_id invalid: %s bus: %d\n",
+		       __FUNCTION__, dev->name, dev->bus_id);
+		return -EINVAL;
+	}
+
+	dev->dev.parent = &sh_bus_devices[dev->bus_id];
+	dev->dev.bus    = &sh_bus_types[dev->bus_id];
+
+	/* This is needed for USB OHCI to work */
+	if (dev->dma_mask)
+		dev->dev.dma_mask = dev->dma_mask;
+
+	snprintf(dev->dev.bus_id, BUS_ID_SIZE, "%s%u",
+		 dev->name, dev->dev_id);
+
+	printk(KERN_INFO "Registering SH device '%s'. Parent at %s\n",
+	       dev->dev.bus_id, dev->dev.parent->bus_id);
+
+	return device_register(&dev->dev);
+}
+
+void sh_device_unregister(struct sh_dev *dev)
+{
+	device_unregister(&dev->dev);
+}
+
+int sh_driver_register(struct sh_driver *drv)
+{
+	if (!drv)
+		return -EINVAL;
+
+	if (drv->bus_id < 0 || drv->bus_id >= SH_NR_BUSES) {
+		printk(KERN_ERR "%s: bus_id invalid: bus: %d device %d\n",
+		       __FUNCTION__, drv->bus_id, drv->dev_id);
+		return -EINVAL;
+	}
+
+	drv->drv.probe  = sh_device_probe;
+	drv->drv.remove = sh_device_remove;
+	drv->drv.bus    = &sh_bus_types[drv->bus_id];
+
+	return driver_register(&drv->drv);
+}
+
+void sh_driver_unregister(struct sh_driver *drv)
+{
+	driver_unregister(&drv->drv);
+}
+
+static int __init sh_bus_init(void)
+{
+	int i, ret = 0;
+
+	for (i = 0; i < SH_NR_BUSES; i++) {
+		ret = device_register(&sh_bus_devices[i]);
+		if (ret != 0) {
+			printk(KERN_ERR "Unable to register bus device %s\n",
+			       sh_bus_devices[i].bus_id);
+			continue;
+		}
+
+		ret = bus_register(&sh_bus_types[i]);
+		if (ret != 0) {
+			printk(KERN_ERR "Unable to register bus %s\n",
+			       sh_bus_types[i].name);
+			device_unregister(&sh_bus_devices[i]);
+		}
+	}
+
+	printk(KERN_INFO "SH Virtual Bus initialized\n");
+
+	return ret;
+}
+
+static void __exit sh_bus_exit(void)
+{
+	int i;
+
+	for (i = 0; i < SH_NR_BUSES; i++) {
+		bus_unregister(&sh_bus_types[i]);
+		device_unregister(&sh_bus_devices[i]);
+	}
+}
+
+module_init(sh_bus_init);
+module_exit(sh_bus_exit);
+
+MODULE_AUTHOR("Paul Mundt <lethal@linux-sh.org>");
+MODULE_DESCRIPTION("SH Virtual Bus");
+MODULE_LICENSE("GPL");
+
+EXPORT_SYMBOL(sh_bus_types);
+EXPORT_SYMBOL(sh_device_register);
+EXPORT_SYMBOL(sh_device_unregister);
+EXPORT_SYMBOL(sh_driver_register);
+EXPORT_SYMBOL(sh_driver_unregister);
+
diff -puN arch/sh/kernel/cpu/init.c~sh-merge arch/sh/kernel/cpu/init.c
--- 25/arch/sh/kernel/cpu/init.c~sh-merge	2004-06-23 20:00:21.211465392 -0700
+++ 25-akpm/arch/sh/kernel/cpu/init.c	2004-06-23 20:00:21.253459008 -0700
@@ -42,7 +42,7 @@ onchip_setup(dsp);
  */
 static void __init cache_init(void)
 {
-	unsigned long ccr, flags = 0;
+	unsigned long ccr, flags;
 
 	if (cpu_data->type == CPU_SH_NONE)
 		panic("Unknown CPU");
@@ -54,42 +54,50 @@ static void __init cache_init(void)
 	 * If the cache is already enabled .. flush it.
 	 */
 	if (ccr & CCR_CACHE_ENABLE) {
-		unsigned long entries, i, j;
+		unsigned long ways, waysize, addrstart;
 
-		entries = cpu_data->dcache.sets;
+		waysize = cpu_data->dcache.sets;
 
 		/*
 		 * If the OC is already in RAM mode, we only have
 		 * half of the entries to flush..
 		 */
 		if (ccr & CCR_CACHE_ORA)
-			entries >>= 1;
+			waysize >>= 1;
 
-		for (i = 0; i < entries; i++) {
-			for (j = 0; j < cpu_data->dcache.ways; j++) {
-				unsigned long data, addr;
-
-				addr = CACHE_OC_ADDRESS_ARRAY |
-					(j << cpu_data->dcache.way_shift) |
-					(i << cpu_data->dcache.entry_shift);
-
-				data = ctrl_inl(addr);
-
-				if ((data & (SH_CACHE_UPDATED | SH_CACHE_VALID))
-					== (SH_CACHE_UPDATED | SH_CACHE_VALID))
-					ctrl_outl(data & ~SH_CACHE_UPDATED, addr);
-			}
-		}
+		waysize <<= cpu_data->dcache.entry_shift;
+
+#ifdef CCR_CACHE_EMODE
+		/* If EMODE is not set, we only have 1 way to flush. */
+		if (!(ccr & CCR_CACHE_EMODE))
+			ways = 1;
+		else
+#endif
+			ways = cpu_data->dcache.ways;
+
+		addrstart = CACHE_OC_ADDRESS_ARRAY;
+		do {
+			unsigned long addr;
+
+			for (addr = addrstart;
+			     addr < addrstart + waysize;
+			     addr += cpu_data->dcache.linesz)
+				ctrl_outl(0, addr);
+
+			addrstart += cpu_data->dcache.way_incr;
+		} while (--ways);
 	}
 
 	/* 
 	 * Default CCR values .. enable the caches
-	 * and flush them immediately..
+	 * and invalidate them immediately..
 	 */
-	flags |= CCR_CACHE_ENABLE | CCR_CACHE_INVALIDATE;
-	
+	flags = CCR_CACHE_ENABLE | CCR_CACHE_INVALIDATE;
+
 #ifdef CCR_CACHE_EMODE
-	flags |= (ccr & CCR_CACHE_EMODE);
+	/* Force EMODE if possible */
+	if (cpu_data->dcache.ways > 1)
+		flags |= CCR_CACHE_EMODE;
 #endif
 
 #ifdef CONFIG_SH_WRITETHROUGH
@@ -145,8 +153,8 @@ static void __init dsp_init(void)
 
 	/* If the DSP bit is still set, this CPU has a DSP */
 	if (sr & SR_DSP)
-		set_bit(CPU_HAS_DSP, &(cpu_data->flags));
-	
+		cpu_data->flags |= CPU_HAS_DSP;
+
 	/* Now that we've determined the DSP status, clear the DSP bit. */
 	release_dsp();
 }
@@ -184,7 +192,7 @@ asmlinkage void __init sh_cpu_init(void)
 	}
 
 	/* FPU initialization */
-	if (test_bit(CPU_HAS_FPU, &(cpu_data->flags))) {
+	if ((cpu_data->flags & CPU_HAS_FPU)) {
 		clear_thread_flag(TIF_USEDFPU);
 		current->used_math = 0;
 	}
diff -puN arch/sh/kernel/cpu/Makefile~sh-merge arch/sh/kernel/cpu/Makefile
--- 25/arch/sh/kernel/cpu/Makefile~sh-merge	2004-06-23 20:00:21.213465088 -0700
+++ 25-akpm/arch/sh/kernel/cpu/Makefile	2004-06-23 20:00:21.254458856 -0700
@@ -2,7 +2,7 @@
 # Makefile for the Linux/SuperH CPU-specifc backends.
 #
 
-obj-y	:= irq_ipr.o irq_imask.o init.o
+obj-y	:= irq_ipr.o irq_imask.o init.o bus.o
 
 obj-$(CONFIG_CPU_SH2)		+= sh2/
 obj-$(CONFIG_CPU_SH3)		+= sh3/
diff -puN arch/sh/kernel/entry.S~sh-merge arch/sh/kernel/entry.S
--- 25/arch/sh/kernel/entry.S~sh-merge	2004-06-23 20:00:21.215464784 -0700
+++ 25-akpm/arch/sh/kernel/entry.S	2004-06-23 20:00:21.255458704 -0700
@@ -1130,6 +1130,14 @@ ENTRY(sys_call_table)
 	.long sys_utimes
  	.long sys_fadvise64_64_wrapper
 	.long sys_ni_syscall	/* Reserved for vserver */
-	.long sys_ni_syscall
+	.long sys_ni_syscall	/* Reserved for mbind */
+	.long sys_ni_syscall	/* 275 - get_mempolicy */
+	.long sys_ni_syscall	/* set_mempolicy */
+	.long sys_mq_open
+	.long sys_mq_unlink
+	.long sys_mq_timedsend
+	.long sys_mq_timedreceive       /* 280 */
+	.long sys_mq_notify
+	.long sys_mq_getsetattr
 
 /* End of entry.S */
diff -puN arch/sh/kernel/io_generic.c~sh-merge arch/sh/kernel/io_generic.c
--- 25/arch/sh/kernel/io_generic.c~sh-merge	2004-06-23 20:00:21.216464632 -0700
+++ 25-akpm/arch/sh/kernel/io_generic.c	2004-06-23 20:00:21.255458704 -0700
@@ -1,4 +1,4 @@
-/* $Id: io_generic.c,v 1.1.1.1.4.2.2.1 2003/01/10 17:26:56 lethal Exp $
+/* $Id: io_generic.c,v 1.2 2003/05/04 19:29:53 lethal Exp $
  *
  * linux/arch/sh/kernel/io_generic.c
  *
@@ -71,16 +71,32 @@ unsigned int generic_inl_p(unsigned long
 	return v;
 }
 
+/*
+ * insb/w/l all read a series of bytes/words/longs from a fixed port
+ * address. However as the port address doesn't change we only need to
+ * convert the port address to real address once.
+ */
+
 void generic_insb(unsigned long port, void *buffer, unsigned long count)
 {
+	volatile unsigned char *port_addr;
 	unsigned char *buf=buffer;
-	while(count--) *buf++=inb(port);
+
+	port_addr = (volatile unsigned char *)PORT2ADDR(port);
+
+	while(count--)
+	    *buf++ = *port_addr;
 }
 
 void generic_insw(unsigned long port, void *buffer, unsigned long count)
 {
+	volatile unsigned short *port_addr;
 	unsigned short *buf=buffer;
-	while(count--) *buf++=inw(port);
+
+	port_addr = (volatile unsigned short *)PORT2ADDR(port);
+
+	while(count--)
+	    *buf++ = *port_addr;
 #ifdef SH3_PCMCIA_BUG_WORKAROUND
 	ctrl_inb (DUMMY_READ_AREA6);
 #endif
@@ -88,8 +104,13 @@ void generic_insw(unsigned long port, vo
 
 void generic_insl(unsigned long port, void *buffer, unsigned long count)
 {
+	volatile unsigned long *port_addr;
 	unsigned long *buf=buffer;
-	while(count--) *buf++=inl(port);
+
+	port_addr = (volatile unsigned long *)PORT2ADDR(port);
+
+	while(count--)
+	    *buf++ = *port_addr;
 #ifdef SH3_PCMCIA_BUG_WORKAROUND
 	ctrl_inb (DUMMY_READ_AREA6);
 #endif
@@ -128,16 +149,33 @@ void generic_outl_p(unsigned int b, unsi
 	delay();
 }
 
+/*
+ * outsb/w/l all write a series of bytes/words/longs to a fixed port
+ * address. However as the port address doesn't change we only need to
+ * convert the port address to real address once.
+ */
+
 void generic_outsb(unsigned long port, const void *buffer, unsigned long count)
 {
+	volatile unsigned char *port_addr;
 	const unsigned char *buf=buffer;
-	while(count--) outb(*buf++, port);
+
+	port_addr = (volatile unsigned char *)PORT2ADDR(port);
+
+	while(count--)
+	    *port_addr = *buf++;
 }
 
 void generic_outsw(unsigned long port, const void *buffer, unsigned long count)
 {
+	volatile unsigned short *port_addr;
 	const unsigned short *buf=buffer;
-	while(count--) outw(*buf++, port);
+
+	port_addr = (volatile unsigned short *)PORT2ADDR(port);
+
+	while(count--)
+	    *port_addr = *buf++;
+
 #ifdef SH3_PCMCIA_BUG_WORKAROUND
 	ctrl_inb (DUMMY_READ_AREA6);
 #endif
@@ -145,8 +183,14 @@ void generic_outsw(unsigned long port, c
 
 void generic_outsl(unsigned long port, const void *buffer, unsigned long count)
 {
+	volatile unsigned long *port_addr;
 	const unsigned long *buf=buffer;
-	while(count--) outl(*buf++, port);
+
+	port_addr = (volatile unsigned long *)PORT2ADDR(port);
+
+	while(count--)
+	    *port_addr = *buf++;
+
 #ifdef SH3_PCMCIA_BUG_WORKAROUND
 	ctrl_inb (DUMMY_READ_AREA6);
 #endif
diff -puN arch/sh/kernel/irq.c~sh-merge arch/sh/kernel/irq.c
--- 25/arch/sh/kernel/irq.c~sh-merge	2004-06-23 20:00:21.218464328 -0700
+++ 25-akpm/arch/sh/kernel/irq.c	2004-06-23 20:00:21.256458552 -0700
@@ -575,6 +575,49 @@ unsigned long probe_irq_on(void)
 
 EXPORT_SYMBOL(probe_irq_on);
 
+/* Return a mask of triggered interrupts (this
+ * can handle only legacy ISA interrupts).
+ */
+
+/*
+ *	probe_irq_mask - scan a bitmap of interrupt lines
+ *	@val:	mask of interrupts to consider
+ *
+ *	Scan the ISA bus interrupt lines and return a bitmap of
+ *	active interrupts. The interrupt probe logic state is then
+ *	returned to its previous value.
+ *
+ *	Note: we need to scan all the irq's even though we will
+ *	only return ISA irq numbers - just so that we reset them
+ *	all to a known state.
+ */
+unsigned int probe_irq_mask(unsigned long val)
+{
+	int i;
+	unsigned int mask;
+
+	mask = 0;
+	for (i = 0; i < NR_IRQS; i++) {
+		irq_desc_t *desc = irq_desc + i;
+		unsigned int status;
+
+		spin_lock_irq(&desc->lock);
+		status = desc->status;
+
+		if (status & IRQ_AUTODETECT) {
+			if (i < 16 && !(status & IRQ_WAITING))
+				mask |= 1 << i;
+
+			desc->status = status & ~IRQ_AUTODETECT;
+			desc->handler->shutdown(i);
+		}
+		spin_unlock_irq(&desc->lock);
+	}
+	up(&probe_sem);
+
+	return mask & val;
+}
+
 int probe_irq_off(unsigned long val)
 {
 	int i, irq_found, nr_irqs;
diff -puN arch/sh/kernel/process.c~sh-merge arch/sh/kernel/process.c
--- 25/arch/sh/kernel/process.c~sh-merge	2004-06-23 20:00:21.219464176 -0700
+++ 25-akpm/arch/sh/kernel/process.c	2004-06-23 20:00:21.257458400 -0700
@@ -1,4 +1,4 @@
-/* $Id: process.c,v 1.26 2004/02/06 14:14:14 kkojima Exp $
+/* $Id: process.c,v 1.28 2004/05/05 16:54:23 lethal Exp $
  *
  *  linux/arch/sh/kernel/process.c
  *
@@ -25,6 +25,11 @@
 #include <asm/uaccess.h>
 #include <asm/mmu_context.h>
 #include <asm/elf.h>
+#if defined(CONFIG_SH_HS7751RVOIP)
+#include <asm/hs7751rvoip/hs7751rvoip.h>
+#elif defined(CONFIG_SH_RTS7751R2D)
+#include <asm/rts7751r2d/rts7751r2d.h>
+#endif
 
 static int hlt_counter=0;
 
@@ -50,8 +55,14 @@ void default_idle(void)
 {
 	/* endless idle loop with no priority at all */
 	while (1) {
-		while (!need_resched())
-			cpu_relax();
+		if (hlt_counter) {
+			while (1)
+				if (need_resched())
+					break;
+		} else {
+			while (!need_resched())
+				cpu_sleep();
+		}
 
 		schedule();
 	}
@@ -73,14 +84,30 @@ EXPORT_SYMBOL(machine_restart);
 
 void machine_halt(void)
 {
+#if defined(CONFIG_SH_HS7751RVOIP)
+	unsigned short value;
+
+	value = ctrl_inw(PA_OUTPORTR);
+	ctrl_outw((value & 0xffdf), PA_OUTPORTR);
+#elif defined(CONFIG_SH_RTS7751R2D)
+	ctrl_outw(0x0001, PA_POWOFF);
+#endif
 	while (1)
-		cpu_relax();
+		cpu_sleep();
 }
 
 EXPORT_SYMBOL(machine_halt);
 
 void machine_power_off(void)
 {
+#if defined(CONFIG_SH_HS7751RVOIP)
+	unsigned short value;
+
+	value = ctrl_inw(PA_OUTPORTR);
+	ctrl_outw((value & 0xffdf), PA_OUTPORTR);
+#elif defined(CONFIG_SH_RTS7751R2D)
+	ctrl_outw(0x0001, PA_POWOFF);
+#endif
 }
 
 EXPORT_SYMBOL(machine_power_off);
diff -puN arch/sh/kernel/ptrace.c~sh-merge arch/sh/kernel/ptrace.c
--- 25/arch/sh/kernel/ptrace.c~sh-merge	2004-06-23 20:00:21.220464024 -0700
+++ 25-akpm/arch/sh/kernel/ptrace.c	2004-06-23 20:00:21.258458248 -0700
@@ -1,4 +1,4 @@
-/* $Id: ptrace.c,v 1.14 2003/11/28 23:05:43 kkojima Exp $
+/* $Id: ptrace.c,v 1.15 2004/05/07 05:32:05 sugioka Exp $
  *
  * linux/arch/sh/kernel/ptrace.c
  *
@@ -255,13 +255,6 @@ asmlinkage int sys_ptrace(long request, 
 		ret = ptrace_detach(child, data);
 		break;
 
-	case PTRACE_SETOPTIONS:
-		if (data & PTRACE_O_TRACESYSGOOD)
-			child->ptrace |= PT_TRACESYSGOOD;
-		else
-			child->ptrace &= ~PT_TRACESYSGOOD;
-		ret = 0;
-		break;
 #ifdef CONFIG_SH_DSP
 	case PTRACE_GETDSPREGS: {
 		unsigned long dp;
diff -puN arch/sh/kernel/setup.c~sh-merge arch/sh/kernel/setup.c
--- 25/arch/sh/kernel/setup.c~sh-merge	2004-06-23 20:00:21.222463720 -0700
+++ 25-akpm/arch/sh/kernel/setup.c	2004-06-23 20:00:21.259458096 -0700
@@ -25,15 +25,12 @@
 #include <asm/io_generic.h>
 #include <asm/sections.h>
 #include <asm/irq.h>
-#ifdef CONFIG_SH_EARLY_PRINTK
-#include <asm/sh_bios.h>
-#endif
 
 #ifdef CONFIG_SH_KGDB
 #include <asm/kgdb.h>
 static int kgdb_parse_options(char *options);
 #endif
-
+extern void * __rd_start, * __rd_end;
 /*
  * Machine setup..
  */
@@ -118,130 +115,6 @@ static struct resource ram_resources[] =
 
 unsigned long memory_start, memory_end;
 
-/* XXX: MRB-remove - blatant hack */
-#if 1
-#define SCIF_REG	0xffe80000
-
-static void scif_sercon_putc(int c)
-{
-	while (!(ctrl_inw(SCIF_REG + 0x10) & 0x20)) ;
-
-	ctrl_outb(c, SCIF_REG + 12);
-	ctrl_outw((ctrl_inw(SCIF_REG + 0x10) & 0x9f), SCIF_REG + 0x10);
-
-	if (c == '\n')
-		scif_sercon_putc('\r');
-}
-
-static void scif_sercon_flush(void)
-{
-	ctrl_outw((ctrl_inw(SCIF_REG + 0x10) & 0xbf), SCIF_REG + 0x10);
-
-	while (!(ctrl_inw(SCIF_REG + 0x10) & 0x40)) ;
-
-	ctrl_outw((ctrl_inw(SCIF_REG + 0x10) & 0xbf), SCIF_REG + 0x10);
-}
-
-static void scif_sercon_write(struct console *con, const char *s, unsigned count)
-{
-	while (count-- > 0)
-		scif_sercon_putc(*s++);
-
-	scif_sercon_flush();
-}
-
-static int __init scif_sercon_setup(struct console *con, char *options)
-{
-	con->cflag = CREAD | HUPCL | CLOCAL | B57600 | CS8;
-
-	return 0;
-}
-
-static struct console scif_sercon = {
-	.name		= "sercon",
-	.write		= scif_sercon_write,
-	.setup		= scif_sercon_setup,
-	.flags		= CON_PRINTBUFFER,
-	.index		= -1,
-};
-
-void scif_sercon_init(int baud)
-{
-	ctrl_outw(0, SCIF_REG + 8);
-	ctrl_outw(0, SCIF_REG);
-
-	/* Set baud rate */
-	ctrl_outb((50000000 / (32 * baud)) - 1, SCIF_REG + 4);
-
-	ctrl_outw(12, SCIF_REG + 24);
-	ctrl_outw(8, SCIF_REG + 24);
-	ctrl_outw(0, SCIF_REG + 32);
-	ctrl_outw(0x60, SCIF_REG + 16);
-	ctrl_outw(0, SCIF_REG + 36);
-	ctrl_outw(0x30, SCIF_REG + 8);
-
-	register_console(&scif_sercon);
-}
-
-void scif_sercon_unregister(void)
-{
-	unregister_console(&scif_sercon);
-}
-#endif
-
-#ifdef CONFIG_SH_EARLY_PRINTK
-/*
- *	Print a string through the BIOS
- */
-static void sh_console_write(struct console *co, const char *s,
-				 unsigned count)
-{
-    	sh_bios_console_write(s, count);
-}
-
-/*
- *	Setup initial baud/bits/parity. We do two things here:
- *	- construct a cflag setting for the first rs_open()
- *	- initialize the serial port
- *	Return non-zero if we didn't find a serial port.
- */
-static int __init sh_console_setup(struct console *co, char *options)
-{
-	int	cflag = CREAD | HUPCL | CLOCAL;
-
-	/*
-	 *	Now construct a cflag setting.
-	 *  	TODO: this is a totally bogus cflag, as we have
-	 *  	no idea what serial settings the BIOS is using, or
-	 *  	even if its using the serial port at all.
-	 */
-    	cflag |= B115200 | CS8 | /*no parity*/0;
-
-	co->cflag = cflag;
-
-	return 0;
-}
-
-static struct console sh_console = {
-	.name		= "bios",
-	.write		= sh_console_write,
-	.setup		= sh_console_setup,
-	.flags		= CON_PRINTBUFFER,
-	.index		= -1,
-};
-
-void sh_console_init(void)
-{
-	register_console(&sh_console);
-}
-
-void sh_console_unregister(void)
-{
-	unregister_console(&sh_console);
-}
-
-#endif
-
 static inline void parse_cmdline (char ** cmdline_p, char mv_name[MV_NAME_SIZE],
 				  struct sh_machine_vector** mvp,
 				  unsigned long *mv_io_base,
@@ -323,10 +196,6 @@ static int __init sh_mv_setup(char **cmd
 
 	parse_cmdline(cmdline_p, mv_name, &mv, &mv_io_base, &mv_mmio_enable);
 
-#ifdef CONFIG_CMDLINE_BOOL
-        sprintf(*cmdline_p, CONFIG_CMDLINE);
-#endif
-
 #ifdef CONFIG_SH_GENERIC
 	if (mv == NULL) {
 		mv = &mv_unknown;
@@ -380,14 +249,15 @@ void __init setup_arch(char **cmdline_p)
 	unsigned long bootmap_size;
 	unsigned long start_pfn, max_pfn, max_low_pfn;
 
-/* XXX: MRB-remove */
-#if 0
-	scif_sercon_init(57600);
+#ifdef CONFIG_EARLY_PRINTK
+	extern void enable_early_printk(void);
+
+	enable_early_printk();
 #endif
-#ifdef CONFIG_SH_EARLY_PRINTK
-	sh_console_init();
+#ifdef CONFIG_CMDLINE_BOOL
+        strcpy(COMMAND_LINE, CONFIG_CMDLINE);
 #endif
-	
+
 	ROOT_DEV = old_decode_dev(ORIG_ROOT_DEV);
 
 #ifdef CONFIG_BLK_DEV_RAM
@@ -490,6 +360,13 @@ void __init setup_arch(char **cmdline_p)
 	reserve_bootmem_node(NODE_DATA(0), __MEMORY_START, PAGE_SIZE);
 
 #ifdef CONFIG_BLK_DEV_INITRD
+ 	ROOT_DEV = MKDEV(RAMDISK_MAJOR, 0);
+ 	if (&__rd_start != &__rd_end) {
+		LOADER_TYPE = 1;
+		INITRD_START = PHYSADDR((unsigned long)&__rd_start) - __MEMORY_START;
+		INITRD_SIZE = (unsigned long)&__rd_end - (unsigned long)&__rd_start;
+ 	}
+
 	if (LOADER_TYPE && INITRD_START) {
 		if (INITRD_START + INITRD_SIZE <= (max_low_pfn << PAGE_SHIFT)) {
 			reserve_bootmem_node(NODE_DATA(0), INITRD_START+__MEMORY_START, INITRD_SIZE);
@@ -555,8 +432,10 @@ subsys_initcall(topology_init);
 
 static const char *cpu_name[] = {
 	[CPU_SH7604]	= "SH7604",
+	[CPU_SH7705]	= "SH7705",
 	[CPU_SH7708]	= "SH7708",
 	[CPU_SH7729]	= "SH7729",
+	[CPU_SH7300]	= "SH7300",
 	[CPU_SH7750]	= "SH7750",
 	[CPU_SH7750S]	= "SH7750S",
 	[CPU_SH7750R]	= "SH7750R",
@@ -593,8 +472,8 @@ static void show_cpuflags(struct seq_fil
 
 	for (i = 0; i < cpu_data->flags; i++)
 		if ((cpu_data->flags & (1 << i)))
-			seq_printf(m, " %s", cpu_flags[i]);
-	
+			seq_printf(m, " %s", cpu_flags[i+1]);
+
 	seq_printf(m, "\n");
 }
 
diff -puN arch/sh/kernel/sh_ksyms.c~sh-merge arch/sh/kernel/sh_ksyms.c
--- 25/arch/sh/kernel/sh_ksyms.c~sh-merge	2004-06-23 20:00:21.223463568 -0700
+++ 25-akpm/arch/sh/kernel/sh_ksyms.c	2004-06-23 20:00:21.259458096 -0700
@@ -33,6 +33,7 @@ EXPORT_SYMBOL(dump_fpu);
 EXPORT_SYMBOL(iounmap);
 EXPORT_SYMBOL(enable_irq);
 EXPORT_SYMBOL(disable_irq);
+EXPORT_SYMBOL(probe_irq_mask);
 EXPORT_SYMBOL(kernel_thread);
 EXPORT_SYMBOL(disable_irq_nosync);
 EXPORT_SYMBOL(irq_desc);
@@ -83,6 +84,7 @@ EXPORT_SYMBOL(__down);
 EXPORT_SYMBOL(__down_interruptible);
 
 EXPORT_SYMBOL(__udelay);
+EXPORT_SYMBOL(__ndelay);
 EXPORT_SYMBOL(__const_udelay);
 
 #define DECLARE_EXPORT(name) extern void name(void);EXPORT_SYMBOL_NOVERS(name)
@@ -100,6 +102,7 @@ DECLARE_EXPORT(__movstr);
  
 DECLARE_EXPORT(__movstr_i4_even);
 DECLARE_EXPORT(__movstr_i4_odd);
+DECLARE_EXPORT(__movstrSI12_i4);
 
 /* needed by some modules */
 EXPORT_SYMBOL(flush_cache_all);
@@ -115,3 +118,4 @@ EXPORT_SYMBOL(synchronize_irq);
 #endif
 
 EXPORT_SYMBOL(csum_partial);
+EXPORT_SYMBOL(consistent_sync);
diff -puN arch/sh/kernel/traps.c~sh-merge arch/sh/kernel/traps.c
--- 25/arch/sh/kernel/traps.c~sh-merge	2004-06-23 20:00:21.225463264 -0700
+++ 25-akpm/arch/sh/kernel/traps.c	2004-06-23 20:00:21.260457944 -0700
@@ -1,4 +1,4 @@
-/* $Id: traps.c,v 1.16 2004/03/16 00:10:54 lethal Exp $
+/* $Id: traps.c,v 1.17 2004/05/02 01:46:30 sugioka Exp $
  *
  *  linux/arch/sh/traps.c
  *
@@ -559,7 +559,7 @@ int is_dsp_inst(struct pt_regs *regs)
 	 * Safe guard if DSP mode is already enabled or we're lacking
 	 * the DSP altogether.
 	 */
-	if (!test_bit(CPU_HAS_DSP, &(cpu_data->flags)) || (regs->sr & SR_DSP))
+	if (!(cpu_data->flags & CPU_HAS_DSP) || (regs->sr & SR_DSP))
 		return 0;
 
 	get_user(inst, ((unsigned short *) regs->pc));
@@ -636,7 +636,7 @@ void __init trap_init(void)
 		= (void *)do_illegal_slot_inst;
 
 #ifdef CONFIG_CPU_SH4
-	if (!test_bit(CPU_HAS_FPU, &(cpu_data->flags))) {
+	if (!(cpu_data->flags & CPU_HAS_FPU)) {
 		/* For SH-4 lacking an FPU, treat floating point instructions
 		   as reserved. */
 		/* entry 64 corresponds to EXPEVT=0x800 */
diff -puN arch/sh/kernel/vmlinux.lds.S~sh-merge arch/sh/kernel/vmlinux.lds.S
--- 25/arch/sh/kernel/vmlinux.lds.S~sh-merge	2004-06-23 20:00:21.226463112 -0700
+++ 25-akpm/arch/sh/kernel/vmlinux.lds.S	2004-06-23 20:00:21.261457792 -0700
@@ -38,6 +38,14 @@ SECTIONS
 
   .data : {			/* Data */
 	*(.data)
+
+ 	 /* Align the initial ramdisk image (INITRD) on page boundaries. */
+ 	 . = ALIGN(4096);
+ 	 __rd_start = .;
+ 	 *(.initrd)
+ 	 . = ALIGN(4096);
+ 	 __rd_end = .;
+
 	CONSTRUCTORS
 	}
 
diff -puN arch/sh/lib/delay.c~sh-merge arch/sh/lib/delay.c
--- 25/arch/sh/lib/delay.c~sh-merge	2004-06-23 20:00:21.227462960 -0700
+++ 25-akpm/arch/sh/lib/delay.c	2004-06-23 20:00:21.261457792 -0700
@@ -33,3 +33,9 @@ void __udelay(unsigned long usecs)
 {
 	__const_udelay(usecs * 0x000010c6);  /* 2**32 / 1000000 */
 }
+
+void __ndelay(unsigned long nsecs)
+{
+	__const_udelay(nsecs * 0x00000005);
+}
+
diff -puN arch/sh/Makefile~sh-merge arch/sh/Makefile
--- 25/arch/sh/Makefile~sh-merge	2004-06-23 20:00:21.229462656 -0700
+++ 25-akpm/arch/sh/Makefile	2004-06-23 20:00:21.262457640 -0700
@@ -1,11 +1,11 @@
-# $Id: Makefile,v 1.34 2004/03/21 17:31:06 lethal Exp $
+# $Id: Makefile,v 1.35 2004/04/15 03:39:20 sugioka Exp $
 #
 # This file is subject to the terms and conditions of the GNU General Public
 # License.  See the file "COPYING" in the main directory of this archive
 # for more details.
 #
 # Copyright (C) 1999  Kaz Kojima
-# Copyright (C) 2002, 2003  Paul Mundt
+# Copyright (C) 2002, 2003, 2004  Paul Mundt
 # Copyright (C) 2002  M. R. Brown
 #
 # This file is included by the global makefile so that you can add your own
@@ -64,10 +64,18 @@ LIBGCC := $(shell $(CC) $(CFLAGS) -print
 
 core-y				+= arch/sh/kernel/ arch/sh/mm/
 
+#
+# ramdisk/initrd support
+# You need a compressed ramdisk image, named
+# CONFIG_EMBEDDED_RAMDISK_IMAGE. Relative pathnames
+# are relative to arch/sh/ramdisk/.
+#
+core-$(CONFIG_EMBEDDED_RAMDISK)	+= arch/sh/ramdisk/
+
 # Boards
 machdir-$(CONFIG_SH_SOLUTION_ENGINE)		:= se/770x
 machdir-$(CONFIG_SH_7751_SOLUTION_ENGINE)	:= se/7751
-machdir-$(CONFIG_SH_7751_SYSTEMH)		:= systemh
+machdir-$(CONFIG_SH_7300_SOLUTION_ENGINE)	:= se/7300
 machdir-$(CONFIG_SH_STB1_HARP)			:= harp
 machdir-$(CONFIG_SH_STB1_OVERDRIVE)		:= overdrive
 machdir-$(CONFIG_SH_HP620)			:= hp6xx/hp620
@@ -84,19 +92,24 @@ machdir-$(CONFIG_SH_SH2000)			:= sh2000
 machdir-$(CONFIG_SH_ADX)			:= adx
 machdir-$(CONFIG_SH_MPC1211)			:= mpc1211
 machdir-$(CONFIG_SH_SECUREEDGE5410)		:= snapgear
+machdir-$(CONFIG_SH_HS7751RVOIP)		:= renesas/hs7751rvoip
+machdir-$(CONFIG_SH_RTS7751R2D)			:= renesas/rts7751r2d
+machdir-$(CONFIG_SH_7751_SYSTEMH)		:= renesas/systemh
 machdir-$(CONFIG_SH_UNKNOWN)			:= unknown
 
-incdir-y			:= $(machdir-y)
+incdir-y			:= $(notdir $(machdir-y))
 
 incdir-$(CONFIG_SH_SOLUTION_ENGINE)		:= se
 incdir-$(CONFIG_SH_7751_SOLUTION_ENGINE)	:= se7751
+incdir-$(CONFIG_SH_7300_SOLUTION_ENGINE)        := se7300
 incdir-$(CONFIG_SH_HP600)			:= hp6xx
 
 core-y				+= arch/sh/boards/$(machdir-y)/
 
 # Companion chips
-core-$(CONFIG_HD64461)	+= arch/sh/cchips/hd6446x/hd64461/
-core-$(CONFIG_HD64465)	+= arch/sh/cchips/hd6446x/hd64465/
+core-$(CONFIG_HD64461)		+= arch/sh/cchips/hd6446x/hd64461/
+core-$(CONFIG_HD64465)		+= arch/sh/cchips/hd6446x/hd64465/
+core-$(CONFIG_VOYAGERGX)	+= arch/sh/cchips/voyagergx/
 
 cpuincdir-$(CONFIG_CPU_SH2)	:= cpu-sh2
 cpuincdir-$(CONFIG_CPU_SH3)	:= cpu-sh3
@@ -114,6 +127,9 @@ AFLAGS_vmlinux.lds.o := -traditional
 prepare: target_links
 
 .PHONY: target_links FORCE
+
+all: zImage
+
 target_links:
 	@echo '  Making asm-sh/cpu -> asm-sh/$(cpuincdir-y) link'
 	@rm -f include/asm-sh/cpu
diff -puN arch/sh/mm/cache-sh3.c~sh-merge arch/sh/mm/cache-sh3.c
--- 25/arch/sh/mm/cache-sh3.c~sh-merge	2004-06-23 20:00:21.230462504 -0700
+++ 25-akpm/arch/sh/mm/cache-sh3.c	2004-06-23 20:00:21.262457640 -0700
@@ -1,4 +1,4 @@
-/* $Id: cache-sh3.c,v 1.8 2004/02/01 16:26:27 lethal Exp $
+/* $Id: cache-sh3.c,v 1.9 2004/05/02 01:46:30 sugioka Exp $
  *
  *  linux/arch/sh/mm/cache-sh3.c
  *
@@ -65,14 +65,14 @@ int __init detect_cpu_and_cache_system(v
 	 * 2K(direct) 7702 is not supported (yet)
 	 */
 	if (data0 == data1 && data2 == data3) {	/* Shadow */
-		cpu_data->dcache.way_shift	= 11;
+		cpu_data->dcache.way_incr	= (1 << 11);
 		cpu_data->dcache.entry_mask	= 0x7f0;
 		cpu_data->dcache.sets		= 128;
 		cpu_data->type = CPU_SH7708;
 
-		set_bit(CPU_HAS_MMU_PAGE_ASSOC, &(cpu_data->flags));
+		cpu_data->flags |= CPU_HAS_MMU_PAGE_ASSOC;
 	} else {				/* 7709A or 7729  */
-		cpu_data->dcache.way_shift	= 12;
+		cpu_data->dcache.way_incr	= (1 << 12);
 		cpu_data->dcache.entry_mask	= 0xff0;
 		cpu_data->dcache.sets		= 256;
 		cpu_data->type = CPU_SH7729;
@@ -108,13 +108,12 @@ void __flush_wback_region(void *start, i
 		& ~(L1_CACHE_BYTES-1);
 
 	for (v = begin; v < end; v+=L1_CACHE_BYTES) {
+		unsigned long addrstart = CACHE_OC_ADDRESS_ARRAY;
 		for (j = 0; j < cpu_data->dcache.ways; j++) {
 			unsigned long data, addr, p;
 
 			p = __pa(v);
-			addr = CACHE_OC_ADDRESS_ARRAY |
-				(j << cpu_data->dcache.way_shift)|
-				(v & cpu_data->dcache.entry_mask);
+			addr = addrstart | (v & cpu_data->dcache.entry_mask);
 			local_irq_save(flags);
 			data = ctrl_inl(addr);
 			
@@ -126,6 +125,7 @@ void __flush_wback_region(void *start, i
 				break;
 			}
 			local_irq_restore(flags);
+			addrstart += cpu_data->dcache.way_incr;
 		}
 	}
 }
diff -puN arch/sh/mm/cache-sh4.c~sh-merge arch/sh/mm/cache-sh4.c
--- 25/arch/sh/mm/cache-sh4.c~sh-merge	2004-06-23 20:00:21.231462352 -0700
+++ 25-akpm/arch/sh/mm/cache-sh4.c	2004-06-23 20:00:21.263457488 -0700
@@ -30,7 +30,7 @@ static void __flush_dcache_all_ex(void);
 
 int __init detect_cpu_and_cache_system(void)
 {
-	unsigned long pvr, prr, ccr, cvr;
+	unsigned long pvr, prr, cvr;
 	unsigned long size;
 
 	static unsigned long sizes[16] = {
@@ -48,7 +48,7 @@ int __init detect_cpu_and_cache_system(v
 	/*
 	 * Setup some sane SH-4 defaults for the icache
 	 */
-	cpu_data->icache.way_shift	= 13;
+	cpu_data->icache.way_incr	= (1 << 13);
 	cpu_data->icache.entry_shift	= 5;
 	cpu_data->icache.entry_mask	= 0x1fe0;
 	cpu_data->icache.sets		= 256;
@@ -58,7 +58,7 @@ int __init detect_cpu_and_cache_system(v
 	/*
 	 * And again for the dcache ..
 	 */
-	cpu_data->dcache.way_shift	= 14;
+	cpu_data->dcache.way_incr	= (1 << 14);
 	cpu_data->dcache.entry_shift	= 5;
 	cpu_data->dcache.entry_mask	= 0x3fe0;
 	cpu_data->dcache.sets		= 512;
@@ -66,7 +66,7 @@ int __init detect_cpu_and_cache_system(v
 	cpu_data->dcache.linesz		= L1_CACHE_BYTES;
 
 	/* Set the FPU flag, virtually all SH-4's have one */
-	set_bit(CPU_HAS_FPU, &(cpu_data->flags));
+	cpu_data->flags |= CPU_HAS_FPU;
 
 	/*
 	 * Probe the underlying processor version/revision and
@@ -75,7 +75,7 @@ int __init detect_cpu_and_cache_system(v
 	switch (pvr) {
 	case 0x205:
 		cpu_data->type = CPU_SH7750;
-		set_bit(CPU_HAS_P2_FLUSH_BUG, &(cpu_data->flags));
+		cpu_data->flags |= CPU_HAS_P2_FLUSH_BUG;
 		break;
 	case 0x206:
 		cpu_data->type = CPU_SH7750S;
@@ -84,7 +84,7 @@ int __init detect_cpu_and_cache_system(v
 		 * FIXME: This is needed for 7750, but do we need it for the
 		 * 7750S too? For now, assume we do.. -- PFM
 		 */
-		set_bit(CPU_HAS_P2_FLUSH_BUG, &(cpu_data->flags));
+		cpu_data->flags |= CPU_HAS_P2_FLUSH_BUG;
 
 		break;
 	case 0x1100:
@@ -102,7 +102,7 @@ int __init detect_cpu_and_cache_system(v
 		cpu_data->dcache.ways = 2;
 
 		/* No FPU on the SH4-500 series.. */
-		clear_bit(CPU_HAS_FPU, &(cpu_data->flags));
+		cpu_data->flags &= ~CPU_HAS_FPU;
 		break;
 	case 0x600:
 		cpu_data->type = CPU_SH4_202;
@@ -129,27 +129,20 @@ int __init detect_cpu_and_cache_system(v
 	 * On anything that's not a direct-mapped cache, look to the CVR
 	 * for I/D-cache specifics.
 	 */
-	if (cpu_data->dcache.ways > 1) {
-		jump_to_P2();
-		ccr = ctrl_inl(CCR);
-
-		/* Force EMODE */
-		if (!(ccr & CCR_CACHE_EMODE)) {
-			ccr |= CCR_CACHE_EMODE;
-			ctrl_outl(ccr, CCR);
-		}
-
-		back_to_P1();
-
+	if (cpu_data->icache.ways > 1) {
 		size = sizes[(cvr >> 20) & 0xf];
-		cpu_data->icache.way_shift	=  (size >> 1);
-		cpu_data->icache.entry_mask	= ((size >> 2) - (1 << 5));
-		cpu_data->icache.sets		=  (size >> 6);
+		cpu_data->icache.way_incr	= size / cpu_data->icache.ways;
+		cpu_data->icache.sets		= (size >> 6);
+		cpu_data->icache.entry_mask	=
+			((size / cpu_data->icache.ways) - (1 << 5));
+	}
 
+	if (cpu_data->dcache.ways > 1) {
 		size = sizes[(cvr >> 16) & 0xf];
-		cpu_data->dcache.way_shift	=  (size >> 1);
-		cpu_data->dcache.entry_mask	= ((size >> 2) - (1 << 5));
-		cpu_data->dcache.sets		=  (size >> 6);
+		cpu_data->dcache.way_incr	= size / cpu_data->dcache.ways;
+		cpu_data->dcache.sets		= (size >> 6);
+		cpu_data->dcache.entry_mask	=
+			((size / cpu_data->dcache.ways) - (1 << 5));
 	}
 
 	return 0;
@@ -250,7 +243,7 @@ static void __flush_cache_4096_all_ex(un
 	int i;
 
 	entry_offset = 1 << cpu_data->dcache.entry_shift;
-	for (i = 0; i < cpu_data->dcache.ways; i++, start += (1 << cpu_data->dcache.way_shift)) {
+	for (i = 0; i < cpu_data->dcache.ways; i++, start += cpu_data->dcache.way_incr) {
 		for (addr = CACHE_OC_ADDRESS_ARRAY + start;
 		     addr < CACHE_OC_ADDRESS_ARRAY + 4096 + start;
 		     addr += entry_offset) {
@@ -297,7 +290,7 @@ void flush_cache_sigtramp(unsigned long 
 
 	local_irq_save(flags);
 	jump_to_P2();
-	for(i = 0; i < cpu_data->icache.ways; i++, index += (1 << cpu_data->icache.way_shift))
+	for(i = 0; i < cpu_data->icache.ways; i++, index += cpu_data->icache.way_incr)
 		ctrl_outl(0, index);	/* Clear out Valid-bit */
 	back_to_P1();
 	local_irq_restore(flags);
@@ -313,12 +306,13 @@ static inline void flush_cache_4096(unsi
 	 * SH7751, SH7751R, and ST40 have no restriction to handle cache.
 	 * (While SH7750 must do that at P2 area.)
 	 */
-	if (test_bit(CPU_HAS_P2_FLUSH_BUG, &(cpu_data->flags))) {
+	if ((cpu_data->flags & CPU_HAS_P2_FLUSH_BUG)
+	   || start < CACHE_OC_ADDRESS_ARRAY) {
 		local_irq_save(flags);
-		__flush_cache_4096(start | SH_CACHE_ASSOC, phys | 0x80000000, 0x20000000);
+		__flush_cache_4096(start | SH_CACHE_ASSOC, P1SEGADDR(phys), 0x20000000);
 		local_irq_restore(flags);
-	} else if (start >= CACHE_OC_ADDRESS_ARRAY) {
-		__flush_cache_4096(start | SH_CACHE_ASSOC, phys | 0x80000000, 0);
+	} else {
+		__flush_cache_4096(start | SH_CACHE_ASSOC, P1SEGADDR(phys), 0);
 	}
 }
 
diff -puN arch/sh/mm/tlb-sh3.c~sh-merge arch/sh/mm/tlb-sh3.c
--- 25/arch/sh/mm/tlb-sh3.c~sh-merge	2004-06-23 20:00:21.233462048 -0700
+++ 25-akpm/arch/sh/mm/tlb-sh3.c	2004-06-23 20:00:21.264457336 -0700
@@ -72,7 +72,7 @@ void __flush_tlb_page(unsigned long asid
 	addr = MMU_TLB_ADDRESS_ARRAY | (page & 0x1F000);
 	data = (page & 0xfffe0000) | asid; /* VALID bit is off */
 	
-	if (test_bit(CPU_HAS_MMU_PAGE_ASSOC, &(cpu_data->flags))) {
+	if ((cpu_data->flags & CPU_HAS_MMU_PAGE_ASSOC)) {
 		addr |= MMU_PAGE_ASSOC_BIT;
 		ways = 1;	/* we already know the way .. */
 	}
diff -puN /dev/null arch/sh/ramdisk/ld.script
--- /dev/null	2003-09-15 06:40:47.000000000 -0700
+++ 25-akpm/arch/sh/ramdisk/ld.script	2004-06-23 20:00:21.264457336 -0700
@@ -0,0 +1,9 @@
+OUTPUT_ARCH(sh)
+SECTIONS
+{
+  .initrd :
+  {
+       *(.data)
+  }
+}
+
diff -puN /dev/null arch/sh/ramdisk/Makefile
--- /dev/null	2003-09-15 06:40:47.000000000 -0700
+++ 25-akpm/arch/sh/ramdisk/Makefile	2004-06-23 20:00:21.264457336 -0700
@@ -0,0 +1,19 @@
+#
+# Makefile for a ramdisk image
+#
+
+obj-y += ramdisk.o
+
+
+O_FORMAT = $(shell $(OBJDUMP) -i | head -n 2 | grep elf32)
+img := $(subst ",,$(CONFIG_EMBEDDED_RAMDISK_IMAGE))
+# add $(src) when $(img) is relative
+img := $(subst $(src)//,/,$(src)/$(img))
+
+quiet_cmd_ramdisk = LD      $@
+define cmd_ramdisk
+	$(LD) -T $(src)/ld.script -b binary --oformat $(O_FORMAT) -o $@ $(img)
+endef
+
+$(obj)/ramdisk.o: $(img) $(src)/ld.script
+	$(call cmd,ramdisk)
diff -puN arch/sh/tools/mach-types~sh-merge arch/sh/tools/mach-types
--- 25/arch/sh/tools/mach-types~sh-merge	2004-06-23 20:00:21.234461896 -0700
+++ 25-akpm/arch/sh/tools/mach-types	2004-06-23 20:00:21.265457184 -0700
@@ -7,6 +7,7 @@
 #
 SE			SH_SOLUTION_ENGINE
 7751SE			SH_7751_SOLUTION_ENGINE		
+7300SE			SH_7300_SOLUTION_ENGINE
 7751SYSTEMH		SH_7751_SYSTEMH
 HP600			SH_HP600
 HP620			SH_HP620
@@ -21,4 +22,6 @@ BIGSUR			SH_BIGSUR
 ADX			SH_ADX
 MPC1211			SH_MPC1211
 SNAPGEAR		SH_SECUREEDGE5410
+HS7751RVOIP		SH_HS7751RVOIP
+RTS7751R2D		SH_RTS7751R2D
 
diff -puN Documentation/sh/new-machine.txt~sh-merge Documentation/sh/new-machine.txt
--- 25/Documentation/sh/new-machine.txt~sh-merge	2004-06-23 20:00:21.236461592 -0700
+++ 25-akpm/Documentation/sh/new-machine.txt	2004-06-23 20:00:21.265457184 -0700
@@ -188,13 +188,7 @@ adding a machine called vapor):
  - add a new file include/asm-sh/vapor/io.h which contains prototypes for
    any machine specific IO functions prefixed with the machine name, for
    example vapor_inb. These will be needed when filling out the machine
-   vector. In addition, a section is required which defines what to do when
-   building a machine specific version. For example:
-
-     #ifdef __WANT_IO_DEF
-     #define inb  vapor_inb
-     ...
-     #endif
+   vector.
 
    This is the minimum that is required, however there are ample
    opportunities to optimise this. In particular, by making the prototypes
diff -puN /dev/null include/asm-sh/bus-sh.h
--- /dev/null	2003-09-15 06:40:47.000000000 -0700
+++ 25-akpm/include/asm-sh/bus-sh.h	2004-06-23 20:00:21.266457032 -0700
@@ -0,0 +1,65 @@
+/*
+ * include/asm-sh/bus-sh.h
+ *
+ * Copyright (C) 2004 Paul Mundt
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#ifndef __ASM_SH_BUS_SH_H
+#define __ASM_SH_BUS_SH_H
+
+extern struct bus_type sh_bus_types[];
+
+struct sh_dev {
+	struct device	dev;
+	char		*name;
+	unsigned int	dev_id;
+	unsigned int	bus_id;
+	struct resource	res;
+	void		*mapbase;
+	unsigned int	irq[6];
+	u64		*dma_mask;
+};
+
+#define to_sh_dev(d)	container_of((d), struct sh_dev, dev)
+
+#define sh_get_drvdata(d)	dev_get_drvdata(&(d)->dev)
+#define sh_set_drvdata(d,p)	dev_set_drvdata(&(d)->dev, (p))
+
+struct sh_driver {
+	struct device_driver	drv;
+	unsigned int		dev_id;
+	unsigned int		bus_id;
+	int (*probe)(struct sh_dev *);
+	int (*remove)(struct sh_dev *);
+	int (*suspend)(struct sh_dev *, u32);
+	int (*resume)(struct sh_dev *);
+};
+
+#define to_sh_driver(d)	container_of((d), struct sh_driver, drv)
+#define sh_name(d)	((d)->dev.driver->name)
+
+/*
+ * Device ID numbers for bus types
+ */
+enum {
+	SH_DEV_ID_USB_OHCI,
+};
+
+#define SH_NR_BUSES		1
+#define SH_BUS_NAME_VIRT	"shbus"
+
+enum {
+	SH_BUS_VIRT,
+};
+
+/* arch/sh/kernel/cpu/bus.c */
+extern int sh_device_register(struct sh_dev *dev);
+extern void sh_device_unregister(struct sh_dev *dev);
+extern int sh_driver_register(struct sh_driver *drv);
+extern void sh_driver_unregister(struct sh_driver *drv);
+
+#endif /* __ASM_SH_BUS_SH_H */
+
diff -puN include/asm-sh/cache.h~sh-merge include/asm-sh/cache.h
--- 25/include/asm-sh/cache.h~sh-merge	2004-06-23 20:00:21.238461288 -0700
+++ 25-akpm/include/asm-sh/cache.h	2004-06-23 20:00:21.266457032 -0700
@@ -28,7 +28,8 @@ struct cache_info {
 	unsigned int sets;
 	unsigned int linesz;
 
-	unsigned int way_shift;
+	unsigned int way_incr;
+
 	unsigned int entry_shift;
 	unsigned int entry_mask;
 
diff -puN include/asm-sh/cpu-sh3/dac.h~sh-merge include/asm-sh/cpu-sh3/dac.h
--- 25/include/asm-sh/cpu-sh3/dac.h~sh-merge	2004-06-23 20:00:21.239461136 -0700
+++ 25-akpm/include/asm-sh/cpu-sh3/dac.h	2004-06-23 20:00:21.266457032 -0700
@@ -1,5 +1,5 @@
-#ifndef __ASM_SH_DAC_H
-#define __ASM_SH_DAC_H
+#ifndef __ASM_CPU_SH3_DAC_H
+#define __ASM_CPU_SH3_DAC_H
 
 /*
  * Copyright (C) 2003  Andriy Skulysh
@@ -38,5 +38,4 @@ static __inline__ void sh_dac_output(u8 
 	else ctrl_outb(value,DADR0);
 }
 
-#endif /* __ASM_SH_DAC_H */
-
+#endif /* __ASM_CPU_SH3_DAC_H */
diff -puN include/asm-sh/processor.h~sh-merge include/asm-sh/processor.h
--- 25/include/asm-sh/processor.h~sh-merge	2004-06-23 20:00:21.240460984 -0700
+++ 25-akpm/include/asm-sh/processor.h	2004-06-23 20:00:21.267456880 -0700
@@ -271,6 +271,7 @@ extern unsigned long get_wchan(struct ta
 #define KSTK_EIP(tsk)  ((tsk)->thread.pc)
 #define KSTK_ESP(tsk)  ((tsk)->thread.sp)
 
-#define cpu_relax()	__asm__ __volatile__ ("sleep" : : : "memory")
+#define cpu_sleep()	__asm__ __volatile__ ("sleep" : : : "memory")
+#define cpu_relax()	do { } while (0)
 
 #endif /* __ASM_SH_PROCESSOR_H */
diff -puN include/asm-sh/serial.h~sh-merge include/asm-sh/serial.h
--- 25/include/asm-sh/serial.h~sh-merge	2004-06-23 20:00:21.243460528 -0700
+++ 25-akpm/include/asm-sh/serial.h	2004-06-23 20:00:21.267456880 -0700
@@ -44,8 +44,5 @@
 
 #define SERIAL_PORT_DFNS STD_SERIAL_PORT_DEFNS
 
-/* XXX: This should be moved ino irq.h */
-#define irq_canonicalize(x) (x)
-
 #endif
 #endif /* _ASM_SERIAL_H */
diff -puN include/asm-sh/sigcontext.h~sh-merge include/asm-sh/sigcontext.h
--- 25/include/asm-sh/sigcontext.h~sh-merge	2004-06-23 20:00:21.244460376 -0700
+++ 25-akpm/include/asm-sh/sigcontext.h	2004-06-23 20:00:21.267456880 -0700
@@ -1,6 +1,26 @@
 #ifndef __ASM_SH_SIGCONTEXT_H
 #define __ASM_SH_SIGCONTEXT_H
 
-#include <asm/cpu/sigcontext.h>
+struct sigcontext {
+	unsigned long	oldmask;
+
+	/* CPU registers */
+	unsigned long sc_regs[16];
+	unsigned long sc_pc;
+	unsigned long sc_pr;
+	unsigned long sc_sr;
+	unsigned long sc_gbr;
+	unsigned long sc_mach;
+	unsigned long sc_macl;
+
+#if defined(__SH4__) || defined(CONFIG_CPU_SH4)
+	/* FPU registers */
+	unsigned long sc_fpregs[16];
+	unsigned long sc_xfpregs[16];
+	unsigned int sc_fpscr;
+	unsigned int sc_fpul;
+	unsigned int sc_ownedfp;
+#endif
+};
 
 #endif /* __ASM_SH_SIGCONTEXT_H */
diff -puN include/asm-sh/unistd.h~sh-merge include/asm-sh/unistd.h
--- 25/include/asm-sh/unistd.h~sh-merge	2004-06-23 20:00:21.245460224 -0700
+++ 25-akpm/include/asm-sh/unistd.h	2004-06-23 20:00:21.268456728 -0700
@@ -281,8 +281,17 @@
 #define __NR_utimes		271
 #define __NR_fadvise64_64	272
 #define __NR_vserver		273
+#define __NR_mbind              274
+#define __NR_get_mempolicy      275
+#define __NR_set_mempolicy      276
+#define __NR_mq_open            277
+#define __NR_mq_unlink          (__NR_mq_open+1)
+#define __NR_mq_timedsend       (__NR_mq_open+2)
+#define __NR_mq_timedreceive    (__NR_mq_open+3)
+#define __NR_mq_notify          (__NR_mq_open+4)
+#define __NR_mq_getsetattr      (__NR_mq_open+5)
 
-#define NR_syscalls 274
+#define NR_syscalls 283
 
 /* user-visible error numbers are in the range -1 - -124: see <asm-sh/errno.h> */
 
@@ -429,6 +438,7 @@ __syscall_return(type,__sc0); \
 
 #include <linux/compiler.h>
 #include <linux/types.h>
+#include <linux/linkage.h>
 #include <asm/ptrace.h>
 
 /*
_
