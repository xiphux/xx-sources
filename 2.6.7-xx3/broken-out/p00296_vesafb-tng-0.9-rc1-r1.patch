diff -Naur linux-2.6.7-orig/arch/i386/boot/video.S linux-2.6.7-vesa/arch/i386/boot/video.S
--- linux-2.6.7-orig/arch/i386/boot/video.S	2004-06-16 07:20:27.000000000 +0200
+++ linux-2.6.7-vesa/arch/i386/boot/video.S	2004-06-20 23:08:15.151884904 +0200
@@ -86,18 +86,6 @@
 #define PARAM_HAVE_VGA		0x0f
 #define PARAM_FONT_POINTS	0x10
 
-#define PARAM_LFB_WIDTH		0x12
-#define PARAM_LFB_HEIGHT	0x14
-#define PARAM_LFB_DEPTH		0x16
-#define PARAM_LFB_BASE		0x18
-#define PARAM_LFB_SIZE		0x1c
-#define PARAM_LFB_LINELENGTH	0x24
-#define PARAM_LFB_COLORS	0x26
-#define PARAM_VESAPM_SEG	0x2e
-#define PARAM_VESAPM_OFF	0x30
-#define PARAM_LFB_PAGES		0x32
-#define PARAM_VESA_ATTRIB	0x34
-
 /* Define DO_STORE according to CONFIG_VIDEO_RETAIN */
 #ifdef CONFIG_VIDEO_RETAIN
 #define DO_STORE call store_screen
@@ -166,9 +154,11 @@
 mode_params:
 #ifdef CONFIG_VIDEO_SELECT
 	cmpb	$0, graphic_mode
-	jnz	mopar_gr
+	jz	mp_a1
+	ret
 #endif
-	movb	$0x03, %ah			# Read cursor position
+
+mp_a1:	movb	$0x03, %ah			# Read cursor position
 	xorb	%bh, %bh
 	int	$0x10
 	movw	%dx, %fs:(PARAM_CURSOR_POS)
@@ -200,50 +190,6 @@
 	ret
 
 #ifdef CONFIG_VIDEO_SELECT
-# Fetching of VESA frame buffer parameters
-mopar_gr:
-	leaw	modelist+1024, %di
-	movb	$0x23, %fs:(PARAM_HAVE_VGA)
-	movw	16(%di), %ax
-	movw	%ax, %fs:(PARAM_LFB_LINELENGTH)
-	movw	18(%di), %ax
-	movw	%ax, %fs:(PARAM_LFB_WIDTH)
-	movw	20(%di), %ax
-	movw	%ax, %fs:(PARAM_LFB_HEIGHT)
-	movb	25(%di), %al
-	movb	$0, %ah
-	movw	%ax, %fs:(PARAM_LFB_DEPTH)
-	movb	29(%di), %al	
-	movb	$0, %ah
-	movw	%ax, %fs:(PARAM_LFB_PAGES)
-	movl	40(%di), %eax
-	movl	%eax, %fs:(PARAM_LFB_BASE)
-	movl	31(%di), %eax
-	movl	%eax, %fs:(PARAM_LFB_COLORS)
-	movl	35(%di), %eax
-	movl	%eax, %fs:(PARAM_LFB_COLORS+4)
-	movw	0(%di), %ax
-	movw	%ax, %fs:(PARAM_VESA_ATTRIB)
-
-# get video mem size
-	leaw	modelist+1024, %di
-	movw	$0x4f00, %ax
-	int	$0x10
-	xorl	%eax, %eax
-	movw	18(%di), %ax
-	movl	%eax, %fs:(PARAM_LFB_SIZE)
-# get protected mode interface informations
-	movw	$0x4f0a, %ax
-	xorw	%bx, %bx
-	xorw	%di, %di
-	int	$0x10
-	cmp	$0x004f, %ax
-	jnz	no_pm
-
-	movw	%es, %fs:(PARAM_VESAPM_SEG)
-	movw	%di, %fs:(PARAM_VESAPM_OFF)
-no_pm:	ret
-
 # The video mode menu
 mode_menu:
 	leaw	keymsg, %si			# "Return/Space/Timeout" message
@@ -458,9 +404,6 @@
 	cmpb	$VIDEO_FIRST_V7>>8, %ah
 	jz	setv7
 	
-	cmpb	$VIDEO_FIRST_VESA>>8, %ah
-	jnc	check_vesa
-	
 	orb	%ah, %ah
 	jz	setmenu
 	
@@ -532,40 +475,6 @@
 	movw	-4(%si), %ax			# Fetch mode ID
 	jmp	_m_s
 
-check_vesa:
-	leaw	modelist+1024, %di
-	subb	$VIDEO_FIRST_VESA>>8, %bh
-	movw	%bx, %cx			# Get mode information structure
-	movw	$0x4f01, %ax
-	int	$0x10
-	addb	$VIDEO_FIRST_VESA>>8, %bh
-	cmpw	$0x004f, %ax
-	jnz	setbad
-
-	movb	(%di), %al			# Check capabilities.
-	andb	$0x19, %al
-	cmpb	$0x09, %al
-	jz	setvesa				# This is a text mode
-
-	movb	(%di), %al			# Check capabilities.
-	andb	$0x99, %al
-	cmpb	$0x99, %al
-	jnz	_setbad				# Doh! No linear frame buffer.
-
-	subb	$VIDEO_FIRST_VESA>>8, %bh
-	orw	$0x4000, %bx			# Use linear frame buffer
-	movw	$0x4f02, %ax			# VESA BIOS mode set call
-	int	$0x10
-	cmpw	$0x004f, %ax			# AL=4f if implemented
-	jnz	_setbad				# AH=0 if OK
-
-	movb	$1, graphic_mode		# flag graphic mode
-	movb	$0, do_restore			# no screen restore
-	stc
-	ret
-
-_setbad:	jmp	setbad          	# Ugly...
-
 # Recalculate vertical display end registers -- this fixes various
 # inconsistencies of extended modes on many adapters. Called when
 # the VIDEO_RECALC flag is set in the mode ID.
diff -Naur linux-2.6.7-orig/Documentation/fb/vesafb.txt linux-2.6.7-vesa/Documentation/fb/vesafb.txt
--- linux-2.6.7-orig/Documentation/fb/vesafb.txt	2004-06-16 07:19:43.000000000 +0200
+++ linux-2.6.7-vesa/Documentation/fb/vesafb.txt	2004-06-20 23:08:15.161883384 +0200
@@ -2,16 +2,11 @@
 What is vesafb?
 ===============
 
-This is a generic driver for a graphic framebuffer on intel boxes.
+Vesafb is a generic framebuffer driver for x86 and x86_64 boxes.
 
-The idea is simple:  Turn on graphics mode at boot time with the help
-of the BIOS, and use this as framebuffer device /dev/fb0, like the m68k
-(and other) ports do.
-
-This means we decide at boot time whenever we want to run in text or
-graphics mode.  Switching mode later on (in protected mode) is
-impossible; BIOS calls work in real mode only.  VESA BIOS Extensions
-Version 2.0 are required, because we need a linear frame buffer.
+VESA BIOS Extensions Version 2.0 are required, because we need a linear
+frame buffer. VBE 3.0 is required if you want to use modes with a higher
+(than the standard 60Hz) refresh rate.
 
 Advantages:
 
@@ -29,16 +24,26 @@
 How to use it?
 ==============
 
-Switching modes is done using the vga=... boot parameter.  Read
-Documentation/svga.txt for details.
-
-You should compile in both vgacon (for text mode) and vesafb (for
-graphics mode). Which of them takes over the console depends on
-whenever the specified mode is text or graphics.
-
-The graphic modes are NOT in the list which you get if you boot with
-vga=ask and hit return. The mode you wish to use is derived from the
-VESA mode number. Here are those VESA mode numbers:
+If you are running your system on hardware platform where vm86 is supported
+(this is 32-bit x86 only as of the time of writing this document), you can
+either compile vesafb into the kernel or use it as a module. The graphic mode
+you want to use is in both cases specified using the standard modedb format.
+
+If your system doesn't support vm86 calls yet (all 64-bit platforms), things
+get a little more tricky. Since on such systems you can't do BIOS calls from
+protected mode in which kernel runs, you have to decide at boot time whenever
+you want to run in text or in graphics mode. Swithcing mode later on is
+impossible. Switching modes is done using the vga=... boot parameter.  Read
+Documentation/svga.txt for details. Below is a more detailed description of
+what to do on systems with old-style mode switching.
+
+You should compile in both vgacon (for text mode) and vesafb (for graphics mode).
+Which of them takes over the console depends on whenever the specified mode is
+text or graphics.
+
+The graphic modes are NOT in the list which you get if you boot with vga=ask
+and hit return. The mode you wish to use is derived from the VESA mode number.
+Here are those VESA mode numbers:
 
     | 640x480  800x600  1024x768 1280x1024
 ----+-------------------------------------
@@ -47,8 +52,7 @@
 64k |  0x111    0x114    0x117    0x11A   
 16M |  0x112    0x115    0x118    0x11B   
 
-The video mode number of the Linux kernel is the VESA mode number plus
-0x200.
+The video mode number of the Linux kernel is the VESA mode number plus 0x200.
  
  Linux_kernel_mode_number = VESA_mode_number + 0x200
 
@@ -61,10 +65,10 @@
 64k |  0x311    0x314    0x317    0x31A   
 16M |  0x312    0x315    0x318    0x31B   
 
-To enable one of those modes you have to specify "vga=ask" in the
-lilo.conf file and rerun LILO. Then you can type in the desired
-mode at the "vga=ask" prompt. For example if you like to use 
-1024x768x256 colors you have to say "305" at this prompt.
+To enable one of those modes you have to specify "vga=ask" in the lilo.conf
+file and rerun LILO. Then you can type in the desired mode at the "vga=ask"
+prompt. For example if you like to use 1024x768x256 colors you have to say
+"305" at this prompt.
 
 If this does not work, this might be because your BIOS does not support
 linear framebuffers or because it does not support this mode at all.
@@ -77,6 +81,7 @@
 2. Note: Some newer versions of LILO appear to work with those hex values,
          if you set the 0x in front of the numbers.
 
+
 X11
 ===
 
@@ -91,72 +96,155 @@
 Refresh rates
 =============
 
-There is no way to change the vesafb video mode and/or timings after
-booting linux.  If you are not happy with the 60 Hz refresh rate, you
-have these options:
+With VBE3.0 compatible BIOSes and vm86 it is possible to change the
+refresh rate either at boot time (by specifying the @<rr> part of the
+mode name) or later, using the fbset utility.
+
+With VBE2.0 there is no way to change the mode timings after booting
+linux. If you are not happy with the 60 Hz refresh rate, you have
+these options:
 
- * configure and load the DOS-Tools for your the graphics board (if
+ * configure and load the DOS tools for your the graphics board (if
    available) and boot linux with loadlin.
  * use a native driver (matroxfb/atyfb) instead if vesafb.  If none
    is available, write a new one!
- * VBE 3.0 might work too.  I have neither a gfx board with VBE 3.0
-   support nor the specs, so I have not checked this yet.
+ * use a BIOS editor to change the default refresh rate (such an
+   editor does exists at least for ATI Radeon BIOSes).
+ * if you're running a non-vm86 and VBE3.0-compatible system, you can
+   use a kernel patch to hard-code some mode timings in the kernel and
+   use these while setting the graphic mode at boot.
 
 
 Configuration
 =============
 
-The VESA BIOS provides protected mode interface for changing
-some parameters.  vesafb can use it for palette changes and
-to pan the display.  It is turned off by default because it
-seems not to work with some BIOS versions, but there are options
-to turn it on.
-
-You can pass options to vesafb using "video=vesafb:option" on
-the kernel command line.  Multiple options should be separated
-by comma, like this: "video=vesafb:ypan,invers"
+The VESA BIOS provides protected mode interface for changing some parameters.
+vesafb can use it for palette changes and to pan the display.  It is turned
+off by default because it seems not to work with some BIOS versions, but there
+are options to turn it on.
+
+You can pass options to vesafb using "video=vesafb:option" on the kernel
+command line. Multiple options should be separated by comma, like this:
+"video=vesafb:ypan,1024x768-32@85"
 
 Accepted options:
 
-invers	no comment...
-
-ypan	enable display panning using the VESA protected mode 
-	interface.  The visible screen is just a window of the
+<mode>	The mode you want to set, in the standard modedb format. Refer to
+	modedb.txt for detailed description. If you specify a mode that is
+	not supported by your board's BIOS, vesafb will attempt to set a
+	similar mode. The list of supported modes can be found in
+	/proc/fbx/modes, where x is the framebuffer number (usually 0).
+
+ypan	Enable display panning using the VESA protected mode
+	interface or vm86 calls. The visible screen is just a window of the
 	video memory, console scrolling is done by changing the
 	start of the window.
 	pro:	* scrolling (fullscreen) is fast, because there is
 		  no need to copy around data.
-		* You'll get scrollback (the Shift-PgUp thing),
+		* you'll get scrollback (the Shift-PgUp thing),
 		  the video memory can be used as scrollback buffer
-	kontra: * scrolling only parts of the screen causes some
+	con: 	* scrolling only parts of the screen causes some
 		  ugly flicker effects (boot logo flickers for
 		  example).
 
-ywrap	Same as ypan, but assumes your gfx board can wrap-around 
-	the video memory (i.e. starts reading from top if it
-	reaches the end of video memory).  Faster than ypan.
+ywrap	Same as ypan, but assumes your gfx board can wrap-around the video
+	memory (i.e. starts reading from top if it reaches the end of video
+	memory). Faster than ypan.
 
-redraw	scroll by redrawing the affected part of the screen, this
-	is the safe (and slow) default.
+redraw	Scroll by redrawing the affected part of the screen, this is the
+	safe (and slow) default.
 
-
-vgapal	Use the standard vga registers for palette changes.
+vgapal	Use the standard vga registers for palette changes.
 	This is the default.
+
 pmipal	Use the protected mode interface for palette changes.
 
-mtrr	setup memory type range registers for the vesafb framebuffer.
+mtrr	Setup memory type range registers for the vesafb framebuffer.
+
+nomtrr	Do not use memory type range registers for vesafb.
+
+nocrtc	Do not use CRTC timings while setting the graphic mode. This option
+	makes sence only with VBE3.0 compliant systems. Use it if you have
+	problems with the modes set in the standard way. Note that specifying
+	this option means the refresh rate will be ignored and will stay at
+	your BIOS' default (60 Hz).
+
+noedid 	Do not try to fetch and use EDID-provided modes.
+
+gtf	Force the use of VESA's GTF (Generalized Timing Formula). Specifying
+	this will cause vesafb to skip it's internal modedb and EDID-modedb
+	and jump straight to the GTF part of the code (normally used only is
+	everything else failed). This can be useful if you want to get as much
+	as possible from you graphics board but your BIOS doesn't support
+	modes with refresh rates you require. Note that you may need to
+	specify the maxhf, maxvf and maxclk parameters if they are not
+	provided by EDID.
 
 vram:n	remap 'n' MiB of video RAM. If 0 or not specified, remap memory
 	according to video mode. (2.5.66 patch/idea by Antonino Daplas
 	reversed to give override possibility (allocate more fb memory
 	than the kernel would) to 2.4 by tmb@iki.fi)
+
+Additionally, the following parameters may be provided. They all override the
+EDID-provided values and BIOS defaults. Refer to you monitor's specs to get
+the correct values for maxhf, maxvf and maxclk for your hardware.
+
+maxhf:n		Maximum horizontal frequency (in kHz).
+maxvf:n		Maximum vertical frequency (in Hz).
+maxclk:n	Maximum pixel clock (in MHz).
+
+
+Technical details
+=================
+
+1. The driver architecture.
+
+The driver's code is stored in three files:
+  /drivers/video/vesafb.c
+  /drivers/video/vesafb-thread.c
+  /include/video/vesa.h
+
+vesafb.c contains the main code. vesafb-thread.c contains code for the vesafb
+service thread. A separate thread is necessary because we need to remap memory
+in order to be able to use the vm86 calls. The service thread is started
+regardless of whether vesafb is compiled into the kernel or compiled as a
+module. This is necessary because of the active_mm stuff, better described in
+the header of vesafb-thread.c.
+
+2. The driver initialization
+
+ o vesafb_vbe_init
+   - get basic info about the graphics BIOS
+   - fetch data about all modes supported by VBE
+   - get info about the protected mode interface
+   - get EDID data and attempt to create an EDID modedb
+
+ o vesafb_probe
+   - get service thread's PID (started earlier from fbmem.c)
+   - call vesafb_vbe_init
+   - try to find the specified mode in vesa_modes modedb
+   - if the previous step failed or was skipped:
+     - try to find a matching mode in the VBE modedb - identify VBE mode ID
+     - try to find a matching mode in the EDID modedb
+     - if the previous step failed or was skipped:
+       - try to calculate mode timings with GTF
+   - low level setup - request_mem_region, ioremap, etc.
+   - setup /proc/fb<x>/modes and /proc/fb<x>/vbe_info
 
-Have fun!
+3. Used hacks
+
+ o info->var.reserved[0] holds the VBE mode ID
+ o info->var.reserved[1] holds a pointer to the VBE mode data in vesafb's
+   mode database.
 
-  Gerd
+Have fun!
 
 --
+Original document for the vesafb driver by
 Gerd Knorr <kraxel@goldbach.in-berlin.de>
 
-Minor (mostly typo) changes 
-by Nico Schmoigl <schmoigl@rumms.uni-mannheim.de>
+Minor (mostly typo) changes by
+Nico Schmoigl <schmoigl@rumms.uni-mannheim.de>
+
+Extended docuemtation for vm86 and VBE3.0 by
+Micha³ Januszewski <spock@gentoo.org>
diff -Naur linux-2.6.7-orig/drivers/video/fbmem.c linux-2.6.7-vesa/drivers/video/fbmem.c
--- linux-2.6.7-orig/drivers/video/fbmem.c	2004-06-16 07:18:37.000000000 +0200
+++ linux-2.6.7-vesa/drivers/video/fbmem.c	2004-06-20 23:08:15.000000000 +0200
@@ -36,6 +36,8 @@
 #include <linux/kernel.h>
 #include <linux/device.h>
 
+#include <video/vesa.h>
+
 #if defined(__mc68000__) || defined(CONFIG_APUS)
 #include <asm/setup.h>
 #endif
@@ -97,6 +99,7 @@
 extern int resolver_video_setup(char*);
 extern int s3triofb_init(void);
 extern int vesafb_init(void);
+extern int vesafb_init_thread(void);
 extern int vesafb_setup(char*);
 extern int vga16fb_init(void);
 extern int vga16fb_setup(char*);
@@ -1436,6 +1439,18 @@
 	}
 #endif
 
+#ifdef CONFIG_FB_VESA
+#ifdef VESAFB_VM86
+	vesafb_init_thread();
+#endif
+#endif
+
+#ifdef CONFIG_FB_VESA_MODULE
+#ifdef VESAFB_VM86
+	vesafb_init_thread();
+#endif
+#endif
+
 	/*
 	 *  Probe for all builtin frame buffer devices
 	 */
diff -Naur linux-2.6.7-orig/drivers/video/Kconfig linux-2.6.7-vesa/drivers/video/Kconfig
--- linux-2.6.7-orig/drivers/video/Kconfig	2004-06-16 07:18:55.000000000 +0200
+++ linux-2.6.7-vesa/drivers/video/Kconfig	2004-06-20 23:08:15.000000000 +0200
@@ -287,7 +287,7 @@
 	  cards. Say Y if you have one of those.
 
 config FB_VESA
-	bool "VESA VGA graphics support"
+	tristate "VESA VGA graphics support"
 	depends on FB && (X86 || X86_64)
 	help
 	  This is the frame buffer device driver for generic VESA 2.0
@@ -295,6 +295,15 @@
 	  You will get a boot time penguin logo at no additional cost. Please
 	  read <file:Documentation/fb/vesafb.txt>. If unsure, say Y.
 
+config FB_VESA_DEFAULT_MODE
+	string "VESA default mode"
+	depends on FB_VESA
+	default "640x480@60"
+	help
+	  This option is used to determine the default mode vesafb is
+	  supposed to switch to in case no mode is provided as a kernel
+	  command line parameter.
+
 config VIDEO_SELECT
 	bool
 	depends on FB_VESA
diff -Naur linux-2.6.7-orig/drivers/video/Makefile linux-2.6.7-vesa/drivers/video/Makefile
--- linux-2.6.7-orig/drivers/video/Makefile	2004-06-16 07:18:58.000000000 +0200
+++ linux-2.6.7-vesa/drivers/video/Makefile	2004-06-20 23:08:15.000000000 +0200
@@ -43,7 +43,16 @@
 obj-$(CONFIG_FB_TRIDENT)	  += tridentfb.o cfbfillrect.o cfbimgblt.o cfbcopyarea.o
 obj-$(CONFIG_FB_S3TRIO)           += S3triofb.o
 obj-$(CONFIG_FB_TGA)              += tgafb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o 
+
+ifeq ($(CONFIG_FB_VESA),y)
+obj-$(CONFIG_FB_VESA)             += vesafb.o vesafb-thread.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o
+endif
+
+ifeq ($(CONFIG_FB_VESA),m)
 obj-$(CONFIG_FB_VESA)             += vesafb.o cfbfillrect.o cfbcopyarea.o cfbimgblt.o 
+obj-y                             += vesafb-thread.o
+endif
+
 obj-$(CONFIG_FB_VGA16)            += vga16fb.o cfbfillrect.o cfbcopyarea.o \
 	                             cfbimgblt.o vgastate.o 
 obj-$(CONFIG_FB_VIRGE)            += virgefb.o
diff -Naur linux-2.6.7-orig/drivers/video/vesafb.c linux-2.6.7-vesa/drivers/video/vesafb.c
--- linux-2.6.7-orig/drivers/video/vesafb.c	2004-06-16 07:18:57.000000000 +0200
+++ linux-2.6.7-vesa/drivers/video/vesafb.c	2004-06-20 23:10:15.000000000 +0200
@@ -1,29 +1,41 @@
 /*
- * framebuffer driver for VBE 2.0 compliant graphic boards
- *
- * switching to graphics mode happens at boot time (while
- * running in real mode, see arch/i386/boot/video.S).
+ * Framebuffer driver for VBE 2.0+ compliant graphic boards
  *
  * (c) 1998 Gerd Knorr <kraxel@goldbach.in-berlin.de>
- *
+ *            - original VBE 2.0 driver
+ *
+ * (c) 2004 Micha³ Januszewski <spock@gentoo.org>
+ *            - rewritten to make use of vm86 and VBE 3.0 features
+ *
+ */
+
+/*
+ * $Header: /srv/cvs/vesafb-tng/vesafb.c,v 1.20 2004/05/31 17:40:45 spock Exp $
  */
 
+#ifdef DEBUG
+#define DPRINTK(fmt, args...)	printk(KERN_DEBUG "%s: " fmt, __FUNCTION__ , ## args)
+#else
+#define DPRINTK(fmt, args...)
+#endif
+
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/string.h>
 #include <linux/mm.h>
 #include <linux/tty.h>
-#include <linux/slab.h>
 #include <linux/delay.h>
 #include <linux/fb.h>
 #include <linux/ioport.h>
 #include <linux/init.h>
-#ifdef __i386__
+#include <linux/proc_fs.h>
 #include <video/edid.h>
-#endif
+#include <video/vesa.h>
+
 #include <asm/io.h>
 #include <asm/mtrr.h>
+#include "edid.h"
 
 #define dac_reg	(0x3c8)
 #define dac_val	(0x3c9)
@@ -47,14 +59,40 @@
 	.accel	= FB_ACCEL_NONE,
 };
 
-static int             inverse   = 0;
-static int             mtrr      = 1;
-static int	       vram __initdata = 0; /* Set amount of memory to be used */
-static int             pmi_setpal = 0;	/* pmi for palette changes ??? */
-static int             ypan       = 0;  /* 0..nothing, 1..ypan, 2..ywrap */
-static unsigned short  *pmi_base  = 0;
-static void            (*pmi_start)(void);
-static void            (*pmi_pal)(void);
+static int				mtrr       = 1;	/* use MTRR */
+static int				ypan       = 0;	/* 0 - nothing, 1 - ypan, 2 -ywrap */
+static int				pmi_setpal = 0;	/* pmi for palette changes */
+static unsigned short			*pmi_base  = 0;	/* protected mode interface location in memory */
+static void				(*pmi_start)(void);
+static void				(*pmi_pal)(void);
+static struct task_struct		*vesafb_serv_thread = NULL;
+static struct vesafb_vbe_info_block	vbe_ib;
+static struct vesafb_mode_info_block	*vbe_modes;
+static int				vbe_modes_cnt = 0;
+static u8				mon_limits = 0;	/* 0 - no monitor limits, 1 - full monitor limits,
+							   2 - monitor limits with default pixel clock */
+static int				nocrtc = 0;	/* ignore CRTC settings */
+static struct fb_info                   *vesafb_info = NULL;
+static struct fb_videomode              *edid_modes    __initdata = NULL;
+static int                              edid_modes_cnt __initdata = 0;
+static int                              noedid         __initdata = 0; /* don't try the DDC transfers */
+static int                              vram           __initdata = 0; /* set the amount of memory to be used */
+static int                              maxclk         __initdata = 0; /* maximum pixel clock */
+static int                              maxvf          __initdata = 0; /* maximum vertical frequency */
+static int                              maxhf          __initdata = 0; /* maximum horizontal frequency */
+static int                              gtf            __initdata = 0; /* forces use of the GTF */
+static char                             *mode_option   __initdata = NULL;
+
+extern int vesafb_pid;			/* PID of the vesafb service thread */
+
+/* --------------------------------------------------------------------- */
+
+#define vesafb_create_task(task)	{	task = kmalloc(sizeof(struct vesafb_task), GFP_ATOMIC); \
+						if (task) memset(task,0,sizeof(struct vesafb_task));	}
+
+#define vesafb_wait_for_task(task)	{ while (task->done == 0) { schedule(); } }
+
+extern void vesafb_queue_task(struct vesafb_task *task);
 
 /* --------------------------------------------------------------------- */
 
@@ -63,6 +101,7 @@
 {
 #ifdef __i386__
 	int offset;
+	struct vesafb_task *mytask;
 
 	if (!ypan)
 		return -EINVAL;
@@ -74,29 +113,49 @@
 		return -EINVAL;
 
 	offset = (var->yoffset * info->fix.line_length + var->xoffset) / 4;
-
-        __asm__ __volatile__(
-                "call *(%%edi)"
-                : /* no return value */
-                : "a" (0x4f07),         /* EAX */
-                  "b" (0),              /* EBX */
-                  "c" (offset),         /* ECX */
-                  "d" (offset >> 16),   /* EDX */
-                  "D" (&pmi_start));    /* EDI */
+
+	if (pmi_start) {
+
+		__asm__ __volatile__(
+			"call *(%%edi)"
+			: /* no return value */
+			: "a" (0x4f07),         /* EAX */
+			  "b" (0),              /* EBX */
+			  "c" (offset),         /* ECX */
+			  "d" (offset >> 16),   /* EDX */
+			  "D" (&pmi_start));    /* EDI */
+	}
+#ifdef VESAFB_VM86
+	else {
+		vesafb_create_task (mytask);
+
+		mytask->regs.eax = 0x4f07;
+		mytask->regs.ebx = 0x0;
+		mytask->regs.ecx = offset;
+		mytask->regs.edx = (offset >> 16);
+		mytask->type = VESAFB_TASK_DOVM86;
+
+		vesafb_queue_task (mytask);
+		vesafb_wait_for_task(mytask);
+		kfree(mytask);
+	}
+#endif
 #endif
 	return 0;
 }
 
 static void vesa_setpalette(int regno, unsigned red, unsigned green, unsigned blue)
 {
+	struct vesafb_pal_entry entry;
+	struct vesafb_task *mytask;
+
 #ifdef __i386__
-	struct { u_char blue, green, red, pad; } entry;
+	entry.red   = red   >> 10;
+	entry.green = green >> 10;
+	entry.blue  = blue  >> 10;
+	entry.pad   = 0;
 
 	if (pmi_setpal) {
-		entry.red   = red   >> 10;
-		entry.green = green >> 10;
-		entry.blue  = blue  >> 10;
-		entry.pad   = 0;
 	        __asm__ __volatile__(
                 "call *(%%esi)"
                 : /* no return value */
@@ -107,11 +166,26 @@
                   "D" (&entry),         /* EDI */
                   "S" (&pmi_pal));      /* ESI */
 	} else {
-		/* without protected mode interface, try VGA registers... */
+#ifdef VESAFB_VM86
+		vesafb_create_task (mytask);
+
+		mytask->regs.eax = 0x4f09;
+		mytask->regs.ebx = 0x0;
+		mytask->regs.ecx = 1;
+		mytask->regs.edx = regno;
+		mytask->res = &entry;
+		mytask->type = VESAFB_TASK_SETPAL;
+
+		vesafb_queue_task (mytask);
+		vesafb_wait_for_task(mytask);
+		kfree(mytask);
+#else
+		/* without protected mode interface and vm86 capabilities, try VGA registers... */
 		outb_p(regno,       dac_reg);
 		outb_p(red   >> 10, dac_val);
 		outb_p(green >> 10, dac_val);
 		outb_p(blue  >> 10, dac_val);
+#endif
 	}
 #endif
 }
@@ -171,6 +245,221 @@
     return 0;
 }
 
+#ifdef VESAFB_VM86
+static int vesafb_set_par(struct fb_info *info)
+{
+	struct vesafb_par *par = (struct vesafb_par *) info->par;
+	struct vesafb_task *mytask;
+	struct vesafb_crtc_info_block *crtc = NULL;
+	struct vesafb_mode_info_block *mode = (void*)info->var.reserved[1];
+	int err = 0;
+
+	/* sanity check */
+	if (info->var.reserved[0] == 0xffff)
+		return -EINVAL;
+
+	vesafb_create_task (mytask);
+
+	mytask->regs.eax = 0x4f02;
+	mytask->regs.ebx = (u16)info->var.reserved[0] | 0x8000;	/* use LFB */
+
+	if (vbe_ib.vbe_version >= 0x0300 && !nocrtc) {
+
+		mytask->regs.ebx |= 0x0800; /* use CRTC data */
+		crtc = kmalloc(sizeof(struct vesafb_crtc_info_block), GFP_KERNEL);
+
+		if (!crtc) {
+			err = -ENOMEM;
+			goto sp_end;
+		}
+		crtc->horiz_start = info->var.xres + info->var.right_margin;
+		crtc->horiz_end	  = crtc->horiz_start + info->var.hsync_len;
+		crtc->horiz_total = crtc->horiz_end + info->var.left_margin;
+
+		crtc->vert_start  = info->var.yres + info->var.lower_margin;
+		crtc->vert_end    = crtc->vert_start + info->var.vsync_len;
+		crtc->vert_total  = crtc->vert_end + info->var.upper_margin;
+
+		crtc->pixel_clock = (u32)((u32)1e9 / info->var.pixclock) * (u32)1e3;
+		crtc->refresh_rate = (u16)(100 * (crtc->pixel_clock / (crtc->vert_total * crtc->horiz_total)));
+		crtc->flags = 0;
+
+		if (info->var.vmode & FB_VMODE_DOUBLE)
+			crtc->flags |= 0x1;
+
+		if (info->var.vmode & FB_VMODE_INTERLACED)
+			crtc->flags |= 0x2;
+
+		if (!(info->var.sync & FB_SYNC_HOR_HIGH_ACT))
+			crtc->flags |= 0x4;
+
+		if (!(info->var.sync & FB_SYNC_VERT_HIGH_ACT))
+			crtc->flags |= 0x8;
+
+		memcpy(&par->crtc, crtc, sizeof(struct vesafb_crtc_info_block));
+	} else
+		memset(&par->crtc, 0, sizeof(struct vesafb_crtc_info_block));
+
+	mytask->res = (void*)crtc;
+	mytask->type = VESAFB_TASK_SWITCHMODE;
+
+	vesafb_queue_task (mytask);
+	vesafb_wait_for_task(mytask);
+
+	if (mytask->regs.eax != 0x004f) {
+		printk(KERN_ERR "vesafb: mode switch failed (eax: 0x%lx)\n", mytask->regs.eax);
+		err = -EINVAL;
+		goto sp_end;
+	}
+
+	mytask->done = 0;
+	mytask->type = VESAFB_TASK_DOVM86;
+	mytask->regs.eax = 0x4f06;
+	mytask->regs.ebx = 0x01;
+
+	vesafb_queue_task (mytask);
+	vesafb_wait_for_task(mytask);
+
+	info->fix.visual = (info->var.bits_per_pixel == 8) ? FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;
+	info->fix.line_length = mode->bytes_per_scan_line;
+	par->vbe_mode = info->var.reserved[0];
+
+	DPRINTK("set new mode %dx%d-%d\n", info->var.xres, info->var.yres, info->var.bits_per_pixel);
+
+sp_end:
+	if (crtc != NULL)
+		kfree(crtc);
+	kfree(mytask);
+
+	return err;
+}
+
+void vesafb_setup_var(struct fb_var_screeninfo *var, struct vesafb_mode_info_block *mode)
+{
+	if (var->bits_per_pixel == 15)
+		var->bits_per_pixel = 16;
+
+	if (var->bits_per_pixel > 8) {
+		var->red.offset    = mode->red_off;
+		var->red.length    = mode->red_len;
+		var->green.offset  = mode->green_off;
+		var->green.length  = mode->green_len;
+		var->blue.offset   = mode->blue_off;
+		var->blue.length   = mode->blue_len;
+		var->transp.offset = mode->rsvd_off;
+		var->transp.length = mode->rsvd_len;
+
+		DPRINTK("directcolor: size=%d:%d:%d:%d, shift=%d:%d:%d:%d\n",
+	       		mode->rsvd_len,
+			mode->red_len,
+			mode->green_len,
+			mode->blue_len,
+			mode->rsvd_off,
+			mode->red_off,
+			mode->green_off,
+			mode->blue_off);
+	} else {
+		var->red.length   = 6;
+		var->green.length = 6;
+		var->blue.length  = 6;
+	}
+}
+
+int inline vesafb_check_limits(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	if (mon_limits)
+		return fb_validate_mode(var, info);
+	else
+		return 0;
+}
+
+int vesafb_find_vbe_mode(int xres, int yres, int bpp, unsigned char flags)
+{
+	int match = -1;
+	int i;
+
+	DPRINTK("looking for mode: %dx%d-%d\n", xres, yres, bpp);
+
+	/* first try to find the exact mode the user wants to set.. */
+	for (i = 0; i < vbe_modes_cnt; i++) {
+
+		if (vbe_modes[i].x_res == xres && vbe_modes[i].y_res == yres) {
+
+			int h = bpp - vbe_modes[i].bits_per_pixel;
+
+			/* ok, we've got an exact match, we do the <= 1 check to cover the 15-bit modes */
+			if (h <= 1 && h >= 0)
+				return i;
+
+			if (match == -1 || (bpp - vbe_modes[match].bits_per_pixel) > h)
+				match = i;
+		}
+	}
+
+	/* .. and if this fails look for similar modes */
+	if (match == -1 && flags) {
+
+		unsigned int min = 0xffffffff; /* just a big number */
+		unsigned int d;
+
+		DPRINTK("mode not found (1st pass)\n");
+
+		for (i = 0; i < vbe_modes_cnt; i++) {
+
+			if (vbe_modes[i].y_res < yres || vbe_modes[i].x_res < xres)
+				continue;
+
+			d = vbe_modes[i].y_res - yres + vbe_modes[i].x_res - xres;
+
+			if (d < min) {
+				min = d;
+				match = i;
+			}
+
+			if (d == min && (bpp - vbe_modes[match].bits_per_pixel) >
+	  		    (bpp - vbe_modes[i].bits_per_pixel))
+				match = i;
+		}
+	}
+
+	return match;
+}
+
+int vesafb_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
+{
+	int match = -1;
+
+	if (vesafb_check_limits(var, info))
+		return -EINVAL;
+
+	match = vesafb_find_vbe_mode(var->xres, var->yres, var->bits_per_pixel, (vbe_ib.vbe_version >= 0x300) ? 1 : 0);
+
+	if (match == -1) {
+		printk(KERN_ERR "vesafb: mode %dx%d%dbpp not found\n", var->xres, var->yres, var->bits_per_pixel);
+		var->reserved[0] = 0xffff;
+		return -EINVAL;
+	} else {
+		var->bits_per_pixel = vbe_modes[match].bits_per_pixel;
+		var->reserved[0] = (u32)vbe_modes[match].mode_id;
+		var->reserved[1] = (u32)(&vbe_modes[match]);
+		vesafb_setup_var(var, &vbe_modes[match]);
+
+		DPRINTK("found mode 0x%x (%dx%d-%dbpp)\n",
+			vbe_modes[match].mode_id, vbe_modes[match].x_res, vbe_modes[match].y_res,
+			vbe_modes[match].bits_per_pixel);
+	}
+
+	return 0;
+}
+#endif /* VESAFB_VM86 */
+
+static void vesafb_platform_release(struct device *device)
+{
+	return;
+}
+
+static int __init vesafb_probe(struct device *device);
+
 static struct fb_ops vesafb_ops = {
 	.owner		= THIS_MODULE,
 	.fb_setcolreg	= vesafb_setcolreg,
@@ -179,8 +468,26 @@
 	.fb_copyarea	= cfb_copyarea,
 	.fb_imageblit	= cfb_imageblit,
 	.fb_cursor	= soft_cursor,
+#ifdef VESAFB_VM86
+	.fb_check_var	= vesafb_check_var,
+	.fb_set_par	= vesafb_set_par
+#endif
+};
+
+static struct device_driver vesafb_driver = {
+	.name	= "vesafb",
+	.bus	= &platform_bus_type,
+	.probe	= vesafb_probe,
 };
 
+static struct platform_device vesafb_device = {
+	.name	= "vesafb",
+        .dev    = {
+                .release = vesafb_platform_release,
+        }
+};
+
+#ifndef MODULE
 int __init vesafb_setup(char *options)
 {
 	char *this_opt;
@@ -188,12 +495,14 @@
 	if (!options || !*options)
 		return 0;
 	
+	DPRINTK("options %s\n",options);
+
 	while ((this_opt = strsep(&options, ",")) != NULL) {
 		if (!*this_opt) continue;
 		
-		if (! strcmp(this_opt, "inverse"))
-			inverse=1;
-		else if (! strcmp(this_opt, "redraw"))
+		DPRINTK("this_opt: %s\n",this_opt);
+
+		if (! strcmp(this_opt, "redraw"))
 			ypan=0;
 		else if (! strcmp(this_opt, "ypan"))
 			ypan=1;
@@ -207,24 +516,288 @@
 			mtrr=1;
 		else if (! strcmp(this_opt, "nomtrr"))
 			mtrr=0;
+		else if (! strcmp(this_opt, "nocrtc"))
+			nocrtc=1;
+		else if (! strcmp(this_opt, "noedid"))
+			noedid=1;
+		else if (! strcmp(this_opt, "gtf"))
+			gtf=1;
 		else if (! strncmp(this_opt, "vram:", 5))
-			vram = simple_strtoul(this_opt+5, NULL, 0);
+			vram = simple_strtoul(this_opt + 5, NULL, 0);
+		else if (! strncmp(this_opt, "maxhf:", 6))
+			maxhf = simple_strtoul(this_opt + 6, NULL, 0);
+		else if (! strncmp(this_opt, "maxvf:", 6))
+			maxhf = simple_strtoul(this_opt + 6, NULL, 0);
+		else if (! strncmp(this_opt, "maxclk:", 7))
+			maxclk = simple_strtoul(this_opt + 7, NULL, 0);
+		else {
+			DPRINTK("mode_option: %s\n",this_opt);
+			mode_option = this_opt;
+		}
+	}
+
+	return 0;
+}
+
+#endif /* !MODULE */
+
+#ifdef VESAFB_VM86
+static int vesafb_read_proc_modes(char *buf, char **start, off_t offset,
+			    	  int len, int *eof, void *private)
+{
+	int clen = 0, i;
+
+	for (i = 0; i < vbe_modes_cnt; i++)
+		clen += sprintf(buf + clen, "%dx%d-%d\n", vbe_modes[i].x_res,
+				vbe_modes[i].y_res, vbe_modes[i].bits_per_pixel);
+
+	*start = buf + offset;
+
+	if (clen > offset)
+		clen -= offset;
+	else
+		clen = 0;
+
+	return clen;
+}
+
+static int vesafb_read_proc_vbe_info(char *buf, char **start, off_t offset,
+			    	     int len, int *eof, void *private)
+{
+	int clen = 0;
+
+	clen += sprintf(buf + clen, "Version:    %d.%d\n", ((vbe_ib.vbe_version & 0xff00) >> 8), vbe_ib.vbe_version & 0xff);
+	clen += sprintf(buf + clen, "Vendor:     %s\n", (char*)vbe_ib.oem_vendor_name_ptr);
+	clen += sprintf(buf + clen, "Product:    %s\n", (char*)vbe_ib.oem_product_name_ptr);
+	clen += sprintf(buf + clen, "OEM rev:    %s\n", (char*)vbe_ib.oem_product_rev_ptr);
+	clen += sprintf(buf + clen, "OEM string: %s\n", (char*)vbe_ib.oem_string_ptr);
+
+	*start = buf + offset;
+
+	if (clen > offset)
+		clen -= offset;
+	else
+		clen = 0;
+
+	return clen;
+}
+
+
+static int __init vesafb_vbe_init(struct fb_info *info)
+{
+	struct vesafb_task *mytask;
+	u16 *mode = 0;
+	int off = 0;
+	int i;
+
+	vesafb_create_task (mytask);
+	mytask->regs.eax = 0x4f00;
+	mytask->type = VESAFB_TASK_GETVBE_IB;
+	mytask->res = &vbe_ib;
+	vesafb_queue_task (mytask);
+	vesafb_wait_for_task(mytask);
+
+	if (vbe_ib.vbe_version < 0x0200 || mytask->regs.eax != 0x004F) {
+		printk(KERN_ERR "vesafb: Sorry, pre-VBE 2.0 cards are not supported.\n");
+		kfree(mytask);
+		return 1;
+	}
+
+	printk(KERN_INFO "vesafb: %s, %s, %s (OEM: %s)\n", (char*)vbe_ib.oem_vendor_name_ptr,
+		(char*)vbe_ib.oem_product_name_ptr, (char*)vbe_ib.oem_product_rev_ptr,
+		(char*)vbe_ib.oem_string_ptr);
+
+	printk(KERN_INFO "vesafb: VBE version: %d.%d\n",((vbe_ib.vbe_version & 0xff00) >> 8), vbe_ib.vbe_version & 0xff);
+
+	/* count the available modes */
+	mode = (u16*)vbe_ib.mode_list_ptr;
+	while (*mode != 0xffff) {
+		vbe_modes_cnt++;
+		mode++;
+	}
+
+	vbe_modes = kmalloc(sizeof(struct vesafb_mode_info_block)*vbe_modes_cnt,GFP_KERNEL);
+
+	/* get mode info for all available modes */
+	mode = (u16*)vbe_ib.mode_list_ptr;
+
+	while (*mode != 0xffff) {
+		mytask->regs.eax = 0x4f01;
+		mytask->regs.ecx = (u32) *mode;
+		mytask->type = VESAFB_TASK_GETVBE_MODEINFO;
+		mytask->res = vbe_modes+off;
+		mytask->done = 0;
+
+		vesafb_queue_task (mytask);
+		vesafb_wait_for_task(mytask);
+
+		vesafb_pmib(mytask->res)->mode_id = *mode;
+
+		/* forget text modes */
+		if ((vesafb_pmib(mytask->res)->mode_attr & 0x10) != 0 &&
+		    vesafb_pmib(mytask->res)->bits_per_pixel >= 8)
+			off++;
+		else
+			vbe_modes_cnt--;
+
+		mode++;
+	}
+
+	mytask->regs.eax = 0x4f0a;
+	mytask->regs.ebx = 0x0;
+	mytask->type = VESAFB_TASK_DOVM86;
+	mytask->res = NULL;
+	mytask->done = 0;
+
+	vesafb_queue_task(mytask);
+	vesafb_wait_for_task(mytask);
+
+	if (mytask->regs.eax != 0x004f || mytask->regs.es < 0xc000) {
+		pmi_setpal = 0;
+		goto vi_1;
+	}
+
+	printk(KERN_INFO "vesafb: protected mode interface info at %04x:%04x\n", (u16)mytask->regs.es, (u16)mytask->regs.edi);
+	pmi_base  = (unsigned short*)phys_to_virt(((unsigned long)mytask->regs.es << 4) + mytask->regs.edi);
+	pmi_start = (void*)((char*)pmi_base + pmi_base[1]);
+	pmi_pal   = (void*)((char*)pmi_base + pmi_base[2]);
+	printk(KERN_INFO "vesafb: pmi: set display start = %p, set palette = %p\n",pmi_start,pmi_pal);
+
+	if (pmi_base[3]) {
+		printk(KERN_INFO "vesafb: pmi: ports = ");
+		for (i = pmi_base[3]/2; pmi_base[i] != 0xffff; i++)
+			printk("%x ",pmi_base[i]);
+		printk("\n");
+
+		if (pmi_base[i] != 0xffff) {
+			/*
+			 * memory areas not supported (yet?)
+			 *
+			 * Rules are: we have to set up a descriptor for the requested
+			 * memory area and pass it in the ES register to the BIOS function.
+			 */
+			printk(KERN_INFO "vesafb: can't handle memory requests, pmi disabled\n");
+			ypan = pmi_setpal = 0;
+		}
 	}
+
+vi_1:	if (noedid)
+		goto vi_2;
+
+	mytask->regs.eax = 0x4f15;
+	mytask->regs.ebx = 0;
+	mytask->regs.ecx = 0;
+	mytask->done = 0;
+
+	vesafb_queue_task(mytask);
+	vesafb_wait_for_task(mytask);
+
+	if (mytask->regs.eax != 0x004f)
+		goto vi_2;
+
+	if ((mytask->regs.ebx & 0x3) == 3) {
+		printk(KERN_INFO "vesafb: hardware supports both DCC1 and DCC2 transfers\n");
+	} else if ((mytask->regs.ebx & 0x3) == 2) {
+		printk(KERN_INFO "vesafb: hardware supports DCC2 transfers\n");
+	} else if ((mytask->regs.ebx & 0x3) == 1) {
+		printk(KERN_INFO "vesafb: hardware supports DCC1 transfers\n");
+	} else {
+		printk(KERN_INFO "vesafb: hardware doesn't support DCC transfers\n");
+		goto vi_2;
+	}
+
+	mytask->regs.eax = 0x4f15;
+	mytask->regs.ebx = 1;
+	mytask->regs.ecx = mytask->regs.edx = mytask->done = 0;
+	mytask->type = VESAFB_TASK_GETEDID;
+	mytask->res = kmalloc(EDID_LENGTH, GFP_KERNEL);
+
+	vesafb_queue_task(mytask);
+	vesafb_wait_for_task(mytask);
+
+	if (mytask->regs.eax == 0x004F) {
+
+		unsigned char *block = mytask->res;
+		unsigned short h = COMBINE_HI_8LO(block[ID_MANUFACTURER_NAME], block[ID_MANUFACTURER_NAME+1]);
+		char sign[4];
+
+		sign[0] = sign[1] = sign[2] = ' ';
+		sign[0] = ((h>>10) & 0x1f) + 'A' - 1;
+		sign[1] = ((h>>5) & 0x1f) + 'A' - 1;
+		sign[2] = (h & 0x1f) + 'A' - 1;
+		sign[3] = 0;
+
+		printk(KERN_INFO "vesafb: EDID vendor sign: %s\n", sign);
+		mon_limits = !fb_get_monitor_limits(mytask->res, &info->monspecs);
+
+		if (mon_limits && info->monspecs.dclkmax == 0) {
+			info->monspecs.dclkmax = 300 * 1000000;
+			mon_limits = 2;
+		}
+
+		edid_modes = fb_create_modedb(mytask->res, &edid_modes_cnt);
+	}
+	kfree(mytask->res);
+
+vi_2:
+	if (maxclk)
+		info->monspecs.dclkmax = maxclk * 1000000;
+
+	if (maxvf)
+		info->monspecs.vfmax = maxvf;
+
+	if (maxhf)
+		info->monspecs.hfmax = maxhf * 1000;
+
+	/* in case DCC transfers are not supported the user can provide monitor limits
+	   manually, lower limits are set to "safe" values */
+	if (!mon_limits && maxclk && maxvf && maxhf) {
+		info->monspecs.dclkmax = 0;
+		info->monspecs.vfmin = 60;
+		info->monspecs.hfmin = 29000;
+	}
+
+	printk(KERN_INFO "vesafb: monitor limits: vf = %d Hz, hf = %d kHz, clk = %d MHz\n",
+		info->monspecs.vfmax, (int)(info->monspecs.hfmax / 1000),
+		(int)(info->monspecs.dclkmax / 1000000));
+
+	kfree(mytask);
 	return 0;
 }
+#endif /* VESAFB_VM86 */
 
 static int __init vesafb_probe(struct device *device)
 {
+	char entry[16];
 	struct platform_device *dev = to_platform_device(device);
 	struct fb_info *info;
-	int i, err;
+	int err = 0, i;
 
-	if (screen_info.orig_video_isVGA != VIDEO_TYPE_VLFB)
-		return -ENXIO;
+	vesafb_info = info = framebuffer_alloc(sizeof(struct vesafb_par) + sizeof(u32) * 256, &dev->dev);
+
+	if (!info)
+	 	return -ENOMEM;
+
+#ifdef VESAFB_VM86
+	if (vesafb_pid)
+		vesafb_serv_thread = find_task_by_pid(vesafb_pid);
+	else {
+		printk(KERN_ERR "vesafb: vesafb thread not running - returning..\n");
+		framebuffer_release(info);
+		return -EINVAL;
+	}
+
+	if (vesafb_vbe_init(info)) {
+		printk(KERN_ERR "vesafb: vbe_init failed - returning..\n");
+		err = -EINVAL;
+		goto pr_err;
+	}
 
+	vesafb_fix.smem_len = vbe_ib.total_memory * 65536;
+#else
 	vesafb_fix.smem_start = screen_info.lfb_base;
 	vesafb_defined.bits_per_pixel = screen_info.lfb_depth;
-	if (15 == vesafb_defined.bits_per_pixel)
+	if (vesafb_defined.bits_per_pixel == 15)
 		vesafb_defined.bits_per_pixel = 16;
 	vesafb_defined.xres = screen_info.lfb_width;
 	vesafb_defined.yres = screen_info.lfb_height;
@@ -237,58 +810,17 @@
 	if (vesafb_fix.smem_len > (screen_info.lfb_size * 65536))
 		vesafb_fix.smem_len = screen_info.lfb_size * 65536;
 
-	/* Set video size according to vram boot option */
-	if (vram)
-		vesafb_fix.smem_len = vram * 1024 * 1024;
-
-	vesafb_fix.visual   = (vesafb_defined.bits_per_pixel == 8) ?
-		FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;
-
 	/* limit framebuffer size to 16 MB.  Otherwise we'll eat tons of
 	 * kernel address space for nothing if the gfx card has alot of
 	 * memory (>= 128 MB isn't uncommon these days ...) */
 	if (vesafb_fix.smem_len > 16 * 1024 * 1024)
 		vesafb_fix.smem_len = 16 * 1024 * 1024;
 
+	vesafb_fix.visual = (vesafb_defined.bits_per_pixel == 8) ? FB_VISUAL_PSEUDOCOLOR : FB_VISUAL_TRUECOLOR;
+
 #ifndef __i386__
 	screen_info.vesapm_seg = 0;
 #endif
-
-	if (!request_mem_region(vesafb_fix.smem_start, vesafb_fix.smem_len, "vesafb")) {
-		printk(KERN_WARNING
-		       "vesafb: abort, cannot reserve video memory at 0x%lx\n",
-			vesafb_fix.smem_start);
-		/* We cannot make this fatal. Sometimes this comes from magic
-		   spaces our resource handlers simply don't know about */
-	}
-
-	info = framebuffer_alloc(sizeof(u32) * 256, &dev->dev);
-	if (!info) {
-		release_mem_region(vesafb_fix.smem_start, vesafb_fix.smem_len);
-		return -ENOMEM;
-	}
-	info->pseudo_palette = info->par;
-	info->par = NULL;
-
-        info->screen_base = ioremap(vesafb_fix.smem_start, vesafb_fix.smem_len);
-	if (!info->screen_base) {
-		printk(KERN_ERR
-		       "vesafb: abort, cannot ioremap video memory 0x%x @ 0x%lx\n",
-			vesafb_fix.smem_len, vesafb_fix.smem_start);
-		err = -EIO;
-		goto err;
-	}
-
-	printk(KERN_INFO "vesafb: framebuffer at 0x%lx, mapped to 0x%p, size %dk\n",
-	       vesafb_fix.smem_start, info->screen_base, vesafb_fix.smem_len/1024);
-	printk(KERN_INFO "vesafb: mode is %dx%dx%d, linelength=%d, pages=%d\n",
-	       vesafb_defined.xres, vesafb_defined.yres, vesafb_defined.bits_per_pixel, vesafb_fix.line_length, screen_info.pages);
-
-	if (screen_info.vesapm_seg) {
-		printk(KERN_INFO "vesafb: protected mode interface info at %04x:%04x\n",
-		       screen_info.vesapm_seg,screen_info.vesapm_off);
-	}
-
 	if (screen_info.vesapm_seg < 0xc000)
 		ypan = pmi_setpal = 0; /* not available or some DOS TSR ... */
 
@@ -317,14 +849,6 @@
 
 	vesafb_defined.xres_virtual = vesafb_defined.xres;
 	vesafb_defined.yres_virtual = vesafb_fix.smem_len / vesafb_fix.line_length;
-	if (ypan && vesafb_defined.yres_virtual > vesafb_defined.yres) {
-		printk(KERN_INFO "vesafb: scrolling: %s using protected mode interface, yres_virtual=%d\n",
-		       (ypan > 1) ? "ywrap" : "ypan",vesafb_defined.yres_virtual);
-	} else {
-		printk(KERN_INFO "vesafb: scrolling: redraw\n");
-		vesafb_defined.yres_virtual = vesafb_defined.yres;
-		ypan = 0;
-	}
 
 	/* some dummy values for timing to make fbset happy */
 	vesafb_defined.pixclock     = 10000000 / vesafb_defined.xres * 1000 / vesafb_defined.yres;
@@ -355,59 +879,235 @@
 		vesafb_defined.green.length = 6;
 		vesafb_defined.blue.length  = 6;
 	}
+#endif	/* VESAFB_VM86 */
 
 	vesafb_fix.ypanstep  = ypan     ? 1 : 0;
 	vesafb_fix.ywrapstep = (ypan>1) ? 1 : 0;
+
+	/* vram boot option override */
+	if (vram)
+		vesafb_fix.smem_len = vram * 1024 * 1024;
+
+	printk(KERN_INFO "vesafb: total memory: %d\n", vesafb_fix.smem_len);
+
+	info->pseudo_palette = ((u8*)info->par + sizeof(struct vesafb_par));
+	info->fbops = &vesafb_ops;
+	info->var = vesafb_defined;
+	info->fix = vesafb_fix;
+	info->flags = FBINFO_FLAG_DEFAULT;
+
+	if (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {
+		err = -ENXIO;
+		goto pr_err;
+	}
+
+#ifdef VESAFB_VM86
+	if (!mode_option)
+		mode_option = CONFIG_FB_VESA_DEFAULT_MODE;
+
+	if (gtf)
+		goto pr_manual;
+
+	i = fb_find_mode(&info->var, info, mode_option, vesa_modes, 33, NULL, 0);
+
+	DPRINTK("fb_find_mode returned %d\n", i);
+
+	if (i == 0 || i >= 3)
+pr_manual:
+	{
+		int match = -1;
+		unsigned int len = strlen(mode_option);
+		unsigned int xres = 0, yres = 0, bpp = 8, refresh = 60;
+		unsigned char res_specified = 0, bpp_specified = 0, refresh_specified = 0, yres_specified = 0;
+
+		for (i = len-1; i >= 0; i--) {
+	    		switch (mode_option[i]) {
+				case '@':
+		    			len = i;
+		    			if (!refresh_specified && !bpp_specified &&
+					    !yres_specified) {
+						refresh = simple_strtoul(&mode_option[i+1], NULL, 0);
+						refresh_specified = 1;
+		    			} else
+						goto pr_modedone;
+		    			break;
+				case '-':
+		    			len = i;
+		    			if (!bpp_specified && !yres_specified) {
+					    	bpp = simple_strtoul(&mode_option[i+1], NULL, 0);
+						bpp_specified = 1;
+		    			} else
+						goto pr_modedone;
+		    			break;
+				case 'x':
+		    			if (!yres_specified) {
+						yres = simple_strtoul(&mode_option[i+1], NULL, 0);
+						yres_specified = 1;
+		    			} else
+						goto pr_modedone;
+		    			break;
+				case '0'...'9':
+		    			break;
+				default:
+		    			goto pr_modedone;
+	    		}
+		}
+
+		if (i < 0 && yres_specified) {
+	    		xres = simple_strtoul(mode_option, NULL, 0);
+	    		res_specified = 1;
+		}
+
+pr_modedone:	if (!res_specified || !yres_specified) {
+			err = -EINVAL;
+			goto pr_err1;
+		}
+
+		match = vesafb_find_vbe_mode(xres, yres, bpp, (vbe_ib.vbe_version >= 0x300) ? 1 : 0);
+
+		if (match == -1) {
+			printk(KERN_ERR "vesafb: no matching VBE mode found\n");
+			err = -EINVAL;
+			goto pr_err1;
+		}
+
+		info->var.xres = xres;
+		info->var.yres = yres;
+		info->var.xres_virtual = xres;
+		info->var.xoffset = 0;
+		info->var.yoffset = 0;
+		info->var.bits_per_pixel = vbe_modes[match].bits_per_pixel;
+		info->var.reserved[0] = (u32)vbe_modes[match].mode_id;
+		info->var.reserved[1] = (u32)(&vbe_modes[match]);
+		info->var.vmode = FB_VMODE_NONINTERLACED;
+		info->var.sync = FB_SYNC_VERT_HIGH_ACT;
+		vesafb_setup_var(&info->var, &vbe_modes[match]);
+
+		if (edid_modes != NULL && !gtf) {
+
+			DPRINTK("looking for EDID modes\n");
+
+			for (i = 0; i < edid_modes_cnt; i++) {
+
+				if (edid_modes[i].xres == xres && edid_modes[i].yres == yres &&
+				    edid_modes[i].refresh - refresh < 5 && edid_modes[i].refresh - refresh > -5) {
+
+					info->var.pixclock = edid_modes[i].pixclock;
+				    	info->var.left_margin = edid_modes[i].left_margin;
+					info->var.right_margin = edid_modes[i].right_margin;
+					info->var.upper_margin = edid_modes[i].upper_margin;
+					info->var.lower_margin = edid_modes[i].lower_margin;
+					info->var.hsync_len = edid_modes[i].hsync_len;
+					info->var.vsync_len = edid_modes[i].vsync_len;
+					info->var.sync = edid_modes[i].sync;
+					info->var.vmode = edid_modes[i].vmode;
+					DPRINTK("using EDID-provided mode\n");
+					goto pr_end;
+				}
+			}
+		}
+
+		i = FB_MAXTIMINGS;
+
+		if (refresh_specified)
+			i = FB_VSYNCTIMINGS;
+
+		if (!mon_limits) {
+			i = FB_VSYNCTIMINGS | FB_IGNOREMON;
+		} else if (mon_limits == 2) {
+			refresh = 60;
+		}
+
+		if (fb_get_mode(i, refresh, &info->var, info) != 0) {
+			printk(KERN_ERR "vesafb: fb_get_mode failed\n");
+			err = -EINVAL;
+			goto pr_err1;
+		}
+	}
+pr_end:
+	info->var.yres_virtual = info->fix.smem_len / ((struct vesafb_mode_info_block*)info->var.reserved[1])->bytes_per_scan_line;
+	info->fix.smem_start = ((struct vesafb_mode_info_block*)info->var.reserved[1])->phys_base_ptr;
+#endif /* VESAFB_VM86 */
+
+	if (ypan && info->var.yres_virtual > info->var.yres) {
+		printk(KERN_INFO "vesafb: scrolling: %s using protected mode interface, yres_virtual=%d\n",
+		       (ypan > 1) ? "ywrap" : "ypan",info->var.yres_virtual);
+	} else {
+		printk(KERN_INFO "vesafb: scrolling: redraw\n");
+		info->var.yres_virtual = info->var.yres;
+		ypan = 0;
+	}
+
+	if (!request_mem_region(info->fix.smem_start, info->fix.smem_len, "vesafb")) {
+		printk(KERN_WARNING "vesafb: cannot reserve video memory at 0x%lx\n", info->fix.smem_start);
+		/* We cannot make this fatal. Sometimes this comes from magic
+		   spaces our resource handlers simply don't know about */
+	}
+
+	info->screen_base = ioremap(info->fix.smem_start, info->fix.smem_len);
+
+	if (!info->screen_base) {
+		printk(KERN_ERR
+		       "vesafb: abort, cannot ioremap video memory 0x%x @ 0x%lx\n",
+			info->fix.smem_len, info->fix.smem_start);
+		err = -EIO;
+		goto pr_err2;
+ 	}
 
 	/* request failure does not faze us, as vgacon probably has this
-	 * region already (FIXME) */
+	   region already (FIXME) */
 	request_region(0x3c0, 32, "vesafb");
 
 	if (mtrr) {
-		int temp_size = vesafb_fix.smem_len;
+		int temp_size = info->fix.smem_len;
+
 		/* Find the largest power-of-two */
 		while (temp_size & (temp_size - 1))
                 	temp_size &= (temp_size - 1);
                         
                 /* Try and find a power of two to add */
-		while (temp_size && mtrr_add(vesafb_fix.smem_start, temp_size, MTRR_TYPE_WRCOMB, 1)==-EINVAL) {
+		while (temp_size && mtrr_add(info->fix.smem_start, temp_size, MTRR_TYPE_WRCOMB, 1) == -EINVAL) {
 			temp_size >>= 1;
 		}
 	}
-	
-	info->fbops = &vesafb_ops;
-	info->var = vesafb_defined;
-	info->fix = vesafb_fix;
-	info->flags = FBINFO_FLAG_DEFAULT;
 
-	if (fb_alloc_cmap(&info->cmap, 256, 0) < 0) {
-		err = -ENXIO;
-		goto err;
-	}
-	if (register_framebuffer(info)<0) {
+	if (register_framebuffer(info) < 0) {
 		err = -EINVAL;
-		fb_dealloc_cmap(&info->cmap);
-		goto err;
+		goto pr_err2;
 	}
-	printk(KERN_INFO "fb%d: %s frame buffer device\n",
-	       info->node, info->fix.id);
+
+  	printk(KERN_INFO "vesafb: framebuffer at 0x%lx, mapped to 0x%p, size %dk\n",
+	       info->fix.smem_start, info->screen_base, info->fix.smem_len/1024);
+	printk(KERN_INFO "fb%d: %s frame buffer device\n", info->node, info->fix.id);
+
+#ifdef VESAFB_VM86
+	sprintf(entry, "fb%d", info->node);
+	proc_mkdir(entry, 0);
+
+	sprintf(entry, "fb%d/modes", info->node);
+	create_proc_read_entry(entry, 0, 0, vesafb_read_proc_modes, NULL);
+
+	sprintf(entry, "fb%d/vbe_info", info->node);
+	create_proc_read_entry(entry, 0, 0, vesafb_read_proc_vbe_info, NULL);
+
+	fb_destroy_modedb(edid_modes);
+#endif
 	return 0;
-err:
+
+pr_err2:
+	release_mem_region(info->fix.smem_start, info->fix.smem_len);
+pr_err1:
+	fb_dealloc_cmap(&info->cmap);
+pr_err:
 	framebuffer_release(info);
-	release_mem_region(vesafb_fix.smem_start, vesafb_fix.smem_len);
+
+#ifdef VESAFB_VM86
+	fb_destroy_modedb(edid_modes);
+	kfree(vbe_modes);
+#endif
 	return err;
 }
 
-static struct device_driver vesafb_driver = {
-	.name	= "vesafb",
-	.bus	= &platform_bus_type,
-	.probe	= vesafb_probe,
-};
-
-static struct platform_device vesafb_device = {
-	.name	= "vesafb",
-};
-
 int __init vesafb_init(void)
 {
 	int ret;
@@ -419,15 +1119,69 @@
 		if (ret)
 			driver_unregister(&vesafb_driver);
 	}
+
 	return ret;
 }
 
-/*
- * Overrides for Emacs so that we follow Linus's tabbing style.
- * ---------------------------------------------------------------------------
- * Local variables:
- * c-basic-offset: 8
- * End:
- */
+#ifdef MODULE
+
+void vesafb_exit(void)
+{
+	char entry[16];
+
+	unregister_framebuffer(vesafb_info);
+	platform_device_unregister(&vesafb_device);
+	driver_unregister(&vesafb_driver);
+
+	sprintf(entry, "fb%d/modes", vesafb_info->node);
+	remove_proc_entry(entry, NULL);
+
+	sprintf(entry, "fb%d/vbe_info", vesafb_info->node);
+	remove_proc_entry(entry, NULL);
+
+	sprintf(entry, "fb%d", vesafb_info->node);
+	remove_proc_entry(entry, NULL);
+
+	release_mem_region(vesafb_info->fix.smem_start, vesafb_info->fix.smem_len);
+	fb_dealloc_cmap(&vesafb_info->cmap);
+	framebuffer_release(vesafb_info);
+
+	kfree(vbe_modes);
+}
+
+module_init(vesafb_init);
+module_exit(vesafb_exit);
+
+static inline int param_get_scroll(char *buffer, struct kernel_param *kp) { return 0; }
+static inline int param_set_scroll(const char *val, struct kernel_param *kp)
+{
+	ypan = 0;
+
+	if (! strcmp(val, "redraw"))
+		ypan=0;
+	else if (! strcmp(val, "ypan"))
+		ypan=1;
+	else if (! strcmp(val, "ywrap"))
+		ypan=2;
+
+	return 0;
+}
+
+#define param_check_scroll(name, p) __param_check(name, p, void);
+
+module_param_named(scroll, ypan, scroll, 0);
+module_param_named(vgapal, pmi_setpal, invbool, 0);
+module_param_named(pmipal, pmi_setpal, bool, 0);
+module_param_named(nomtrr, mtrr, invbool, 0);
+module_param(nocrtc, bool, 0);
+module_param(noedid, bool, 0);
+module_param(gtf, bool, 0);
+module_param(vram, uint, 0);
+module_param(maxclk, uint, 0);
+module_param(maxhf, uint, 0);
+module_param(maxvf, uint, 0);
+module_param_named(mode, mode_option, charp, 0);
+
+#endif /* MODULE */
 
 MODULE_LICENSE("GPL");
diff -Naur linux-2.6.7-orig/drivers/video/vesafb-thread.c linux-2.6.7-vesa/drivers/video/vesafb-thread.c
--- linux-2.6.7-orig/drivers/video/vesafb-thread.c	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.7-vesa/drivers/video/vesafb-thread.c	2004-06-20 23:08:15.000000000 +0200
@@ -0,0 +1,313 @@
+/*
+ * Framebuffer driver for VBE 2.0+ compliant graphic boards - kernel thread
+ * and vm86 routines.
+ *
+ * This code has to be compiled into the kernel even if vesafb is configured
+ * as a module. If vesafb_thread were to be started while the module is being
+ * initialized, it would share its active_mm with modprobe. This mm would be
+ * lost after modprobe finished its work, and we can't allow it, because we
+ * need it for as long as the vesafb thread is active.
+ *
+ * (c) 2004 Micha³ Januszewski <spock@gentoo.org>
+ *
+ */
+
+#include <linux/workqueue.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/mm.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/signal.h>
+#include <linux/suspend.h>
+#include <video/vesa.h>
+#include <video/edid.h>
+#include <asm/mman.h>
+#include <asm/page.h>
+#include <asm/vm86.h>
+#include <asm/unistd.h>
+#include <asm/thread_info.h>
+#include <asm/uaccess.h>
+#include "edid.h"
+
+#ifdef DEBUG
+#define DPRINTK(fmt, args...)	printk(KERN_DEBUG "%s: " fmt, __FUNCTION__ , ## args)
+#else
+#define DPRINTK(fmt, args...)
+#endif
+
+static int		errno = 0;
+int			vesafb_pid = 0;
+struct vm86_struct	vm86;
+
+static DECLARE_MUTEX(vesafb_sem);
+static LIST_HEAD(vesafb_task_list);
+static DECLARE_WAIT_QUEUE_HEAD(vesafb_wait);
+
+_syscall3(int,ioperm,unsigned long, a, unsigned long, b, unsigned long, c);
+_syscall1(int,vm86old,struct vm86_struct __user*, v86);
+
+#define DEFAULT_VM86_FLAGS (IF_MASK | IOPL_MASK)
+#define VM86_PUSHW(x)	vm86.regs.esp -= 2; *(unsigned short*)(real_mem+vm86.regs.esp) = x;
+#define REAL_MEM_SIZE	0x20000
+#define REAL_MEM	0x10000
+#define RET_CODE_SIZE 	0x02
+#define STACK_SIZE	0x500
+#define BUFFER		(STACK_SIZE + RET_CODE_SIZE)
+
+void vesafb_queue_task(struct vesafb_task *task)
+{
+	list_add_tail(&task->node, &vesafb_task_list);
+	wake_up(&vesafb_wait);
+}
+
+void vesafb_do_vm86(struct vm86_regs *regs)
+{
+        unsigned char *real_mem = (void*)REAL_MEM;
+
+	memset(&vm86,0,sizeof(vm86));
+	memcpy(&vm86.regs, regs, sizeof(struct vm86_regs));
+
+	/* the return code */
+	real_mem[0] = 0xcd;  		/* int opcode */
+	real_mem[1] = 0xff;		/* int number (255) */
+
+        /* we use int 255 to get back to protected mode */
+	memset(&vm86.int_revectored, 0, sizeof(vm86.int_revectored));
+        ((unsigned char *) &vm86.int_revectored)[0xff / 8] |= (1 << (0xff % 8));	/* int 0xff */
+
+	/* it's up to the caller to set the rest of the registers */
+	vm86.regs.eflags = DEFAULT_VM86_FLAGS;
+	vm86.regs.cs = *(unsigned short *)0x42;		/* 0x10 * 4 + 2 - the int map starts at 0x0	*/
+	vm86.regs.eip = *(unsigned short *)0x40;	/* 0x10 * 4					*/
+
+	/* stack @ 0x10500, size: 0x500-4 - should be enough for our needs */
+	vm86.regs.ss = (REAL_MEM >> 4);
+	vm86.regs.esp = STACK_SIZE+RET_CODE_SIZE;
+
+	/* these will be fetched off the stack when we come to an iret in the int's 0x10 code */
+	VM86_PUSHW(DEFAULT_VM86_FLAGS);
+	VM86_PUSHW((REAL_MEM >> 4));		/* return code segment */
+	VM86_PUSHW(0x0000);			/* return code offset */
+
+	vm86old(&vm86);
+
+	/* copy the registers' state back to the caller's struct */
+	memcpy(regs, &vm86.regs, sizeof(struct vm86_regs));
+}
+
+#define vesafb_get_string(str) { \
+													\
+	/* the address is in the form ssssoooo, where oooo = offset, ssss = segment */			\
+	addr = ((vbe_pib(task->res)->str & 0xffff0000) >> 12) +						\
+		(vbe_pib(task->res)->str & 0x0000ffff);							\
+													\
+	/* the data is in ROM which is shared between processes, so we just translate the		\
+	   real mode address into one visible from the kernel space */					\
+	if (addr >= 0xa0000) {										\
+		vbe_pib(task->res)->str = (u32) __va(addr);						\
+													\
+	/* the data is in the buffer, we just have to convert the address so that it would		\
+	   point into the buffer user provided */							\
+	} else if (addr > REAL_MEM+BUFFER && addr < REAL_MEM+BUFFER + 					\
+		   sizeof(struct vesafb_vbe_info_block)) {						\
+		addr -= BUFFER+REAL_MEM;					 			\
+		vbe_pib(task->res)->str = (u32) (task->res + addr);					\
+													\
+	/* this should never happen: someone was insane enough to put the data somewhere in the RAM;	\
+	   we need to copy as much of it as possible to our buffer */					\
+	} else {											\
+		res = strlcpy((char*) (((int)&(vbe_pib(task->res)->oem_data)) + oem_offset),		\
+			      (char*) addr, sizeof(vbe_pib(task->res)->oem_data) - oem_offset);		\
+													\
+		vbe_pib(task->res)->str = ((u32)&(vbe_pib(task->res)->oem_data)) + oem_offset;		\
+													\
+		oem_offset += res+1;									\
+		if (oem_offset > sizeof(vbe_pib(task->res)->oem_data)) {				\
+			oem_offset = sizeof(vbe_pib(task->res)->oem_data);				\
+		}											\
+	}												\
+}
+
+void vesafb_handle_tasks(void)
+{
+	struct vesafb_task *task;
+	struct list_head *node, *next;
+	int addr, oem_offset = 0, res;
+
+	down(&vesafb_sem);
+	list_for_each_safe(node, next, &vesafb_task_list) {
+
+		task = container_of(node, struct vesafb_task, node);
+
+		switch (task->type) {
+
+			case VESAFB_TASK_DOVM86:
+				vesafb_do_vm86(&task->regs);
+				break;
+
+			case VESAFB_TASK_GETVBE_IB:
+				task->regs.es	= (REAL_MEM >> 4);
+				task->regs.edi	= BUFFER;
+				strncpy(vbe_pib(REAL_MEM+BUFFER)->vbe_signature,"VBE2",4);
+
+				vesafb_do_vm86(&task->regs);
+
+				memcpy(task->res, (void*)(REAL_MEM + BUFFER), sizeof(struct vesafb_vbe_info_block));
+
+				/* the OEM fields were not defined prior to VBE 2.0 */
+				if (vbe_pib(task->res)->vbe_version >= 0x200) {
+					vesafb_get_string(oem_string_ptr);
+					vesafb_get_string(oem_vendor_name_ptr);
+					vesafb_get_string(oem_product_name_ptr);
+					vesafb_get_string(oem_product_rev_ptr);
+				}
+
+				/* this is basically the same as vesafb_get_string; the third part
+				   is different though, so that's what causes all this mess */
+				addr = ((vbe_pib(task->res)->mode_list_ptr & 0xffff0000) >> 12) +
+					(vbe_pib(task->res)->mode_list_ptr & 0x0000ffff);
+
+				if (addr >= 0xa0000) {
+					vbe_pib(task->res)->mode_list_ptr = (u32) __va(addr);
+				} else if (addr > REAL_MEM+BUFFER && addr < REAL_MEM+BUFFER +
+					   sizeof(struct vesafb_vbe_info_block))
+				{
+					addr -= BUFFER+REAL_MEM;
+					vbe_pib(task->res)->mode_list_ptr = (u32) (task->res + addr);
+				} else {
+					res = 0;
+					while (*(u16*)(addr+res) != 0xffff &&
+					       res < (sizeof(vbe_pib(task->res)->reserved) - 2) )
+					{
+						*(u16*) ((u32)&(vbe_pib(task->res)->reserved) + res) =
+							*(u16*)(addr+res);
+						res += 2;
+					}
+
+					*(u16*) ((u32)&(vbe_pib(task->res)->reserved) + res) = 0xffff;
+ 				}
+				break;
+
+			case VESAFB_TASK_GETVBE_MODEINFO:
+				task->regs.es	= (REAL_MEM >> 4);
+				task->regs.edi	= BUFFER;
+				vesafb_do_vm86(&task->regs);
+				memcpy(task->res, (void*)(REAL_MEM + BUFFER), sizeof(struct vesafb_mode_info_block));
+				break;
+
+			case VESAFB_TASK_SWITCHMODE:
+				if (task->res != NULL) {
+					task->regs.es	= (REAL_MEM >> 4);
+					task->regs.edi	= BUFFER;
+					memcpy((void*)(REAL_MEM + BUFFER), task->res, sizeof(struct vesafb_crtc_info_block));
+				}
+
+				vesafb_do_vm86(&task->regs);
+				break;
+
+			case VESAFB_TASK_SETPAL:
+				task->regs.es	= (REAL_MEM >> 4);
+				task->regs.edi	= BUFFER;
+				memcpy((void*)(REAL_MEM + BUFFER), task->res, sizeof(struct vesafb_pal_entry));
+				vesafb_do_vm86(&task->regs);
+				break;
+
+			case VESAFB_TASK_GETEDID:
+				task->regs.es	= (REAL_MEM >> 4);
+				task->regs.edi	= BUFFER;
+				vesafb_do_vm86(&task->regs);
+				memcpy(task->res, (void*)(REAL_MEM + BUFFER), EDID_LENGTH);
+
+			default:
+				break;
+		}
+
+		task->done = 1;
+		if (task->flags & VESAFB_FLAG_FREESTRUCT) {
+			kfree(task);
+		}
+	}
+
+	up(&vesafb_sem);
+	list_del_init(node);
+}
+
+int vesafb_thread(void *unused)
+{
+	struct vm_area_struct vma;
+	struct page *page;
+
+	int ret, err = 0;
+	void *mem;
+
+	set_fs(KERNEL_DS);
+	daemonize("vesafb");
+	DPRINTK("started vesafb thread\n");
+
+	current->mm = current->active_mm;
+	mem = kmalloc(REAL_MEM_SIZE,GFP_KERNEL);
+
+	if (!mem)
+		return -ENOMEM;
+
+	for (page = virt_to_page(mem); page < virt_to_page(mem+REAL_MEM_SIZE); page++) {
+		SetPageReserved(page);
+        }
+
+	vma.vm_mm = current->active_mm;
+	vma.vm_page_prot.pgprot = PROT_READ | PROT_EXEC | PROT_WRITE;
+
+	ret = remap_page_range(&vma, 0x000000, __pa(mem), REAL_MEM_SIZE, vma.vm_page_prot);
+	ret += remap_page_range(&vma, 0x0a0000, 0x0a0000, 0x100000 - 0x0a0000, vma.vm_page_prot);
+
+	if (ret) {
+		printk(KERN_ERR "vesafb thread: memory remapping failed\n");
+		err = -EINVAL;
+		goto thr_end;
+	}
+
+	/* copy the first 0x20000 bytes from low mem to our private memory, which is
+	 * then used for the vm86 calls */
+	memcpy((void*)0x0, __va(0x0), REAL_MEM_SIZE);
+
+	if (ioperm(0,1024,1)) {
+		printk(KERN_ERR "vesafb thread: ioperm failed\n");
+		err = -EINVAL;
+		goto thr_end;
+	}
+
+	set_user_nice(current, -10);
+
+	while (1) {
+
+		vesafb_handle_tasks();
+		wait_event_interruptible(vesafb_wait, !list_empty(&vesafb_task_list));
+		if (current->flags & PF_FREEZE)
+			refrigerator(PF_FREEZE);
+
+		if (signal_pending(current))
+			break;
+	}
+
+thr_end:
+	DPRINTK("exiting the vesafb thread\n");
+	vesafb_pid = 0;
+
+	for (page = virt_to_page(mem); page < virt_to_page(mem+REAL_MEM_SIZE); page++) {
+		ClearPageReserved(page);
+        }
+
+	kfree(mem);
+	return err;
+}
+
+int vesafb_init_thread(void)
+{
+	vesafb_pid = kernel_thread(vesafb_thread,NULL,0);
+	return 0;
+}
+
+EXPORT_SYMBOL(vesafb_pid);
+EXPORT_SYMBOL(vesafb_queue_task);
diff -Naur linux-2.6.7-orig/include/video/vesa.h linux-2.6.7-vesa/include/video/vesa.h
--- linux-2.6.7-orig/include/video/vesa.h	1970-01-01 01:00:00.000000000 +0100
+++ linux-2.6.7-vesa/include/video/vesa.h	2004-06-20 23:08:15.000000000 +0200
@@ -0,0 +1,131 @@
+#ifdef __i386__
+#define VESAFB_VM86
+#else
+#undef VESAFB_VM86
+#endif
+
+#define crtc_pib(arg) ((struct vesafb_crtc_info_block*)(arg))
+#define vbe_pib(arg) ((struct vesafb_vbe_info_block*)(arg))
+#define vesafb_pmib(arg) ((struct vesafb_mode_info_block*)(arg))
+
+struct vesafb_task {
+	enum {
+		VESAFB_TASK_DOVM86,
+		VESAFB_TASK_GETVBE_IB,
+		VESAFB_TASK_GETVBE_MODEINFO,
+		VESAFB_TASK_SWITCHMODE,
+		VESAFB_TASK_GETEDID,
+		VESAFB_TASK_SETPAL
+	} type;
+
+	unsigned short		flags;
+	struct vm86_regs 	regs;
+
+	unsigned char		done;
+	void 			*res;
+
+	struct list_head 	node;
+};
+
+#define VESAFB_FLAG_FREESTRUCT		0x0001
+
+/* this struct is 512 bytes long */
+struct vesafb_vbe_info_block {
+	char	vbe_signature[4];
+	u16	vbe_version;
+	u32	oem_string_ptr;
+	u32	capabilities;
+	u32 	mode_list_ptr;
+	u16 	total_memory;
+	u16	oem_software_rev;
+	u32	oem_vendor_name_ptr;
+	u32 	oem_product_name_ptr;
+	u32 	oem_product_rev_ptr;
+	u8	reserved[222];
+	char	oem_data[256];
+} __attribute__ ((packed));
+
+struct vesafb_crtc_info_block {
+
+	u16	horiz_total;
+	u16	horiz_start;
+	u16	horiz_end;
+	u16	vert_total;
+	u16	vert_start;
+	u16	vert_end;
+	u8	flags;
+	u32	pixel_clock;
+	u16	refresh_rate;
+	u8	reserved[40];
+
+} __attribute__ ((packed));
+
+/* this struct is 256 bytes long */
+struct vesafb_mode_info_block {
+
+	/* for all VBE revisions */
+	u16	mode_attr;
+	u8	winA_attr;
+	u8	winB_attr;
+	u16	win_granularity;
+	u16	win_size;
+	u16	winA_seg;
+	u16	winB_seg;
+	u32	win_func_ptr;
+	u16	bytes_per_scan_line;
+
+	/* for VBE 1.2+ */
+	u16	x_res;
+	u16	y_res;
+	u8	x_char_size;
+	u8	y_char_size;
+	u8	planes;
+	u8	bits_per_pixel;
+	u8	banks;
+	u8	memory_model;
+	u8	bank_size;
+	u8	image_pages;
+	u8	reserved1;
+
+	/* direct color fields for direct/6 and YUV/7 memory models */
+	u8	red_len;
+	u8	red_off;		/* offsets are bit positions of lsb in the mask */
+	u8	green_len;
+	u8	green_off;
+	u8	blue_len;
+	u8	blue_off;
+	u8	rsvd_len;
+	u8	rsvd_off;
+	u8	direct_color_info;	/* direct color mode attributes */
+
+	/* for VBE 2.0+ */
+	u32	phys_base_ptr;
+	u8	reserved2[6];
+
+	/* for VBE 3.0+ */
+	u16	lin_bytes_per_scan_line;
+	u8	bnk_image_pages;
+	u8	lin_image_pages;
+	u8	lin_red_len;
+	u8	lin_red_off;
+	u8	lin_green_len;
+	u8	lin_green_off;
+	u8	lin_blue_len;
+	u8	lin_blue_off;
+	u8	lin_rsvd_len;
+	u8	lin_rsvd_off;
+	u32	max_pixel_clock;
+
+	u16	mode_id;
+
+} __attribute__ ((packed));
+
+struct vesafb_par {
+	u16 				vbe_mode;
+	struct vesafb_crtc_info_block 	crtc;
+};
+
+
+struct vesafb_pal_entry {
+	u_char blue, green, red, pad;
+} __attribute__ ((packed));
