---

 linux-2.6.7-xx2-xiphux/Documentation/kernel-parameters.txt      |    9 
 linux-2.6.7-xx2-xiphux/Documentation/power/swsusp2.txt          |  495 +++++++
 linux-2.6.7-xx2-xiphux/arch/arm/kernel/ecard.c                  |    6 
 linux-2.6.7-xx2-xiphux/arch/i386/kernel/apm.c                   |    6 
 linux-2.6.7-xx2-xiphux/arch/i386/kernel/cpu/mcheck/non-fatal.c  |    6 
 linux-2.6.7-xx2-xiphux/arch/i386/kernel/io_apic.c               |    7 
 linux-2.6.7-xx2-xiphux/arch/i386/kernel/process.c               |   25 
 linux-2.6.7-xx2-xiphux/arch/i386/kernel/signal.c                |    6 
 linux-2.6.7-xx2-xiphux/arch/i386/kernel/smp.c                   |    2 
 linux-2.6.7-xx2-xiphux/arch/i386/mm/init.c                      |   53 
 linux-2.6.7-xx2-xiphux/arch/i386/mm/pageattr.c                  |    2 
 linux-2.6.7-xx2-xiphux/arch/i386/power/Makefile                 |    3 
 linux-2.6.7-xx2-xiphux/arch/i386/power/cpu.c                    |   10 
 linux-2.6.7-xx2-xiphux/arch/i386/power/suspend2.c               |  656 ++++++++++
 linux-2.6.7-xx2-xiphux/arch/ppc/Kconfig                         |    2 
 linux-2.6.7-xx2-xiphux/arch/ppc/Makefile                        |    1 
 linux-2.6.7-xx2-xiphux/arch/ppc/kernel/signal.c                 |   11 
 linux-2.6.7-xx2-xiphux/arch/ppc/kernel/vmlinux.lds.S            |    6 
 linux-2.6.7-xx2-xiphux/arch/ppc/mm/init.c                       |   27 
 linux-2.6.7-xx2-xiphux/arch/ppc/platforms/pmac_feature.c        |    5 
 linux-2.6.7-xx2-xiphux/arch/ppc/power/Makefile                  |    2 
 linux-2.6.7-xx2-xiphux/arch/ppc/power/cpu.c                     |   61 
 linux-2.6.7-xx2-xiphux/arch/ppc/power/cpu_reg.S                 |  325 ++++
 linux-2.6.7-xx2-xiphux/arch/ppc/power/swsusp2-asm.S             |   53 
 linux-2.6.7-xx2-xiphux/arch/ppc/power/swsusp2-copyback.S        |   73 +
 linux-2.6.7-xx2-xiphux/arch/ppc/power/swsusp2.c                 |  170 ++
 linux-2.6.7-xx2-xiphux/drivers/acpi/osl.c                       |    2 
 linux-2.6.7-xx2-xiphux/drivers/acpi/sleep/proc.c                |   13 
 linux-2.6.7-xx2-xiphux/drivers/base/power/resume.c              |   53 
 linux-2.6.7-xx2-xiphux/drivers/block/ll_rw_blk.c                |    2 
 linux-2.6.7-xx2-xiphux/drivers/block/loop.c                     |    1 
 linux-2.6.7-xx2-xiphux/drivers/char/hvc_console.c               |    6 
 linux-2.6.7-xx2-xiphux/drivers/char/keyboard.c                  |  142 ++
 linux-2.6.7-xx2-xiphux/drivers/char/n_tty.c                     |    4 
 linux-2.6.7-xx2-xiphux/drivers/char/tty_io.c                    |   14 
 linux-2.6.7-xx2-xiphux/drivers/char/vt.c                        |   16 
 linux-2.6.7-xx2-xiphux/drivers/ide/ide.c                        |    6 
 linux-2.6.7-xx2-xiphux/drivers/ieee1394/nodemgr.c               |   12 
 linux-2.6.7-xx2-xiphux/drivers/input/serio/serio.c              |   10 
 linux-2.6.7-xx2-xiphux/drivers/macintosh/Kconfig                |    4 
 linux-2.6.7-xx2-xiphux/drivers/macintosh/via-pmu.c              |    7 
 linux-2.6.7-xx2-xiphux/drivers/md/dm-crypt.c                    |    2 
 linux-2.6.7-xx2-xiphux/drivers/md/md.c                          |    1 
 linux-2.6.7-xx2-xiphux/drivers/media/video/msp3400.c            |   13 
 linux-2.6.7-xx2-xiphux/drivers/media/video/tvaudio.c            |    8 
 linux-2.6.7-xx2-xiphux/drivers/message/i2o/i2o_block.c          |   11 
 linux-2.6.7-xx2-xiphux/drivers/message/i2o/i2o_core.c           |   23 
 linux-2.6.7-xx2-xiphux/drivers/mtd/mtdblock.c                   |    4 
 linux-2.6.7-xx2-xiphux/drivers/net/irda/sir_kthread.c           |    6 
 linux-2.6.7-xx2-xiphux/drivers/net/wan/sdlamain.c               |    2 
 linux-2.6.7-xx2-xiphux/drivers/parport/ieee1284.c               |    4 
 linux-2.6.7-xx2-xiphux/drivers/pcmcia/cs.c                      |   11 
 linux-2.6.7-xx2-xiphux/drivers/pnp/pnpbios/core.c               |   14 
 linux-2.6.7-xx2-xiphux/drivers/s390/cio/device.c                |    5 
 linux-2.6.7-xx2-xiphux/drivers/scsi/scsi_error.c                |    1 
 linux-2.6.7-xx2-xiphux/drivers/serial/8250.c                    |  104 +
 linux-2.6.7-xx2-xiphux/drivers/usb/core/hub.c                   |   10 
 linux-2.6.7-xx2-xiphux/drivers/usb/storage/usb.c                |   15 
 linux-2.6.7-xx2-xiphux/drivers/video/console/fbcon.c            |    4 
 linux-2.6.7-xx2-xiphux/fs/aio.c                                 |    2 
 linux-2.6.7-xx2-xiphux/fs/buffer.c                              |   51 
 linux-2.6.7-xx2-xiphux/fs/dcache.c                              |    5 
 linux-2.6.7-xx2-xiphux/fs/devfs/base.c                          |   13 
 linux-2.6.7-xx2-xiphux/fs/exec.c                                |   18 
 linux-2.6.7-xx2-xiphux/fs/fcntl.c                               |   19 
 linux-2.6.7-xx2-xiphux/fs/jbd/journal.c                         |   20 
 linux-2.6.7-xx2-xiphux/fs/jffs/intrep.c                         |   15 
 linux-2.6.7-xx2-xiphux/fs/jffs2/background.c                    |   18 
 linux-2.6.7-xx2-xiphux/fs/jfs/jfs_logmgr.c                      |   12 
 linux-2.6.7-xx2-xiphux/fs/jfs/jfs_txnmgr.c                      |   26 
 linux-2.6.7-xx2-xiphux/fs/lockd/clntlock.c                      |    8 
 linux-2.6.7-xx2-xiphux/fs/lockd/clntproc.c                      |    4 
 linux-2.6.7-xx2-xiphux/fs/lockd/svc.c                           |   12 
 linux-2.6.7-xx2-xiphux/fs/locks.c                               |    8 
 linux-2.6.7-xx2-xiphux/fs/namei.c                               |   54 
 linux-2.6.7-xx2-xiphux/fs/namespace.c                           |   16 
 linux-2.6.7-xx2-xiphux/fs/nfsd/nfssvc.c                         |    8 
 linux-2.6.7-xx2-xiphux/fs/open.c                                |   89 +
 linux-2.6.7-xx2-xiphux/fs/pipe.c                                |    4 
 linux-2.6.7-xx2-xiphux/fs/proc/generic.c                        |    8 
 linux-2.6.7-xx2-xiphux/fs/proc/kmsg.c                           |   10 
 linux-2.6.7-xx2-xiphux/fs/read_write.c                          |   73 -
 linux-2.6.7-xx2-xiphux/fs/reiserfs/journal.c                    |    2 
 linux-2.6.7-xx2-xiphux/fs/select.c                              |    9 
 linux-2.6.7-xx2-xiphux/fs/stat.c                                |   41 
 linux-2.6.7-xx2-xiphux/fs/super.c                               |    5 
 linux-2.6.7-xx2-xiphux/fs/sysfs/file.c                          |    4 
 linux-2.6.7-xx2-xiphux/fs/xfs/linux-2.6/xfs_buf.c               |   16 
 linux-2.6.7-xx2-xiphux/fs/xfs/linux-2.6/xfs_super.c             |   11 
 linux-2.6.7-xx2-xiphux/include/asm-i386/cpufeature.h            |    1 
 linux-2.6.7-xx2-xiphux/include/asm-i386/mtrr.h                  |    4 
 linux-2.6.7-xx2-xiphux/include/asm-i386/suspend.h               |    4 
 linux-2.6.7-xx2-xiphux/include/asm-i386/tlbflush.h              |    5 
 linux-2.6.7-xx2-xiphux/include/asm-ppc/suspend.h                |   14 
 linux-2.6.7-xx2-xiphux/include/linux/kthread.h                  |   10 
 linux-2.6.7-xx2-xiphux/include/linux/sched.h                    |    6 
 linux-2.6.7-xx2-xiphux/include/linux/suspend-version-specific.h |  122 +
 linux-2.6.7-xx2-xiphux/include/linux/suspend1.h                 |   90 +
 linux-2.6.7-xx2-xiphux/include/linux/workqueue.h                |    7 
 linux-2.6.7-xx2-xiphux/init/do_mounts.c                         |   16 
 linux-2.6.7-xx2-xiphux/kernel/exit.c                            |    8 
 linux-2.6.7-xx2-xiphux/kernel/fork.c                            |    7 
 linux-2.6.7-xx2-xiphux/kernel/kmod.c                            |    2 
 linux-2.6.7-xx2-xiphux/kernel/kthread.c                         |    6 
 linux-2.6.7-xx2-xiphux/kernel/module.c                          |   27 
 linux-2.6.7-xx2-xiphux/kernel/panic.c                           |    5 
 linux-2.6.7-xx2-xiphux/kernel/power/Kconfig                     |  143 ++
 linux-2.6.7-xx2-xiphux/kernel/power/Makefile                    |   13 
 linux-2.6.7-xx2-xiphux/kernel/power/disk.c                      |    3 
 linux-2.6.7-xx2-xiphux/kernel/power/main.c                      |    3 
 linux-2.6.7-xx2-xiphux/kernel/power/pmdisk.c                    |    2 
 linux-2.6.7-xx2-xiphux/kernel/power/swsusp.c                    |    2 
 linux-2.6.7-xx2-xiphux/kernel/sched.c                           |   16 
 linux-2.6.7-xx2-xiphux/kernel/softirq.c                         |   16 
 linux-2.6.7-xx2-xiphux/kernel/stop_machine.c                    |    2 
 linux-2.6.7-xx2-xiphux/kernel/sys.c                             |    8 
 linux-2.6.7-xx2-xiphux/kernel/workqueue.c                       |   31 
 linux-2.6.7-xx2-xiphux/mm/bootmem.c                             |    6 
 linux-2.6.7-xx2-xiphux/mm/filemap.c                             |    5 
 linux-2.6.7-xx2-xiphux/mm/highmem.c                             |    9 
 linux-2.6.7-xx2-xiphux/mm/oom_kill.c                            |    5 
 linux-2.6.7-xx2-xiphux/mm/page-writeback.c                      |   11 
 linux-2.6.7-xx2-xiphux/mm/page_alloc.c                          |   64 
 linux-2.6.7-xx2-xiphux/mm/pdflush.c                             |   16 
 linux-2.6.7-xx2-xiphux/mm/swapfile.c                            |    5 
 linux-2.6.7-xx2-xiphux/mm/vmscan.c                              |    2 
 linux-2.6.7-xx2-xiphux/net/bluetooth/bnep/core.c                |    2 
 linux-2.6.7-xx2-xiphux/net/bluetooth/rfcomm/core.c              |    8 
 linux-2.6.7-xx2-xiphux/net/socket.c                             |   21 
 linux-2.6.7-xx2-xiphux/net/sunrpc/sched.c                       |   22 
 linux-2.6.7-xx2-xiphux/net/sunrpc/svcsock.c                     |    8 
 linux-2.6.7-xx2/include/linux/suspend.h                         |   90 -
 linux-2.6.7-xx2/kernel/power/console.c                          |   55 
 linux-2.6.7-xx2/kernel/power/process.c                          |  119 -
 134 files changed, 3704 insertions(+), 450 deletions(-)

diff -puN Documentation/kernel-parameters.txt~20-software-suspend-linux-2.6.7-rev1-whole Documentation/kernel-parameters.txt
--- linux-2.6.7-xx2/Documentation/kernel-parameters.txt~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.799939632 -0400
+++ linux-2.6.7-xx2-xiphux/Documentation/kernel-parameters.txt	2004-06-24 07:14:54.425844480 -0400
@@ -750,6 +750,8 @@ running once the system is up.
 
 	noresume	[SWSUSP] Disables resume and restore original swap space.
  
+	noresume2	[SWSUSP2] Disables resuming and restores original swap signature.
+
 	no-scroll	[VGA] Disables scrollback.
 			This is required for the Braillex ib80-piezo Braille
 			reader made by F.H. Papenmeier (Germany).
@@ -947,7 +949,12 @@ running once the system is up.
 
 	reserve=	[KNL,BUGS] Force the kernel to ignore some iomem area
 
-	resume=		[SWSUSP] Specify the partition device for software suspension
+	resume=		[SWSUSP] Specify the partition device for software suspension.
+
+	resume2=	[SWSUSP2] Specify the storage device for software suspend.
+			Format: <writer>:<writer-parameters>.
+			See Documentation/power/swsusp2.txt for details of the formats
+			for available image writers.
 
 	rhash_entries=	[KNL,NET]
 			Set number of hash buckets for route cache
diff -puN /dev/null Documentation/power/swsusp2.txt
--- /dev/null	2004-05-31 17:36:38.000000000 -0400
+++ linux-2.6.7-xx2-xiphux/Documentation/power/swsusp2.txt	2004-06-24 07:14:54.428844024 -0400
@@ -0,0 +1,495 @@
+   --- Software Suspend ('swsusp') for Linux, version 2.0 ---
+
+1.  What is it?
+2.  Why would you want it?
+3.  What do you need to use it?
+4.  How do you use it?
+5.  What do all those entries in /proc/swsusp do?
+6.  How do you get support?
+7.  I think I've found a bug. What should I do?
+8.  When will XXX be supported?
+9.  How does it work?
+10. Who wrote Software Suspend?
+
+1. What is it?
+
+   Imagine you're sitting at your computer, working away. For some reason, you
+   need to turn off your computer for a while - perhaps it's time to go home
+   for the day. When you come back to your computer next, you're going to want
+   to carry on where you left off. Now imagine that you could push a button and
+   have your computer store the contents of its memory to disk and power down.
+   Then, when you next start up your computer, it loads that image back into
+   memory and you can carry on from where you were, just as if you'd never
+   turned the computer off. Far less time to start up, no reopening
+   applications and finding what directory you put that file in yesterday.
+   That's what Software Suspend does.
+
+2. Why would you want it?
+
+   Why wouldn't you want it?
+
+   Being able to save the state of your system and quickly restore it improves
+   your productivity - you get a useful system in far less time than through
+   the normal boot process.
+
+3. What do you need to use it?
+
+   a. Kernel Support.
+
+   Software Suspend is part of the Linux Kernel. This version is not part of Linus's
+   2.6 tree at the moment, so you will need to download the kernel source and
+   apply the latest patch. Having done that, enable the appropriate options in
+   make [menu|x]config (under General Setup), compile and install your kernel.
+   Software Suspend is incompatible with SMP, and non x86 hardware but
+   works with preempt support and HighMem. It requires your swap
+   partitions/files to be on IDE devices.
+
+   Software Suspend patches are available from http://swsusp.sf.net.
+
+   You may also want to apply the optional patches. At the time of writing,
+   option patches are available to support Bootsplash (www.bootsplash.org, for
+   an even nicer display during suspend), Laptop mode and Win4Lin. The laptop
+   mode patch is a variation on Jens Axboe's patch, which disables laptop mode
+   when suspending. The Win4Lin option patch provides support for Win4Lin.
+
+   Option patches should be applied after the main patch and after Win4Lin
+   or Bootsplash.
+
+   b. Swapspace.
+
+   Software Suspend can store the suspend image in your swap partition,
+   a swap file or a combination thereof. Whichever combination you choose, you
+   will probably want to create enough swap space to store the largest image
+   you could have, plus the space you'd normally use for swap. A good rule of
+   thumb would be to calculate the amount of swap you'd want without using
+   Software Suspend, and then add the amount of memory you have. This swap
+   space can be arranged in any way you'd like. It can be in one partition or
+   file, or spread over a number. The only requirement is that they be active
+   when you start a suspend cycle.
+
+   There is one exception to this requirement. Software Suspend has
+   the ability to turn on one swap file or partition at the start of
+   suspending and turn it back off at the end. If you want to ensure you have
+   enough memory to store a image when your memory is fully used, you might
+   want to make one swap partition/file for 'normal' use, and another for
+   Software Suspend to activate & deactivate automatically. (Further details
+   below).
+
+   c. Bootloader configuration.
+
+   Using Software Suspend also requires that you add an extra parameter to
+   your lilo.conf or equivalent. Here's an example for a swap partition:
+
+   append="resume=/dev/hda1"
+
+   This would tell Software Suspend that /dev/hda1 is a swap partition you
+   have. Software Suspend will use the swap signature of this partition as a
+   pointer to your data when you suspend. This means that (in this example)
+   /dev/hda1 doesn't need to be _the_ swap partition where all of your data
+   is actually stored. It just needs to be a swap partition that will be
+   turned on at suspend time.
+
+   You don't need to have a swap partition for this purpose. Software Suspend
+   can also use a swap file, but usage is a little more complex. Having made
+   your swap file, turn it on and do "cat /proc/swsusp/header_locations"
+   (this assumes you've already compiled your kernel with Software Suspend
+   support and booted it). The results of the cat command will tell you
+   what you need to put in lilo.conf:
+
+   For swap partitions like /dev/hda1, simply use resume=/dev/hda1.
+   For swapfile `swapfile`, use resume=/dev/hda2 resume_block=0x242d.
+
+   If the swapfile changes for any reason (it is moved to a different
+   location, it is deleted and recreated, or the filesystem is
+   defragmented) then you will have to check
+   /proc/swsusp/header_locations for a new resume_block value.
+
+   Once you've compiled and installed the kernel, adjusted your lilo.conf
+   and rerun lilo, you should only need to reboot for the most basic part
+   of Software Suspend to be ready.
+
+   d. A suspend script.
+
+   Since the driver model in 2.6 kernels is still being developed, you may need
+   to do more, however. Users of Software Suspend usually start the process
+   via a script which prepares for the suspend, tells the kernel to do its
+   stuff and then restore things afterwards. This script might involve:
+
+   - Switching to a text console and back if X doesn't like the video card
+     status on resume.
+   - Running /sbin/hwclock [--directisa] to update the clock on resume
+   - Un/reloading PCMCIA support since it doesn't play well with swsusp.
+
+   Note that you might not be able to unload some drivers if there are
+   processes using them. You might have to kill off processes that hold
+   devices open. Hint: if your X server accesses an USB mouse, doing a
+   'chvt' to a text console releases the device and you can unload the
+   module.
+
+   Check out the latest script (available on Sourceforge).
+
+4. How do you use it?
+
+   Once your script is properly set up, you should just be able to start it
+   and everything should go like clockwork. Of course things aren't always
+   that easy out of the box.
+
+   Check out (in the kernel source tree) include/linux/suspend-debug for
+   settings you can use to get detailed information about what swsusp is doing.
+   /proc/sys/kernel/swsusp and the kernel parameters swsusp_act, swsusp_dbg
+   and swsusp_lvl allow you to set the action and debugging parameters prior
+   to starting a suspend and/or at the lilo prompt before resuming. There is
+   also a nice little program that should be available from Sourceforge which
+   makes it easier to turn these debugging settings on and off. Note that to
+   get any debugging output, you need to enable it when compiling the kernel.
+   If cat /proc/sys/kernel/swsusp only shows 4 numbers, you didn't do that.
+
+   A neat feature of Software Suspend is that you can press Escape at any time
+   during suspending, and the process will be aborted.
+
+   Due to the way swsusp works, this means you'll have your system back and
+   perfectly usable almost instantly. The only exception is when it's at
+   the very end of writing the image. Then it will need to reload a small
+   (usually 4-50MBs) portion first.
+
+   If you run into problems with resuming, adding the "noresume" option to
+   the kernel command line will let you skip the resume step and
+   (hopefully) recover your system.
+
+5. What do all those entries in /proc/swsusp do?
+
+   /proc/swsusp is the directory which contains files you can use to tune
+   and configure Software Suspend to your liking. The exact contents of
+   the directory will depend upon the version of Software Suspend you're
+   running, and the options you selected at compile time. In the following
+   descriptions, names in brackets refer to compile time options that
+   control whether the file exists. (Note that they're all dependant upon
+   you having selected CONFIG_SOFTWARE_SUSPEND2 in the first place!)
+
+   Since the values of these settings can open potential security risks, they
+   are usually accessible only to the root user. You can, however, enable a
+   compile time option which makes all of these files world-accessible. This
+   should only be done if you trust everyone with shell access to this
+   computer!
+
+   - activate:
+
+   When anything is written to this file swsusp will be activated and suspend
+   the system. The value is completely ignored. It is just the fact that you
+   write to the file that initiates the suspend.
+
+   - async_io_limit:
+
+   This value is the limit on the number of pages Software Suspend will submit
+   for reading or writing at once. The ideal value depends upon the speed of
+   your hard disks, but the default of 32 should be fine.
+
+   - beeping:
+
+   Set this value to 1 to hear beeps at the different stages of suspending and
+   resuming.
+
+   - debug_info:
+
+   This file returns information about your configuration that may be helpful
+   in diagnosing problems with suspending.
+
+   - debug_sections (CONFIG_SOFTWARE_SUSPEND_DEBUG):
+
+   This value, together with the console log level, controls what debugging
+   information is displayed. The console log level determines the level of
+   detail, and this value determines what detail is displayed. This value is
+   a bit vector, and the meaning of the bits can be found in the kernel tree
+   in include/linux/suspend-debug.h. It can be over-ridden using the kernel's
+   command line option swsusp_dbg.
+
+   - default_console_level (CONFIG_SOFTWARE_SUSPEND_DEBUG):
+
+   This determines the value of the console log level at the start of a
+   suspend cycle. If debugging is compiled in, the console log level can be
+   changed during a cycle by pressing the digit keys. Meanings are:
+
+   0: Nice display.
+   1: Nice display plus numerical progress.
+   2: Errors only.
+   3: Low level debugging info.
+   4: Medium level debugging info.
+   5: High level debugging info.
+   6: Verbose debugging info.
+
+   This value can be over-ridden using the kernel command line option
+   swsusp_lvl.
+
+   - disable_gzip_compression (CONFIG_SOFTWARE_SUSPEND_GZIP_COMPRESSION):
+
+   If gzip compression support is compiled in, this option can be used to
+   disable this plugin.
+
+   - disable_lzf_compression (CONFIG_SOFTWARE_SUSPEND_LZF_COMPRESSION):
+
+   If lzf compression support is compiled in, this option can be used to
+   disable this plugin.
+
+   - enable_escape:
+
+   Setting this to "1" will enable you abort a suspend by
+   pressing escape, "0" (default) disables this feature. Note that enabling
+   this option means that you cannot initiate a suspend and then walk away
+   from your computer, expecting it to be secure. With feature disabled,
+   you can validly have this expectation once Suspend begins to write the
+   image to disk. (Prior to this point, it is possible that Suspend might
+   about because of failure to freeze all processes or because constraints
+   on its ability to save the image are not met).
+
+   - expected_gzip_compression (CONFIG_SOFTWARE_SUSPEND_GZIP_COMPRESSION):
+   - expected_lzf_compression (CONFIG_SOFTWARE_SUSPEND_LZF_COMPRESSION):
+
+   These values allow you to set an expected compression ratio, which Software
+   Suspend will use in calculating whether it meets constraints on the image
+   size. If this expected compression ratio is not attained, the suspend will
+   abort, so it is wise to allow some spare. You can see what compression
+   ratio is achieved in the logs after suspending.
+
+   Note that the values are cumulative. If you compile in both gzip and lzf
+   compression, have both enabled, and set both expected compression ratios
+   to 20, Suspend will expect that the storage required  will be at most
+   .8 * .8 = 64% of the number of pages to be written.
+
+   - header_locations:
+
+   This option tells you the resume= options to use for swap devices you
+   currently have activated. It is particularly useful when you only want to
+   use a swap file to store your image. See above for further details.
+
+   - image_size_limit:
+
+   The maximum size of suspend image written to disk, measured in megabytes
+   (1024*1024).
+
+   - interface_version:
+
+   The value returned by this file can be used by scripts and configuration
+   tools to determine what entries should be looked for. The value is
+   incremented whenever an entry in /proc/swsusp is obsoleted or added.
+
+   - last_result:
+
+   The result of the last suspend, as defined in
+   include/linux/suspend-debug.h with the values SUSPEND_ABORTED to
+   SUSPEND_KEPT_IMAGE. This is a bitmask.
+
+   - log_everything (CONFIG_SOFTWARE_SUSPEND_DEBUG):
+
+   Setting this option results in all messages printed being logged. Normally,
+   only a subset are logged, so as to not slow the process and not clutter the
+   logs. Useful for debugging. It can be toggled during a cycle by pressing
+   'L'.
+
+   - no_output:
+
+   Setting this to "1" disables all output from suspend. It may be useful if a
+   distribution wants to implement a static display while suspending.
+
+   - pause_between_steps (CONFIG_SOFTWARE_SUSPEND_DEBUG):
+
+   This option is used during debugging, to make Software Suspend pause between
+   each step of the process. It is ignored when the nice display is on.
+
+   - progressbar_granularity_limit (CONFIG_FBCON_SPLASHSCREEN):
+
+   This option can be used to limit the granularity of the progress bar
+   displayed with a bootsplash screen. The value is the maximum number of
+   steps. That is, 10 will make the progress bar jump in 10% increments.
+
+   - reboot (CONFIG_SOFTWARE_SUSPEND_DEBUG):
+
+   This option causes Software Suspend to reboot rather than powering down
+   at the end of saving an image. It can be toggled during a cycle by pressing
+   'R'.
+
+   - slow:
+
+   This option inserts a couple of one+ second delays in the code. It should
+   not be needed, and may disappear in a future version.
+
+   - swapfile:
+
+   This entry is used to specify the swapfile or partition that
+   Software Suspend will attempt to swapon/swapoff automatically. Thus, if
+   I normally use /dev/hda1 for swap, and want to use /dev/hda2 for specifically
+   for my suspend image, I would
+
+   echo /dev/hda2 > /proc/swsusp/swapfile
+
+   /dev/hda2 would then be automatically swapon'd and swapoff'd. Note that the
+   swapon and swapoff occur while other processes are frozen (including kswapd)
+   so this swap file will not be used up when attempting to free memory. The
+   parition/file is also given the highest priority, so other swapfiles/partitions
+   will only be used to save the image when this one is filled.
+
+   The value of this file is used by header_locations along with any currently
+   activated swapfiles/partitions.
+
+   - version:
+
+   The version of swsusp you have compiled into the currently running kernel.
+
+6. How do you get support?
+
+   Glad you asked. Software Suspend is being actively maintained and supported,
+   both by Nigel (the guy doing most of the coding at the moment) and its
+   users. You can find the mailing list via the Sourceforge project page.
+
+7. I think I've found a bug. What should I do?
+
+   If you're seeing Software Suspend hang at some point, and especially if
+   lights are flashing on your keyboard, you should compile in debugging
+   support and try...
+
+   echo 1 > /proc/swsusp/debug_sections
+   echo 3 > /proc/swsusp/default_console_level
+   echo > /proc/swsusp/activate
+
+   You should then see low level debugging information and eventually an
+   oops.
+
+   Good information on how to provide us with useful information from an
+   oops is found in the file REPORTING-BUGS, in the top level directory
+   of the kernel tree. If you get an oops, please especially note the
+   information about running what is printed on the screen through ksymoops.
+   The raw information is useless.
+
+   You might also read the FAQ and HOWTO on the web site for known issues,
+   and subscribe to the mailing list.
+
+   Beginning with 1.1rc10, you should include the contents of
+   /proc/swsusp/debug_info in your report. Prior to this version, similar
+   information is written to /var/log/messages at the end of a successful
+   resume and should be sent. It is also a good idea to check /var/log/messages
+   for relevant information as well. Information from the unloading and
+   reloading of drivers and modules  prior to and after suspending is sometimes
+   helpful.
+
+8. When will XXX be supported?
+
+   Software Suspend currently lacks support for SMP, non x86 and SCSI.
+
+   Patches for the other items (and anything that's been missed) are welcome.
+   Please send to the list.
+
+   Because Nigel's main task is definitely not Software Suspend and he doesn't
+   have the hardware, he will be unlikely to develop support for any of these
+   in the near future. His development work to date has been driven by the
+   desire to be a user of a more feature complete Software Suspend.
+
+9. How does it work?
+
+   Software Suspend does its work in a number of steps.
+
+   a. Freezing system activity.
+
+   The first main stage in suspending is to stop all other activity. This is
+   achieved in stages. First, we stop tasks from submitting new I/O using hooks
+   in the system calls for reading, writing and at a number of other places as
+   well as at the kernel threads that start I/O. If any tasks are syncing,
+   we wait for them to complete. We then do our own sync, just in case no
+   syncs were running. Next, we stop all the others tasks. Some are signalled
+   and put in a 'refrigerator'. Others are simply not scheduled again until we
+   decide to wake them up.
+
+   b. Eating memory.
+
+   For a successful suspend, you need to have enough disk space to store the
+   image and enough memory for the various limitations of Software Suspend's
+   algorithm. You can also specify a maximum image size. In order to attain
+   to those constraints, Software Suspend may 'eat' memory. If, after freezing
+   processes, the constraints aren't met, Software Suspend will thaw all the
+   other processes and begin to eat memory until its calculations indicate
+   the constraints are met. It will then freeze processes again and recheck
+   its calculations.
+
+   c. Suspending drivers and storing processor context.
+
+   Software Suspend then calls the power management functions to notify
+   drivers of the suspend, and saves the processor state.
+
+   d. Storage of meta data and image.
+
+   Next, Software Suspend allocates the swap pages that will be used to save
+   the image and stores their locations, along with the locations of the pages
+   to be saved in what we call pagesets or pagedirs. Software Suspend stores
+   data in two pagesets. Pageset 2 contains pages on the active and inactive
+   lists; essentially the page cache. Pageset 1 contains all other pages,
+   including the kernel. We use two pagesets for one important reason: We
+   need to make an atomic copy of the kernel to ensure consistency of the
+   image. Without a second pagedir, that would limit us to an image that was
+   at most half the amount of memory available. Using two pagesets allows us
+   to store a full image. Since pageset 2 pages won't be needed in saving
+   pageset 1, we first save pageset 2 pages. We can then make our atomic copy
+   of the remaining pages using both pageset 2 pages and any other pages that
+   are free. While saving both pagesets, we are careful not to corrupt the
+   image. We immediately shoot down pages that are added to the page cache,
+   and we allocate a special memory pool of extra pages that can be used by
+   during suspending. All of the pages in this pool are saved along with the
+   rest of the pageset 1 pages, even if they're not used. This saves us having
+   to worry about the image becoming inconsistent while we're saving it.
+
+   e. Save a second copy of the pagedirs.
+
+   To reload pagedir 1 at resume time, we need to know where the data is
+   stored. This requires the saving of a second copy of the pagedirs.
+
+   f. Save the suspend header.
+
+   Nearly there! We save our settings and other parameters needed for
+   reloading pagedir 1 in a 'suspend header' this is a single swap page.
+
+   g. Set the swap header.
+
+   Finally, we edit the swap header for our resume= swap file/partition. The
+   swap signature is changed to record what kind of header it originally was
+   (swapspace 1 or 2) and the bdev and first block and block size details of
+   the suspend header.
+
+   h. Power down.
+
+   Or reboot if we're debugging and the appropriate option is selected.
+
+   Whew!
+
+   Reloading the image.
+   --------------------
+
+   Reloading the image is essentially the reverse of all the above. We load
+   our copy of pagedir 1, being careful to choose locations that aren't going
+   to be overwritten as we copy it back (We start very early in the boot
+   process, so there are no other processes to quiesce here). We then copy
+   pagedir 1 back to its original location in memory and restore the process
+   context. We are now running with the original kernel. Next, we reload the
+   pageset 2 pages, free the memory and swap used by Software Suspend, restore
+   the pagedir header and restart processes. Sounds easy in comparison to
+   suspending, doesn't it!
+
+   There is of course more to Software Suspend than this, but this explanation
+   should be a good start. If there's interest, I'll write further
+   documentation on range pages and the low level I/O.
+
+10. Who wrote Software Suspend?
+
+   (Answer based on the writings of Florent Chabaud, credits in files and
+   Nigel's limited knowledge; apologies to anyone missed out!)
+
+   The main developers of Software Suspend have been...
+
+   Gabor Kuti
+   Pavel Machek
+   Florent Chabaud
+   Nigel Cunningham
+
+   They have been aided in their efforts by a host of hundreds, if not thousands
+   of testers and people who have submitted bug fixes & suggestions. Of special
+   note are the efforts of Michael Frank, who had his computers repetitively
+   suspend and resume for literally tens of thousands of cycles and developed
+   scripts to stress the system and test Software Suspend far beyond the point
+   most of us (Nigel included!) would consider testing. His efforts have
+   contributed as much to Software Suspend as any of the names above.
diff -puN arch/arm/kernel/ecard.c~20-software-suspend-linux-2.6.7-rev1-whole arch/arm/kernel/ecard.c
--- linux-2.6.7-xx2/arch/arm/kernel/ecard.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.803939024 -0400
+++ linux-2.6.7-xx2-xiphux/arch/arm/kernel/ecard.c	2004-06-24 07:14:54.430843720 -0400
@@ -283,9 +283,13 @@ static int
 ecard_task(void * unused)
 {
 	struct task_struct *tsk = current;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	daemonize("kecardd");
 
+	SWSUSP_THREAD_FLAGS_RESET;
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
+
 	/*
 	 * Allocate a mm.  We're not a lazy-TLB kernel task since we need
 	 * to set page table entries where the user space would be.  Note
@@ -303,7 +307,9 @@ ecard_task(void * unused)
 
 			if (req == NULL) {
 				sigemptyset(&tsk->pending.signal);
+				SWSUSP_ACTIVITY_PAUSING;
 				interruptible_sleep_on(&ecard_wait);
+				SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 			}
 		} while (req == NULL);
 
diff -puN arch/i386/kernel/apm.c~20-software-suspend-linux-2.6.7-rev1-whole arch/i386/kernel/apm.c
--- linux-2.6.7-xx2/arch/i386/kernel/apm.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.806938568 -0400
+++ linux-2.6.7-xx2-xiphux/arch/i386/kernel/apm.c	2004-06-24 07:15:25.449128224 -0400
@@ -223,6 +223,7 @@
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
 #include <linux/dmi.h>
+#include <linux/suspend.h>
 
 #include <asm/system.h>
 #include <asm/uaccess.h>
@@ -1410,9 +1411,12 @@ static void apm_event_handler(void)
 static void apm_mainloop(void)
 {
 	DECLARE_WAITQUEUE(wait, current);
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	add_wait_queue(&apm_waitqueue, &wait);
 	set_current_state(TASK_INTERRUPTIBLE);
+	SWSUSP_THREAD_FLAGS_RESET;
+
 	for (;;) {
 		schedule_timeout(APM_CHECK_TIMEOUT);
 		if (exit_kapmd)
@@ -1422,7 +1426,9 @@ static void apm_mainloop(void)
 		 * so as not to count towards the load average)..
 		 */
 		set_current_state(TASK_INTERRUPTIBLE);
+		SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
 		apm_event_handler();
+		SWSUSP_ACTIVITY_END;
 	}
 	remove_wait_queue(&apm_waitqueue, &wait);
 }
diff -puN arch/i386/kernel/cpu/mcheck/non-fatal.c~20-software-suspend-linux-2.6.7-rev1-whole arch/i386/kernel/cpu/mcheck/non-fatal.c
--- linux-2.6.7-xx2/arch/i386/kernel/cpu/mcheck/non-fatal.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.809938112 -0400
+++ linux-2.6.7-xx2-xiphux/arch/i386/kernel/cpu/mcheck/non-fatal.c	2004-06-24 07:14:54.439842352 -0400
@@ -17,6 +17,7 @@
 #include <linux/interrupt.h>
 #include <linux/smp.h>
 #include <linux/module.h>
+#include <linux/suspend.h>
 
 #include <asm/processor.h> 
 #include <asm/system.h>
@@ -57,7 +58,10 @@ static DECLARE_WORK(mce_work, mce_work_f
 
 static void mce_work_fn(void *data)
 { 
-	on_each_cpu(mce_checkregs, NULL, 1, 1);
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+	if (!(software_suspend_state & SOFTWARE_SUSPEND_RUNNING))
+#endif
+		on_each_cpu(mce_checkregs, NULL, 1, 1);
 	schedule_delayed_work(&mce_work, MCE_RATE);
 } 
 
diff -puN arch/i386/kernel/io_apic.c~20-software-suspend-linux-2.6.7-rev1-whole arch/i386/kernel/io_apic.c
--- linux-2.6.7-xx2/arch/i386/kernel/io_apic.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.812937656 -0400
+++ linux-2.6.7-xx2-xiphux/arch/i386/kernel/io_apic.c	2004-06-24 07:16:13.968752120 -0400
@@ -31,6 +31,7 @@
 #include <linux/mc146818rtc.h>
 #include <linux/compiler.h>
 #include <linux/acpi.h>
+#include <linux/suspend.h>
 
 #include <asm/io.h>
 #include <asm/smp.h>
@@ -560,17 +561,23 @@ static int balanced_irq(void *unused)
 	int i;
 	unsigned long prev_balance_time = jiffies;
 	long time_remaining = balanced_irq_interval;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	daemonize("kirqd");
 	
+	SWSUSP_THREAD_FLAGS_RESET;
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
+
 	/* push everything to CPU 0 to give us a starting point.  */
 	for (i = 0 ; i < NR_IRQS ; i++) {
 		pending_irq_balance_cpumask[i] = cpumask_of_cpu(0);
 	}
 
 	for ( ; ; ) {
+		SWSUSP_ACTIVITY_PAUSING;
 		set_current_state(TASK_INTERRUPTIBLE);
 		time_remaining = schedule_timeout(time_remaining);
+		SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 		if (time_after(jiffies,
 				prev_balance_time+balanced_irq_interval)) {
 			do_irq_balance();
diff -puN arch/i386/kernel/process.c~20-software-suspend-linux-2.6.7-rev1-whole arch/i386/kernel/process.c
--- linux-2.6.7-xx2/arch/i386/kernel/process.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.817936896 -0400
+++ linux-2.6.7-xx2-xiphux/arch/i386/kernel/process.c	2004-06-24 07:14:54.448840984 -0400
@@ -37,6 +37,7 @@
 #include <linux/module.h>
 #include <linux/kallsyms.h>
 #include <linux/ptrace.h>
+#include <linux/suspend.h>
 
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -595,7 +596,12 @@ struct task_struct fastcall * __switch_t
 
 asmlinkage int sys_fork(struct pt_regs regs)
 {
-	return do_fork(SIGCHLD, regs.esp, &regs, 0, NULL, NULL);
+	int result;
+	DECLARE_SWSUSP_LOCAL_VAR;
+	SWSUSP_ACTIVITY_START(0);
+	result = do_fork(SIGCHLD, regs.esp, &regs, 0, NULL, NULL);
+	SWSUSP_ACTIVITY_END;
+	return result;
 }
 
 asmlinkage int sys_clone(struct pt_regs regs)
@@ -603,6 +609,10 @@ asmlinkage int sys_clone(struct pt_regs 
 	unsigned long clone_flags;
 	unsigned long newsp;
 	int __user *parent_tidptr, *child_tidptr;
+	int result;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	clone_flags = regs.ebx;
 	newsp = regs.ecx;
@@ -610,7 +620,9 @@ asmlinkage int sys_clone(struct pt_regs 
 	child_tidptr = (int __user *)regs.edi;
 	if (!newsp)
 		newsp = regs.esp;
-	return do_fork(clone_flags & ~CLONE_IDLETASK, newsp, &regs, 0, parent_tidptr, child_tidptr);
+	result = do_fork(clone_flags & ~CLONE_IDLETASK, newsp, &regs, 0, parent_tidptr, child_tidptr);
+	SWSUSP_ACTIVITY_END;
+	return result;
 }
 
 /*
@@ -625,7 +637,14 @@ asmlinkage int sys_clone(struct pt_regs 
  */
 asmlinkage int sys_vfork(struct pt_regs regs)
 {
-	return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, regs.esp, &regs, 0, NULL, NULL);
+	int result;
+
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
+	result = do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, regs.esp, &regs, 0, NULL, NULL);
+	SWSUSP_ACTIVITY_END;
+	return result;
 }
 
 /*
diff -puN arch/i386/kernel/signal.c~20-software-suspend-linux-2.6.7-rev1-whole arch/i386/kernel/signal.c
--- linux-2.6.7-xx2/arch/i386/kernel/signal.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.819936592 -0400
+++ linux-2.6.7-xx2-xiphux/arch/i386/kernel/signal.c	2004-06-24 07:14:54.449840832 -0400
@@ -573,8 +573,10 @@ int fastcall do_signal(struct pt_regs *r
 #endif
 
 	if (current->flags & PF_FREEZE) {
-		refrigerator(0);
-		goto no_signal;
+		refrigerator(PF_FREEZE);
+		recalc_sigpending();
+		if (!signal_pending(current))
+			goto no_signal;
 	}
 
 	if (!oldset)
diff -puN arch/i386/kernel/smp.c~20-software-suspend-linux-2.6.7-rev1-whole arch/i386/kernel/smp.c
--- linux-2.6.7-xx2/arch/i386/kernel/smp.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.823935984 -0400
+++ linux-2.6.7-xx2-xiphux/arch/i386/kernel/smp.c	2004-06-24 07:14:54.452840376 -0400
@@ -452,7 +452,7 @@ void flush_tlb_page(struct vm_area_struc
 	preempt_enable();
 }
 
-static void do_flush_tlb_all(void* info)
+void do_flush_tlb_all(void* info)
 {
 	unsigned long cpu = smp_processor_id();
 
diff -puN arch/i386/mm/init.c~20-software-suspend-linux-2.6.7-rev1-whole arch/i386/mm/init.c
--- linux-2.6.7-xx2/arch/i386/mm/init.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.826935528 -0400
+++ linux-2.6.7-xx2-xiphux/arch/i386/mm/init.c	2004-06-24 07:14:54.454840072 -0400
@@ -27,6 +27,9 @@
 #include <linux/slab.h>
 #include <linux/proc_fs.h>
 #include <linux/efi.h>
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+#include <linux/suspend-common.h>
+#endif
 
 #include <asm/processor.h>
 #include <asm/system.h>
@@ -269,6 +272,9 @@ void __init one_highpage_init(struct pag
 	*bad = 0;
 	if (page_is_ram(pfn) && !(bad_ppro && page_kills_ppro(pfn))) {
 		ClearPageReserved(page);
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+		ClearPageNosave(page);
+#endif
 		set_bit(PG_highmem, &page->flags);
 		set_page_count(page, 1);
 #ifdef CONFIG_BADRAM
@@ -278,8 +284,12 @@ void __init one_highpage_init(struct pag
 #endif
 			__free_page(page);
 		totalhigh_pages++;
-	} else
+	} else {
 		SetPageReserved(page);
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+		SetPageNosave(page);
+#endif
+	}
 }
 
 #ifndef CONFIG_DISCONTIGMEM
@@ -360,7 +370,7 @@ static void __init pagetable_init (void)
 #endif
 }
 
-#if defined(CONFIG_PM_DISK) || defined(CONFIG_SOFTWARE_SUSPEND)
+#if defined(CONFIG_PM_DISK) || defined(CONFIG_SOFTWARE_SUSPEND) || defined(CONFIG_SOFTWARE_SUSPEND2)
 /*
  * Swap suspend & friends need this for resume because things like the intel-agp
  * driver might have split up a kernel 4MB mapping.
@@ -553,6 +563,7 @@ void __init mem_init(void)
 	int codesize, reservedpages, badpages, datasize, initsize;
 	int tmp;
 	int bad_ppro;
+	void * addr;
 
 #ifndef CONFIG_DISCONTIGMEM
 	if (!mem_map)
@@ -584,15 +595,31 @@ void __init mem_init(void)
 
 	reservedpages = 0;
 	badpages = 0;
-	for (tmp = 0; tmp < max_low_pfn; tmp++) {
-		/*
-		 * Only count reserved and bad RAM pages
-		 */
-		if (page_is_ram(tmp) && PageReserved(pfn_to_page(tmp)))
-			reservedpages++;
+	addr = __va(0);
+	for (tmp = 0; tmp < max_low_pfn; tmp++, addr += PAGE_SIZE) {
+		if (page_is_ram(tmp)) {
+			/*
+			 * Only count reserved RAM pages
+			 */
+			if (PageReserved(mem_map+tmp))
+				reservedpages++;
 #ifdef CONFIG_BADRAM
-		if (page_is_ram(tmp) && PageBad(pfn_to_page(tmp)))
-			badpages++;
+			if (PageBad(mem_map+tmp))
+				badpages++;
+#endif
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+			/*
+			 * Mark nosave pages
+			 */
+			if (addr >= (void *)&__nosave_begin && addr < (void *)&__nosave_end)
+				SetPageNosave(mem_map+tmp);
+		} else
+			/*
+			 * Non-RAM pages are always nosave
+			 */
+			SetPageNosave(mem_map+tmp);
+#else
+		}
 #endif
 	}
 
@@ -706,6 +733,9 @@ void free_initmem(void)
 	addr = (unsigned long)(&__init_begin);
 	for (; addr < (unsigned long)(&__init_end); addr += PAGE_SIZE) {
 		ClearPageReserved(virt_to_page(addr));
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+		ClearPageNosave(virt_to_page(addr));
+#endif
 		set_page_count(virt_to_page(addr), 1);
 		free_page(addr);
 		totalram_pages++;
@@ -720,6 +750,9 @@ void free_initrd_mem(unsigned long start
 		printk (KERN_INFO "Freeing initrd memory: %ldk freed\n", (end - start) >> 10);
 	for (; start < end; start += PAGE_SIZE) {
 		ClearPageReserved(virt_to_page(start));
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+		ClearPageNosave(virt_to_page(start));
+#endif
 		set_page_count(virt_to_page(start), 1);
 		free_page(start);
 		totalram_pages++;
diff -puN arch/i386/mm/pageattr.c~20-software-suspend-linux-2.6.7-rev1-whole arch/i386/mm/pageattr.c
--- linux-2.6.7-xx2/arch/i386/mm/pageattr.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.829935072 -0400
+++ linux-2.6.7-xx2-xiphux/arch/i386/mm/pageattr.c	2004-06-24 07:14:54.455839920 -0400
@@ -17,7 +17,7 @@ static spinlock_t cpa_lock = SPIN_LOCK_U
 static struct list_head df_list = LIST_HEAD_INIT(df_list);
 
 
-static inline pte_t *lookup_address(unsigned long address) 
+inline pte_t *lookup_address(unsigned long address)
 { 
 	pgd_t *pgd = pgd_offset_k(address); 
 	pmd_t *pmd;
diff -puN arch/i386/power/Makefile~20-software-suspend-linux-2.6.7-rev1-whole arch/i386/power/Makefile
--- linux-2.6.7-xx2/arch/i386/power/Makefile~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.831934768 -0400
+++ linux-2.6.7-xx2-xiphux/arch/i386/power/Makefile	2004-06-24 07:14:54.456839768 -0400
@@ -1,3 +1,6 @@
+CFLAGS_suspend2.o = -O0
+
 obj-$(CONFIG_PM)		+= cpu.o
 obj-$(CONFIG_PM_DISK)		+= pmdisk.o
 obj-$(CONFIG_SOFTWARE_SUSPEND)	+= swsusp.o
+obj-$(CONFIG_SOFTWARE_SUSPEND2)	+= suspend2.o
diff -puN arch/i386/power/cpu.c~20-software-suspend-linux-2.6.7-rev1-whole arch/i386/power/cpu.c
--- linux-2.6.7-xx2/arch/i386/power/cpu.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.834934312 -0400
+++ linux-2.6.7-xx2-xiphux/arch/i386/power/cpu.c	2004-06-24 07:17:10.770117000 -0400
@@ -25,8 +25,10 @@
 #include <asm/uaccess.h>
 #include <asm/acpi.h>
 #include <asm/tlbflush.h>
+#include <asm/desc.h>
+#include <asm/suspend.h>
 
-static struct saved_context saved_context;
+struct saved_context saved_context;
 
 unsigned long saved_context_eax, saved_context_ebx;
 unsigned long saved_context_ecx, saved_context_edx;
@@ -34,6 +36,10 @@ unsigned long saved_context_esp, saved_c
 unsigned long saved_context_esi, saved_context_edi;
 unsigned long saved_context_eflags;
 
+/* Special page directory for resume */
+extern char __nosavedata swsusp_pg_dir[PAGE_SIZE]
+                  __attribute__ ((aligned (PAGE_SIZE)));
+
 extern void enable_sep_cpu(void *);
 
 void __save_processor_state(struct saved_context *ctxt)
@@ -80,7 +86,7 @@ do_fpu_end(void)
 }
 
 
-static void fix_processor_context(void)
+void fix_processor_context(void)
 {
 	int cpu = smp_processor_id();
 	struct tss_struct * t = init_tss + cpu;
diff -puN /dev/null arch/i386/power/suspend2.c
--- /dev/null	2004-05-31 17:36:38.000000000 -0400
+++ linux-2.6.7-xx2-xiphux/arch/i386/power/suspend2.c	2004-06-24 07:14:54.460839160 -0400
@@ -0,0 +1,656 @@
+ /*
+  * Copyright 2001-2002 Pavel Machek <pavel@suse.cz>
+  * Based on code
+  * Copyright 2001 Patrick Mochel <mochel@osdl.org>
+  */
+#include <linux/init.h>
+#include <linux/version.h>
+#include <asm/desc.h>
+#include <asm/i387.h>
+#include <asm/apic.h>
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,99)
+#define SUSPEND_C
+#include <linux/suspend-common.h>
+extern void do_suspend2_suspend_1(void);
+extern void do_suspend2_suspend_2(void);
+extern void do_suspend2_resume_1(void);
+extern void do_suspend2_resume_2(void);
+extern struct pagedir pagedir_resume;
+extern int suspend_io_time[2][2];
+extern char __nosavedata swsusp_pg_dir[PAGE_SIZE]
+                  __attribute__ ((aligned (PAGE_SIZE)));
+#else
+#define lowmem_page_address(struct_page) (page_address(struct_page))
+char __nosavedata swsusp_pg_dir[PAGE_SIZE]
+                  __attribute__ ((aligned (PAGE_SIZE)));
+#endif
+#ifdef SUSPEND_C
+#include <asm/processor.h>
+#endif
+//#define DEBUG_LOWLEVEL_SUSPEND
+
+/* image of the saved processor states */
+struct suspend2_saved_context {
+	u32 eax, ebx, ecx, edx;
+	u32 esp, ebp, esi, edi;
+	u16 es, fs, gs, ss;
+	u32 cr0, cr2, cr3, cr4;
+	u16 gdt_pad;
+	u16 gdt_limit;
+	u32 gdt_base;
+	u16 idt_pad;
+	u16 idt_limit;
+	u32 idt_base;
+	u16 ldt;
+	u16 tss;
+	u32 tr;
+	u32 safety;
+	u32 return_address;
+	u32 eflags;
+} __attribute__((packed));
+
+#ifdef CONFIG_SMP
+static struct suspend2_saved_context suspend2_saved_contexts[NR_CPUS];
+#endif
+static struct suspend2_saved_context suspend2_saved_context;	/* temporary storage */
+
+spinlock_t saved_context_lock __nosavedata = SPIN_LOCK_UNLOCKED;
+
+#define loaddebug(thread,register) \
+               __asm__("movl %0,%%db" #register  \
+                       : /* no output */ \
+                       :"r" ((thread)->debugreg[register]))
+
+
+/*
+ * save_processor_context
+ *
+ * Save the state of the processor before we go to sleep.
+ *
+ * return_stack is the value of the stack pointer (%esp) as the caller sees it.
+ * A good way could not be found to obtain it from here (don't want to make _too_
+ * many assumptions about the layout of the stack this far down.) Also, the
+ * handy little __builtin_frame_pointer(level) where level > 0, is blatantly
+ * buggy - it returns the value of the stack at the proper location, not the
+ * location, like it should (as of gcc 2.91.66)
+ *
+ * Note that the context and timing of this function is pretty critical.
+ * With a minimal amount of things going on in the caller and in here, gcc
+ * does a good job of being just a dumb compiler.  Watch the assembly output
+ * if anything changes, though, and make sure everything is going in the right
+ * place.
+ */
+static inline void save_processor_context(void)
+{
+	kernel_fpu_begin();
+
+	/*
+	 * descriptor tables
+	 */
+	asm volatile ("sgdt (%0)" : "=m" (suspend2_saved_context.gdt_limit));
+	asm volatile ("sidt (%0)" : "=m" (suspend2_saved_context.idt_limit));
+	asm volatile ("sldt (%0)" : "=m" (suspend2_saved_context.ldt));
+	asm volatile ("str (%0)"  : "=m" (suspend2_saved_context.tr));
+
+	/*
+	 * save the general registers.
+	 * note that gcc has constructs to specify output of certain registers,
+	 * but they're not used here, because it assumes that you want to modify
+	 * those registers, so it tries to be smart and save them beforehand.
+	 * It's really not necessary, and kinda fishy (check the assembly output),
+	 * so it's avoided.
+	 */
+	asm volatile ("movl %%esp, (%0)" : "=m" (suspend2_saved_context.esp));
+	asm volatile ("movl %%eax, (%0)" : "=m" (suspend2_saved_context.eax));
+	asm volatile ("movl %%ebx, (%0)" : "=m" (suspend2_saved_context.ebx));
+	asm volatile ("movl %%ecx, (%0)" : "=m" (suspend2_saved_context.ecx));
+	asm volatile ("movl %%edx, (%0)" : "=m" (suspend2_saved_context.edx));
+	asm volatile ("movl %%ebp, (%0)" : "=m" (suspend2_saved_context.ebp));
+	asm volatile ("movl %%esi, (%0)" : "=m" (suspend2_saved_context.esi));
+	asm volatile ("movl %%edi, (%0)" : "=m" (suspend2_saved_context.edi));
+
+	/*
+	 * segment registers
+	 */
+	asm volatile ("movw %%es, %0" : "=r" (suspend2_saved_context.es));
+	asm volatile ("movw %%fs, %0" : "=r" (suspend2_saved_context.fs));
+	asm volatile ("movw %%gs, %0" : "=r" (suspend2_saved_context.gs));
+	asm volatile ("movw %%ss, %0" : "=r" (suspend2_saved_context.ss));
+
+	/*
+	 * control registers
+	 */
+	asm volatile ("movl %%cr0, %0" : "=r" (suspend2_saved_context.cr0));
+	asm volatile ("movl %%cr2, %0" : "=r" (suspend2_saved_context.cr2));
+	asm volatile ("movl %%cr3, %0" : "=r" (suspend2_saved_context.cr3));
+	asm volatile ("movl %%cr4, %0" : "=r" (suspend2_saved_context.cr4));
+
+	/*
+	 * eflags
+	 */
+	asm volatile ("pushfl ; popl (%0)" : "=m" (suspend2_saved_context.eflags));
+}
+
+static void fix_processor_context(void)
+{
+	int nr = smp_processor_id();
+	struct tss_struct * t = &init_tss[nr];
+
+	set_tss_desc(nr,t);	/* This just modifies memory; should not be neccessary. But... This is neccessary, because 386 hardware has concept of busy tsc or some similar stupidity. */
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,4,99)
+        cpu_gdt_table[nr][GDT_ENTRY_TSS].b &= 0xfffffdff;
+
+	load_TR_desc();
+#else
+        gdt_table[__TSS(nr)].b &= 0xfffffdff;
+
+	load_TR(nr);		/* This does ltr */
+#endif
+
+	load_LDT(&current->active_mm->context);	/* This does lldt */
+
+	/*
+	 * Now maybe reload the debug registers
+	 */
+	if (current->thread.debugreg[7]){
+                loaddebug(&current->thread, 0);
+                loaddebug(&current->thread, 1);
+                loaddebug(&current->thread, 2);
+                loaddebug(&current->thread, 3);
+                /* no 4 and 5 */
+                loaddebug(&current->thread, 6);
+                loaddebug(&current->thread, 7);
+	}
+
+}
+
+static void do_fpu_end(void)
+{
+        /* restore FPU regs if necessary */
+	/* Do it out of line so that gcc does not move cr0 load to some stupid place */
+        kernel_fpu_end();
+}
+
+/*
+ * restore_processor_context
+ *
+ * Restore the processor context as it was before we went to sleep
+ * - descriptor tables
+ * - control registers
+ * - segment registers
+ * - flags
+ *
+ * Note that it is critical that this function is declared inline.
+ * It was separated out from restore_state to make that function
+ * a little clearer, but it needs to be inlined because we won't have a
+ * stack when we get here (so we can't push a return address).
+ */
+static inline void restore_processor_context(void)
+{
+	/*
+	 * first restore %ds, so we can access our data properly
+	 */
+	asm volatile (".align 4");
+	asm volatile ("movw %0, %%ds" :: "r" ((u16)__KERNEL_DS));
+
+
+	/*
+	 * control registers
+	 */
+	asm volatile ("movl %0, %%cr4" :: "r" (suspend2_saved_context.cr4));
+	asm volatile ("movl %0, %%cr3" :: "r" (suspend2_saved_context.cr3));
+	asm volatile ("movl %0, %%cr2" :: "r" (suspend2_saved_context.cr2));
+	asm volatile ("movl %0, %%cr0" :: "r" (suspend2_saved_context.cr0));
+
+	/*
+	 * segment registers
+	 */
+	asm volatile ("movw %0, %%es" :: "r" (suspend2_saved_context.es));
+	asm volatile ("movw %0, %%fs" :: "r" (suspend2_saved_context.fs));
+	asm volatile ("movw %0, %%gs" :: "r" (suspend2_saved_context.gs));
+	asm volatile ("movw %0, %%ss" :: "r" (suspend2_saved_context.ss));
+
+	/*
+	 * the other general registers
+	 *
+	 * note that even though gcc has constructs to specify memory
+	 * input into certain registers, it will try to be too smart
+	 * and save them at the beginning of the function.  This is esp.
+	 * bad since we don't have a stack set up when we enter, and we
+	 * want to preserve the values on exit. So, we set them manually.
+	 */
+	asm volatile ("movl %0, %%esp" :: "m" (suspend2_saved_context.esp));
+	asm volatile ("movl %0, %%ebp" :: "m" (suspend2_saved_context.ebp));
+	asm volatile ("movl %0, %%eax" :: "m" (suspend2_saved_context.eax));
+	asm volatile ("movl %0, %%ebx" :: "m" (suspend2_saved_context.ebx));
+	asm volatile ("movl %0, %%ecx" :: "m" (suspend2_saved_context.ecx));
+	asm volatile ("movl %0, %%edx" :: "m" (suspend2_saved_context.edx));
+	asm volatile ("movl %0, %%esi" :: "m" (suspend2_saved_context.esi));
+	asm volatile ("movl %0, %%edi" :: "m" (suspend2_saved_context.edi));
+
+	/*
+	 * now restore the descriptor tables to their proper values
+	 * ltr is done i fix_processor_context().
+	 */
+
+	asm volatile ("lgdt (%0)" :: "m" (suspend2_saved_context.gdt_limit));
+	asm volatile ("lidt (%0)" :: "m" (suspend2_saved_context.idt_limit));
+	asm volatile ("lldt (%0)" :: "m" (suspend2_saved_context.ldt));
+
+	fix_processor_context();
+
+	/*
+	 * the flags
+	 */
+	asm volatile ("pushl %0 ; popfl" :: "m" (suspend2_saved_context.eflags));
+
+	do_fpu_end();
+}
+
+#ifdef SUSPEND_C
+/* Local variables for do_suspend2_lowlevel */
+volatile static int loop __nosavedata = 0;
+volatile static int state1 __nosavedata = 0;
+volatile static int state2 __nosavedata = 0;
+volatile static int state3 __nosavedata = 0;
+volatile static struct range *origrange __nosavedata;
+volatile static struct range *copyrange __nosavedata;
+volatile static int origoffset __nosavedata;
+volatile static int copyoffset __nosavedata;
+volatile static unsigned long * origpage __nosavedata;
+volatile static unsigned long * copypage __nosavedata;
+volatile unsigned char * my_saved_context __nosavedata;
+static int io_speed_save[2][2] __nosavedata;
+#ifndef CONFIG_SMP
+static unsigned long c_loops_per_jiffy_ref __nosavedata = 0;
+static unsigned long cpu_khz_ref __nosavedata = 0;
+#endif
+extern atomic_t suspend_cpu_counter __nosavedata;
+
+/*
+ * APIC support: These routines save the APIC
+ * configuration for the CPU on which they are
+ * being executed
+ */
+extern void suspend_apic_save_state(void);
+extern void suspend_apic_reload_state(void);
+
+#ifdef CONFIG_SMP
+/* ------------------------------------------------
+ * BEGIN Irq affinity code, based on code from LKCD.
+ *
+ * IRQ affinity support:
+ * Save and restore IRQ affinities, and set them
+ * all to CPU 0.
+ *
+ * Section between dashes taken from LKCD code.
+ * Perhaps we should be working toward a shared library
+ * of such routines for kexec, lkcd, software suspend
+ * and whatever other similar projects there are?
+ */
+
+extern irq_desc_t irq_desc[];
+extern unsigned long irq_affinity[];
+unsigned long saved_affinity[NR_IRQS];
+
+/*
+ * Routine to save the old irq affinities and change affinities of all irqs to
+ * the dumping cpu.
+ */
+static void set_irq_affinity(void)
+{
+	int i;
+	int cpu = smp_processor_id();
+
+	memcpy(saved_affinity, irq_affinity, NR_IRQS * sizeof(unsigned long));
+	for (i = 0; i < NR_IRQS; i++) {
+		if (irq_desc[i].handler == NULL)
+			continue;
+		irq_affinity[i] = 1UL << cpu;
+		if (irq_desc[i].handler->set_affinity != NULL)
+			irq_desc[i].handler->set_affinity(i, irq_affinity[i]);
+	}
+}
+
+/*
+ * Restore old irq affinities.
+ */
+static void reset_irq_affinity(void)
+{
+	int i;
+
+	memcpy(irq_affinity, saved_affinity, NR_IRQS * sizeof(unsigned long));
+	for (i = 0; i < NR_IRQS; i++) {
+		if (irq_desc[i].handler == NULL)
+			continue;
+		if (irq_desc[i].handler->set_affinity != NULL)
+			irq_desc[i].handler->set_affinity(i, saved_affinity[i]);
+	}
+}
+
+/*
+ * END of IRQ affinity code, based on LKCD code.
+ * -----------------------------------------------------------------
+ */
+#endif
+
+/*
+ * FIXME: This function should really be written in assembly. Actually
+ * requirement is that it does not touch stack, because %esp will be
+ * wrong during resume before restore_processor_context(). Check
+ * assembly if you modify this.
+ *
+ * SMP support:
+ * All SMP processors enter this routine during suspend. The one through
+ * which the suspend is initiated (which, for simplicity, is always CPU 0)
+ * sends the others here using an IPI during do_suspend2_suspend_1. They
+ * remain here until after the atomic copy of the kernel is made, to ensure
+ * that they don't mess with memory in the meantime (even just idling will
+ * do that). Once the atomic copy is made, they are free to carry on idling.
+ * Note that we must let them go, because if we're using compression, the
+ * vfree calls in the compressors will result in IPIs being called and hanging
+ * because the CPUs are still here.
+ *
+ * At resume time, we do a similar thing. CPU 0 sends the others in here using
+ * an IPI. It then copies the original kernel back, restores its own processor
+ * context and flushes local tlbs before freeing the others to do the same.
+ * They can then go back to idling while CPU 0 reloads pageset 2, cleans up
+ * and unfreezes the processes.
+ *
+ * (Remember that freezing and thawing processes also uses IPIs, as may
+ * decompressing the data. Again, therefore, we cannot leave the other processors
+ * in here).
+ *
+ * At the moment, we do nothing about APICs, even though the code is there.
+ */
+void do_suspend2_lowlevel(int resume)
+{
+	if (!resume) {
+#ifdef CONFIG_SMP
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+		if (smp_processor_id() != cpu_logical_map(0)) {
+#else
+		if (smp_processor_id()) {
+#endif
+			/*
+			 *Save context and go back to idling.
+			 * Note that we cannot leave the processor
+			 * here. It must be able to receive IPIs if
+			 * the LZF compression driver (eg) does a
+			 * vfree after compressing the kernel etc
+			 */
+			while ((software_suspend_state & SOFTWARE_SUSPEND_FREEZE_SMP) &&
+				(atomic_read(&suspend_cpu_counter) != (smp_processor_id() - 1))) {
+				smp_mb();
+				barrier();
+			}
+			save_processor_context();
+			my_saved_context = (unsigned char *) (suspend2_saved_contexts + smp_processor_id());
+			for (loop = sizeof(struct suspend2_saved_context); loop--; loop)
+				*(my_saved_context + loop - 1) = *(((unsigned char *) &suspend2_saved_context) + loop - 1);
+#ifdef DEBUG_LOWLEVEL_SUSPEND
+			printk("Saved context:\n");
+			for (loop = 0; loop < sizeof(struct suspend2_saved_context); loop+=(sizeof(unsigned long))) {
+				if (!(loop%16))
+					printk("%p: ", ((unsigned char *) &suspend2_saved_context) + loop);
+				printk("%lx %s",
+					*((unsigned long *) (((unsigned char *) &suspend2_saved_context) + loop)),
+					(!((loop + 4)%16)) ? "\n" : "");
+			}
+			printk("\nMy Saved context:\n");
+			for (loop = 0; loop < sizeof(struct suspend2_saved_context); loop+=4) {
+				if (!(loop%16))
+					printk("%p: ", my_saved_context + loop);
+				printk("%lx %s",
+					*((unsigned long *) (my_saved_context + loop)),
+					(!((loop + 4)%16)) ? "\n" : "");
+			}
+			printk("\n");
+#endif
+			atomic_inc(&suspend_cpu_counter);
+			/* Now spin until the atomic copy of the kernel is made. */
+			while (software_suspend_state & SOFTWARE_SUSPEND_FREEZE_SMP) {
+				cpu_relax();
+				smp_mb();
+			}
+			FLUSH_LOCAL_TLB();
+			atomic_dec(&suspend_cpu_counter);
+			return;
+		}
+
+		/*
+		 * Save the irq affinities before we freeze the
+		 * other processors!
+		 */
+		set_irq_affinity();
+#endif
+
+		do_suspend2_suspend_1();
+		save_processor_context();	/* We need to capture registers and memory at "same time" */
+		do_suspend2_suspend_2();		/* If everything goes okay, this function does not return */
+		return;
+	}
+
+	/* We want to run from swsusp_pg_dir, since swsusp_pg_dir is stored in constant
+	 * place in memory
+	 */
+
+        __asm__( "movl %%ecx,%%cr3\n" ::"c"(__pa(swsusp_pg_dir)));
+
+/*
+ * Final function for resuming: after copying the pages to their original
+ * position, it restores the register state.
+ *
+ * What about page tables? Writing data pages may toggle
+ * accessed/dirty bits in our page tables. That should be no problems
+ * with 4MB page tables. That's why we require have_pse.
+ *
+ * This loops destroys stack from under itself, so it better should
+ * not use any stack space, itself. When this function is entered at
+ * resume time, we move stack to _old_ place.  This is means that this
+ * function must use no stack and no local variables in registers,
+ * until calling restore_processor_context();
+ *
+ * Critical section here: noone should touch saved memory after
+ * do_suspend2_resume_1; copying works, because nr_copy_pages,
+ * pagedir_resume, loop and loop2 are nosavedata.
+ */
+
+#ifdef CONFIG_PREEMPT
+	/*
+	 * Preempt disabled in kernel we're about to restore.
+	 * Make sure we match state now.
+	 */
+	preempt_disable();
+#endif
+
+#ifdef CONFIG_SMP
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+	if (smp_processor_id() != cpu_logical_map(0)) {
+#else
+	if (smp_processor_id()) {
+#endif
+		/* Save context and hold other processors here */
+		atomic_inc(&suspend_cpu_counter);
+		smp_mb();
+		barrier();
+		while ((software_suspend_state & SOFTWARE_SUSPEND_FREEZE_SMP) ||
+			(atomic_read(&suspend_cpu_counter) != smp_processor_id())) {
+			cpu_relax();
+			smp_mb();
+		}
+	       	my_saved_context = (unsigned char *) (suspend2_saved_contexts + smp_processor_id());
+		//KDB_ENTER();
+		for (loop = sizeof(struct suspend2_saved_context); loop--; loop)
+			*(((unsigned char *) &suspend2_saved_context) + loop - 1) = *(my_saved_context + loop - 1);
+		restore_processor_context();
+		FLUSH_LOCAL_TLB();
+		atomic_dec(&suspend_cpu_counter);
+		return;
+	}
+#endif
+
+	do_suspend2_resume_1();
+
+	state1 = suspend_action;
+	state2 = suspend_debug_state;
+	state3 = console_loglevel;
+	for (loop = 0; loop < 4; loop++)
+		io_speed_save[loop/2][loop%2] =
+			suspend_io_time[loop/2][loop%2];
+
+#ifdef CONFIG_SMP
+	/* Send all IRQs to CPU 0. We will replace the saved affinities
+	 * with the suspend-time ones when we copy the original kernel
+	 * back in place
+	 */
+	set_irq_affinity();
+#else
+	c_loops_per_jiffy_ref = cpu_data->loops_per_jiffy;
+	cpu_khz_ref = cpu_khz;
+#endif
+
+	origrange = pagedir_resume.origranges.first;
+	copyrange = pagedir_resume.destranges.first;
+	origoffset = origrange->minimum;
+	copyoffset = copyrange->minimum;
+	origpage = (unsigned long *) (lowmem_page_address(mem_map + origoffset));
+	copypage = (unsigned long *) (lowmem_page_address(mem_map + copyoffset));
+
+	/* As of 2.0.0.51, pageset1 can include highmem pages. If
+	 * !CONFIG_HIGHMEM, highstart_pfn == 0, hence the #ifdef.
+	 */
+#ifdef CONFIG_HIGHMEM
+	while ((origrange) && (origoffset < highstart_pfn)) {
+#else
+	while (origrange) {
+#endif
+		for (loop=0; loop < (PAGE_SIZE / sizeof(unsigned long)); loop++)
+			*(origpage + loop) = *(copypage + loop);
+
+		if (origoffset < origrange->maximum) {
+			origoffset++;
+			origpage += (PAGE_SIZE / sizeof(unsigned long));
+		} else {
+			origrange = origrange->next;
+			if (origrange) {
+				origoffset = origrange->minimum;
+				origpage = (unsigned long *) (lowmem_page_address(mem_map + origoffset));
+			}
+		}
+
+		if (copyoffset < copyrange->maximum) {
+			copyoffset++;
+			copypage += (PAGE_SIZE / sizeof(unsigned long));
+		} else {
+			copyrange = copyrange->next;
+			if (copyrange) {
+				copyoffset = copyrange->minimum;
+				copypage = (unsigned long *) (lowmem_page_address(mem_map + copyoffset));
+			}
+		}
+	}
+
+	restore_processor_context();
+#ifdef CONFIG_SMP
+	FLUSH_LOCAL_TLB();
+#else
+	__flush_tlb_all();
+#endif
+
+	/* Now we are running with our old stack, and with registers copied
+	 * from suspend time. Let's copy back those remaining Highmem pages. */
+
+#ifdef CONFIG_HIGHMEM
+	while (origrange) {
+		unsigned long * origpage = (unsigned long *) kmap_atomic(mem_map + origoffset);
+		for (loop=0; loop < (PAGE_SIZE / sizeof(unsigned long)); loop++)
+			*(origpage + loop) = *(copypage + loop);
+		kunmap_atomic(mem_map + origoffset);
+
+		if (origoffset < origrange->maximum)
+			origoffset++;
+		else {
+			origrange = origrange->next;
+			if (origrange)
+				origoffset = origrange->minimum;
+		}
+
+		if (copyoffset < copyrange->maximum) {
+			copyoffset++;
+			copypage += (PAGE_SIZE / sizeof(unsigned long));
+		} else {
+			copyrange = copyrange->next;
+			if (copyrange) {
+				copyoffset = copyrange->minimum;
+				copypage = (unsigned long *) (page_address(mem_map + copyoffset));
+			}
+		}
+	}
+#endif
+
+#if defined(DEBUG_LOWLEVEL_SUSPEND) && #defined(CONFIG_SMP)
+	{
+		my_saved_context = (unsigned char *) (suspend2_saved_contexts + 1);
+		printk("Saved context for CPU 1:\n");
+		for (loop = 0; loop < sizeof(struct suspend2_saved_context); loop+=4) {
+			if (!(loop%16))
+				printk("%p: ", my_saved_context + loop);
+			printk("%lx %s",
+				*((unsigned long *) (my_saved_context + loop)),
+				(!((loop + 4)%16)) ? "\n" : "");
+		}
+	}
+#endif
+	/* Get other CPUs to restore their contexts and flush their tlbs. */
+	software_suspend_state &= ~SOFTWARE_SUSPEND_FREEZE_SMP;
+
+	while (atomic_read(&suspend_cpu_counter)) {
+		cpu_relax();
+		smp_mb();
+	}
+
+#ifdef CONFIG_SMP
+	/* put the irq affinity tables back */
+	reset_irq_affinity();
+#else
+	cpu_data->loops_per_jiffy = c_loops_per_jiffy_ref;
+	loops_per_jiffy = c_loops_per_jiffy_ref;
+	cpu_khz = cpu_khz_ref;
+#endif
+	suspend_action = state1;
+	suspend_debug_state = state2;
+	console_loglevel = state3;
+
+	for (loop = 0; loop < 4; loop++)
+		suspend_io_time[loop/2][loop%2] =
+			io_speed_save[loop/2][loop%2];
+
+	do_suspend2_resume_2();
+#ifdef DEBUG_LOWLEVEL_SUSPEND
+	printk("CPU %d left lowlevel suspend.\n", smp_processor_id());
+#endif
+}
+
+/*
+ * Function to put other smp processors in do_suspend2_lowlevel
+ * during suspend or resume. They get their CPU data saved and
+ * restored there
+ */
+
+void smp_suspend2_lowlevel(void * info)
+{
+	unsigned long irq_lock_flags;
+	spinlock_t irq_lock = SPIN_LOCK_UNLOCKED;
+
+	smp_mb();
+	barrier();
+	spin_lock_irqsave(&irq_lock, irq_lock_flags);
+	kernel_fpu_begin();
+	do_suspend2_lowlevel(now_resuming);
+	barrier();
+	smp_mb();
+	kernel_fpu_end();
+	spin_unlock_irqrestore(&irq_lock, irq_lock_flags);
+}
+#endif
diff -puN arch/ppc/Kconfig~20-software-suspend-linux-2.6.7-rev1-whole arch/ppc/Kconfig
--- linux-2.6.7-xx2/arch/ppc/Kconfig~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.836934008 -0400
+++ linux-2.6.7-xx2-xiphux/arch/ppc/Kconfig	2004-06-24 07:14:54.463838704 -0400
@@ -225,6 +225,8 @@ config PPC601_SYNC_FIX
 
 	  If in doubt, say Y here.
 
+source kernel/power/Kconfig
+
 source arch/ppc/platforms/4xx/Kconfig
 source arch/ppc/platforms/85xx/Kconfig
 
diff -puN arch/ppc/Makefile~20-software-suspend-linux-2.6.7-rev1-whole arch/ppc/Makefile
--- linux-2.6.7-xx2/arch/ppc/Makefile~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.840933400 -0400
+++ linux-2.6.7-xx2-xiphux/arch/ppc/Makefile	2004-06-24 07:14:54.480836120 -0400
@@ -49,6 +49,7 @@ core-$(CONFIG_APUS)		+= arch/ppc/amiga/
 drivers-$(CONFIG_8xx)		+= arch/ppc/8xx_io/
 drivers-$(CONFIG_4xx)		+= arch/ppc/4xx_io/
 drivers-$(CONFIG_8260)		+= arch/ppc/8260_io/
+drivers-$(CONFIG_PM)		+= arch/ppc/power/
 
 drivers-$(CONFIG_OPROFILE)	+= arch/ppc/oprofile/
 
diff -puN arch/ppc/kernel/signal.c~20-software-suspend-linux-2.6.7-rev1-whole arch/ppc/kernel/signal.c
--- linux-2.6.7-xx2/arch/ppc/kernel/signal.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.843932944 -0400
+++ linux-2.6.7-xx2-xiphux/arch/ppc/kernel/signal.c	2004-06-24 07:14:54.482835816 -0400
@@ -28,6 +28,7 @@
 #include <linux/elf.h>
 #include <linux/tty.h>
 #include <linux/binfmts.h>
+#include <linux/suspend.h>
 #include <asm/ucontext.h>
 #include <asm/uaccess.h>
 #include <asm/pgtable.h>
@@ -608,6 +609,15 @@ int do_signal(sigset_t *oldset, struct p
 	unsigned long frame, newsp;
 	int signr, ret;
 
+	if (current->flags & PF_FREEZE) {
+		refrigerator(PF_FREEZE);
+		signr = 0;
+		ret = regs->gpr[3];
+		recalc_sigpending();
+		if (!signal_pending(current))
+			goto no_signal;
+	}
+
 	if (!oldset)
 		oldset = &current->blocked;
 
@@ -632,6 +642,7 @@ int do_signal(sigset_t *oldset, struct p
 			regs->gpr[3] = EINTR;
 			/* note that the cr0.SO bit is already set */
 		} else {
+no_signal:
 			regs->nip -= 4;	/* Back up & retry system call */
 			regs->result = 0;
 			regs->trap = 0;
diff -puN arch/ppc/kernel/vmlinux.lds.S~20-software-suspend-linux-2.6.7-rev1-whole arch/ppc/kernel/vmlinux.lds.S
--- linux-2.6.7-xx2/arch/ppc/kernel/vmlinux.lds.S~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.847932336 -0400
+++ linux-2.6.7-xx2-xiphux/arch/ppc/kernel/vmlinux.lds.S	2004-06-24 07:14:54.484835512 -0400
@@ -73,6 +73,12 @@ SECTIONS
     CONSTRUCTORS
   }
 
+  . = ALIGN(4096);
+  __nosave_begin = .;
+  .data_nosave : { *(.data.nosave) }
+  . = ALIGN(4096);
+  __nosave_end = .;
+
   . = ALIGN(32);
   .data.cacheline_aligned : { *(.data.cacheline_aligned) }
 
diff -puN arch/ppc/mm/init.c~20-software-suspend-linux-2.6.7-rev1-whole arch/ppc/mm/init.c
--- linux-2.6.7-xx2/arch/ppc/mm/init.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.851931728 -0400
+++ linux-2.6.7-xx2-xiphux/arch/ppc/mm/init.c	2004-06-24 07:14:54.489834752 -0400
@@ -31,6 +31,9 @@
 #include <linux/bootmem.h>
 #include <linux/highmem.h>
 #include <linux/initrd.h>
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+#include <linux/suspend-common.h>
+#endif
 
 #include <asm/pgalloc.h>
 #include <asm/prom.h>
@@ -148,6 +151,9 @@ static void free_sec(unsigned long start
 
 	while (start < end) {
 		ClearPageReserved(virt_to_page(start));
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+		ClearPageNosave(virt_to_page(start));
+#endif
 		set_page_count(virt_to_page(start), 1);
 		free_page(start);
 		cnt++;
@@ -187,6 +193,9 @@ void free_initrd_mem(unsigned long start
 
 	for (; start < end; start += PAGE_SIZE) {
 		ClearPageReserved(virt_to_page(start));
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+		ClearPageNosave(virt_to_page(start));
+#endif
 		set_page_count(virt_to_page(start), 1);
 		free_page(start);
 		totalram_pages++;
@@ -419,8 +428,12 @@ void __init mem_init(void)
 	/* if we are booted from BootX with an initial ramdisk,
 	   make sure the ramdisk pages aren't reserved. */
 	if (initrd_start) {
-		for (addr = initrd_start; addr < initrd_end; addr += PAGE_SIZE)
+		for (addr = initrd_start; addr < initrd_end; addr += PAGE_SIZE) {
 			ClearPageReserved(virt_to_page(addr));
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+			ClearPageNosave(virt_to_page(addr));
+#endif
+		}
 	}
 #endif /* CONFIG_BLK_DEV_INITRD */
 
@@ -446,6 +459,14 @@ void __init mem_init(void)
 	     addr += PAGE_SIZE) {
 		if (!PageReserved(virt_to_page(addr)))
 			continue;
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+		/*
+		 * Mark nosave pages
+		 */
+		if (addr >= (void *)&__nosave_begin && addr < (void *)&__nosave_end)
+			SetPageNosave(virt_to_page(addr));
+#endif
+
 		if (addr < (ulong) etext)
 			codepages++;
 		else if (addr >= (unsigned long)&__init_begin
@@ -463,6 +484,9 @@ void __init mem_init(void)
 			struct page *page = mem_map + pfn;
 
 			ClearPageReserved(page);
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+			ClearPageNosave(page);
+#endif
 			set_bit(PG_highmem, &page->flags);
 			set_page_count(page, 1);
 			__free_page(page);
@@ -496,7 +520,6 @@ void __init mem_init(void)
 			pg->index = addr;
 		}
 	}
-
 	mem_init_done = 1;
 }
 
diff -puN arch/ppc/platforms/pmac_feature.c~20-software-suspend-linux-2.6.7-rev1-whole arch/ppc/platforms/pmac_feature.c
--- linux-2.6.7-xx2/arch/ppc/platforms/pmac_feature.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.853931424 -0400
+++ linux-2.6.7-xx2-xiphux/arch/ppc/platforms/pmac_feature.c	2004-06-24 07:14:54.493834144 -0400
@@ -2146,7 +2146,10 @@ static struct pmac_mb_def pmac_mb_defs[]
 	},
 	{	"PowerBook6,1",			"PowerBook G4 12\"",
 		PMAC_TYPE_UNKNOWN_INTREPID,	intrepid_features,
-		PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE,
+		PMAC_MB_HAS_FW_POWER | PMAC_MB_MOBILE
+#ifdef CONFIG_SOFTWARE_REPLACE_SLEEP
+		| PMAC_MB_CAN_SLEEP,
+#endif
 	},
 	{	"PowerBook6,2",			"PowerBook G4",
 		PMAC_TYPE_UNKNOWN_INTREPID,	intrepid_features,
diff -puN /dev/null arch/ppc/power/Makefile
--- /dev/null	2004-05-31 17:36:38.000000000 -0400
+++ linux-2.6.7-xx2-xiphux/arch/ppc/power/Makefile	2004-06-24 07:14:54.493834144 -0400
@@ -0,0 +1,2 @@
+obj-$(CONFIG_PM) += cpu.o
+obj-$(CONFIG_SOFTWARE_SUSPEND2) += swsusp2-asm.o
diff -puN /dev/null arch/ppc/power/cpu.c
--- /dev/null	2004-05-31 17:36:38.000000000 -0400
+++ linux-2.6.7-xx2-xiphux/arch/ppc/power/cpu.c	2004-06-24 07:14:54.494833992 -0400
@@ -0,0 +1,61 @@
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/string.h>
+#include <linux/adb.h>
+#include <linux/cuda.h>
+#include <linux/pmu.h>
+#include <linux/suspend.h>
+#include <linux/delay.h>
+#include <linux/module.h>
+
+#include <asm/mmu_context.h>
+
+extern void enable_kernel_altivec(void);
+
+static inline void do_pmu_resume(void)
+{
+	struct adb_request req;
+
+	printk("resume pmu");
+	/* Tell PMU we are ready */
+	pmu_request(&req, NULL, 2, PMU_SYSTEM_READY, 2);
+	pmu_wait_complete(&req);
+
+	/* Resume PMU event interrupts */
+	pmu_resume();
+	printk(".\n");
+}
+
+void save_processor_state(void)
+{
+	printk("suspend pmu");
+	pmu_suspend();
+	printk(".\n");
+	printk("current is 0x%p\n", current);
+}
+
+void restore_processor_state(void)
+{
+	printk("seting context, 0x%p", current);
+	local_irq_disable();
+	/* Restore userland MMU context */
+	set_context(current->active_mm->context, current->active_mm->pgd);
+	printk(".\n");
+
+#ifdef CONFIG_ALTIVEC
+	if (cur_cpu_spec[0]->cpu_features & CPU_FTR_ALTIVEC)
+		enable_kernel_altivec();
+#endif
+	printk("enable kernel fp");
+	enable_kernel_fp();
+	printk(".\n");
+	do_pmu_resume();
+	local_irq_enable();
+}
+
+EXPORT_SYMBOL(save_processor_state);
+EXPORT_SYMBOL(restore_processor_state);
diff -puN /dev/null arch/ppc/power/cpu_reg.S
--- /dev/null	2004-05-31 17:36:38.000000000 -0400
+++ linux-2.6.7-xx2-xiphux/arch/ppc/power/cpu_reg.S	2004-06-24 07:14:54.495833840 -0400
@@ -0,0 +1,325 @@
+/*
+ * This code base on pmdisk.S by Benjamin Herrenschmidt <benh@kernel.crashing.org>
+ *
+ * changed for swsusp2 by Hu Gang <hugang@soulinfo.com>
+ */
+#include <linux/config.h>
+#include <linux/threads.h>
+#include <asm/processor.h>
+#include <asm/page.h>
+#include <asm/cputable.h>
+#include <asm/thread_info.h>
+#include <asm/ppc_asm.h>
+#include <asm/offsets.h>
+
+/*
+ * Structure for storing CPU registers on the save area.
+ */
+#define SL_SP		0
+#define SL_PC		4
+#define SL_MSR		8
+#define SL_SDR1		0xc
+#define SL_SPRG0	0x10	/* 4 sprg's */
+#define SL_DBAT0	0x20
+#define SL_IBAT0	0x28
+#define SL_DBAT1	0x30
+#define SL_IBAT1	0x38
+#define SL_DBAT2	0x40
+#define SL_IBAT2	0x48
+#define SL_DBAT3	0x50
+#define SL_IBAT3	0x58
+#define SL_TB		0x60
+#define SL_R2		0x68
+#define SL_CR		0x6c
+#define SL_LR		0x70
+#define SL_R12		0x74	/* r12 to r31 */
+#define SL_SIZE		(SL_R12 + 80)
+
+#define CPU_REG_MEM_DEFINE \
+	.section .data					  ; \
+	.align	5					  ; \
+\
+_GLOBAL(cpu_reg_save_area)				  ; \
+	.space	SL_SIZE
+
+#define CPU_REG_MEM_SAVE \
+	lis	r11,cpu_reg_save_area@h;\
+	ori	r11,r11,cpu_reg_save_area@l;\
+;\
+	mflr	r0					  ; \
+	stw	r0,SL_LR(r11);\
+	mfcr	r0;\
+	stw	r0,SL_CR(r11);\
+	stw	r1,SL_SP(r11);\
+	stw	r2,SL_R2(r11);\
+	stmw	r12,SL_R12(r11);\
+;\
+	/* Save MSR & SDR1 */;\
+	mfmsr	r4;\
+	stw	r4,SL_MSR(r11);\
+	mfsdr1	r4;\
+	stw	r4,SL_SDR1(r11);\
+;\
+	/* Get a stable timebase and save it */;\
+1:	mftbu	r4;\
+	stw	r4,SL_TB(r11);\
+	mftb	r5;\
+	stw	r5,SL_TB+4(r11);\
+	mftbu	r3;\
+	cmpw	r3,r4;\
+	bne	1b;\
+;\
+	/* Save SPRGs */;\
+	mfsprg	r4,0;\
+	stw	r4,SL_SPRG0(r11);\
+	mfsprg	r4,1;\
+	stw	r4,SL_SPRG0+4(r11);\
+	mfsprg	r4,2;\
+	stw	r4,SL_SPRG0+8(r11);\
+	mfsprg	r4,3;\
+	stw	r4,SL_SPRG0+12(r11);\
+;\
+	/* Save BATs */;\
+	mfdbatu	r4,0;\
+	stw	r4,SL_DBAT0(r11);\
+	mfdbatl	r4,0;\
+	stw	r4,SL_DBAT0+4(r11);\
+	mfdbatu	r4,1;\
+	stw	r4,SL_DBAT1(r11);\
+	mfdbatl	r4,1;\
+	stw	r4,SL_DBAT1+4(r11);\
+	mfdbatu	r4,2;\
+	stw	r4,SL_DBAT2(r11);\
+	mfdbatl	r4,2;\
+	stw	r4,SL_DBAT2+4(r11);\
+	mfdbatu	r4,3;\
+	stw	r4,SL_DBAT3(r11);\
+	mfdbatl	r4,3;\
+	stw	r4,SL_DBAT3+4(r11);\
+	mfibatu	r4,0;\
+	stw	r4,SL_IBAT0(r11);\
+	mfibatl	r4,0;\
+	stw	r4,SL_IBAT0+4(r11);\
+	mfibatu	r4,1;\
+	stw	r4,SL_IBAT1(r11);\
+	mfibatl	r4,1;\
+	stw	r4,SL_IBAT1+4(r11);\
+	mfibatu	r4,2;\
+	stw	r4,SL_IBAT2(r11);\
+	mfibatl	r4,2;\
+	stw	r4,SL_IBAT2+4(r11);\
+	mfibatu	r4,3;\
+	stw	r4,SL_IBAT3(r11);\
+	mfibatl	r4,3;\
+	stw	r4,SL_IBAT3+4(r11);\
+	/* Backup various CPU config stuffs */;\
+	/* bl	__save_cpu_setup; */
+
+#define CPU_REG_MEM_DISABLE_MMU \
+	/* Disable MSR:DR to make sure we don't take a TLB or	;\
+	 * hash miss during the copy, as our hash table will	;\
+	 * for a while be unuseable. For .text, we assume we are;\
+	 * covered by a BAT. This works only for non-G5 at this	;\
+	 * point. G5 will need a better approach, possibly using;\
+	 * a small temporary hash table filled with large mappings,;\
+	 * disabling the MMU completely isn't a good option for	;\
+	 * performance reasons.	;\
+	 * (Note that 750's may have the same performance issue as;\
+	 * the G5 in this case, we should investigate using moving;\
+	 * BATs for these CPUs);\
+	 */;\
+	mfmsr	r0	;\
+	sync	;\
+	rlwinm	r0,r0,0,28,26		/* clear MSR_DR */ ;\
+	mtmsr	r0 ;\
+	sync ;\
+	isync
+
+#define CPU_REG_MEM_FLUSH_CACHE \
+	/* Do a very simple cache flush/inval of the L1 to ensure \
+	 * coherency of the icache \
+	 */ \
+	lis	r3,0x0002 ;\
+	mtctr	r3 ;\
+	li	r3, 0 ;\
+1: ;\
+	lwz	r0,0(r3) ;\
+	addi	r3,r3,0x0020 ;\
+	bdnz	1b ;\
+	isync ;\
+	sync ;\
+;\
+	/* Now flush those cache lines */ ;\
+	lis	r3,0x0002 ;\
+	mtctr	r3 ;\
+	li	r3, 0 ;\
+1:;\
+	dcbf	0,r3 ;\
+	addi	r3,r3,0x0020 ;\
+	bdnz	1b
+
+#define CPU_REG_MEM_RESTORE \
+/* Ok, we are now running with the kernel data of the old;\
+	 * kernel fully restored. We can get to the save area;\
+	 * easily now. As for the rest of the code, it assumes the;\
+	 * loader kernel and the booted one are exactly identical;\
+	 */;\
+	lis	r11,cpu_reg_save_area@h;\
+	ori	r11,r11,cpu_reg_save_area@l;\
+	tophys(r11,r11);\
+	/* Restore various CPU config stuffs */;\
+	/* bl	__restore_cpu_setup; */\
+	/* Restore the BATs, and SDR1.  Then we can turn on the MMU. ;\
+	 * This is a bit hairy as we are running out of those BATs,;\
+	 * but first, our code is probably in the icache, and we are;\
+	 * writing the same value to the BAT, so that should be fine,;\
+	 * though a better solution will have to be found long-term;\
+	 */;\
+	lwz	r4,SL_SDR1(r11);\
+	mtsdr1	r4;\
+	lwz	r4,SL_SPRG0(r11);\
+	mtsprg	0,r4;\
+	lwz	r4,SL_SPRG0+4(r11);\
+	mtsprg	1,r4;\
+	lwz	r4,SL_SPRG0+8(r11);\
+	mtsprg	2,r4;\
+	lwz	r4,SL_SPRG0+12(r11);\
+	mtsprg	3,r4;\
+;\
+/*	lwz	r4,SL_DBAT0(r11);\
+	mtdbatu	0,r4;\
+	lwz	r4,SL_DBAT0+4(r11);\
+	mtdbatl	0,r4;\
+	lwz	r4,SL_DBAT1(r11);\
+	mtdbatu	1,r4;\
+	lwz	r4,SL_DBAT1+4(r11);\
+	mtdbatl	1,r4;\
+	lwz	r4,SL_DBAT2(r11);\
+	mtdbatu	2,r4;\
+	lwz	r4,SL_DBAT2+4(r11);\
+	mtdbatl	2,r4;\
+	lwz	r4,SL_DBAT3(r11);\
+	mtdbatu	3,r4;\
+	lwz	r4,SL_DBAT3+4(r11);\
+	mtdbatl	3,r4;\
+	lwz	r4,SL_IBAT0(r11);\
+	mtibatu	0,r4;\
+	lwz	r4,SL_IBAT0+4(r11);\
+	mtibatl	0,r4;\
+	lwz	r4,SL_IBAT1(r11);\
+	mtibatu	1,r4;\
+	lwz	r4,SL_IBAT1+4(r11);\
+	mtibatl	1,r4;\
+	lwz	r4,SL_IBAT2(r11);\
+	mtibatu	2,r4;\
+	lwz	r4,SL_IBAT2+4(r11);\
+	mtibatl	2,r4;\
+	lwz	r4,SL_IBAT3(r11);\
+	mtibatu	3,r4;\
+	lwz	r4,SL_IBAT3+4(r11);\
+	mtibatl	3,r4;\
+; */ \
+BEGIN_FTR_SECTION;\
+	li	r4,0;\
+	mtspr	SPRN_DBAT4U,r4;\
+	mtspr	SPRN_DBAT4L,r4;\
+	mtspr	SPRN_DBAT5U,r4;\
+	mtspr	SPRN_DBAT5L,r4;\
+	mtspr	SPRN_DBAT6U,r4;\
+	mtspr	SPRN_DBAT6L,r4;\
+	mtspr	SPRN_DBAT7U,r4;\
+	mtspr	SPRN_DBAT7L,r4;\
+	mtspr	SPRN_IBAT4U,r4;\
+	mtspr	SPRN_IBAT4L,r4;\
+	mtspr	SPRN_IBAT5U,r4;\
+	mtspr	SPRN_IBAT5L,r4;\
+	mtspr	SPRN_IBAT6U,r4;\
+	mtspr	SPRN_IBAT6L,r4;\
+	mtspr	SPRN_IBAT7U,r4;\
+	mtspr	SPRN_IBAT7L,r4;\
+END_FTR_SECTION_IFSET(CPU_FTR_HAS_HIGH_BATS);\
+;\
+	/* Flush all TLBs */;\
+	lis	r4,0x1000;\
+1:	addic.	r4,r4,-0x1000;\
+	tlbie	r4;\
+	blt	1b;\
+	sync;\
+;\
+	/* restore the MSR and turn on the MMU */;\
+	lwz	r3,SL_MSR(r11);\
+	bl	turn_on_mmu;\
+	tovirt(r11,r11);\
+;\
+	/* Restore TB */;\
+	li	r3,0;\
+	mttbl	r3;\
+	lwz	r3,SL_TB(r11);\
+	lwz	r4,SL_TB+4(r11);\
+	mttbu	r3;\
+	mttbl	r4;\
+; \
+	lwz	r0,SL_CR(r11);\
+	mtcr	r0;\
+	lwz	r2,SL_R2(r11);\
+	lmw	r12,SL_R12(r11);\
+	lwz	r1,SL_SP(r11);\
+	lwz	r4,SL_LR(r11)
+
+#define CPU_REG_MEM_RESTORE_END \
+	/* Restore LR from the save area */		  ; \
+	lis	r11,cpu_reg_save_area@h			  ; \
+	ori	r11,r11,cpu_reg_save_area@l		  ; \
+	lwz	r0,SL_CR(r11)				  ; \
+	mtcr r0					  ; \
+	lwz	r2,SL_R2(r11)				  ; \
+	lmw	r12,SL_R12(r11)				  ; \
+	lwz	r1,SL_SP(r11)
+
+#define CPU_REG_TURN_ON_MMU \
+/* FIXME:This construct is actually not useful since we don't shut ; \
+ * down the instruction MMU, we could just flip back MSR-DR on.	; \
+ */							  ; \
+turn_on_mmu:						  ; \
+	mflr	r4					  ; \
+	mtsrr0	r4					  ; \
+	mtsrr1	r3					  ; \
+	sync						  ; \
+	isync						  ; \
+	rfi
+
+#define CPU_REG_STACK_SAVE \
+	mflr	r0					  ; \
+	stw	r0,4(r1)				  ; \
+	stwu	r1,-SL_SIZE(r1)				  ; \
+	mfcr	r0					  ; \
+	stw	r0,SL_CR(r1)				  ; \
+	stw	r2,SL_R2(r1)				  ; \
+	stmw	r12,SL_R12(r1)				  ; \
+	/* Save SPRGs */				  ; \
+	mfsprg	r4,0					  ; \
+	stw	r4,SL_SPRG0(r1)				  ; \
+	mfsprg	r4,1					  ; \
+	stw	r4,SL_SPRG0+4(r1)			  ; \
+	mfsprg	r4,2					  ; \
+	stw	r4,SL_SPRG0+8(r1)			  ; \
+	mfsprg	r4,3					  ; \
+	stw	r4,SL_SPRG0+12(r1)
+
+#define CPU_REG_STACK_RESTORE \
+	lwz	r4,SL_SPRG0(r1)				  ; \
+	mtsprg	0,r4					  ; \
+	lwz	r4,SL_SPRG0+4(r1)			  ; \
+	mtsprg	1,r4					  ; \
+	lwz	r4,SL_SPRG0+8(r1)			  ; \
+	mtsprg	2,r4					  ; \
+	lwz	r4,SL_SPRG0+12(r1)			  ; \
+	mtsprg	3,r4					  ; \
+	lwz	r0,SL_CR(r1)				  ; \
+	mtcr	r0					  ; \
+	lwz	r2,SL_R2(r1)				  ; \
+	lmw	r12,SL_R12(r1)				  ; \
+	addi	r1,r1,SL_SIZE				  ; \
+	lwz	r0,4(r1)				  ; \
+	mtlr	r0					  ; \
+	blr
diff -puN /dev/null arch/ppc/power/swsusp2-asm.S
--- /dev/null	2004-05-31 17:36:38.000000000 -0400
+++ linux-2.6.7-xx2-xiphux/arch/ppc/power/swsusp2-asm.S	2004-06-24 07:14:54.496833688 -0400
@@ -0,0 +1,53 @@
+/*
+ * This code base on pmdisk.S by Benjamin Herrenschmidt <benh@kernel.crashing.org>
+ *
+ * changed for swsusp2 by Hu Gang <hugang@soulinfo.com>
+ */
+#include <linux/config.h>
+#include <asm/processor.h>
+#include <asm/page.h>
+#include <asm/ppc_asm.h>
+#include <asm/cputable.h>
+#include <asm/cache.h>
+#include <asm/thread_info.h>
+#include <asm/offsets.h>
+#include "cpu_reg.S"
+
+	CPU_REG_MEM_DEFINE
+
+	.section .text
+	.align 5
+_GLOBAL(do_suspend2_lowlevel)
+	CPU_REG_STACK_SAVE
+	cmpwi	0,r3,0
+	bne	do_resume
+	bl	save_processor_state
+	bl	do_suspend2_suspend_1
+	CPU_REG_MEM_SAVE
+	bl	do_suspend2_suspend_2
+	CPU_REG_MEM_RESTORE_END
+	CPU_REG_STACK_RESTORE
+
+do_resume:
+	bl save_processor_state
+	bl do_suspend2_resume_1
+
+	/* Stop pending alitvec streams and memory accesses */
+BEGIN_FTR_SECTION
+	DSSALL
+END_FTR_SECTION_IFSET(CPU_FTR_ALTIVEC)
+ 	sync
+
+	CPU_REG_MEM_DISABLE_MMU
+#include "swsusp2-copyback.S"
+	CPU_REG_MEM_FLUSH_CACHE
+
+	CPU_REG_MEM_RESTORE
+	bl	do_suspend2_resume_2
+	bl	restore_processor_state
+	CPU_REG_MEM_RESTORE_END
+	CPU_REG_STACK_RESTORE
+
+	CPU_REG_TURN_ON_MMU
+
+	.section .text
diff -puN /dev/null arch/ppc/power/swsusp2-copyback.S
--- /dev/null	2004-05-31 17:36:38.000000000 -0400
+++ linux-2.6.7-xx2-xiphux/arch/ppc/power/swsusp2-copyback.S	2004-06-24 07:14:54.497833536 -0400
@@ -0,0 +1,73 @@
+#define PAGE_TO_POINTER(in, out, p)	\
+	lwz out,0(in)					  ; \
+	slwi r9,out,2					  ; \
+	add r9,r9,out					  ; \
+	slwi r9,r9,3					  ; \
+	mullw r9,r9,r4					  ; \
+	slwi r9,r9,9					  ; \
+	addis p,r9,0xc000				  ; \
+	tophys(p,p)
+
+	.section ".text"
+swsusp2_copyback:
+	lis r20,pagedir_resume@ha	/* can't ture this is right FIXME */
+	addi r20,r20,pagedir_resume@l
+	tophys(r20,r20)
+#if 0
+	lwz	r4,4(r20)
+	twi	31,r0,0	/* triger trap */
+#endif
+	lis r4,0xcccc /* FIXME */
+	ori r4,r4,52429
+
+	lwz r6,12(r20)		/* r6 is origranges.first */
+	cmpwi r6,0
+	beq- swsusp2_end_copyback
+
+	tophys(r6,r6)
+	PAGE_TO_POINTER(r6,r8,r10)
+
+	lwz r5,56(r20)		/* r5 is copyranges.first */
+	tophys(r5,r5)
+	PAGE_TO_POINTER(r5,r7,r11)
+
+swsusp2_copy_one_page:
+	li r0,1024		/* r9 is loop */
+	mtctr r0		/* prepare for branch */
+	li r9,0
+swsusp2_copy_data:
+	lwzx r0,r9,r11
+	stwx r0,r9,r10
+	addi r9,r9,4
+
+	bdnz swsusp2_copy_data
+
+	lwz r0,4(r6)					  /* r0 is maximum */
+	cmplw r8,r0
+	bge- next_orig
+	addi r8,r8,1
+	addi r10,r10,4096
+	b end_orig
+next_orig:
+	lwz r6,8(r6)	/* r6 origrange */
+	cmpwi r6,0
+	beq- end_orig
+	tophys(r6,r6)
+	PAGE_TO_POINTER(r6,r8,r10)
+end_orig:
+	lwz r0,4(r5)					  /* r0 is maximum */
+	cmplw r7,r0
+	bge- next_copy
+	addi r7,r7,1
+	addi r11,r11,4096
+	b end_copy
+next_copy:
+	lwz r5,8(r5)	/* r5 is copypage */
+	cmpwi r5,0
+	beq- end_copy
+	tophys(r5,r5)
+	PAGE_TO_POINTER(r5,r7,r11)
+end_copy:
+	cmpwi 0,r6,0
+	bc r4,r2,swsusp2_copy_one_page
+swsusp2_end_copyback:
diff -puN /dev/null arch/ppc/power/swsusp2.c
--- /dev/null	2004-05-31 17:36:38.000000000 -0400
+++ linux-2.6.7-xx2-xiphux/arch/ppc/power/swsusp2.c	2004-06-24 07:14:54.498833384 -0400
@@ -0,0 +1,170 @@
+ /*
+  * Copyright 2003 Nigel Cunningham.
+  *
+  * This is the code that the code in swsusp2-asm.S for
+  * copying back the original kernel is based upon. It
+  * was based upon code that is...
+  * Copyright 2001-2002 Pavel Machek <pavel@suse.cz>
+  * Based on code
+  * Copyright 2001 Patrick Mochel <mochel@osdl.org>
+  * Copyright 2004 Hu Gang <hugang@soulinfo.com
+  *  port to PowerPC
+  */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/spinlock.h>
+#include <linux/poll.h>
+#include <linux/delay.h>
+#include <linux/sysrq.h>
+#include <linux/proc_fs.h>
+#include <linux/irq.h>
+#include <linux/pm.h>
+#include <linux/device.h>
+#include <linux/suspend.h>
+#include <linux/suspend-debug.h>
+#include <linux/suspend-common.h>
+#include <asm/uaccess.h>
+#if 0
+/* Local variables for do_swsusp2_suspend */
+volatile static int state1 __nosavedata = 0;
+volatile static int state2 __nosavedata = 0;
+volatile static int state3 __nosavedata = 0;
+volatile static int loop __nosavedata = 0;
+volatile static struct range *origrange __nosavedata;
+volatile static struct range *copyrange __nosavedata;
+volatile static int origoffset __nosavedata;
+volatile static int copyoffset __nosavedata;
+volatile static unsigned long * origpage __nosavedata;
+volatile static unsigned long * copypage __nosavedata;
+#endif
+
+//volatile static int orig_min_free __nosavedata;
+#ifndef CONFIG_SMP
+//static unsigned long c_loops_per_jiffy_ref __nosavedata = 0;
+//static unsigned long cpu_khz_ref __nosavedata = 0;
+#endif
+
+extern void do_swsusp2_suspend_1(void);
+extern void do_swsusp2_suspend_2(void);
+extern void do_swsusp2_resume_1(void);
+extern void do_swsusp2_resume_2(void);
+extern struct pagedir __nosavedata pagedir_resume;
+
+/*
+ * FIXME: This function should really be written in assembly. Actually
+ * requirement is that it does not touch stack, because %esp will be
+ * wrong during resume before restore_processor_context(). Check
+ * assembly if you modify this.
+ */
+#if 0
+static inline void pre_copyback(void)
+{
+#ifdef CONFIG_PREEMPT
+	/*
+	 * Preempt disabled in kernel we're about to restore.
+	 * Make sure we match state now.
+	 */
+	preempt_disable();
+	PRINTPREEMPTCOUNT("Prior to copying old kernel back.");
+#endif
+
+	state1 = swsusp_action;
+	state2 = swsusp_debug_state;
+	state3 = console_loglevel;
+
+#ifndef CONFIG_SMP
+	//c_loops_per_jiffy_ref = cpu_data->loops_per_jiffy;
+	//cpu_khz_ref = cpu_khz;
+#endif
+}
+static inline void post_copyback(void)
+{
+#ifndef CONFIG_SMP
+	//cpu_data->loops_per_jiffy = c_loops_per_jiffy_ref;
+	//loops_per_jiffy = c_loops_per_jiffy_ref;
+	//cpu_khz = cpu_khz_ref;
+#endif
+	swsusp_action = state1;
+	swsusp_debug_state = state2;
+	console_loglevel = state3;
+	//swsusp_min_free = orig_min_free;
+
+}
+#endif
+static inline void do_swsusp2_copyback(void)
+{
+	/* PowerPC has a lots register, use local register is possible */
+	register int origoffset, copyoffset;
+	register unsigned long * origpage, * copypage;
+	register struct range *origrange, *copyrange;
+//	register int pagesize;
+
+//	pre_copyback();
+
+	origrange = pagedir_resume.origranges.first;
+//	pagesize = pagedir_resume.pageset_size;
+//	printk("%d\n", pagesize);
+	origoffset = origrange->minimum;
+	origpage = (unsigned long *) (page_address(mem_map + origoffset));
+
+	copyrange = pagedir_resume.destranges.first;
+	copyoffset = copyrange->minimum;
+	copypage = (unsigned long *) (page_address(mem_map + copyoffset));
+	//orig_min_free = swsusp_min_free;
+
+	while (origrange) {
+		register int loop;
+		for (loop = 0; loop < (PAGE_SIZE / sizeof(unsigned long)); loop++)
+			*(origpage + loop) = *(copypage + loop);
+
+		if (origoffset < origrange->maximum) {
+			origoffset++;
+			origpage += (PAGE_SIZE / sizeof(unsigned long));
+		} else {
+			origrange = origrange->next;
+			if (origrange) {
+				origoffset = origrange->minimum;
+				origpage = (unsigned long *) (page_address(mem_map + origoffset));
+			}
+		}
+
+		if (copyoffset < copyrange->maximum) {
+			copyoffset++;
+			copypage += (PAGE_SIZE / sizeof(unsigned long));
+		} else {
+			copyrange = copyrange->next;
+			if (copyrange) {
+				copyoffset = copyrange->minimum;
+				copypage = (unsigned long *) (page_address(mem_map + copyoffset));
+			}
+		}
+	}
+
+/* Ahah, we now run with our old stack, and with registers copied from
+   suspend time */
+
+//	post_copyback();
+}
+
+void do_swsusp_lowlevel(int resume)
+{
+	if (!resume) {
+		do_swsusp2_suspend_1();
+		save_processor_state();
+		/* saving stack */
+
+		do_swsusp2_suspend_2();
+		return;
+	}
+
+	/* setup swapper_pg_dir in x86 */
+
+	do_swsusp2_resume_1();
+	do_swsusp2_copyback();
+	/* setup segment register */
+	restore_processor_state();
+	do_swsusp2_resume_2();
+}
diff -puN drivers/acpi/osl.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/acpi/osl.c
--- linux-2.6.7-xx2/drivers/acpi/osl.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.859930512 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/acpi/osl.c	2004-06-24 07:14:54.499833232 -0400
@@ -82,7 +82,7 @@ acpi_os_initialize(void)
 		return AE_NULL_ENTRY;
 	}
 #endif
-	kacpid_wq = create_singlethread_workqueue("kacpid");
+	kacpid_wq = create_singlethread_workqueue("kacpid", 0);
 	BUG_ON(!kacpid_wq);
 
 	return AE_OK;
diff -puN drivers/acpi/sleep/proc.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/acpi/sleep/proc.c
--- linux-2.6.7-xx2/drivers/acpi/sleep/proc.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.864929752 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/acpi/sleep/proc.c	2004-06-24 07:14:54.501832928 -0400
@@ -1,7 +1,9 @@
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
 #include <linux/suspend.h>
+#include <linux/sched.h>
 #include <linux/bcd.h>
+#include <linux/init.h>
 #include <asm/uaccess.h>
 
 #include <acpi/acpi_bus.h>
@@ -54,6 +56,9 @@ acpi_system_write_sleep (
 	char	str[12];
 	u32	state = 0;
 	int	error = 0;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_PAUSING;
 
 	if (count > sizeof(str) - 1)
 		goto Done;
@@ -61,6 +66,7 @@ acpi_system_write_sleep (
 	if (copy_from_user(str, buffer, count))
 		return -EFAULT;
 
+
 	/* Check for S4 bios request */
 	if (!strcmp(str,"4b")) {
 		error = acpi_suspend(4);
@@ -73,8 +79,15 @@ acpi_system_write_sleep (
 		goto Done;
 	}
 #endif
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+	if (state == 4) {
+		software_suspend_pending();
+		goto Done;
+	}
+#endif
 	error = acpi_suspend(state);
  Done:
+	SWSUSP_ACTIVITY_RESTARTING(0);
 	return error ? error : count;
 }
 
diff -puN drivers/base/power/resume.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/base/power/resume.c
--- linux-2.6.7-xx2/drivers/base/power/resume.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.867929296 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/base/power/resume.c	2004-06-24 07:14:54.522829736 -0400
@@ -97,6 +97,59 @@ void device_power_up(void)
 	dpm_power_up();
 }
 
+
+#if 0
+
+/**
+ *
+ * 	pci_find_class_storage
+ *
+ *	Find a PCI storage device.
+ *	Based upon pci_find_class, but less strict.
+ */
+
+static struct pci_dev *
+pci_find_class_storage(unsigned int class, const struct pci_dev *from)
+{
+	struct list_head *n;
+	struct pci_dev *dev;
+
+	spin_lock(&pci_bus_lock);
+	n = from ? from->global_list.next : pci_devices.next;
+
+	while (n && (n != &pci_devices)) {
+		dev = pci_dev_g(n);
+		if (((dev->class & 0xff00) >> 16) == class)
+			goto exit;
+		n = n->next;
+	}
+	dev = NULL;
+exit:
+	spin_unlock(&pci_bus_lock);
+	return dev;
+}
+
+
+/**
+ *	device_resume_type - Resume some devices.
+ *
+ *	Resume devices of a specific type and their parents.
+ *	Interrupts must be disabled when calling this.
+ *
+ *	Note that we only handle pci devices at the moment.
+ *	We have no way that I can tell of getting the class
+ *	of devices not on the pci bus.
+ */
+void device_resume_type(type)
+{
+	struct device * dev_dev;
+	struct pci_dev * pci_dev = NULL;
+
+	while ((dev = pci_find_class(PCI_BASE_CLASS_STORAGE, dev))) {
+	}
+}
+#endif
+
 EXPORT_SYMBOL(device_power_up);
 
 
diff -puN drivers/block/ll_rw_blk.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/block/ll_rw_blk.c
--- linux-2.6.7-xx2/drivers/block/ll_rw_blk.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.871928688 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/block/ll_rw_blk.c	2004-06-24 07:14:54.530828520 -0400
@@ -3092,7 +3092,7 @@ void kblockd_flush(void)
 
 int __init blk_dev_init(void)
 {
-	kblockd_workqueue = create_workqueue("kblockd");
+	kblockd_workqueue = create_workqueue("kblockd", PF_NOFREEZE);
 	if (!kblockd_workqueue)
 		panic("Failed to create kblockd\n");
 
diff -puN drivers/block/loop.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/block/loop.c
--- linux-2.6.7-xx2/drivers/block/loop.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.876927928 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/block/loop.c	2004-06-24 07:14:54.533828064 -0400
@@ -63,7 +63,6 @@
 #include <linux/swap.h>
 #include <linux/slab.h>
 #include <linux/loop.h>
-#include <linux/suspend.h>
 #include <linux/writeback.h>
 #include <linux/buffer_head.h>		/* for invalidate_bdev() */
 #include <linux/completion.h>
diff -puN drivers/char/hvc_console.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/char/hvc_console.c
--- linux-2.6.7-xx2/drivers/char/hvc_console.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.880927320 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/char/hvc_console.c	2004-06-24 07:14:54.535827760 -0400
@@ -26,6 +26,7 @@
 #include <linux/tty.h>
 #include <linux/tty_flip.h>
 #include <linux/sched.h>
+#include <linux/suspend.h>
 #include <linux/kbd_kern.h>
 #include <asm/uaccess.h>
 #include <linux/spinlock.h>
@@ -268,16 +269,21 @@ static const cpumask_t cpus_in_xmon = CP
 int khvcd(void *unused)
 {
 	int i;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	daemonize("khvcd");
+	SWSUSP_THREAD_FLAGS_RESET;
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
 
 	for (;;) {
 		if (cpus_empty(cpus_in_xmon)) {
 			for (i = 0; i < MAX_NR_HVC_CONSOLES; ++i)
 				hvc_poll(i);
 		}
+		SWSUSP_ACTIVITY_PAUSING;
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout(TIMEOUT);
+		SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 	}
 }
 
diff -puN drivers/char/keyboard.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/char/keyboard.c
--- linux-2.6.7-xx2/drivers/char/keyboard.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.882927016 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/char/keyboard.c	2004-06-24 07:14:54.537827456 -0400
@@ -33,6 +33,7 @@
 #include <linux/string.h>
 #include <linux/random.h>
 #include <linux/init.h>
+#include <linux/completion.h>
 #include <linux/slab.h>
 
 #include <linux/kbd_kern.h>
@@ -41,9 +42,15 @@
 #include <linux/sysrq.h>
 #include <linux/input.h>
 
+#include <linux/suspend.h>
+
 static void kbd_disconnect(struct input_handle *handle);
 extern void ctrl_alt_del(void);
 
+#ifdef CONFIG_PM
+extern void wakeup_suspend(void);
+#endif
+
 /*
  * Exported functions/variables
  */
@@ -1092,6 +1099,141 @@ void kbd_keycode(unsigned int keycode, i
 		return;
 	}
 #endif
+#ifdef CONFIG_PM
+	if (down && (software_suspend_state & SOFTWARE_SUSPEND_RUNNING)) {
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+		extern void prepare_status(int printalways, int clearbar, const char *fmt, ...);
+		extern unsigned long suspend_action;
+		extern void request_abort_suspend(void);
+		extern void machine_restart(char * __unused);
+		if (software_suspend_state & SOFTWARE_SUSPEND_SANITY_CHECK_PROMPT) {
+			if (keycode == 57)
+				wakeup_suspend();
+			else if (keycode == 46) {
+				software_suspend_state |= SOFTWARE_SUSPEND_CONTINUE_REQ;
+				wakeup_suspend();
+			}
+			return;
+		}
+		switch (keycode) {
+			case 1:
+				/* Abort suspend */
+				request_abort_suspend();
+				wakeup_suspend();
+				break;
+			case 2:
+				console_loglevel = 1;
+				wakeup_suspend();
+				break;
+			case 11:
+				console_loglevel = 0;
+				wakeup_suspend();
+				break;
+			case 19:
+				/* Otherwise, if R pressed, toggle rebooting */
+				suspend_action ^= (1 << SUSPEND_REBOOT);
+				schedule_suspend_message(2);
+				wakeup_suspend();
+				break;
+#ifdef CONFIG_SOFTWARE_SUSPEND_DEBUG
+			case 41:
+				/* `: Toggle slow */
+				suspend_action ^= (1 << SUSPEND_SLOW);
+				schedule_suspend_message(7);
+				wakeup_suspend();
+				break;
+			case 59:
+				/* F1: Toggle any section debugging. */
+				suspend_debug_state ^= (1 << SUSPEND_ANY_SECTION);
+				schedule_suspend_message(20);
+				wakeup_suspend();
+				break;
+			case 60:
+				/* F2: Freeze. */
+				suspend_debug_state ^= (1 << SUSPEND_FREEZER);
+				schedule_suspend_message(21);
+				wakeup_suspend();
+				break;
+			case 61:
+				/* F3: Eat Memory */
+				suspend_debug_state ^= (1 << SUSPEND_EAT_MEMORY);
+				schedule_suspend_message(22);
+				wakeup_suspend();
+				break;
+			case 62:
+				/* F4: Pagesets. */
+				suspend_debug_state ^= (1 << SUSPEND_PAGESETS);
+				schedule_suspend_message(23);
+				wakeup_suspend();
+				break;
+			case 63:
+				/* F5: IO. */
+				suspend_debug_state ^= (1 << SUSPEND_IO);
+				schedule_suspend_message(24);
+				wakeup_suspend();
+				break;
+			case 64:
+				/* F6: Bmapping of pages */
+				suspend_debug_state ^= (1 << SUSPEND_BMAP);
+				schedule_suspend_message(25);
+				wakeup_suspend();
+				break;
+			case 65:
+				/* F7: Swap */
+				suspend_debug_state ^= (1 << SUSPEND_SWAP);
+				schedule_suspend_message(26);
+				wakeup_suspend();
+				break;
+			case 66:
+				/* F8: Ranges */
+				suspend_debug_state ^= (1 << SUSPEND_RANGES);
+				schedule_suspend_message(27);
+				wakeup_suspend();
+				break;
+			case 67:
+				/* F9: Memory Pool */
+				suspend_debug_state ^= (1 << SUSPEND_MEM_POOL);
+				schedule_suspend_message(28);
+				wakeup_suspend();
+				break;
+			case 25:
+				/* During suspend, toggle pausing with P */
+				suspend_action ^= (1 << SUSPEND_PAUSE);
+				schedule_suspend_message(1);
+				wakeup_suspend();
+				break;
+			case 31:
+				/* Otherwise, if S pressed, toggle single step */
+				suspend_action ^= (1 << SUSPEND_SINGLESTEP);
+				schedule_suspend_message(3);
+				wakeup_suspend();
+				break;
+			case 38:
+				/* Otherwise, if L pressed, toggle logging everything */
+				suspend_action ^= (1 << SUSPEND_LOGALL);
+				schedule_suspend_message(4);
+				wakeup_suspend();
+				break;
+			case 3:
+			case 4:
+			case 5:
+			case 6:
+			case 7:
+			case 8:
+			case 9:
+			case 10:
+				console_loglevel = ((keycode - 1));
+				wakeup_suspend();
+				break;
+#endif
+		}
+#endif
+		if (keycode == 57)
+			wakeup_suspend();
+
+		return;
+	}
+#endif
 #if defined(CONFIG_SPARC32) || defined(CONFIG_SPARC64)
 	if (keycode == KEY_A && sparc_l1_a_state) {
 		sparc_l1_a_state = 0;
diff -puN drivers/char/n_tty.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/char/n_tty.c
--- linux-2.6.7-xx2/drivers/char/n_tty.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.886926408 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/char/n_tty.c	2004-06-24 07:14:54.539827152 -0400
@@ -36,6 +36,7 @@
 #include <linux/signal.h>
 #include <linux/fcntl.h>
 #include <linux/sched.h>
+#include <linux/suspend.h>
 #include <linux/interrupt.h>
 #include <linux/tty.h>
 #include <linux/timer.h>
@@ -1201,6 +1202,7 @@ static ssize_t write_chan(struct tty_str
 	DECLARE_WAITQUEUE(wait, current);
 	int c;
 	ssize_t retval = 0;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	/* Job control check -- must be done at start (POSIX.1 7.1.1.4). */
 	if (L_TOSTOP(tty) && file->f_op->write != redirected_tty_write) {
@@ -1255,7 +1257,9 @@ static ssize_t write_chan(struct tty_str
 			retval = -EAGAIN;
 			break;
 		}
+		SWSUSP_ACTIVITY_PAUSING;
 		schedule();
+		SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 	}
 break_out:
 	__set_current_state(TASK_RUNNING);
diff -puN drivers/char/tty_io.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/char/tty_io.c
--- linux-2.6.7-xx2/drivers/char/tty_io.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.889925952 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/char/tty_io.c	2004-06-24 07:14:54.542826696 -0400
@@ -92,6 +92,7 @@
 #include <linux/smp_lock.h>
 #include <linux/device.h>
 #include <linux/idr.h>
+#include <linux/suspend.h>
 
 #include <asm/uaccess.h>
 #include <asm/system.h>
@@ -639,6 +640,7 @@ static ssize_t tty_read(struct file * fi
 	int i;
 	struct tty_struct * tty;
 	struct inode *inode;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	/* Can't seek (pread) on ttys.  */
 	if (ppos != &file->f_pos)
@@ -651,6 +653,7 @@ static ssize_t tty_read(struct file * fi
 	if (!tty || (test_bit(TTY_IO_ERROR, &tty->flags)))
 		return -EIO;
 
+	SWSUSP_ACTIVITY_PAUSING;
 	lock_kernel();
 	if (tty->ldisc.read)
 		i = (tty->ldisc.read)(tty,file,buf,count);
@@ -659,6 +662,7 @@ static ssize_t tty_read(struct file * fi
 	unlock_kernel();
 	if (i > 0)
 		inode->i_atime = CURRENT_TIME;
+	SWSUSP_ACTIVITY_RESTARTING(0);
 	return i;
 }
 
@@ -674,10 +678,14 @@ static inline ssize_t do_tty_write(
 	size_t count)
 {
 	ssize_t ret = 0, written = 0;
+ 	DECLARE_SWSUSP_LOCAL_VAR;
 	
-	if (down_interruptible(&tty->atomic_write)) {
+	SWSUSP_ACTIVITY_PAUSING;
+	ret = down_interruptible(&tty->atomic_write);
+	SWSUSP_ACTIVITY_RESTARTING(0);
+	if (ret)
 		return -ERESTARTSYS;
-	}
+
 	if ( test_bit(TTY_NO_WRITE_SPLIT, &tty->flags) ) {
 		lock_kernel();
 		written = write(tty, file, buf, count);
@@ -700,7 +708,9 @@ static inline ssize_t do_tty_write(
 			ret = -ERESTARTSYS;
 			if (signal_pending(current))
 				break;
+	 		SWSUSP_ACTIVITY_PAUSING;
 			cond_resched();
+			SWSUSP_ACTIVITY_RESTARTING(0);
 		}
 	}
 	if (written) {
diff -puN drivers/char/vt.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/char/vt.c
--- linux-2.6.7-xx2/drivers/char/vt.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.894925192 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/char/vt.c	2004-06-24 07:14:54.547825936 -0400
@@ -150,11 +150,11 @@ static void vc_init(unsigned int console
 		    unsigned int cols, int do_clear);
 static void gotoxy(int currcons, int new_x, int new_y);
 static void save_cur(int currcons);
-static void reset_terminal(int currcons, int do_clear);
+void reset_terminal(int currcons, int do_clear);
 static void con_flush_chars(struct tty_struct *tty);
 static void set_vesa_blanking(char __user *p);
 static void set_cursor(int currcons);
-static void hide_cursor(int currcons);
+void hide_cursor(int currcons);
 static void console_callback(void *ignored);
 static void blank_screen_t(unsigned long dummy);
 
@@ -552,7 +552,7 @@ static void hide_softcursor(int currcons
 	}
 }
 
-static void hide_cursor(int currcons)
+void hide_cursor(int currcons)
 {
 	if (currcons == sel_cons)
 		clear_selection();
@@ -885,7 +885,7 @@ int default_blu[] = {0x00,0x00,0x00,0x00
  */
 static void gotoxy(int currcons, int new_x, int new_y)
 {
-	int min_y, max_y;
+	unsigned int min_y, max_y;
 
 	if (new_x < 0)
 		x = 0;
@@ -912,7 +912,7 @@ static void gotoxy(int currcons, int new
 }
 
 /* for absolute user moves, when decom is set */
-static void gotoxay(int currcons, int new_x, int new_y)
+static void gotoxay(int currcons, unsigned int new_x, unsigned int new_y)
 {
 	gotoxy(currcons, new_x, decom ? (top+new_y) : new_y);
 }
@@ -1427,7 +1427,7 @@ enum { ESnormal, ESesc, ESsquare, ESgetp
 	ESpalette };
 
 /* console_sem is held (except via vc_init()) */
-static void reset_terminal(int currcons, int do_clear)
+void reset_terminal(int currcons, int do_clear)
 {
 	top		= 0;
 	bottom		= video_num_lines;
@@ -1921,7 +1921,7 @@ static int do_con_write(struct tty_struc
 again:
 		if (count > CON_BUF_SIZE)
 			count = CON_BUF_SIZE;
-		console_conditional_schedule();
+		//console_conditional_schedule();
 		if (copy_from_user(con_buf, buf, count)) {
 			n = 0; /* ?? are error codes legal here ?? */
 			goto out;
@@ -2062,7 +2062,7 @@ again:
 		do_con_trol(tty, currcons, c);
 	}
 	FLUSH
-	console_conditional_schedule();
+	//console_conditional_schedule();
 	release_console_sem();
 
 out:
diff -puN drivers/ide/ide.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/ide/ide.c
--- linux-2.6.7-xx2/drivers/ide/ide.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.900924280 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/ide/ide.c	2004-06-24 07:14:54.552825176 -0400
@@ -2258,6 +2258,11 @@ static int ide_drive_remove(struct devic
 	return 0;
 }
 
+static void ide_drive_shutdown (struct device * dev)
+{
+	generic_ide_suspend(dev, 5);
+}
+
 int ide_register_driver(ide_driver_t *driver)
 {
 	struct list_head list;
@@ -2284,6 +2289,7 @@ int ide_register_driver(ide_driver_t *dr
 	driver->gen_driver.name = (char *) driver->name;
 	driver->gen_driver.bus = &ide_bus_type;
 	driver->gen_driver.remove = ide_drive_remove;
+	driver->gen_driver.shutdown = ide_drive_shutdown;
 	return driver_register(&driver->gen_driver);
 }
 
diff -puN drivers/ieee1394/nodemgr.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/ieee1394/nodemgr.c
--- linux-2.6.7-xx2/drivers/ieee1394/nodemgr.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.903923824 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/ieee1394/nodemgr.c	2004-06-24 07:14:54.555824720 -0400
@@ -18,6 +18,7 @@
 #include <linux/completion.h>
 #include <linux/delay.h>
 #include <linux/pci.h>
+#include <linux/suspend.h>
 #include <linux/moduleparam.h>
 #include <linux/suspend.h>
 #include <asm/atomic.h>
@@ -1466,10 +1467,13 @@ static int nodemgr_host_thread(void *__h
 	struct host_info *hi = (struct host_info *)__hi;
 	struct hpsb_host *host = hi->host;
 	int reset_cycles = 0;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	/* No userlevel access needed */
 	daemonize(hi->daemon_name);
 
+	SWSUSP_THREAD_FLAGS_RESET;
+
 	/* Setup our device-model entries */
 	nodemgr_create_host_dev_files(host);
 
@@ -1498,7 +1502,11 @@ static int nodemgr_host_thread(void *__h
 			set_current_state(TASK_INTERRUPTIBLE);
 			if (schedule_timeout(HZ/16)) {
 				up(&nodemgr_serialize);
-				goto caught_signal;
+				/* don't exit if it's a freezer sig */
+				SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
+				SWSUSP_ACTIVITY_END;
+				if (signal_pending(current))
+					goto caught_signal;
 			}
 
 			/* Now get the generation in which the node ID's we collect
@@ -1539,12 +1547,14 @@ static int nodemgr_host_thread(void *__h
 
 		/* This actually does the full probe, with sysfs
 		 * registration. */
+		SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
 		nodemgr_node_probe(hi, generation);
 
 		/* Update some of our sysfs symlinks */
 		nodemgr_update_host_dev_links(host);
 
 		up(&nodemgr_serialize);
+		SWSUSP_ACTIVITY_END;
 	}
 
 caught_signal:
diff -puN drivers/input/serio/serio.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/input/serio/serio.c
--- linux-2.6.7-xx2/drivers/input/serio/serio.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.906923368 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/input/serio/serio.c	2004-06-24 07:14:54.556824568 -0400
@@ -218,20 +218,26 @@ static void serio_remove_pending_events(
 
 static int serio_thread(void *nothing)
 {
+	DECLARE_SWSUSP_LOCAL_VAR;
+
 	lock_kernel();
 	daemonize("kseriod");
 	allow_signal(SIGTERM);
 
+	SWSUSP_THREAD_FLAGS_RESET;
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
+
 	do {
 		serio_handle_events();
+		SWSUSP_ACTIVITY_PAUSING;
 		wait_event_interruptible(serio_wait, !list_empty(&serio_event_list));
-		if (current->flags & PF_FREEZE)
-			refrigerator(PF_FREEZE);
+		SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 	} while (!signal_pending(current));
 
 	printk(KERN_DEBUG "serio: kseriod exiting\n");
 
 	unlock_kernel();
+	SWSUSP_ACTIVITY_END;
 	complete_and_exit(&serio_exited, 0);
 }
 
diff -puN drivers/macintosh/Kconfig~20-software-suspend-linux-2.6.7-rev1-whole drivers/macintosh/Kconfig
--- linux-2.6.7-xx2/drivers/macintosh/Kconfig~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.933919264 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/macintosh/Kconfig	2004-06-24 07:14:54.558824264 -0400
@@ -194,4 +194,8 @@ config ANSLCD
 	bool "Support for ANS LCD display"
 	depends on ADB_CUDA && PPC_PMAC
 
+config SOFTWARE_REPLACE_SLEEP
+	bool "Using Software suspend replace broken sleep function"
+	depends on SOFTWARE_SUSPEND2
+
 endmenu
diff -puN drivers/macintosh/via-pmu.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/macintosh/via-pmu.c
--- linux-2.6.7-xx2/drivers/macintosh/via-pmu.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.935918960 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/macintosh/via-pmu.c	2004-06-24 07:14:54.562823656 -0400
@@ -2888,6 +2888,13 @@ pmu_ioctl(struct inode * inode, struct f
 			return -EACCES;
 		if (sleep_in_progress)
 			return -EBUSY;
+#ifdef CONFIG_SOFTWARE_REPLACE_SLEEP
+		{
+		extern void software_suspend_pending(void);
+		software_suspend_pending();
+		return (0);
+		}
+#endif
 		sleep_in_progress = 1;
 		switch (pmu_kind) {
 		case PMU_OHARE_BASED:
diff -puN drivers/md/dm-crypt.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/md/dm-crypt.c
--- linux-2.6.7-xx2/drivers/md/dm-crypt.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.939918352 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/md/dm-crypt.c	2004-06-24 07:14:54.564823352 -0400
@@ -758,7 +758,7 @@ static int __init dm_crypt_init(void)
 	if (!_crypt_io_pool)
 		return -ENOMEM;
 
-	_kcryptd_workqueue = create_workqueue("kcryptd");
+	_kcryptd_workqueue = create_workqueue("kcryptd", PF_NOFREEZE);
 	if (!_kcryptd_workqueue) {
 		r = -ENOMEM;
 		DMERR(PFX "couldn't create kcryptd");
diff -puN drivers/md/md.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/md/md.c
--- linux-2.6.7-xx2/drivers/md/md.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.942917896 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/md/md.c	2004-06-24 07:14:54.568822744 -0400
@@ -2832,6 +2832,7 @@ int md_thread(void * arg)
 	 */
 
 	daemonize(thread->name, mdname(thread->mddev));
+	current->flags |= PF_NOFREEZE;
 
 	current->exit_signal = SIGCHLD;
 	allow_signal(SIGKILL);
diff -puN drivers/media/video/msp3400.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/media/video/msp3400.c
--- linux-2.6.7-xx2/drivers/media/video/msp3400.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.945917440 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/media/video/msp3400.c	2004-06-24 07:14:54.571822288 -0400
@@ -47,6 +47,7 @@
 #include <linux/videodev.h>
 #include <linux/init.h>
 #include <linux/smp_lock.h>
+#include <linux/suspend.h>
 #include <asm/semaphore.h>
 #include <asm/pgtable.h>
 
@@ -785,16 +786,22 @@ static int msp3400c_thread(void *data)
 	
 	struct CARRIER_DETECT *cd;
 	int count, max1,max2,val1,val2, val,this;
+	DECLARE_SWSUSP_LOCAL_VAR;
 	
 	daemonize("msp3400");
 	allow_signal(SIGTERM);
 	printk("msp3400: daemon started\n");
 
+	SWSUSP_THREAD_FLAGS_RESET;
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
+
 	for (;;) {
 		d2printk("msp3400: thread: sleep\n");
+		SWSUSP_ACTIVITY_PAUSING;
 		if (msp34xx_sleep(msp,-1))
 			goto done;
 
+		SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 		d2printk("msp3400: thread: wakeup\n");
 		msp->active = 1;
 
@@ -805,9 +812,11 @@ static int msp3400c_thread(void *data)
 		}
 
 		/* some time for the tuner to sync */
+		SWSUSP_ACTIVITY_PAUSING;
 		if (msp34xx_sleep(msp,HZ/5))
 			goto done;
 		
+		SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 	restart:
 		if (VIDEO_MODE_RADIO == msp->norm ||
 		    MSP_MODE_EXTERN  == msp->mode) {
@@ -873,8 +882,10 @@ static int msp3400c_thread(void *data)
 		for (this = 0; this < count; this++) {
 			msp3400c_setcarrier(client, cd[this].cdo,cd[this].cdo);
 
+			SWSUSP_ACTIVITY_PAUSING;
 			if (msp34xx_sleep(msp,HZ/10))
 				goto done;
+			SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 			if (msp->restart)
 				goto restart;
 
@@ -973,6 +984,8 @@ static int msp3400c_thread(void *data)
 	}
 
 done:
+	SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
+	SWSUSP_ACTIVITY_END;
 	msp->active = 0;
 	dprintk(KERN_DEBUG "msp3400: thread: exit\n");
         complete_and_exit(&msp->texit, 0);
diff -puN drivers/media/video/tvaudio.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/media/video/tvaudio.c
--- linux-2.6.7-xx2/drivers/media/video/tvaudio.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.947917136 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/media/video/tvaudio.c	2004-06-24 07:14:54.573821984 -0400
@@ -28,6 +28,7 @@
 #include <linux/i2c-algo-bit.h>
 #include <linux/init.h>
 #include <linux/smp_lock.h>
+#include <linux/suspend.h>
 
 #include <media/audiochip.h>
 #include <media/id.h>
@@ -273,18 +274,24 @@ static int chip_thread(void *data)
 	DECLARE_WAITQUEUE(wait, current);
         struct CHIPSTATE *chip = data;
 	struct CHIPDESC  *desc = chiplist + chip->type;
+	DECLARE_SWSUSP_LOCAL_VAR;
 	
 	daemonize("%s",i2c_clientname(&chip->c));
 	allow_signal(SIGTERM);
 	dprintk("%s: thread started\n", i2c_clientname(&chip->c));
 
+	SWSUSP_THREAD_FLAGS_RESET;
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
+
 	for (;;) {
+		SWSUSP_ACTIVITY_PAUSING;
 		add_wait_queue(&chip->wq, &wait);
 		if (!chip->done) {
 			set_current_state(TASK_INTERRUPTIBLE);
 			schedule();
 		}
 		remove_wait_queue(&chip->wq, &wait);
+		SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 		if (chip->done || signal_pending(current))
 			break;
 		dprintk("%s: thread wakeup\n", i2c_clientname(&chip->c));
@@ -301,6 +308,7 @@ static int chip_thread(void *data)
 	}
 
 	dprintk("%s: thread exiting\n", i2c_clientname(&chip->c));
+	SWSUSP_ACTIVITY_END;
         complete_and_exit(&chip->texit, 0);
 	return 0;
 }
diff -puN drivers/message/i2o/i2o_block.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/message/i2o/i2o_block.c
--- linux-2.6.7-xx2/drivers/message/i2o/i2o_block.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.969913792 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/message/i2o/i2o_block.c	2004-06-24 07:14:54.577821376 -0400
@@ -78,6 +78,7 @@
 
 #include <linux/notifier.h>
 #include <linux/reboot.h>
+#include <linux/suspend.h>
 
 #include <asm/uaccess.h>
 #include <asm/semaphore.h>
@@ -605,21 +606,30 @@ static int i2ob_evt(void *dummy)
 		u16 pad;
 		u8 data[16];
 		} *evt_local;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	daemonize("i2oblock");
 	allow_signal(SIGKILL);
 
 	evt_running = 1;
 
+	SWSUSP_THREAD_FLAGS_RESET;
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
+
 	while(1)
 	{
+		SWSUSP_ACTIVITY_PAUSING;
+
 		if(down_interruptible(&i2ob_evt_sem))
 		{
+			SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 			evt_running = 0;
 			printk("exiting...");
 			break;
 		}
 
+		SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
+
 		/*
 		 * Keep another CPU/interrupt from overwriting the 
 		 * message while we're reading it
@@ -742,6 +752,7 @@ static int i2ob_evt(void *dummy)
 		}
 	};
 
+	SWSUSP_ACTIVITY_END;
 	complete_and_exit(&i2ob_thread_dead,0);
 	return 0;
 }
diff -puN drivers/message/i2o/i2o_core.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/message/i2o/i2o_core.c
--- linux-2.6.7-xx2/drivers/message/i2o/i2o_core.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:53.995909840 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/message/i2o/i2o_core.c	2004-06-24 07:14:54.584820312 -0400
@@ -55,6 +55,8 @@
 #include <asm/mtrr.h>
 #endif // CONFIG_MTRR
 
+#include <linux/suspend.h>
+
 #include "i2o_lan.h"
 
 //#define DRIVERDEBUG
@@ -1014,22 +1016,32 @@ static int i2o_core_evt(void *reply_data
 	u32 *msg = reply->msg;
 	struct i2o_controller *c = NULL;
 	unsigned long flags;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	daemonize("i2oevtd");
 	allow_signal(SIGKILL);
 
-	evt_running = 1;
+	SWSUSP_THREAD_FLAGS_RESET;
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
+
+ 	evt_running = 1;
 
 	while(1)
 	{
+		SWSUSP_ACTIVITY_PAUSING;
+
 		if(down_interruptible(&evt_sem))
 		{
 			dprintk(KERN_INFO "I2O event thread dead\n");
 			printk("exiting...");
 			evt_running = 0;
+			SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
+			SWSUSP_ACTIVITY_END;
 			complete_and_exit(&evt_dead, 0);
 		}
 
+		SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
+
 		/* 
 		 * Copy the data out of the queue so that we don't have to lock
 		 * around the whole function and just around the qlen update
@@ -1161,6 +1173,7 @@ static int i2o_core_evt(void *reply_data
 		}
 	}
 
+	SWSUSP_ACTIVITY_END;
 	return 0;
 }
 
@@ -1181,19 +1194,26 @@ static int i2o_dyn_lct(void *foo)
 	int found = 0;
 	int entries;
 	void *tmp;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	daemonize("iop%d_lctd", c->unit);
 	allow_signal(SIGKILL);
 
+	SWSUSP_THREAD_FLAGS_RESET;
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
+
 	c->lct_running = 1;
 
 	while(1)
 	{
+		SWSUSP_ACTIVITY_PAUSING;
 		down_interruptible(&c->lct_sem);
+		SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 		if(signal_pending(current))
 		{
 			dprintk(KERN_ERR "%s: LCT thread dead\n", c->name);
 			c->lct_running = 0;
+			SWSUSP_ACTIVITY_END;
 			return 0;
 		}
 
@@ -1271,6 +1291,7 @@ static int i2o_dyn_lct(void *foo)
 		memcpy(c->lct, c->dlct, c->dlct->table_size<<2);
 	}
 
+	SWSUSP_ACTIVITY_END;
 	return 0;
 }
 
diff -puN drivers/mtd/mtdblock.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/mtd/mtdblock.c
--- linux-2.6.7-xx2/drivers/mtd/mtdblock.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.019906192 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/mtd/mtdblock.c	2004-06-24 07:14:54.586820008 -0400
@@ -17,6 +17,7 @@
 #include <linux/vmalloc.h>
 #include <linux/mtd/mtd.h>
 #include <linux/mtd/blktrans.h>
+#include <linux/suspend.h>
 
 static struct mtdblk_dev {
 	struct mtd_info *mtd;
@@ -52,6 +53,7 @@ static int erase_write (struct mtd_info 
 	wait_queue_head_t wait_q;
 	size_t retlen;
 	int ret;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	/*
 	 * First, let's erase the flash block.
@@ -77,8 +79,10 @@ static int erase_write (struct mtd_info 
 		return ret;
 	}
 
+	SWSUSP_ACTIVITY_SYNCTHREAD_PAUSING;
 	schedule();  /* Wait for erase to finish. */
 	remove_wait_queue(&wait_q, &wait);
+	SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 
 	/*
 	 * Next, writhe data to flash.
diff -puN drivers/net/irda/sir_kthread.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/net/irda/sir_kthread.c
--- linux-2.6.7-xx2/drivers/net/irda/sir_kthread.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.022905736 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/net/irda/sir_kthread.c	2004-06-24 07:14:54.587819856 -0400
@@ -111,8 +111,13 @@ static void run_irda_queue(void)
 static int irda_thread(void *startup)
 {
 	DECLARE_WAITQUEUE(wait, current);
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	daemonize("kIrDAd");
+	current->flags |= PF_SYNCTHREAD;
+
+	SWSUSP_THREAD_FLAGS_RESET;
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
 
 	irda_rq_queue.thread = current;
 
@@ -127,6 +132,7 @@ static int irda_thread(void *startup)
 		 * that the problem is that "uninterruptible sleep
 		 * contributes to load average", making user worry.
 		 * Jean II */
+		SWSUSP_ACTIVITY_SYNCTHREAD_PAUSING;
 		set_task_state(current, TASK_INTERRUPTIBLE);
 		add_wait_queue(&irda_rq_queue.kick, &wait);
 		if (list_empty(&irda_rq_queue.request_list))
diff -puN drivers/net/wan/sdlamain.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/net/wan/sdlamain.c
--- linux-2.6.7-xx2/drivers/net/wan/sdlamain.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.051901328 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/net/wan/sdlamain.c	2004-06-24 07:14:54.590819400 -0400
@@ -240,7 +240,7 @@ static int __init wanpipe_init(void)
 	printk(KERN_INFO "%s v%u.%u %s\n",
 		fullname, DRV_VERSION, DRV_RELEASE, copyright);
 
-	wanpipe_wq = create_workqueue("wanpipe_wq");
+	wanpipe_wq = create_workqueue("wanpipe_wq", 0);
 	if (!wanpipe_wq)
 		return -ENOMEM;
 
diff -puN drivers/parport/ieee1284.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/parport/ieee1284.c
--- linux-2.6.7-xx2/drivers/parport/ieee1284.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.055900720 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/parport/ieee1284.c	2004-06-24 07:14:54.591819248 -0400
@@ -25,6 +25,7 @@
 #include <linux/interrupt.h>
 #include <linux/timer.h>
 #include <linux/sched.h>
+#include <linux/suspend.h>
 
 #undef DEBUG /* undef me for production */
 
@@ -71,6 +72,7 @@ int parport_wait_event (struct parport *
 {
 	int ret;
 	struct timer_list timer;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	if (!port->physport->cad->timeout)
 		/* Zero timeout is special, and we can't down() the
@@ -84,7 +86,9 @@ int parport_wait_event (struct parport *
 	timer.data = port->number;
 
 	add_timer (&timer);
+	SWSUSP_ACTIVITY_PAUSING;
 	ret = down_interruptible (&port->physport->ieee1284.irq);
+	SWSUSP_ACTIVITY_RESTARTING(0);
 	if (!del_timer (&timer) && !ret)
 		/* Timed out. */
 		ret = 1;
diff -puN drivers/pcmcia/cs.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/pcmcia/cs.c
--- linux-2.6.7-xx2/drivers/pcmcia/cs.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.057900416 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/pcmcia/cs.c	2004-06-24 07:14:54.594818792 -0400
@@ -676,8 +676,14 @@ static int pccardd(void *__skt)
 	struct pcmcia_socket *skt = __skt;
 	DECLARE_WAITQUEUE(wait, current);
 	int ret;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	daemonize("pccardd");
+	current->flags |= PF_SYNCTHREAD;
+
+	SWSUSP_THREAD_FLAGS_RESET;
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
+
 	skt->thread = current;
 	complete(&skt->thread_done);
 
@@ -718,9 +724,9 @@ static int pccardd(void *__skt)
 			continue;
 		}
 
+		SWSUSP_ACTIVITY_SYNCTHREAD_PAUSING;
 		schedule();
-		if (current->flags & PF_FREEZE)
-			refrigerator(PF_FREEZE);
+		SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 
 		if (!skt->thread)
 			break;
@@ -730,6 +736,7 @@ static int pccardd(void *__skt)
 	/* remove from the device core */
 	class_device_unregister(&skt->dev);
 
+	SWSUSP_ACTIVITY_END;
 	complete_and_exit(&skt->thread_done, 0);
 }
 
diff -puN drivers/pnp/pnpbios/core.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/pnp/pnpbios/core.c
--- linux-2.6.7-xx2/drivers/pnp/pnpbios/core.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.059900112 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/pnp/pnpbios/core.c	2004-06-24 07:14:54.596818488 -0400
@@ -65,6 +65,7 @@
 #include <asm/desc.h>
 #include <asm/system.h>
 #include <asm/byteorder.h>
+#include <linux/suspend.h>
 
 #include "pnpbios.h"
 
@@ -168,17 +169,28 @@ static int pnp_dock_thread(void * unused
 {
 	static struct pnp_docking_station_info now;
 	int docked = -1, d = 0;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
 	daemonize("kpnpbiosd");
 	allow_signal(SIGKILL);
+
+	SWSUSP_THREAD_FLAGS_RESET;
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
+
 	while(!unloading && !signal_pending(current))
 	{
 		int status;
 		
+		SWSUSP_ACTIVITY_PAUSING;
+
 		/*
 		 * Poll every 2 seconds
 		 */
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout(HZ*2);
+
+		SWSUSP_ACTIVITY_RESTARTING(PF_FREEZE);
+
 		if(signal_pending(current))
 			break;
 
@@ -190,6 +202,7 @@ static int pnp_dock_thread(void * unused
 			 * No dock to manage
 			 */
 			case PNP_FUNCTION_NOT_SUPPORTED:
+				SWSUSP_ACTIVITY_END;
 				complete_and_exit(&unload_sem, 0);
 			case PNP_SYSTEM_NOT_DOCKED:
 				d = 0;
@@ -212,6 +225,7 @@ static int pnp_dock_thread(void * unused
 			}
 		}
 	}
+	SWSUSP_ACTIVITY_END;
 	complete_and_exit(&unload_sem, 0);
 }
 
diff -puN drivers/s390/cio/device.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/s390/cio/device.c
--- linux-2.6.7-xx2/drivers/s390/cio/device.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.081896768 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/s390/cio/device.c	2004-06-24 07:14:54.598818184 -0400
@@ -151,10 +151,11 @@ init_ccw_bus_type (void)
 	init_waitqueue_head(&ccw_device_init_wq);
 	atomic_set(&ccw_device_init_count, 0);
 
-	ccw_device_work = create_singlethread_workqueue("cio");
+	ccw_device_work = create_singlethread_workqueue("cio", 0);
 	if (!ccw_device_work)
 		return -ENOMEM; /* FIXME: better errno ? */
-	ccw_device_notify_work = create_singlethread_workqueue("cio_notify");
+	ccw_device_notify_work = create_singlethread_workqueue("cio_notify",
+			0);
 	if (!ccw_device_notify_work) {
 		ret = -ENOMEM; /* FIXME: better errno ? */
 		goto out_err;
diff -puN drivers/scsi/scsi_error.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/scsi/scsi_error.c
--- linux-2.6.7-xx2/drivers/scsi/scsi_error.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.084896312 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/scsi/scsi_error.c	2004-06-24 07:14:54.601817728 -0400
@@ -23,6 +23,7 @@
 #include <linux/interrupt.h>
 #include <linux/blkdev.h>
 #include <linux/smp_lock.h>
+#include <linux/suspend.h>
 
 #include <scsi/scsi.h>
 #include <scsi/scsi_dbg.h>
diff -puN drivers/serial/8250.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/serial/8250.c
--- linux-2.6.7-xx2/drivers/serial/8250.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.086896008 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/serial/8250.c	2004-06-24 07:14:54.607816816 -0400
@@ -50,6 +50,12 @@
  */
 unsigned int share_irqs = SERIAL8250_SHARE_IRQS;
 
+#if defined(CONFIG_SERIAL_CORE_CONSOLE) && defined(CONFIG_SOFTWARE_SUSPEND2)
+#include <linux/suspend.h>
+#include <linux/suspend-debug.h>
+extern void wakeup_suspend(void);
+#endif
+
 /*
  * Debugging.
  */
@@ -821,6 +827,94 @@ static void serial8250_enable_ms(struct 
 	serial_out(up, UART_IER, up->ier);
 }
 
+#if defined(CONFIG_SERIAL_CORE_CONSOLE) && defined(CONFIG_SOFTWARE_SUSPEND2)
+static inline void suspend_handle_character(unsigned char ch)
+{
+	extern void prepare_status(int printalways, int clearbar, const char *fmt, ...);
+	extern unsigned long suspend_action;
+	extern void request_abort_suspend(void);
+	extern void machine_restart(char * __unused);
+
+	/*
+	 * I would like to be able to do the same as drivers/char/keyboard.c
+	 * here, and allow responding to the sanity check prompt over a serial
+	 * console. Unfortunately, it's one way communication at this point.
+	 * You can't even get into kdb because the serial port interrupts
+	 * aren't running yet.
+	 */
+
+	if (software_suspend_state & SOFTWARE_SUSPEND_SANITY_CHECK_PROMPT) {
+		if (ch == 32)
+			wakeup_suspend();
+		else if (ch == 67) {
+			software_suspend_state |= SOFTWARE_SUSPEND_CONTINUE_REQ;
+			wakeup_suspend();
+		} else
+			return;
+	}
+
+	if (ch >= 'A')
+		ch |= 32;
+
+	switch (ch) {
+		case 27:
+			/* Abort suspend */
+			if (TEST_ACTION_STATE(SUSPEND_CAN_CANCEL))
+				request_abort_suspend();
+			wakeup_suspend();
+			break;
+		case 49:
+			console_loglevel = 1;
+			wakeup_suspend();
+			break;
+		case 48:
+			console_loglevel = 0;
+			wakeup_suspend();
+			break;
+		case 32:
+			wakeup_suspend();
+			break;
+#ifdef CONFIG_SOFTWARE_SUSPEND_DEBUG
+		case 112:
+			/* During suspend, toggle pausing with Pause or Break if kdb active */
+			suspend_action ^= (1 << SUSPEND_PAUSE);
+			schedule_suspend_message(1);
+			wakeup_suspend();
+			break;
+		case 114:
+			/* Otherwise, if R pressed, toggle rebooting */
+			suspend_action ^= (1 << SUSPEND_REBOOT);
+			schedule_suspend_message(2);
+			wakeup_suspend();
+			break;
+		case 115:
+			/* Otherwise, if S pressed, toggle single-stepping */
+			suspend_action ^= (1 << SUSPEND_SINGLESTEP);
+			schedule_suspend_message(3);
+			wakeup_suspend();
+			break;
+		case 108:
+			/* Otherwise, if L pressed, toggle logging everything */
+			suspend_action ^= (1 << SUSPEND_LOGALL);
+			schedule_suspend_message(4);
+			wakeup_suspend();
+			break;
+		case 50:
+		case 51:
+		case 52:
+		case 53:
+		case 54:
+		case 55:
+			console_loglevel = ((ch - 48));
+			wakeup_suspend();
+			break;
+		default:
+			printk("Unhandled character %d.\n", ch);
+#endif
+	}
+}
+#endif /* #if defined(CONFIG_SERIAL_CORE_CONSOLE) && defined(CONFIG_SOFTWARE_SUSPEND2) */
+
 static _INLINE_ void
 receive_chars(struct uart_8250_port *up, int *status, struct pt_regs *regs)
 {
@@ -884,6 +978,16 @@ receive_chars(struct uart_8250_port *up,
 		}
 		if (uart_handle_sysrq_char(&up->port, ch, regs))
 			goto ignore_char;
+
+#if defined(CONFIG_SERIAL_CORE_CONSOLE) && defined(CONFIG_SOFTWARE_SUSPEND2)
+		if (software_suspend_state &
+			(SOFTWARE_SUSPEND_SANITY_CHECK_PROMPT |
+		     	 SOFTWARE_SUSPEND_RUNNING)) {
+			suspend_handle_character(ch);
+			goto ignore_char;
+		}
+#endif
+
 		if ((*status & up->port.ignore_status_mask) == 0) {
 			tty->flip.flag_buf_ptr++;
 			tty->flip.char_buf_ptr++;
diff -puN drivers/usb/core/hub.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/usb/core/hub.c
--- linux-2.6.7-xx2/drivers/usb/core/hub.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.115891600 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/usb/core/hub.c	2004-06-24 07:14:54.610816360 -0400
@@ -1887,22 +1887,28 @@ loop:
 
 static int hub_thread(void *__unused)
 {
+	DECLARE_SWSUSP_LOCAL_VAR;
 	/*
 	 * This thread doesn't need any user-level access,
 	 * so get rid of all our resources
 	 */
 
 	daemonize("khubd");
+	current->flags |= PF_SYNCTHREAD;
+
+	SWSUSP_THREAD_FLAGS_RESET;
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
 	allow_signal(SIGKILL);
 
 	/* Send me a signal to get me die (for debugging) */
 	do {
 		hub_events();
+		SWSUSP_ACTIVITY_SYNCTHREAD_PAUSING;
 		wait_event_interruptible(khubd_wait, !list_empty(&hub_event_list)); 
-		if (current->flags & PF_FREEZE)
-			refrigerator(PF_FREEZE);
+		SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 	} while (!signal_pending(current));
 
+	SWSUSP_ACTIVITY_END;
 	pr_debug ("%s: khubd exiting\n", usbcore_name);
 	complete_and_exit(&khubd_exited, 0);
 }
diff -puN drivers/usb/storage/usb.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/usb/storage/usb.c
--- linux-2.6.7-xx2/drivers/usb/storage/usb.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.147886736 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/usb/storage/usb.c	2004-06-24 07:14:54.615815600 -0400
@@ -50,6 +50,7 @@
 #include <linux/config.h>
 #include <linux/sched.h>
 #include <linux/errno.h>
+#include <linux/suspend.h>
 #include "usb.h"
 #include "scsiglue.h"
 #include "transport.h"
@@ -267,6 +268,7 @@ static int usb_stor_control_thread(void 
 {
 	struct us_data *us = (struct us_data *)__us;
 	struct Scsi_Host *host = us->host;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	lock_kernel();
 
@@ -276,7 +278,10 @@ static int usb_stor_control_thread(void 
 	 */
 	daemonize("usb-storage");
 
-	current->flags |= PF_NOFREEZE;
+	current->flags |= PF_SYNCTHREAD;
+
+	SWSUSP_THREAD_FLAGS_RESET;
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
 
 	unlock_kernel();
 
@@ -285,10 +290,14 @@ static int usb_stor_control_thread(void 
 
 	for(;;) {
 		US_DEBUGP("*** thread sleeping.\n");
-		if(down_interruptible(&us->sema))
+		SWSUSP_ACTIVITY_SYNCTHREAD_PAUSING;
+		if(down_interruptible(&us->sema)) {
+			SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 			break;
+		}
 			
 		US_DEBUGP("*** thread awakened.\n");
+		SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 
 		/* lock the device pointers */
 		down(&(us->dev_semaphore));
@@ -393,6 +402,8 @@ SkipForDisconnect:
 		up(&(us->dev_semaphore));
 	} /* for (;;) */
 
+	SWSUSP_ACTIVITY_END;
+
 	/* notify the exit routine that we're actually exiting now 
 	 *
 	 * complete()/wait_for_completion() is similar to up()/down(),
diff -puN drivers/video/console/fbcon.c~20-software-suspend-linux-2.6.7-rev1-whole drivers/video/console/fbcon.c
--- linux-2.6.7-xx2/drivers/video/console/fbcon.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.171883088 -0400
+++ linux-2.6.7-xx2-xiphux/drivers/video/console/fbcon.c	2004-06-24 07:14:54.635812560 -0400
@@ -1429,14 +1429,14 @@ static void fbcon_redraw(struct vc_data 
 				}
 			}
 			scr_writew(c, d);
-			console_conditional_schedule();
+			//console_conditional_schedule();
 			s++;
 			d++;
 		} while (s < le);
 		if (s > start)
 			accel_putcs(vc, info, start, s - start,
 				    real_y(p, line), x);
-		console_conditional_schedule();
+		//console_conditional_schedule();
 		if (offset > 0)
 			line++;
 		else {
diff -puN fs/aio.c~20-software-suspend-linux-2.6.7-rev1-whole fs/aio.c
--- linux-2.6.7-xx2/fs/aio.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.174882632 -0400
+++ linux-2.6.7-xx2-xiphux/fs/aio.c	2004-06-24 07:14:54.637812256 -0400
@@ -69,7 +69,7 @@ static int __init aio_setup(void)
 	kioctx_cachep = kmem_cache_create("kioctx", sizeof(struct kioctx),
 				0, SLAB_HWCACHE_ALIGN|SLAB_PANIC, NULL, NULL);
 
-	aio_wq = create_workqueue("aio");
+	aio_wq = create_workqueue("aio", PF_NOFREEZE);
 
 	pr_debug("aio_setup: sizeof(struct page) = %d\n", (int)sizeof(struct page));
 
diff -puN fs/buffer.c~20-software-suspend-linux-2.6.7-rev1-whole fs/buffer.c
--- linux-2.6.7-xx2/fs/buffer.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.177882176 -0400
+++ linux-2.6.7-xx2-xiphux/fs/buffer.c	2004-06-24 07:14:54.643811344 -0400
@@ -37,6 +37,8 @@
 #include <linux/bio.h>
 #include <linux/notifier.h>
 #include <linux/cpu.h>
+#include <linux/init.h>
+#include <linux/swap.h>
 #include <asm/bitops.h>
 
 static void invalidate_bh_lrus(void);
@@ -253,6 +255,14 @@ EXPORT_SYMBOL(sync_blockdev);
  */
 int fsync_super(struct super_block *sb)
 {
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+	/* A safety net. During suspend, we might overwrite
+	 * memory containing filesystem info. We don't then
+	 * want to sync it to disk. */
+	if (unlikely(software_suspend_state & SOFTWARE_SUSPEND_FREEZE_UNREFRIGERATED))
+		return sync_blockdev(sb->s_bdev);
+#endif
+
 	sync_inodes_sb(sb, 0);
 	DQUOT_SYNC(sb);
 	lock_super(sb);
@@ -276,12 +286,20 @@ EXPORT_SYMBOL(fsync_super);
 int fsync_bdev(struct block_device *bdev)
 {
 	struct super_block *sb = get_super(bdev);
+	int result = 0;
+ 	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
+	current->flags |= PF_SYNCTHREAD;
 	if (sb) {
 		int res = fsync_super(sb);
 		drop_super(sb);
 		return res;
 	}
-	return sync_blockdev(bdev);
+	result = sync_blockdev(bdev);
+	current->flags &= ~PF_SYNCTHREAD;
+ 	SWSUSP_ACTIVITY_END;
+	return result;
 }
 
 /**
@@ -361,6 +379,13 @@ EXPORT_SYMBOL(thaw_bdev);
  */
 static void do_sync(unsigned long wait)
 {
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+	/* A safety net. During suspend, we might overwrite
+	 * memory containing filesystem info. We don't then
+	 * want to sync it to disk. */
+	if (unlikely(software_suspend_state & SOFTWARE_SUSPEND_FREEZE_UNREFRIGERATED))
+		return;
+#endif
 	wakeup_bdflush(0);
 	sync_inodes(0);		/* All mappings, inodes and their blockdevs */
 	DQUOT_SYNC(NULL);
@@ -376,7 +401,13 @@ static void do_sync(unsigned long wait)
 
 asmlinkage long sys_sync(void)
 {
+ 	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
+	current->flags |= PF_SYNCTHREAD;
 	do_sync(1);
+	current->flags &= ~PF_SYNCTHREAD;
+ 	SWSUSP_ACTIVITY_END;
 	return 0;
 }
 
@@ -417,6 +448,10 @@ asmlinkage long sys_fsync(unsigned int f
 	struct file * file;
 	struct address_space *mapping;
 	int ret, err;
+ 	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
+	current->flags |= PF_SYNCTHREAD;
 
 	ret = -EBADF;
 	file = fget(fd);
@@ -447,6 +482,8 @@ asmlinkage long sys_fsync(unsigned int f
 out_putf:
 	fput(file);
 out:
+	current->flags &= ~PF_SYNCTHREAD;
+	SWSUSP_ACTIVITY_END;
 	return ret;
 }
 
@@ -455,6 +492,10 @@ asmlinkage long sys_fdatasync(unsigned i
 	struct file * file;
 	struct address_space *mapping;
 	int ret, err;
+ 	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
+	current->flags |= PF_SYNCTHREAD;
 
 	ret = -EBADF;
 	file = fget(fd);
@@ -482,6 +523,8 @@ asmlinkage long sys_fdatasync(unsigned i
 out_putf:
 	fput(file);
 out:
+	current->flags &= ~PF_SYNCTHREAD;
+	SWSUSP_ACTIVITY_END;
 	return ret;
 }
 
@@ -1152,6 +1195,10 @@ no_grow:
 	 * async buffer heads in use.
 	 */
 	free_more_memory();
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+	if (suspend_task == current->pid)
+		cleanup_finished_suspend_io();
+#endif
 	goto try_again;
 }
 
@@ -2914,7 +2961,7 @@ int sync_dirty_buffer(struct buffer_head
  *
  * try_to_free_buffers() is non-blocking.
  */
-static inline int buffer_busy(struct buffer_head *bh)
+inline int buffer_busy(struct buffer_head *bh)
 {
 	return atomic_read(&bh->b_count) |
 		(bh->b_state & ((1 << BH_Dirty) | (1 << BH_Lock)));
diff -puN fs/dcache.c~20-software-suspend-linux-2.6.7-rev1-whole fs/dcache.c
--- linux-2.6.7-xx2/fs/dcache.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.180881720 -0400
+++ linux-2.6.7-xx2-xiphux/fs/dcache.c	2004-06-24 07:14:54.648810584 -0400
@@ -26,6 +26,7 @@
 #include <linux/module.h>
 #include <linux/mount.h>
 #include <linux/file.h>
+#include <linux/suspend.h>
 #include <asm/uaccess.h>
 #include <linux/security.h>
 #include <linux/seqlock.h>
@@ -1390,10 +1391,13 @@ asmlinkage long sys_getcwd(char __user *
 	struct vfsmount *pwdmnt, *rootmnt;
 	struct dentry *pwd, *root;
 	char *page = (char *) __get_free_page(GFP_USER);
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	if (!page)
 		return -ENOMEM;
 
+	SWSUSP_ACTIVITY_START(0);
+
 	read_lock(&current->fs->lock);
 	pwdmnt = mntget(current->fs->pwdmnt);
 	pwd = dget(current->fs->pwd);
@@ -1431,6 +1435,7 @@ out:
 	dput(root);
 	mntput(rootmnt);
 	free_page((unsigned long) page);
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 
diff -puN fs/devfs/base.c~20-software-suspend-linux-2.6.7-rev1-whole fs/devfs/base.c
--- linux-2.6.7-xx2/fs/devfs/base.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.182881416 -0400
+++ linux-2.6.7-xx2-xiphux/fs/devfs/base.c	2004-06-24 07:14:54.653809824 -0400
@@ -677,6 +677,7 @@
 #include <linux/rwsem.h>
 #include <linux/sched.h>
 #include <linux/namei.h>
+#include <linux/suspend.h>
 
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -2591,6 +2592,7 @@ static ssize_t devfsd_read(struct file *
 	struct fs_info *fs_info = file->f_dentry->d_inode->i_sb->s_fs_info;
 	struct devfsd_notify_struct *info = fs_info->devfsd_info;
 	DECLARE_WAITQUEUE(wait, current);
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	/*  Can't seek (pread) on this device  */
 	if (ppos != &file->f_pos)
@@ -2598,6 +2600,7 @@ static ssize_t devfsd_read(struct file *
 	/*  Verify the task has grabbed the queue  */
 	if (fs_info->devfsd_task != current)
 		return -EPERM;
+	current->flags |= PF_SYNCTHREAD;
 	info->major = 0;
 	info->minor = 0;
 	/*  Block for a new entry  */
@@ -2605,12 +2608,15 @@ static ssize_t devfsd_read(struct file *
 	add_wait_queue(&fs_info->devfsd_wait_queue, &wait);
 	while (devfsd_queue_empty(fs_info)) {
 		fs_info->devfsd_sleeping = TRUE;
+		SWSUSP_ACTIVITY_SYNCTHREAD_PAUSING;
 		wake_up(&fs_info->revalidate_wait_queue);
 		schedule();
+		SWSUSP_ACTIVITY_RESTARTING(0);
 		fs_info->devfsd_sleeping = FALSE;
 		if (signal_pending(current)) {
 			remove_wait_queue(&fs_info->devfsd_wait_queue, &wait);
 			__set_current_state(TASK_RUNNING);
+			current->flags &= ~PF_SYNCTHREAD;
 			return -EINTR;
 		}
 		set_current_state(TASK_INTERRUPTIBLE);
@@ -2631,8 +2637,10 @@ static ssize_t devfsd_read(struct file *
 		info->minor = MINOR(de->u.dev);
 	}
 	pos = devfs_generate_path(de, info->devname, DEVFS_PATHLEN);
-	if (pos < 0)
+	if (pos < 0) {
+		current->flags &= ~PF_SYNCTHREAD;
 		return pos;
+	}
 	info->namelen = DEVFS_PATHLEN - pos - 1;
 	if (info->mode == 0)
 		info->mode = de->mode;
@@ -2644,6 +2652,7 @@ static ssize_t devfsd_read(struct file *
 		if (tlen > len)
 			tlen = len;
 		if (copy_to_user(buf, (char *)info + rpos, tlen)) {
+			current->flags &= ~PF_SYNCTHREAD;
 			return -EFAULT;
 		}
 		rpos += tlen;
@@ -2659,6 +2668,7 @@ static ssize_t devfsd_read(struct file *
 			done = TRUE;
 		if (copy_to_user
 		    (buf, info->devname + pos + rpos - devname_offset, tlen)) {
+			current->flags &= ~PF_SYNCTHREAD;
 			return -EFAULT;
 		}
 		rpos += tlen;
@@ -2682,6 +2692,7 @@ static ssize_t devfsd_read(struct file *
 		*ppos = 0;
 	} else
 		*ppos = rpos;
+	current->flags &= ~PF_SYNCTHREAD;
 	return tlen;
 }				/*  End Function devfsd_read  */
 
diff -puN fs/exec.c~20-software-suspend-linux-2.6.7-rev1-whole fs/exec.c
--- linux-2.6.7-xx2/fs/exec.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.185880960 -0400
+++ linux-2.6.7-xx2-xiphux/fs/exec.c	2004-06-24 07:14:54.655809520 -0400
@@ -46,6 +46,7 @@
 #include <linux/security.h>
 #include <linux/syscalls.h>
 #include <linux/rmap.h>
+#include <linux/suspend.h>
 
 #include <asm/uaccess.h>
 #include <asm/mmu_context.h>
@@ -120,6 +121,9 @@ asmlinkage long sys_uselib(const char __
 	struct file * file;
 	struct nameidata nd;
 	int error;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	nd.intent.open.flags = FMODE_READ;
 	error = __user_walk(library, LOOKUP_FOLLOW|LOOKUP_OPEN, &nd);
@@ -160,6 +164,7 @@ asmlinkage long sys_uselib(const char __
 	}
 	fput(file);
 out:
+	SWSUSP_ACTIVITY_END;
   	return error;
 exit:
 	path_release(&nd);
@@ -1075,12 +1080,17 @@ int do_execve(char * filename,
 	struct file *file;
 	int retval;
 	int i;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	file = open_exec(filename);
 
 	retval = PTR_ERR(file);
-	if (IS_ERR(file))
+	if (IS_ERR(file)) {
+		SWSUSP_ACTIVITY_END;
 		return retval;
+	}
 
 	sched_balance_exec();
 
@@ -1139,6 +1149,7 @@ int do_execve(char * filename,
 
 		/* execve success */
 		security_bprm_free(&bprm);
+		SWSUSP_ACTIVITY_END;
 		return retval;
 	}
 
@@ -1162,6 +1173,7 @@ out_file:
 		allow_write_access(bprm.file);
 		fput(bprm.file);
 	}
+	SWSUSP_ACTIVITY_END;
 	return retval;
 }
 
@@ -1352,6 +1364,9 @@ int do_coredump(long signr, int exit_cod
 	struct inode * inode;
 	struct file * file;
 	int retval = 0;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	lock_kernel();
 	binfmt = current->binfmt;
@@ -1399,5 +1414,6 @@ fail_unlock:
 	complete_all(&mm->core_done);
 fail:
 	unlock_kernel();
+	SWSUSP_ACTIVITY_END;
 	return retval;
 }
diff -puN fs/fcntl.c~20-software-suspend-linux-2.6.7-rev1-whole fs/fcntl.c
--- linux-2.6.7-xx2/fs/fcntl.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.188880504 -0400
+++ linux-2.6.7-xx2-xiphux/fs/fcntl.c	2004-06-24 07:14:54.657809216 -0400
@@ -14,6 +14,7 @@
 #include <linux/module.h>
 #include <linux/security.h>
 #include <linux/ptrace.h>
+#include <linux/suspend.h>
 
 #include <asm/poll.h>
 #include <asm/siginfo.h>
@@ -153,6 +154,9 @@ asmlinkage long sys_dup2(unsigned int ol
 	int err = -EBADF;
 	struct file * file, *tofree;
 	struct files_struct * files = current->files;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	spin_lock(&files->file_lock);
 	if (!(file = fcheck(oldfd)))
@@ -191,6 +195,7 @@ asmlinkage long sys_dup2(unsigned int ol
 		filp_close(tofree, files);
 	err = newfd;
 out:
+	SWSUSP_ACTIVITY_END;
 	return err;
 out_unlock:
 	spin_unlock(&files->file_lock);
@@ -206,9 +211,13 @@ asmlinkage long sys_dup(unsigned int fil
 {
 	int ret = -EBADF;
 	struct file * file = fget(fildes);
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	if (file)
 		ret = dupfd(file, 0);
+	SWSUSP_ACTIVITY_END;
 	return ret;
 }
 
@@ -370,6 +379,9 @@ asmlinkage long sys_fcntl(int fd, unsign
 {	
 	struct file *filp;
 	long err = -EBADF;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	filp = fget(fd);
 	if (!filp)
@@ -378,6 +390,7 @@ asmlinkage long sys_fcntl(int fd, unsign
 	err = security_file_fcntl(filp, cmd, arg);
 	if (err) {
 		fput(filp);
+		SWSUSP_ACTIVITY_END;
 		return err;
 	}
 
@@ -385,6 +398,7 @@ asmlinkage long sys_fcntl(int fd, unsign
 
  	fput(filp);
 out:
+	SWSUSP_ACTIVITY_END;
 	return err;
 }
 
@@ -393,6 +407,9 @@ asmlinkage long sys_fcntl64(unsigned int
 {	
 	struct file * filp;
 	long err;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	err = -EBADF;
 	filp = fget(fd);
@@ -402,6 +419,7 @@ asmlinkage long sys_fcntl64(unsigned int
 	err = security_file_fcntl(filp, cmd, arg);
 	if (err) {
 		fput(filp);
+		SWSUSP_ACTIVITY_END;
 		return err;
 	}
 	err = -EBADF;
@@ -420,6 +438,7 @@ asmlinkage long sys_fcntl64(unsigned int
 	}
 	fput(filp);
 out:
+	SWSUSP_ACTIVITY_END;
 	return err;
 }
 #endif
diff -puN fs/jbd/journal.c~20-software-suspend-linux-2.6.7-rev1-whole fs/jbd/journal.c
--- linux-2.6.7-xx2/fs/jbd/journal.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.190880200 -0400
+++ linux-2.6.7-xx2-xiphux/fs/jbd/journal.c	2004-06-24 07:14:54.660808760 -0400
@@ -127,10 +127,15 @@ int kjournald(void *arg)
 	journal_t *journal = (journal_t *) arg;
 	transaction_t *transaction;
 	struct timer_list timer;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	current_journal = journal;
 
 	daemonize("kjournald");
+	current->flags |= PF_SYNCTHREAD;
+
+	SWSUSP_THREAD_FLAGS_RESET;
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
 
 	/* Set up an interval timer which can be used to trigger a
            commit wakeup after the commit interval expires */
@@ -165,17 +170,7 @@ loop:
 	}
 
 	wake_up(&journal->j_wait_done_commit);
-	if (current->flags & PF_FREEZE) {
-		/*
-		 * The simpler the better. Flushing journal isn't a
-		 * good idea, because that depends on threads that may
-		 * be already stopped.
-		 */
-		jbd_debug(1, "Now suspending kjournald\n");
-		spin_unlock(&journal->j_state_lock);
-		refrigerator(PF_FREEZE);
-		spin_lock(&journal->j_state_lock);
-	} else {
+	{
 		/*
 		 * We assume on resume that commits are already there,
 		 * so we don't sleep
@@ -193,7 +188,9 @@ loop:
 			should_sleep = 0;
 		if (should_sleep) {
 			spin_unlock(&journal->j_state_lock);
+			SWSUSP_ACTIVITY_SYNCTHREAD_PAUSING;
 			schedule();
+			SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 			spin_lock(&journal->j_state_lock);
 		}
 		finish_wait(&journal->j_wait_commit, &wait);
@@ -215,6 +212,7 @@ end_loop:
 
 	spin_unlock(&journal->j_state_lock);
 	del_timer_sync(journal->j_commit_timer);
+	SWSUSP_ACTIVITY_END;
 	journal->j_task = NULL;
 	wake_up(&journal->j_wait_done_commit);
 	jbd_debug(1, "Journal thread exiting.\n");
diff -puN fs/jffs/intrep.c~20-software-suspend-linux-2.6.7-rev1-whole fs/jffs/intrep.c
--- linux-2.6.7-xx2/fs/jffs/intrep.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.193879744 -0400
+++ linux-2.6.7-xx2-xiphux/fs/jffs/intrep.c	2004-06-24 07:14:54.665808000 -0400
@@ -67,6 +67,7 @@
 #include <linux/smp_lock.h>
 #include <linux/time.h>
 #include <linux/ctype.h>
+#include <linux/suspend.h>
 
 #include "intrep.h"
 #include "jffs_fm.h"
@@ -3335,9 +3336,19 @@ jffs_garbage_collect_thread(void *ptr)
 	struct jffs_fmcontrol *fmc = c->fmc;
 	long erased;
 	int result = 0;
-	D1(int i = 1);
+#if CONFIG_JFFS_FS_VERBOSE > 0
+	/*
+	 * For the swsusp macro that follows, we can't just use D1
+	 * with some compilers
+	 */
+	int i = 1;
+#endif
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	daemonize("jffs_gcd");
+	current->flags |= PF_SYNCTHREAD;
+
+	SWSUSP_THREAD_FLAGS_RESET;
 
 	c->gc_task = current;
 
@@ -3391,6 +3402,7 @@ jffs_garbage_collect_thread(void *ptr)
 			}
 		}
 
+		SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
 
 		D1(printk (KERN_NOTICE "jffs_garbage_collect_thread(): collecting.\n"));
 
@@ -3427,5 +3439,6 @@ jffs_garbage_collect_thread(void *ptr)
 	gc_end:
 		D3(printk (KERN_NOTICE "g_c_thread(): up biglock\n"));
 		up(&fmc->biglock);
+		SWSUSP_ACTIVITY_END;
 	} /* for (;;) */
 } /* jffs_garbage_collect_thread() */
diff -puN fs/jffs2/background.c~20-software-suspend-linux-2.6.7-rev1-whole fs/jffs2/background.c
--- linux-2.6.7-xx2/fs/jffs2/background.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.217876096 -0400
+++ linux-2.6.7-xx2-xiphux/fs/jffs2/background.c	2004-06-24 07:14:54.671807088 -0400
@@ -70,8 +70,14 @@ void jffs2_stop_garbage_collect_thread(s
 static int jffs2_garbage_collect_thread(void *_c)
 {
 	struct jffs2_sb_info *c = _c;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	daemonize("jffs2_gcd_mtd%d", c->mtd->index);
+	current->flags |= PF_SYNCTHREAD;
+
+	SWSUSP_THREAD_FLAGS_RESET;
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
+
 	allow_signal(SIGKILL);
 	allow_signal(SIGSTOP);
 	allow_signal(SIGCONT);
@@ -84,6 +90,7 @@ static int jffs2_garbage_collect_thread(
 	for (;;) {
 		allow_signal(SIGHUP);
 
+		SWSUSP_ACTIVITY_SYNCTHREAD_PAUSING;
 		if (!thread_should_wake(c)) {
 			set_current_state (TASK_INTERRUPTIBLE);
 			D1(printk(KERN_DEBUG "jffs2_garbage_collect_thread sleeping...\n"));
@@ -94,14 +101,8 @@ static int jffs2_garbage_collect_thread(
 			schedule();
 		}
 
-		if (current->flags & PF_FREEZE) {
-			refrigerator(0);
-			/* refrigerator() should recalc sigpending for us
-			   but doesn't. No matter - allow_signal() will. */
-			continue;
-		}
-
 		cond_resched();
+		SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 
 		/* Put_super will send a SIGKILL and then wait on the sem. 
 		 */
@@ -115,7 +116,9 @@ static int jffs2_garbage_collect_thread(
 			case SIGSTOP:
 				D1(printk(KERN_DEBUG "jffs2_garbage_collect_thread(): SIGSTOP received.\n"));
 				set_current_state(TASK_STOPPED);
+				SWSUSP_ACTIVITY_SYNCTHREAD_PAUSING;
 				schedule();
+				SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 				break;
 
 			case SIGKILL:
@@ -142,6 +145,7 @@ static int jffs2_garbage_collect_thread(
 	spin_lock(&c->erase_completion_lock);
 	c->gc_task = NULL;
 	spin_unlock(&c->erase_completion_lock);
+	SWSUSP_ACTIVITY_END;
 	complete_and_exit(&c->gc_thread_exit, 0);
 }
 
diff -puN fs/jfs/jfs_logmgr.c~20-software-suspend-linux-2.6.7-rev1-whole fs/jfs/jfs_logmgr.c
--- linux-2.6.7-xx2/fs/jfs/jfs_logmgr.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.219875792 -0400
+++ linux-2.6.7-xx2-xiphux/fs/jfs/jfs_logmgr.c	2004-06-24 07:14:54.674806632 -0400
@@ -2312,8 +2312,12 @@ static int lbmIODone(struct bio *bio, un
 int jfsIOWait(void *arg)
 {
 	struct lbuf *bp;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	daemonize("jfsIO");
+	current->flags |= PF_SYNCTHREAD;
+	SWSUSP_THREAD_FLAGS_RESET;
+	SWSUSP_ACTIVITY_START(0);
 
 	complete(&jfsIOwait);
 
@@ -2328,20 +2332,20 @@ int jfsIOWait(void *arg)
 			lbmStartIO(bp);
 			spin_lock_irq(&log_redrive_lock);
 		}
-		if (current->flags & PF_FREEZE) {
-			spin_unlock_irq(&log_redrive_lock);
-			refrigerator(PF_FREEZE);
-		} else {
+		{
 			add_wait_queue(&jfs_IO_thread_wait, &wq);
 			set_current_state(TASK_INTERRUPTIBLE);
 			spin_unlock_irq(&log_redrive_lock);
+			SWSUSP_ACTIVITY_SYNCTHREAD_PAUSING;
 			schedule();
 			current->state = TASK_RUNNING;
+	 		SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 			remove_wait_queue(&jfs_IO_thread_wait, &wq);
 		}
 	} while (!jfs_stop_threads);
 
 	jfs_info("jfsIOWait being killed!");
+	SWSUSP_ACTIVITY_END;
 	complete_and_exit(&jfsIOwait, 0);
 }
 
diff -puN fs/jfs/jfs_txnmgr.c~20-software-suspend-linux-2.6.7-rev1-whole fs/jfs/jfs_txnmgr.c
--- linux-2.6.7-xx2/fs/jfs/jfs_txnmgr.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.222875336 -0400
+++ linux-2.6.7-xx2-xiphux/fs/jfs/jfs_txnmgr.c	2004-06-24 07:14:54.678806024 -0400
@@ -2728,8 +2728,13 @@ int jfs_lazycommit(void *arg)
 	struct tblock *tblk;
 	unsigned long flags;
 	struct jfs_sb_info *sbi;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	daemonize("jfsCommit");
+	current->flags |= PF_SYNCTHREAD;
+
+	SWSUSP_THREAD_FLAGS_RESET;
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
 
 	complete(&jfsIOwait);
 
@@ -2778,19 +2783,24 @@ int jfs_lazycommit(void *arg)
 
 		if (current->flags & PF_FREEZE) {
 			LAZY_UNLOCK(flags);
-			refrigerator(PF_FREEZE);
+			SWSUSP_ACTIVITY_SYNCTHREAD_PAUSING;
+			SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 		} else {
 			DECLARE_WAITQUEUE(wq, current);
 
 			add_wait_queue(&jfs_commit_thread_wait, &wq);
 			set_current_state(TASK_INTERRUPTIBLE);
 			LAZY_UNLOCK(flags);
+			SWSUSP_ACTIVITY_SYNCTHREAD_PAUSING;
 			schedule();
+			SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 			current->state = TASK_RUNNING;
 			remove_wait_queue(&jfs_commit_thread_wait, &wq);
 		}
 	} while (!jfs_stop_threads);
 
+	SWSUSP_ACTIVITY_END;
+
 	if (!list_empty(&TxAnchor.unlock_queue))
 		jfs_err("jfs_lazycommit being killed w/pending transactions!");
 	else
@@ -2926,8 +2936,12 @@ int jfs_sync(void *arg)
 	struct jfs_inode_info *jfs_ip;
 	int rc;
 	tid_t tid;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	daemonize("jfsSync");
+	current->flags |= PF_SYNCTHREAD;
+	SWSUSP_THREAD_FLAGS_RESET;
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
 
 	complete(&jfsIOwait);
 
@@ -2963,7 +2977,9 @@ int jfs_sync(void *arg)
 				 * Just to be safe.  I don't know how
 				 * long we can run without blocking
 				 */
+				SWSUSP_ACTIVITY_SYNCTHREAD_PAUSING;
 				cond_resched();
+				SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 				TXN_LOCK();
 			} else {
 				/* We can't get the commit semaphore.  It may
@@ -2987,21 +3003,21 @@ int jfs_sync(void *arg)
 		/* Add anon_list2 back to anon_list */
 		list_splice_init(&TxAnchor.anon_list2, &TxAnchor.anon_list);
 
-		if (current->flags & PF_FREEZE) {
-			TXN_UNLOCK();
-			refrigerator(PF_FREEZE);
-		} else {
+		{
 			DECLARE_WAITQUEUE(wq, current);
 
 			add_wait_queue(&jfs_sync_thread_wait, &wq);
 			set_current_state(TASK_INTERRUPTIBLE);
 			TXN_UNLOCK();
+			SWSUSP_ACTIVITY_SYNCTHREAD_PAUSING;
 			schedule();
+			SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 			current->state = TASK_RUNNING;
 			remove_wait_queue(&jfs_sync_thread_wait, &wq);
 		}
 	} while (!jfs_stop_threads);
 
+	SWSUSP_ACTIVITY_END;
 	jfs_info("jfs_sync being killed");
 	complete_and_exit(&jfsIOwait, 0);
 }
diff -puN fs/lockd/clntlock.c~20-software-suspend-linux-2.6.7-rev1-whole fs/lockd/clntlock.c
--- linux-2.6.7-xx2/fs/lockd/clntlock.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.224875032 -0400
+++ linux-2.6.7-xx2-xiphux/fs/lockd/clntlock.c	2004-06-24 07:14:54.679805872 -0400
@@ -14,6 +14,7 @@
 #include <linux/sunrpc/svc.h>
 #include <linux/lockd/lockd.h>
 #include <linux/smp_lock.h>
+#include <linux/suspend.h>
 
 #define NLMDBG_FACILITY		NLMDBG_CLIENT
 
@@ -198,10 +199,16 @@ reclaimer(void *ptr)
 	struct list_head *tmp;
 	struct file_lock *fl;
 	struct inode *inode;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	daemonize("%s-reclaim", host->h_name);
 	allow_signal(SIGKILL);
 
+	current->flags |= PF_SYNCTHREAD;
+
+	SWSUSP_THREAD_FLAGS_RESET;
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
+
 	/* This one ensures that our parent doesn't terminate while the
 	 * reclaim is in progress */
 	lock_kernel();
@@ -241,5 +248,6 @@ restart:
 	nlm_release_host(host);
 	lockd_down();
 	unlock_kernel();
+	SWSUSP_ACTIVITY_END;
 	module_put_and_exit(0);
 }
diff -puN fs/lockd/clntproc.c~20-software-suspend-linux-2.6.7-rev1-whole fs/lockd/clntproc.c
--- linux-2.6.7-xx2/fs/lockd/clntproc.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.226874728 -0400
+++ linux-2.6.7-xx2-xiphux/fs/lockd/clntproc.c	2004-06-24 07:14:54.681805568 -0400
@@ -17,6 +17,7 @@
 #include <linux/sunrpc/svc.h>
 #include <linux/lockd/lockd.h>
 #include <linux/lockd/sm_inter.h>
+#include <linux/suspend.h>
 
 #define NLMDBG_FACILITY		NLMDBG_CLIENT
 #define NLMCLNT_GRACE_WAIT	(5*HZ)
@@ -248,6 +249,7 @@ nlmclnt_call(struct nlm_rqst *req, u32 p
 		.rpc_resp	= resp,
 	};
 	int		status;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	dprintk("lockd: call procedure %d on %s\n",
 			(int)proc, host->h_name);
@@ -307,7 +309,9 @@ in_grace_period:
 		 * reclaimed.
 		 * We can only back off and try again later.
 		 */
+		SWSUSP_ACTIVITY_PAUSING;
 		status = nlm_wait_on_grace(&host->h_gracewait);
+		SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 	} while (status == 0);
 
 	return status;
diff -puN fs/lockd/svc.c~20-software-suspend-linux-2.6.7-rev1-whole fs/lockd/svc.c
--- linux-2.6.7-xx2/fs/lockd/svc.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.228874424 -0400
+++ linux-2.6.7-xx2-xiphux/fs/lockd/svc.c	2004-06-24 07:14:54.683805264 -0400
@@ -25,6 +25,7 @@
 #include <linux/slab.h>
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
+#include <linux/suspend.h>
 
 #include <linux/sunrpc/types.h>
 #include <linux/sunrpc/stats.h>
@@ -96,6 +97,7 @@ lockd(struct svc_rqst *rqstp)
 	struct svc_serv	*serv = rqstp->rq_server;
 	int		err = 0;
 	unsigned long grace_period_expire;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	/* Lock module and set up kernel thread */
 	/* lockd_up is waiting for us to startup, so will
@@ -112,6 +114,10 @@ lockd(struct svc_rqst *rqstp)
 	up(&lockd_start);
 
 	daemonize("lockd");
+	current->flags |= PF_SYNCTHREAD;
+
+	SWSUSP_THREAD_FLAGS_RESET;
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
 
 	/* Process request with signals blocked, but allow SIGKILL.  */
 	allow_signal(SIGKILL);
@@ -135,6 +141,10 @@ lockd(struct svc_rqst *rqstp)
 	while ((nlmsvc_users || !signalled()) && nlmsvc_pid == current->pid) {
 		long timeout = MAX_SCHEDULE_TIMEOUT;
 
+		/* Chance for lockd to refrigerate */
+		SWSUSP_ACTIVITY_SYNCTHREAD_PAUSING;
+		SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
+
 		if (signalled()) {
 			flush_signals(current);
 			if (nlmsvc_ops) {
@@ -195,6 +205,8 @@ lockd(struct svc_rqst *rqstp)
 	/* release rpciod */
 	rpciod_down();
 
+	SWSUSP_ACTIVITY_END;
+
 	/* Release module */
 	unlock_kernel();
 	module_put_and_exit(0);
diff -puN fs/locks.c~20-software-suspend-linux-2.6.7-rev1-whole fs/locks.c
--- linux-2.6.7-xx2/fs/locks.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.230874120 -0400
+++ linux-2.6.7-xx2-xiphux/fs/locks.c	2004-06-24 07:14:54.686804808 -0400
@@ -123,6 +123,7 @@
 #include <linux/slab.h>
 #include <linux/smp_lock.h>
 #include <linux/time.h>
+#include <linux/suspend.h>
 
 #include <asm/semaphore.h>
 #include <asm/uaccess.h>
@@ -571,13 +572,16 @@ static int interruptible_sleep_on_locked
 {
 	int result = 0;
 	DECLARE_WAITQUEUE(wait, current);
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	__set_current_state(TASK_INTERRUPTIBLE);
 	add_wait_queue(fl_wait, &wait);
+	SWSUSP_ACTIVITY_PAUSING;
 	if (timeout == 0)
 		schedule();
 	else
 		result = schedule_timeout(timeout);
+	SWSUSP_ACTIVITY_RESTARTING(0);
 	if (signal_pending(current))
 		result = -ERESTARTSYS;
 	remove_wait_queue(fl_wait, &wait);
@@ -1319,6 +1323,9 @@ asmlinkage long sys_flock(unsigned int f
 	struct file_lock *lock;
 	int can_sleep, unlock;
 	int error;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	error = -EBADF;
 	filp = fget(fd);
@@ -1362,6 +1369,7 @@ asmlinkage long sys_flock(unsigned int f
  out_putf:
 	fput(filp);
  out:
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 
diff -puN fs/namei.c~20-software-suspend-linux-2.6.7-rev1-whole fs/namei.c
--- linux-2.6.7-xx2/fs/namei.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.233873664 -0400
+++ linux-2.6.7-xx2-xiphux/fs/namei.c	2004-06-24 07:14:54.692803896 -0400
@@ -27,6 +27,7 @@
 #include <linux/security.h>
 #include <linux/mount.h>
 #include <linux/audit.h>
+#include <linux/suspend.h>
 #include <asm/namei.h>
 #include <asm/uaccess.h>
 
@@ -1476,12 +1477,18 @@ asmlinkage long sys_mknod(const char __u
 	char * tmp;
 	struct dentry * dentry;
 	struct nameidata nd;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	if (S_ISDIR(mode))
 		return -EPERM;
+
+	SWSUSP_ACTIVITY_START(0);
+
 	tmp = getname(filename);
-	if (IS_ERR(tmp))
+	if (IS_ERR(tmp)) {
+		SWSUSP_ACTIVITY_END;
 		return PTR_ERR(tmp);
+	}
 
 	error = path_lookup(tmp, LOOKUP_PARENT, &nd);
 	if (error)
@@ -1515,6 +1522,7 @@ asmlinkage long sys_mknod(const char __u
 	path_release(&nd);
 out:
 	putname(tmp);
+	SWSUSP_ACTIVITY_END;
 
 	return error;
 }
@@ -1547,6 +1555,9 @@ asmlinkage long sys_mkdir(const char __u
 {
 	int error = 0;
 	char * tmp;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	tmp = getname(pathname);
 	error = PTR_ERR(tmp);
@@ -1571,6 +1582,7 @@ out:
 		putname(tmp);
 	}
 
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 
@@ -1646,10 +1658,15 @@ asmlinkage long sys_rmdir(const char __u
 	char * name;
 	struct dentry *dentry;
 	struct nameidata nd;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	name = getname(pathname);
-	if(IS_ERR(name))
+	if(IS_ERR(name)) {
+		SWSUSP_ACTIVITY_END;
 		return PTR_ERR(name);
+	}
 
 	error = path_lookup(name, LOOKUP_PARENT, &nd);
 	if (error)
@@ -1678,6 +1695,7 @@ exit1:
 	path_release(&nd);
 exit:
 	putname(name);
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 
@@ -1724,10 +1742,15 @@ asmlinkage long sys_unlink(const char __
 	struct dentry *dentry;
 	struct nameidata nd;
 	struct inode *inode = NULL;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	name = getname(pathname);
-	if(IS_ERR(name))
+	if(IS_ERR(name)) {
+		SWSUSP_ACTIVITY_END;
 		return PTR_ERR(name);
+	}
 
 	error = path_lookup(name, LOOKUP_PARENT, &nd);
 	if (error)
@@ -1757,6 +1780,7 @@ exit:
 
 	if (inode)
 		iput(inode);	/* truncate the inode here */
+	SWSUSP_ACTIVITY_END;
 	return error;
 
 slashes:
@@ -1793,10 +1817,15 @@ asmlinkage long sys_symlink(const char _
 	int error = 0;
 	char * from;
 	char * to;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	from = getname(oldname);
-	if(IS_ERR(from))
+	if(IS_ERR(from)) {
+		SWSUSP_ACTIVITY_END;
 		return PTR_ERR(from);
+	}
 	to = getname(newname);
 	error = PTR_ERR(to);
 	if (!IS_ERR(to)) {
@@ -1818,6 +1847,7 @@ out:
 		putname(to);
 	}
 	putname(from);
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 
@@ -1876,10 +1906,15 @@ asmlinkage long sys_link(const char __us
 	struct nameidata nd, old_nd;
 	int error;
 	char * to;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	to = getname(newname);
-	if (IS_ERR(to))
+	if (IS_ERR(to)) {
+		SWSUSP_ACTIVITY_END;
 		return PTR_ERR(to);
+	}
 
 	error = __user_walk(oldname, 0, &old_nd);
 	if (error)
@@ -1904,6 +1939,7 @@ out:
 exit:
 	putname(to);
 
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 
@@ -2136,10 +2172,15 @@ asmlinkage long sys_rename(const char __
 	int error;
 	char * from;
 	char * to;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	from = getname(oldname);
-	if(IS_ERR(from))
+	if(IS_ERR(from)) {
+		SWSUSP_ACTIVITY_END;
 		return PTR_ERR(from);
+	}
 	to = getname(newname);
 	error = PTR_ERR(to);
 	if (!IS_ERR(to)) {
@@ -2147,6 +2188,7 @@ asmlinkage long sys_rename(const char __
 		putname(to);
 	}
 	putname(from);
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 
diff -puN fs/namespace.c~20-software-suspend-linux-2.6.7-rev1-whole fs/namespace.c
--- linux-2.6.7-xx2/fs/namespace.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.237873056 -0400
+++ linux-2.6.7-xx2-xiphux/fs/namespace.c	2004-06-24 07:14:54.694803592 -0400
@@ -21,6 +21,7 @@
 #include <linux/namei.h>
 #include <linux/security.h>
 #include <linux/mount.h>
+#include <linux/suspend.h>
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
 
@@ -445,6 +446,9 @@ asmlinkage long sys_umount(char __user *
 {
 	struct nameidata nd;
 	int retval;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	retval = __user_walk(name, LOOKUP_FOLLOW, &nd);
 	if (retval)
@@ -463,6 +467,7 @@ asmlinkage long sys_umount(char __user *
 dput_and_out:
 	path_release(&nd);
 out:
+	SWSUSP_ACTIVITY_END;
 	return retval;
 }
 
@@ -969,10 +974,15 @@ asmlinkage long sys_mount(char __user * 
 	unsigned long type_page;
 	unsigned long dev_page;
 	char *dir_page;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	retval = copy_mount_options (type, &type_page);
-	if (retval < 0)
+	if (retval < 0) {
+		SWSUSP_ACTIVITY_END;
 		return retval;
+	}
 
 	dir_page = getname(dir_name);
 	retval = PTR_ERR(dir_page);
@@ -999,6 +1009,7 @@ out2:
 	putname(dir_page);
 out1:
 	free_page(type_page);
+	SWSUSP_ACTIVITY_END;
 	return retval;
 }
 
@@ -1091,10 +1102,12 @@ asmlinkage long sys_pivot_root(const cha
 	struct vfsmount *tmp;
 	struct nameidata new_nd, old_nd, parent_nd, root_parent, user_nd;
 	int error;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
+	SWSUSP_ACTIVITY_START(0);
 	lock_kernel();
 
 	error = __user_walk(new_root, LOOKUP_FOLLOW|LOOKUP_DIRECTORY, &new_nd);
@@ -1171,6 +1184,7 @@ out1:
 	path_release(&new_nd);
 out0:
 	unlock_kernel();
+	SWSUSP_ACTIVITY_END;
 	return error;
 out3:
 	spin_unlock(&vfsmount_lock);
diff -puN fs/nfsd/nfssvc.c~20-software-suspend-linux-2.6.7-rev1-whole fs/nfsd/nfssvc.c
--- linux-2.6.7-xx2/fs/nfsd/nfssvc.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.240872600 -0400
+++ linux-2.6.7-xx2-xiphux/fs/nfsd/nfssvc.c	2004-06-24 07:14:54.696803288 -0400
@@ -21,6 +21,7 @@
 #include <linux/smp.h>
 #include <linux/smp_lock.h>
 #include <linux/fs_struct.h>
+#include <linux/suspend.h>
 
 #include <linux/sunrpc/types.h>
 #include <linux/sunrpc/stats.h>
@@ -176,11 +177,16 @@ nfsd(struct svc_rqst *rqstp)
 	int		err;
 	struct nfsd_list me;
 	sigset_t shutdown_mask, allowed_mask;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	/* Lock module and set up kernel thread */
 	lock_kernel();
 	daemonize("nfsd");
 	current->rlim[RLIMIT_FSIZE].rlim_cur = RLIM_INFINITY;
+	current->flags |= PF_SYNCTHREAD;
+
+	SWSUSP_THREAD_FLAGS_RESET;
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
 
 	/* After daemonize() this kernel thread shares current->fs
 	 * with the init process. We need to create files with a
@@ -282,6 +288,8 @@ out:
 	/* Release the thread */
 	svc_exit_thread(rqstp);
 
+	SWSUSP_ACTIVITY_END;
+
 	/* Release module */
 	module_put_and_exit(0);
 }
diff -puN fs/open.c~20-software-suspend-linux-2.6.7-rev1-whole fs/open.c
--- linux-2.6.7-xx2/fs/open.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.241872448 -0400
+++ linux-2.6.7-xx2-xiphux/fs/open.c	2004-06-24 07:14:54.699802832 -0400
@@ -19,6 +19,7 @@
 #include <linux/security.h>
 #include <linux/mount.h>
 #include <linux/vfs.h>
+#include <linux/suspend.h>
 #include <asm/uaccess.h>
 #include <linux/fs.h>
 #include <linux/pagemap.h>
@@ -120,6 +121,9 @@ asmlinkage long sys_statfs(const char __
 {
 	struct nameidata nd;
 	int error;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	error = user_path_walk(path, &nd);
 	if (!error) {
@@ -129,6 +133,7 @@ asmlinkage long sys_statfs(const char __
 			error = -EFAULT;
 		path_release(&nd);
 	}
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 
@@ -137,9 +142,13 @@ asmlinkage long sys_statfs64(const char 
 {
 	struct nameidata nd;
 	long error;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	if (sz != sizeof(*buf))
 		return -EINVAL;
+
+	SWSUSP_ACTIVITY_START(0);
+
 	error = user_path_walk(path, &nd);
 	if (!error) {
 		struct statfs64 tmp;
@@ -148,6 +157,7 @@ asmlinkage long sys_statfs64(const char 
 			error = -EFAULT;
 		path_release(&nd);
 	}
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 
@@ -157,6 +167,9 @@ asmlinkage long sys_fstatfs(unsigned int
 	struct file * file;
 	struct statfs tmp;
 	int error;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	error = -EBADF;
 	file = fget(fd);
@@ -167,6 +180,7 @@ asmlinkage long sys_fstatfs(unsigned int
 		error = -EFAULT;
 	fput(file);
 out:
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 
@@ -175,10 +189,13 @@ asmlinkage long sys_fstatfs64(unsigned i
 	struct file * file;
 	struct statfs64 tmp;
 	int error;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	if (sz != sizeof(*buf))
 		return -EINVAL;
 
+	SWSUSP_ACTIVITY_START(0);
+
 	error = -EBADF;
 	file = fget(fd);
 	if (!file)
@@ -188,6 +205,7 @@ asmlinkage long sys_fstatfs64(unsigned i
 		error = -EFAULT;
 	fput(file);
 out:
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 
@@ -215,6 +233,9 @@ static inline long do_sys_truncate(const
 	struct nameidata nd;
 	struct inode * inode;
 	int error;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	error = -EINVAL;
 	if (length < 0)	/* sorry, but loff_t says... */
@@ -267,6 +288,7 @@ static inline long do_sys_truncate(const
 dput_and_out:
 	path_release(&nd);
 out:
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 
@@ -282,6 +304,9 @@ static inline long do_sys_ftruncate(unsi
 	struct dentry *dentry;
 	struct file * file;
 	int error;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	error = -EINVAL;
 	if (length < 0)
@@ -316,6 +341,7 @@ static inline long do_sys_ftruncate(unsi
 out_putf:
 	fput(file);
 out:
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 
@@ -356,6 +382,9 @@ asmlinkage long sys_utime(char __user * 
 	struct nameidata nd;
 	struct inode * inode;
 	struct iattr newattrs;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	error = user_path_walk(filename, &nd);
 	if (error)
@@ -397,6 +426,7 @@ asmlinkage long sys_utime(char __user * 
 dput_and_out:
 	path_release(&nd);
 out:
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 
@@ -412,6 +442,9 @@ long do_utimes(char __user * filename, s
 	struct nameidata nd;
 	struct inode * inode;
 	struct iattr newattrs;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	error = user_path_walk(filename, &nd);
 
@@ -450,6 +483,7 @@ long do_utimes(char __user * filename, s
 dput_and_out:
 	path_release(&nd);
 out:
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 
@@ -474,10 +508,13 @@ asmlinkage long sys_access(const char __
 	int old_fsuid, old_fsgid;
 	kernel_cap_t old_cap;
 	int res;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	if (mode & ~S_IRWXO)	/* where's F_OK, X_OK, W_OK, R_OK? */
 		return -EINVAL;
 
+	SWSUSP_ACTIVITY_START(0);
+
 	old_fsuid = current->fsuid;
 	old_fsgid = current->fsgid;
 	old_cap = current->cap_effective;
@@ -512,6 +549,7 @@ asmlinkage long sys_access(const char __
 	current->fsgid = old_fsgid;
 	current->cap_effective = old_cap;
 
+	SWSUSP_ACTIVITY_END;
 	return res;
 }
 
@@ -519,6 +557,9 @@ asmlinkage long sys_chdir(const char __u
 {
 	struct nameidata nd;
 	int error;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	error = __user_walk(filename, LOOKUP_FOLLOW|LOOKUP_DIRECTORY, &nd);
 	if (error)
@@ -533,6 +574,7 @@ asmlinkage long sys_chdir(const char __u
 dput_and_out:
 	path_release(&nd);
 out:
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 
@@ -543,6 +585,9 @@ asmlinkage long sys_fchdir(unsigned int 
 	struct inode *inode;
 	struct vfsmount *mnt;
 	int error;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	error = -EBADF;
 	file = fget(fd);
@@ -563,6 +608,7 @@ asmlinkage long sys_fchdir(unsigned int 
 out_putf:
 	fput(file);
 out:
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 
@@ -570,6 +616,9 @@ asmlinkage long sys_chroot(const char __
 {
 	struct nameidata nd;
 	int error;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	error = __user_walk(filename, LOOKUP_FOLLOW | LOOKUP_DIRECTORY | LOOKUP_NOALT, &nd);
 	if (error)
@@ -589,6 +638,7 @@ asmlinkage long sys_chroot(const char __
 dput_and_out:
 	path_release(&nd);
 out:
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 
@@ -599,6 +649,9 @@ asmlinkage long sys_fchmod(unsigned int 
 	struct file * file;
 	int err = -EBADF;
 	struct iattr newattrs;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	file = fget(fd);
 	if (!file)
@@ -624,6 +677,7 @@ asmlinkage long sys_fchmod(unsigned int 
 out_putf:
 	fput(file);
 out:
+	SWSUSP_ACTIVITY_END;
 	return err;
 }
 
@@ -633,6 +687,9 @@ asmlinkage long sys_chmod(const char __u
 	struct inode * inode;
 	int error;
 	struct iattr newattrs;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	error = user_path_walk(filename, &nd);
 	if (error)
@@ -658,6 +715,7 @@ asmlinkage long sys_chmod(const char __u
 dput_and_out:
 	path_release(&nd);
 out:
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 
@@ -700,12 +758,16 @@ asmlinkage long sys_chown(const char __u
 {
 	struct nameidata nd;
 	int error;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	error = user_path_walk(filename, &nd);
 	if (!error) {
 		error = chown_common(nd.dentry, user, group);
 		path_release(&nd);
 	}
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 
@@ -713,12 +775,16 @@ asmlinkage long sys_lchown(const char __
 {
 	struct nameidata nd;
 	int error;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	error = user_path_walk_link(filename, &nd);
 	if (!error) {
 		error = chown_common(nd.dentry, user, group);
 		path_release(&nd);
 	}
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 
@@ -727,12 +793,16 @@ asmlinkage long sys_fchown(unsigned int 
 {
 	struct file * file;
 	int error = -EBADF;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	file = fget(fd);
 	if (file) {
 		error = chown_common(file->f_dentry, user, group);
 		fput(file);
 	}
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 
@@ -942,6 +1012,9 @@ asmlinkage long sys_open(const char __us
 {
 	char * tmp;
 	int fd, error;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 #if BITS_PER_LONG != 32
 	flags |= O_LARGEFILE;
@@ -960,6 +1033,7 @@ asmlinkage long sys_open(const char __us
 out:
 		putname(tmp);
 	}
+	SWSUSP_ACTIVITY_END;
 	return fd;
 
 out_error:
@@ -1023,6 +1097,9 @@ asmlinkage long sys_close(unsigned int f
 {
 	struct file * filp;
 	struct files_struct *files = current->files;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	spin_lock(&files->file_lock);
 	if (fd >= files->max_fds)
@@ -1034,10 +1111,12 @@ asmlinkage long sys_close(unsigned int f
 	FD_CLR(fd, files->close_on_exec);
 	__put_unused_fd(files, fd);
 	spin_unlock(&files->file_lock);
+	SWSUSP_ACTIVITY_END;
 	return filp_close(filp, files);
 
 out_unlock:
 	spin_unlock(&files->file_lock);
+	SWSUSP_ACTIVITY_END;
 	return -EBADF;
 }
 
@@ -1049,11 +1128,17 @@ EXPORT_SYMBOL(sys_close);
  */
 asmlinkage long sys_vhangup(void)
 {
+	int ret = -EPERM;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
+
 	if (capable(CAP_SYS_TTY_CONFIG)) {
 		tty_vhangup(current->signal->tty);
-		return 0;
+		ret = 0;
 	}
-	return -EPERM;
+	SWSUSP_ACTIVITY_END;
+	return ret;
 }
 
 /*
diff -puN fs/pipe.c~20-software-suspend-linux-2.6.7-rev1-whole fs/pipe.c
--- linux-2.6.7-xx2/fs/pipe.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.244871992 -0400
+++ linux-2.6.7-xx2-xiphux/fs/pipe.c	2004-06-24 07:14:54.700802680 -0400
@@ -14,6 +14,7 @@
 #include <linux/mount.h>
 #include <linux/pipe_fs_i.h>
 #include <linux/uio.h>
+#include <linux/suspend.h>
 #include <asm/uaccess.h>
 #include <asm/ioctls.h>
 
@@ -36,10 +37,13 @@
 void pipe_wait(struct inode * inode)
 {
 	DEFINE_WAIT(wait);
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	prepare_to_wait(PIPE_WAIT(*inode), &wait, TASK_INTERRUPTIBLE);
 	up(PIPE_SEM(*inode));
+	SWSUSP_ACTIVITY_PAUSING;
 	schedule();
+	SWSUSP_ACTIVITY_RESTARTING(0);
 	finish_wait(PIPE_WAIT(*inode), &wait);
 	down(PIPE_SEM(*inode));
 }
diff -puN fs/proc/generic.c~20-software-suspend-linux-2.6.7-rev1-whole fs/proc/generic.c
--- linux-2.6.7-xx2/fs/proc/generic.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.246871688 -0400
+++ linux-2.6.7-xx2-xiphux/fs/proc/generic.c	2004-06-24 07:14:54.702802376 -0400
@@ -17,6 +17,7 @@
 #include <linux/smp_lock.h>
 #include <linux/init.h>
 #include <linux/idr.h>
+#include <linux/suspend.h>
 #include <asm/uaccess.h>
 #include <asm/bitops.h>
 
@@ -187,6 +188,8 @@ proc_file_write(struct file *file, const
 {
 	struct inode *inode = file->f_dentry->d_inode;
 	struct proc_dir_entry * dp;
+	ssize_t result;
+	DECLARE_SWSUSP_LOCAL_VAR;
 	
 	dp = PDE(inode);
 
@@ -194,7 +197,10 @@ proc_file_write(struct file *file, const
 		return -EIO;
 
 	/* FIXME: does this routine need ppos?  probably... */
-	return dp->write_proc(file, buffer, count, dp->data);
+	SWSUSP_ACTIVITY_PAUSING;	/* Might be initiating suspend */
+	result = dp->write_proc(file, buffer, count, dp->data);
+	SWSUSP_ACTIVITY_RESTARTING(0);
+	return result;
 }
 
 
diff -puN fs/proc/kmsg.c~20-software-suspend-linux-2.6.7-rev1-whole fs/proc/kmsg.c
--- linux-2.6.7-xx2/fs/proc/kmsg.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.248871384 -0400
+++ linux-2.6.7-xx2-xiphux/fs/proc/kmsg.c	2004-06-24 07:14:54.703802224 -0400
@@ -11,6 +11,7 @@
 #include <linux/kernel.h>
 #include <linux/poll.h>
 #include <linux/fs.h>
+#include <linux/suspend.h>
 
 #include <asm/uaccess.h>
 #include <asm/io.h>
@@ -33,9 +34,16 @@ static int kmsg_release(struct inode * i
 static ssize_t kmsg_read(struct file *file, char __user *buf,
 			 size_t count, loff_t *ppos)
 {
+	ssize_t size;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
 	if ((file->f_flags & O_NONBLOCK) && !do_syslog(9, 0, 0))
 		return -EAGAIN;
-	return do_syslog(2, buf, count);
+
+	SWSUSP_ACTIVITY_PAUSING;
+	size = do_syslog(2, buf, count);
+	SWSUSP_ACTIVITY_RESTARTING(0);
+	return size;
 }
 
 static unsigned int kmsg_poll(struct file *file, poll_table *wait)
diff -puN fs/read_write.c~20-software-suspend-linux-2.6.7-rev1-whole fs/read_write.c
--- linux-2.6.7-xx2/fs/read_write.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.250871080 -0400
+++ linux-2.6.7-xx2-xiphux/fs/read_write.c	2004-06-24 07:14:54.705801920 -0400
@@ -13,6 +13,7 @@
 #include <linux/dnotify.h>
 #include <linux/security.h>
 #include <linux/module.h>
+#include <linux/suspend.h>
 
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
@@ -117,6 +118,9 @@ asmlinkage off_t sys_lseek(unsigned int 
 	off_t retval;
 	struct file * file;
 	int fput_needed;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	retval = -EBADF;
 	file = fget_light(fd, &fput_needed);
@@ -132,6 +136,7 @@ asmlinkage off_t sys_lseek(unsigned int 
 	}
 	fput_light(file, fput_needed);
 bad:
+	SWSUSP_ACTIVITY_END;
 	return retval;
 }
 EXPORT_SYMBOL_GPL(sys_lseek);
@@ -145,6 +150,9 @@ asmlinkage long sys_llseek(unsigned int 
 	struct file * file;
 	loff_t offset;
 	int fput_needed;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	retval = -EBADF;
 	file = fget_light(fd, &fput_needed);
@@ -167,6 +175,7 @@ asmlinkage long sys_llseek(unsigned int 
 out_putf:
 	fput_light(file, fput_needed);
 bad:
+	SWSUSP_ACTIVITY_END;
 	return retval;
 }
 #endif
@@ -264,12 +273,16 @@ asmlinkage ssize_t sys_read(unsigned int
 	struct file *file;
 	ssize_t ret = -EBADF;
 	int fput_needed;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	file = fget_light(fd, &fput_needed);
 	if (file) {
 		ret = vfs_read(file, buf, count, &file->f_pos);
 		fput_light(file, fput_needed);
 	}
+	SWSUSP_ACTIVITY_END;
 
 	return ret;
 }
@@ -280,6 +293,9 @@ asmlinkage ssize_t sys_write(unsigned in
 	struct file *file;
 	ssize_t ret = -EBADF;
 	int fput_needed;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	file = fget_light(fd, &fput_needed);
 	if (file) {
@@ -287,6 +303,7 @@ asmlinkage ssize_t sys_write(unsigned in
 		fput_light(file, fput_needed);
 	}
 
+	SWSUSP_ACTIVITY_END;
 	return ret;
 }
 
@@ -296,16 +313,20 @@ asmlinkage ssize_t sys_pread64(unsigned 
 	struct file *file;
 	ssize_t ret = -EBADF;
 	int fput_needed;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	if (pos < 0)
 		return -EINVAL;
 
+	SWSUSP_ACTIVITY_START(0);
+
 	file = fget_light(fd, &fput_needed);
 	if (file) {
 		ret = vfs_read(file, buf, count, &pos);
 		fput_light(file, fput_needed);
 	}
 
+	SWSUSP_ACTIVITY_END;
 	return ret;
 }
 
@@ -315,16 +336,19 @@ asmlinkage ssize_t sys_pwrite64(unsigned
 	struct file *file;
 	ssize_t ret = -EBADF;
 	int fput_needed;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	if (pos < 0)
 		return -EINVAL;
 
+	SWSUSP_ACTIVITY_START(0);
 	file = fget_light(fd, &fput_needed);
 	if (file) {
 		ret = vfs_write(file, buf, count, &pos);
 		fput_light(file, fput_needed);
 	}
 
+	SWSUSP_ACTIVITY_END;
 	return ret;
 }
 
@@ -502,13 +526,16 @@ sys_readv(unsigned long fd, const struct
 	struct file *file;
 	ssize_t ret = -EBADF;
 	int fput_needed;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
+	SWSUSP_ACTIVITY_START(0);
 	file = fget_light(fd, &fput_needed);
 	if (file) {
 		ret = vfs_readv(file, vec, vlen, &file->f_pos);
 		fput_light(file, fput_needed);
 	}
 
+	SWSUSP_ACTIVITY_END;
 	return ret;
 }
 
@@ -518,6 +545,9 @@ sys_writev(unsigned long fd, const struc
 	struct file *file;
 	ssize_t ret = -EBADF;
 	int fput_needed;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	file = fget_light(fd, &fput_needed);
 	if (file) {
@@ -525,6 +555,7 @@ sys_writev(unsigned long fd, const struc
 		fput_light(file, fput_needed);
 	}
 
+	SWSUSP_ACTIVITY_END;
 	return ret;
 }
 
@@ -615,33 +646,45 @@ asmlinkage ssize_t sys_sendfile(int out_
 	loff_t pos;
 	off_t off;
 	ssize_t ret;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	if (offset) {
 		if (unlikely(get_user(off, offset)))
-			return -EFAULT;
-		pos = off;
-		ret = do_sendfile(out_fd, in_fd, &pos, count, MAX_NON_LFS);
-		if (unlikely(put_user(pos, offset)))
-			return -EFAULT;
-		return ret;
-	}
+			ret = -EFAULT;
+		else {
+			pos = off;
+			ret = do_sendfile(out_fd, in_fd, &pos, count, MAX_NON_LFS);
+			if (unlikely(put_user(pos, offset)))
+				ret = -EFAULT;
+		}
+	} else
+		ret = do_sendfile(out_fd, in_fd, NULL, count, 0);
 
-	return do_sendfile(out_fd, in_fd, NULL, count, 0);
+	SWSUSP_ACTIVITY_END;
+	return ret;
 }
 
 asmlinkage ssize_t sys_sendfile64(int out_fd, int in_fd, loff_t __user *offset, size_t count)
 {
 	loff_t pos;
 	ssize_t ret;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	if (offset) {
 		if (unlikely(copy_from_user(&pos, offset, sizeof(loff_t))))
-			return -EFAULT;
-		ret = do_sendfile(out_fd, in_fd, &pos, count, 0);
-		if (unlikely(put_user(pos, offset)))
-			return -EFAULT;
-		return ret;
-	}
+			ret = -EFAULT;
+		else {
+			ret = do_sendfile(out_fd, in_fd, &pos, count, 0);
+			if (unlikely(put_user(pos, offset)))
+				ret = -EFAULT;
+		}
+	} else
+		ret = do_sendfile(out_fd, in_fd, NULL, count, 0);
 
-	return do_sendfile(out_fd, in_fd, NULL, count, 0);
+	SWSUSP_ACTIVITY_END;
+	return ret;
 }
diff -puN fs/reiserfs/journal.c~20-software-suspend-linux-2.6.7-rev1-whole fs/reiserfs/journal.c
--- linux-2.6.7-xx2/fs/reiserfs/journal.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.252870776 -0400
+++ linux-2.6.7-xx2-xiphux/fs/reiserfs/journal.c	2004-06-24 07:14:54.716800248 -0400
@@ -2483,7 +2483,7 @@ int journal_init(struct super_block *p_s
 
   reiserfs_mounted_fs_count++ ;
   if (reiserfs_mounted_fs_count <= 1)
-    commit_wq = create_workqueue("reiserfs");
+    commit_wq = create_workqueue("reiserfs", PF_SYNCTHREAD);
 
   INIT_WORK(&journal->j_work, flush_async_commits, p_s_sb);
   return 0 ;
diff -puN fs/select.c~20-software-suspend-linux-2.6.7-rev1-whole fs/select.c
--- linux-2.6.7-xx2/fs/select.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.255870320 -0400
+++ linux-2.6.7-xx2-xiphux/fs/select.c	2004-06-24 07:14:54.718799944 -0400
@@ -21,6 +21,7 @@
 #include <linux/personality.h> /* for STICKY_TIMEOUTS */
 #include <linux/file.h>
 #include <linux/fs.h>
+#include <linux/suspend.h>
 
 #include <asm/uaccess.h>
 
@@ -183,6 +184,7 @@ int do_select(int n, fd_set_bits *fds, l
 	poll_table *wait;
 	int retval, i;
 	long __timeout = *timeout;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
  	spin_lock(&current->files->file_lock);
 	retval = max_select_fd(n, fds);
@@ -190,6 +192,7 @@ int do_select(int n, fd_set_bits *fds, l
 
 	if (retval < 0)
 		return retval;
+
 	n = retval;
 
 	poll_initwait(&table);
@@ -258,7 +261,9 @@ int do_select(int n, fd_set_bits *fds, l
 			retval = table.error;
 			break;
 		}
+		SWSUSP_ACTIVITY_PAUSING;
 		__timeout = schedule_timeout(__timeout);
+		SWSUSP_ACTIVITY_RESTARTING(PF_FREEZE);
 	}
 	__set_current_state(TASK_RUNNING);
 
@@ -301,6 +306,9 @@ sys_select(int n, fd_set __user *inp, fd
 	char *bits;
 	long timeout;
 	int ret, size, max_fdset;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	timeout = MAX_SCHEDULE_TIMEOUT;
 	if (tvp) {
@@ -384,6 +392,7 @@ sys_select(int n, fd_set __user *inp, fd
 out:
 	select_bits_free(bits, size);
 out_nofds:
+	SWSUSP_ACTIVITY_END;
 	return ret;
 }
 
diff -puN fs/stat.c~20-software-suspend-linux-2.6.7-rev1-whole fs/stat.c
--- linux-2.6.7-xx2/fs/stat.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.257870016 -0400
+++ linux-2.6.7-xx2-xiphux/fs/stat.c	2004-06-24 07:14:54.720799640 -0400
@@ -14,6 +14,7 @@
 #include <linux/fs.h>
 #include <linux/namei.h>
 #include <linux/security.h>
+#include <linux/suspend.h>
 
 #include <asm/uaccess.h>
 #include <asm/unistd.h>
@@ -151,30 +152,42 @@ asmlinkage long sys_stat(char __user * f
 {
 	struct kstat stat;
 	int error = vfs_stat(filename, &stat);
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	if (!error)
 		error = cp_old_stat(&stat, statbuf);
 
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 asmlinkage long sys_lstat(char __user * filename, struct __old_kernel_stat __user * statbuf)
 {
 	struct kstat stat;
 	int error = vfs_lstat(filename, &stat);
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	if (!error)
 		error = cp_old_stat(&stat, statbuf);
 
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 asmlinkage long sys_fstat(unsigned int fd, struct __old_kernel_stat __user * statbuf)
 {
 	struct kstat stat;
 	int error = vfs_fstat(fd, &stat);
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	if (!error)
 		error = cp_old_stat(&stat, statbuf);
 
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 
@@ -232,30 +245,42 @@ asmlinkage long sys_newstat(char __user 
 {
 	struct kstat stat;
 	int error = vfs_stat(filename, &stat);
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	if (!error)
 		error = cp_new_stat(&stat, statbuf);
 
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 asmlinkage long sys_newlstat(char __user * filename, struct stat __user * statbuf)
 {
 	struct kstat stat;
 	int error = vfs_lstat(filename, &stat);
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	if (!error)
 		error = cp_new_stat(&stat, statbuf);
 
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 asmlinkage long sys_newfstat(unsigned int fd, struct stat __user * statbuf)
 {
 	struct kstat stat;
 	int error = vfs_fstat(fd, &stat);
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	if (!error)
 		error = cp_new_stat(&stat, statbuf);
 
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 
@@ -263,10 +288,13 @@ asmlinkage long sys_readlink(const char 
 {
 	struct nameidata nd;
 	int error;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	if (bufsiz <= 0)
 		return -EINVAL;
 
+	SWSUSP_ACTIVITY_START(0);
+
 	error = user_path_walk_link(path, &nd);
 	if (!error) {
 		struct inode * inode = nd.dentry->d_inode;
@@ -281,6 +309,7 @@ asmlinkage long sys_readlink(const char 
 		}
 		path_release(&nd);
 	}
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 
@@ -327,30 +356,42 @@ asmlinkage long sys_stat64(char __user *
 {
 	struct kstat stat;
 	int error = vfs_stat(filename, &stat);
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	if (!error)
 		error = cp_new_stat64(&stat, statbuf);
 
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 asmlinkage long sys_lstat64(char __user * filename, struct stat64 __user * statbuf)
 {
 	struct kstat stat;
 	int error = vfs_lstat(filename, &stat);
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	if (!error)
 		error = cp_new_stat64(&stat, statbuf);
 
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 asmlinkage long sys_fstat64(unsigned long fd, struct stat64 __user * statbuf)
 {
 	struct kstat stat;
 	int error = vfs_fstat(fd, &stat);
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
 	if (!error)
 		error = cp_new_stat64(&stat, statbuf);
 
+	SWSUSP_ACTIVITY_END;
 	return error;
 }
 
diff -puN fs/super.c~20-software-suspend-linux-2.6.7-rev1-whole fs/super.c
--- linux-2.6.7-xx2/fs/super.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.258869864 -0400
+++ linux-2.6.7-xx2-xiphux/fs/super.c	2004-06-24 07:14:54.722799336 -0400
@@ -36,6 +36,7 @@
 #include <linux/writeback.h>		/* for the emergency remount stuff */
 #include <linux/idr.h>
 #include <asm/uaccess.h>
+#include <linux/suspend.h>
 
 
 void get_filesystem(struct file_system_type *fs);
@@ -654,6 +655,9 @@ asmlinkage long sys_ustat(unsigned dev, 
         struct ustat tmp;
         struct kstatfs sbuf;
 	int err = -EINVAL;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_START(0);
 
         s = user_get_super(new_decode_dev(dev));
         if (s == NULL)
@@ -669,6 +673,7 @@ asmlinkage long sys_ustat(unsigned dev, 
 
         err = copy_to_user(ubuf,&tmp,sizeof(struct ustat)) ? -EFAULT : 0;
 out:
+	SWSUSP_ACTIVITY_END;
 	return err;
 }
 
diff -puN fs/sysfs/file.c~20-software-suspend-linux-2.6.7-rev1-whole fs/sysfs/file.c
--- linux-2.6.7-xx2/fs/sysfs/file.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.261869408 -0400
+++ linux-2.6.7-xx2-xiphux/fs/sysfs/file.c	2004-06-24 07:14:54.723799184 -0400
@@ -6,6 +6,7 @@
 #include <linux/dnotify.h>
 #include <linux/kobject.h>
 #include <linux/kallsyms.h>
+#include <linux/suspend.h>
 
 #include <asm/uaccess.h>
 
@@ -39,9 +40,12 @@ subsys_attr_store(struct kobject * kobj,
 	struct subsystem * s = to_subsys(kobj);
 	struct subsys_attribute * sattr = to_sattr(attr);
 	ssize_t ret = 0;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
+	SWSUSP_ACTIVITY_PAUSING;
 	if (sattr->store)
 		ret = sattr->store(s,page,count);
+	SWSUSP_ACTIVITY_RESTARTING(0);
 	return ret;
 }
 
diff -puN fs/xfs/linux-2.6/xfs_buf.c~20-software-suspend-linux-2.6.7-rev1-whole fs/xfs/linux-2.6/xfs_buf.c
--- linux-2.6.7-xx2/fs/xfs/linux-2.6/xfs_buf.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.287865456 -0400
+++ linux-2.6.7-xx2-xiphux/fs/xfs/linux-2.6/xfs_buf.c	2004-06-24 07:14:54.725798880 -0400
@@ -1601,10 +1601,14 @@ pagebuf_daemon(
 	struct list_head	tmp;
 	unsigned long		age;
 	xfs_buf_t		*pb, *n;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	/*  Set up the thread  */
 	daemonize("xfsbufd");
-	current->flags |= PF_MEMALLOC;
+	current->flags |= PF_MEMALLOC | PF_SYNCTHREAD;
+
+	SWSUSP_THREAD_FLAGS_RESET;
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
 
 	pagebuf_daemon_task = current;
 	pagebuf_daemon_active = 1;
@@ -1612,13 +1616,12 @@ pagebuf_daemon(
 
 	INIT_LIST_HEAD(&tmp);
 	do {
-		/* swsusp */
-		if (current->flags & PF_FREEZE)
-			refrigerator(PF_FREEZE);
+ 		SWSUSP_ACTIVITY_SYNCTHREAD_PAUSING;
 
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout((xfs_buf_timer_centisecs * HZ) / 100);
 
+		SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 		age = (xfs_buf_age_centisecs * HZ) / 100;
 		spin_lock(&pbd_delwrite_lock);
 		list_for_each_entry_safe(pb, n, &pbd_delwrite_queue, pb_list) {
@@ -1653,6 +1656,7 @@ pagebuf_daemon(
 		force_flush = 0;
 	} while (pagebuf_daemon_active);
 
+	SWSUSP_ACTIVITY_END;
 	complete_and_exit(&pagebuf_daemon_done, 0);
 }
 
@@ -1728,11 +1732,11 @@ pagebuf_daemon_start(void)
 {
 	int		rval;
 
-	pagebuf_logio_workqueue = create_workqueue("xfslogd");
+	pagebuf_logio_workqueue = create_workqueue("xfslogd", PF_SYNCTHREAD);
 	if (!pagebuf_logio_workqueue)
 		return -ENOMEM;
 
-	pagebuf_dataio_workqueue = create_workqueue("xfsdatad");
+	pagebuf_dataio_workqueue = create_workqueue("xfsdatad", PF_SYNCTHREAD);
 	if (!pagebuf_dataio_workqueue) {
 		destroy_workqueue(pagebuf_logio_workqueue);
 		return -ENOMEM;
diff -puN fs/xfs/linux-2.6/xfs_super.c~20-software-suspend-linux-2.6.7-rev1-whole fs/xfs/linux-2.6/xfs_super.c
--- linux-2.6.7-xx2/fs/xfs/linux-2.6/xfs_super.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.290865000 -0400
+++ linux-2.6.7-xx2-xiphux/fs/xfs/linux-2.6/xfs_super.c	2004-06-24 07:14:54.728798424 -0400
@@ -383,19 +383,23 @@ xfssyncd(
 {
 	vfs_t			*vfsp = (vfs_t *) arg;
 	int			error;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	daemonize("xfssyncd");
+	current->flags |= PF_SYNCTHREAD;
 
 	vfsp->vfs_sync_task = current;
 	wmb();
 	wake_up(&vfsp->vfs_wait_sync_task);
 
+	SWSUSP_THREAD_FLAGS_RESET;
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
+
 	for (;;) {
+		SWSUSP_ACTIVITY_SYNCTHREAD_PAUSING;
 		set_current_state(TASK_INTERRUPTIBLE);
 		schedule_timeout((xfs_syncd_centisecs * HZ) / 100);
-		/* swsusp */
-		if (current->flags & PF_FREEZE)
-			refrigerator(PF_FREEZE);
+		SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 		if (vfsp->vfs_flag & VFS_UMOUNT)
 			break;
 		if (vfsp->vfs_flag & VFS_RDONLY)
@@ -407,6 +411,7 @@ xfssyncd(
 		wake_up(&vfsp->vfs_wait_single_sync_task);
 	}
 
+	SWSUSP_ACTIVITY_END;
 	vfsp->vfs_sync_task = NULL;
 	wmb();
 	wake_up(&vfsp->vfs_wait_sync_task);
diff -puN include/asm-i386/cpufeature.h~20-software-suspend-linux-2.6.7-rev1-whole include/asm-i386/cpufeature.h
--- linux-2.6.7-xx2/include/asm-i386/cpufeature.h~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.292864696 -0400
+++ linux-2.6.7-xx2-xiphux/include/asm-i386/cpufeature.h	2004-06-24 07:14:54.730798120 -0400
@@ -89,6 +89,7 @@
 #define cpu_has_vme		boot_cpu_has(X86_FEATURE_VME)
 #define cpu_has_de		boot_cpu_has(X86_FEATURE_DE)
 #define cpu_has_pse		boot_cpu_has(X86_FEATURE_PSE)
+#define cpu_has_pse36		boot_cpu_has(X86_FEATURE_PSE36)
 #define cpu_has_tsc		boot_cpu_has(X86_FEATURE_TSC)
 #define cpu_has_pae		boot_cpu_has(X86_FEATURE_PAE)
 #define cpu_has_pge		boot_cpu_has(X86_FEATURE_PGE)
diff -puN include/asm-i386/mtrr.h~20-software-suspend-linux-2.6.7-rev1-whole include/asm-i386/mtrr.h
--- linux-2.6.7-xx2/include/asm-i386/mtrr.h~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.294864392 -0400
+++ linux-2.6.7-xx2-xiphux/include/asm-i386/mtrr.h	2004-06-24 07:14:54.755794320 -0400
@@ -106,4 +106,8 @@ static __inline__ void mtrr_centaur_repo
 
 #endif
 
+/* Save and restore functions for Software Suspend */
+extern int *mtrr_suspend(void);
+extern void mtrr_resume(int *ptr);
+
 #endif  /*  _LINUX_MTRR_H  */
diff -puN include/asm-i386/suspend.h~20-software-suspend-linux-2.6.7-rev1-whole include/asm-i386/suspend.h
--- linux-2.6.7-xx2/include/asm-i386/suspend.h~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.296864088 -0400
+++ linux-2.6.7-xx2-xiphux/include/asm-i386/suspend.h	2004-06-24 07:14:54.756794168 -0400
@@ -9,6 +9,10 @@
 static inline int
 arch_prepare_suspend(void)
 {
+	/* If you want to make non-PSE machine work, turn off paging
+	   in do_magic. swsusp_pg_dir should have identity mapping, so
+	   it could work...
+	 */
 	if (!cpu_has_pse)
 		return -EPERM;
 	return 0;
diff -puN include/asm-i386/tlbflush.h~20-software-suspend-linux-2.6.7-rev1-whole include/asm-i386/tlbflush.h
--- linux-2.6.7-xx2/include/asm-i386/tlbflush.h~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.298863784 -0400
+++ linux-2.6.7-xx2-xiphux/include/asm-i386/tlbflush.h	2004-06-24 07:14:54.757794016 -0400
@@ -82,6 +82,7 @@ extern unsigned long pgkern_mask;
 #define flush_tlb() __flush_tlb()
 #define flush_tlb_all() __flush_tlb_all()
 #define local_flush_tlb() __flush_tlb()
+#define local_flush_tlb_all() __flush_tlb_all();
 
 static inline void flush_tlb_mm(struct mm_struct *mm)
 {
@@ -114,6 +115,10 @@ extern void flush_tlb_all(void);
 extern void flush_tlb_current_task(void);
 extern void flush_tlb_mm(struct mm_struct *);
 extern void flush_tlb_page(struct vm_area_struct *, unsigned long);
+extern void do_flush_tlb_all(void * info);
+
+#define local_flush_tlb_all() \
+	do_flush_tlb_all(NULL);
 
 #define flush_tlb()	flush_tlb_current_task()
 
diff -puN /dev/null include/asm-ppc/suspend.h
--- /dev/null	2004-05-31 17:36:38.000000000 -0400
+++ linux-2.6.7-xx2-xiphux/include/asm-ppc/suspend.h	2004-06-24 07:14:54.758793864 -0400
@@ -0,0 +1,14 @@
+#ifndef _PPC_SUSPEND_H
+#define _PPC_SUSPEND_H
+
+static inline void flush_tlb_all(void)
+{
+	/* Flush all TLBs */
+	__asm__ __volatile__("lis 4, 0x1000");
+	__asm__ __volatile__("1: addic. 4,4,-0x1000");
+	__asm__ __volatile__("tlbie 4");
+	__asm__ __volatile__("blt 1b");
+	__asm__ __volatile__("sync");
+}
+
+#endif
diff -puN include/linux/kthread.h~20-software-suspend-linux-2.6.7-rev1-whole include/linux/kthread.h
--- linux-2.6.7-xx2/include/linux/kthread.h~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.300863480 -0400
+++ linux-2.6.7-xx2-xiphux/include/linux/kthread.h	2004-06-24 07:14:54.759793712 -0400
@@ -25,20 +25,26 @@
  */
 struct task_struct *kthread_create(int (*threadfn)(void *data),
 				   void *data,
+				   unsigned long freezer_flags,
 				   const char namefmt[], ...);
 
 /**
  * kthread_run: create and wake a thread.
  * @threadfn: the function to run until signal_pending(current).
  * @data: data ptr for @threadfn.
+ * @freezer_flags: process flags that should be used for freezing.
+ * 	PF_SYNCTHREAD if needed for syncing data to disk.
+ * 	PF_NOFREEZE if also needed for writing the image.
+ * 	0 otherwise.
  * @namefmt: printf-style name for the thread.
  *
  * Description: Convenient wrapper for kthread_create() followed by
  * wake_up_process().  Returns the kthread, or ERR_PTR(-ENOMEM). */
-#define kthread_run(threadfn, data, namefmt, ...)			   \
+#define kthread_run(threadfn, data, freezer_flags, namefmt, ...)	   \
 ({									   \
 	struct task_struct *__k						   \
-		= kthread_create(threadfn, data, namefmt, ## __VA_ARGS__); \
+		= kthread_create(threadfn, data, freezer_flags, 	   \
+			namefmt, ## __VA_ARGS__);			   \
 	if (!IS_ERR(__k))						   \
 		wake_up_process(__k);					   \
 	__k;								   \
diff -puN include/linux/sched.h~20-software-suspend-linux-2.6.7-rev1-whole include/linux/sched.h
--- linux-2.6.7-xx2/include/linux/sched.h~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.303863024 -0400
+++ linux-2.6.7-xx2-xiphux/include/linux/sched.h	2004-06-24 07:14:54.762793256 -0400
@@ -686,7 +686,7 @@ do { if (atomic_dec_and_test(&(tsk)->usa
 #define PF_MEMDIE	0x00001000	/* Killed for out-of-memory */
 #define PF_FLUSHER	0x00002000	/* responsible for disk writeback */
 
-#define PF_FREEZE	0x00004000	/* this task should be frozen for suspend */
+#define PF_FREEZE	0x00004000	/* this task is being frozen for suspend now */
 #define PF_NOFREEZE	0x00008000	/* this thread should not be frozen */
 #define PF_FROZEN	0x00010000	/* frozen for system suspend */
 #define PF_FSTRANS	0x00020000	/* inside a filesystem transaction */
@@ -694,6 +694,10 @@ do { if (atomic_dec_and_test(&(tsk)->usa
 #define PF_SWAPOFF	0x00080000	/* I am in swapoff */
 #define PF_LESS_THROTTLE 0x00100000	/* Throttle me less: I clean memory */
 #define PF_SYNCWRITE	0x00200000	/* I am doing a sync write */
+#define PF_REFRIGERATE	0x00400000	/* This task should be refrigerated */
+#define PF_SYNCTHREAD	0x00800000	/* this thread can start activity during the
+					   early part of freezing processes */
+#define PF_FRIDGE_WAIT	0x01000000	/* this thread is currently doing I/O */
 
 #ifdef CONFIG_EBS
 /*
diff -puN /dev/null include/linux/suspend-version-specific.h
--- /dev/null	2004-05-31 17:36:38.000000000 -0400
+++ linux-2.6.7-xx2-xiphux/include/linux/suspend-version-specific.h	2004-06-24 07:14:54.763793104 -0400
@@ -0,0 +1,122 @@
+/*
+ * Software Suspend header file.
+ *
+ * This file sets the major and minor version numbers of the version specific
+ * part of the Software Suspend patch. The major and minor numbers must match
+ * those of the core patch. The extra is updated as necessary for version
+ * specific changes.
+ */
+
+#ifndef SWSUSP_VERSION_SPECIFIC_REVISION
+#define SWSUSP_VERSION_SPECIFIC_REVISION 0x201
+#define SWSUSP_VERSION_SPECIFIC_REVISION_STRING "2.0.1"
+
+#ifdef CONFIG_BOOTSPLASH
+#include <linux/console.h>
+#include "../../drivers/video/console/fbcon.h"
+static inline struct splash_data * get_splash_data(int consolenr)
+{
+	BUG_ON(consolenr >= MAX_NR_CONSOLES);
+
+	if (vc_cons[consolenr].d)
+		return vc_cons[consolenr].d->vc_splash_data;
+
+	return NULL;
+}
+#endif
+
+/* --- Definitions for swapwriter */
+#include <linux/blkdev.h>
+#include <linux/swapops.h>
+#include <linux/buffer_head.h>
+
+#define DEVICE_ID_TYPE dev_t
+#define DEVICE_BLOCK_TYPE struct block_device *
+#define DEVICE_BLOCK_NONE NULL
+#define SYS_IO_STRUCT struct bio
+#define SYS_ZONE_TYPE long
+#define SIG_BDEV_START 2
+#define SWP_OFFSET swp_offset
+#define SWP_TYPE swp_type
+#define SWP_ENTRY swp_entry
+#define UNUSED_SWAP_ENTRY(i) (!swap_info[i].swap_file)
+#define SWAP_FILE_INODE(i) swap_info[i].swap_file->f_dentry->d_inode
+#define SWAP_IS_PARTITION(i) (S_ISBLK(SWAP_FILE_INODE(i)->i_mode))
+#define SWAP_DEVICE_ID(i) (SWAP_FILE_INODE(i)->i_rdev)
+#define SWAP_DEVICE_BDEV(i) (swap_info[i].bdev)
+#define BDEV_TO_DEVICE_ID(bdev) ((bdev)->bd_dev)
+#define SWAP_BLOCKSIZE(bdev) (block_size(bdev))
+#define RESUME_BDEV(i) swap_info[i].bdev
+extern void kblockd_flush(void);
+#define RUN_IO do { \
+	int device; \
+	for (device = 0; device < MAX_SWAPFILES; device++) \
+		if (SWAP_DEVICE_BDEV(device)) \
+			generic_unplug_device(bdev_get_queue(SWAP_DEVICE_BDEV(device))); \
+	/* kblockd_flush(); io_schedule(); */ \
+	} while(0)
+extern asmlinkage long sys_sync(void);
+#define SYNC_IO do { RUN_IO; sys_sync(); schedule(); \
+	check_shift_keys(0, NULL); } while(0)
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,3)
+#define OPEN_BY_DEVNUM(device, mode) open_by_devnum(device, mode)
+#else
+#define OPEN_BY_DEVNUM(device, mode) \
+			open_by_devnum(device, mode, BDEV_RAW)
+#endif
+
+/* --- End of definitions for swapwriter */
+
+#define NUM_CPUS num_online_cpus()
+#define MIN min
+#define MAX max
+#define PROCESS_SIG_MASK(p) &p->sighand->siglock
+#define RECALC_SIGPENDING recalc_sigpending()
+#define FOR_EACH_THREAD_TASK_STRUCTS *p, *g
+#define FOR_EACH_THREAD_START do_each_thread(g, p)
+#define FOR_EACH_THREAD_END while_each_thread(g, p);
+#define THREAD_PREEMPT_COUNT preempt_count()
+#define WAKE_UP(p) signal_wake_up(p, 0)
+#define FREE_AREA_TYPE struct free_area
+#define ZONE_TYPE struct zone
+#define STORAGE_UNSUSPEND
+#define STORAGE_SUSPEND
+#define EAT_MEMORY_FLAGS GFP_ATOMIC | __GFP_NOWARN
+#define CPU0_MASK (cpumask_of_cpu(0))
+
+extern asmlinkage ssize_t sys_write(unsigned int fd, const char __user * buf, size_t count);
+
+#define INACTIVE_LIST_FOR_EACH(procedure) \
+do { \
+ if (zone->nr_inactive) { \
+  struct list_head * entry = zone->inactive_list.prev; \
+  while (entry != &zone->inactive_list) { \
+   struct page * page = list_entry(entry, struct page, lru); \
+   { \
+    procedure(page); \
+   } \
+   entry = entry->prev; \
+  } \
+ } \
+} while(0)
+
+#define ACTIVE_LIST_FOR_EACH(procedure) \
+do { \
+ if (zone->nr_active) { \
+  struct list_head * entry = zone->active_list.prev; \
+  while (entry != &zone->active_list) { \
+   struct page * page; \
+   page = list_entry(entry, struct page, lru); \
+   procedure(page); \
+   entry = entry->prev; \
+  } \
+ } \
+} while(0)
+
+extern void disable_pcp_lists(void);
+extern void enable_pcp_lists(void);
+
+#define KMAP_ATOMIC(a) kmap_atomic(a, KM_USER1)
+#define KUNMAP_ATOMIC(a) kunmap_atomic(a, KM_USER1)
+
+#endif
diff -puN -L include/linux/suspend.h include/linux/suspend.h~20-software-suspend-linux-2.6.7-rev1-whole /dev/null
--- linux-2.6.7-xx2/include/linux/suspend.h
+++ /dev/null	2004-05-31 17:36:38.000000000 -0400
@@ -1,90 +0,0 @@
-#ifndef _LINUX_SWSUSP_H
-#define _LINUX_SWSUSP_H
-
-#ifdef CONFIG_X86
-#include <asm/suspend.h>
-#endif
-#include <linux/swap.h>
-#include <linux/notifier.h>
-#include <linux/config.h>
-#include <linux/init.h>
-#include <linux/pm.h>
-
-#ifdef CONFIG_PM
-/* page backup entry */
-typedef struct pbe {
-	unsigned long address;		/* address of the copy */
-	unsigned long orig_address;	/* original address of page */
-	swp_entry_t swap_address;	
-	swp_entry_t dummy;		/* we need scratch space at 
-					 * end of page (see link, diskpage)
-					 */
-} suspend_pagedir_t;
-
-#define SWAP_FILENAME_MAXLENGTH	32
-
-struct suspend_header {
-	u32 version_code;
-	unsigned long num_physpages;
-	char machine[8];
-	char version[20];
-	int num_cpus;
-	int page_size;
-	suspend_pagedir_t *suspend_pagedir;
-	unsigned int num_pbes;
-};
-
-#define SUSPEND_PD_PAGES(x)     (((x)*sizeof(struct pbe))/PAGE_SIZE+1)
-   
-/* mm/vmscan.c */
-extern int shrink_mem(void);
-
-/* mm/page_alloc.c */
-extern void drain_local_pages(void);
-
-/* kernel/power/swsusp.c */
-extern int software_suspend(void);
-
-extern unsigned int nr_copy_pages __nosavedata;
-extern suspend_pagedir_t *pagedir_nosave __nosavedata;
-
-#else	/* CONFIG_SOFTWARE_SUSPEND */
-static inline int software_suspend(void)
-{
-	printk("Warning: fake suspend called\n");
-	return -EPERM;
-}
-#define software_resume()		do { } while(0)
-#endif	/* CONFIG_SOFTWARE_SUSPEND */
-
-
-#ifdef CONFIG_PM
-extern void refrigerator(unsigned long);
-extern int freeze_processes(void);
-extern void thaw_processes(void);
-
-extern int pm_prepare_console(void);
-extern void pm_restore_console(void);
-
-#else
-static inline void refrigerator(unsigned long flag)
-{
-
-}
-static inline int freeze_processes(void)
-{
-	return 0;
-}
-static inline void thaw_processes(void)
-{
-
-}
-#endif	/* CONFIG_PM */
-
-asmlinkage void do_magic(int is_resume);
-asmlinkage void do_magic_resume_1(void);
-asmlinkage void do_magic_resume_2(void);
-asmlinkage void do_magic_suspend_1(void);
-asmlinkage void do_magic_suspend_2(void);
-
-#endif /* _LINUX_SWSUSP_H */
diff -puN /dev/null include/linux/suspend1.h
--- /dev/null	2004-05-31 17:36:38.000000000 -0400
+++ linux-2.6.7-xx2-xiphux/include/linux/suspend1.h	2004-06-24 07:14:54.765792800 -0400
@@ -0,0 +1,90 @@
+#ifndef _LINUX_SWSUSP_H
+#define _LINUX_SWSUSP_H
+
+#ifdef CONFIG_X86
+#include <asm/suspend.h>
+#endif
+#include <linux/swap.h>
+#include <linux/notifier.h>
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/pm.h>
+
+#ifdef CONFIG_PM
+/* page backup entry */
+typedef struct pbe {
+	unsigned long address;		/* address of the copy */
+	unsigned long orig_address;	/* original address of page */
+	swp_entry_t swap_address;
+	swp_entry_t dummy;		/* we need scratch space at
+					 * end of page (see link, diskpage)
+					 */
+} suspend_pagedir_t;
+
+#define SWAP_FILENAME_MAXLENGTH	32
+
+struct suspend_header {
+	u32 version_code;
+	unsigned long num_physpages;
+	char machine[8];
+	char version[20];
+	int num_cpus;
+	int page_size;
+	suspend_pagedir_t *suspend_pagedir;
+	unsigned int num_pbes;
+};
+
+#define SUSPEND_PD_PAGES(x)     (((x)*sizeof(struct pbe))/PAGE_SIZE+1)
+
+/* mm/vmscan.c */
+extern int shrink_mem(void);
+
+/* mm/page_alloc.c */
+extern void drain_local_pages(void);
+
+/* kernel/power/swsusp.c */
+extern int software_suspend(void);
+
+extern unsigned int nr_copy_pages __nosavedata;
+extern suspend_pagedir_t *pagedir_nosave __nosavedata;
+
+#else	/* CONFIG_SOFTWARE_SUSPEND */
+static inline int software_suspend(void)
+{
+	printk("Warning: fake suspend called\n");
+	return -EPERM;
+}
+#define software_resume()		do { } while(0)
+#endif	/* CONFIG_SOFTWARE_SUSPEND */
+
+
+#ifdef CONFIG_PM
+extern void refrigerator(unsigned long);
+extern int freeze_processes(void);
+extern void thaw_processes(void);
+
+extern int pm_prepare_console(void);
+extern void pm_restore_console(void);
+
+#else
+static inline void refrigerator(unsigned long flag)
+{
+
+}
+static inline int freeze_processes(void)
+{
+	return 0;
+}
+static inline void thaw_processes(void)
+{
+
+}
+#endif	/* CONFIG_PM */
+
+asmlinkage void do_magic(int is_resume);
+asmlinkage void do_magic_resume_1(void);
+asmlinkage void do_magic_resume_2(void);
+asmlinkage void do_magic_suspend_1(void);
+asmlinkage void do_magic_suspend_2(void);
+
+#endif /* _LINUX_SWSUSP_H */
diff -puN include/linux/workqueue.h~20-software-suspend-linux-2.6.7-rev1-whole include/linux/workqueue.h
--- linux-2.6.7-xx2/include/linux/workqueue.h~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.310861960 -0400
+++ linux-2.6.7-xx2-xiphux/include/linux/workqueue.h	2004-06-24 07:14:54.766792648 -0400
@@ -51,9 +51,10 @@ struct work_struct {
 	} while (0)
 
 extern struct workqueue_struct *__create_workqueue(const char *name,
-						    int singlethread);
-#define create_workqueue(name) __create_workqueue((name), 0)
-#define create_singlethread_workqueue(name) __create_workqueue((name), 1)
+						    int singlethread,
+						    unsigned long freezer_flag);
+#define create_workqueue(name, flags) __create_workqueue((name), 0, flags)
+#define create_singlethread_workqueue(name, flags) __create_workqueue((name), 1, flags)
 
 extern void destroy_workqueue(struct workqueue_struct *wq);
 
diff -puN init/do_mounts.c~20-software-suspend-linux-2.6.7-rev1-whole init/do_mounts.c
--- linux-2.6.7-xx2/init/do_mounts.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.312861656 -0400
+++ linux-2.6.7-xx2-xiphux/init/do_mounts.c	2004-06-24 07:14:54.767792496 -0400
@@ -52,7 +52,7 @@ static int __init readwrite(char *str)
 __setup("ro", readonly);
 __setup("rw", readwrite);
 
-static dev_t __init try_name(char *name, int part)
+static dev_t try_name(char *name, int part)
 {
 	char path[64];
 	char buf[32];
@@ -134,16 +134,21 @@ fail:
  *	is mounted on rootfs /sys.
  */
 
-dev_t __init name_to_dev_t(char *name)
+dev_t name_to_dev_t(char *name)
 {
 	char s[32];
 	char *p;
 	dev_t res = 0;
-	int part;
+	int part, mount_result;
 
 #ifdef CONFIG_SYSFS
 	sys_mkdir("/sys", 0700);
-	if (sys_mount("sysfs", "/sys", "sysfs", 0, NULL) < 0)
+	/*
+	 * When changing resume2 parameter for Software Suspend, sysfs may
+	 * already be mounted.
+	 */
+	mount_result = sys_mount("sysfs", "/sys", "sysfs", 0, NULL);
+	if (mount_result < 0 && mount_result != -EBUSY)
 		goto out;
 #endif
 
@@ -195,7 +200,8 @@ dev_t __init name_to_dev_t(char *name)
 	res = try_name(s, part);
 done:
 #ifdef CONFIG_SYSFS
-	sys_umount("/sys", 0);
+	if (mount_result >= 0)
+		sys_umount("/sys", 0);
 out:
 	sys_rmdir("/sys");
 #endif
diff -puN kernel/exit.c~20-software-suspend-linux-2.6.7-rev1-whole kernel/exit.c
--- linux-2.6.7-xx2/kernel/exit.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.315861200 -0400
+++ linux-2.6.7-xx2-xiphux/kernel/exit.c	2004-06-24 07:14:54.769792192 -0400
@@ -33,6 +33,8 @@
 #include <asm/mki.h>
 #endif
 
+#include <linux/suspend.h>
+
 extern void sem_exit (void);
 extern struct task_struct *child_reaper;
 
@@ -774,6 +776,7 @@ static void exit_notify(struct task_stru
 asmlinkage NORET_TYPE void do_exit(long code)
 {
 	struct task_struct *tsk = current;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	if (unlikely(in_interrupt()))
 		panic("Aiee, killing interrupt handler!");
@@ -783,6 +786,8 @@ asmlinkage NORET_TYPE void do_exit(long 
 		panic("Attempted to kill init!");
 	if (tsk->io_context)
 		exit_io_context();
+	SWSUSP_ACTIVITY_START(0);
+	SWSUSP_ACTIVITY_END;
 	tsk->flags |= PF_EXITING;
 	del_timer_sync(&tsk->real_timer);
 
@@ -1105,6 +1110,7 @@ asmlinkage long sys_wait4(pid_t pid,unsi
 	DECLARE_WAITQUEUE(wait, current);
 	struct task_struct *tsk;
 	int flag, retval;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	if (options & ~(WNOHANG|WUNTRACED|__WNOTHREAD|__WCLONE|__WALL))
 		return -EINVAL;
@@ -1173,7 +1179,9 @@ repeat:
 		retval = -ERESTARTSYS;
 		if (signal_pending(current))
 			goto end_wait4;
+		SWSUSP_ACTIVITY_PAUSING;
 		schedule();
+		SWSUSP_ACTIVITY_RESTARTING(0);
 		goto repeat;
 	}
 	retval = -ECHILD;
diff -puN kernel/fork.c~20-software-suspend-linux-2.6.7-rev1-whole kernel/fork.c
--- linux-2.6.7-xx2/kernel/fork.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.320860440 -0400
+++ linux-2.6.7-xx2-xiphux/kernel/fork.c	2004-06-24 07:14:54.774791432 -0400
@@ -36,6 +36,7 @@
 #include <linux/mount.h>
 #include <linux/audit.h>
 #include <linux/rmap.h>
+#include <linux/suspend.h>
 
 #include <asm/pgtable.h>
 #include <asm/pgalloc.h>
@@ -843,7 +844,7 @@ static inline void copy_flags(unsigned l
 {
 	unsigned long new_flags = p->flags;
 
-	new_flags &= ~PF_SUPERPRIV;
+	new_flags &= ~(PF_SUPERPRIV | PF_FRIDGE_WAIT);
 	new_flags |= PF_FORKNOEXEC;
 	if (!(clone_flags & CLONE_PTRACE))
 		p->ptrace = 0;
@@ -1249,7 +1250,11 @@ long do_fork(unsigned long clone_flags,
 		}
 
 		if (clone_flags & CLONE_VFORK) {
+			DECLARE_SWSUSP_LOCAL_VAR;
+
+			SWSUSP_ACTIVITY_PAUSING;
 			wait_for_completion(&vfork);
+			SWSUSP_ACTIVITY_RESTARTING(0);
 			if (unlikely (current->ptrace & PT_TRACE_VFORK_DONE))
 				ptrace_notify ((PTRACE_EVENT_VFORK_DONE << 8) | SIGTRAP);
 		} else
diff -puN kernel/kmod.c~20-software-suspend-linux-2.6.7-rev1-whole kernel/kmod.c
--- linux-2.6.7-xx2/kernel/kmod.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.323859984 -0400
+++ linux-2.6.7-xx2-xiphux/kernel/kmod.c	2004-06-24 07:14:54.775791280 -0400
@@ -274,7 +274,7 @@ EXPORT_SYMBOL(call_usermodehelper);
 
 static __init int usermodehelper_init(void)
 {
-	khelper_wq = create_singlethread_workqueue("khelper");
+	khelper_wq = create_singlethread_workqueue("khelper", 0);
 	BUG_ON(!khelper_wq);
 	return 0;
 }
diff -puN kernel/kthread.c~20-software-suspend-linux-2.6.7-rev1-whole kernel/kthread.c
--- linux-2.6.7-xx2/kernel/kthread.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.327859376 -0400
+++ linux-2.6.7-xx2-xiphux/kernel/kthread.c	2004-06-24 07:14:54.776791128 -0400
@@ -19,6 +19,7 @@ struct kthread_create_info
 	/* Information passed to kthread() from keventd. */
 	int (*threadfn)(void *data);
 	void *data;
+	unsigned long freezer_flags;
 	struct completion started;
 
 	/* Result passed back to kthread_create() from keventd. */
@@ -80,6 +81,9 @@ static int kthread(void *_create)
 	/* By default we can run anywhere, unlike keventd. */
 	set_cpus_allowed(current, CPU_MASK_ALL);
 
+	/* Set our freezer flags */
+	current->flags |= create->freezer_flags;
+
 	/* OK, tell user we're spawned, wait for stop or wakeup */
 	__set_current_state(TASK_INTERRUPTIBLE);
 	complete(&create->started);
@@ -115,6 +119,7 @@ static void keventd_create_kthread(void 
 
 struct task_struct *kthread_create(int (*threadfn)(void *data),
 				   void *data,
+				   unsigned long freezer_flags,
 				   const char namefmt[],
 				   ...)
 {
@@ -123,6 +128,7 @@ struct task_struct *kthread_create(int (
 
 	create.threadfn = threadfn;
 	create.data = data;
+	create.freezer_flags = freezer_flags;
 	init_completion(&create.started);
 	init_completion(&create.done);
 
diff -puN kernel/module.c~20-software-suspend-linux-2.6.7-rev1-whole kernel/module.c
--- linux-2.6.7-xx2/kernel/module.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.330858920 -0400
+++ linux-2.6.7-xx2-xiphux/kernel/module.c	2004-06-24 07:14:54.780790520 -0400
@@ -2150,6 +2150,33 @@ void print_modules(void)
 	printk("\n");
 }
 
+#define MODLIST_SIZE 4096
+
+void print_module_list(void)
+{
+	static char modlist[MODLIST_SIZE];
+	struct module *mod;
+	int pos = 0;
+
+	list_for_each_entry(mod, &modules, list)
+		if (mod->name)
+			pos += snprintf(modlist+pos, MODLIST_SIZE-pos-1,
+					"%s ", mod->name);
+	printk("%s\n",modlist);
+}
+
+int print_module_list_to_buffer(char * buffer, int size)
+{
+	struct module *mod;
+	int pos = 0;
+
+	list_for_each_entry(mod, &modules, list)
+		if (mod->name)
+			pos += snprintf(buffer+pos, size-pos-1,
+					"%s ", mod->name);
+	return pos;
+}
+
 #ifdef CONFIG_MODVERSIONS
 /* Generate the signature for struct module here, too, for modversions. */
 void struct_module(struct module *mod) { return; }
diff -puN kernel/panic.c~20-software-suspend-linux-2.6.7-rev1-whole kernel/panic.c
--- linux-2.6.7-xx2/kernel/panic.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.333858464 -0400
+++ linux-2.6.7-xx2-xiphux/kernel/panic.c	2004-06-24 07:14:54.781790368 -0400
@@ -18,6 +18,7 @@
 #include <linux/sysrq.h>
 #include <linux/syscalls.h>
 #include <linux/interrupt.h>
+#include <linux/suspend.h>
 #include <linux/nmi.h>
 
 int panic_timeout;
@@ -64,6 +65,10 @@ NORET_TYPE void panic(const char * fmt, 
 		printk(KERN_EMERG "In interrupt handler - not syncing\n");
 	else if (!current->pid)
 		printk(KERN_EMERG "In idle task - not syncing\n");
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+	else if (suspend_task)
+		printk(KERN_EMERG "In software suspend - not syncing.\n");
+#endif
 	else
 		sys_sync();
 	bust_spinlocks(0);
diff -puN kernel/power/Kconfig~20-software-suspend-linux-2.6.7-rev1-whole kernel/power/Kconfig
--- linux-2.6.7-xx2/kernel/power/Kconfig~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.336858008 -0400
+++ linux-2.6.7-xx2-xiphux/kernel/power/Kconfig	2004-06-24 07:14:54.782790216 -0400
@@ -22,14 +22,16 @@ config SOFTWARE_SUSPEND
 	bool "Software Suspend (EXPERIMENTAL)"
 	depends on EXPERIMENTAL && PM && SWAP
 	---help---
-	  Enable the possibilty of suspendig machine. It doesn't need APM.
+	  Pavel's original version.
+
+	  Enable the possibilty of suspending your machine. It doesn't need APM.
 	  You may suspend your machine by 'swsusp' or 'shutdown -z <time>' 
 	  (patch for sysvinit needed). 
 
-	  It creates an image which is saved in your active swaps. By the next
-	  booting the, pass 'resume=/dev/swappartition' and kernel will 
-	  detect the saved image, restore the memory from
-	  it and then it continues to run as before you've suspended.
+	  It creates an image which is saved in your active swaps. At the next
+	  boot, pass 'resume=/dev/swappartition' and the kernel will
+	  detect the saved image, restore the memory from disk
+	  and then continue to run as before you suspended.
 	  If you don't want the previous state to continue use the 'noresume'
 	  kernel option. However note that your partitions will be fsck'd and
 	  you must re-mkswap your swap partitions. It does not work with swap
@@ -42,6 +44,137 @@ config SOFTWARE_SUSPEND
 
 	  For more information take a look at Documentation/power/swsusp.txt.
 
+menu "Software Suspend 2"
+	depends on EXPERIMENTAL && PM
+
+	config SOFTWARE_SUSPEND2
+	bool
+
+	comment 'Image Storage (you need at least one writer)'
+
+	config SOFTWARE_SUSPEND_SWAPWRITER
+		bool '   Swap Writer'
+		depends on SWAP
+		select SOFTWARE_SUSPEND2
+		---help---
+		  This option enabled support for storing an image in your
+		  swap space. Swap partitions are supported. Swap file
+		  support is currently broken (16 April 2004).
+
+	config SOFTWARE_SUSPEND_NFSWRITER
+		bool '   NFS Writer'
+		depends on NFSROOT
+		select SOFTWARE_SUSPEND2
+		---help---
+		  This option currently does nothing. The NFS writer is just
+		  beginning to be written.
+
+	config SOFTWARE_SUSPEND_NULLWRITER
+		bool '   Null Writer (For debugging)'
+		select SOFTWARE_SUSPEND2
+		---help---
+		  This is a template, which you can use to develop your
+		  own storage backend for Software Suspend 2.
+
+	if SOFTWARE_SUSPEND2
+		comment 'Page Transformers'
+
+		config SOFTWARE_SUSPEND_LZF_COMPRESSION
+			bool '   LZF image compression'
+			default Y
+			---help---
+			  This option enables compression of pages stored during suspending
+			  to disk, using LZF compression. LZF compression is fast and
+			  still achieves a good compression ratio.
+
+			  You want to say 'Y'.
+
+		config SOFTWARE_SUSPEND_GZIP_COMPRESSION
+			bool '   GZIP image Compression'
+			select ZLIB_DEFLATE
+			select ZLIB_INFLATE
+			---help---
+			  This option enables compression of pages stored during Software Suspend
+			  process. Pages are compressed using the zlib library, with a default
+			  setting (in code) of fastest compression. If your swap device is
+			  significantly slower than your CPU, you may improve the speed of a
+			  suspend/resume cycle by enabling this option.
+
+			  You may also benefit from it if your swap space is small. Note, however,
+			  that since we can't know how big the image will be until we actually
+			  compress it, the algorithm assumes no compression will be achieved and
+			  ensures that your data will fit on disk even if that happens. This means
+			  that more memory will be eaten than probably needs to be. The best
+			  solution to this issue is to increase your swapspace size. We may
+			  implement support for a swap file in future.
+
+			  This option should be off for most people.
+
+		config SOFTWARE_SUSPEND_NULLTRANSFORMER
+			bool '  Null Page Transformer (For debugging)'
+
+		comment 'General Options'
+
+		config SOFTWARE_SUSPEND_DEBUG
+			bool '   Compile in debugging output'
+			---help---
+			  This option enables the inclusion of debugging info in the software
+			  suspend code. Turning it off will reduce the kernel size but make
+			  debugging suspend & resume issues harder to do.
+
+			  For normal usage, this option can be turned off.
+
+		config SOFTWARE_SUSPEND_VARIATION_ANALYSIS
+			bool '   Variation Analysis'
+			---help---
+			  This option enables code which allows you to examine the differences
+			  between the contents of memory at 2 points in time (usually before
+			  and after suspending). It is mostly intended for Nigel to use, and
+			  thus the documentation is not wonderful :>.
+
+		config SOFTWARE_SUSPEND2_DUMP
+			bool '   Metadata dump'
+			---help---
+			  This is a temporary option which allows you to dump metadata about
+			  the image to dmesg, rather than resuming from it. Add suspend_dump
+			  to the command line to do this.
+
+		config SOFTWARE_SUSPEND_KEEP_IMAGE
+			bool '   Allow Keep Image Mode'
+			---help---
+			  This option allows you to keep and image and reuse it. It is intended
+			  __ONLY__ for use with systems where all filesystems are mounted read-
+			  only (kiosks, for example). To use it, compile this option in and boot
+			  normally. Set the KEEP_IMAGE flag in /proc/swsusp and suspend. When you
+			  resume, the image will not be removed. You will be unable to turn
+			  off swap partitions (assuming you are using the swap writer), but future
+			  suspends simply do a power-down. The image can be updated using the
+			  kernel command line parameter suspend_act= to turn off the keep image
+			  bit. Keep image mode is a little less user friendly on purpose - it
+			  should not be used without thought!
+
+		config SOFTWARE_SUSPEND_RELAXED_PROC
+			bool '   Relaxed /proc/swsusp permissions'
+			---help---
+			  This option makes /proc/swsusp entries world-accessible, rather than
+			  root-only. It is intended for systems where security is not a concern.
+
+			  Networked machines, and particularly those where users are granted
+			  shell access, should say 'N' here!
+
+		config SOFTWARE_SUSPEND_DEFAULT_RESUME2
+			string '   Default resume device name'
+			---help---
+			  You normally need to add a resume2= parameter to your lilo.conf or
+			  equivalent. With this option properly set, the kernel has a value
+			  to default. No damage will be done if the value is invalid.
+
+	endif
+
+	comment 'Suspend will not be compiled in if no storage method is selected.'
+		depends on !SOFTWARE_SUSPEND2
+endmenu
+
 config PM_DISK
 	bool "Suspend-to-Disk Support"
 	depends on PM && SWAP && X86 && !X86_64
diff -puN kernel/power/Makefile~20-software-suspend-linux-2.6.7-rev1-whole kernel/power/Makefile
--- linux-2.6.7-xx2/kernel/power/Makefile~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.340857400 -0400
+++ linux-2.6.7-xx2-xiphux/kernel/power/Makefile	2004-06-24 07:14:54.783790064 -0400
@@ -1,5 +1,16 @@
-obj-y				:= main.o process.o console.o pm.o
+obj-y				:= main.o process.o ui.o pm.o utility.o
+obj-$(CONFIG_SOFTWARE_SUSPEND_LZF_COMPRESSION)	+= lzfcompress.o
+obj-$(CONFIG_SOFTWARE_SUSPEND_GZIP_COMPRESSION)	+= gzipcompress.o
+obj-$(CONFIG_SOFTWARE_SUSPEND_NULLTRANSFORMER)	+= nulltransformer.o
+obj-$(CONFIG_SOFTWARE_SUSPEND_NULLWRITER)	+= nullwriter.o
+obj-$(CONFIG_SOFTWARE_SUSPEND_NFSWRITER)	+= nfswriter.o
+obj-$(CONFIG_SOFTWARE_SUSPEND_SWAPWRITER)	+= swapwriter.o
+obj-$(CONFIG_SOFTWARE_SUSPEND2) += io.o memory_pool.o pagedir.o prepare_image.o proc.o range.o suspend2.o
 obj-$(CONFIG_SOFTWARE_SUSPEND)	+= swsusp.o
 obj-$(CONFIG_PM_DISK)		+= disk.o pmdisk.o
 
 obj-$(CONFIG_MAGIC_SYSRQ)	+= poweroff.o
+
+ui.c:
+	@(echo -e "\n\n *** It looks like you have not applied the core Software Suspend patch. *** \n\n"; \
+	  exit 1)
diff -puN -L kernel/power/console.c kernel/power/console.c~20-software-suspend-linux-2.6.7-rev1-whole /dev/null
--- linux-2.6.7-xx2/kernel/power/console.c
+++ /dev/null	2004-05-31 17:36:38.000000000 -0400
@@ -1,55 +0,0 @@
-/*
- * drivers/power/process.c - Functions for saving/restoring console.
- *
- * Originally from swsusp.
- */
-
-#include <linux/vt_kern.h>
-#include <linux/kbd_kern.h>
-#include <linux/console.h>
-#include "power.h"
-
-static int new_loglevel = 10;
-static int orig_loglevel;
-static int orig_fgconsole, orig_kmsg;
-
-int pm_prepare_console(void)
-{
-	orig_loglevel = console_loglevel;
-	console_loglevel = new_loglevel;
-
-#ifdef SUSPEND_CONSOLE
-	acquire_console_sem();
-
-	orig_fgconsole = fg_console;
-
-	if (vc_allocate(SUSPEND_CONSOLE)) {
-	  /* we can't have a free VC for now. Too bad,
-	   * we don't want to mess the screen for now. */
-		release_console_sem();
-		return 1;
-	}
-
-	set_console(SUSPEND_CONSOLE);
-	release_console_sem();
-
-	if (vt_waitactive(SUSPEND_CONSOLE)) {
-		pr_debug("Suspend: Can't switch VCs.");
-		return 1;
-	}
-	orig_kmsg = kmsg_redirect;
-	kmsg_redirect = SUSPEND_CONSOLE;
-#endif
-	return 0;
-}
-
-void pm_restore_console(void)
-{
-	console_loglevel = orig_loglevel;
-#ifdef SUSPEND_CONSOLE
-	acquire_console_sem();
-	set_console(orig_fgconsole);
-	release_console_sem();
-#endif
-	return;
-}
diff -puN kernel/power/disk.c~20-software-suspend-linux-2.6.7-rev1-whole kernel/power/disk.c
--- linux-2.6.7-xx2/kernel/power/disk.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.345856640 -0400
+++ linux-2.6.7-xx2-xiphux/kernel/power/disk.c	2004-06-24 07:14:54.785789760 -0400
@@ -11,12 +11,13 @@
 #define DEBUG
 
 
-#include <linux/suspend.h>
+#include <linux/suspend1.h>
 #include <linux/syscalls.h>
 #include <linux/reboot.h>
 #include <linux/string.h>
 #include <linux/delay.h>
 #include <linux/fs.h>
+#include <linux/init.h>
 #include "power.h"
 
 
diff -puN kernel/power/main.c~20-software-suspend-linux-2.6.7-rev1-whole kernel/power/main.c
--- linux-2.6.7-xx2/kernel/power/main.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.349856032 -0400
+++ linux-2.6.7-xx2-xiphux/kernel/power/main.c	2004-06-24 07:14:54.786789608 -0400
@@ -17,7 +17,8 @@
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/pm.h>
-
+#include <linux/cpumask.h>
+#include <asm/semaphore.h>
 
 #include "power.h"
 
diff -puN kernel/power/pmdisk.c~20-software-suspend-linux-2.6.7-rev1-whole kernel/power/pmdisk.c
--- linux-2.6.7-xx2/kernel/power/pmdisk.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.352855576 -0400
+++ linux-2.6.7-xx2-xiphux/kernel/power/pmdisk.c	2004-06-24 07:14:54.788789304 -0400
@@ -22,7 +22,7 @@
 
 #include <linux/mm.h>
 #include <linux/bio.h>
-#include <linux/suspend.h>
+#include <linux/suspend1.h>
 #include <linux/version.h>
 #include <linux/reboot.h>
 #include <linux/device.h>
diff -puN -L kernel/power/process.c kernel/power/process.c~20-software-suspend-linux-2.6.7-rev1-whole /dev/null
--- linux-2.6.7-xx2/kernel/power/process.c
+++ /dev/null	2004-05-31 17:36:38.000000000 -0400
@@ -1,119 +0,0 @@
-/*
- * drivers/power/process.c - Functions for starting/stopping processes on 
- *                           suspend transitions.
- *
- * Originally from swsusp.
- */
-
-
-#undef DEBUG
-
-#include <linux/smp_lock.h>
-#include <linux/interrupt.h>
-#include <linux/suspend.h>
-#include <linux/module.h>
-
-/* 
- * Timeout for stopping processes
- */
-#define TIMEOUT	(6 * HZ)
-
-
-static inline int freezeable(struct task_struct * p)
-{
-	if ((p == current) || 
-	    (p->flags & PF_NOFREEZE) ||
-	    (p->state == TASK_ZOMBIE) ||
-	    (p->state == TASK_DEAD) ||
-	    (p->state == TASK_STOPPED))
-		return 0;
-	return 1;
-}
-
-/* Refrigerator is place where frozen processes are stored :-). */
-void refrigerator(unsigned long flag)
-{
-	/* Hmm, should we be allowed to suspend when there are realtime
-	   processes around? */
-	long save;
-	save = current->state;
-	current->state = TASK_UNINTERRUPTIBLE;
-	pr_debug("%s entered refrigerator\n", current->comm);
-	printk("=");
-	current->flags &= ~PF_FREEZE;
-
-	spin_lock_irq(&current->sighand->siglock);
-	recalc_sigpending(); /* We sent fake signal, clean it up */
-	spin_unlock_irq(&current->sighand->siglock);
-
-	current->flags |= PF_FROZEN;
-	while (current->flags & PF_FROZEN)
-		schedule();
-	pr_debug("%s left refrigerator\n", current->comm);
-	current->state = save;
-}
-
-/* 0 = success, else # of processes that we failed to stop */
-int freeze_processes(void)
-{
-       int todo;
-       unsigned long start_time;
-	struct task_struct *g, *p;
-	
-	printk( "Stopping tasks: " );
-	start_time = jiffies;
-	do {
-		todo = 0;
-		read_lock(&tasklist_lock);
-		do_each_thread(g, p) {
-			unsigned long flags;
-			if (!freezeable(p))
-				continue;
-			if ((p->flags & PF_FROZEN) ||
-			    (p->state == TASK_STOPPED))
-				continue;
-
-			/* FIXME: smp problem here: we may not access other process' flags
-			   without locking */
-			p->flags |= PF_FREEZE;
-			spin_lock_irqsave(&p->sighand->siglock, flags);
-			signal_wake_up(p, 0);
-			spin_unlock_irqrestore(&p->sighand->siglock, flags);
-			todo++;
-		} while_each_thread(g, p);
-		read_unlock(&tasklist_lock);
-		yield();			/* Yield is okay here */
-		if (time_after(jiffies, start_time + TIMEOUT)) {
-			printk( "\n" );
-			printk(KERN_ERR " stopping tasks failed (%d tasks remaining)\n", todo );
-			return todo;
-		}
-	} while(todo);
-	
-	printk( "|\n" );
-	BUG_ON(in_atomic());
-	return 0;
-}
-
-void thaw_processes(void)
-{
-	struct task_struct *g, *p;
-
-	printk( "Restarting tasks..." );
-	read_lock(&tasklist_lock);
-	do_each_thread(g, p) {
-		if (!freezeable(p))
-			continue;
-		if (p->flags & PF_FROZEN) {
-			p->flags &= ~PF_FROZEN;
-			wake_up_process(p);
-		} else
-			printk(KERN_INFO " Strange, %s not stopped\n", p->comm );
-	} while_each_thread(g, p);
-
-	read_unlock(&tasklist_lock);
-	schedule();
-	printk( " done\n" );
-}
-
-EXPORT_SYMBOL(refrigerator);
diff -puN kernel/power/swsusp.c~20-software-suspend-linux-2.6.7-rev1-whole kernel/power/swsusp.c
--- linux-2.6.7-xx2/kernel/power/swsusp.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.356854968 -0400
+++ linux-2.6.7-xx2-xiphux/kernel/power/swsusp.c	2004-06-24 07:14:56.325555680 -0400
@@ -38,7 +38,7 @@
 
 #include <linux/module.h>
 #include <linux/mm.h>
-#include <linux/suspend.h>
+#include <linux/suspend1.h>
 #include <linux/smp_lock.h>
 #include <linux/file.h>
 #include <linux/utsname.h>
diff -puN kernel/sched.c~20-software-suspend-linux-2.6.7-rev1-whole kernel/sched.c
--- linux-2.6.7-xx2/kernel/sched.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.361854208 -0400
+++ linux-2.6.7-xx2-xiphux/kernel/sched.c	2004-06-24 07:14:56.333554464 -0400
@@ -6191,7 +6191,7 @@ static inline struct task_struct *younge
 	return list_entry(p->sibling.next,struct task_struct,sibling);
 }
 
-static void show_task(task_t * p)
+void show_task(task_t * p)
 {
 	task_t *relative;
 	unsigned state;
@@ -6525,18 +6525,19 @@ static int migration_thread(void * data)
 {
 	runqueue_t *rq;
 	int cpu = (long)data;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	rq = cpu_rq(cpu);
 	BUG_ON(rq->migration_thread != current);
 
+	SWSUSP_THREAD_FLAGS_RESET;
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
+
 	set_current_state(TASK_INTERRUPTIBLE);
 	while (!kthread_should_stop()) {
 		struct list_head *head;
 		migration_req_t *req;
 
-		if (current->flags & PF_FREEZE)
-			refrigerator(PF_FREEZE);
-
 		spin_lock_irq(&rq->lock);
 
 		if (cpu_is_offline(cpu)) {
@@ -6553,7 +6554,9 @@ static int migration_thread(void * data)
 
 		if (list_empty(head)) {
 			spin_unlock_irq(&rq->lock);
+			SWSUSP_ACTIVITY_SYNCTHREAD_PAUSING;
 			schedule();
+			SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 			set_current_state(TASK_INTERRUPTIBLE);
 			continue;
 		}
@@ -6576,6 +6579,7 @@ static int migration_thread(void * data)
 		complete(&req->done);
 	}
 	__set_current_state(TASK_RUNNING);
+	SWSUSP_ACTIVITY_END;
 	return 0;
 
 wait_to_die:
@@ -6585,6 +6589,7 @@ wait_to_die:
 		schedule();
 		set_current_state(TASK_INTERRUPTIBLE);
 	}
+	SWSUSP_ACTIVITY_END;
 	__set_current_state(TASK_RUNNING);
 	return 0;
 }
@@ -6688,7 +6693,8 @@ static int migration_call(struct notifie
 
 	switch (action) {
 	case CPU_UP_PREPARE:
-		p = kthread_create(migration_thread, hcpu, "migration/%d",cpu);
+		p = kthread_create(migration_thread, hcpu, 0,
+				"migration/%d",cpu);
 		if (IS_ERR(p))
 			return NOTIFY_BAD;
 		p->flags |= PF_NOFREEZE;
diff -puN kernel/softirq.c~20-software-suspend-linux-2.6.7-rev1-whole kernel/softirq.c
--- linux-2.6.7-xx2/kernel/softirq.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.364853752 -0400
+++ linux-2.6.7-xx2-xiphux/kernel/softirq.c	2004-06-24 07:14:56.335554160 -0400
@@ -15,6 +15,7 @@
 #include <linux/percpu.h>
 #include <linux/cpu.h>
 #include <linux/kthread.h>
+#include <linux/suspend.h>
 
 #include <asm/irq.h>
 /*
@@ -322,14 +323,21 @@ void __init softirq_init(void)
 
 static int ksoftirqd(void * __bind_cpu)
 {
+	DECLARE_SWSUSP_LOCAL_VAR;
+
 	set_user_nice(current, 19);
-	current->flags |= PF_NOFREEZE;
+
+	SWSUSP_THREAD_FLAGS_RESET;
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
 
 	set_current_state(TASK_INTERRUPTIBLE);
 
 	while (!kthread_should_stop()) {
-		if (!local_softirq_pending())
+		if (!local_softirq_pending()) {
+			SWSUSP_ACTIVITY_SYNCTHREAD_PAUSING;
 			schedule();
+			SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
+		}
 
 		__set_current_state(TASK_RUNNING);
 
@@ -348,6 +356,7 @@ static int ksoftirqd(void * __bind_cpu)
 		set_current_state(TASK_INTERRUPTIBLE);
 	}
 	__set_current_state(TASK_RUNNING);
+	SWSUSP_ACTIVITY_END;
 	return 0;
 
 wait_to_die:
@@ -359,6 +368,7 @@ wait_to_die:
 		set_current_state(TASK_INTERRUPTIBLE);
 	}
 	__set_current_state(TASK_RUNNING);
+	SWSUSP_ACTIVITY_END;
 	return 0;
 }
 
@@ -425,7 +435,7 @@ static int __devinit cpu_callback(struct
 	case CPU_UP_PREPARE:
 		BUG_ON(per_cpu(tasklet_vec, hotcpu).list);
 		BUG_ON(per_cpu(tasklet_hi_vec, hotcpu).list);
-		p = kthread_create(ksoftirqd, hcpu, "ksoftirqd/%d", hotcpu);
+		p = kthread_create(ksoftirqd, hcpu, 0, "ksoftirqd/%d", hotcpu);
 		if (IS_ERR(p)) {
 			printk("ksoftirqd for %i failed\n", hotcpu);
 			return NOTIFY_BAD;
diff -puN kernel/stop_machine.c~20-software-suspend-linux-2.6.7-rev1-whole kernel/stop_machine.c
--- linux-2.6.7-xx2/kernel/stop_machine.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.366853448 -0400
+++ linux-2.6.7-xx2-xiphux/kernel/stop_machine.c	2004-06-24 07:14:56.337553856 -0400
@@ -174,7 +174,7 @@ struct task_struct *__stop_machine_run(i
 	if (cpu == NR_CPUS)
 		cpu = smp_processor_id();
 
-	p = kthread_create(do_stop, &smdata, "kstopmachine");
+	p = kthread_create(do_stop, &smdata, 0, "kstopmachine");
 	if (!IS_ERR(p)) {
 		kthread_bind(p, cpu);
 		wake_up_process(p);
diff -puN kernel/sys.c~20-software-suspend-linux-2.6.7-rev1-whole kernel/sys.c
--- linux-2.6.7-xx2/kernel/sys.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.370852840 -0400
+++ linux-2.6.7-xx2-xiphux/kernel/sys.c	2004-06-24 07:14:56.341553248 -0400
@@ -509,10 +509,14 @@ asmlinkage long sys_reboot(int magic1, i
 		machine_restart(buffer);
 		break;
 
-#ifdef CONFIG_SOFTWARE_SUSPEND
+#ifdef CONFIG_SOFTWARE_SUSPEND2
 	case LINUX_REBOOT_CMD_SW_SUSPEND:
 		{
-			int ret = software_suspend();
+			int ret = -EINVAL;
+			if (!(software_suspend_state & SOFTWARE_SUSPEND_DISABLED)) {
+				software_suspend_pending();
+				ret = 0;
+			}
 			unlock_kernel();
 			return ret;
 		}
diff -puN kernel/workqueue.c~20-software-suspend-linux-2.6.7-rev1-whole kernel/workqueue.c
--- linux-2.6.7-xx2/kernel/workqueue.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.372852536 -0400
+++ linux-2.6.7-xx2-xiphux/kernel/workqueue.c	2004-06-24 07:14:56.343552944 -0400
@@ -25,6 +25,7 @@
 #include <linux/cpu.h>
 #include <linux/notifier.h>
 #include <linux/kthread.h>
+#include <linux/suspend.h>
 
 /*
  * The per-CPU workqueue (if single thread, we always use cpu 0's).
@@ -185,8 +186,15 @@ static int worker_thread(void *__cwq)
 	DECLARE_WAITQUEUE(wait, current);
 	struct k_sigaction sa;
 	sigset_t blocked;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
-	current->flags |= PF_NOFREEZE;
+	/*
+	 * This thread might be NOFREEZE, SYNCTHREAD
+	 * or an ordinary task.
+	 */
+
+	SWSUSP_THREAD_FLAGS_RESET;
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
 
 	set_user_nice(current, -10);
 
@@ -204,16 +212,19 @@ static int worker_thread(void *__cwq)
 	set_current_state(TASK_INTERRUPTIBLE);
 	while (!kthread_should_stop()) {
 		add_wait_queue(&cwq->more_work, &wait);
+		SWSUSP_ACTIVITY_SYNCTHREAD_PAUSING;
 		if (list_empty(&cwq->worklist))
 			schedule();
 		else
 			__set_current_state(TASK_RUNNING);
+		SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 		remove_wait_queue(&cwq->more_work, &wait);
 
 		if (!list_empty(&cwq->worklist))
 			run_workqueue(cwq);
 		set_current_state(TASK_INTERRUPTIBLE);
 	}
+	SWSUSP_ACTIVITY_END;
 	__set_current_state(TASK_RUNNING);
 	return 0;
 }
@@ -277,7 +288,8 @@ void fastcall flush_workqueue(struct wor
 }
 
 static struct task_struct *create_workqueue_thread(struct workqueue_struct *wq,
-						   int cpu)
+						   int cpu,
+						   unsigned long freezer_flags)
 {
 	struct cpu_workqueue_struct *cwq = wq->cpu_wq + cpu;
 	struct task_struct *p;
@@ -292,9 +304,11 @@ static struct task_struct *create_workqu
 	init_waitqueue_head(&cwq->work_done);
 
 	if (is_single_threaded(wq))
-		p = kthread_create(worker_thread, cwq, "%s", wq->name);
+		p = kthread_create(worker_thread, cwq, freezer_flags,
+				"%s", wq->name);
 	else
-		p = kthread_create(worker_thread, cwq, "%s/%d", wq->name, cpu);
+		p = kthread_create(worker_thread, cwq, freezer_flags,
+				"%s/%d", wq->name, cpu);
 	if (IS_ERR(p))
 		return NULL;
 	cwq->thread = p;
@@ -302,7 +316,8 @@ static struct task_struct *create_workqu
 }
 
 struct workqueue_struct *__create_workqueue(const char *name,
-					    int singlethread)
+					    int singlethread,
+					    unsigned long freezer_flags)
 {
 	int cpu, destroy = 0;
 	struct workqueue_struct *wq;
@@ -320,7 +335,7 @@ struct workqueue_struct *__create_workqu
 	lock_cpu_hotplug();
 	if (singlethread) {
 		INIT_LIST_HEAD(&wq->list);
-		p = create_workqueue_thread(wq, 0);
+		p = create_workqueue_thread(wq, 0, freezer_flags);
 		if (!p)
 			destroy = 1;
 		else
@@ -330,7 +345,7 @@ struct workqueue_struct *__create_workqu
 		list_add(&wq->list, &workqueues);
 		spin_unlock(&workqueue_lock);
 		for_each_online_cpu(cpu) {
-			p = create_workqueue_thread(wq, cpu);
+			p = create_workqueue_thread(wq, cpu, freezer_flags);
 			if (p) {
 				kthread_bind(p, cpu);
 				wake_up_process(p);
@@ -493,7 +508,7 @@ static int __devinit workqueue_cpu_callb
 void init_workqueues(void)
 {
 	hotcpu_notifier(workqueue_cpu_callback, 0);
-	keventd_wq = create_workqueue("events");
+	keventd_wq = create_workqueue("events", 0);
 	BUG_ON(!keventd_wq);
 }
 
diff -puN mm/bootmem.c~20-software-suspend-linux-2.6.7-rev1-whole mm/bootmem.c
--- linux-2.6.7-xx2/mm/bootmem.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.374852232 -0400
+++ linux-2.6.7-xx2-xiphux/mm/bootmem.c	2004-06-24 07:14:56.345552640 -0400
@@ -270,6 +270,9 @@ static unsigned long __init free_all_boo
 				if (v & m) {
 					count++;
 					ClearPageReserved(page);
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+					//ClearPageNosave(page);
+#endif
 #ifdef CONFIG_BADRAM
 					if (!PageBad(page))
 #endif
@@ -295,6 +298,9 @@ static unsigned long __init free_all_boo
 	for (i = 0; i < ((bdata->node_low_pfn-(bdata->node_boot_start >> PAGE_SHIFT))/8 + PAGE_SIZE-1)/PAGE_SIZE; i++,page++) {
 		count++;
 		ClearPageReserved(page);
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+		//ClearPageNosave(page);
+#endif
 #ifdef CONFIG_BADRAM
 		if (!PageBad(page))
 #endif
diff -puN mm/filemap.c~20-software-suspend-linux-2.6.7-rev1-whole mm/filemap.c
--- linux-2.6.7-xx2/mm/filemap.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.376851928 -0400
+++ linux-2.6.7-xx2-xiphux/mm/filemap.c	2004-06-24 07:14:56.348552184 -0400
@@ -276,7 +276,8 @@ EXPORT_SYMBOL(add_to_page_cache);
 int add_to_page_cache_lru(struct page *page, struct address_space *mapping,
 				pgoff_t offset, int gfp_mask)
 {
-	int ret = add_to_page_cache(page, mapping, offset, gfp_mask);
+	int ret;
+	ret = add_to_page_cache(page, mapping, offset, gfp_mask);
 	if (ret == 0)
 		lru_cache_add(page);
 	return ret;
@@ -1984,7 +1985,7 @@ generic_file_aio_write_nolock(struct kio
 		if (status < 0)
 			break;
 		balance_dirty_pages_ratelimited(mapping);
-		cond_resched();
+		//cond_resched();
 	} while (count);
 	*ppos = pos;
 
diff -puN mm/highmem.c~20-software-suspend-linux-2.6.7-rev1-whole mm/highmem.c
--- linux-2.6.7-xx2/mm/highmem.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.379851472 -0400
+++ linux-2.6.7-xx2-xiphux/mm/highmem.c	2004-06-24 07:14:56.349552032 -0400
@@ -26,6 +26,7 @@
 #include <linux/init.h>
 #include <linux/hash.h>
 #include <linux/highmem.h>
+#include <linux/suspend.h>
 #include <asm/tlbflush.h>
 
 static mempool_t *page_pool, *isa_page_pool;
@@ -94,7 +95,13 @@ static void flush_all_zero_pkmaps(void)
 
 		set_page_address(page, NULL);
 	}
-	flush_tlb_kernel_range(PKMAP_ADDR(0), PKMAP_ADDR(LAST_PKMAP));
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+	/* While suspending, we delay flushing tlbs on other processors. */
+	if (software_suspend_state & SOFTWARE_SUSPEND_FREEZE_SMP)
+		__flush_tlb();
+	else
+#endif
+		flush_tlb_kernel_range(PKMAP_ADDR(0), PKMAP_ADDR(LAST_PKMAP));
 }
 
 static inline unsigned long map_new_virtual(struct page *page)
diff -puN mm/oom_kill.c~20-software-suspend-linux-2.6.7-rev1-whole mm/oom_kill.c
--- linux-2.6.7-xx2/mm/oom_kill.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.381851168 -0400
+++ linux-2.6.7-xx2-xiphux/mm/oom_kill.c	2004-06-24 07:14:56.423540784 -0400
@@ -20,6 +20,7 @@
 #include <linux/swap.h>
 #include <linux/timex.h>
 #include <linux/jiffies.h>
+#include <linux/suspend.h>
 
 /* #define DEBUG */
 
@@ -232,6 +233,10 @@ void out_of_memory(void)
 	static unsigned long first, last, count, lastkill;
 	unsigned long now, since;
 
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+	if (software_suspend_state & SOFTWARE_SUSPEND_RUNNING)
+		return;
+#endif
 	spin_lock(&oom_lock);
 	now = jiffies;
 	since = now - last;
diff -puN mm/page-writeback.c~20-software-suspend-linux-2.6.7-rev1-whole mm/page-writeback.c
--- linux-2.6.7-xx2/mm/page-writeback.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.382851016 -0400
+++ linux-2.6.7-xx2-xiphux/mm/page-writeback.c	2004-06-24 07:14:56.424540632 -0400
@@ -29,6 +29,7 @@
 #include <linux/sysctl.h>
 #include <linux/cpu.h>
 #include <linux/syscalls.h>
+#include <linux/suspend.h>
 
 /*
  * The maximum number of pages to writeout in a single bdflush/kupdate
@@ -371,6 +372,13 @@ static void wb_kupdate(unsigned long arg
 		.for_kupdate	= 1,
 	};
 
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+	if (software_suspend_state & SOFTWARE_SUSPEND_RUNNING) {
+		start_jif = jiffies;
+		next_jif = start_jif + (dirty_writeback_centisecs * HZ) / 100;
+		goto out;
+	}
+#endif
 	sync_supers();
 
 	get_writeback_state(&wbs);
@@ -391,6 +399,9 @@ static void wb_kupdate(unsigned long arg
 		}
 		nr_to_write -= MAX_WRITEBACK_PAGES - wbc.nr_to_write;
 	}
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+out:
+#endif
 	if (time_before(next_jif, jiffies + HZ))
 		next_jif = jiffies + HZ;
 	if (dirty_writeback_centisecs)
diff -puN mm/page_alloc.c~20-software-suspend-linux-2.6.7-rev1-whole mm/page_alloc.c
--- linux-2.6.7-xx2/mm/page_alloc.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.385850560 -0400
+++ linux-2.6.7-xx2-xiphux/mm/page_alloc.c	2004-06-24 07:14:56.428540024 -0400
@@ -43,6 +43,12 @@ long nr_swap_pages;
 int numnodes = 1;
 int sysctl_lower_zone_protection = 0;
 
+#ifdef CONFIG_PM
+char pcp_lists_enabled = 1;
+#else
+#define pcp_lists_enabled (1)
+#endif
+
 EXPORT_SYMBOL(totalram_pages);
 EXPORT_SYMBOL(nr_swap_pages);
 
@@ -284,6 +290,12 @@ void __free_pages_ok(struct page *page, 
 	mod_page_state(pgfree, 1 << order);
 	for (i = 0 ; i < (1 << order) ; ++i)
 		free_pages_check(__FUNCTION__, page + i);
+#ifdef CONFIG_SOFTWARE_SUSPEND2
+	if (unlikely(software_suspend_state & SOFTWARE_SUSPEND_USE_MEMORY_POOL)) {
+		free_suspend_pool_pages(page, order);
+		return;
+	}
+#endif
 	list_add(&page->lru, &list);
 	kernel_map_pages(page, 1<<order, 0);
 	free_pages_bulk(page_zone(page), 1, &list, order);
@@ -474,6 +486,35 @@ void drain_local_pages(void)
 	__drain_pages(smp_processor_id());
 	local_irq_restore(flags);	
 }
+
+#ifdef CONFIG_SMP
+static void __smp_drain_local_pages(void * data)
+{
+	drain_local_pages();
+}
+
+void smp_drain_local_pages(void)
+{
+	smp_call_function(__smp_drain_local_pages, NULL, 0, 1);
+	drain_local_pages();
+}
+#else
+void smp_drain_local_pages(void)
+{
+	drain_local_pages();
+}
+#endif
+
+void disable_pcp_lists(void)
+{
+	pcp_lists_enabled = 0;
+	smp_drain_local_pages();
+}
+
+void enable_pcp_lists(void)
+{
+	pcp_lists_enabled = 1;
+}
 #endif /* CONFIG_PM */
 
 static void zone_statistics(struct zonelist *zonelist, struct zone *z)
@@ -512,6 +553,11 @@ static void fastcall free_hot_cold_page(
 	struct per_cpu_pages *pcp;
 	unsigned long flags;
 
+	if (!pcp_lists_enabled) {
+		__free_pages_ok(page, 0);
+		return;
+	}
+
 	kernel_map_pages(page, 1, 0);
 	inc_page_state(pgfree);
 	free_pages_check(__FUNCTION__, page);
@@ -639,7 +685,7 @@ buffered_rmqueue(struct zone *zone, int 
 	struct page *page = NULL;
 	int cold = !!(gfp_flags & __GFP_COLD);
 
-	if (order == 0) {
+	if ((order == 0) && (pcp_lists_enabled)) {
 		struct per_cpu_pages *pcp;
 
 		pcp = &zone->pageset[get_cpu()].pcp[cold];
@@ -702,6 +748,22 @@ __alloc_pages(unsigned int gfp_mask, uns
 	int alloc_type;
 	int do_retry;
 
+#if CONFIG_SOFTWARE_SUSPEND2
+	if (unlikely(software_suspend_state & SOFTWARE_SUSPEND_USE_MEMORY_POOL)) {
+		/*
+		 * When pool enabled, processes get allocations
+		 * from a special pool so the image size doesn't
+		 * vary (all the pages in the pool are saved,
+		 * used or not).
+		 *
+		 * The only process that should be running is
+		 * suspend, so the demand should be very
+		 * predicatable.
+		 */
+		return get_suspend_pool_page(gfp_mask, order);
+	}
+#endif
+
 	might_sleep_if(wait);
 
 	if (order == 0) {
diff -puN mm/pdflush.c~20-software-suspend-linux-2.6.7-rev1-whole mm/pdflush.c
--- linux-2.6.7-xx2/mm/pdflush.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.387850256 -0400
+++ linux-2.6.7-xx2-xiphux/mm/pdflush.c	2004-06-24 07:14:56.429539872 -0400
@@ -90,7 +90,13 @@ struct pdflush_work {
 
 static int __pdflush(struct pdflush_work *my_work)
 {
+	DECLARE_SWSUSP_LOCAL_VAR;
+
 	current->flags |= PF_FLUSHER;
+
+	SWSUSP_THREAD_FLAGS_RESET;
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
+
 	my_work->fn = NULL;
 	my_work->who = current;
 	INIT_LIST_HEAD(&my_work->list);
@@ -104,14 +110,11 @@ static int __pdflush(struct pdflush_work
 		list_move(&my_work->list, &pdflush_list);
 		my_work->when_i_went_to_sleep = jiffies;
 		spin_unlock_irq(&pdflush_lock);
+		SWSUSP_ACTIVITY_SYNCTHREAD_PAUSING;
 
 		schedule();
-		if (current->flags & PF_FREEZE) {
-			refrigerator(PF_FREEZE);
-			spin_lock_irq(&pdflush_lock);
-			continue;
-		}
 
+		SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 		spin_lock_irq(&pdflush_lock);
 		if (!list_empty(&my_work->list)) {
 			printk("pdflush: bogus wakeup!\n");
@@ -159,6 +162,7 @@ static int __pdflush(struct pdflush_work
 	}
 	nr_pdflush_threads--;
 	spin_unlock_irq(&pdflush_lock);
+	SWSUSP_ACTIVITY_END;
 	return 0;
 }
 
@@ -215,7 +219,7 @@ int pdflush_operation(void (*fn)(unsigne
 
 static void start_one_pdflush_thread(void)
 {
-	kthread_run(pdflush, NULL, "pdflush");
+	kthread_run(pdflush, NULL, 0, "pdflush");
 }
 
 static int __init pdflush_init(void)
diff -puN mm/swapfile.c~20-software-suspend-linux-2.6.7-rev1-whole mm/swapfile.c
--- linux-2.6.7-xx2/mm/swapfile.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.389849952 -0400
+++ linux-2.6.7-xx2-xiphux/mm/swapfile.c	2004-06-24 07:14:56.431539568 -0400
@@ -29,6 +29,7 @@
 #include <asm/pgtable.h>
 #include <asm/tlbflush.h>
 #include <linux/swapops.h>
+#include <linux/suspend.h>
 
 spinlock_t swaplock = SPIN_LOCK_UNLOCKED;
 unsigned int nr_swapfiles;
@@ -192,6 +193,8 @@ swp_entry_t get_swap_page(void)
 	}
 out:
 	swap_list_unlock();
+	if (suspend_task)
+		printnolog(SUSPEND_SWAP, SUSPEND_VERBOSE, 1, "[Get SWAP %lx]", swp_offset(entry));
 	return entry;
 }
 
@@ -269,6 +272,8 @@ void swap_free(swp_entry_t entry)
 
 	p = swap_info_get(entry);
 	if (p) {
+		if (suspend_task)
+			printnolog(SUSPEND_SWAP, SUSPEND_VERBOSE, 1, "[Free SWAP %lx]", entry.val);
 		swap_entry_free(p, swp_offset(entry));
 		swap_info_put(p);
 	}
diff -puN mm/vmscan.c~20-software-suspend-linux-2.6.7-rev1-whole mm/vmscan.c
--- linux-2.6.7-xx2/mm/vmscan.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.392849496 -0400
+++ linux-2.6.7-xx2-xiphux/mm/vmscan.c	2004-06-24 07:14:56.434539112 -0400
@@ -18,10 +18,10 @@
 #include <linux/swap.h>
 #include <linux/pagemap.h>
 #include <linux/init.h>
+#include <linux/suspend.h>
 #include <linux/highmem.h>
 #include <linux/file.h>
 #include <linux/writeback.h>
-#include <linux/suspend.h>
 #include <linux/blkdev.h>
 #include <linux/buffer_head.h>	/* for try_to_release_page(),
 					buffer_heads_over_limit */
diff -puN net/bluetooth/bnep/core.c~20-software-suspend-linux-2.6.7-rev1-whole net/bluetooth/bnep/core.c
--- linux-2.6.7-xx2/net/bluetooth/bnep/core.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.394849192 -0400
+++ linux-2.6.7-xx2-xiphux/net/bluetooth/bnep/core.c	2004-06-24 07:14:56.435538960 -0400
@@ -54,6 +54,8 @@
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/l2cap.h>
 
+#include <linux/suspend.h>
+
 #include "bnep.h"
 
 #ifndef CONFIG_BT_BNEP_DEBUG
diff -puN net/bluetooth/rfcomm/core.c~20-software-suspend-linux-2.6.7-rev1-whole net/bluetooth/rfcomm/core.c
--- linux-2.6.7-xx2/net/bluetooth/rfcomm/core.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.413846304 -0400
+++ linux-2.6.7-xx2-xiphux/net/bluetooth/rfcomm/core.c	2004-06-24 07:14:56.439538352 -0400
@@ -42,6 +42,7 @@
 #include <linux/net.h>
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
+#include <linux/suspend.h>
 #include <net/sock.h>
 #include <asm/uaccess.h>
 #include <asm/unaligned.h>
@@ -1728,14 +1729,20 @@ static inline void rfcomm_process_sessio
 
 static void rfcomm_worker(void)
 {
+	DECLARE_SWSUSP_LOCAL_VAR;
 	BT_DBG("");
 
+	SWSUSP_THREAD_FLAGS_RESET;
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
+
 	while (!atomic_read(&terminate)) {
 		if (!test_bit(RFCOMM_SCHED_WAKEUP, &rfcomm_event)) {
 			/* No pending events. Let's sleep.
 			 * Incoming connections and data will wake us up. */
 			set_current_state(TASK_INTERRUPTIBLE);
+			SWSUSP_ACTIVITY_PAUSING;
 			schedule();
+			SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 		}
 
 		/* Process stuff */
@@ -1743,6 +1750,7 @@ static void rfcomm_worker(void)
 		rfcomm_process_sessions();
 	}
 	set_current_state(TASK_RUNNING);
+	SWSUSP_ACTIVITY_END;
 	return;
 }
 
diff -puN net/socket.c~20-software-suspend-linux-2.6.7-rev1-whole net/socket.c
--- linux-2.6.7-xx2/net/socket.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.415846000 -0400
+++ linux-2.6.7-xx2-xiphux/net/socket.c	2004-06-24 07:14:56.442537896 -0400
@@ -81,6 +81,7 @@
 #include <linux/syscalls.h>
 #include <linux/compat.h>
 #include <linux/kmod.h>
+#include <linux/suspend.h>
 
 #ifdef CONFIG_NET_RADIO
 #include <linux/wireless.h>		/* Note : will define WIRELESS_EXT */
@@ -532,6 +533,9 @@ static inline int __sock_sendmsg(struct 
 {
 	struct sock_iocb *si = kiocb_to_siocb(iocb);
 	int err;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_PAUSING;
 
 	si->sock = sock;
 	si->scm = NULL;
@@ -539,9 +543,12 @@ static inline int __sock_sendmsg(struct 
 	si->size = size;
 
 	err = security_socket_sendmsg(sock, msg, size);
-	if (err)
+	if (err) {
+		SWSUSP_ACTIVITY_RESTARTING(0);
 		return err;
+	}
 
+	SWSUSP_ACTIVITY_RESTARTING(0);
 	return sock->ops->sendmsg(iocb, sock, msg, size);
 }
 
@@ -563,6 +570,10 @@ static inline int __sock_recvmsg(struct 
 {
 	int err;
 	struct sock_iocb *si = kiocb_to_siocb(iocb);
+	int result;
+	DECLARE_SWSUSP_LOCAL_VAR;
+
+	SWSUSP_ACTIVITY_PAUSING;
 
 	si->sock = sock;
 	si->scm = NULL;
@@ -571,10 +582,14 @@ static inline int __sock_recvmsg(struct 
 	si->flags = flags;
 
 	err = security_socket_recvmsg(sock, msg, size, flags);
-	if (err)
+	if (err) {
+		SWSUSP_ACTIVITY_RESTARTING(0);
 		return err;
+	}
 
-	return sock->ops->recvmsg(iocb, sock, msg, size, flags);
+	result = sock->ops->recvmsg(iocb, sock, msg, size, flags);
+	SWSUSP_ACTIVITY_RESTARTING(0);
+	return result;
 }
 
 int sock_recvmsg(struct socket *sock, struct msghdr *msg, 
diff -puN net/sunrpc/sched.c~20-software-suspend-linux-2.6.7-rev1-whole net/sunrpc/sched.c
--- linux-2.6.7-xx2/net/sunrpc/sched.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.418845544 -0400
+++ linux-2.6.7-xx2-xiphux/net/sunrpc/sched.c	2004-06-24 07:14:56.444537592 -0400
@@ -630,6 +630,7 @@ static int
 __rpc_execute(struct rpc_task *task)
 {
 	int		status = 0;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	dprintk("RPC: %4d rpc_execute flgs %x\n",
 				task->tk_pid, task->tk_flags);
@@ -698,6 +699,7 @@ __rpc_execute(struct rpc_task *task)
 		if (current->pid == rpciod_pid)
 			printk(KERN_ERR "RPC: rpciod waiting on sync task!\n");
 
+		SWSUSP_ACTIVITY_SYNCTHREAD_PAUSING;
 		if (!task->tk_client->cl_intr) {
 			__wait_event(task->tk_wait, !RPC_IS_SLEEPING(task));
 		} else {
@@ -715,6 +717,7 @@ __rpc_execute(struct rpc_task *task)
 				rpc_wake_up_task(task);
 			}
 		}
+		SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 		dprintk("RPC: %4d sync task resuming\n", task->tk_pid);
 	}
 
@@ -783,6 +786,7 @@ __rpc_schedule(void)
 {
 	struct rpc_task	*task;
 	int		count = 0;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	dprintk("RPC:      rpc_schedule enter\n");
 	while (1) {
@@ -800,7 +804,9 @@ __rpc_schedule(void)
 		if (++count >= 200 || need_resched()) {
 			count = 0;
 			spin_unlock_bh(&rpc_queue_lock);
+			SWSUSP_ACTIVITY_SYNCTHREAD_PAUSING;
 			schedule();
+			SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 			spin_lock_bh(&rpc_queue_lock);
 		}
 	}
@@ -1103,6 +1109,7 @@ static int
 rpciod(void *ptr)
 {
 	int		rounds = 0;
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	lock_kernel();
 	/*
@@ -1114,6 +1121,11 @@ rpciod(void *ptr)
 	daemonize("rpciod");
 	allow_signal(SIGKILL);
 
+	current->flags |= PF_SYNCTHREAD;
+
+	SWSUSP_THREAD_FLAGS_RESET;
+	SWSUSP_ACTIVITY_START(PF_SYNCTHREAD);
+
 	dprintk("RPC: rpciod starting (pid %d)\n", rpciod_pid);
 	spin_lock_bh(&rpc_queue_lock);
 	while (rpciod_users) {
@@ -1125,15 +1137,12 @@ rpciod(void *ptr)
 			spin_lock_bh(&rpc_queue_lock);
 		}
 		__rpc_schedule();
-		if (current->flags & PF_FREEZE) {
-			spin_unlock_bh(&rpc_queue_lock);
-			refrigerator(PF_FREEZE);
-			spin_lock_bh(&rpc_queue_lock);
-		}
 
 		if (++rounds >= 64) {	/* safeguard */
 			spin_unlock_bh(&rpc_queue_lock);
+			SWSUSP_ACTIVITY_SYNCTHREAD_PAUSING;
 			schedule();
+			SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 			rounds = 0;
 			spin_lock_bh(&rpc_queue_lock);
 		}
@@ -1142,7 +1151,9 @@ rpciod(void *ptr)
 		prepare_to_wait(&rpciod_idle, &wait, TASK_INTERRUPTIBLE);
 		if (!rpciod_task_pending() && !signalled()) {
 			spin_unlock_bh(&rpc_queue_lock);
+			SWSUSP_ACTIVITY_SYNCTHREAD_PAUSING;
 			schedule();
+			SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 			rounds = 0;
 			spin_lock_bh(&rpc_queue_lock);
 		}
@@ -1161,6 +1172,7 @@ rpciod(void *ptr)
 	unlock_kernel();
 
 	rpciod_pid = 0;
+	SWSUSP_ACTIVITY_END;
 	complete_and_exit(&rpciod_killer, 0);
 	return 0;
 }
diff -puN net/sunrpc/svcsock.c~20-software-suspend-linux-2.6.7-rev1-whole net/sunrpc/svcsock.c
--- linux-2.6.7-xx2/net/sunrpc/svcsock.c~20-software-suspend-linux-2.6.7-rev1-whole	2004-06-24 07:14:54.421845088 -0400
+++ linux-2.6.7-xx2-xiphux/net/sunrpc/svcsock.c	2004-06-24 07:14:56.447537136 -0400
@@ -1151,6 +1151,7 @@ svc_recv(struct svc_serv *serv, struct s
 	int 			pages;
 	struct xdr_buf		*arg;
 	DECLARE_WAITQUEUE(wait, current);
+	DECLARE_SWSUSP_LOCAL_VAR;
 
 	dprintk("svc: server %p waiting for data (to = %ld)\n",
 		rqstp, timeout);
@@ -1173,8 +1174,10 @@ svc_recv(struct svc_serv *serv, struct s
 	while (rqstp->rq_arghi < pages) {
 		struct page *p = alloc_page(GFP_KERNEL);
 		if (!p) {
+			SWSUSP_ACTIVITY_SYNCTHREAD_PAUSING;
 			set_current_state(TASK_UNINTERRUPTIBLE);
 			schedule_timeout(HZ/2);
+			SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 			continue;
 		}
 		rqstp->rq_argpages[rqstp->rq_arghi++] = p;
@@ -1229,12 +1232,11 @@ svc_recv(struct svc_serv *serv, struct s
 		set_current_state(TASK_INTERRUPTIBLE);
 		add_wait_queue(&rqstp->rq_wait, &wait);
 		spin_unlock_bh(&serv->sv_lock);
+		SWSUSP_ACTIVITY_SYNCTHREAD_PAUSING;
 
 		schedule_timeout(timeout);
 
-		if (current->flags & PF_FREEZE)
-			refrigerator(PF_FREEZE);
-
+		SWSUSP_ACTIVITY_RESTARTING(PF_SYNCTHREAD);
 		spin_lock_bh(&serv->sv_lock);
 		remove_wait_queue(&rqstp->rq_wait, &wait);
 

_
