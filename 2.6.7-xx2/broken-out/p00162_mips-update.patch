
From: Ralf Baechle <ralf@linux-mips.org>

MIPS update:

 - Further conversion of MIPS kernel configuration to reverse dependencies.
 - Support for the PMC-Sierra Yosemite evaluation board.
 - Merge arch/mips/mm-32 and arch/mips/mm-32 into arch/mips/mm.
 - Partial support for the R8000 now that I finally have clearance for the
   documentation previously covered by NDA.
 - Make distclean fixes.
 - Regenerate default configuration files against latest Kconfig files.
 - Fix handling of data bus errors in modules.
 - Make R4000 bug probing more bullet proof.
 - Rewrite semaphore code folloing the PPC implementation to no longer
   manipulate 2 32-bit quantities atomically using 64-bit instructions.
   Occasionally this did cause problems due to struct semaphore not having
   sufficient alignment.
 - Make sys_pipe() code bullet proof against gcc 3.5 over-optimization.
 - Fix possibly exploitable bug in IRIX compatibility statvfs(2).
 - Make sched_clock() an outline function.
 - Support for the MIPS 24K and 25K processors.
 - Make functions static that aren't needed anywhere else.
 - Factor out some more generic MIPS SMP code.
 - Factor out common part of the GT-64240 code.
 - Ocelot C now uses the generic MV-64340 interrupt handler code.
 - Factor out common board support code
 - More cleanup and bug fixes for the NEC VR41xx code.
 - Start cleanup of hazard handling as required for MIPS32/64 V2 processors.
 - Enforce minimal kmalloc alignment of 8 byte so 64-bit registers can be
   stored into fields without exceptions.
 - Speeling and warning fixes.

Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
Signed-off-by: Andrew Morton <akpm@osdl.org>
---

 /dev/null                                                      | 2867 ----------
 25-akpm/arch/mips/Kconfig                                      |   78 
 25-akpm/arch/mips/Makefile                                     |    9 
 25-akpm/arch/mips/boot/Makefile                                |    2 
 25-akpm/arch/mips/configs/atlas_defconfig                      |    9 
 25-akpm/arch/mips/configs/bosporus_defconfig                   |    7 
 25-akpm/arch/mips/configs/capcella_defconfig                   |   12 
 25-akpm/arch/mips/configs/cobalt_defconfig                     |    8 
 25-akpm/arch/mips/configs/db1000_defconfig                     |    8 
 25-akpm/arch/mips/configs/db1100_defconfig                     |    7 
 25-akpm/arch/mips/configs/db1500_defconfig                     |   10 
 25-akpm/arch/mips/configs/ddb5476_defconfig                    |    9 
 25-akpm/arch/mips/configs/ddb5477_defconfig                    |    7 
 25-akpm/arch/mips/configs/decstation_defconfig                 |    4 
 25-akpm/arch/mips/configs/e55_defconfig                        |    6 
 25-akpm/arch/mips/configs/eagle_defconfig                      |   11 
 25-akpm/arch/mips/configs/ev64120_defconfig                    |    6 
 25-akpm/arch/mips/configs/ev96100_defconfig                    |    4 
 25-akpm/arch/mips/configs/ip22_defconfig                       |    5 
 25-akpm/arch/mips/configs/ip27_defconfig                       |    9 
 25-akpm/arch/mips/configs/ip32_defconfig                       |    8 
 25-akpm/arch/mips/configs/it8172_defconfig                     |    6 
 25-akpm/arch/mips/configs/ivr_defconfig                        |    8 
 25-akpm/arch/mips/configs/jaguar-atx_defconfig                 |    4 
 25-akpm/arch/mips/configs/jmr3927_defconfig                    |    7 
 25-akpm/arch/mips/configs/lasat200_defconfig                   |    8 
 25-akpm/arch/mips/configs/malta_defconfig                      |    6 
 25-akpm/arch/mips/configs/mirage_defconfig                     |    7 
 25-akpm/arch/mips/configs/mpc30x_defconfig                     |    9 
 25-akpm/arch/mips/configs/mtx1_defconfig                       |    7 
 25-akpm/arch/mips/configs/ocelot_c_defconfig                   |   50 
 25-akpm/arch/mips/configs/ocelot_defconfig                     |    4 
 25-akpm/arch/mips/configs/ocelot_g_defconfig                   |  587 ++
 25-akpm/arch/mips/configs/osprey_defconfig                     |    4 
 25-akpm/arch/mips/configs/pb1000_defconfig                     |    7 
 25-akpm/arch/mips/configs/pb1100_defconfig                     |    7 
 25-akpm/arch/mips/configs/pb1500_defconfig                     |   12 
 25-akpm/arch/mips/configs/pb1550_defconfig                     |   12 
 25-akpm/arch/mips/configs/rm200_defconfig                      |   17 
 25-akpm/arch/mips/configs/sb1250-swarm_defconfig               |   34 
 25-akpm/arch/mips/configs/sead_defconfig                       |    3 
 25-akpm/arch/mips/configs/tb0226_defconfig                     |    8 
 25-akpm/arch/mips/configs/tb0229_defconfig                     |   10 
 25-akpm/arch/mips/configs/workpad_defconfig                    |    5 
 25-akpm/arch/mips/configs/xxs1500_defconfig                    |    7 
 25-akpm/arch/mips/configs/yosemite_defconfig                   |  181 
 25-akpm/arch/mips/defconfig                                    |    5 
 25-akpm/arch/mips/kernel/Makefile                              |    3 
 25-akpm/arch/mips/kernel/cpu-bugs64.c                          |   40 
 25-akpm/arch/mips/kernel/cpu-probe.c                           |   46 
 25-akpm/arch/mips/kernel/module-elf32.c                        |   11 
 25-akpm/arch/mips/kernel/module-elf64.c                        |   11 
 25-akpm/arch/mips/kernel/module.c                              |   53 
 25-akpm/arch/mips/kernel/scall32-o32.S                         |    1 
 25-akpm/arch/mips/kernel/scall64-64.S                          |    1 
 25-akpm/arch/mips/kernel/scall64-n32.S                         |    1 
 25-akpm/arch/mips/kernel/scall64-o32.S                         |    1 
 25-akpm/arch/mips/kernel/semaphore.c                           |  326 -
 25-akpm/arch/mips/kernel/setup.c                               |   14 
 25-akpm/arch/mips/kernel/syscall.c                             |    2 
 25-akpm/arch/mips/kernel/sysirix.c                             |    2 
 25-akpm/arch/mips/kernel/time.c                                |    5 
 25-akpm/arch/mips/kernel/traps.c                               |   59 
 25-akpm/arch/mips/lib-32/Makefile                              |   22 
 25-akpm/arch/mips/lib-64/Makefile                              |   22 
 25-akpm/arch/mips/mips-boards/generic/cmdline.c                |    6 
 25-akpm/arch/mips/mips-boards/generic/printf.c                 |   34 
 25-akpm/arch/mips/mm/Makefile                                  |   39 
 25-akpm/arch/mips/mm/tlb-r8k.c                                 |  253 
 25-akpm/arch/mips/mm/tlb-sb1.c                                 |    2 
 25-akpm/arch/mips/mm/tlb64-glue-r4k.S                          |   41 
 25-akpm/arch/mips/mm/tlb64-glue-sb1.S                          |   66 
 25-akpm/arch/mips/mm/tlbex32-r3k.S                             |  224 
 25-akpm/arch/mips/mm/tlbex32-r4k.S                             |  524 +
 25-akpm/arch/mips/mm/tlbex64-r4k.S                             |  203 
 25-akpm/arch/mips/momentum/jaguar_atx/prom.c                   |   14 
 25-akpm/arch/mips/momentum/jaguar_atx/setup.c                  |    2 
 25-akpm/arch/mips/momentum/ocelot_c/Makefile                   |    4 
 25-akpm/arch/mips/momentum/ocelot_c/irq.c                      |    3 
 25-akpm/arch/mips/momentum/ocelot_c/prom.c                     |    3 
 25-akpm/arch/mips/momentum/ocelot_c/setup.c                    |    2 
 25-akpm/arch/mips/momentum/ocelot_g/Makefile                   |    3 
 25-akpm/arch/mips/momentum/ocelot_g/gt-irq.c                   |   96 
 25-akpm/arch/mips/momentum/ocelot_g/prom.c                     |    8 
 25-akpm/arch/mips/momentum/ocelot_g/setup.c                    |  116 
 25-akpm/arch/mips/pci/Makefile                                 |   17 
 25-akpm/arch/mips/pci/fixup-capcella.c                         |   28 
 25-akpm/arch/mips/pci/fixup-jaguar.c                           |   42 
 25-akpm/arch/mips/pci/fixup-mpc30x.c                           |   48 
 25-akpm/arch/mips/pci/fixup-ocelot-c.c                         |   39 
 25-akpm/arch/mips/pci/fixup-ocelot-g.c                         |   35 
 25-akpm/arch/mips/pci/fixup-tb0219.c                           |   64 
 25-akpm/arch/mips/pci/fixup-tb0226.c                           |  117 
 25-akpm/arch/mips/pci/fixup-yosemite.c                         |   17 
 25-akpm/arch/mips/pci/ops-gt64240.c                            |  149 
 25-akpm/arch/mips/pci/ops-msc.c                                |    6 
 25-akpm/arch/mips/pci/ops-titan-ht.c                           |  125 
 25-akpm/arch/mips/pci/ops-titan.c                              |   32 
 25-akpm/arch/mips/pci/ops-vr41xx.c                             |  126 
 25-akpm/arch/mips/pci/pci-ocelot-c.c                           |  159 
 25-akpm/arch/mips/pci/pci-ocelot-g.c                           |  496 -
 25-akpm/arch/mips/pci/pci-vr41xx.c                             |  406 -
 25-akpm/arch/mips/pci/pci-vr41xx.h                             |  287 -
 25-akpm/arch/mips/pci/pci-yosemite.c                           |   37 
 25-akpm/arch/mips/pci/pci.c                                    |    2 
 25-akpm/arch/mips/pmc-sierra/yosemite/Makefile                 |    7 
 25-akpm/arch/mips/pmc-sierra/yosemite/dbg_io.c                 |  184 
 25-akpm/arch/mips/pmc-sierra/yosemite/i2c-yosemite.c           |  188 
 25-akpm/arch/mips/pmc-sierra/yosemite/i2c-yosemite.h           |   52 
 25-akpm/arch/mips/pmc-sierra/yosemite/irq-handler.S            |   87 
 25-akpm/arch/mips/pmc-sierra/yosemite/irq.c                    |  247 
 25-akpm/arch/mips/pmc-sierra/yosemite/prom.c                   |  144 
 25-akpm/arch/mips/pmc-sierra/yosemite/py-console.c             |  130 
 25-akpm/arch/mips/pmc-sierra/yosemite/setup.c                  |  177 
 25-akpm/arch/mips/pmc-sierra/yosemite/setup.h                  |   18 
 25-akpm/arch/mips/ramdisk/Makefile                             |    2 
 25-akpm/arch/mips/sgi-ip22/ip22-setup.c                        |    3 
 25-akpm/arch/mips/vr41xx/common/bcu.c                          |   60 
 25-akpm/arch/mips/vr41xx/common/cmu.c                          |    6 
 25-akpm/arch/mips/vr41xx/common/giu.c                          |  242 
 25-akpm/arch/mips/vr41xx/common/icu.c                          |  493 +
 25-akpm/arch/mips/vr41xx/common/init.c                         |   15 
 25-akpm/arch/mips/vr41xx/common/ksyms.c                        |    2 
 25-akpm/arch/mips/vr41xx/common/pmu.c                          |    8 
 25-akpm/arch/mips/vr41xx/common/rtc.c                          |    8 
 25-akpm/arch/mips/vr41xx/common/serial.c                       |    2 
 25-akpm/arch/mips/vr41xx/common/vrc4173.c                      |  404 +
 25-akpm/arch/mips/vr41xx/tanbac-tb0226/setup.c                 |   61 
 25-akpm/arch/mips/vr41xx/tanbac-tb0229/Makefile                |    2 
 25-akpm/arch/mips/vr41xx/tanbac-tb0229/setup.c                 |   66 
 25-akpm/arch/mips/vr41xx/tanbac-tb0229/tb0219.c                |   44 
 25-akpm/arch/mips/vr41xx/victor-mpc30x/setup.c                 |   61 
 25-akpm/arch/mips/vr41xx/zao-capcella/setup.c                  |   61 
 25-akpm/include/asm-mips/asmmacro.h                            |    4 
 25-akpm/include/asm-mips/atomic.h                              |  130 
 25-akpm/include/asm-mips/cache.h                               |    2 
 25-akpm/include/asm-mips/gt64240.h                             | 1264 ++++
 25-akpm/include/asm-mips/hazards.h                             |  117 
 25-akpm/include/asm-mips/mach-yosemite/cpu-feature-overrides.h |   38 
 25-akpm/include/asm-mips/mipsregs.h                            |    2 
 25-akpm/include/asm-mips/mmu_context.h                         |   12 
 25-akpm/include/asm-mips/module.h                              |   19 
 25-akpm/include/asm-mips/page.h                                |    6 
 25-akpm/include/asm-mips/pci.h                                 |    3 
 25-akpm/include/asm-mips/pgtable-32.h                          |   72 
 25-akpm/include/asm-mips/pgtable-64.h                          |   33 
 25-akpm/include/asm-mips/pgtable-bits.h                        |   18 
 25-akpm/include/asm-mips/pgtable.h                             |    2 
 25-akpm/include/asm-mips/pmon.h                                |    3 
 25-akpm/include/asm-mips/processor.h                           |    9 
 25-akpm/include/asm-mips/semaphore.h                           |  265 
 25-akpm/include/asm-mips/serial.h                              |   19 
 25-akpm/include/asm-mips/smp.h                                 |    8 
 25-akpm/include/asm-mips/stackframe.h                          |    3 
 25-akpm/include/asm-mips/system.h                              |   21 
 25-akpm/include/asm-mips/thread_info.h                         |    3 
 25-akpm/include/asm-mips/titan_dep.h                           |  181 
 25-akpm/include/asm-mips/unistd.h                              |   15 
 25-akpm/include/asm-mips/vr41xx/capcella.h                     |   54 
 25-akpm/include/asm-mips/vr41xx/mpc30x.h                       |   54 
 25-akpm/include/asm-mips/vr41xx/tb0219.h                       |   42 
 25-akpm/include/asm-mips/vr41xx/tb0226.h                       |   54 
 25-akpm/include/asm-mips/vr41xx/vr41xx.h                       |  144 
 25-akpm/include/asm-mips/vr41xx/vrc4173.h                      |   78 
 164 files changed, 7922 insertions(+), 6123 deletions(-)

diff -puN arch/mips/boot/Makefile~mips-update arch/mips/boot/Makefile
--- 25/arch/mips/boot/Makefile~mips-update	2004-06-21 23:10:45.214345952 -0700
+++ 25-akpm/arch/mips/boot/Makefile	2004-06-21 23:10:45.532297616 -0700
@@ -39,7 +39,7 @@ $(obj)/addinitrd: $(obj)/addinitrd.c
 archhelp:
 	@echo	'* vmlinux.ecoff	- ECOFF boot image'
 
-CLEAN_FILES += addinitrd \
+clean-files += addinitrd \
 	       elf2ecoff \
 	       vmlinux.ecoff \
 	       vmlinux.srec \
diff -puN arch/mips/configs/atlas_defconfig~mips-update arch/mips/configs/atlas_defconfig
--- 25/arch/mips/configs/atlas_defconfig~mips-update	2004-06-21 23:10:45.218345344 -0700
+++ 25-akpm/arch/mips/configs/atlas_defconfig	2004-06-21 23:10:45.534297312 -0700
@@ -107,6 +107,7 @@ CONFIG_CPU_MIPS32=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
@@ -121,6 +122,7 @@ CONFIG_CPU_HAS_SYNC=y
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
 CONFIG_PCI_NAMES=y
@@ -197,7 +199,6 @@ CONFIG_BLK_DEV_SD=y
 # Some SCSI devices (e.g. CD jukebox) support multiple LUNs
 #
 # CONFIG_SCSI_MULTI_LUN is not set
-# CONFIG_SCSI_REPORT_LUNS is not set
 # CONFIG_SCSI_CONSTANTS is not set
 # CONFIG_SCSI_LOGGING is not set
 
@@ -216,11 +217,11 @@ CONFIG_BLK_DEV_SD=y
 # CONFIG_SCSI_AIC7XXX is not set
 # CONFIG_SCSI_AIC7XXX_OLD is not set
 # CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_DPT_I2O is not set
 # CONFIG_SCSI_ADVANSYS is not set
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_SATA is not set
 # CONFIG_SCSI_BUSLOGIC is not set
-# CONFIG_SCSI_CPQFCTS is not set
 # CONFIG_SCSI_DMX3191D is not set
 # CONFIG_SCSI_EATA is not set
 # CONFIG_SCSI_EATA_PIO is not set
@@ -229,6 +230,7 @@ CONFIG_BLK_DEV_SD=y
 # CONFIG_SCSI_IPS is not set
 # CONFIG_SCSI_INIA100 is not set
 # CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
 # CONFIG_SCSI_QLOGIC_ISP is not set
 # CONFIG_SCSI_QLOGIC_FC is not set
 # CONFIG_SCSI_QLOGIC_1280 is not set
@@ -395,7 +397,6 @@ CONFIG_NET_ETHERNET=y
 # CONFIG_PPP is not set
 # CONFIG_SLIP is not set
 # CONFIG_NET_FC is not set
-# CONFIG_RCPCI is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
 
@@ -616,7 +617,6 @@ CONFIG_SUNRPC=y
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -651,3 +651,4 @@ CONFIG_CMDLINE=""
 # Library routines
 #
 # CONFIG_CRC32 is not set
+# CONFIG_LIBCRC32C is not set
diff -puN arch/mips/configs/bosporus_defconfig~mips-update arch/mips/configs/bosporus_defconfig
--- 25/arch/mips/configs/bosporus_defconfig~mips-update	2004-06-21 23:10:45.220345040 -0700
+++ 25-akpm/arch/mips/configs/bosporus_defconfig	2004-06-21 23:10:45.536297008 -0700
@@ -105,6 +105,7 @@ CONFIG_CPU_MIPS32=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
@@ -496,6 +497,9 @@ CONFIG_FS_MBCACHE=y
 CONFIG_REISERFS_FS=m
 # CONFIG_REISERFS_CHECK is not set
 # CONFIG_REISERFS_PROC_INFO is not set
+CONFIG_REISERFS_FS_XATTR=y
+CONFIG_REISERFS_FS_POSIX_ACL=y
+CONFIG_REISERFS_FS_SECURITY=y
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
 # CONFIG_XFS_FS is not set
@@ -567,7 +571,6 @@ CONFIG_SMB_FS=m
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -652,11 +655,13 @@ CONFIG_CRYPTO_AES=y
 # CONFIG_CRYPTO_ARC4 is not set
 CONFIG_CRYPTO_DEFLATE=y
 CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
 #
 # Library routines
 #
 CONFIG_CRC32=y
+CONFIG_LIBCRC32C=m
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=y
diff -puN arch/mips/configs/capcella_defconfig~mips-update arch/mips/configs/capcella_defconfig
--- 25/arch/mips/configs/capcella_defconfig~mips-update	2004-06-21 23:10:45.223344584 -0700
+++ 25-akpm/arch/mips/configs/capcella_defconfig	2004-06-21 23:10:45.538296704 -0700
@@ -59,7 +59,8 @@ CONFIG_MACH_VR41XX=y
 # CONFIG_TANBAC_TB0229 is not set
 # CONFIG_VICTOR_MPC30X is not set
 CONFIG_ZAO_CAPCELLA=y
-# CONFIG_VRC4173 is not set
+CONFIG_PCI_VR41XX=y
+CONFIG_VRC4173=y
 # CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
@@ -91,7 +92,6 @@ CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
-CONFIG_DUMMY_KEYB=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 # CONFIG_FB is not set
 
@@ -116,6 +116,7 @@ CONFIG_CPU_VR41XX=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 # CONFIG_CPU_ADVANCED is not set
@@ -126,6 +127,7 @@ CONFIG_CPU_HAS_SYNC=y
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
 CONFIG_PCI_NAMES=y
@@ -185,7 +187,6 @@ CONFIG_BLK_DEV_IDE=y
 #
 CONFIG_BLK_DEV_IDEDISK=y
 # CONFIG_IDEDISK_MULTI_MODE is not set
-# CONFIG_IDEDISK_STROKE is not set
 # CONFIG_BLK_DEV_IDECD is not set
 # CONFIG_BLK_DEV_IDETAPE is not set
 # CONFIG_BLK_DEV_IDEFLOPPY is not set
@@ -197,6 +198,7 @@ CONFIG_IDE_TASKFILE_IO=y
 #
 CONFIG_IDE_GENERIC=y
 # CONFIG_BLK_DEV_IDEPCI is not set
+# CONFIG_IDE_ARM is not set
 # CONFIG_BLK_DEV_IDEDMA is not set
 # CONFIG_IDEDMA_AUTO is not set
 # CONFIG_BLK_DEV_HD is not set
@@ -214,7 +216,6 @@ CONFIG_IDE_GENERIC=y
 #
 # Fusion MPT device support
 #
-# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -357,7 +358,6 @@ CONFIG_NET_ETHERNET=y
 # CONFIG_HIPPI is not set
 # CONFIG_PPP is not set
 # CONFIG_SLIP is not set
-# CONFIG_RCPCI is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
 
@@ -591,7 +591,6 @@ CONFIG_SUNRPC=y
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -626,3 +625,4 @@ CONFIG_CMDLINE=""
 # Library routines
 #
 # CONFIG_CRC32 is not set
+CONFIG_LIBCRC32C=m
diff -puN arch/mips/configs/cobalt_defconfig~mips-update arch/mips/configs/cobalt_defconfig
--- 25/arch/mips/configs/cobalt_defconfig~mips-update	2004-06-21 23:10:45.225344280 -0700
+++ 25-akpm/arch/mips/configs/cobalt_defconfig	2004-06-21 23:10:45.539296552 -0700
@@ -104,6 +104,7 @@ CONFIG_CPU_NEVADA=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 # CONFIG_CPU_ADVANCED is not set
@@ -116,6 +117,7 @@ CONFIG_CPU_HAS_SYNC=y
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
 CONFIG_PCI_NAMES=y
@@ -176,7 +178,6 @@ CONFIG_BLK_DEV_IDE=y
 #
 CONFIG_BLK_DEV_IDEDISK=y
 # CONFIG_IDEDISK_MULTI_MODE is not set
-# CONFIG_IDEDISK_STROKE is not set
 # CONFIG_BLK_DEV_IDECD is not set
 # CONFIG_BLK_DEV_IDETAPE is not set
 # CONFIG_BLK_DEV_IDEFLOPPY is not set
@@ -188,6 +189,7 @@ CONFIG_IDE_TASKFILE_IO=y
 #
 CONFIG_IDE_GENERIC=y
 # CONFIG_BLK_DEV_IDEPCI is not set
+# CONFIG_IDE_ARM is not set
 # CONFIG_BLK_DEV_IDEDMA is not set
 # CONFIG_IDEDMA_AUTO is not set
 # CONFIG_BLK_DEV_HD is not set
@@ -205,7 +207,6 @@ CONFIG_IDE_GENERIC=y
 #
 # Fusion MPT device support
 #
-# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -344,7 +345,6 @@ CONFIG_NET_ETHERNET=y
 # CONFIG_HIPPI is not set
 # CONFIG_PPP is not set
 # CONFIG_SLIP is not set
-# CONFIG_RCPCI is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
 
@@ -567,7 +567,6 @@ CONFIG_SUNRPC=y
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -602,3 +601,4 @@ CONFIG_CMDLINE=""
 # Library routines
 #
 # CONFIG_CRC32 is not set
+# CONFIG_LIBCRC32C is not set
diff -puN arch/mips/configs/db1000_defconfig~mips-update arch/mips/configs/db1000_defconfig
--- 25/arch/mips/configs/db1000_defconfig~mips-update	2004-06-21 23:10:45.226344128 -0700
+++ 25-akpm/arch/mips/configs/db1000_defconfig	2004-06-21 23:10:45.541296248 -0700
@@ -122,6 +122,7 @@ CONFIG_CPU_MIPS32=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
@@ -136,6 +137,7 @@ CONFIG_CPU_HAS_SYNC=y
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_PCI=y
 # CONFIG_PCI is not set
 CONFIG_MMU=y
 
@@ -522,6 +524,9 @@ CONFIG_FS_MBCACHE=y
 CONFIG_REISERFS_FS=m
 # CONFIG_REISERFS_CHECK is not set
 # CONFIG_REISERFS_PROC_INFO is not set
+CONFIG_REISERFS_FS_XATTR=y
+CONFIG_REISERFS_FS_POSIX_ACL=y
+CONFIG_REISERFS_FS_SECURITY=y
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
 # CONFIG_XFS_FS is not set
@@ -593,7 +598,6 @@ CONFIG_SMB_FS=m
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -678,11 +682,13 @@ CONFIG_CRYPTO_AES=y
 # CONFIG_CRYPTO_ARC4 is not set
 CONFIG_CRYPTO_DEFLATE=y
 CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
 #
 # Library routines
 #
 CONFIG_CRC32=y
+CONFIG_LIBCRC32C=m
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=y
diff -puN arch/mips/configs/db1100_defconfig~mips-update arch/mips/configs/db1100_defconfig
--- 25/arch/mips/configs/db1100_defconfig~mips-update	2004-06-21 23:10:45.228343824 -0700
+++ 25-akpm/arch/mips/configs/db1100_defconfig	2004-06-21 23:10:45.543295944 -0700
@@ -122,6 +122,7 @@ CONFIG_CPU_MIPS32=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
@@ -518,6 +519,9 @@ CONFIG_FS_MBCACHE=y
 CONFIG_REISERFS_FS=m
 # CONFIG_REISERFS_CHECK is not set
 # CONFIG_REISERFS_PROC_INFO is not set
+CONFIG_REISERFS_FS_XATTR=y
+CONFIG_REISERFS_FS_POSIX_ACL=y
+CONFIG_REISERFS_FS_SECURITY=y
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
 # CONFIG_XFS_FS is not set
@@ -589,7 +593,6 @@ CONFIG_SMB_FS=m
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -674,11 +677,13 @@ CONFIG_CRYPTO_AES=y
 # CONFIG_CRYPTO_ARC4 is not set
 CONFIG_CRYPTO_DEFLATE=y
 CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
 #
 # Library routines
 #
 CONFIG_CRC32=y
+CONFIG_LIBCRC32C=m
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=y
diff -puN arch/mips/configs/db1500_defconfig~mips-update arch/mips/configs/db1500_defconfig
--- 25/arch/mips/configs/db1500_defconfig~mips-update	2004-06-21 23:10:45.230343520 -0700
+++ 25-akpm/arch/mips/configs/db1500_defconfig	2004-06-21 23:10:45.544295792 -0700
@@ -122,6 +122,7 @@ CONFIG_CPU_MIPS32=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
@@ -136,6 +137,7 @@ CONFIG_CPU_HAS_SYNC=y
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_PCI=y
 # CONFIG_PCI is not set
 CONFIG_MMU=y
 
@@ -259,7 +261,6 @@ CONFIG_BLK_DEV_IDE=y
 #
 CONFIG_BLK_DEV_IDEDISK=y
 # CONFIG_IDEDISK_MULTI_MODE is not set
-# CONFIG_IDEDISK_STROKE is not set
 CONFIG_BLK_DEV_IDECS=m
 # CONFIG_BLK_DEV_IDECD is not set
 # CONFIG_BLK_DEV_IDETAPE is not set
@@ -271,6 +272,7 @@ CONFIG_BLK_DEV_IDECS=m
 # IDE chipset support/bugfixes
 #
 CONFIG_IDE_GENERIC=y
+# CONFIG_IDE_ARM is not set
 # CONFIG_BLK_DEV_IDEDMA is not set
 # CONFIG_IDEDMA_AUTO is not set
 # CONFIG_BLK_DEV_HD is not set
@@ -592,6 +594,9 @@ CONFIG_FS_MBCACHE=y
 CONFIG_REISERFS_FS=m
 # CONFIG_REISERFS_CHECK is not set
 # CONFIG_REISERFS_PROC_INFO is not set
+CONFIG_REISERFS_FS_XATTR=y
+CONFIG_REISERFS_FS_POSIX_ACL=y
+CONFIG_REISERFS_FS_SECURITY=y
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
 # CONFIG_XFS_FS is not set
@@ -665,7 +670,6 @@ CONFIG_SMB_FS=m
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -750,11 +754,13 @@ CONFIG_CRYPTO_AES=y
 # CONFIG_CRYPTO_ARC4 is not set
 CONFIG_CRYPTO_DEFLATE=y
 CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
 #
 # Library routines
 #
 CONFIG_CRC32=y
+CONFIG_LIBCRC32C=m
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=y
diff -puN arch/mips/configs/ddb5476_defconfig~mips-update arch/mips/configs/ddb5476_defconfig
--- 25/arch/mips/configs/ddb5476_defconfig~mips-update	2004-06-21 23:10:45.232343216 -0700
+++ 25-akpm/arch/mips/configs/ddb5476_defconfig	2004-06-21 23:10:45.546295488 -0700
@@ -105,6 +105,7 @@ CONFIG_CPU_R5432=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 # CONFIG_CPU_ADVANCED is not set
@@ -117,6 +118,7 @@ CONFIG_CPU_HAS_SYNC=y
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
 CONFIG_PCI_NAMES=y
@@ -179,7 +181,6 @@ CONFIG_BLK_DEV_IDE=y
 #
 CONFIG_BLK_DEV_IDEDISK=y
 # CONFIG_IDEDISK_MULTI_MODE is not set
-# CONFIG_IDEDISK_STROKE is not set
 # CONFIG_BLK_DEV_IDECD is not set
 # CONFIG_BLK_DEV_IDETAPE is not set
 # CONFIG_BLK_DEV_IDEFLOPPY is not set
@@ -191,6 +192,7 @@ CONFIG_IDE_TASKFILE_IO=y
 #
 CONFIG_IDE_GENERIC=y
 # CONFIG_BLK_DEV_IDEPCI is not set
+# CONFIG_IDE_ARM is not set
 # CONFIG_IDE_CHIPSETS is not set
 # CONFIG_BLK_DEV_IDEDMA is not set
 # CONFIG_IDEDMA_AUTO is not set
@@ -214,7 +216,6 @@ CONFIG_IDE_GENERIC=y
 #
 # Fusion MPT device support
 #
-# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -363,7 +364,6 @@ CONFIG_NET_ETHERNET=y
 # CONFIG_HIPPI is not set
 # CONFIG_PPP is not set
 # CONFIG_SLIP is not set
-# CONFIG_RCPCI is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
 
@@ -487,6 +487,7 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # CONFIG_FB_PM2 is not set
 # CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ASILIANT is not set
 # CONFIG_FB_IMSTT is not set
 # CONFIG_FB_RIVA is not set
 # CONFIG_FB_MATROX is not set
@@ -606,7 +607,6 @@ CONFIG_SUNRPC=y
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -641,3 +641,4 @@ CONFIG_CMDLINE="ip=any"
 # Library routines
 #
 # CONFIG_CRC32 is not set
+# CONFIG_LIBCRC32C is not set
diff -puN arch/mips/configs/ddb5477_defconfig~mips-update arch/mips/configs/ddb5477_defconfig
--- 25/arch/mips/configs/ddb5477_defconfig~mips-update	2004-06-21 23:10:45.234342912 -0700
+++ 25-akpm/arch/mips/configs/ddb5477_defconfig	2004-06-21 23:10:45.548295184 -0700
@@ -80,7 +80,6 @@ CONFIG_DMA_NONCOHERENT=y
 CONFIG_I8259=y
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
-CONFIG_DUMMY_KEYB=y
 CONFIG_DDB5XXX_COMMON=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 # CONFIG_FB is not set
@@ -106,6 +105,7 @@ CONFIG_CPU_R5432=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 # CONFIG_CPU_ADVANCED is not set
@@ -118,6 +118,7 @@ CONFIG_CPU_HAS_SYNC=y
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
 CONFIG_PCI_NAMES=y
@@ -184,7 +185,6 @@ CONFIG_TRAD_SIGNALS=y
 #
 # Fusion MPT device support
 #
-# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -345,7 +345,6 @@ CONFIG_PCNET32=y
 # CONFIG_HIPPI is not set
 # CONFIG_PPP is not set
 # CONFIG_SLIP is not set
-# CONFIG_RCPCI is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
 
@@ -567,7 +566,6 @@ CONFIG_SUNRPC=y
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -602,3 +600,4 @@ CONFIG_CMDLINE="ip=any"
 # Library routines
 #
 CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
diff -puN arch/mips/configs/decstation_defconfig~mips-update arch/mips/configs/decstation_defconfig
--- 25/arch/mips/configs/decstation_defconfig~mips-update	2004-06-21 23:10:45.236342608 -0700
+++ 25-akpm/arch/mips/configs/decstation_defconfig	2004-06-21 23:10:45.549295032 -0700
@@ -109,6 +109,7 @@ CONFIG_CPU_R3000=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 # CONFIG_CPU_ADVANCED is not set
@@ -184,7 +185,6 @@ CONFIG_BLK_DEV_SD=y
 # Some SCSI devices (e.g. CD jukebox) support multiple LUNs
 #
 # CONFIG_SCSI_MULTI_LUN is not set
-# CONFIG_SCSI_REPORT_LUNS is not set
 CONFIG_SCSI_CONSTANTS=y
 # CONFIG_SCSI_LOGGING is not set
 
@@ -537,7 +537,6 @@ CONFIG_RAMFS=y
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -587,3 +586,4 @@ CONFIG_CMDLINE=""
 # Library routines
 #
 CONFIG_CRC32=y
+CONFIG_LIBCRC32C=m
diff -puN arch/mips/configs/e55_defconfig~mips-update arch/mips/configs/e55_defconfig
--- 25/arch/mips/configs/e55_defconfig~mips-update	2004-06-21 23:10:45.238342304 -0700
+++ 25-akpm/arch/mips/configs/e55_defconfig	2004-06-21 23:10:45.551294728 -0700
@@ -91,7 +91,6 @@ CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
-CONFIG_DUMMY_KEYB=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 # CONFIG_FB is not set
 
@@ -116,6 +115,7 @@ CONFIG_CPU_VR41XX=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 # CONFIG_CPU_ADVANCED is not set
@@ -180,7 +180,6 @@ CONFIG_BLK_DEV_IDE=y
 #
 CONFIG_BLK_DEV_IDEDISK=y
 # CONFIG_IDEDISK_MULTI_MODE is not set
-# CONFIG_IDEDISK_STROKE is not set
 # CONFIG_BLK_DEV_IDECD is not set
 # CONFIG_BLK_DEV_IDETAPE is not set
 # CONFIG_BLK_DEV_IDEFLOPPY is not set
@@ -191,6 +190,7 @@ CONFIG_IDE_TASKFILE_IO=y
 # IDE chipset support/bugfixes
 #
 CONFIG_IDE_GENERIC=y
+# CONFIG_IDE_ARM is not set
 # CONFIG_IDE_CHIPSETS is not set
 # CONFIG_BLK_DEV_IDEDMA is not set
 # CONFIG_IDEDMA_AUTO is not set
@@ -570,7 +570,6 @@ CONFIG_SUNRPC=y
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -605,3 +604,4 @@ CONFIG_CMDLINE=""
 # Library routines
 #
 # CONFIG_CRC32 is not set
+CONFIG_LIBCRC32C=m
diff -puN arch/mips/configs/eagle_defconfig~mips-update arch/mips/configs/eagle_defconfig
--- 25/arch/mips/configs/eagle_defconfig~mips-update	2004-06-21 23:10:45.240342000 -0700
+++ 25-akpm/arch/mips/configs/eagle_defconfig	2004-06-21 23:10:45.552294576 -0700
@@ -59,6 +59,7 @@ CONFIG_NEC_EAGLE=y
 # CONFIG_TANBAC_TB0229 is not set
 # CONFIG_VICTOR_MPC30X is not set
 # CONFIG_ZAO_CAPCELLA is not set
+CONFIG_PCI_VR41XX=y
 CONFIG_VRC4173=y
 # CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_MIPS_COBALT is not set
@@ -91,7 +92,6 @@ CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
-CONFIG_DUMMY_KEYB=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 # CONFIG_FB is not set
 
@@ -116,6 +116,7 @@ CONFIG_CPU_VR41XX=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 # CONFIG_CPU_ADVANCED is not set
@@ -126,6 +127,7 @@ CONFIG_CPU_HAS_SYNC=y
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
 CONFIG_PCI_NAMES=y
@@ -261,7 +263,6 @@ CONFIG_BLK_DEV_IDE=y
 #
 CONFIG_BLK_DEV_IDEDISK=y
 CONFIG_IDEDISK_MULTI_MODE=y
-# CONFIG_IDEDISK_STROKE is not set
 CONFIG_BLK_DEV_IDECS=y
 # CONFIG_BLK_DEV_IDECD is not set
 # CONFIG_BLK_DEV_IDETAPE is not set
@@ -274,6 +275,7 @@ CONFIG_IDE_TASKFILE_IO=y
 #
 CONFIG_IDE_GENERIC=y
 # CONFIG_BLK_DEV_IDEPCI is not set
+# CONFIG_IDE_ARM is not set
 # CONFIG_BLK_DEV_IDEDMA is not set
 # CONFIG_IDEDMA_AUTO is not set
 # CONFIG_BLK_DEV_HD is not set
@@ -291,7 +293,6 @@ CONFIG_IDE_GENERIC=y
 #
 # Fusion MPT device support
 #
-# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -447,7 +448,6 @@ CONFIG_PCMCIA_PCNET=m
 # CONFIG_HIPPI is not set
 # CONFIG_PPP is not set
 # CONFIG_SLIP is not set
-# CONFIG_RCPCI is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
 
@@ -692,7 +692,6 @@ CONFIG_SUNRPC=y
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -739,11 +738,13 @@ CONFIG_CRYPTO_AES=y
 # CONFIG_CRYPTO_ARC4 is not set
 CONFIG_CRYPTO_DEFLATE=y
 CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
 #
 # Library routines
 #
 CONFIG_CRC32=y
+CONFIG_LIBCRC32C=m
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=y
diff -puN arch/mips/configs/ev64120_defconfig~mips-update arch/mips/configs/ev64120_defconfig
--- 25/arch/mips/configs/ev64120_defconfig~mips-update	2004-06-21 23:10:45.242341696 -0700
+++ 25-akpm/arch/mips/configs/ev64120_defconfig	2004-06-21 23:10:45.554294272 -0700
@@ -111,6 +111,7 @@ CONFIG_CPU_R5000=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 # CONFIG_64BIT_PHYS_ADDR is not set
@@ -124,6 +125,7 @@ CONFIG_CPU_HAS_SYNC=y
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
 CONFIG_PCI_NAMES=y
@@ -191,7 +193,6 @@ CONFIG_TRAD_SIGNALS=y
 #
 # Fusion MPT device support
 #
-# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -339,7 +340,6 @@ CONFIG_PPP_ASYNC=y
 # CONFIG_PPP_BSDCOMP is not set
 # CONFIG_PPPOE is not set
 # CONFIG_SLIP is not set
-# CONFIG_RCPCI is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
 
@@ -559,7 +559,6 @@ CONFIG_SUNRPC=y
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -594,3 +593,4 @@ CONFIG_CMDLINE="console=ttyS0,115200 roo
 # Library routines
 #
 # CONFIG_CRC32 is not set
+CONFIG_LIBCRC32C=m
diff -puN arch/mips/configs/ev96100_defconfig~mips-update arch/mips/configs/ev96100_defconfig
--- 25/arch/mips/configs/ev96100_defconfig~mips-update	2004-06-21 23:10:45.244341392 -0700
+++ 25-akpm/arch/mips/configs/ev96100_defconfig	2004-06-21 23:10:45.555294120 -0700
@@ -110,6 +110,7 @@ CONFIG_CPU_RM7000=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_BOARD_SCACHE=y
@@ -126,6 +127,7 @@ CONFIG_CPU_HAS_SYNC=y
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_PCI=y
 # CONFIG_PCI is not set
 CONFIG_MMU=y
 
@@ -514,7 +516,6 @@ CONFIG_SUNRPC=y
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -549,3 +550,4 @@ CONFIG_CMDLINE=""
 # Library routines
 #
 # CONFIG_CRC32 is not set
+CONFIG_LIBCRC32C=m
diff -puN arch/mips/configs/ip22_defconfig~mips-update arch/mips/configs/ip22_defconfig
--- 25/arch/mips/configs/ip22_defconfig~mips-update	2004-06-21 23:10:45.246341088 -0700
+++ 25-akpm/arch/mips/configs/ip22_defconfig	2004-06-21 23:10:45.557293816 -0700
@@ -114,6 +114,7 @@ CONFIG_CPU_R5000=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_BOARD_SCACHE=y
@@ -196,7 +197,6 @@ CONFIG_BLK_DEV_SR=y
 # Some SCSI devices (e.g. CD jukebox) support multiple LUNs
 #
 # CONFIG_SCSI_MULTI_LUN is not set
-# CONFIG_SCSI_REPORT_LUNS is not set
 CONFIG_SCSI_CONSTANTS=y
 # CONFIG_SCSI_LOGGING is not set
 
@@ -750,7 +750,6 @@ CONFIG_RPCSEC_GSS_KRB5=m
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -850,11 +849,13 @@ CONFIG_CRYPTO_CAST6=m
 CONFIG_CRYPTO_ARC4=m
 CONFIG_CRYPTO_DEFLATE=y
 CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
 #
 # Library routines
 #
 # CONFIG_CRC32 is not set
+CONFIG_LIBCRC32C=m
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=y
diff -puN arch/mips/configs/ip27_defconfig~mips-update arch/mips/configs/ip27_defconfig
--- 25/arch/mips/configs/ip27_defconfig~mips-update	2004-06-21 23:10:45.248340784 -0700
+++ 25-akpm/arch/mips/configs/ip27_defconfig	2004-06-21 23:10:45.559293512 -0700
@@ -113,6 +113,7 @@ CONFIG_CPU_R10000=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
@@ -128,6 +129,7 @@ CONFIG_NR_CPUS=64
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
 CONFIG_PCI_NAMES=y
@@ -203,7 +205,6 @@ CONFIG_CHR_DEV_ST=y
 # Some SCSI devices (e.g. CD jukebox) support multiple LUNs
 #
 # CONFIG_SCSI_MULTI_LUN is not set
-# CONFIG_SCSI_REPORT_LUNS is not set
 CONFIG_SCSI_CONSTANTS=y
 CONFIG_SCSI_LOGGING=y
 
@@ -226,7 +227,6 @@ CONFIG_SCSI_SPI_ATTRS=y
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_SATA is not set
 # CONFIG_SCSI_BUSLOGIC is not set
-# CONFIG_SCSI_CPQFCTS is not set
 # CONFIG_SCSI_DMX3191D is not set
 # CONFIG_SCSI_EATA is not set
 # CONFIG_SCSI_EATA_PIO is not set
@@ -235,6 +235,7 @@ CONFIG_SCSI_SPI_ATTRS=y
 # CONFIG_SCSI_IPS is not set
 # CONFIG_SCSI_INIA100 is not set
 # CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
 CONFIG_SCSI_QLOGIC_ISP=y
 # CONFIG_SCSI_QLOGIC_FC is not set
 # CONFIG_SCSI_QLOGIC_1280 is not set
@@ -267,6 +268,7 @@ CONFIG_SCSI_QLA2XXX=y
 #
 # I2O device support
 #
+# CONFIG_I2O is not set
 
 #
 # Networking support
@@ -638,7 +640,6 @@ CONFIG_RPCSEC_GSS_KRB5=y
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -700,11 +701,13 @@ CONFIG_CRYPTO_CAST6=y
 CONFIG_CRYPTO_ARC4=y
 CONFIG_CRYPTO_DEFLATE=y
 CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
 #
 # Library routines
 #
 CONFIG_CRC32=y
+CONFIG_LIBCRC32C=m
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=y
diff -puN arch/mips/configs/ip32_defconfig~mips-update arch/mips/configs/ip32_defconfig
--- 25/arch/mips/configs/ip32_defconfig~mips-update	2004-06-21 23:10:45.250340480 -0700
+++ 25-akpm/arch/mips/configs/ip32_defconfig	2004-06-21 23:10:45.560293360 -0700
@@ -102,6 +102,7 @@ CONFIG_CPU_R5000=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_BOARD_SCACHE=y
@@ -116,6 +117,7 @@ CONFIG_CPU_HAS_SYNC=y
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
 CONFIG_PCI_NAMES=y
@@ -193,7 +195,6 @@ CONFIG_CHR_DEV_SG=y
 # Some SCSI devices (e.g. CD jukebox) support multiple LUNs
 #
 CONFIG_SCSI_MULTI_LUN=y
-# CONFIG_SCSI_REPORT_LUNS is not set
 CONFIG_SCSI_CONSTANTS=y
 CONFIG_SCSI_LOGGING=y
 
@@ -222,7 +223,6 @@ CONFIG_AIC7XXX_REG_PRETTY_PRINT=y
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_SATA is not set
 # CONFIG_SCSI_BUSLOGIC is not set
-# CONFIG_SCSI_CPQFCTS is not set
 # CONFIG_SCSI_DMX3191D is not set
 # CONFIG_SCSI_EATA is not set
 # CONFIG_SCSI_EATA_PIO is not set
@@ -231,6 +231,7 @@ CONFIG_AIC7XXX_REG_PRETTY_PRINT=y
 # CONFIG_SCSI_IPS is not set
 # CONFIG_SCSI_INIA100 is not set
 # CONFIG_SCSI_SYM53C8XX_2 is not set
+# CONFIG_SCSI_IPR is not set
 # CONFIG_SCSI_QLOGIC_ISP is not set
 # CONFIG_SCSI_QLOGIC_FC is not set
 # CONFIG_SCSI_QLOGIC_1280 is not set
@@ -263,6 +264,7 @@ CONFIG_SCSI_QLA2XXX=y
 #
 # I2O device support
 #
+# CONFIG_I2O is not set
 
 #
 # Networking support
@@ -617,7 +619,6 @@ CONFIG_SUNRPC=y
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -663,3 +664,4 @@ CONFIG_CMDLINE=""
 # Library routines
 #
 # CONFIG_CRC32 is not set
+# CONFIG_LIBCRC32C is not set
diff -puN arch/mips/configs/it8172_defconfig~mips-update arch/mips/configs/it8172_defconfig
--- 25/arch/mips/configs/it8172_defconfig~mips-update	2004-06-21 23:10:45.252340176 -0700
+++ 25-akpm/arch/mips/configs/it8172_defconfig	2004-06-21 23:10:45.562293056 -0700
@@ -110,6 +110,7 @@ CONFIG_CPU_NEVADA=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 # CONFIG_CPU_ADVANCED is not set
@@ -122,6 +123,7 @@ CONFIG_CPU_HAS_SYNC=y
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_PCI=y
 # CONFIG_PCI is not set
 CONFIG_MMU=y
 
@@ -231,7 +233,6 @@ CONFIG_BLK_DEV_IDE=y
 #
 CONFIG_BLK_DEV_IDEDISK=y
 # CONFIG_IDEDISK_MULTI_MODE is not set
-# CONFIG_IDEDISK_STROKE is not set
 # CONFIG_BLK_DEV_IDECD is not set
 # CONFIG_BLK_DEV_IDETAPE is not set
 # CONFIG_BLK_DEV_IDEFLOPPY is not set
@@ -242,6 +243,7 @@ CONFIG_IDE_TASKFILE_IO=y
 # IDE chipset support/bugfixes
 #
 CONFIG_IDE_GENERIC=y
+# CONFIG_IDE_ARM is not set
 # CONFIG_BLK_DEV_IDEDMA is not set
 # CONFIG_IDEDMA_AUTO is not set
 # CONFIG_BLK_DEV_HD is not set
@@ -615,7 +617,6 @@ CONFIG_SUNRPC=y
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -650,3 +651,4 @@ CONFIG_CMDLINE=""
 # Library routines
 #
 # CONFIG_CRC32 is not set
+CONFIG_LIBCRC32C=m
diff -puN arch/mips/configs/ivr_defconfig~mips-update arch/mips/configs/ivr_defconfig
--- 25/arch/mips/configs/ivr_defconfig~mips-update	2004-06-21 23:10:45.254339872 -0700
+++ 25-akpm/arch/mips/configs/ivr_defconfig	2004-06-21 23:10:45.564292752 -0700
@@ -108,6 +108,7 @@ CONFIG_CPU_NEVADA=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 # CONFIG_CPU_ADVANCED is not set
@@ -120,6 +121,7 @@ CONFIG_CPU_HAS_SYNC=y
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
 CONFIG_PCI_NAMES=y
@@ -179,7 +181,6 @@ CONFIG_BLK_DEV_IDE=y
 #
 CONFIG_BLK_DEV_IDEDISK=y
 # CONFIG_IDEDISK_MULTI_MODE is not set
-# CONFIG_IDEDISK_STROKE is not set
 # CONFIG_BLK_DEV_IDECD is not set
 # CONFIG_BLK_DEV_IDETAPE is not set
 # CONFIG_BLK_DEV_IDEFLOPPY is not set
@@ -191,6 +192,7 @@ CONFIG_IDE_TASKFILE_IO=y
 #
 CONFIG_IDE_GENERIC=y
 # CONFIG_BLK_DEV_IDEPCI is not set
+# CONFIG_IDE_ARM is not set
 # CONFIG_BLK_DEV_IDEDMA is not set
 # CONFIG_IDEDMA_AUTO is not set
 # CONFIG_BLK_DEV_HD is not set
@@ -208,7 +210,6 @@ CONFIG_IDE_GENERIC=y
 #
 # Fusion MPT device support
 #
-# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -350,7 +351,6 @@ CONFIG_NET_ETHERNET=y
 # CONFIG_HIPPI is not set
 # CONFIG_PPP is not set
 # CONFIG_SLIP is not set
-# CONFIG_RCPCI is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
 
@@ -571,7 +571,6 @@ CONFIG_SUNRPC=y
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -606,3 +605,4 @@ CONFIG_CMDLINE=""
 # Library routines
 #
 # CONFIG_CRC32 is not set
+CONFIG_LIBCRC32C=m
diff -puN arch/mips/configs/jaguar-atx_defconfig~mips-update arch/mips/configs/jaguar-atx_defconfig
--- 25/arch/mips/configs/jaguar-atx_defconfig~mips-update	2004-06-21 23:10:45.256339568 -0700
+++ 25-akpm/arch/mips/configs/jaguar-atx_defconfig	2004-06-21 23:10:45.565292600 -0700
@@ -100,6 +100,7 @@ CONFIG_MIPS_L1_CACHE_SHIFT=5
 CONFIG_CPU_RM9000=y
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_BOARD_SCACHE=y
@@ -118,6 +119,7 @@ CONFIG_HIGHMEM=y
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
 CONFIG_PCI_NAMES=y
@@ -184,7 +186,6 @@ CONFIG_TRAD_SIGNALS=y
 #
 # Fusion MPT device support
 #
-# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -538,3 +539,4 @@ CONFIG_CMDLINE=""
 # Library routines
 #
 # CONFIG_CRC32 is not set
+# CONFIG_LIBCRC32C is not set
diff -puN arch/mips/configs/jmr3927_defconfig~mips-update arch/mips/configs/jmr3927_defconfig
--- 25/arch/mips/configs/jmr3927_defconfig~mips-update	2004-06-21 23:10:45.257339416 -0700
+++ 25-akpm/arch/mips/configs/jmr3927_defconfig	2004-06-21 23:10:45.567292296 -0700
@@ -104,6 +104,7 @@ CONFIG_CPU_TX39XX=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 # CONFIG_CPU_ADVANCED is not set
@@ -115,6 +116,7 @@ CONFIG_RTC_DS1742=y
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
 CONFIG_PCI_NAMES=y
@@ -182,7 +184,6 @@ CONFIG_TRAD_SIGNALS=y
 #
 # Fusion MPT device support
 #
-# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -324,7 +325,6 @@ CONFIG_NET_ETHERNET=y
 # CONFIG_HIPPI is not set
 # CONFIG_PPP is not set
 # CONFIG_SLIP is not set
-# CONFIG_RCPCI is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
 
@@ -462,6 +462,7 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # CONFIG_FB_PM2 is not set
 # CONFIG_FB_CYBER2000 is not set
+# CONFIG_FB_ASILIANT is not set
 # CONFIG_FB_IMSTT is not set
 # CONFIG_FB_RIVA is not set
 # CONFIG_FB_MATROX is not set
@@ -578,7 +579,6 @@ CONFIG_SUNRPC=y
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -613,3 +613,4 @@ CONFIG_CMDLINE=""
 # Library routines
 #
 # CONFIG_CRC32 is not set
+# CONFIG_LIBCRC32C is not set
diff -puN arch/mips/configs/lasat200_defconfig~mips-update arch/mips/configs/lasat200_defconfig
--- 25/arch/mips/configs/lasat200_defconfig~mips-update	2004-06-21 23:10:45.259339112 -0700
+++ 25-akpm/arch/mips/configs/lasat200_defconfig	2004-06-21 23:10:45.568292144 -0700
@@ -112,6 +112,7 @@ CONFIG_CPU_R5000=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_BOARD_SCACHE=y
@@ -127,6 +128,7 @@ CONFIG_CPU_HAS_SYNC=y
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
 # CONFIG_PCI_NAMES is not set
@@ -242,7 +244,6 @@ CONFIG_BLK_DEV_IDE=y
 #
 CONFIG_BLK_DEV_IDEDISK=y
 CONFIG_IDEDISK_MULTI_MODE=y
-# CONFIG_IDEDISK_STROKE is not set
 # CONFIG_BLK_DEV_IDECD is not set
 # CONFIG_BLK_DEV_IDETAPE is not set
 # CONFIG_BLK_DEV_IDEFLOPPY is not set
@@ -283,6 +284,7 @@ CONFIG_BLK_DEV_CMD64X=y
 # CONFIG_BLK_DEV_SLC90E66 is not set
 # CONFIG_BLK_DEV_TRM290 is not set
 # CONFIG_BLK_DEV_VIA82CXXX is not set
+# CONFIG_IDE_ARM is not set
 CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_IDEDMA_IVB is not set
 CONFIG_IDEDMA_AUTO=y
@@ -301,7 +303,6 @@ CONFIG_IDEDMA_AUTO=y
 #
 # Fusion MPT device support
 #
-# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -438,7 +439,6 @@ CONFIG_NET_ETHERNET=y
 # CONFIG_HIPPI is not set
 # CONFIG_PPP is not set
 # CONFIG_SLIP is not set
-# CONFIG_RCPCI is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
 
@@ -665,7 +665,6 @@ CONFIG_SUNRPC=y
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -700,3 +699,4 @@ CONFIG_CMDLINE=""
 # Library routines
 #
 CONFIG_CRC32=y
+CONFIG_LIBCRC32C=m
diff -puN arch/mips/configs/malta_defconfig~mips-update arch/mips/configs/malta_defconfig
--- 25/arch/mips/configs/malta_defconfig~mips-update	2004-06-21 23:10:45.261338808 -0700
+++ 25-akpm/arch/mips/configs/malta_defconfig	2004-06-21 23:10:45.570291840 -0700
@@ -115,6 +115,7 @@ CONFIG_CPU_MIPS32=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
@@ -129,6 +130,7 @@ CONFIG_CPU_HAS_SYNC=y
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
 CONFIG_PCI_NAMES=y
@@ -197,7 +199,6 @@ CONFIG_BLK_DEV_RAM_SIZE=4096
 #
 # Fusion MPT device support
 #
-# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -357,7 +358,6 @@ CONFIG_PCNET32=y
 # CONFIG_HIPPI is not set
 # CONFIG_PPP is not set
 # CONFIG_SLIP is not set
-# CONFIG_RCPCI is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
 
@@ -580,7 +580,6 @@ CONFIG_SUNRPC=y
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -615,3 +614,4 @@ CONFIG_CMDLINE=""
 # Library routines
 #
 CONFIG_CRC32=y
+CONFIG_LIBCRC32C=m
diff -puN arch/mips/configs/mirage_defconfig~mips-update arch/mips/configs/mirage_defconfig
--- 25/arch/mips/configs/mirage_defconfig~mips-update	2004-06-21 23:10:45.263338504 -0700
+++ 25-akpm/arch/mips/configs/mirage_defconfig	2004-06-21 23:10:45.571291688 -0700
@@ -105,6 +105,7 @@ CONFIG_CPU_MIPS32=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
@@ -496,6 +497,9 @@ CONFIG_FS_MBCACHE=y
 CONFIG_REISERFS_FS=m
 # CONFIG_REISERFS_CHECK is not set
 # CONFIG_REISERFS_PROC_INFO is not set
+CONFIG_REISERFS_FS_XATTR=y
+CONFIG_REISERFS_FS_POSIX_ACL=y
+CONFIG_REISERFS_FS_SECURITY=y
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
 # CONFIG_XFS_FS is not set
@@ -567,7 +571,6 @@ CONFIG_SMB_FS=m
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -652,11 +655,13 @@ CONFIG_CRYPTO_AES=y
 # CONFIG_CRYPTO_ARC4 is not set
 CONFIG_CRYPTO_DEFLATE=y
 CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
 #
 # Library routines
 #
 CONFIG_CRC32=y
+CONFIG_LIBCRC32C=m
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=y
diff -puN arch/mips/configs/mpc30x_defconfig~mips-update arch/mips/configs/mpc30x_defconfig
--- 25/arch/mips/configs/mpc30x_defconfig~mips-update	2004-06-21 23:10:45.265338200 -0700
+++ 25-akpm/arch/mips/configs/mpc30x_defconfig	2004-06-21 23:10:45.573291384 -0700
@@ -59,6 +59,7 @@ CONFIG_MACH_VR41XX=y
 # CONFIG_TANBAC_TB0229 is not set
 CONFIG_VICTOR_MPC30X=y
 # CONFIG_ZAO_CAPCELLA is not set
+CONFIG_PCI_VR41XX=y
 CONFIG_VRC4173=y
 # CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_MIPS_COBALT is not set
@@ -91,7 +92,6 @@ CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
-CONFIG_DUMMY_KEYB=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 # CONFIG_FB is not set
 
@@ -116,6 +116,7 @@ CONFIG_CPU_VR41XX=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 # CONFIG_CPU_ADVANCED is not set
@@ -126,6 +127,7 @@ CONFIG_CPU_HAS_SYNC=y
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
 CONFIG_PCI_NAMES=y
@@ -192,7 +194,6 @@ CONFIG_TRAD_SIGNALS=y
 #
 # Fusion MPT device support
 #
-# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -335,7 +336,6 @@ CONFIG_NET_ETHERNET=y
 # CONFIG_HIPPI is not set
 # CONFIG_PPP is not set
 # CONFIG_SLIP is not set
-# CONFIG_RCPCI is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
 
@@ -555,7 +555,6 @@ CONFIG_SUNRPC=y
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -602,11 +601,13 @@ CONFIG_CRYPTO_AES=y
 # CONFIG_CRYPTO_ARC4 is not set
 CONFIG_CRYPTO_DEFLATE=y
 CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
 #
 # Library routines
 #
 # CONFIG_CRC32 is not set
+CONFIG_LIBCRC32C=m
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=y
diff -puN arch/mips/configs/mtx1_defconfig~mips-update arch/mips/configs/mtx1_defconfig
--- 25/arch/mips/configs/mtx1_defconfig~mips-update	2004-06-21 23:10:45.267337896 -0700
+++ 25-akpm/arch/mips/configs/mtx1_defconfig	2004-06-21 23:10:45.575291080 -0700
@@ -105,6 +105,7 @@ CONFIG_CPU_MIPS32=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
@@ -496,6 +497,9 @@ CONFIG_FS_MBCACHE=y
 CONFIG_REISERFS_FS=m
 # CONFIG_REISERFS_CHECK is not set
 # CONFIG_REISERFS_PROC_INFO is not set
+CONFIG_REISERFS_FS_XATTR=y
+CONFIG_REISERFS_FS_POSIX_ACL=y
+CONFIG_REISERFS_FS_SECURITY=y
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
 # CONFIG_XFS_FS is not set
@@ -567,7 +571,6 @@ CONFIG_SMB_FS=m
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -652,11 +655,13 @@ CONFIG_CRYPTO_AES=y
 # CONFIG_CRYPTO_ARC4 is not set
 CONFIG_CRYPTO_DEFLATE=y
 CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
 #
 # Library routines
 #
 CONFIG_CRC32=y
+CONFIG_LIBCRC32C=m
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=y
diff -puN arch/mips/configs/ocelot_c_defconfig~mips-update arch/mips/configs/ocelot_c_defconfig
--- 25/arch/mips/configs/ocelot_c_defconfig~mips-update	2004-06-21 23:10:45.268337744 -0700
+++ 25-akpm/arch/mips/configs/ocelot_c_defconfig	2004-06-21 23:10:45.576290928 -0700
@@ -100,6 +100,7 @@ CONFIG_CPU_RM7000=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_BOARD_SCACHE=y
@@ -114,7 +115,10 @@ CONFIG_CPU_HAS_SYNC=y
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
-# CONFIG_PCI is not set
+CONFIG_HW_HAS_PCI=y
+CONFIG_PCI=y
+CONFIG_PCI_LEGACY_PROC=y
+CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
@@ -154,8 +158,13 @@ CONFIG_BINFMT_ELF32=y
 # Block devices
 #
 # CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
 # CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_CARMEL is not set
 # CONFIG_BLK_DEV_RAM is not set
 
 #
@@ -185,6 +194,7 @@ CONFIG_BINFMT_ELF32=y
 #
 # I2O device support
 #
+# CONFIG_I2O is not set
 
 #
 # Networking support
@@ -258,26 +268,50 @@ CONFIG_NETDEVICES=y
 # CONFIG_ETHERTAP is not set
 
 #
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
 # CONFIG_MII is not set
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_PCI is not set
 
 #
 # Ethernet (1000 Mbit)
 #
-CONFIG_MV64340_ETH=y
-CONFIG_MV64340_ETH_0=y
-# CONFIG_MV64340_ETH_1 is not set
-# CONFIG_MV64340_ETH_2 is not set
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+# CONFIG_MV64340_ETH is not set
 
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
 
 #
 # Token Ring devices
 #
+# CONFIG_TR is not set
 
 #
 # Wireless LAN (non-hamradio)
@@ -288,6 +322,8 @@ CONFIG_MV64340_ETH_0=y
 # Wan interfaces
 #
 # CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
 # CONFIG_PPP is not set
 # CONFIG_SLIP is not set
 # CONFIG_SHAPER is not set
@@ -329,6 +365,7 @@ CONFIG_SERIO=y
 # CONFIG_SERIO_I8042 is not set
 CONFIG_SERIO_SERPORT=y
 # CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
 
 #
 # Input Device Drivers
@@ -426,6 +463,7 @@ CONFIG_DUMMY_CONSOLE=y
 #
 # USB support
 #
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -509,7 +547,6 @@ CONFIG_SUNRPC=y
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -544,3 +581,4 @@ CONFIG_CMDLINE=""
 # Library routines
 #
 # CONFIG_CRC32 is not set
+# CONFIG_LIBCRC32C is not set
diff -puN arch/mips/configs/ocelot_defconfig~mips-update arch/mips/configs/ocelot_defconfig
--- 25/arch/mips/configs/ocelot_defconfig~mips-update	2004-06-21 23:10:45.270337440 -0700
+++ 25-akpm/arch/mips/configs/ocelot_defconfig	2004-06-21 23:10:45.578290624 -0700
@@ -108,6 +108,7 @@ CONFIG_CPU_RM7000=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_BOARD_SCACHE=y
@@ -124,6 +125,7 @@ CONFIG_CPU_HAS_SYNC=y
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_PCI=y
 # CONFIG_PCI is not set
 CONFIG_MMU=y
 
@@ -513,7 +515,6 @@ CONFIG_SUNRPC=y
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -548,3 +549,4 @@ CONFIG_CMDLINE=""
 # Library routines
 #
 # CONFIG_CRC32 is not set
+# CONFIG_LIBCRC32C is not set
diff -puN /dev/null arch/mips/configs/ocelot_g_defconfig
--- /dev/null	2003-09-15 06:40:47.000000000 -0700
+++ 25-akpm/arch/mips/configs/ocelot_g_defconfig	2004-06-21 23:10:45.581290168 -0700
@@ -0,0 +1,587 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_MIPS=y
+CONFIG_MIPS64=y
+CONFIG_64BIT=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_STANDALONE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_HOTPLUG is not set
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+CONFIG_KALLSYMS=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_AS=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+
+#
+# Loadable module support
+#
+# CONFIG_MODULES is not set
+
+#
+# Machine selection
+#
+# CONFIG_MACH_JAZZ is not set
+# CONFIG_MACH_VR41XX is not set
+# CONFIG_MIPS_COBALT is not set
+# CONFIG_MACH_DECSTATION is not set
+# CONFIG_MIPS_EV64120 is not set
+# CONFIG_MIPS_EV96100 is not set
+# CONFIG_MIPS_IVR is not set
+# CONFIG_LASAT is not set
+# CONFIG_MIPS_ITE8172 is not set
+# CONFIG_MIPS_ATLAS is not set
+# CONFIG_MIPS_MALTA is not set
+# CONFIG_MIPS_SEAD is not set
+# CONFIG_MOMENCO_OCELOT is not set
+CONFIG_MOMENCO_OCELOT_G=y
+# CONFIG_MOMENCO_OCELOT_C is not set
+# CONFIG_MOMENCO_JAGUAR_ATX is not set
+# CONFIG_PMC_YOSEMITE is not set
+# CONFIG_DDB5074 is not set
+# CONFIG_DDB5476 is not set
+# CONFIG_DDB5477 is not set
+# CONFIG_NEC_OSPREY is not set
+# CONFIG_SGI_IP22 is not set
+# CONFIG_SGI_IP27 is not set
+# CONFIG_SGI_IP32 is not set
+# CONFIG_SIBYTE_SB1xxx_SOC is not set
+# CONFIG_SNI_RM200_PCI is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_HAVE_DEC_LOCK=y
+CONFIG_DMA_NONCOHERENT=y
+# CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_IRQ_CPU=y
+CONFIG_IRQ_CPU_RM7K=y
+CONFIG_SWAP_IO_SPACE=y
+# CONFIG_SYSCLK_75 is not set
+# CONFIG_SYSCLK_83 is not set
+CONFIG_SYSCLK_100=y
+CONFIG_MIPS_L1_CACHE_SHIFT=5
+# CONFIG_FB is not set
+
+#
+# CPU selection
+#
+# CONFIG_CPU_MIPS32 is not set
+# CONFIG_CPU_MIPS64 is not set
+# CONFIG_CPU_R3000 is not set
+# CONFIG_CPU_TX39XX is not set
+# CONFIG_CPU_VR41XX is not set
+# CONFIG_CPU_R4300 is not set
+# CONFIG_CPU_R4X00 is not set
+# CONFIG_CPU_TX49XX is not set
+# CONFIG_CPU_R5000 is not set
+# CONFIG_CPU_R5432 is not set
+# CONFIG_CPU_R6000 is not set
+# CONFIG_CPU_NEVADA is not set
+# CONFIG_CPU_R8000 is not set
+# CONFIG_CPU_R10000 is not set
+CONFIG_CPU_RM7000=y
+# CONFIG_CPU_RM9000 is not set
+# CONFIG_CPU_SB1 is not set
+CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
+# CONFIG_PAGE_SIZE_16KB is not set
+# CONFIG_PAGE_SIZE_64KB is not set
+CONFIG_BOARD_SCACHE=y
+CONFIG_RM7000_CPU_SCACHE=y
+CONFIG_CPU_HAS_PREFETCH=y
+CONFIG_CPU_HAS_LLSC=y
+CONFIG_CPU_HAS_LLDSCD=y
+CONFIG_CPU_HAS_SYNC=y
+# CONFIG_PREEMPT is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+
+#
+# Bus options (PCI, PCMCIA, EISA, ISA, TC)
+#
+CONFIG_HW_HAS_PCI=y
+CONFIG_PCI=y
+CONFIG_PCI_LEGACY_PROC=y
+CONFIG_PCI_NAMES=y
+CONFIG_MMU=y
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+CONFIG_MIPS32_COMPAT=y
+CONFIG_COMPAT=y
+CONFIG_MIPS32_O32=y
+CONFIG_MIPS32_N32=y
+CONFIG_BINFMT_ELF32=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_UMEM is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_CARMEL is not set
+# CONFIG_BLK_DEV_RAM is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+# CONFIG_I2O is not set
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+CONFIG_NETLINK_DEV=y
+CONFIG_UNIX=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_ETHERTAP is not set
+
+#
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
+# Ethernet (10 or 100Mbit)
+#
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_GALILEO_64240_ETH=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_PCI is not set
+
+#
+# Ethernet (1000 Mbit)
+#
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_YELLOWFIN is not set
+# CONFIG_R8169 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+
+#
+# Ethernet (10000 Mbit)
+#
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
+
+#
+# Token Ring devices
+#
+# CONFIG_TR is not set
+
+#
+# Wireless LAN (non-hamradio)
+#
+# CONFIG_NET_RADIO is not set
+
+#
+# Wan interfaces
+#
+# CONFIG_WAN is not set
+# CONFIG_FDDI is not set
+# CONFIG_HIPPI is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_SHAPER is not set
+# CONFIG_NETCONSOLE is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO_PCIPS2 is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_QIC02_TAPE is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+# CONFIG_MDA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+# CONFIG_USB is not set
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_FAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+CONFIG_DEVPTS_FS_XATTR=y
+CONFIG_DEVPTS_FS_SECURITY=y
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+# CONFIG_NFS_V3 is not set
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+CONFIG_NFSD=y
+# CONFIG_NFSD_V3 is not set
+# CONFIG_NFSD_TCP is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_EXPORTFS=y
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+# CONFIG_NLS is not set
+
+#
+# Kernel hacking
+#
+CONFIG_CROSSCOMPILE=y
+CONFIG_CMDLINE=""
+# CONFIG_DEBUG_KERNEL is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+# CONFIG_CRC32 is not set
+# CONFIG_LIBCRC32C is not set
diff -puN arch/mips/configs/osprey_defconfig~mips-update arch/mips/configs/osprey_defconfig
--- 25/arch/mips/configs/osprey_defconfig~mips-update	2004-06-21 23:10:45.273336984 -0700
+++ 25-akpm/arch/mips/configs/osprey_defconfig	2004-06-21 23:10:45.582290016 -0700
@@ -83,7 +83,6 @@ CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
-CONFIG_DUMMY_KEYB=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 # CONFIG_FB is not set
 CONFIG_VR4181=y
@@ -109,6 +108,7 @@ CONFIG_CPU_VR41XX=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 # CONFIG_CPU_ADVANCED is not set
@@ -507,7 +507,6 @@ CONFIG_SUNRPC=y
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -542,3 +541,4 @@ CONFIG_CMDLINE="ip=bootp ether=46,0x03fe
 # Library routines
 #
 # CONFIG_CRC32 is not set
+CONFIG_LIBCRC32C=m
diff -puN arch/mips/configs/pb1000_defconfig~mips-update arch/mips/configs/pb1000_defconfig
--- 25/arch/mips/configs/pb1000_defconfig~mips-update	2004-06-21 23:10:45.275336680 -0700
+++ 25-akpm/arch/mips/configs/pb1000_defconfig	2004-06-21 23:10:45.584289712 -0700
@@ -105,6 +105,7 @@ CONFIG_CPU_MIPS32=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
@@ -496,6 +497,9 @@ CONFIG_FS_MBCACHE=y
 CONFIG_REISERFS_FS=m
 # CONFIG_REISERFS_CHECK is not set
 # CONFIG_REISERFS_PROC_INFO is not set
+CONFIG_REISERFS_FS_XATTR=y
+CONFIG_REISERFS_FS_POSIX_ACL=y
+CONFIG_REISERFS_FS_SECURITY=y
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
 # CONFIG_XFS_FS is not set
@@ -567,7 +571,6 @@ CONFIG_SMB_FS=m
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -652,11 +655,13 @@ CONFIG_CRYPTO_AES=y
 # CONFIG_CRYPTO_ARC4 is not set
 CONFIG_CRYPTO_DEFLATE=y
 CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
 #
 # Library routines
 #
 CONFIG_CRC32=y
+CONFIG_LIBCRC32C=m
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=y
diff -puN arch/mips/configs/pb1100_defconfig~mips-update arch/mips/configs/pb1100_defconfig
--- 25/arch/mips/configs/pb1100_defconfig~mips-update	2004-06-21 23:10:45.277336376 -0700
+++ 25-akpm/arch/mips/configs/pb1100_defconfig	2004-06-21 23:10:45.585289560 -0700
@@ -105,6 +105,7 @@ CONFIG_CPU_MIPS32=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
@@ -496,6 +497,9 @@ CONFIG_FS_MBCACHE=y
 CONFIG_REISERFS_FS=m
 # CONFIG_REISERFS_CHECK is not set
 # CONFIG_REISERFS_PROC_INFO is not set
+CONFIG_REISERFS_FS_XATTR=y
+CONFIG_REISERFS_FS_POSIX_ACL=y
+CONFIG_REISERFS_FS_SECURITY=y
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
 # CONFIG_XFS_FS is not set
@@ -567,7 +571,6 @@ CONFIG_SMB_FS=m
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -652,11 +655,13 @@ CONFIG_CRYPTO_AES=y
 # CONFIG_CRYPTO_ARC4 is not set
 CONFIG_CRYPTO_DEFLATE=y
 CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
 #
 # Library routines
 #
 CONFIG_CRC32=y
+CONFIG_LIBCRC32C=m
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=y
diff -puN arch/mips/configs/pb1500_defconfig~mips-update arch/mips/configs/pb1500_defconfig
--- 25/arch/mips/configs/pb1500_defconfig~mips-update	2004-06-21 23:10:45.279336072 -0700
+++ 25-akpm/arch/mips/configs/pb1500_defconfig	2004-06-21 23:10:45.587289256 -0700
@@ -123,6 +123,7 @@ CONFIG_CPU_MIPS32=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
@@ -137,6 +138,7 @@ CONFIG_CPU_HAS_SYNC=y
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
 CONFIG_PCI_NAMES=y
@@ -213,7 +215,6 @@ CONFIG_BLK_DEV_IDE=y
 #
 CONFIG_BLK_DEV_IDEDISK=y
 # CONFIG_IDEDISK_MULTI_MODE is not set
-# CONFIG_IDEDISK_STROKE is not set
 # CONFIG_BLK_DEV_IDECS is not set
 # CONFIG_BLK_DEV_IDECD is not set
 # CONFIG_BLK_DEV_IDETAPE is not set
@@ -254,6 +255,7 @@ CONFIG_BLK_DEV_HPT366=y
 # CONFIG_BLK_DEV_SLC90E66 is not set
 # CONFIG_BLK_DEV_TRM290 is not set
 # CONFIG_BLK_DEV_VIA82CXXX is not set
+# CONFIG_IDE_ARM is not set
 CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_IDEDMA_IVB is not set
 # CONFIG_IDEDMA_AUTO is not set
@@ -272,7 +274,6 @@ CONFIG_BLK_DEV_IDEDMA=y
 #
 # Fusion MPT device support
 #
-# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -452,7 +453,6 @@ CONFIG_PPP_DEFLATE=m
 # CONFIG_PPP_BSDCOMP is not set
 CONFIG_PPPOE=m
 # CONFIG_SLIP is not set
-# CONFIG_RCPCI is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
 
@@ -611,6 +611,9 @@ CONFIG_FS_MBCACHE=y
 CONFIG_REISERFS_FS=m
 # CONFIG_REISERFS_CHECK is not set
 # CONFIG_REISERFS_PROC_INFO is not set
+CONFIG_REISERFS_FS_XATTR=y
+CONFIG_REISERFS_FS_POSIX_ACL=y
+CONFIG_REISERFS_FS_SECURITY=y
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
 # CONFIG_XFS_FS is not set
@@ -682,7 +685,6 @@ CONFIG_SMB_FS=m
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -767,11 +769,13 @@ CONFIG_CRYPTO_AES=y
 # CONFIG_CRYPTO_ARC4 is not set
 CONFIG_CRYPTO_DEFLATE=y
 CONFIG_CRYPTO_MICHAEL_MIC=y
+# CONFIG_CRYPTO_CRC32C is not set
 # CONFIG_CRYPTO_TEST is not set
 
 #
 # Library routines
 #
 CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=y
diff -puN arch/mips/configs/pb1550_defconfig~mips-update arch/mips/configs/pb1550_defconfig
--- 25/arch/mips/configs/pb1550_defconfig~mips-update	2004-06-21 23:10:45.281335768 -0700
+++ 25-akpm/arch/mips/configs/pb1550_defconfig	2004-06-21 23:10:45.589288952 -0700
@@ -122,6 +122,7 @@ CONFIG_CPU_MIPS32=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
@@ -136,6 +137,7 @@ CONFIG_CPU_HAS_SYNC=y
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
 CONFIG_PCI_NAMES=y
@@ -212,7 +214,6 @@ CONFIG_BLK_DEV_IDE=y
 #
 CONFIG_BLK_DEV_IDEDISK=y
 # CONFIG_IDEDISK_MULTI_MODE is not set
-# CONFIG_IDEDISK_STROKE is not set
 # CONFIG_BLK_DEV_IDECS is not set
 # CONFIG_BLK_DEV_IDECD is not set
 # CONFIG_BLK_DEV_IDETAPE is not set
@@ -253,6 +254,7 @@ CONFIG_BLK_DEV_HPT366=y
 # CONFIG_BLK_DEV_SLC90E66 is not set
 # CONFIG_BLK_DEV_TRM290 is not set
 # CONFIG_BLK_DEV_VIA82CXXX is not set
+# CONFIG_IDE_ARM is not set
 CONFIG_BLK_DEV_IDEDMA=y
 # CONFIG_IDEDMA_IVB is not set
 # CONFIG_IDEDMA_AUTO is not set
@@ -271,7 +273,6 @@ CONFIG_BLK_DEV_IDEDMA=y
 #
 # Fusion MPT device support
 #
-# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -451,7 +452,6 @@ CONFIG_PPP_DEFLATE=m
 # CONFIG_PPP_BSDCOMP is not set
 CONFIG_PPPOE=m
 # CONFIG_SLIP is not set
-# CONFIG_RCPCI is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
 
@@ -610,6 +610,9 @@ CONFIG_FS_MBCACHE=y
 CONFIG_REISERFS_FS=m
 # CONFIG_REISERFS_CHECK is not set
 # CONFIG_REISERFS_PROC_INFO is not set
+CONFIG_REISERFS_FS_XATTR=y
+CONFIG_REISERFS_FS_POSIX_ACL=y
+CONFIG_REISERFS_FS_SECURITY=y
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
 # CONFIG_XFS_FS is not set
@@ -681,7 +684,6 @@ CONFIG_SMB_FS=m
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -766,11 +768,13 @@ CONFIG_CRYPTO_AES=y
 # CONFIG_CRYPTO_ARC4 is not set
 CONFIG_CRYPTO_DEFLATE=y
 CONFIG_CRYPTO_MICHAEL_MIC=y
+CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
 #
 # Library routines
 #
 CONFIG_CRC32=y
+CONFIG_LIBCRC32C=m
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=y
diff -puN arch/mips/configs/rm200_defconfig~mips-update arch/mips/configs/rm200_defconfig
--- 25/arch/mips/configs/rm200_defconfig~mips-update	2004-06-21 23:10:45.283335464 -0700
+++ 25-akpm/arch/mips/configs/rm200_defconfig	2004-06-21 23:10:45.591288648 -0700
@@ -116,6 +116,7 @@ CONFIG_CPU_R4X00=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 # CONFIG_64BIT_PHYS_ADDR is not set
@@ -129,6 +130,7 @@ CONFIG_CPU_HAS_SYNC=y
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
 # CONFIG_PCI_NAMES is not set
@@ -246,7 +248,6 @@ CONFIG_BLK_DEV_SR_VENDOR=y
 # Some SCSI devices (e.g. CD jukebox) support multiple LUNs
 #
 # CONFIG_SCSI_MULTI_LUN is not set
-# CONFIG_SCSI_REPORT_LUNS is not set
 CONFIG_SCSI_CONSTANTS=y
 # CONFIG_SCSI_LOGGING is not set
 
@@ -268,12 +269,12 @@ CONFIG_SCSI_SPI_ATTRS=y
 # CONFIG_SCSI_AIC7XXX is not set
 # CONFIG_SCSI_AIC7XXX_OLD is not set
 # CONFIG_SCSI_AIC79XX is not set
+# CONFIG_SCSI_DPT_I2O is not set
 # CONFIG_SCSI_ADVANSYS is not set
 # CONFIG_SCSI_IN2000 is not set
 # CONFIG_SCSI_MEGARAID is not set
 # CONFIG_SCSI_SATA is not set
 # CONFIG_SCSI_BUSLOGIC is not set
-# CONFIG_SCSI_CPQFCTS is not set
 # CONFIG_SCSI_DMX3191D is not set
 # CONFIG_SCSI_DTC3280 is not set
 # CONFIG_SCSI_EATA is not set
@@ -294,6 +295,7 @@ CONFIG_SCSI_SYM53C8XX_DMA_ADDRESSING_MOD
 CONFIG_SCSI_SYM53C8XX_DEFAULT_TAGS=16
 CONFIG_SCSI_SYM53C8XX_MAX_TAGS=64
 # CONFIG_SCSI_SYM53C8XX_IOMAPPED is not set
+# CONFIG_SCSI_IPR is not set
 # CONFIG_SCSI_PAS16 is not set
 # CONFIG_SCSI_PSI240I is not set
 # CONFIG_SCSI_QLOGIC_FAS is not set
@@ -695,7 +697,6 @@ CONFIG_PLIP=m
 # CONFIG_PPP is not set
 # CONFIG_SLIP is not set
 # CONFIG_NET_FC is not set
-# CONFIG_RCPCI is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
 
@@ -908,6 +909,7 @@ CONFIG_USB_WACOM=m
 CONFIG_USB_KBTAB=m
 CONFIG_USB_POWERMATE=m
 # CONFIG_USB_MTOUCH is not set
+CONFIG_USB_EGALAX=m
 CONFIG_USB_XPAD=m
 # CONFIG_USB_ATI_REMOTE is not set
 
@@ -1016,6 +1018,7 @@ CONFIG_USB_LEGOTOWER=m
 CONFIG_USB_LCD=m
 CONFIG_USB_LED=m
 CONFIG_USB_CYTHERM=m
+CONFIG_USB_PHIDGETSERVO=m
 CONFIG_USB_TEST=m
 
 #
@@ -1051,10 +1054,14 @@ CONFIG_FS_MBCACHE=y
 CONFIG_REISERFS_FS=m
 # CONFIG_REISERFS_CHECK is not set
 # CONFIG_REISERFS_PROC_INFO is not set
+CONFIG_REISERFS_FS_XATTR=y
+CONFIG_REISERFS_FS_POSIX_ACL=y
+CONFIG_REISERFS_FS_SECURITY=y
 CONFIG_JFS_FS=m
 # CONFIG_JFS_POSIX_ACL is not set
 # CONFIG_JFS_DEBUG is not set
 # CONFIG_JFS_STATISTICS is not set
+CONFIG_FS_POSIX_ACL=y
 CONFIG_XFS_FS=m
 # CONFIG_XFS_RT is not set
 CONFIG_XFS_QUOTA=y
@@ -1140,6 +1147,7 @@ CONFIG_RPCSEC_GSS_KRB5=m
 CONFIG_SMB_FS=m
 # CONFIG_SMB_NLS_DEFAULT is not set
 CONFIG_CIFS=m
+# CONFIG_CIFS_STATS is not set
 CONFIG_NCP_FS=m
 CONFIG_NCPFS_PACKET_SIGNING=y
 CONFIG_NCPFS_IOCTL_LOCKING=y
@@ -1151,7 +1159,6 @@ CONFIG_NCPFS_NLS=y
 CONFIG_NCPFS_EXTRAS=y
 CONFIG_CODA_FS=m
 CONFIG_CODA_FS_OLD_API=y
-CONFIG_INTERMEZZO_FS=m
 CONFIG_AFS_FS=m
 CONFIG_RXRPC=m
 
@@ -1252,11 +1259,13 @@ CONFIG_CRYPTO_CAST6=m
 # CONFIG_CRYPTO_ARC4 is not set
 CONFIG_CRYPTO_DEFLATE=m
 CONFIG_CRYPTO_MICHAEL_MIC=m
+# CONFIG_CRYPTO_CRC32C is not set
 CONFIG_CRYPTO_TEST=m
 
 #
 # Library routines
 #
 CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
 CONFIG_ZLIB_INFLATE=m
 CONFIG_ZLIB_DEFLATE=m
diff -puN arch/mips/configs/sb1250-swarm_defconfig~mips-update arch/mips/configs/sb1250-swarm_defconfig
--- 25/arch/mips/configs/sb1250-swarm_defconfig~mips-update	2004-06-21 23:10:45.285335160 -0700
+++ 25-akpm/arch/mips/configs/sb1250-swarm_defconfig	2004-06-21 23:10:45.593288344 -0700
@@ -93,7 +93,6 @@ CONFIG_CPU_SB1_PASS_1=y
 # CONFIG_CPU_SB1_PASS_4 is not set
 # CONFIG_CPU_SB1_PASS_2_112x is not set
 # CONFIG_CPU_SB1_PASS_3 is not set
-CONFIG_SIBYTE_HAS_PCI=y
 CONFIG_SIBYTE_HAS_LDT=y
 # CONFIG_SIMULATION is not set
 CONFIG_SIBYTE_CFE=y
@@ -107,7 +106,6 @@ CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_COHERENT=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
-CONFIG_DUMMY_KEYB=y
 CONFIG_SWAP_IO_SPACE=y
 CONFIG_BOOT_ELF32=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
@@ -134,6 +132,7 @@ CONFIG_MIPS_L1_CACHE_SHIFT=5
 # CONFIG_CPU_RM9000 is not set
 CONFIG_CPU_SB1=y
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 # CONFIG_SIBYTE_DMA_PAGEOPS is not set
@@ -154,6 +153,7 @@ CONFIG_NR_CPUS=2
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
 CONFIG_PCI_NAMES=y
@@ -213,7 +213,30 @@ CONFIG_BLK_DEV_INITRD=y
 #
 # ATA/ATAPI/MFM/RLL support
 #
-# CONFIG_IDE is not set
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECD=y
+CONFIG_BLK_DEV_IDETAPE=y
+CONFIG_BLK_DEV_IDEFLOPPY=y
+# CONFIG_IDE_TASK_IOCTL is not set
+# CONFIG_IDE_TASKFILE_IO is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+# CONFIG_BLK_DEV_IDEPCI is not set
+CONFIG_BLK_DEV_IDE_SWARM=y
+# CONFIG_IDE_ARM is not set
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
 
 #
 # SCSI device support
@@ -228,7 +251,6 @@ CONFIG_BLK_DEV_INITRD=y
 #
 # Fusion MPT device support
 #
-# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -371,7 +393,6 @@ CONFIG_NET_SB1250_MAC=y
 # CONFIG_HIPPI is not set
 # CONFIG_PPP is not set
 # CONFIG_SLIP is not set
-# CONFIG_RCPCI is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
 
@@ -575,7 +596,6 @@ CONFIG_SUNRPC=y
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -623,11 +643,13 @@ CONFIG_CRYPTO_AES=y
 # CONFIG_CRYPTO_ARC4 is not set
 CONFIG_CRYPTO_DEFLATE=y
 CONFIG_CRYPTO_MICHAEL_MIC=y
+# CONFIG_CRYPTO_CRC32C is not set
 # CONFIG_CRYPTO_TEST is not set
 
 #
 # Library routines
 #
 CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=y
diff -puN arch/mips/configs/sead_defconfig~mips-update arch/mips/configs/sead_defconfig
--- 25/arch/mips/configs/sead_defconfig~mips-update	2004-06-21 23:10:45.287334856 -0700
+++ 25-akpm/arch/mips/configs/sead_defconfig	2004-06-21 23:10:45.593288344 -0700
@@ -19,7 +19,6 @@ CONFIG_BROKEN_ON_SMP=y
 #
 CONFIG_SWAP=y
 # CONFIG_SYSVIPC is not set
-# CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
@@ -103,6 +102,7 @@ CONFIG_CPU_MIPS32=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
@@ -429,3 +429,4 @@ CONFIG_CMDLINE=""
 # Library routines
 #
 # CONFIG_CRC32 is not set
+# CONFIG_LIBCRC32C is not set
diff -puN arch/mips/configs/tb0226_defconfig~mips-update arch/mips/configs/tb0226_defconfig
--- 25/arch/mips/configs/tb0226_defconfig~mips-update	2004-06-21 23:10:45.289334552 -0700
+++ 25-akpm/arch/mips/configs/tb0226_defconfig	2004-06-21 23:10:45.596287888 -0700
@@ -90,7 +90,6 @@ CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
-CONFIG_DUMMY_KEYB=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 CONFIG_FB=y
 
@@ -115,6 +114,7 @@ CONFIG_CPU_VR41XX=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 # CONFIG_CPU_ADVANCED is not set
@@ -125,6 +125,7 @@ CONFIG_CPU_HAS_SYNC=y
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_PCI=y
 # CONFIG_PCI is not set
 CONFIG_MMU=y
 
@@ -179,7 +180,6 @@ CONFIG_BLK_DEV_IDE=y
 #
 CONFIG_BLK_DEV_IDEDISK=y
 CONFIG_IDEDISK_MULTI_MODE=y
-# CONFIG_IDEDISK_STROKE is not set
 # CONFIG_BLK_DEV_IDECD is not set
 # CONFIG_BLK_DEV_IDETAPE is not set
 # CONFIG_BLK_DEV_IDEFLOPPY is not set
@@ -191,6 +191,7 @@ CONFIG_IDE_TASKFILE_IO=y
 # IDE chipset support/bugfixes
 #
 CONFIG_IDE_GENERIC=y
+# CONFIG_IDE_ARM is not set
 # CONFIG_BLK_DEV_IDEDMA is not set
 # CONFIG_IDEDMA_AUTO is not set
 # CONFIG_BLK_DEV_HD is not set
@@ -215,7 +216,6 @@ CONFIG_CHR_DEV_SG=y
 # Some SCSI devices (e.g. CD jukebox) support multiple LUNs
 #
 CONFIG_SCSI_MULTI_LUN=y
-# CONFIG_SCSI_REPORT_LUNS is not set
 CONFIG_SCSI_CONSTANTS=y
 # CONFIG_SCSI_LOGGING is not set
 
@@ -608,7 +608,6 @@ CONFIG_SMB_NLS_REMOTE="cp932"
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -681,5 +680,6 @@ CONFIG_CMDLINE=""
 # Library routines
 #
 # CONFIG_CRC32 is not set
+# CONFIG_LIBCRC32C is not set
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=m
diff -puN arch/mips/configs/tb0229_defconfig~mips-update arch/mips/configs/tb0229_defconfig
--- 25/arch/mips/configs/tb0229_defconfig~mips-update	2004-06-21 23:10:45.291334248 -0700
+++ 25-akpm/arch/mips/configs/tb0229_defconfig	2004-06-21 23:10:45.598287584 -0700
@@ -59,7 +59,8 @@ CONFIG_MACH_VR41XX=y
 CONFIG_TANBAC_TB0229=y
 # CONFIG_VICTOR_MPC30X is not set
 # CONFIG_ZAO_CAPCELLA is not set
-# CONFIG_VRC4173 is not set
+CONFIG_PCI_VR41XX=y
+CONFIG_VRC4173=y
 # CONFIG_TOSHIBA_JMR3927 is not set
 # CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
@@ -91,7 +92,6 @@ CONFIG_HAVE_DEC_LOCK=y
 CONFIG_DMA_NONCOHERENT=y
 CONFIG_CPU_LITTLE_ENDIAN=y
 CONFIG_IRQ_CPU=y
-CONFIG_DUMMY_KEYB=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 # CONFIG_FB is not set
 CONFIG_TANBAC_TB0219=y
@@ -117,6 +117,7 @@ CONFIG_CPU_VR41XX=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 # CONFIG_CPU_ADVANCED is not set
@@ -127,6 +128,7 @@ CONFIG_CPU_HAS_SYNC=y
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_PCI=y
 CONFIG_PCI=y
 CONFIG_PCI_LEGACY_PROC=y
 CONFIG_PCI_NAMES=y
@@ -196,7 +198,6 @@ CONFIG_BLK_DEV_RAM_SIZE=4096
 #
 # Fusion MPT device support
 #
-# CONFIG_FUSION is not set
 
 #
 # IEEE 1394 (FireWire) support
@@ -355,7 +356,6 @@ CONFIG_SLIP=m
 CONFIG_SLIP_COMPRESSED=y
 CONFIG_SLIP_SMART=y
 CONFIG_SLIP_MODE_SLIP6=y
-# CONFIG_RCPCI is not set
 # CONFIG_SHAPER is not set
 # CONFIG_NETCONSOLE is not set
 
@@ -599,7 +599,6 @@ CONFIG_SMB_NLS_REMOTE="cp932"
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -672,5 +671,6 @@ CONFIG_CMDLINE=""
 # Library routines
 #
 # CONFIG_CRC32 is not set
+# CONFIG_LIBCRC32C is not set
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=m
diff -puN arch/mips/configs/workpad_defconfig~mips-update arch/mips/configs/workpad_defconfig
--- 25/arch/mips/configs/workpad_defconfig~mips-update	2004-06-21 23:10:45.293333944 -0700
+++ 25-akpm/arch/mips/configs/workpad_defconfig	2004-06-21 23:10:45.599287432 -0700
@@ -115,6 +115,7 @@ CONFIG_CPU_VR41XX=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 # CONFIG_CPU_ADVANCED is not set
@@ -179,7 +180,6 @@ CONFIG_BLK_DEV_IDE=y
 #
 CONFIG_BLK_DEV_IDEDISK=y
 # CONFIG_IDEDISK_MULTI_MODE is not set
-# CONFIG_IDEDISK_STROKE is not set
 # CONFIG_BLK_DEV_IDECD is not set
 # CONFIG_BLK_DEV_IDETAPE is not set
 # CONFIG_BLK_DEV_IDEFLOPPY is not set
@@ -190,6 +190,7 @@ CONFIG_IDE_TASKFILE_IO=y
 # IDE chipset support/bugfixes
 #
 CONFIG_IDE_GENERIC=y
+# CONFIG_IDE_ARM is not set
 # CONFIG_IDE_CHIPSETS is not set
 # CONFIG_BLK_DEV_IDEDMA is not set
 # CONFIG_IDEDMA_AUTO is not set
@@ -573,7 +574,6 @@ CONFIG_SUNRPC=y
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -608,3 +608,4 @@ CONFIG_CMDLINE=""
 # Library routines
 #
 # CONFIG_CRC32 is not set
+# CONFIG_LIBCRC32C is not set
diff -puN arch/mips/configs/xxs1500_defconfig~mips-update arch/mips/configs/xxs1500_defconfig
--- 25/arch/mips/configs/xxs1500_defconfig~mips-update	2004-06-21 23:10:45.295333640 -0700
+++ 25-akpm/arch/mips/configs/xxs1500_defconfig	2004-06-21 23:10:45.601287128 -0700
@@ -105,6 +105,7 @@ CONFIG_CPU_MIPS32=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
@@ -496,6 +497,9 @@ CONFIG_FS_MBCACHE=y
 CONFIG_REISERFS_FS=m
 # CONFIG_REISERFS_CHECK is not set
 # CONFIG_REISERFS_PROC_INFO is not set
+CONFIG_REISERFS_FS_XATTR=y
+CONFIG_REISERFS_FS_POSIX_ACL=y
+CONFIG_REISERFS_FS_SECURITY=y
 # CONFIG_JFS_FS is not set
 CONFIG_FS_POSIX_ACL=y
 # CONFIG_XFS_FS is not set
@@ -567,7 +571,6 @@ CONFIG_SMB_FS=m
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -652,11 +655,13 @@ CONFIG_CRYPTO_AES=y
 # CONFIG_CRYPTO_ARC4 is not set
 CONFIG_CRYPTO_DEFLATE=y
 CONFIG_CRYPTO_MICHAEL_MIC=y
+# CONFIG_CRYPTO_CRC32C is not set
 # CONFIG_CRYPTO_TEST is not set
 
 #
 # Library routines
 #
 CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=y
diff -puN arch/mips/configs/yosemite_defconfig~mips-update arch/mips/configs/yosemite_defconfig
--- 25/arch/mips/configs/yosemite_defconfig~mips-update	2004-06-21 23:10:45.296333488 -0700
+++ 25-akpm/arch/mips/configs/yosemite_defconfig	2004-06-21 23:10:45.603286824 -0700
@@ -9,20 +9,20 @@ CONFIG_MIPS32=y
 #
 # Code maturity level options
 #
-CONFIG_EXPERIMENTAL=y
+# CONFIG_EXPERIMENTAL is not set
 CONFIG_CLEAN_COMPILE=y
 CONFIG_STANDALONE=y
+CONFIG_BROKEN_ON_SMP=y
 
 #
 # General setup
 #
 CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
-# CONFIG_POSIX_MQUEUE is not set
 # CONFIG_BSD_PROCESS_ACCT is not set
 CONFIG_SYSCTL=y
 # CONFIG_AUDIT is not set
-CONFIG_LOG_BUF_SHIFT=15
+CONFIG_LOG_BUF_SHIFT=14
 # CONFIG_HOTPLUG is not set
 CONFIG_IKCONFIG=y
 CONFIG_IKCONFIG_PROC=y
@@ -41,47 +41,40 @@ CONFIG_IOSCHED_CFQ=y
 #
 CONFIG_MODULES=y
 CONFIG_MODULE_UNLOAD=y
-# CONFIG_MODULE_FORCE_UNLOAD is not set
 CONFIG_OBSOLETE_MODPARM=y
-CONFIG_MODVERSIONS=y
 CONFIG_KMOD=y
-CONFIG_STOP_MACHINE=y
 
 #
 # Machine selection
 #
 # CONFIG_MACH_JAZZ is not set
-# CONFIG_BAGET_MIPS is not set
 # CONFIG_MACH_VR41XX is not set
 # CONFIG_TOSHIBA_JMR3927 is not set
-# CONFIG_MIPS_COBALT is not set
 # CONFIG_MACH_DECSTATION is not set
-# CONFIG_MIPS_EV64120 is not set
-# CONFIG_MIPS_EV96100 is not set
 # CONFIG_MIPS_IVR is not set
 # CONFIG_LASAT is not set
 # CONFIG_MIPS_ITE8172 is not set
 # CONFIG_MIPS_ATLAS is not set
 # CONFIG_MIPS_MALTA is not set
-# CONFIG_MIPS_SEAD is not set
 # CONFIG_MOMENCO_OCELOT is not set
 # CONFIG_MOMENCO_OCELOT_G is not set
 # CONFIG_MOMENCO_OCELOT_C is not set
 # CONFIG_MOMENCO_JAGUAR_ATX is not set
-# CONFIG_PMC_YOSEMITE is not set
-# CONFIG_DDB5074 is not set
+CONFIG_PMC_YOSEMITE=y
+# CONFIG_HYPERTRANSPORT is not set
 # CONFIG_DDB5476 is not set
 # CONFIG_DDB5477 is not set
 # CONFIG_NEC_OSPREY is not set
 # CONFIG_SGI_IP22 is not set
-# CONFIG_SGI_IP32 is not set
 # CONFIG_SOC_AU1X00 is not set
-# CONFIG_SIBYTE_SB1xxx_SOC is not set
 # CONFIG_SNI_RM200_PCI is not set
 # CONFIG_TOSHIBA_RBTX4927 is not set
 CONFIG_RWSEM_GENERIC_SPINLOCK=y
 CONFIG_HAVE_DEC_LOCK=y
+CONFIG_DMA_COHERENT=y
 # CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_IRQ_CPU=y
+CONFIG_IRQ_CPU_RM7K=y
 CONFIG_MIPS_L1_CACHE_SHIFT=5
 # CONFIG_FB is not set
 
@@ -106,6 +99,7 @@ CONFIG_MIPS_L1_CACHE_SHIFT=5
 CONFIG_CPU_RM9000=y
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_CPU_HAS_PREFETCH=y
@@ -114,15 +108,18 @@ CONFIG_CPU_HAS_PREFETCH=y
 CONFIG_CPU_HAS_LLSC=y
 CONFIG_CPU_HAS_LLDSCD=y
 CONFIG_CPU_HAS_SYNC=y
-# CONFIG_HIGHMEM is not set
-CONFIG_SMP=y
-CONFIG_NR_CPUS=2
+CONFIG_HIGHMEM=y
+# CONFIG_SMP is not set
 # CONFIG_PREEMPT is not set
 # CONFIG_DEBUG_SPINLOCK_SLEEP is not set
 
 #
 # Bus options (PCI, PCMCIA, EISA, ISA, TC)
 #
+CONFIG_HW_HAS_PCI=y
+CONFIG_PCI=y
+CONFIG_PCI_LEGACY_PROC=y
+CONFIG_PCI_NAMES=y
 CONFIG_MMU=y
 
 #
@@ -159,11 +156,14 @@ CONFIG_TRAD_SIGNALS=y
 # Block devices
 #
 # CONFIG_BLK_DEV_FD is not set
-CONFIG_BLK_DEV_LOOP=y
-# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_CPQ_DA is not set
+# CONFIG_BLK_CPQ_CISS_DA is not set
+# CONFIG_BLK_DEV_DAC960 is not set
+# CONFIG_BLK_DEV_LOOP is not set
 # CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_CARMEL is not set
 # CONFIG_BLK_DEV_RAM is not set
-CONFIG_LBD=y
+# CONFIG_LBD is not set
 
 #
 # ATA/ATAPI/MFM/RLL support
@@ -173,40 +173,7 @@ CONFIG_LBD=y
 #
 # SCSI device support
 #
-CONFIG_SCSI=y
-CONFIG_SCSI_PROC_FS=y
-
-#
-# SCSI support type (disk, tape, CD-ROM)
-#
-CONFIG_BLK_DEV_SD=y
-# CONFIG_CHR_DEV_ST is not set
-# CONFIG_CHR_DEV_OSST is not set
-CONFIG_BLK_DEV_SR=y
-# CONFIG_BLK_DEV_SR_VENDOR is not set
-CONFIG_CHR_DEV_SG=y
-
-#
-# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
-#
-# CONFIG_SCSI_MULTI_LUN is not set
-CONFIG_SCSI_REPORT_LUNS=y
-# CONFIG_SCSI_CONSTANTS is not set
-# CONFIG_SCSI_LOGGING is not set
-
-#
-# SCSI Transport Attributes
-#
-# CONFIG_SCSI_SPI_ATTRS is not set
-# CONFIG_SCSI_FC_ATTRS is not set
-
-#
-# SCSI low-level drivers
-#
-# CONFIG_SCSI_AIC7XXX_OLD is not set
-# CONFIG_SCSI_SATA is not set
-# CONFIG_SCSI_EATA_PIO is not set
-# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI is not set
 
 #
 # Multi-device support (RAID and LVM)
@@ -225,6 +192,7 @@ CONFIG_SCSI_REPORT_LUNS=y
 #
 # I2O device support
 #
+# CONFIG_I2O is not set
 
 #
 # Networking support
@@ -234,46 +202,31 @@ CONFIG_NET=y
 #
 # Networking options
 #
-CONFIG_PACKET=y
+CONFIG_PACKET=m
 CONFIG_PACKET_MMAP=y
-# CONFIG_NETLINK_DEV is not set
+CONFIG_NETLINK_DEV=m
 CONFIG_UNIX=y
 # CONFIG_NET_KEY is not set
 CONFIG_INET=y
 # CONFIG_IP_MULTICAST is not set
 # CONFIG_IP_ADVANCED_ROUTER is not set
 CONFIG_IP_PNP=y
-CONFIG_IP_PNP_DHCP=y
-# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_DHCP is not set
+CONFIG_IP_PNP_BOOTP=y
 # CONFIG_IP_PNP_RARP is not set
 # CONFIG_NET_IPIP is not set
 # CONFIG_NET_IPGRE is not set
-# CONFIG_ARPD is not set
 # CONFIG_SYN_COOKIES is not set
 # CONFIG_INET_AH is not set
 # CONFIG_INET_ESP is not set
 # CONFIG_INET_IPCOMP is not set
-# CONFIG_IPV6 is not set
 # CONFIG_NETFILTER is not set
-
-#
-# SCTP Configuration (EXPERIMENTAL)
-#
-# CONFIG_IP_SCTP is not set
-# CONFIG_ATM is not set
 # CONFIG_BRIDGE is not set
 # CONFIG_VLAN_8021Q is not set
 # CONFIG_DECNET is not set
 # CONFIG_LLC2 is not set
 # CONFIG_IPX is not set
 # CONFIG_ATALK is not set
-# CONFIG_X25 is not set
-# CONFIG_LAPB is not set
-# CONFIG_NET_DIVERT is not set
-# CONFIG_ECONET is not set
-# CONFIG_WAN_ROUTER is not set
-# CONFIG_NET_FASTROUTE is not set
-# CONFIG_NET_HW_FLOWCONTROL is not set
 
 #
 # QoS and/or fair queueing
@@ -296,22 +249,49 @@ CONFIG_NETDEVICES=y
 # CONFIG_TUN is not set
 
 #
+# ARCnet devices
+#
+# CONFIG_ARCNET is not set
+
+#
 # Ethernet (10 or 100Mbit)
 #
 CONFIG_NET_ETHERNET=y
-# CONFIG_MII is not set
+CONFIG_MII=y
+# CONFIG_HAPPYMEAL is not set
+# CONFIG_SUNGEM is not set
+# CONFIG_NET_VENDOR_3COM is not set
+
+#
+# Tulip family network device support
+#
+# CONFIG_NET_TULIP is not set
+# CONFIG_HP100 is not set
+# CONFIG_NET_PCI is not set
 
 #
 # Ethernet (1000 Mbit)
 #
+# CONFIG_ACENIC is not set
+# CONFIG_DL2K is not set
+# CONFIG_E1000 is not set
+# CONFIG_NS83820 is not set
+# CONFIG_HAMACHI is not set
+# CONFIG_R8169 is not set
+# CONFIG_SK98LIN is not set
+# CONFIG_TIGON3 is not set
+CONFIG_TITAN_GE=y
 
 #
 # Ethernet (10000 Mbit)
 #
+# CONFIG_IXGB is not set
+# CONFIG_S2IO is not set
 
 #
 # Token Ring devices
 #
+# CONFIG_TR is not set
 
 #
 # Wireless LAN (non-hamradio)
@@ -322,10 +302,9 @@ CONFIG_NET_ETHERNET=y
 # Wan interfaces
 #
 # CONFIG_WAN is not set
+# CONFIG_FDDI is not set
 # CONFIG_PPP is not set
 # CONFIG_SLIP is not set
-# CONFIG_SHAPER is not set
-# CONFIG_NETCONSOLE is not set
 
 #
 # ISDN subsystem
@@ -351,10 +330,8 @@ CONFIG_NET_ETHERNET=y
 #
 # CONFIG_GAMEPORT is not set
 CONFIG_SOUND_GAMEPORT=y
-CONFIG_SERIO=y
-CONFIG_SERIO_I8042=y
-CONFIG_SERIO_SERPORT=y
-# CONFIG_SERIO_CT82C710 is not set
+# CONFIG_SERIO is not set
+# CONFIG_SERIO_I8042 is not set
 
 #
 # Input Device Drivers
@@ -364,22 +341,21 @@ CONFIG_SERIO_SERPORT=y
 # Character devices
 #
 # CONFIG_VT is not set
-CONFIG_SERIAL_NONSTANDARD=y
-# CONFIG_ROCKETPORT is not set
-# CONFIG_CYCLADES is not set
-# CONFIG_SYNCLINK is not set
-# CONFIG_SYNCLINKMP is not set
-# CONFIG_N_HDLC is not set
-# CONFIG_STALDRV is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
 
 #
 # Serial drivers
 #
-# CONFIG_SERIAL_8250 is not set
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_NR_UARTS=4
+# CONFIG_SERIAL_8250_EXTENDED is not set
 
 #
 # Non-8250 serial port support
 #
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
 CONFIG_UNIX98_PTYS=y
 CONFIG_LEGACY_PTYS=y
 CONFIG_LEGACY_PTY_COUNT=256
@@ -403,6 +379,7 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # Ftape, the floppy tape device driver
 #
+# CONFIG_FTAPE is not set
 # CONFIG_AGP is not set
 # CONFIG_DRM is not set
 # CONFIG_RAW_DRIVER is not set
@@ -438,6 +415,7 @@ CONFIG_LEGACY_PTY_COUNT=256
 #
 # USB support
 #
+# CONFIG_USB is not set
 
 #
 # USB Gadget Support
@@ -448,13 +426,8 @@ CONFIG_LEGACY_PTY_COUNT=256
 # File systems
 #
 # CONFIG_EXT2_FS is not set
-CONFIG_EXT3_FS=y
-CONFIG_EXT3_FS_XATTR=y
-# CONFIG_EXT3_FS_POSIX_ACL is not set
-# CONFIG_EXT3_FS_SECURITY is not set
-CONFIG_JBD=y
-# CONFIG_JBD_DEBUG is not set
-CONFIG_FS_MBCACHE=y
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
 # CONFIG_REISERFS_FS is not set
 # CONFIG_JFS_FS is not set
 # CONFIG_XFS_FS is not set
@@ -482,7 +455,6 @@ CONFIG_FS_MBCACHE=y
 CONFIG_PROC_FS=y
 CONFIG_PROC_KCORE=y
 CONFIG_SYSFS=y
-# CONFIG_DEVFS_FS is not set
 # CONFIG_DEVPTS_FS_XATTR is not set
 CONFIG_TMPFS=y
 # CONFIG_HUGETLB_PAGE is not set
@@ -491,13 +463,7 @@ CONFIG_RAMFS=y
 #
 # Miscellaneous filesystems
 #
-# CONFIG_ADFS_FS is not set
-# CONFIG_AFFS_FS is not set
-# CONFIG_HFS_FS is not set
 # CONFIG_HFSPLUS_FS is not set
-# CONFIG_BEFS_FS is not set
-# CONFIG_BFS_FS is not set
-# CONFIG_EFS_FS is not set
 # CONFIG_CRAMFS is not set
 # CONFIG_VXFS_FS is not set
 # CONFIG_HPFS_FS is not set
@@ -509,22 +475,16 @@ CONFIG_RAMFS=y
 # Network File Systems
 #
 CONFIG_NFS_FS=y
-CONFIG_NFS_V3=y
-# CONFIG_NFS_V4 is not set
-# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFS_V3 is not set
 # CONFIG_NFSD is not set
 CONFIG_ROOT_NFS=y
 CONFIG_LOCKD=y
-CONFIG_LOCKD_V4=y
 # CONFIG_EXPORTFS is not set
 CONFIG_SUNRPC=y
-# CONFIG_RPCSEC_GSS_KRB5 is not set
 # CONFIG_SMB_FS is not set
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
-# CONFIG_AFS_FS is not set
 
 #
 # Partition Types
@@ -558,3 +518,4 @@ CONFIG_CMDLINE=""
 # Library routines
 #
 # CONFIG_CRC32 is not set
+# CONFIG_LIBCRC32C is not set
diff -puN arch/mips/defconfig~mips-update arch/mips/defconfig
--- 25/arch/mips/defconfig~mips-update	2004-06-21 23:10:45.298333184 -0700
+++ 25-akpm/arch/mips/defconfig	2004-06-21 23:10:45.605286520 -0700
@@ -114,6 +114,7 @@ CONFIG_CPU_R5000=y
 # CONFIG_CPU_RM9000 is not set
 # CONFIG_CPU_SB1 is not set
 CONFIG_PAGE_SIZE_4KB=y
+# CONFIG_PAGE_SIZE_8KB is not set
 # CONFIG_PAGE_SIZE_16KB is not set
 # CONFIG_PAGE_SIZE_64KB is not set
 CONFIG_BOARD_SCACHE=y
@@ -196,7 +197,6 @@ CONFIG_BLK_DEV_SR=y
 # Some SCSI devices (e.g. CD jukebox) support multiple LUNs
 #
 # CONFIG_SCSI_MULTI_LUN is not set
-# CONFIG_SCSI_REPORT_LUNS is not set
 CONFIG_SCSI_CONSTANTS=y
 # CONFIG_SCSI_LOGGING is not set
 
@@ -750,7 +750,6 @@ CONFIG_RPCSEC_GSS_KRB5=m
 # CONFIG_CIFS is not set
 # CONFIG_NCP_FS is not set
 # CONFIG_CODA_FS is not set
-# CONFIG_INTERMEZZO_FS is not set
 # CONFIG_AFS_FS is not set
 
 #
@@ -850,11 +849,13 @@ CONFIG_CRYPTO_CAST6=m
 CONFIG_CRYPTO_ARC4=m
 CONFIG_CRYPTO_DEFLATE=y
 CONFIG_CRYPTO_MICHAEL_MIC=m
+CONFIG_CRYPTO_CRC32C=m
 # CONFIG_CRYPTO_TEST is not set
 
 #
 # Library routines
 #
 # CONFIG_CRC32 is not set
+CONFIG_LIBCRC32C=m
 CONFIG_ZLIB_INFLATE=y
 CONFIG_ZLIB_DEFLATE=y
diff -puN arch/mips/Kconfig~mips-update arch/mips/Kconfig
--- 25/arch/mips/Kconfig~mips-update	2004-06-21 23:10:45.300332880 -0700
+++ 25-akpm/arch/mips/Kconfig	2004-06-21 23:10:45.609285912 -0700
@@ -96,11 +96,13 @@ config NEC_EAGLE
 	select DMA_NONCOHERENT
 	select IRQ_CPU
 	depends on MACH_VR41XX
+	select HW_HAS_PCI
 
 config TANBAC_TB0226
 	bool "Support for TANBAC TB0226 (Mbase)"
 	depends on MACH_VR41XX
 	select DMA_NONCOHERENT
+	select HW_HAS_PCI
 	select IRQ_CPU
 	help
 	  The TANBAC TB0226 (Mbase) is a MIPS-based platform manufactured by TANBAC.
@@ -110,6 +112,7 @@ config TANBAC_TB0229
 	bool "Support for TANBAC TB0229 (VR4131DIMM)"
 	depends on MACH_VR41XX
 	select DMA_NONCOHERENT
+	select HW_HAS_PCI
 	select IRQ_CPU
 	help
 	  The TANBAC TB0229 (VR4131DIMM) is a MIPS-based platform manufactured by TANBAC.
@@ -118,6 +121,7 @@ config TANBAC_TB0229
 config VICTOR_MPC30X
 	bool "Support for Victor MP-C303/304"
 	select DMA_NONCOHERENT
+	select HW_HAS_PCI
 	select IRQ_CPU
 	depends on MACH_VR41XX
 
@@ -125,17 +129,22 @@ config ZAO_CAPCELLA
 	bool "Support for ZAO Networks Capcella"
 	depends on MACH_VR41XX
 	select DMA_NONCOHERENT
+	select HW_HAS_PCI
 	select IRQ_CPU
 
+config PCI_VR41XX
+	bool "Add PCI control unit support of NEC VR4100 series"
+	depends on MACH_VR41XX && PCI
+
 config VRC4171
-	tristate "add NEC VRC4171 companion chip support"
+	tristate "Add NEC VRC4171 companion chip support"
 	depends on MACH_VR41XX && ISA
 	---help---
 	  The NEC VRC4171/4171A is a companion chip for NEC VR4111/VR4121.
 
 config VRC4173
-	tristate "add NEC VRC4173 companion chip support"
-	depends on MACH_VR41XX && PCI
+	tristate "Add NEC VRC4173 companion chip support"
+	depends on MACH_VR41XX && PCI_VR41XX
 	---help---
 	  The NEC VRC4173 is a companion chip for NEC VR4122/VR4131.
 
@@ -143,11 +152,13 @@ config TOSHIBA_JMR3927
 	bool "Support for Toshiba JMR-TX3927 board"
 	depends on MIPS32
 	select DMA_NONCOHERENT
+	select HW_HAS_PCI
 
 config MIPS_COBALT
 	bool "Support for Cobalt Server (EXPERIMENTAL)"
 	depends on EXPERIMENTAL
 	select DMA_NONCOHERENT
+	select HW_HAS_PCI
 	select IRQ_CPU
 
 config MACH_DECSTATION
@@ -174,6 +185,7 @@ config MIPS_EV64120
 	bool "Support for Galileo EV64120 Evaluation board (EXPERIMENTAL)"
 	depends on EXPERIMENTAL
 	select DMA_NONCOHERENT
+	select HW_HAS_PCI
 	help
 	  This is an evaluation board based on the Galileo GT-64120
 	  single-chip system controller that contains a MIPS R5000 compatible
@@ -189,6 +201,7 @@ config MIPS_EV96100
 	bool "Support for Galileo EV96100 Evaluation board (EXPERIMENTAL)"
 	depends on EXPERIMENTAL
 	select DMA_NONCOHERENT
+	select HW_HAS_PCI
 	select IRQ_CPU
 	select MIPS_GT96100
 	select RM7000_CPU_SCACHE
@@ -201,6 +214,7 @@ config MIPS_EV96100
 config MIPS_IVR
 	bool "Support for Globespan IVR board"
 	select DMA_NONCOHERENT
+	select HW_HAS_PCI
 	help
 	  This is an evaluation board built by Globespan to showcase thir
 	  iVR (Internet Video Recorder) design. It utilizes a QED RM5231
@@ -211,6 +225,7 @@ config MIPS_IVR
 config LASAT
 	bool "Support for LASAT Networks platforms"
 	select DMA_NONCOHERENT
+	select HW_HAS_PCI
 	select R5000_CPU_SCACHE
 
 config PICVUE
@@ -233,11 +248,13 @@ config HP_LASERJET
 	bool "Support for Hewlett Packard LaserJet board"
 	depends on BROKEN
 	select DMA_NONCOHERENT
+	select HW_HAS_PCI
 	select IRQ_CPU
 
 config MIPS_ITE8172
 	bool "Support for ITE 8172G board"
 	select DMA_NONCOHERENT
+	select HW_HAS_PCI
 	help
 	  Ths is an evaluation board made by ITE <http://www.ite.com.tw/>
 	  with ATX form factor that utilizes a MIPS R5000 to work with its
@@ -257,6 +274,7 @@ config IT8172_REVC
 config MIPS_ATLAS
 	bool "Support for MIPS Atlas board"
 	select DMA_NONCOHERENT
+	select HW_HAS_PCI
 	help
 	  This enables support for the QED R5231-based MIPS Atlas evaluation
 	  board.
@@ -265,6 +283,7 @@ config MIPS_MALTA
 	bool "Support for MIPS Malta board"
 	select HAVE_STD_PC_SERIAL_PORT
 	select DMA_NONCOHERENT
+	select HW_HAS_PCI
 	help
 	  This enables support for the VR5000-based MIPS Malta evaluation
 	  board.
@@ -278,6 +297,7 @@ config MIPS_SEAD
 config MOMENCO_OCELOT
 	bool "Support for Momentum Ocelot board"
 	select DMA_NONCOHERENT
+	select HW_HAS_PCI
 	select IRQ_CPU
 	select IRQ_CPU_RM7K
 	select RM7000_CPU_SCACHE
@@ -288,6 +308,7 @@ config MOMENCO_OCELOT
 config MOMENCO_OCELOT_G
 	bool "Support for Momentum Ocelot-G board"
 	select DMA_NONCOHERENT
+	select HW_HAS_PCI
 	select IRQ_CPU
 	select IRQ_CPU_RM7K
 	select RM7000_CPU_SCACHE
@@ -298,6 +319,7 @@ config MOMENCO_OCELOT_G
 config MOMENCO_OCELOT_C
 	bool "Support for Momentum Ocelot-C board"
 	select DMA_NONCOHERENT
+	select HW_HAS_PCI
 	select IRQ_CPU
 	select RM7000_CPU_SCACHE
 	help
@@ -307,6 +329,7 @@ config MOMENCO_OCELOT_C
 config MOMENCO_JAGUAR_ATX
 	bool "Support for Momentum Jaguar board"
 	select DMA_NONCOHERENT
+	select HW_HAS_PCI
 	select IRQ_CPU
 	select IRQ_CPU_RM7K
 	select LIMITED_DMA
@@ -324,7 +347,10 @@ config JAGUAR_DMALOW
 
 config PMC_YOSEMITE
 	bool "Support for PMC-Sierra Yosemite eval board"
-	select DMA_NONCOHERENT
+	select DMA_COHERENT
+	select HW_HAS_PCI
+	select IRQ_CPU
+	select IRQ_CPU_RM7K
 	help
 	  Yosemite is an evaluation board for the RM9000x2 processor
 	  manufactured by PMC-Sierra
@@ -338,6 +364,7 @@ config DDB5074
 	depends on EXPERIMENTAL
 	select DMA_NONCOHERENT
 	select HAVE_STD_PC_SERIAL_PORT
+	select HW_HAS_PCI
 	select IRQ_CPU
 	select ISA
 	help
@@ -348,6 +375,7 @@ config DDB5476
 	bool "Support for NEC DDB Vrc-5476"
 	select DMA_NONCOHERENT
 	select HAVE_STD_PC_SERIAL_PORT
+	select HW_HAS_PCI
 	select IRQ_CPU
 	select ISA
 	help
@@ -361,6 +389,7 @@ config DDB5476
 config DDB5477
 	bool "Support for NEC DDB Vrc-5477"
 	select DMA_NONCOHERENT
+	select HW_HAS_PCI
 	select IRQ_CPU
 	help
 	  This enables support for the R5432-based NEC DDB Vrc-5477,
@@ -393,6 +422,7 @@ config SGI_IP27
 	bool "Support for SGI IP27 (Origin200/2000)"
 	depends on MIPS64
 	select DMA_IP27
+	select HW_HAS_PCI
 	help
 	  This are the SGI Origin 200, Origin 2000 and Onyx 2 Graphics
 	  workstations.  To compile a Linux kernel that runs on these, say Y
@@ -457,6 +487,7 @@ config SGI_IP32
 	bool "Support for SGI IP32 (O2) (EXPERIMENTAL)"
 	depends on EXPERIMENTAL
 	select DMA_NONCOHERENT
+	select HW_HAS_PCI
 	select R5000_CPU_SCACHE
 	select RM7000_CPU_SCACHE
 	help
@@ -499,26 +530,31 @@ config MIPS_PB1000
 	bool "PB1000 board"
 	depends on SOC_AU1000
 	select DMA_NONCOHERENT
+	select HW_HAS_PCI
 
 config MIPS_PB1100
 	bool "PB1100 board"
 	depends on SOC_AU1100
 	select DMA_NONCOHERENT
+	select HW_HAS_PCI
 
 config MIPS_PB1500
 	bool "PB1500 board"
 	depends on SOC_AU1500
 	select DMA_NONCOHERENT
+	select HW_HAS_PCI
 
 config MIPS_PB1550
 	bool "PB1550 board"
 	depends on SOC_AU1550
 	select DMA_NONCOHERENT
+	select HW_HAS_PCI
 
 config MIPS_DB1000
 	bool "DB1000 board"
 	depends on SOC_AU1000
 	select DMA_NONCOHERENT
+	select HW_HAS_PCI
 
 config MIPS_DB1100
 	bool "DB1100 board"
@@ -529,10 +565,12 @@ config MIPS_DB1500
 	bool "DB1500 board"
 	depends on SOC_AU1500
 	select DMA_NONCOHERENT
+	select HW_HAS_PCI
 
 config MIPS_DB1550
 	bool "DB1550 board"
 	depends on SOC_AU1550
+	select HW_HAS_PCI
 
 config MIPS_BOSPORUS
 	bool "Bosporus board"
@@ -642,6 +680,7 @@ endchoice
 
 config SIBYTE_SB1250
 	bool
+	select HW_HAS_PCI
 
 config SIBYTE_BCM1120
 	bool
@@ -649,10 +688,12 @@ config SIBYTE_BCM1120
 
 config SIBYTE_BCM1125
 	bool
+	select HW_HAS_PCI
 	select SIBYTE_BCM112X
 
 config SIBYTE_BCM1125H
 	bool
+	select HW_HAS_PCI
 	select SIBYTE_BCM112X
 
 config SIBYTE_BCM112X
@@ -699,11 +740,6 @@ endchoice
 config CPU_SB1_PASS_2
 	bool
 
-config SIBYTE_HAS_PCI
-	bool
-	depends on SIBYTE_SB1250 || SIBYTE_BCM1125 || SIBYTE_BCM1125H
-	default y
-
 config SIBYTE_HAS_LDT
 	bool
 	depends on PCI && (SIBYTE_SB1250 || SIBYTE_BCM1125H)
@@ -770,6 +806,7 @@ config SNI_RM200_PCI
 	bool "Support for SNI RM200 PCI"
 	select DMA_NONCOHERENT
 	select HAVE_STD_PC_SERIAL_PORT
+	select HW_HAS_PCI
 	select ISA
 	help
 	  The SNI RM200 PCI was a MIPS-based platform manufactured by Siemens
@@ -781,6 +818,7 @@ config TOSHIBA_RBTX4927
 	bool "Support for Toshiba TBTX49[23]7 board"
 	depends on MIPS32
 	select DMA_NONCOHERENT
+	select HW_HAS_PCI
 	select ISA
 
 config RWSEM_GENERIC_SPINLOCK
@@ -860,11 +898,6 @@ config IRQ_CPU
 config IRQ_CPU_RM7K
 	bool
 
-config DUMMY_KEYB
-	bool
-	depends on ZAO_CAPCELLA || VICTOR_MPC30X || SIBYTE_SB1xxx_SOC || NEC_EAGLE || NEC_OSPREY || DDB5477 || CASIO_E55 || TANBAC_TB0226 || TANBAC_TB0229
-	default y
-
 config DDB5XXX_COMMON
 	bool
 	depends on DDB5074 || DDB5476 || DDB5477
@@ -1164,6 +1197,16 @@ config PAGE_SIZE_4KB
 	 4kB page size will minimize memory consumption and is therefore
 	 recommended for low memory systems. 
 
+config PAGE_SIZE_8KB
+	bool "8kB"
+	depends on EXPERIMENTAL && CPU_R8000
+	help
+	  Using 8kB page size will result in higher performance kernel at
+	  the price of higher memory consumption.  This option is available
+	  only on the R8000 processor.  Not that at the time of this writing
+	  this option is still high experimental; there are also issues with
+	  compatibility of user applications.
+
 config PAGE_SIZE_16KB
 	bool "16kB"
 	depends on EXPERIMENTAL && !CPU_R3000 && !CPU_TX39XX
@@ -1377,9 +1420,12 @@ endmenu
 
 menu "Bus options (PCI, PCMCIA, EISA, ISA, TC)"
 
+config HW_HAS_PCI
+	bool
+
 config PCI
 	bool "Support for PCI controller"
-	depends on MIPS_DB1000 || DDB5074 || DDB5476 || DDB5477 || HP_LASERJET || LASAT || MIPS_IVR || MIPS_ATLAS || MIPS_COBALT || MIPS_EV64120 || MIPS_EV96100 || MIPS_ITE8172 || MIPS_MALTA || MOMENCO_OCELOT || MOMENCO_OCELOT_C || MOMENCO_OCELOT_G || MOMENCO_JAGUAR_ATX || MIPS_PB1000 || MIPS_PB1100 || SOC_AU1500 || SOC_AU1550 || NEC_EAGLE || SGI_IP27 || SGI_IP32 || SIBYTE_HAS_PCI || SNI_RM200_PCI || TANBAC_TB0226 || TANBAC_TB0229 || TOSHIBA_JMR3927 || TOSHIBA_RBTX4927 || VICTOR_MPC30X || ZAO_CAPCELLA
+	depends on HW_HAS_PCI
 	help
 	  Find out whether you have a PCI motherboard. PCI is the name of a
 	  bus system, i.e. the way the CPU talks to the other stuff inside
@@ -1559,7 +1605,7 @@ config DEBUG_STACK_USAGE
 
 config DEBUG_SLAB
 	bool "Debug memory allocations"
-	depends on DEBUG_KERNEL && !CPU_HAS_LLDSCD
+	depends on DEBUG_KERNEL
 	help
 	  Say Y here to have the kernel do limited verification on memory
 	  allocation as well as poisoning memory on free to catch use of freed
diff -puN arch/mips/kernel/cpu-bugs64.c~mips-update arch/mips/kernel/cpu-bugs64.c
--- 25/arch/mips/kernel/cpu-bugs64.c~mips-update	2004-06-21 23:10:45.302332576 -0700
+++ 25-akpm/arch/mips/kernel/cpu-bugs64.c	2004-06-21 23:10:45.610285760 -0700
@@ -177,7 +177,7 @@ static inline void check_daddi(void)
 	extern asmlinkage void handle_daddi_ov(void);
 	unsigned long flags;
 	void *handler;
-	long v;
+	long v, tmp;
 
 	printk("Checking for the daddi bug... ");
 
@@ -197,13 +197,15 @@ static inline void check_daddi(void)
 		".set	noat\n\t"
 		".set	noreorder\n\t"
 		".set	nomacro\n\t"
+		"addiu	%1, $0, %2\n\t"
+		"dsrl	%1, %1, 1\n\t"
 #ifdef HAVE_AS_SET_DADDI
 		".set	daddi\n\t"
 #endif
-		"daddi	%0, %1, %2\n\t"
+		"daddi	%0, %1, %3\n\t"
 		".set	pop"
-		: "=r" (v)
-		: "r" (0x7fffffffffffedcd), "I" (0x1234));
+		: "=r" (v), "=&r" (tmp)
+		: "I" (0xffffffffffffdb9a), "I" (0x1234));
 	set_except_vector(12, handler);
 	local_irq_restore(flags);
 
@@ -217,9 +219,11 @@ static inline void check_daddi(void)
 	local_irq_save(flags);
 	handler = set_except_vector(12, handle_daddi_ov);
 	asm volatile(
-		"daddi	%0, %1, %2"
-		: "=r" (v)
-		: "r" (0x7fffffffffffedcd), "I" (0x1234));
+		"addiu	%1, $0, %2\n\t"
+		"dsrl	%1, %1, 1\n\t"
+		"daddi	%0, %1, %3"
+		: "=r" (v), "=&r" (tmp)
+		: "I" (0xffffffffffffdb9a), "I" (0x1234));
 	set_except_vector(12, handler);
 	local_irq_restore(flags);
 
@@ -240,7 +244,7 @@ static inline void check_daddi(void)
 
 static inline void check_daddiu(void)
 {
-	long v, w;
+	long v, w, tmp;
 
 	printk("Checking for the daddiu bug... ");
 
@@ -265,15 +269,17 @@ static inline void check_daddiu(void)
 		".set	noat\n\t"
 		".set	noreorder\n\t"
 		".set	nomacro\n\t"
+		"addiu	%2, $0, %3\n\t"
+		"dsrl	%2, %2, 1\n\t"
 #ifdef HAVE_AS_SET_DADDI
 		".set	daddi\n\t"
 #endif
-		"daddiu	%0, %2, %3\n\t"
-		"addiu	%1, $0, %3\n\t"
+		"daddiu	%0, %2, %4\n\t"
+		"addiu	%1, $0, %4\n\t"
 		"daddu	%1, %2\n\t"
 		".set	pop"
-		: "=&r" (v), "=&r" (w)
-		: "r" (0x7fffffffffffedcd), "I" (0x1234));
+		: "=&r" (v), "=&r" (w), "=&r" (tmp)
+		: "I" (0xffffffffffffdb9a), "I" (0x1234));
 
 	if (v == w) {
 		printk("no.\n");
@@ -283,11 +289,13 @@ static inline void check_daddiu(void)
 	printk("yes, workaround... ");
 
 	asm volatile(
-		"daddiu	%0, %2, %3\n\t"
-		"addiu	%1, $0, %3\n\t"
+		"addiu	%2, $0, %3\n\t"
+		"dsrl	%2, %2, 1\n\t"
+		"daddiu	%0, %2, %4\n\t"
+		"addiu	%1, $0, %4\n\t"
 		"daddu	%1, %2"
-		: "=&r" (v), "=&r" (w)
-		: "r" (0x7fffffffffffedcd), "I" (0x1234));
+		: "=&r" (v), "=&r" (w), "=&r" (tmp)
+		: "I" (0xffffffffffffdb9a), "I" (0x1234));
 
 	if (v == w) {
 		printk("yes.\n");
diff -puN arch/mips/kernel/cpu-probe.c~mips-update arch/mips/kernel/cpu-probe.c
--- 25/arch/mips/kernel/cpu-probe.c~mips-update	2004-06-21 23:10:45.304332272 -0700
+++ 25-akpm/arch/mips/kernel/cpu-probe.c	2004-06-21 23:10:45.612285456 -0700
@@ -1,6 +1,8 @@
 /*
  * Processor capabilities determination functions.
  *
+ * Copyright (C) xxxx  the Anonymous
+ * Copyright (C) 2003  Maciej W. Rozycki
  * Copyright (C) 1994 - 2003 Ralf Baechle
  * Copyright (C) 2001 MIPS Inc.
  *
@@ -49,6 +51,14 @@ static void r4k_wait(void)
 		".set\tmips0");
 }
 
+/*
+ * The Au1xxx wait is available only if we run CONFIG_PM and
+ * the timer setup found we had a 32KHz counter available.
+ * There are still problems with functions that may call au1k_wait
+ * directly, but that will be discovered pretty quickly.
+ */
+extern void (*au1k_wait_ptr)(void);
+
 void au1k_wait(void)
 {
 #ifdef CONFIG_PM
@@ -90,7 +100,6 @@ static inline void check_wait(void)
 	case CPU_R5000:
 	case CPU_NEVADA:
 	case CPU_RM7000:
-/*	case CPU_RM9000: */
 	case CPU_TX49XX:
 	case CPU_4KC:
 	case CPU_4KEC:
@@ -102,12 +111,19 @@ static inline void check_wait(void)
 		cpu_wait = r4k_wait;
 		printk(" available.\n");
 		break;
+#ifdef CONFIG_PM
 	case CPU_AU1000:
 	case CPU_AU1100:
 	case CPU_AU1500:
-		cpu_wait = au1k_wait;
-		printk(" available.\n");
+		if (au1k_wait_ptr != NULL) {
+			cpu_wait = au1k_wait_ptr;
+			printk(" available.\n");
+		}
+		else {
+			printk(" unavailable.\n");
+		}
 		break;
+#endif
 	default:
 		printk(" unavailable.\n");
 		break;
@@ -238,8 +254,8 @@ static inline void cpu_probe_legacy(stru
 			break;
 		default:
 			printk(KERN_INFO "Unexpected CPU of NEC VR4100 series\n");
-				c->cputype = CPU_VR41XX;
-				break;
+			c->cputype = CPU_VR41XX;
+			break;
 		}
 		c->isa_level = MIPS_CPU_ISA_III;
 		c->options = R4K_OPTS;
@@ -371,7 +387,7 @@ static inline void cpu_probe_legacy(stru
 		c->cputype = CPU_RM9000;
 		c->isa_level = MIPS_CPU_ISA_IV;
 		c->options = R4K_OPTS | MIPS_CPU_FPU | MIPS_CPU_32FPR |
-			     MIPS_CPU_LLSC;
+		             MIPS_CPU_LLSC;
 		/*
 		 * Bit 29 in the info register of the RM9000
 		 * indicates if the TLB has 48 or 64 entries.
@@ -407,9 +423,6 @@ static inline void cpu_probe_legacy(stru
 		             MIPS_CPU_LLSC;
 		c->tlbsize = 64;
 		break;
-	default:
-		c->cputype = CPU_UNKNOWN;
-		break;
 	}
 }
 
@@ -475,9 +488,6 @@ static inline void cpu_probe_mips(struct
 		/* Probe for L2 cache */
 		c->scache.flags &= ~MIPS_CACHE_NOT_PRESENT;
 		break;
-	default:
-		c->cputype = CPU_UNKNOWN;
-		break;
 	}
 }
 
@@ -505,9 +515,6 @@ static inline void cpu_probe_alchemy(str
 			break;
 		}
 		c->isa_level = MIPS_CPU_ISA_M32;
- 		break;
-	default:
-		c->cputype = CPU_UNKNOWN;
 		break;
 	}
 }
@@ -528,9 +535,6 @@ static inline void cpu_probe_sibyte(stru
 		c->options |= MIPS_CPU_FPU | MIPS_CPU_32FPR;
 #endif
 		break;
-	default:
-		c->cputype = CPU_UNKNOWN;
-		break;
 	}
 }
 
@@ -542,14 +546,11 @@ static inline void cpu_probe_sandcraft(s
 		c->cputype = CPU_SR71000;
 		c->isa_level = MIPS_CPU_ISA_M64;
 		c->options = MIPS_CPU_TLB | MIPS_CPU_4KEX |
-                                    MIPS_CPU_4KTLB | MIPS_CPU_FPU |
+		             MIPS_CPU_4KTLB | MIPS_CPU_FPU |
 		             MIPS_CPU_COUNTER | MIPS_CPU_MCHECK;
 		c->scache.ways = 8;
 		c->tlbsize = 64;
 		break;
-	default:
-		c->cputype = CPU_UNKNOWN;
-		break;
 	}
 }
 
@@ -563,7 +564,6 @@ __init void cpu_probe(void)
 
 	c->processor_id = read_c0_prid();
 	switch (c->processor_id & 0xff0000) {
-
 	case PRID_COMP_LEGACY:
 		cpu_probe_legacy(c);
 		break;
diff -puN arch/mips/kernel/Makefile~mips-update arch/mips/kernel/Makefile
--- 25/arch/mips/kernel/Makefile~mips-update	2004-06-21 23:10:45.305332120 -0700
+++ 25-akpm/arch/mips/kernel/Makefile	2004-06-21 23:10:45.613285304 -0700
@@ -9,7 +9,7 @@ obj-y		+= cpu-probe.o branch.o entry.o g
 		   time.o traps.o unaligned.o
 
 ifdef CONFIG_MODULES
-obj-y				+= mips_ksyms.o
+obj-y				+= mips_ksyms.o module.o
 obj-$(CONFIG_MIPS32)		+= module-elf32.o
 obj-$(CONFIG_MIPS64)		+= module-elf64.o
 endif
@@ -23,6 +23,7 @@ obj-$(CONFIG_CPU_R4300)		+= r4k_fpu.o r4
 obj-$(CONFIG_CPU_R4X00)		+= r4k_fpu.o r4k_switch.o
 obj-$(CONFIG_CPU_R5000)		+= r4k_fpu.o r4k_switch.o
 obj-$(CONFIG_CPU_R5432)		+= r4k_fpu.o r4k_switch.o
+obj-$(CONFIG_CPU_R8000)		+= r4k_fpu.o r4k_switch.o
 obj-$(CONFIG_CPU_RM7000)	+= r4k_fpu.o r4k_switch.o
 obj-$(CONFIG_CPU_RM9000)	+= r4k_fpu.o r4k_switch.o
 obj-$(CONFIG_CPU_NEVADA)	+= r4k_fpu.o r4k_switch.o
diff -puN /dev/null arch/mips/kernel/module.c
--- /dev/null	2003-09-15 06:40:47.000000000 -0700
+++ 25-akpm/arch/mips/kernel/module.c	2004-06-21 23:10:45.614285152 -0700
@@ -0,0 +1,53 @@
+#include <linux/module.h>
+#include <linux/spinlock.h>
+
+static LIST_HEAD(dbe_list);
+static spinlock_t dbe_lock = SPIN_LOCK_UNLOCKED;
+
+/* Given an address, look for it in the module exception tables. */
+const struct exception_table_entry *search_module_dbetables(unsigned long addr)
+{
+	unsigned long flags;
+	const struct exception_table_entry *e = NULL;
+	struct mod_arch_specific *dbe;
+
+	spin_lock_irqsave(&dbe_lock, flags);
+	list_for_each_entry(dbe, &dbe_list, dbe_list) {
+		e = search_extable(dbe->dbe_start, dbe->dbe_end - 1, addr);
+		if (e)
+			break;
+	}
+	spin_unlock_irqrestore(&dbe_lock, flags);
+
+	/* Now, if we found one, we are running inside it now, hence
+           we cannot unload the module, hence no refcnt needed. */
+	return e;
+}
+
+/* Put in dbe list if neccessary. */
+int module_finalize(const Elf_Ehdr *hdr,
+		    const Elf_Shdr *sechdrs,
+		    struct module *me)
+{
+	const Elf_Shdr *s;
+	char *secstrings = (void *)hdr + sechdrs[hdr->e_shstrndx].sh_offset;
+
+	INIT_LIST_HEAD(&me->arch.dbe_list);
+	for (s = sechdrs; s < sechdrs + hdr->e_shnum; s++) {
+		if (strcmp("__dbe_table", secstrings + s->sh_name) != 0)
+			continue;
+		me->arch.dbe_start = (void *)s->sh_addr;
+		me->arch.dbe_end = (void *)s->sh_addr + s->sh_size;
+		spin_lock_irq(&dbe_lock);
+		list_add(&me->arch.dbe_list, &dbe_list);
+		spin_unlock_irq(&dbe_lock);
+	}
+	return 0;
+}
+
+void module_arch_cleanup(struct module *mod)
+{
+	spin_lock_irq(&dbe_lock);
+	list_del(&mod->arch.dbe_list);
+	spin_unlock_irq(&dbe_lock);
+}
diff -puN arch/mips/kernel/module-elf32.c~mips-update arch/mips/kernel/module-elf32.c
--- 25/arch/mips/kernel/module-elf32.c~mips-update	2004-06-21 23:10:45.309331512 -0700
+++ 25-akpm/arch/mips/kernel/module-elf32.c	2004-06-21 23:10:45.615285000 -0700
@@ -248,14 +248,3 @@ int apply_relocate_add(Elf32_Shdr *sechd
 	       me->name);
 	return -ENOEXEC;
 }
-
-int module_finalize(const Elf_Ehdr *hdr,
-		    const Elf_Shdr *sechdrs,
-		    struct module *me)
-{
-	return 0;
-}
-
-void module_arch_cleanup(struct module *mod)
-{
-}
diff -puN arch/mips/kernel/module-elf64.c~mips-update arch/mips/kernel/module-elf64.c
--- 25/arch/mips/kernel/module-elf64.c~mips-update	2004-06-21 23:10:45.310331360 -0700
+++ 25-akpm/arch/mips/kernel/module-elf64.c	2004-06-21 23:10:45.616284848 -0700
@@ -272,14 +272,3 @@ int apply_relocate_add(Elf64_Shdr *sechd
 
 	return 0;
 }
-
-int module_finalize(const Elf_Ehdr *hdr,
-		    const Elf_Shdr *sechdrs,
-		    struct module *me)
-{
-	return 0;
-}
-
-void module_arch_cleanup(struct module *mod)
-{
-}
diff -puN arch/mips/kernel/scall32-o32.S~mips-update arch/mips/kernel/scall32-o32.S
--- 25/arch/mips/kernel/scall32-o32.S~mips-update	2004-06-21 23:10:45.312331056 -0700
+++ 25-akpm/arch/mips/kernel/scall32-o32.S	2004-06-21 23:10:45.619284392 -0700
@@ -627,6 +627,7 @@ out:	jr	ra
 	sys	sys_mq_timedreceive	5
 	sys	sys_mq_notify		2	/* 4275 */
 	sys	sys_mq_getsetattr	3
+	sys	sys_ni_syscall		0	/* sys_vserver */
 
 	.endm
 
diff -puN arch/mips/kernel/scall64-64.S~mips-update arch/mips/kernel/scall64-64.S
--- 25/arch/mips/kernel/scall64-64.S~mips-update	2004-06-21 23:10:45.314330752 -0700
+++ 25-akpm/arch/mips/kernel/scall64-64.S	2004-06-21 23:10:45.620284240 -0700
@@ -447,3 +447,4 @@ sys_call_table:
 	PTR	sys_mq_timedreceive
 	PTR	sys_mq_notify
 	PTR	sys_mq_getsetattr		/* 5235 */
+	PTR	sys_ni_syscall			/* sys_vserver */
diff -puN arch/mips/kernel/scall64-n32.S~mips-update arch/mips/kernel/scall64-n32.S
--- 25/arch/mips/kernel/scall64-n32.S~mips-update	2004-06-21 23:10:45.316330448 -0700
+++ 25-akpm/arch/mips/kernel/scall64-n32.S	2004-06-21 23:10:45.621284088 -0700
@@ -357,3 +357,4 @@ EXPORT(sysn32_call_table)
 	PTR	compat_sys_mq_timedreceive
 	PTR	compat_sys_mq_notify
 	PTR	compat_sys_mq_getsetattr	/* 6239 */
+	PTR	sys_ni_syscall			/* sys_vserver */
diff -puN arch/mips/kernel/scall64-o32.S~mips-update arch/mips/kernel/scall64-o32.S
--- 25/arch/mips/kernel/scall64-o32.S~mips-update	2004-06-21 23:10:45.318330144 -0700
+++ 25-akpm/arch/mips/kernel/scall64-o32.S	2004-06-21 23:10:45.622283936 -0700
@@ -535,6 +535,7 @@ out:	jr	ra
 	sys	compat_sys_mq_timedreceive 5
 	sys	compat_sys_mq_notify	2	/* 4275 */
 	sys	compat_sys_mq_getsetattr 3
+	sys	sys_ni_syscall		0	/* sys_vserver */
 
 	.endm
 
diff -puN arch/mips/kernel/semaphore.c~mips-update arch/mips/kernel/semaphore.c
--- 25/arch/mips/kernel/semaphore.c~mips-update	2004-06-21 23:10:45.320329840 -0700
+++ 25-akpm/arch/mips/kernel/semaphore.c	2004-06-21 23:10:45.624283632 -0700
@@ -1,273 +1,165 @@
 /*
- * Copyright (C) 1999, 2001, 02, 03 Ralf Baechle
+ * MIPS-specific semaphore code.
  *
- * Heavily inspired by the Alpha implementation
+ * Copyright (C) 1999 Cort Dougan <cort@cs.nmt.edu>
+ * Copyright (C) 2004 Ralf Baechle <ralf@linux-mips.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * April 2001 - Reworked by Paul Mackerras <paulus@samba.org>
+ * to eliminate the SMP races in the old version between the updates
+ * of `count' and `waking'.  Now we use negative `count' values to
+ * indicate that some process(es) are waiting for the semaphore.
  */
+
 #include <linux/config.h>
-#include <linux/errno.h>
 #include <linux/module.h>
-#include <linux/init.h>
 #include <linux/sched.h>
+#include <linux/init.h>
+#include <asm/atomic.h>
+#include <asm/semaphore.h>
+#include <asm/errno.h>
 
-#ifdef CONFIG_CPU_HAS_LLDSCD
-/*
- * On machines without lld/scd we need a spinlock to make the manipulation of
- * sem->count and sem->waking atomic.  Scalability isn't an issue because
- * this lock is used on UP only so it's just an empty variable.
- */
-spinlock_t semaphore_lock = SPIN_LOCK_UNLOCKED;
-
-EXPORT_SYMBOL(semaphore_lock);
-#endif
+#ifdef CONFIG_CPU_HAS_LLSC
 
 /*
- * Semaphores are implemented using a two-way counter: The "count" variable is
- * decremented for each process that tries to sleep, while the "waking" variable
- * is incremented when the "up()" code goes to wake up waiting processes.
- *
- * Notably, the inline "up()" and "down()" functions can efficiently test if
- * they need to do any extra work (up needs to do something only if count was
- * negative before the increment operation.
- *
- * waking_non_zero() must execute atomically.
- *
- * When __up() is called, the count was negative before incrementing it, and we
- * need to wake up somebody.
+ * Atomically update sem->count.
+ * This does the equivalent of the following:
  *
- * This routine adds one to the count of processes that need to wake up and
- * exit.  ALL waiting processes actually wake up but only the one that gets to
- * the "waking" field first will gate through and acquire the semaphore.  The
- * others will go back to sleep.
- *
- * Note that these functions are only called when there is contention on the
- * lock, and as such all this is the "non-critical" part of the whole semaphore
- * business. The critical part is the inline stuff in <asm/semaphore.h> where
- * we want to avoid any extra jumps and calls.
+ *	old_count = sem->count;
+ *	tmp = MAX(old_count, 0) + incr;
+ *	sem->count = tmp;
+ *	return old_count;
  */
-void __up_wakeup(struct semaphore *sem)
-{
-	wake_up(&sem->wait);
-}
-
-EXPORT_SYMBOL(__up_wakeup);
-
-#ifdef CONFIG_CPU_HAS_LLSC
-
-static inline int waking_non_zero(struct semaphore *sem)
+static inline int __sem_update_count(struct semaphore *sem, int incr)
 {
-	int ret, tmp;
+	int old_count, tmp;
 
 	__asm__ __volatile__(
-	"1:	ll	%1, %2			# waking_non_zero	\n"
-	"	blez	%1, 2f						\n"
-	"	subu	%0, %1, 1					\n"
-	"	sc	%0, %2						\n"
-	"	beqz	%0, 1b						\n"
-	"2:								\n"
-	: "=r" (ret), "=r" (tmp), "+m" (sem->waking)
-	: "0" (0));
+	"1:	ll	%0, %2					\n"
+	"	sra	%1, %0, 31				\n"
+	"	not	%1					\n"
+	"	and	%1, %0, %1				\n"
+	"	add	%1, %1, %3				\n"
+	"	sc	%1, %2					\n"
+	"	beqz	%1, 1b					\n"
+	: "=&r" (old_count), "=&r" (tmp), "=m" (sem->count)
+	: "r" (incr), "m" (sem->count));
 
-	return ret;
+	return old_count;
 }
 
-#else /* !CONFIG_CPU_HAS_LLSC */
+#else
+
+/*
+ * On machines without lld/scd we need a spinlock to make the manipulation of
+ * sem->count and sem->waking atomic.  Scalability isn't an issue because
+ * this lock is used on UP only so it's just an empty variable.
+ */
+static spinlock_t semaphore_lock = SPIN_LOCK_UNLOCKED;
 
-static inline int waking_non_zero(struct semaphore *sem)
+static inline int __sem_update_count(struct semaphore *sem, int incr)
 {
 	unsigned long flags;
-	int waking, ret = 0;
+	int old_count, tmp;
 
 	spin_lock_irqsave(&semaphore_lock, flags);
-	waking = atomic_read(&sem->waking);
-	if (waking > 0) {
-		atomic_set(&sem->waking, waking - 1);
-		ret = 1;
-	}
+	old_count = atomic_read(&sem->count);
+	tmp = max_t(int, old_count, 0) + incr;
+	atomic_set(&sem->count, tmp);
 	spin_unlock_irqrestore(&semaphore_lock, flags);
 
-	return ret;
+	return old_count;
 }
 
-#endif /* !CONFIG_CPU_HAS_LLSC */
-
-/*
- * Perform the "down" function.  Return zero for semaphore acquired, return
- * negative for signalled out of the function.
- *
- * If called from down, the return is ignored and the wait loop is not
- * interruptible.  This means that a task waiting on a semaphore using "down()"
- * cannot be killed until someone does an "up()" on the semaphore.
- *
- * If called from down_interruptible, the return value gets checked upon return.
- * If the return value is negative then the task continues with the negative
- * value in the return register (it can be tested by the caller).
- *
- * Either form may be used in conjunction with "up()".
- */
+#endif
 
-void __sched __down_failed(struct semaphore * sem)
+void __up(struct semaphore *sem)
 {
-	struct task_struct *tsk = current;
-	wait_queue_t wait;
-
-	init_waitqueue_entry(&wait, tsk);
-	__set_current_state(TASK_UNINTERRUPTIBLE);
-	add_wait_queue_exclusive(&sem->wait, &wait);
-
 	/*
-	 * Ok, we're set up.  sem->count is known to be less than zero
-	 * so we must wait.
-	 *
-	 * We can let go the lock for purposes of waiting.
-	 * We re-acquire it after awaking so as to protect
-	 * all semaphore operations.
-	 *
-	 * If "up()" is called before we call waking_non_zero() then
-	 * we will catch it right away.  If it is called later then
-	 * we will have to go through a wakeup cycle to catch it.
-	 *
-	 * Multiple waiters contend for the semaphore lock to see
-	 * who gets to gate through and who has to wait some more.
+	 * Note that we incremented count in up() before we came here,
+	 * but that was ineffective since the result was <= 0, and
+	 * any negative value of count is equivalent to 0.
+	 * This ends up setting count to 1, unless count is now > 0
+	 * (i.e. because some other cpu has called up() in the meantime),
+	 * in which case we just increment count.
 	 */
-	for (;;) {
-		if (waking_non_zero(sem))
-			break;
-		schedule();
-		__set_current_state(TASK_UNINTERRUPTIBLE);
-	}
-	__set_current_state(TASK_RUNNING);
-	remove_wait_queue(&sem->wait, &wait);
+	__sem_update_count(sem, 1);
+	wake_up(&sem->wait);
 }
 
-EXPORT_SYMBOL(__down_failed);
-
-#ifdef CONFIG_CPU_HAS_LLDSCD
+EXPORT_SYMBOL(__up);
 
 /*
- * waking_non_zero_interruptible:
- *	1	got the lock
- *	0	go to sleep
- *	-EINTR	interrupted
- *
- * We must undo the sem->count down_interruptible decrement
- * simultaneously and atomically with the sem->waking adjustment,
- * otherwise we can race with wake_one_more.
- *
- * This is accomplished by doing a 64-bit lld/scd on the 2 32-bit words.
- *
- * This is crazy.  Normally it's strictly forbidden to use 64-bit operations
- * in the 32-bit MIPS kernel.  In this case it's however ok because if an
- * interrupt has destroyed the upper half of registers sc will fail.
- * Note also that this will not work for MIPS32 CPUs!
- *
- * Pseudocode:
- *
- * If(sem->waking > 0) {
- *	Decrement(sem->waking)
- *	Return(SUCCESS)
- * } else If(signal_pending(tsk)) {
- *	Increment(sem->count)
- *	Return(-EINTR)
- * } else {
- *	Return(SLEEP)
- * }
+ * Note that when we come in to __down or __down_interruptible,
+ * we have already decremented count, but that decrement was
+ * ineffective since the result was < 0, and any negative value
+ * of count is equivalent to 0.
+ * Thus it is only when we decrement count from some value > 0
+ * that we have actually got the semaphore.
  */
-
-static inline int
-waking_non_zero_interruptible(struct semaphore *sem, struct task_struct *tsk)
+void __sched __down(struct semaphore *sem)
 {
-	long ret, tmp;
-
-	__asm__ __volatile__(
-	"	.set	push		# waking_non_zero_interruptible	\n"
-	"	.set	mips3						\n"
-	"	.set	noat						\n"
-	"0:	lld	%1, %2						\n"
-	"	li	%0, 0						\n"
-	"	sll	$1, %1, 0					\n"
-	"	blez	$1, 1f						\n"
-	"	daddiu	%1, %1, -1					\n"
-	"	li	%0, 1						\n"
-	"	b	2f						\n"
-	"1:	beqz	%3, 2f						\n"
-	"	li	%0, %4						\n"
-	"	dli	$1, 0x0000000100000000				\n"
-	"	daddu	%1, %1, $1					\n"
-	"2:	scd	%1, %2						\n"
-	"	beqz	%1, 0b						\n"
-	"	.set	pop						\n"
-	: "=&r" (ret), "=&r" (tmp), "=m" (*sem)
-	: "r" (signal_pending(tsk)), "i" (-EINTR));
-
-	return ret;
-}
-
-#else /* !CONFIG_CPU_HAS_LLDSCD */
-
-static inline int waking_non_zero_interruptible(struct semaphore *sem,
-						struct task_struct *tsk)
-{
-	int waking, pending, ret = 0;
-	unsigned long flags;
+	struct task_struct *tsk = current;
+	DECLARE_WAITQUEUE(wait, tsk);
 
-	pending = signal_pending(tsk);
+	__set_task_state(tsk, TASK_UNINTERRUPTIBLE);
+	add_wait_queue_exclusive(&sem->wait, &wait);
 
-	spin_lock_irqsave(&semaphore_lock, flags);
-	waking = atomic_read(&sem->waking);
-	if (waking > 0) {
-		atomic_set(&sem->waking, waking - 1);
-		ret = 1;
-	} else if (pending) {
-		atomic_set(&sem->count, atomic_read(&sem->count) + 1);
-		ret = -EINTR;
+	/*
+	 * Try to get the semaphore.  If the count is > 0, then we've
+	 * got the semaphore; we decrement count and exit the loop.
+	 * If the count is 0 or negative, we set it to -1, indicating
+	 * that we are asleep, and then sleep.
+	 */
+	while (__sem_update_count(sem, -1) <= 0) {
+		schedule();
+		set_task_state(tsk, TASK_UNINTERRUPTIBLE);
 	}
-	spin_unlock_irqrestore(&semaphore_lock, flags);
+	remove_wait_queue(&sem->wait, &wait);
+	__set_task_state(tsk, TASK_RUNNING);
 
-	return ret;
+	/*
+	 * If there are any more sleepers, wake one of them up so
+	 * that it can either get the semaphore, or set count to -1
+	 * indicating that there are still processes sleeping.
+	 */
+	wake_up(&sem->wait);
 }
 
-#endif /* !CONFIG_CPU_HAS_LLDSCD */
+EXPORT_SYMBOL(__down);
 
-int __sched __down_failed_interruptible(struct semaphore * sem)
+int __sched __down_interruptible(struct semaphore * sem)
 {
+	int retval = 0;
 	struct task_struct *tsk = current;
-	wait_queue_t wait;
-	int ret = 0;
+	DECLARE_WAITQUEUE(wait, tsk);
 
-	init_waitqueue_entry(&wait, tsk);
-	__set_current_state(TASK_INTERRUPTIBLE);
+	__set_task_state(tsk, TASK_INTERRUPTIBLE);
 	add_wait_queue_exclusive(&sem->wait, &wait);
 
-	/*
-	 * Ok, we're set up.  sem->count is known to be less than zero
-	 * so we must wait.
-	 *
-	 * We can let go the lock for purposes of waiting.
-	 * We re-acquire it after awaking so as to protect
-	 * all semaphore operations.
-	 *
-	 * If "up()" is called before we call waking_non_zero() then
-	 * we will catch it right away.  If it is called later then
-	 * we will have to go through a wakeup cycle to catch it.
-	 *
-	 * Multiple waiters contend for the semaphore lock to see
-	 * who gets to gate through and who has to wait some more.
-	 */
-	for (;;) {
-		ret = waking_non_zero_interruptible(sem, tsk);
-		if (ret) {
-			if (ret == 1)
-				/* ret != 0 only if we get interrupted -arca */
-				ret = 0;
+	while (__sem_update_count(sem, -1) <= 0) {
+		if (signal_pending(current)) {
+			/*
+			 * A signal is pending - give up trying.
+			 * Set sem->count to 0 if it is negative,
+			 * since we are no longer sleeping.
+			 */
+			__sem_update_count(sem, 0);
+			retval = -EINTR;
 			break;
 		}
 		schedule();
-		__set_current_state(TASK_INTERRUPTIBLE);
+		set_task_state(tsk, TASK_INTERRUPTIBLE);
 	}
-	__set_current_state(TASK_RUNNING);
 	remove_wait_queue(&sem->wait, &wait);
+	__set_task_state(tsk, TASK_RUNNING);
 
-	return ret;
+	wake_up(&sem->wait);
+	return retval;
 }
 
-EXPORT_SYMBOL(__down_failed_interruptible);
+EXPORT_SYMBOL(__down_interruptible);
diff -puN arch/mips/kernel/setup.c~mips-update arch/mips/kernel/setup.c
--- 25/arch/mips/kernel/setup.c~mips-update	2004-06-21 23:10:45.322329536 -0700
+++ 25-akpm/arch/mips/kernel/setup.c	2004-06-21 23:10:45.627283176 -0700
@@ -452,14 +452,18 @@ static void __init do_earlyinitcalls(voi
 
 void __init setup_arch(char **cmdline_p)
 {
+	unsigned int status;
+
 	cpu_probe();
 	prom_init();
 	cpu_report();
 
 #ifdef CONFIG_MIPS32
 	/* Disable coprocessors and set FPU for 16/32 FPR register model */
-	clear_c0_status(ST0_CU1|ST0_CU2|ST0_CU3|ST0_KX|ST0_SX|ST0_FR);
-	set_c0_status(ST0_CU0);
+	status = read_c0_status();
+	status &= ~(ST0_CU1|ST0_CU2|ST0_CU3|ST0_KX|ST0_SX|ST0_FR);
+	status |= ST0_CU0;
+	write_c0_status(status);
 #endif
 #ifdef CONFIG_MIPS64
 	/*
@@ -467,8 +471,10 @@ void __init setup_arch(char **cmdline_p)
 	 * Maybe because the kernel is in ckseg0 and not xkphys? Clear it
 	 * anyway ...
 	 */
-	clear_c0_status(ST0_BEV|ST0_TS|ST0_CU1|ST0_CU2|ST0_CU3);
-	set_c0_status(ST0_CU0|ST0_KX|ST0_SX|ST0_FR);
+	status = read_c0_status();
+	status &= ~(ST0_BEV|ST0_TS|ST0_CU1|ST0_CU2|ST0_CU3);
+	status |= (ST0_CU0|ST0_KX|ST0_SX|ST0_FR);
+	write_c0_status(status);
 #endif
 
 #if defined(CONFIG_VT)
diff -puN arch/mips/kernel/syscall.c~mips-update arch/mips/kernel/syscall.c
--- 25/arch/mips/kernel/syscall.c~mips-update	2004-06-21 23:10:45.324329232 -0700
+++ 25-akpm/arch/mips/kernel/syscall.c	2004-06-21 23:10:45.628283024 -0700
@@ -36,7 +36,7 @@
 #include <asm/sysmips.h>
 #include <asm/uaccess.h>
 
-asmlinkage int sys_pipe(nabi_no_regargs struct pt_regs regs)
+asmlinkage int sys_pipe(nabi_no_regargs volatile struct pt_regs regs)
 {
 	int fd[2];
 	int error, res;
diff -puN arch/mips/kernel/sysirix.c~mips-update arch/mips/kernel/sysirix.c
--- 25/arch/mips/kernel/sysirix.c~mips-update	2004-06-21 23:10:45.326328928 -0700
+++ 25-akpm/arch/mips/kernel/sysirix.c	2004-06-21 23:10:45.631282568 -0700
@@ -1639,7 +1639,7 @@ asmlinkage int irix_statvfs64(char *fnam
 
 	printk("[%s:%d] Wheee.. irix_statvfs(%s,%p)\n",
 	       current->comm, current->pid, fname, buf);
-	error = verify_area(VERIFY_WRITE, buf, sizeof(struct irix_statvfs));
+	error = verify_area(VERIFY_WRITE, buf, sizeof(struct irix_statvfs64));
 	if(error)
 		goto out;
 	error = user_path_walk(fname, &nd);
diff -puN arch/mips/kernel/time.c~mips-update arch/mips/kernel/time.c
--- 25/arch/mips/kernel/time.c~mips-update	2004-06-21 23:10:45.327328776 -0700
+++ 25-akpm/arch/mips/kernel/time.c	2004-06-21 23:10:45.632282416 -0700
@@ -789,3 +789,8 @@ EXPORT_SYMBOL(rtc_lock);
 EXPORT_SYMBOL(to_tm);
 EXPORT_SYMBOL(rtc_set_time);
 EXPORT_SYMBOL(rtc_get_time);
+
+unsigned long long sched_clock(void)
+{
+	return (unsigned long long)jiffies*(1000000000/HZ);
+}
diff -puN arch/mips/kernel/traps.c~mips-update arch/mips/kernel/traps.c
--- 25/arch/mips/kernel/traps.c~mips-update	2004-06-21 23:10:45.329328472 -0700
+++ 25-akpm/arch/mips/kernel/traps.c	2004-06-21 23:10:45.634282112 -0700
@@ -234,6 +234,7 @@ void show_regs(struct pt_regs *regs)
 void show_registers(struct pt_regs *regs)
 {
 	show_regs(regs);
+	print_modules();
 	printk("Process %s (pid: %d, threadinfo=%p, task=%p)\n",
 	        current->comm, current->pid, current_thread_info(), current);
 	show_stack(current, (long *) regs->regs[29]);
@@ -278,47 +279,8 @@ void __declare_dbe_table(void)
 	);
 }
 
-#ifdef CONFIG_MDULES
-
-/* Given an address, look for it in the module exception tables. */
-const struct exception_table_entry *search_module_dbetables(unsigned long addr)
-{
-	unsigned long flags;
-	const struct exception_table_entry *e = NULL;
-	struct module *mod;
-
-	spin_lock_irqsave(&modlist_lock, flags);
-	list_for_each_entry(mod, &modules, list) {
-		if (mod->arch.num_dbeentries == 0)
-			continue;
-				
-		e = search_extable(mod->arch.dbe_table_start,
-				   mod->arch.dbe_table_end +
-		                   mod->arch.num_dbeentries - 1,
-				   addr);
-		if (e)
-			break;
-	}
-	spin_unlock_irqrestore(&modlist_lock, flags);
-
-	/* Now, if we found one, we are running inside it now, hence
-           we cannot unload the module, hence no refcnt needed. */
-	return e;
-}
-
-#else
-
 /* Given an address, look for it in the exception tables. */
-static inline const struct exception_table_entry *
-search_module_dbetables(unsigned long addr)
-{
-	return NULL;
-}
-
-#endif
-
-/* Given an address, look for it in the exception tables. */
-const struct exception_table_entry *search_dbe_tables(unsigned long addr)
+static const struct exception_table_entry *search_dbe_tables(unsigned long addr)
 {
 	const struct exception_table_entry *e;
 
@@ -745,12 +707,25 @@ asmlinkage void do_reserved(struct pt_re
 static inline void parity_protection_init(void)
 {
 	switch (current_cpu_data.cputype) {
+	case CPU_24K:
+		/* 24K cache parity not currently implemented in FPGA */
+		printk(KERN_INFO "Disable cache parity protection for "
+		       "MIPS 24K CPU.\n");
+		write_c0_ecc(read_c0_ecc() & ~0x80000000);
+		break;
 	case CPU_5KC:
 		/* Set the PE bit (bit 31) in the c0_ecc register. */
-		printk(KERN_INFO "Enable the cache parity protection for "
-		       "MIPS 5KC CPUs.\n");
+		printk(KERN_INFO "Enable cache parity protection for "
+		       "MIPS 5KC/24K CPUs.\n");
 		write_c0_ecc(read_c0_ecc() | 0x80000000);
 		break;
+	case CPU_20KC:
+	case CPU_25KF:
+		/* Clear the DE bit (bit 16) in the c0_status register. */
+		printk(KERN_INFO "Enable cache parity protection for "
+		       "MIPS 20KC/25KF CPUs.\n");
+		clear_c0_status(ST0_DE);
+		break;
 	default:
 		break;
 	}
diff -puN arch/mips/lib-32/Makefile~mips-update arch/mips/lib-32/Makefile
--- 25/arch/mips/lib-32/Makefile~mips-update	2004-06-21 23:10:45.331328168 -0700
+++ 25-akpm/arch/mips/lib-32/Makefile	2004-06-21 23:10:45.635281960 -0700
@@ -4,10 +4,22 @@
 
 lib-y	+= csum_partial.o memset.o watch.o 
 
-ifeq ($(CONFIG_CPU_R3000)$(CONFIG_CPU_TX39XX),y)
-  lib-y	+= r3k_dump_tlb.o
-else
-  lib-y	+= dump_tlb.o
-endif
+obj-$(CONFIG_CPU_MIPS32)	+= dump_tlb.o
+obj-$(CONFIG_CPU_MIPS64)	+= dump_tlb.o
+obj-$(CONFIG_CPU_NEVADA)	+= dump_tlb.o
+obj-$(CONFIG_CPU_R10000)	+= dump_tlb.o
+obj-$(CONFIG_CPU_R3000)		+= r3k_dump_tlb.o
+obj-$(CONFIG_CPU_R4300)		+= dump_tlb.o
+obj-$(CONFIG_CPU_R4X00)		+= dump_tlb.o
+obj-$(CONFIG_CPU_R5000)		+= dump_tlb.o
+obj-$(CONFIG_CPU_R5432)		+= dump_tlb.o
+obj-$(CONFIG_CPU_R6000)		+=
+obj-$(CONFIG_CPU_R8000)		+=
+obj-$(CONFIG_CPU_RM7000)	+= dump_tlb.o
+obj-$(CONFIG_CPU_RM9000)	+= dump_tlb.o
+obj-$(CONFIG_CPU_SB1)		+= dump_tlb.o
+obj-$(CONFIG_CPU_TX39XX)	+= r3k_dump_tlb.o
+obj-$(CONFIG_CPU_TX49XX)	+= dump_tlb.o
+obj-$(CONFIG_CPU_VR41XX)	+= dump_tlb.o
 
 EXTRA_AFLAGS := $(CFLAGS)
diff -puN arch/mips/lib-64/Makefile~mips-update arch/mips/lib-64/Makefile
--- 25/arch/mips/lib-64/Makefile~mips-update	2004-06-21 23:10:45.333327864 -0700
+++ 25-akpm/arch/mips/lib-64/Makefile	2004-06-21 23:10:45.636281808 -0700
@@ -4,10 +4,22 @@
 
 lib-y	+= csum_partial.o memset.o watch.o 
 
-ifeq ($(CONFIG_CPU_R3000)$(CONFIG_CPU_TX39XX),y)
-  lib-y	+= r3k_dump_tlb.o
-else
-  lib-y	+= dump_tlb.o
-endif
+obj-$(CONFIG_CPU_MIPS32)	+= dump_tlb.o
+obj-$(CONFIG_CPU_MIPS64)	+= dump_tlb.o
+obj-$(CONFIG_CPU_NEVADA)	+= dump_tlb.o
+obj-$(CONFIG_CPU_R10000)	+= dump_tlb.o
+obj-$(CONFIG_CPU_R3000)		+= r3k_dump_tlb.o
+obj-$(CONFIG_CPU_R4300)		+= dump_tlb.o
+obj-$(CONFIG_CPU_R4X00)		+= dump_tlb.o
+obj-$(CONFIG_CPU_R5000)		+= dump_tlb.o
+obj-$(CONFIG_CPU_R5432)		+= dump_tlb.o
+obj-$(CONFIG_CPU_R6000)		+=
+obj-$(CONFIG_CPU_R8000)		+=
+obj-$(CONFIG_CPU_RM7000)	+= dump_tlb.o
+obj-$(CONFIG_CPU_RM9000)	+= dump_tlb.o
+obj-$(CONFIG_CPU_SB1)		+= dump_tlb.o
+obj-$(CONFIG_CPU_TX39XX)	+= r3k_dump_tlb.o
+obj-$(CONFIG_CPU_TX49XX)	+= dump_tlb.o
+obj-$(CONFIG_CPU_VR41XX)	+= dump_tlb.o
 
 EXTRA_AFLAGS := $(CFLAGS)
diff -puN arch/mips/Makefile~mips-update arch/mips/Makefile
--- 25/arch/mips/Makefile~mips-update	2004-06-21 23:10:45.335327560 -0700
+++ 25-akpm/arch/mips/Makefile	2004-06-21 23:10:45.638281504 -0700
@@ -406,6 +406,13 @@ core-$(CONFIG_MOMENCO_OCELOT_C)	+= arch/
 load-$(CONFIG_MOMENCO_OCELOT_C)	+= 0x80100000
 
 #
+# PMC-Sierra Yosemite
+#
+core-$(CONFIG_PMC_YOSEMITE)	+= arch/mips/pmc-sierra/yosemite/
+cflags-$(CONFIG_PMC_YOSEMITE)	+= -Iinclude/asm-mips/mach-yosemite
+load-$(CONFIG_PMC_YOSEMITE)	+= 0x80100000
+
+#
 # Momentum Jaguar ATX
 #
 core-$(CONFIG_MOMENCO_JAGUAR_ATX)	+= arch/mips/momentum/jaguar_atx/
@@ -659,8 +666,6 @@ libs-$(CONFIG_MIPS32)	+= arch/mips/lib-3
 libs-$(CONFIG_MIPS64)	+= arch/mips/lib-64/
 
 core-y			+= arch/mips/kernel/ arch/mips/mm/ arch/mips/math-emu/
-core-$(CONFIG_MIPS32)	+= arch/mips/mm-32/
-core-$(CONFIG_MIPS64)	+= arch/mips/mm-64/
 
 ifdef CONFIG_BAGET_MIPS
 
diff -puN arch/mips/mips-boards/generic/cmdline.c~mips-update arch/mips/mips-boards/generic/cmdline.c
--- 25/arch/mips/mips-boards/generic/cmdline.c~mips-update	2004-06-21 23:10:45.337327256 -0700
+++ 25-akpm/arch/mips/mips-boards/generic/cmdline.c	2004-06-21 23:10:45.639281352 -0700
@@ -51,7 +51,9 @@ void  __init prom_init_cmdline(void)
 		*cp++ = ' ';
 		actr++;
 	}
-	if (cp != &(arcs_cmdline[0])) /* get rid of trailing space */
+	if (cp != &(arcs_cmdline[0])) {
+		/* get rid of trailing space */
 		--cp;
-	*cp = '\0';
+		*cp = '\0';
+	}
 }
diff -puN arch/mips/mips-boards/generic/printf.c~mips-update arch/mips/mips-boards/generic/printf.c
--- 25/arch/mips/mips-boards/generic/printf.c~mips-update	2004-06-21 23:10:45.339326952 -0700
+++ 25-akpm/arch/mips/mips-boards/generic/printf.c	2004-06-21 23:10:45.640281200 -0700
@@ -59,7 +59,7 @@ static inline void serial_out(int offset
 	outb(value, PORT(offset));
 }
 
-int putPromChar(char c)
+int prom_putchar(char c)
 {
 	while ((serial_in(UART_LSR) & UART_LSR_THRE) == 0)
 		;
@@ -69,7 +69,7 @@ int putPromChar(char c)
 	return 1;
 }
 
-char getPromChar(void)
+char prom_getchar(void)
 {
 	while (!(serial_in(UART_LSR) & UART_LSR_DR))
 		;
@@ -77,33 +77,3 @@ char getPromChar(void)
 	return serial_in(UART_RX);
 }
 
-static spinlock_t con_lock = SPIN_LOCK_UNLOCKED;
-
-static char buf[1024];
-
-void __init prom_printf(char *fmt, ...)
-{
-	va_list args;
-	int l;
-	char *p, *buf_end;
-	long flags;
-
-	spin_lock_irqsave(con_lock, flags);
-
-	va_start(args, fmt);
-	l = vsprintf(buf, fmt, args); /* hopefully i < sizeof(buf) */
-	va_end(args);
-
-	buf_end = buf + l;
-
-	for (p = buf; p < buf_end; p++) {
-		/* Crude cr/nl handling is better than none */
-		if (*p == '\n')
-			putPromChar('\r');
-		putPromChar(*p);
-	}
-	/* wait for output to drain */
-	while ((serial_in(UART_LSR) & UART_LSR_TEMT) == 0)
-		;
-	spin_unlock_irqrestore(con_lock, flags);
-}
diff -L arch/mips/mm-32/Makefile -puN arch/mips/mm-32/Makefile~mips-update /dev/null
--- 25/arch/mips/mm-32/Makefile
+++ /dev/null	2003-09-15 06:40:47.000000000 -0700
@@ -1,19 +0,0 @@
-#
-# Makefile for the Linux/MIPS-specific parts of the memory manager.
-#
-
-obj-$(CONFIG_CPU_TX49XX)	+= tlbex-r4k.o
-obj-$(CONFIG_CPU_R4300)		+= tlbex-r4k.o
-obj-$(CONFIG_CPU_R4X00)		+= tlbex-r4k.o
-obj-$(CONFIG_CPU_VR41XX)	+= tlbex-r4k.o
-obj-$(CONFIG_CPU_R5000)		+= tlbex-r4k.o
-obj-$(CONFIG_CPU_NEVADA)	+= tlbex-r4k.o
-obj-$(CONFIG_CPU_R5432)		+= tlbex-r4k.o
-obj-$(CONFIG_CPU_RM7000)	+= tlbex-r4k.o
-obj-$(CONFIG_CPU_RM9000)	+= tlbex-r4k.o
-obj-$(CONFIG_CPU_R10000)	+= tlbex-r4k.o
-obj-$(CONFIG_CPU_MIPS32)	+= tlbex-r4k.o
-obj-$(CONFIG_CPU_MIPS64)	+= tlbex-r4k.o
-obj-$(CONFIG_CPU_SB1)		+= tlbex-r4k.o
-
-EXTRA_AFLAGS := $(CFLAGS)
diff -L arch/mips/mm-32/tlbex-r4k.S -puN arch/mips/mm-32/tlbex-r4k.S~mips-update /dev/null
--- 25/arch/mips/mm-32/tlbex-r4k.S
+++ /dev/null	2003-09-15 06:40:47.000000000 -0700
@@ -1,524 +0,0 @@
-/*
- * TLB exception handling code for r4k.
- *
- * Copyright (C) 1994, 1995, 1996 by Ralf Baechle and Andreas Busse
- *
- * Multi-cpu abstraction and reworking:
- * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
- *
- * Carsten Langgaard, carstenl@mips.com
- * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
- */
-#include <linux/init.h>
-#include <linux/config.h>
-
-#include <asm/asm.h>
-#include <asm/offset.h>
-#include <asm/cachectl.h>
-#include <asm/fpregdef.h>
-#include <asm/mipsregs.h>
-#include <asm/page.h>
-#include <asm/pgtable-bits.h>
-#include <asm/regdef.h>
-#include <asm/stackframe.h>
-#include <asm/war.h>
-
-#define TLB_OPTIMIZE /* If you are paranoid, disable this. */
-
-#ifdef CONFIG_64BIT_PHYS_ADDR
-#define PTE_L		ld
-#define PTE_S		sd
-#define PTE_SRL		dsrl
-#define P_MTC0		dmtc0
-#define PTE_SIZE	8
-#define PTEP_INDX_MSK	0xff0
-#define PTE_INDX_MSK	0xff8
-#define PTE_INDX_SHIFT	9
-#else
-#define PTE_L		lw
-#define PTE_S		sw
-#define PTE_SRL		srl
-#define P_MTC0		mtc0
-#define PTE_SIZE	4
-#define PTEP_INDX_MSK	0xff8
-#define PTE_INDX_MSK	0xffc
-#define PTE_INDX_SHIFT	10
-#endif
-
-/*
- * ABUSE of CPP macros 101.
- *
- * After this macro runs, the pte faulted on is
- * in register PTE, a ptr into the table in which
- * the pte belongs is in PTR.
- */
-
-#ifdef CONFIG_SMP
-#define GET_PGD(scratch, ptr)        \
-	mfc0    ptr, CP0_CONTEXT;    \
-	la      scratch, pgd_current;\
-	srl     ptr, 23;             \
-	sll     ptr, 2;              \
-	addu    ptr, scratch, ptr;   \
-	lw      ptr, (ptr);
-#else
-#define GET_PGD(scratch, ptr)    \
-	lw	ptr, pgd_current;
-#endif
-
-#define LOAD_PTE(pte, ptr) \
-	GET_PGD(pte, ptr)          \
-	mfc0	pte, CP0_BADVADDR; \
-	srl	pte, pte, _PGDIR_SHIFT; \
-	sll	pte, pte, 2; \
-	addu	ptr, ptr, pte; \
-	mfc0	pte, CP0_BADVADDR; \
-	lw	ptr, (ptr); \
-	srl	pte, pte, PTE_INDX_SHIFT; \
-	and	pte, pte, PTE_INDX_MSK; \
-	addu	ptr, ptr, pte; \
-	PTE_L	pte, (ptr);
-
-	/* This places the even/odd pte pair in the page
-	 * table at PTR into ENTRYLO0 and ENTRYLO1 using
-	 * TMP as a scratch register.
-	 */
-#define PTE_RELOAD(ptr, tmp) \
-	ori	ptr, ptr, PTE_SIZE; \
-	xori	ptr, ptr, PTE_SIZE; \
-	PTE_L	tmp, PTE_SIZE(ptr); \
-	PTE_L	ptr, 0(ptr); \
-	PTE_SRL	tmp, tmp, 6; \
-	P_MTC0	tmp, CP0_ENTRYLO1; \
-	PTE_SRL	ptr, ptr, 6; \
-	P_MTC0	ptr, CP0_ENTRYLO0;
-
-#define DO_FAULT(write) \
-	.set	noat; \
-	SAVE_ALL; \
-	mfc0	a2, CP0_BADVADDR; \
-	KMODE; \
-	.set	at; \
-	move	a0, sp; \
-	jal	do_page_fault; \
-	 li	a1, write; \
-	j	ret_from_exception; \
-	 nop; \
-	.set	noat;
-
-	/* Check is PTE is present, if not then jump to LABEL.
-	 * PTR points to the page table where this PTE is located,
-	 * when the macro is done executing PTE will be restored
-	 * with it's original value.
-	 */
-#define PTE_PRESENT(pte, ptr, label) \
-	andi	pte, pte, (_PAGE_PRESENT | _PAGE_READ); \
-	xori	pte, pte, (_PAGE_PRESENT | _PAGE_READ); \
-	bnez	pte, label; \
-	 PTE_L	pte, (ptr);
-
-	/* Make PTE valid, store result in PTR. */
-#define PTE_MAKEVALID(pte, ptr) \
-	ori	pte, pte, (_PAGE_VALID | _PAGE_ACCESSED); \
-	PTE_S	pte, (ptr);
-
-	/* Check if PTE can be written to, if not branch to LABEL.
-	 * Regardless restore PTE with value from PTR when done.
-	 */
-#define PTE_WRITABLE(pte, ptr, label) \
-	andi	pte, pte, (_PAGE_PRESENT | _PAGE_WRITE); \
-	xori	pte, pte, (_PAGE_PRESENT | _PAGE_WRITE); \
-	bnez	pte, label; \
-	 PTE_L	pte, (ptr);
-
-	/* Make PTE writable, update software status bits as well,
-	 * then store at PTR.
-	 */
-#define PTE_MAKEWRITE(pte, ptr) \
-	ori	pte, pte, (_PAGE_ACCESSED | _PAGE_MODIFIED | \
-			   _PAGE_VALID | _PAGE_DIRTY); \
-	PTE_S	pte, (ptr);
-
-	__INIT
-
-#ifdef CONFIG_64BIT_PHYS_ADDR
-#define GET_PTE_OFF(reg)
-#elif CONFIG_CPU_VR41XX
-#define GET_PTE_OFF(reg)	srl	reg, reg, 3
-#else
-#define GET_PTE_OFF(reg)	srl	reg, reg, 1
-#endif
-
-/*
- * These handlers much be written in a relocatable manner
- * because based upon the cpu type an arbitrary one of the
- * following pieces of code will be copied to the KSEG0
- * vector location.
- */
-	/* TLB refill, EXL == 0, R4xx0, non-R4600 version */
-	.set	noreorder
-	.set	noat
-	LEAF(except_vec0_r4000)
-	.set	mips3
-	GET_PGD(k0, k1)				# get pgd pointer
-	mfc0	k0, CP0_BADVADDR		# Get faulting address
-	srl	k0, k0, _PGDIR_SHIFT		# get pgd only bits
-
-	sll	k0, k0, 2
-	addu	k1, k1, k0			# add in pgd offset
-	mfc0	k0, CP0_CONTEXT			# get context reg
-	lw	k1, (k1)
-	GET_PTE_OFF(k0)				# get pte offset
-	and	k0, k0, PTEP_INDX_MSK
-	addu	k1, k1, k0			# add in offset
-	PTE_L	k0, 0(k1)			# get even pte
-	PTE_L	k1, PTE_SIZE(k1)		# get odd pte
-	PTE_SRL	k0, k0, 6			# convert to entrylo0
-	P_MTC0	k0, CP0_ENTRYLO0		# load it
-	PTE_SRL	k1, k1, 6			# convert to entrylo1
-	P_MTC0	k1, CP0_ENTRYLO1		# load it
-	mtc0_tlbw_hazard
-	tlbwr					# write random tlb entry
-	tlbw_eret_hazard
-	eret					# return from trap
-	END(except_vec0_r4000)
-
-	/* TLB refill, EXL == 0, R4600 version */
-	LEAF(except_vec0_r4600)
-	.set	mips3
-	GET_PGD(k0, k1)				# get pgd pointer
-	mfc0	k0, CP0_BADVADDR
-	srl	k0, k0, _PGDIR_SHIFT
-	sll	k0, k0, 2			# log2(sizeof(pgd_t)
-	addu	k1, k1, k0
-	mfc0	k0, CP0_CONTEXT
-	lw	k1, (k1)
-	GET_PTE_OFF(k0)				# get pte offset
-	and	k0, k0, PTEP_INDX_MSK
-	addu	k1, k1, k0
-	PTE_L	k0, 0(k1)
-	PTE_L	k1, PTE_SIZE(k1)
-	PTE_SRL	k0, k0, 6
-	P_MTC0	k0, CP0_ENTRYLO0
-	PTE_SRL	k1, k1, 6
-	P_MTC0	k1, CP0_ENTRYLO1
-	nop
-	tlbwr
-	nop
-	eret
-	END(except_vec0_r4600)
-
-	/* TLB refill, EXL == 0, R52x0 "Nevada" version */
-        /*
-         * This version has a bug workaround for the Nevada.  It seems
-         * as if under certain circumstances the move from cp0_context
-         * might produce a bogus result when the mfc0 instruction and
-         * it's consumer are in a different cacheline or a load instruction,
-         * probably any memory reference, is between them.  This is
-         * potencially slower than the R4000 version, so we use this
-         * special version.
-         */
-	.set	noreorder
-	.set	noat
-	LEAF(except_vec0_nevada)
-	.set	mips3
-	mfc0	k0, CP0_BADVADDR		# Get faulting address
-	srl	k0, k0, _PGDIR_SHIFT		# get pgd only bits
-	lw	k1, pgd_current			# get pgd pointer
-	sll	k0, k0, 2			# log2(sizeof(pgd_t)
-	addu	k1, k1, k0			# add in pgd offset
-	lw	k1, (k1)
-	mfc0	k0, CP0_CONTEXT			# get context reg
-	GET_PTE_OFF(k0)				# get pte offset
-	and	k0, k0, PTEP_INDX_MSK
-	addu	k1, k1, k0			# add in offset
-	PTE_L	k0, 0(k1)			# get even pte
-	PTE_L	k1, PTE_SIZE(k1)		# get odd pte
-	PTE_SRL	k0, k0, 6			# convert to entrylo0
-	P_MTC0	k0, CP0_ENTRYLO0		# load it
-	PTE_SRL	k1, k1, 6			# convert to entrylo1
-	P_MTC0	k1, CP0_ENTRYLO1		# load it
-	nop					# QED specified nops
-	nop
-	tlbwr					# write random tlb entry
-	nop					# traditional nop
-	eret					# return from trap
-	END(except_vec0_nevada)
-
-	/* TLB refill, EXL == 0, SB1 with M3 errata handling version */
-	LEAF(except_vec0_sb1)
-#if BCM1250_M3_WAR
-	mfc0	k0, CP0_BADVADDR
-	mfc0	k1, CP0_ENTRYHI
-	xor	k0, k1
-	srl	k0, k0, PAGE_SHIFT+1
-	bnez	k0, 1f
-#endif
-	GET_PGD(k0, k1)				# get pgd pointer
-	mfc0	k0, CP0_BADVADDR		# Get faulting address
-	srl	k0, k0, _PGDIR_SHIFT		# get pgd only bits
-	sll	k0, k0, 2
-	addu	k1, k1, k0			# add in pgd offset
-	mfc0	k0, CP0_CONTEXT			# get context reg
-	lw	k1, (k1)
-	GET_PTE_OFF(k0)				# get pte offset
-	and	k0, k0, PTEP_INDX_MSK
-	addu	k1, k1, k0			# add in offset
-	PTE_L	k0, 0(k1)			# get even pte
-	PTE_L	k1, PTE_SIZE(k1)		# get odd pte
-	PTE_SRL	k0, k0, 6			# convert to entrylo0
-	P_MTC0	k0, CP0_ENTRYLO0		# load it
-	PTE_SRL	k1, k1, 6			# convert to entrylo1
-	P_MTC0	k1, CP0_ENTRYLO1		# load it
-	tlbwr					# write random tlb entry
-1:	eret					# return from trap
-	END(except_vec0_sb1)
-
-	/* TLB refill, EXL == 0, R4[40]00/R5000 badvaddr hwbug version */
-	LEAF(except_vec0_r45k_bvahwbug)
-	.set	mips3
-	GET_PGD(k0, k1)				# get pgd pointer
-	mfc0	k0, CP0_BADVADDR
-	srl	k0, k0, _PGDIR_SHIFT
-	sll	k0, k0, 2			# log2(sizeof(pgd_t)
-	addu	k1, k1, k0
-	mfc0	k0, CP0_CONTEXT
-	lw	k1, (k1)
-#ifndef CONFIG_64BIT_PHYS_ADDR
-	srl	k0, k0, 1
-#endif
-	and	k0, k0, PTEP_INDX_MSK
-	addu	k1, k1, k0
-	PTE_L	k0, 0(k1)
-	PTE_L	k1, PTE_SIZE(k1)
-	nop				/* XXX */
-	tlbp
-	PTE_SRL	k0, k0, 6
-	P_MTC0	k0, CP0_ENTRYLO0
-	PTE_SRL	k1, k1, 6
-	mfc0	k0, CP0_INDEX
-	P_MTC0	k1, CP0_ENTRYLO1
-	bltzl	k0, 1f
-	tlbwr
-1:
-	nop
-	eret
-	END(except_vec0_r45k_bvahwbug)
-
-#ifdef CONFIG_SMP
-	/* TLB refill, EXL == 0, R4000 MP badvaddr hwbug version */
-	LEAF(except_vec0_r4k_mphwbug)
-	.set	mips3
-	GET_PGD(k0, k1)				# get pgd pointer
-	mfc0	k0, CP0_BADVADDR
-	srl	k0, k0, _PGDIR_SHIFT
-	sll	k0, k0, 2			# log2(sizeof(pgd_t)
-	addu	k1, k1, k0
-	mfc0	k0, CP0_CONTEXT
-	lw	k1, (k1)
-#ifndef CONFIG_64BIT_PHYS_ADDR
-	srl	k0, k0, 1
-#endif
-	and	k0, k0, PTEP_INDX_MSK
-	addu	k1, k1, k0
-	PTE_L	k0, 0(k1)
-	PTE_L	k1, PTE_SIZE(k1)
-	nop				/* XXX */
-	tlbp
-	PTE_SRL	k0, k0, 6
-	P_MTC0	k0, CP0_ENTRYLO0
-	PTE_SRL	k1, k1, 6
-	mfc0	k0, CP0_INDEX
-	P_MTC0	k1, CP0_ENTRYLO1
-	bltzl	k0, 1f
-	tlbwr
-1:
-	nop
-	eret
-	END(except_vec0_r4k_mphwbug)
-#endif
-
-	/* TLB refill, EXL == 0, R4000 UP 250MHZ entrylo[01] hwbug version */
-	LEAF(except_vec0_r4k_250MHZhwbug)
-	.set	mips3
-	GET_PGD(k0, k1)				# get pgd pointer
-	mfc0	k0, CP0_BADVADDR
-	srl	k0, k0, _PGDIR_SHIFT
-	sll	k0, k0, 2			# log2(sizeof(pgd_t)
-	addu	k1, k1, k0
-	mfc0	k0, CP0_CONTEXT
-	lw	k1, (k1)
-#ifndef CONFIG_64BIT_PHYS_ADDR
-	srl	k0, k0, 1
-#endif
-	and	k0, k0, PTEP_INDX_MSK
-	addu	k1, k1, k0
-	PTE_L	k0, 0(k1)
-	PTE_L	k1, PTE_SIZE(k1)
-	PTE_SRL	k0, k0, 6
-	P_MTC0	zero, CP0_ENTRYLO0
-	P_MTC0	k0, CP0_ENTRYLO0
-	PTE_SRL	k1, k1, 6
-	P_MTC0	zero, CP0_ENTRYLO1
-	P_MTC0	k1, CP0_ENTRYLO1
-	b	1f
-	tlbwr
-1:
-	nop
-	eret
-	END(except_vec0_r4k_250MHZhwbug)
-
-#ifdef CONFIG_SMP
-	/* TLB refill, EXL == 0, R4000 MP 250MHZ entrylo[01]+badvaddr bug version */
-	LEAF(except_vec0_r4k_MP250MHZhwbug)
-	.set	mips3
-	GET_PGD(k0, k1)				# get pgd pointer
-	mfc0	k0, CP0_BADVADDR
-	srl	k0, k0, _PGDIR_SHIFT
-	sll	k0, k0, 2			# log2(sizeof(pgd_t)
-	addu	k1, k1, k0
-	mfc0	k0, CP0_CONTEXT
-	lw	k1, (k1)
-#ifndef CONFIG_64BIT_PHYS_ADDR
-	srl	k0, k0, 1
-#endif
-	and	k0, k0, PTEP_INDX_MSK
-	addu	k1, k1, k0
-	PTE_L	k0, 0(k1)
-	PTE_L	k1, PTE_SIZE(k1)
-	nop				/* XXX */
-	tlbp
-	PTE_SRL	k0, k0, 6
-	P_MTC0  zero, CP0_ENTRYLO0
-	P_MTC0  k0, CP0_ENTRYLO0
-	mfc0    k0, CP0_INDEX
-	PTE_SRL	k1, k1, 6
-	P_MTC0	zero, CP0_ENTRYLO1
-	P_MTC0	k1, CP0_ENTRYLO1
-	bltzl	k0, 1f
-	tlbwr
-1:
-	nop
-	eret
-	END(except_vec0_r4k_MP250MHZhwbug)
-#endif
-
-	__FINIT
-
-	.set	noreorder
-
-/*
- * From the IDT errata for the QED RM5230 (Nevada), processor revision 1.0:
- * 2. A timing hazard exists for the TLBP instruction.
- *
- *      stalling_instruction
- *      TLBP
- *
- * The JTLB is being read for the TLBP throughout the stall generated by the
- * previous instruction. This is not really correct as the stalling instruction
- * can modify the address used to access the JTLB.  The failure symptom is that
- * the TLBP instruction will use an address created for the stalling instruction
- * and not the address held in C0_ENHI and thus report the wrong results.
- *
- * The software work-around is to not allow the instruction preceding the TLBP
- * to stall - make it an NOP or some other instruction guaranteed not to stall.
- *
- * Errata 2 will not be fixed.  This errata is also on the R5000.
- *
- * As if we MIPS hackers wouldn't know how to nop pipelines happy ...
- */
-#define R5K_HAZARD nop
-
-	/*
-	 * Note for many R4k variants tlb probes cannot be executed out
-	 * of the instruction cache else you get bogus results.
-	 */
-	.align	5
-	NESTED(handle_tlbl, PT_SIZE, sp)
-	.set	noat
-#if BCM1250_M3_WAR
-	mfc0	k0, CP0_BADVADDR
-	mfc0	k1, CP0_ENTRYHI
-	xor	k0, k1
-	srl	k0, k0, PAGE_SHIFT+1
-	beqz	k0, 1f
-	 nop
-	.set	mips3
-	eret
-	.set	mips0
-1:
-#endif
-invalid_tlbl:
-#ifdef TLB_OPTIMIZE
-	.set	mips3
-	/* Test present bit in entry. */
-	LOAD_PTE(k0, k1)
-	R5K_HAZARD
-	tlbp
-	PTE_PRESENT(k0, k1, nopage_tlbl)
-	PTE_MAKEVALID(k0, k1)
-	PTE_RELOAD(k1, k0)
-	mtc0_tlbw_hazard
-	tlbwi
-	tlbw_eret_hazard
-	.set	mips3
-	eret
-	.set	mips0
-#endif
-
-nopage_tlbl:
-	DO_FAULT(0)
-	END(handle_tlbl)
-
-	.align	5
-	NESTED(handle_tlbs, PT_SIZE, sp)
-	.set	noat
-#ifdef TLB_OPTIMIZE
-	.set	mips3
-        li      k0,0
-	LOAD_PTE(k0, k1)
-	R5K_HAZARD
-	tlbp				# find faulting entry
-	PTE_WRITABLE(k0, k1, nopage_tlbs)
-	PTE_MAKEWRITE(k0, k1)
-	PTE_RELOAD(k1, k0)
-	mtc0_tlbw_hazard
-	tlbwi
-	tlbw_eret_hazard
-	.set	mips3
-	eret
-	.set	mips0
-#endif
-
-nopage_tlbs:
-	DO_FAULT(1)
-	END(handle_tlbs)
-
-	.align	5
-	NESTED(handle_mod, PT_SIZE, sp)
-	.set	noat
-#ifdef TLB_OPTIMIZE
-	.set	mips3
-	LOAD_PTE(k0, k1)
-	R5K_HAZARD
-	tlbp					# find faulting entry
-	andi	k0, k0, _PAGE_WRITE
-	beqz	k0, nowrite_mod
-	 PTE_L	k0, (k1)
-
-	/* Present and writable bits set, set accessed and dirty bits. */
-	PTE_MAKEWRITE(k0, k1)
-
-	/* Now reload the entry into the tlb. */
-	PTE_RELOAD(k1, k0)
-	mtc0_tlbw_hazard
-	tlbwi
-	tlbw_eret_hazard
-	.set	mips3
-	eret
-	.set	mips0
-#endif
-
-nowrite_mod:
-	DO_FAULT(1)
-	END(handle_mod)
diff -L arch/mips/mm-64/Makefile -puN arch/mips/mm-64/Makefile~mips-update /dev/null
--- 25/arch/mips/mm-64/Makefile
+++ /dev/null	2003-09-15 06:40:47.000000000 -0700
@@ -1,25 +0,0 @@
-#
-# Makefile for the Linux/MIPS-specific parts of the memory manager.
-#
-
-obj-y				:= tlbex-r4k.o
-
-obj-$(CONFIG_CPU_R4300)		+= tlb-glue-r4k.o
-obj-$(CONFIG_CPU_R4X00)		+= tlb-glue-r4k.o
-obj-$(CONFIG_CPU_R5000)		+= tlb-glue-r4k.o
-obj-$(CONFIG_CPU_NEVADA)	+= tlb-glue-r4k.o
-obj-$(CONFIG_CPU_R5432)		+= tlb-glue-r4k.o
-obj-$(CONFIG_CPU_RM7000)	+= tlb-glue-r4k.o
-obj-$(CONFIG_CPU_RM9000)	+= tlb-glue-r4k.o
-obj-$(CONFIG_CPU_R10000)	+= tlb-glue-r4k.o
-obj-$(CONFIG_CPU_SB1)		+= tlb-glue-sb1.o
-obj-$(CONFIG_CPU_MIPS64)	+= tlb-glue-r4k.o
-
-#
-# Debug TLB exception handler, currently unused
-#
-#obj-y				+=  tlb-dbg-r4k.o
-
-AFLAGS_tlb-glue-r4k.o := -P
-
-EXTRA_AFLAGS := $(CFLAGS)
diff -L arch/mips/mm-64/tlb-dbg-r4k.c -puN arch/mips/mm-64/tlb-dbg-r4k.c~mips-update /dev/null
--- 25/arch/mips/mm-64/tlb-dbg-r4k.c
+++ /dev/null	2003-09-15 06:40:47.000000000 -0700
@@ -1,71 +0,0 @@
-/*
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * Copyright (C) 1999 Ralf Baechle
- * Copyright (C) 1999 Silicon Graphics, Inc.
- *
- * TLB debugging routines.  These perform horribly slow but can easily be
- * modified for debugging purposes.
- */
-#include <linux/linkage.h>
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/mm.h>
-#include <asm/page.h>
-#include <asm/pgtable.h>
-#include <asm/ptrace.h>
-#include <asm/system.h>
-
-asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long write,
-                              unsigned long address);
-
-asmlinkage void tlb_refill_debug(struct pt_regs regs)
-{
-	show_regs(&regs);
-	panic("%s called.  This Does Not Happen (TM).", __FUNCTION__);
-}
-
-asmlinkage void xtlb_refill_debug(struct pt_regs *regs)
-{
-	unsigned long addr;
-	pgd_t *pgd;
-	pmd_t *pmd;
-	pte_t *pte;
-
-	addr = regs->cp0_badvaddr & ~((PAGE_SIZE << 1) - 1);
-	pgd = pgd_offset(current->active_mm, addr);
-	pmd = pmd_offset(pgd, addr);
-	pte = pte_offset(pmd, addr);
-
-	write_c0_entrylo0(pte_val(pte[0]) >> 6);
-	write_c0_entrylo1(pte_val(pte[1]) >> 6);
-	__asm__ __volatile__("nop;nop;nop");
-
-	tlb_write_random();
-}
-
-asmlinkage void xtlb_mod_debug(struct pt_regs *regs)
-{
-	unsigned long addr;
-
-	addr = regs->cp0_badvaddr;
-	do_page_fault(regs, 1, addr);
-}
-
-asmlinkage void xtlb_tlbl_debug(struct pt_regs *regs)
-{
-	unsigned long addr;
-
-	addr = regs->cp0_badvaddr;
-	do_page_fault(regs, 0, addr);
-}
-
-asmlinkage void xtlb_tlbs_debug(struct pt_regs *regs)
-{
-	unsigned long addr;
-
-	addr = regs->cp0_badvaddr;
-	do_page_fault(regs, 1, addr);
-}
diff -L arch/mips/mm-64/tlbex-r4k.S -puN arch/mips/mm-64/tlbex-r4k.S~mips-update /dev/null
--- 25/arch/mips/mm-64/tlbex-r4k.S
+++ /dev/null	2003-09-15 06:40:47.000000000 -0700
@@ -1,203 +0,0 @@
-/*
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * Copyright (C) 2000 Silicon Graphics, Inc.
- * Written by Ulf Carlsson (ulfc@engr.sgi.com)
- * Copyright (C) 2002  Maciej W. Rozycki
- */
-#include <linux/config.h>
-#include <linux/init.h>
-#include <linux/threads.h>
-
-#include <asm/asm.h>
-#include <asm/hazards.h>
-#include <asm/regdef.h>
-#include <asm/mipsregs.h>
-#include <asm/stackframe.h>
-#include <asm/war.h>
-
-#define _VMALLOC_START	0xc000000000000000
-
-	/*
-	 * After this macro runs we have a pointer to the pte of the address
-	 * that caused the fault in PTR.
-	 */
-	.macro	LOAD_PTE2, ptr, tmp, kaddr
-#ifdef CONFIG_SMP
-	dmfc0	\ptr, CP0_CONTEXT
-	dmfc0	\tmp, CP0_BADVADDR
-	dsra	\ptr, 23			# get pgd_current[cpu]
-#else
-	dmfc0	\tmp, CP0_BADVADDR
-	dla	\ptr, pgd_current
-#endif
-	bltz	\tmp, \kaddr
-	 ld	\ptr, (\ptr)
-	dsrl	\tmp, (_PGDIR_SHIFT-3)		# get pgd offset in bytes
-	andi	\tmp, ((_PTRS_PER_PGD - 1)<<3)
-	daddu	\ptr, \tmp			# add in pgd offset
-	dmfc0	\tmp, CP0_BADVADDR
-	ld	\ptr, (\ptr)			# get pmd pointer
-	dsrl	\tmp, (_PMD_SHIFT-3)		# get pmd offset in bytes
-	andi	\tmp, ((_PTRS_PER_PMD - 1)<<3)
-	daddu	\ptr, \tmp			# add in pmd offset
-	dmfc0	\tmp, CP0_XCONTEXT
-	ld	\ptr, (\ptr)			# get pte pointer
-	andi	\tmp, 0xff0			# get pte offset
-	daddu	\ptr, \tmp
-	.endm
-
-
-	/*
-	 * Ditto for the kernel table.
-	 */
-	.macro	LOAD_KPTE2, ptr, tmp, not_vmalloc
-	/*
-	 * First, determine that the address is in/above vmalloc range.
-	 */
-	dmfc0	\tmp, CP0_BADVADDR
-	dli	\ptr, _VMALLOC_START
-
-	/*
-	 * Now find offset into kptbl.
-	 */
-	dsubu	\tmp, \tmp, \ptr
-	dla	\ptr, kptbl
-	dsrl	\tmp, (_PAGE_SHIFT+1)		# get vpn2
-	dsll	\tmp, 4				# byte offset of pte
-	daddu	\ptr, \ptr, \tmp
-
-	/*
-	 * Determine that fault address is within vmalloc range.
-	 */
-	dla	\tmp, ekptbl
-	slt	\tmp, \ptr, \tmp
-	beqz	\tmp, \not_vmalloc		# not vmalloc
-	 nop
-	.endm
-
-
-	/*
-	 * This places the even/odd pte pair in the page table at the pte
-	 * entry pointed to by PTE into ENTRYLO0 and ENTRYLO1.
-	 */
-	.macro	PTE_RELOAD, pte0, pte1
-	dsrl	\pte0, 6			# convert to entrylo0
-	dmtc0	\pte0, CP0_ENTRYLO0		# load it
-	dsrl	\pte1, 6			# convert to entrylo1
-	dmtc0	\pte1, CP0_ENTRYLO1		# load it
-	.endm
-
-
-	.text
-	.set	noreorder
-	.set	mips3
-
-	__INIT
-
-	/*
-	 * TLB refill handlers for the R4000 and SB1.
-	 * Attention:  We may only use 32 instructions / 128 bytes.
-	 */
-	.align  5
-LEAF(except_vec1_r4k)
-	.set    noat
-	dla     k0, handle_vec1_r4k
-	jr      k0
-	 nop
-END(except_vec1_r4k)
-
-LEAF(except_vec1_sb1)
-#if BCM1250_M3_WAR
-	dmfc0	k0, CP0_BADVADDR
-	dmfc0	k1, CP0_ENTRYHI
-	xor	k0, k1
-	dsrl	k0, k0, _PAGE_SHIFT+1
-	bnez	k0, 1f
-#endif
-	.set    noat
-	dla     k0, handle_vec1_r4k
-	jr      k0
-	 nop
-
-1:	eret
-	nop
-END(except_vec1_sb1)
-
-	__FINIT
-
-	.align  5
-LEAF(handle_vec1_r4k)
-	.set    noat
-	LOAD_PTE2 k1 k0 9f
-	ld	k0, 0(k1)			# get even pte
-	ld	k1, 8(k1)			# get odd pte
-	PTE_RELOAD k0 k1
-	mtc0_tlbw_hazard
-	tlbwr
-	tlbw_eret_hazard
-	eret
-
-9:						# handle the vmalloc range
-	LOAD_KPTE2 k1 k0 invalid_vmalloc_address
-	ld	k0, 0(k1)			# get even pte
-	ld	k1, 8(k1)			# get odd pte
-	PTE_RELOAD k0 k1
-	mtc0_tlbw_hazard
-	 tlbwr
-	tlbw_eret_hazard
-	eret
-END(handle_vec1_r4k)
-
-
-	__INIT
-
-	/*
-	 * TLB refill handler for the R10000.
-	 * Attention:  We may only use 32 instructions / 128 bytes.
-	 */
-	.align	5
-LEAF(except_vec1_r10k)
-	.set    noat
-	dla     k0, handle_vec1_r10k
-	jr      k0
-	 nop
-END(except_vec1_r10k)
-
-	__FINIT
-
-	.align	5
-LEAF(handle_vec1_r10k)
-	.set	noat
-	LOAD_PTE2 k1 k0 9f
-	ld	k0, 0(k1)			# get even pte
-	ld	k1, 8(k1)			# get odd pte
-	PTE_RELOAD k0 k1
-	nop
-	tlbwr
-	eret
-
-9:						# handle the vmalloc range
-	LOAD_KPTE2 k1 k0 invalid_vmalloc_address
-	ld	k0, 0(k1)			# get even pte
-	ld	k1, 8(k1)			# get odd pte
-	PTE_RELOAD k0 k1
-	nop
-	tlbwr
-	eret
-END(handle_vec1_r10k)
-
-
-	.align	5
-LEAF(invalid_vmalloc_address)
-	.set	noat
-	SAVE_ALL
-	CLI
-	dmfc0	t0, CP0_BADVADDR
-	sd	t0, PT_BVADDR(sp)
-	move	a0, sp
-	jal	show_regs
-	PANIC("Invalid kernel address")
-END(invalid_vmalloc_address)
diff -L arch/mips/mm-64/tlb-glue-r4k.S -puN arch/mips/mm-64/tlb-glue-r4k.S~mips-update /dev/null
--- 25/arch/mips/mm-64/tlb-glue-r4k.S
+++ /dev/null	2003-09-15 06:40:47.000000000 -0700
@@ -1,41 +0,0 @@
-/*
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * Copyright (C) 1999 Ralf Baechle
- * Copyright (C) 1999 Silicon Graphics, Inc.
- */
-#include <linux/init.h>
-#include <asm/mipsregs.h>
-#include <asm/regdef.h>
-#include <asm/stackframe.h>
-
-	.macro	__BUILD_cli
-	CLI
-	.endm
-
-	.macro	__BUILD_sti
-	STI
-	.endm
-
-	.macro	__BUILD_kmode
-	KMODE
-	.endm
-
-	.macro	tlb_handler name interruptible writebit
-	NESTED(__\name, PT_SIZE, sp)
-	SAVE_ALL
-	dmfc0	a2, CP0_BADVADDR
-	__BUILD_\interruptible
-	li	a1, \writebit
-	sd	a2, PT_BVADDR(sp)
-	move	a0, sp
-	jal	do_page_fault
-	j	ret_from_exception
-	END(__\name)
-	.endm
-
-	tlb_handler	xtlb_mod kmode 1
-	tlb_handler	xtlb_tlbl kmode 0
-	tlb_handler	xtlb_tlbs kmode 1
diff -L arch/mips/mm-64/tlb-glue-sb1.S -puN arch/mips/mm-64/tlb-glue-sb1.S~mips-update /dev/null
--- 25/arch/mips/mm-64/tlb-glue-sb1.S
+++ /dev/null	2003-09-15 06:40:47.000000000 -0700
@@ -1,66 +0,0 @@
-/*
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * Copyright (C) 1999 Ralf Baechle
- * Copyright (C) 1999 Silicon Graphics, Inc.
- */
-#include <linux/init.h>
-#include <asm/mipsregs.h>
-#include <asm/page.h>
-#include <asm/regdef.h>
-#include <asm/stackframe.h>
-#include <asm/war.h>
-
-	.macro	__BUILD_cli
-	CLI
-	.endm
-
-	.macro	__BUILD_sti
-	STI
-	.endm
-
-	.macro	__BUILD_kmode
-	KMODE
-	.endm
-
-	.macro	tlb_handler name interruptible writebit
-	NESTED(__\name, PT_SIZE, sp)
-	SAVE_ALL
-	dmfc0	a2, CP0_BADVADDR
-	__BUILD_\interruptible
-	li	a1, \writebit
-	sd	a2, PT_BVADDR(sp)
-	move	a0, sp
-	jal	do_page_fault
-	j	ret_from_exception
-	END(__\name)
-	.endm
-
-	.macro	tlb_handler_m3 name interruptible writebit
-	NESTED(__\name, PT_SIZE, sp)
-	dmfc0	k0, CP0_BADVADDR
-	dmfc0	k1, CP0_ENTRYHI
-	xor	k0, k1
-	dsrl	k0, k0, PAGE_SHIFT + 1
-	bnez	k0, 1f
-	SAVE_ALL
-	dmfc0	a2, CP0_BADVADDR
-	__BUILD_\interruptible
-	li	a1, \writebit
-	sd	a2, PT_BVADDR(sp)
-	move	a0, sp
-	jal	do_page_fault
-1:
-	j	ret_from_exception
-	END(__\name)
-	.endm
-
-	tlb_handler	xtlb_mod kmode 1
-#if BCM1250_M3_WAR
-	tlb_handler_m3	xtlb_tlbl kmode 0
-#else
-	tlb_handler	xtlb_tlbl kmode 0
-#endif
-	tlb_handler	xtlb_tlbs kmode 1
diff -puN arch/mips/mm/Makefile~mips-update arch/mips/mm/Makefile
--- 25/arch/mips/mm/Makefile~mips-update	2004-06-21 23:10:45.354324672 -0700
+++ 25-akpm/arch/mips/mm/Makefile	2004-06-21 23:10:45.646280288 -0700
@@ -12,19 +12,54 @@ obj-$(CONFIG_CPU_MIPS32)	+= c-r4k.o cex-
 obj-$(CONFIG_CPU_MIPS64)	+= c-r4k.o cex-gen.o pg-r4k.o tlb-r4k.o
 obj-$(CONFIG_CPU_NEVADA)	+= c-r4k.o cex-gen.o pg-r4k.o tlb-r4k.o
 obj-$(CONFIG_CPU_R10000)	+= c-r4k.o cex-gen.o pg-r4k.o tlb-andes.o
-obj-$(CONFIG_CPU_R3000)		+= c-r3k.o tlb-r3k.o pg-r4k.o tlbex-r3k.o
+obj-$(CONFIG_CPU_R3000)		+= c-r3k.o tlb-r3k.o pg-r4k.o
 obj-$(CONFIG_CPU_R4300)		+= c-r4k.o cex-gen.o pg-r4k.o tlb-r4k.o
 obj-$(CONFIG_CPU_R4X00)		+= c-r4k.o cex-gen.o pg-r4k.o tlb-r4k.o
 obj-$(CONFIG_CPU_R5000)		+= c-r4k.o cex-gen.o pg-r4k.o tlb-r4k.o
 obj-$(CONFIG_CPU_R5432)		+= c-r4k.o cex-gen.o pg-r4k.o tlb-r4k.o
+obj-$(CONFIG_CPU_R8000)		+= c-r4k.o cex-gen.o pg-r4k.o tlb-r8k.o
 obj-$(CONFIG_CPU_RM7000)	+= c-r4k.o cex-gen.o pg-r4k.o tlb-r4k.o
 obj-$(CONFIG_CPU_RM9000)	+= c-r4k.o cex-gen.o pg-r4k.o tlb-r4k.o
 obj-$(CONFIG_CPU_SB1)		+= c-sb1.o cerr-sb1.o cex-sb1.o pg-sb1.o \
 				   tlb-sb1.o
-obj-$(CONFIG_CPU_TX39XX)	+= c-tx39.o pg-r4k.o tlb-r3k.o tlbex-r3k.o
+obj-$(CONFIG_CPU_TX39XX)	+= c-tx39.o pg-r4k.o tlb-r3k.o
 obj-$(CONFIG_CPU_TX49XX)	+= c-r4k.o cex-gen.o pg-r4k.o tlb-r4k.o
 obj-$(CONFIG_CPU_VR41XX)	+= c-r4k.o cex-gen.o pg-r4k.o tlb-r4k.o
 
+#
+# TLB exception handling code differs between 32-bit and 64-bit kernels.
+#
+ifdef CONFIG_MIPS32
+obj-$(CONFIG_CPU_R3000)		+= tlbex32-r3k.o
+obj-$(CONFIG_CPU_TX49XX)	+= tlbex32-r4k.o
+obj-$(CONFIG_CPU_R4300)		+= tlbex32-r4k.o
+obj-$(CONFIG_CPU_R4X00)		+= tlbex32-r4k.o
+obj-$(CONFIG_CPU_VR41XX)	+= tlbex32-r4k.o
+obj-$(CONFIG_CPU_R5000)		+= tlbex32-r4k.o
+obj-$(CONFIG_CPU_NEVADA)	+= tlbex32-r4k.o
+obj-$(CONFIG_CPU_R5432)		+= tlbex32-r4k.o
+obj-$(CONFIG_CPU_RM7000)	+= tlbex32-r4k.o
+obj-$(CONFIG_CPU_RM9000)	+= tlbex32-r4k.o
+obj-$(CONFIG_CPU_R10000)	+= tlbex32-r4k.o
+obj-$(CONFIG_CPU_MIPS32)	+= tlbex32-r4k.o
+obj-$(CONFIG_CPU_MIPS64)	+= tlbex32-r4k.o
+obj-$(CONFIG_CPU_SB1)		+= tlbex32-r4k.o
+obj-$(CONFIG_CPU_TX39XX)	+= tlbex32-r3k.o
+endif
+ifdef CONFIG_MIPS64
+obj-$(CONFIG_CPU_R4300)		+= tlb64-glue-r4k.o tlbex64-r4k.o
+obj-$(CONFIG_CPU_R4X00)		+= tlb64-glue-r4k.o tlbex64-r4k.o
+obj-$(CONFIG_CPU_R5000)		+= tlb64-glue-r4k.o tlbex64-r4k.o
+obj-$(CONFIG_CPU_NEVADA)	+= tlb64-glue-r4k.o tlbex64-r4k.o
+obj-$(CONFIG_CPU_R5432)		+= tlb64-glue-r4k.o tlbex64-r4k.o
+obj-$(CONFIG_CPU_RM7000)	+= tlb64-glue-r4k.o tlbex64-r4k.o
+obj-$(CONFIG_CPU_RM9000)	+= tlb64-glue-r4k.o tlbex64-r4k.o
+obj-$(CONFIG_CPU_R10000)	+= tlb64-glue-r4k.o tlbex64-r4k.o
+obj-$(CONFIG_CPU_SB1)		+= tlb64-glue-sb1.o tlbex64-r4k.o
+obj-$(CONFIG_CPU_MIPS64)	+= tlb64-glue-r4k.o tlbex64-r4k.o
+endif
+
+
 obj-$(CONFIG_IP22_CPU_SCACHE)	+= sc-ip22.o
 obj-$(CONFIG_R5000_CPU_SCACHE)  += sc-r5k.o
 obj-$(CONFIG_RM7000_CPU_SCACHE)	+= sc-rm7k.o
diff -puN /dev/null arch/mips/mm/tlb64-glue-r4k.S
--- /dev/null	2003-09-15 06:40:47.000000000 -0700
+++ 25-akpm/arch/mips/mm/tlb64-glue-r4k.S	2004-06-21 23:10:45.648279984 -0700
@@ -0,0 +1,41 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1999 Ralf Baechle
+ * Copyright (C) 1999 Silicon Graphics, Inc.
+ */
+#include <linux/init.h>
+#include <asm/mipsregs.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+
+	.macro	__BUILD_cli
+	CLI
+	.endm
+
+	.macro	__BUILD_sti
+	STI
+	.endm
+
+	.macro	__BUILD_kmode
+	KMODE
+	.endm
+
+	.macro	tlb_handler name interruptible writebit
+	NESTED(__\name, PT_SIZE, sp)
+	SAVE_ALL
+	dmfc0	a2, CP0_BADVADDR
+	__BUILD_\interruptible
+	li	a1, \writebit
+	sd	a2, PT_BVADDR(sp)
+	move	a0, sp
+	jal	do_page_fault
+	j	ret_from_exception
+	END(__\name)
+	.endm
+
+	tlb_handler	xtlb_mod kmode 1
+	tlb_handler	xtlb_tlbl kmode 0
+	tlb_handler	xtlb_tlbs kmode 1
diff -puN /dev/null arch/mips/mm/tlb64-glue-sb1.S
--- /dev/null	2003-09-15 06:40:47.000000000 -0700
+++ 25-akpm/arch/mips/mm/tlb64-glue-sb1.S	2004-06-21 23:10:45.649279832 -0700
@@ -0,0 +1,66 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1999 Ralf Baechle
+ * Copyright (C) 1999 Silicon Graphics, Inc.
+ */
+#include <linux/init.h>
+#include <asm/mipsregs.h>
+#include <asm/page.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+#include <asm/war.h>
+
+	.macro	__BUILD_cli
+	CLI
+	.endm
+
+	.macro	__BUILD_sti
+	STI
+	.endm
+
+	.macro	__BUILD_kmode
+	KMODE
+	.endm
+
+	.macro	tlb_handler name interruptible writebit
+	NESTED(__\name, PT_SIZE, sp)
+	SAVE_ALL
+	dmfc0	a2, CP0_BADVADDR
+	__BUILD_\interruptible
+	li	a1, \writebit
+	sd	a2, PT_BVADDR(sp)
+	move	a0, sp
+	jal	do_page_fault
+	j	ret_from_exception
+	END(__\name)
+	.endm
+
+	.macro	tlb_handler_m3 name interruptible writebit
+	NESTED(__\name, PT_SIZE, sp)
+	dmfc0	k0, CP0_BADVADDR
+	dmfc0	k1, CP0_ENTRYHI
+	xor	k0, k1
+	dsrl	k0, k0, PAGE_SHIFT + 1
+	bnez	k0, 1f
+	SAVE_ALL
+	dmfc0	a2, CP0_BADVADDR
+	__BUILD_\interruptible
+	li	a1, \writebit
+	sd	a2, PT_BVADDR(sp)
+	move	a0, sp
+	jal	do_page_fault
+1:
+	j	ret_from_exception
+	END(__\name)
+	.endm
+
+	tlb_handler	xtlb_mod kmode 1
+#if BCM1250_M3_WAR
+	tlb_handler_m3	xtlb_tlbl kmode 0
+#else
+	tlb_handler	xtlb_tlbl kmode 0
+#endif
+	tlb_handler	xtlb_tlbs kmode 1
diff -puN /dev/null arch/mips/mm/tlbex32-r3k.S
--- /dev/null	2003-09-15 06:40:47.000000000 -0700
+++ 25-akpm/arch/mips/mm/tlbex32-r3k.S	2004-06-21 23:10:45.651279528 -0700
@@ -0,0 +1,224 @@
+/*
+ * TLB exception handling code for R2000/R3000.
+ *
+ * Copyright (C) 1994, 1995, 1996 by Ralf Baechle and Andreas Busse
+ *
+ * Multi-CPU abstraction reworking:
+ * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
+ *
+ * Further modifications to make this work:
+ * Copyright (c) 1998 Harald Koerfgen
+ * Copyright (c) 1998, 1999 Gleb Raiko & Vladimir Roganov
+ * Copyright (c) 2001 Ralf Baechle
+ * Copyright (c) 2001 MIPS Technologies, Inc.
+ */
+#include <linux/init.h>
+#include <asm/asm.h>
+#include <asm/cachectl.h>
+#include <asm/fpregdef.h>
+#include <asm/mipsregs.h>
+#include <asm/page.h>
+#include <asm/pgtable-bits.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+
+#define TLB_OPTIMIZE /* If you are paranoid, disable this. */
+
+	.text
+	.set	mips1
+	.set	noreorder
+
+	__INIT
+
+	/* TLB refill, R[23]00 version */
+	LEAF(except_vec0_r2300)
+	.set	noat
+	.set	mips1
+	mfc0	k0, CP0_BADVADDR
+	lw	k1, pgd_current			# get pgd pointer
+	srl	k0, k0, 22
+	sll	k0, k0, 2
+	addu	k1, k1, k0
+	mfc0	k0, CP0_CONTEXT
+	lw	k1, (k1)
+	and	k0, k0, 0xffc
+	addu	k1, k1, k0
+	lw	k0, (k1)
+	nop
+	mtc0	k0, CP0_ENTRYLO0
+	mfc0	k1, CP0_EPC
+	tlbwr
+	jr	k1
+	rfe
+	END(except_vec0_r2300)
+
+	__FINIT
+
+	/* ABUSE of CPP macros 101. */
+
+	/* After this macro runs, the pte faulted on is
+	 * in register PTE, a ptr into the table in which
+	 * the pte belongs is in PTR.
+	 */
+#define LOAD_PTE(pte, ptr) \
+	mfc0	pte, CP0_BADVADDR; \
+	lw	ptr, pgd_current; \
+	srl	pte, pte, 22; \
+	sll	pte, pte, 2; \
+	addu	ptr, ptr, pte; \
+	mfc0	pte, CP0_CONTEXT; \
+	lw	ptr, (ptr); \
+	andi	pte, pte, 0xffc; \
+	addu	ptr, ptr, pte; \
+	lw	pte, (ptr); \
+	nop;
+
+	/* This places the even/odd pte pair in the page
+	 * table at PTR into ENTRYLO0 and ENTRYLO1 using
+	 * TMP as a scratch register.
+	 */
+#define PTE_RELOAD(ptr) \
+	lw	ptr, (ptr)	; \
+	nop			; \
+	mtc0	ptr, CP0_ENTRYLO0; \
+	nop;
+
+#define DO_FAULT(write) \
+	.set	noat; \
+	.set	macro; \
+	SAVE_ALL; \
+	mfc0	a2, CP0_BADVADDR; \
+	KMODE; \
+	.set	at; \
+	move	a0, sp; \
+	jal	do_page_fault; \
+	 li	a1, write; \
+	j	ret_from_exception; \
+	 nop; \
+	.set	noat; \
+	.set	nomacro;
+
+	/* Check is PTE is present, if not then jump to LABEL.
+	 * PTR points to the page table where this PTE is located,
+	 * when the macro is done executing PTE will be restored
+	 * with it's original value.
+	 */
+#define PTE_PRESENT(pte, ptr, label) \
+	andi	pte, pte, (_PAGE_PRESENT | _PAGE_READ); \
+	xori	pte, pte, (_PAGE_PRESENT | _PAGE_READ); \
+	bnez	pte, label; \
+	.set	push;       \
+	.set	reorder;    \
+	 lw	pte, (ptr); \
+	.set	pop;
+
+	/* Make PTE valid, store result in PTR. */
+#define PTE_MAKEVALID(pte, ptr) \
+	ori	pte, pte, (_PAGE_VALID | _PAGE_ACCESSED); \
+	sw	pte, (ptr);
+
+	/* Check if PTE can be written to, if not branch to LABEL.
+	 * Regardless restore PTE with value from PTR when done.
+	 */
+#define PTE_WRITABLE(pte, ptr, label) \
+	andi	pte, pte, (_PAGE_PRESENT | _PAGE_WRITE); \
+	xori	pte, pte, (_PAGE_PRESENT | _PAGE_WRITE); \
+	bnez	pte, label; \
+	.set    push;       \
+	.set    reorder;    \
+	lw      pte, (ptr); \
+	.set    pop;
+
+
+	/* Make PTE writable, update software status bits as well,
+	 * then store at PTR.
+	 */
+#define PTE_MAKEWRITE(pte, ptr) \
+	ori	pte, pte, (_PAGE_ACCESSED | _PAGE_MODIFIED | \
+			   _PAGE_VALID | _PAGE_DIRTY); \
+	sw	pte, (ptr);
+
+/*
+ * The index register may have the probe fail bit set,
+ * because we would trap on access kseg2, i.e. without refill.
+ */
+#define TLB_WRITE(reg) \
+	mfc0	reg, CP0_INDEX; \
+	nop; \
+	bltz    reg, 1f; \
+	 nop; \
+	tlbwi; \
+	j	2f; \
+	 nop; \
+1:	tlbwr; \
+2:
+
+#define RET(reg) \
+	mfc0	reg, CP0_EPC; \
+	nop; \
+	jr	reg; \
+	 rfe
+
+	.set	noreorder
+
+	.align	5
+NESTED(handle_tlbl, PT_SIZE, sp)
+	.set	noat
+
+#ifdef TLB_OPTIMIZE
+	/* Test present bit in entry. */
+	LOAD_PTE(k0, k1)
+        tlbp
+        PTE_PRESENT(k0, k1, nopage_tlbl)
+        PTE_MAKEVALID(k0, k1)
+        PTE_RELOAD(k1)
+	TLB_WRITE(k0)
+	RET(k0)
+nopage_tlbl:
+#endif
+
+	DO_FAULT(0)
+END(handle_tlbl)
+
+NESTED(handle_tlbs, PT_SIZE, sp)
+	.set	noat
+
+#ifdef TLB_OPTIMIZE
+	LOAD_PTE(k0, k1)
+	tlbp                            # find faulting entry
+	PTE_WRITABLE(k0, k1, nopage_tlbs)
+	PTE_MAKEWRITE(k0, k1)
+	PTE_RELOAD(k1)
+	TLB_WRITE(k0)
+	RET(k0)
+nopage_tlbs:
+#endif
+
+	DO_FAULT(1)
+END(handle_tlbs)
+
+	.align	5
+NESTED(handle_mod, PT_SIZE, sp)
+	.set	noat
+#ifdef TLB_OPTIMIZE
+	LOAD_PTE(k0, k1)
+	tlbp					# find faulting entry
+	andi	k0, k0, _PAGE_WRITE
+	beqz	k0, nowrite_mod
+	.set	push
+	.set    reorder
+	lw	k0, (k1)
+	.set    pop
+
+	/* Present and writable bits set, set accessed and dirty bits. */
+	PTE_MAKEWRITE(k0, k1)
+
+	/* Now reload the entry into the tlb. */
+	PTE_RELOAD(k1)
+	tlbwi
+	RET(k0)
+#endif
+
+nowrite_mod:
+	DO_FAULT(1)
+END(handle_mod)
diff -puN /dev/null arch/mips/mm/tlbex32-r4k.S
--- /dev/null	2003-09-15 06:40:47.000000000 -0700
+++ 25-akpm/arch/mips/mm/tlbex32-r4k.S	2004-06-21 23:10:45.654279072 -0700
@@ -0,0 +1,524 @@
+/*
+ * TLB exception handling code for r4k.
+ *
+ * Copyright (C) 1994, 1995, 1996 by Ralf Baechle and Andreas Busse
+ *
+ * Multi-cpu abstraction and reworking:
+ * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
+ *
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 2000 MIPS Technologies, Inc.  All rights reserved.
+ */
+#include <linux/init.h>
+#include <linux/config.h>
+
+#include <asm/asm.h>
+#include <asm/offset.h>
+#include <asm/cachectl.h>
+#include <asm/fpregdef.h>
+#include <asm/mipsregs.h>
+#include <asm/page.h>
+#include <asm/pgtable-bits.h>
+#include <asm/regdef.h>
+#include <asm/stackframe.h>
+#include <asm/war.h>
+
+#define TLB_OPTIMIZE /* If you are paranoid, disable this. */
+
+#ifdef CONFIG_64BIT_PHYS_ADDR
+#define PTE_L		ld
+#define PTE_S		sd
+#define PTE_SRL		dsrl
+#define P_MTC0		dmtc0
+#define PTE_SIZE	8
+#define PTEP_INDX_MSK	0xff0
+#define PTE_INDX_MSK	0xff8
+#define PTE_INDX_SHIFT	9
+#else
+#define PTE_L		lw
+#define PTE_S		sw
+#define PTE_SRL		srl
+#define P_MTC0		mtc0
+#define PTE_SIZE	4
+#define PTEP_INDX_MSK	0xff8
+#define PTE_INDX_MSK	0xffc
+#define PTE_INDX_SHIFT	10
+#endif
+
+/*
+ * ABUSE of CPP macros 101.
+ *
+ * After this macro runs, the pte faulted on is
+ * in register PTE, a ptr into the table in which
+ * the pte belongs is in PTR.
+ */
+
+#ifdef CONFIG_SMP
+#define GET_PGD(scratch, ptr)        \
+	mfc0    ptr, CP0_CONTEXT;    \
+	la      scratch, pgd_current;\
+	srl     ptr, 23;             \
+	sll     ptr, 2;              \
+	addu    ptr, scratch, ptr;   \
+	lw      ptr, (ptr);
+#else
+#define GET_PGD(scratch, ptr)    \
+	lw	ptr, pgd_current;
+#endif
+
+#define LOAD_PTE(pte, ptr) \
+	GET_PGD(pte, ptr)          \
+	mfc0	pte, CP0_BADVADDR; \
+	srl	pte, pte, _PGDIR_SHIFT; \
+	sll	pte, pte, 2; \
+	addu	ptr, ptr, pte; \
+	mfc0	pte, CP0_BADVADDR; \
+	lw	ptr, (ptr); \
+	srl	pte, pte, PTE_INDX_SHIFT; \
+	and	pte, pte, PTE_INDX_MSK; \
+	addu	ptr, ptr, pte; \
+	PTE_L	pte, (ptr);
+
+	/* This places the even/odd pte pair in the page
+	 * table at PTR into ENTRYLO0 and ENTRYLO1 using
+	 * TMP as a scratch register.
+	 */
+#define PTE_RELOAD(ptr, tmp) \
+	ori	ptr, ptr, PTE_SIZE; \
+	xori	ptr, ptr, PTE_SIZE; \
+	PTE_L	tmp, PTE_SIZE(ptr); \
+	PTE_L	ptr, 0(ptr); \
+	PTE_SRL	tmp, tmp, 6; \
+	P_MTC0	tmp, CP0_ENTRYLO1; \
+	PTE_SRL	ptr, ptr, 6; \
+	P_MTC0	ptr, CP0_ENTRYLO0;
+
+#define DO_FAULT(write) \
+	.set	noat; \
+	SAVE_ALL; \
+	mfc0	a2, CP0_BADVADDR; \
+	KMODE; \
+	.set	at; \
+	move	a0, sp; \
+	jal	do_page_fault; \
+	 li	a1, write; \
+	j	ret_from_exception; \
+	 nop; \
+	.set	noat;
+
+	/* Check is PTE is present, if not then jump to LABEL.
+	 * PTR points to the page table where this PTE is located,
+	 * when the macro is done executing PTE will be restored
+	 * with it's original value.
+	 */
+#define PTE_PRESENT(pte, ptr, label) \
+	andi	pte, pte, (_PAGE_PRESENT | _PAGE_READ); \
+	xori	pte, pte, (_PAGE_PRESENT | _PAGE_READ); \
+	bnez	pte, label; \
+	 PTE_L	pte, (ptr);
+
+	/* Make PTE valid, store result in PTR. */
+#define PTE_MAKEVALID(pte, ptr) \
+	ori	pte, pte, (_PAGE_VALID | _PAGE_ACCESSED); \
+	PTE_S	pte, (ptr);
+
+	/* Check if PTE can be written to, if not branch to LABEL.
+	 * Regardless restore PTE with value from PTR when done.
+	 */
+#define PTE_WRITABLE(pte, ptr, label) \
+	andi	pte, pte, (_PAGE_PRESENT | _PAGE_WRITE); \
+	xori	pte, pte, (_PAGE_PRESENT | _PAGE_WRITE); \
+	bnez	pte, label; \
+	 PTE_L	pte, (ptr);
+
+	/* Make PTE writable, update software status bits as well,
+	 * then store at PTR.
+	 */
+#define PTE_MAKEWRITE(pte, ptr) \
+	ori	pte, pte, (_PAGE_ACCESSED | _PAGE_MODIFIED | \
+			   _PAGE_VALID | _PAGE_DIRTY); \
+	PTE_S	pte, (ptr);
+
+	__INIT
+
+#ifdef CONFIG_64BIT_PHYS_ADDR
+#define GET_PTE_OFF(reg)
+#elif CONFIG_CPU_VR41XX
+#define GET_PTE_OFF(reg)	srl	reg, reg, 3
+#else
+#define GET_PTE_OFF(reg)	srl	reg, reg, 1
+#endif
+
+/*
+ * These handlers much be written in a relocatable manner
+ * because based upon the cpu type an arbitrary one of the
+ * following pieces of code will be copied to the KSEG0
+ * vector location.
+ */
+	/* TLB refill, EXL == 0, R4xx0, non-R4600 version */
+	.set	noreorder
+	.set	noat
+	LEAF(except_vec0_r4000)
+	.set	mips3
+	GET_PGD(k0, k1)				# get pgd pointer
+	mfc0	k0, CP0_BADVADDR		# Get faulting address
+	srl	k0, k0, _PGDIR_SHIFT		# get pgd only bits
+
+	sll	k0, k0, 2
+	addu	k1, k1, k0			# add in pgd offset
+	mfc0	k0, CP0_CONTEXT			# get context reg
+	lw	k1, (k1)
+	GET_PTE_OFF(k0)				# get pte offset
+	and	k0, k0, PTEP_INDX_MSK
+	addu	k1, k1, k0			# add in offset
+	PTE_L	k0, 0(k1)			# get even pte
+	PTE_L	k1, PTE_SIZE(k1)		# get odd pte
+	PTE_SRL	k0, k0, 6			# convert to entrylo0
+	P_MTC0	k0, CP0_ENTRYLO0		# load it
+	PTE_SRL	k1, k1, 6			# convert to entrylo1
+	P_MTC0	k1, CP0_ENTRYLO1		# load it
+	mtc0_tlbw_hazard
+	tlbwr					# write random tlb entry
+	tlbw_eret_hazard
+	eret					# return from trap
+	END(except_vec0_r4000)
+
+	/* TLB refill, EXL == 0, R4600 version */
+	LEAF(except_vec0_r4600)
+	.set	mips3
+	GET_PGD(k0, k1)				# get pgd pointer
+	mfc0	k0, CP0_BADVADDR
+	srl	k0, k0, _PGDIR_SHIFT
+	sll	k0, k0, 2			# log2(sizeof(pgd_t)
+	addu	k1, k1, k0
+	mfc0	k0, CP0_CONTEXT
+	lw	k1, (k1)
+	GET_PTE_OFF(k0)				# get pte offset
+	and	k0, k0, PTEP_INDX_MSK
+	addu	k1, k1, k0
+	PTE_L	k0, 0(k1)
+	PTE_L	k1, PTE_SIZE(k1)
+	PTE_SRL	k0, k0, 6
+	P_MTC0	k0, CP0_ENTRYLO0
+	PTE_SRL	k1, k1, 6
+	P_MTC0	k1, CP0_ENTRYLO1
+	nop
+	tlbwr
+	nop
+	eret
+	END(except_vec0_r4600)
+
+	/* TLB refill, EXL == 0, R52x0 "Nevada" version */
+        /*
+         * This version has a bug workaround for the Nevada.  It seems
+         * as if under certain circumstances the move from cp0_context
+         * might produce a bogus result when the mfc0 instruction and
+         * it's consumer are in a different cacheline or a load instruction,
+         * probably any memory reference, is between them.  This is
+         * potencially slower than the R4000 version, so we use this
+         * special version.
+         */
+	.set	noreorder
+	.set	noat
+	LEAF(except_vec0_nevada)
+	.set	mips3
+	mfc0	k0, CP0_BADVADDR		# Get faulting address
+	srl	k0, k0, _PGDIR_SHIFT		# get pgd only bits
+	lw	k1, pgd_current			# get pgd pointer
+	sll	k0, k0, 2			# log2(sizeof(pgd_t)
+	addu	k1, k1, k0			# add in pgd offset
+	lw	k1, (k1)
+	mfc0	k0, CP0_CONTEXT			# get context reg
+	GET_PTE_OFF(k0)				# get pte offset
+	and	k0, k0, PTEP_INDX_MSK
+	addu	k1, k1, k0			# add in offset
+	PTE_L	k0, 0(k1)			# get even pte
+	PTE_L	k1, PTE_SIZE(k1)		# get odd pte
+	PTE_SRL	k0, k0, 6			# convert to entrylo0
+	P_MTC0	k0, CP0_ENTRYLO0		# load it
+	PTE_SRL	k1, k1, 6			# convert to entrylo1
+	P_MTC0	k1, CP0_ENTRYLO1		# load it
+	nop					# QED specified nops
+	nop
+	tlbwr					# write random tlb entry
+	nop					# traditional nop
+	eret					# return from trap
+	END(except_vec0_nevada)
+
+	/* TLB refill, EXL == 0, SB1 with M3 errata handling version */
+	LEAF(except_vec0_sb1)
+#if BCM1250_M3_WAR
+	mfc0	k0, CP0_BADVADDR
+	mfc0	k1, CP0_ENTRYHI
+	xor	k0, k1
+	srl	k0, k0, PAGE_SHIFT+1
+	bnez	k0, 1f
+#endif
+	GET_PGD(k0, k1)				# get pgd pointer
+	mfc0	k0, CP0_BADVADDR		# Get faulting address
+	srl	k0, k0, _PGDIR_SHIFT		# get pgd only bits
+	sll	k0, k0, 2
+	addu	k1, k1, k0			# add in pgd offset
+	mfc0	k0, CP0_CONTEXT			# get context reg
+	lw	k1, (k1)
+	GET_PTE_OFF(k0)				# get pte offset
+	and	k0, k0, PTEP_INDX_MSK
+	addu	k1, k1, k0			# add in offset
+	PTE_L	k0, 0(k1)			# get even pte
+	PTE_L	k1, PTE_SIZE(k1)		# get odd pte
+	PTE_SRL	k0, k0, 6			# convert to entrylo0
+	P_MTC0	k0, CP0_ENTRYLO0		# load it
+	PTE_SRL	k1, k1, 6			# convert to entrylo1
+	P_MTC0	k1, CP0_ENTRYLO1		# load it
+	tlbwr					# write random tlb entry
+1:	eret					# return from trap
+	END(except_vec0_sb1)
+
+	/* TLB refill, EXL == 0, R4[40]00/R5000 badvaddr hwbug version */
+	LEAF(except_vec0_r45k_bvahwbug)
+	.set	mips3
+	GET_PGD(k0, k1)				# get pgd pointer
+	mfc0	k0, CP0_BADVADDR
+	srl	k0, k0, _PGDIR_SHIFT
+	sll	k0, k0, 2			# log2(sizeof(pgd_t)
+	addu	k1, k1, k0
+	mfc0	k0, CP0_CONTEXT
+	lw	k1, (k1)
+#ifndef CONFIG_64BIT_PHYS_ADDR
+	srl	k0, k0, 1
+#endif
+	and	k0, k0, PTEP_INDX_MSK
+	addu	k1, k1, k0
+	PTE_L	k0, 0(k1)
+	PTE_L	k1, PTE_SIZE(k1)
+	nop				/* XXX */
+	tlbp
+	PTE_SRL	k0, k0, 6
+	P_MTC0	k0, CP0_ENTRYLO0
+	PTE_SRL	k1, k1, 6
+	mfc0	k0, CP0_INDEX
+	P_MTC0	k1, CP0_ENTRYLO1
+	bltzl	k0, 1f
+	tlbwr
+1:
+	nop
+	eret
+	END(except_vec0_r45k_bvahwbug)
+
+#ifdef CONFIG_SMP
+	/* TLB refill, EXL == 0, R4000 MP badvaddr hwbug version */
+	LEAF(except_vec0_r4k_mphwbug)
+	.set	mips3
+	GET_PGD(k0, k1)				# get pgd pointer
+	mfc0	k0, CP0_BADVADDR
+	srl	k0, k0, _PGDIR_SHIFT
+	sll	k0, k0, 2			# log2(sizeof(pgd_t)
+	addu	k1, k1, k0
+	mfc0	k0, CP0_CONTEXT
+	lw	k1, (k1)
+#ifndef CONFIG_64BIT_PHYS_ADDR
+	srl	k0, k0, 1
+#endif
+	and	k0, k0, PTEP_INDX_MSK
+	addu	k1, k1, k0
+	PTE_L	k0, 0(k1)
+	PTE_L	k1, PTE_SIZE(k1)
+	nop				/* XXX */
+	tlbp
+	PTE_SRL	k0, k0, 6
+	P_MTC0	k0, CP0_ENTRYLO0
+	PTE_SRL	k1, k1, 6
+	mfc0	k0, CP0_INDEX
+	P_MTC0	k1, CP0_ENTRYLO1
+	bltzl	k0, 1f
+	tlbwr
+1:
+	nop
+	eret
+	END(except_vec0_r4k_mphwbug)
+#endif
+
+	/* TLB refill, EXL == 0, R4000 UP 250MHZ entrylo[01] hwbug version */
+	LEAF(except_vec0_r4k_250MHZhwbug)
+	.set	mips3
+	GET_PGD(k0, k1)				# get pgd pointer
+	mfc0	k0, CP0_BADVADDR
+	srl	k0, k0, _PGDIR_SHIFT
+	sll	k0, k0, 2			# log2(sizeof(pgd_t)
+	addu	k1, k1, k0
+	mfc0	k0, CP0_CONTEXT
+	lw	k1, (k1)
+#ifndef CONFIG_64BIT_PHYS_ADDR
+	srl	k0, k0, 1
+#endif
+	and	k0, k0, PTEP_INDX_MSK
+	addu	k1, k1, k0
+	PTE_L	k0, 0(k1)
+	PTE_L	k1, PTE_SIZE(k1)
+	PTE_SRL	k0, k0, 6
+	P_MTC0	zero, CP0_ENTRYLO0
+	P_MTC0	k0, CP0_ENTRYLO0
+	PTE_SRL	k1, k1, 6
+	P_MTC0	zero, CP0_ENTRYLO1
+	P_MTC0	k1, CP0_ENTRYLO1
+	b	1f
+	tlbwr
+1:
+	nop
+	eret
+	END(except_vec0_r4k_250MHZhwbug)
+
+#ifdef CONFIG_SMP
+	/* TLB refill, EXL == 0, R4000 MP 250MHZ entrylo[01]+badvaddr bug version */
+	LEAF(except_vec0_r4k_MP250MHZhwbug)
+	.set	mips3
+	GET_PGD(k0, k1)				# get pgd pointer
+	mfc0	k0, CP0_BADVADDR
+	srl	k0, k0, _PGDIR_SHIFT
+	sll	k0, k0, 2			# log2(sizeof(pgd_t)
+	addu	k1, k1, k0
+	mfc0	k0, CP0_CONTEXT
+	lw	k1, (k1)
+#ifndef CONFIG_64BIT_PHYS_ADDR
+	srl	k0, k0, 1
+#endif
+	and	k0, k0, PTEP_INDX_MSK
+	addu	k1, k1, k0
+	PTE_L	k0, 0(k1)
+	PTE_L	k1, PTE_SIZE(k1)
+	nop				/* XXX */
+	tlbp
+	PTE_SRL	k0, k0, 6
+	P_MTC0  zero, CP0_ENTRYLO0
+	P_MTC0  k0, CP0_ENTRYLO0
+	mfc0    k0, CP0_INDEX
+	PTE_SRL	k1, k1, 6
+	P_MTC0	zero, CP0_ENTRYLO1
+	P_MTC0	k1, CP0_ENTRYLO1
+	bltzl	k0, 1f
+	tlbwr
+1:
+	nop
+	eret
+	END(except_vec0_r4k_MP250MHZhwbug)
+#endif
+
+	__FINIT
+
+	.set	noreorder
+
+/*
+ * From the IDT errata for the QED RM5230 (Nevada), processor revision 1.0:
+ * 2. A timing hazard exists for the TLBP instruction.
+ *
+ *      stalling_instruction
+ *      TLBP
+ *
+ * The JTLB is being read for the TLBP throughout the stall generated by the
+ * previous instruction. This is not really correct as the stalling instruction
+ * can modify the address used to access the JTLB.  The failure symptom is that
+ * the TLBP instruction will use an address created for the stalling instruction
+ * and not the address held in C0_ENHI and thus report the wrong results.
+ *
+ * The software work-around is to not allow the instruction preceding the TLBP
+ * to stall - make it an NOP or some other instruction guaranteed not to stall.
+ *
+ * Errata 2 will not be fixed.  This errata is also on the R5000.
+ *
+ * As if we MIPS hackers wouldn't know how to nop pipelines happy ...
+ */
+#define R5K_HAZARD nop
+
+	/*
+	 * Note for many R4k variants tlb probes cannot be executed out
+	 * of the instruction cache else you get bogus results.
+	 */
+	.align	5
+	NESTED(handle_tlbl, PT_SIZE, sp)
+	.set	noat
+#if BCM1250_M3_WAR
+	mfc0	k0, CP0_BADVADDR
+	mfc0	k1, CP0_ENTRYHI
+	xor	k0, k1
+	srl	k0, k0, PAGE_SHIFT+1
+	beqz	k0, 1f
+	 nop
+	.set	mips3
+	eret
+	.set	mips0
+1:
+#endif
+invalid_tlbl:
+#ifdef TLB_OPTIMIZE
+	.set	mips3
+	/* Test present bit in entry. */
+	LOAD_PTE(k0, k1)
+	R5K_HAZARD
+	tlbp
+	PTE_PRESENT(k0, k1, nopage_tlbl)
+	PTE_MAKEVALID(k0, k1)
+	PTE_RELOAD(k1, k0)
+	mtc0_tlbw_hazard
+	tlbwi
+	tlbw_eret_hazard
+	.set	mips3
+	eret
+	.set	mips0
+#endif
+
+nopage_tlbl:
+	DO_FAULT(0)
+	END(handle_tlbl)
+
+	.align	5
+	NESTED(handle_tlbs, PT_SIZE, sp)
+	.set	noat
+#ifdef TLB_OPTIMIZE
+	.set	mips3
+        li      k0,0
+	LOAD_PTE(k0, k1)
+	R5K_HAZARD
+	tlbp				# find faulting entry
+	PTE_WRITABLE(k0, k1, nopage_tlbs)
+	PTE_MAKEWRITE(k0, k1)
+	PTE_RELOAD(k1, k0)
+	mtc0_tlbw_hazard
+	tlbwi
+	tlbw_eret_hazard
+	.set	mips3
+	eret
+	.set	mips0
+#endif
+
+nopage_tlbs:
+	DO_FAULT(1)
+	END(handle_tlbs)
+
+	.align	5
+	NESTED(handle_mod, PT_SIZE, sp)
+	.set	noat
+#ifdef TLB_OPTIMIZE
+	.set	mips3
+	LOAD_PTE(k0, k1)
+	R5K_HAZARD
+	tlbp					# find faulting entry
+	andi	k0, k0, _PAGE_WRITE
+	beqz	k0, nowrite_mod
+	 PTE_L	k0, (k1)
+
+	/* Present and writable bits set, set accessed and dirty bits. */
+	PTE_MAKEWRITE(k0, k1)
+
+	/* Now reload the entry into the tlb. */
+	PTE_RELOAD(k1, k0)
+	mtc0_tlbw_hazard
+	tlbwi
+	tlbw_eret_hazard
+	.set	mips3
+	eret
+	.set	mips0
+#endif
+
+nowrite_mod:
+	DO_FAULT(1)
+	END(handle_mod)
diff -puN /dev/null arch/mips/mm/tlbex64-r4k.S
--- /dev/null	2003-09-15 06:40:47.000000000 -0700
+++ 25-akpm/arch/mips/mm/tlbex64-r4k.S	2004-06-21 23:10:45.655278920 -0700
@@ -0,0 +1,203 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000 Silicon Graphics, Inc.
+ * Written by Ulf Carlsson (ulfc@engr.sgi.com)
+ * Copyright (C) 2002  Maciej W. Rozycki
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/threads.h>
+
+#include <asm/asm.h>
+#include <asm/hazards.h>
+#include <asm/regdef.h>
+#include <asm/mipsregs.h>
+#include <asm/stackframe.h>
+#include <asm/war.h>
+
+#define _VMALLOC_START	0xc000000000000000
+
+	/*
+	 * After this macro runs we have a pointer to the pte of the address
+	 * that caused the fault in PTR.
+	 */
+	.macro	LOAD_PTE2, ptr, tmp, kaddr
+#ifdef CONFIG_SMP
+	dmfc0	\ptr, CP0_CONTEXT
+	dmfc0	\tmp, CP0_BADVADDR
+	dsra	\ptr, 23			# get pgd_current[cpu]
+#else
+	dmfc0	\tmp, CP0_BADVADDR
+	dla	\ptr, pgd_current
+#endif
+	bltz	\tmp, \kaddr
+	 ld	\ptr, (\ptr)
+	dsrl	\tmp, (_PGDIR_SHIFT-3)		# get pgd offset in bytes
+	andi	\tmp, ((_PTRS_PER_PGD - 1)<<3)
+	daddu	\ptr, \tmp			# add in pgd offset
+	dmfc0	\tmp, CP0_BADVADDR
+	ld	\ptr, (\ptr)			# get pmd pointer
+	dsrl	\tmp, (_PMD_SHIFT-3)		# get pmd offset in bytes
+	andi	\tmp, ((_PTRS_PER_PMD - 1)<<3)
+	daddu	\ptr, \tmp			# add in pmd offset
+	dmfc0	\tmp, CP0_XCONTEXT
+	ld	\ptr, (\ptr)			# get pte pointer
+	andi	\tmp, 0xff0			# get pte offset
+	daddu	\ptr, \tmp
+	.endm
+
+
+	/*
+	 * Ditto for the kernel table.
+	 */
+	.macro	LOAD_KPTE2, ptr, tmp, not_vmalloc
+	/*
+	 * First, determine that the address is in/above vmalloc range.
+	 */
+	dmfc0	\tmp, CP0_BADVADDR
+	dli	\ptr, _VMALLOC_START
+
+	/*
+	 * Now find offset into kptbl.
+	 */
+	dsubu	\tmp, \tmp, \ptr
+	dla	\ptr, kptbl
+	dsrl	\tmp, (_PAGE_SHIFT+1)		# get vpn2
+	dsll	\tmp, 4				# byte offset of pte
+	daddu	\ptr, \ptr, \tmp
+
+	/*
+	 * Determine that fault address is within vmalloc range.
+	 */
+	dla	\tmp, ekptbl
+	slt	\tmp, \ptr, \tmp
+	beqz	\tmp, \not_vmalloc		# not vmalloc
+	 nop
+	.endm
+
+
+	/*
+	 * This places the even/odd pte pair in the page table at the pte
+	 * entry pointed to by PTE into ENTRYLO0 and ENTRYLO1.
+	 */
+	.macro	PTE_RELOAD, pte0, pte1
+	dsrl	\pte0, 6			# convert to entrylo0
+	dmtc0	\pte0, CP0_ENTRYLO0		# load it
+	dsrl	\pte1, 6			# convert to entrylo1
+	dmtc0	\pte1, CP0_ENTRYLO1		# load it
+	.endm
+
+
+	.text
+	.set	noreorder
+	.set	mips3
+
+	__INIT
+
+	/*
+	 * TLB refill handlers for the R4000 and SB1.
+	 * Attention:  We may only use 32 instructions / 128 bytes.
+	 */
+	.align  5
+LEAF(except_vec1_r4k)
+	.set    noat
+	dla     k0, handle_vec1_r4k
+	jr      k0
+	 nop
+END(except_vec1_r4k)
+
+LEAF(except_vec1_sb1)
+#if BCM1250_M3_WAR
+	dmfc0	k0, CP0_BADVADDR
+	dmfc0	k1, CP0_ENTRYHI
+	xor	k0, k1
+	dsrl	k0, k0, _PAGE_SHIFT+1
+	bnez	k0, 1f
+#endif
+	.set    noat
+	dla     k0, handle_vec1_r4k
+	jr      k0
+	 nop
+
+1:	eret
+	nop
+END(except_vec1_sb1)
+
+	__FINIT
+
+	.align  5
+LEAF(handle_vec1_r4k)
+	.set    noat
+	LOAD_PTE2 k1 k0 9f
+	ld	k0, 0(k1)			# get even pte
+	ld	k1, 8(k1)			# get odd pte
+	PTE_RELOAD k0 k1
+	mtc0_tlbw_hazard
+	tlbwr
+	tlbw_eret_hazard
+	eret
+
+9:						# handle the vmalloc range
+	LOAD_KPTE2 k1 k0 invalid_vmalloc_address
+	ld	k0, 0(k1)			# get even pte
+	ld	k1, 8(k1)			# get odd pte
+	PTE_RELOAD k0 k1
+	mtc0_tlbw_hazard
+	 tlbwr
+	tlbw_eret_hazard
+	eret
+END(handle_vec1_r4k)
+
+
+	__INIT
+
+	/*
+	 * TLB refill handler for the R10000.
+	 * Attention:  We may only use 32 instructions / 128 bytes.
+	 */
+	.align	5
+LEAF(except_vec1_r10k)
+	.set    noat
+	dla     k0, handle_vec1_r10k
+	jr      k0
+	 nop
+END(except_vec1_r10k)
+
+	__FINIT
+
+	.align	5
+LEAF(handle_vec1_r10k)
+	.set	noat
+	LOAD_PTE2 k1 k0 9f
+	ld	k0, 0(k1)			# get even pte
+	ld	k1, 8(k1)			# get odd pte
+	PTE_RELOAD k0 k1
+	nop
+	tlbwr
+	eret
+
+9:						# handle the vmalloc range
+	LOAD_KPTE2 k1 k0 invalid_vmalloc_address
+	ld	k0, 0(k1)			# get even pte
+	ld	k1, 8(k1)			# get odd pte
+	PTE_RELOAD k0 k1
+	nop
+	tlbwr
+	eret
+END(handle_vec1_r10k)
+
+
+	.align	5
+LEAF(invalid_vmalloc_address)
+	.set	noat
+	SAVE_ALL
+	CLI
+	dmfc0	t0, CP0_BADVADDR
+	sd	t0, PT_BVADDR(sp)
+	move	a0, sp
+	jal	show_regs
+	PANIC("Invalid kernel address")
+END(invalid_vmalloc_address)
diff -L arch/mips/mm/tlbex-r3k.S -puN arch/mips/mm/tlbex-r3k.S~mips-update /dev/null
--- 25/arch/mips/mm/tlbex-r3k.S
+++ /dev/null	2003-09-15 06:40:47.000000000 -0700
@@ -1,224 +0,0 @@
-/*
- * TLB exception handling code for R2000/R3000.
- *
- * Copyright (C) 1994, 1995, 1996 by Ralf Baechle and Andreas Busse
- *
- * Multi-CPU abstraction reworking:
- * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
- *
- * Further modifications to make this work:
- * Copyright (c) 1998 Harald Koerfgen
- * Copyright (c) 1998, 1999 Gleb Raiko & Vladimir Roganov
- * Copyright (c) 2001 Ralf Baechle
- * Copyright (c) 2001 MIPS Technologies, Inc.
- */
-#include <linux/init.h>
-#include <asm/asm.h>
-#include <asm/cachectl.h>
-#include <asm/fpregdef.h>
-#include <asm/mipsregs.h>
-#include <asm/page.h>
-#include <asm/pgtable-bits.h>
-#include <asm/regdef.h>
-#include <asm/stackframe.h>
-
-#define TLB_OPTIMIZE /* If you are paranoid, disable this. */
-
-	.text
-	.set	mips1
-	.set	noreorder
-
-	__INIT
-
-	/* TLB refill, R[23]00 version */
-	LEAF(except_vec0_r2300)
-	.set	noat
-	.set	mips1
-	mfc0	k0, CP0_BADVADDR
-	lw	k1, pgd_current			# get pgd pointer
-	srl	k0, k0, 22
-	sll	k0, k0, 2
-	addu	k1, k1, k0
-	mfc0	k0, CP0_CONTEXT
-	lw	k1, (k1)
-	and	k0, k0, 0xffc
-	addu	k1, k1, k0
-	lw	k0, (k1)
-	nop
-	mtc0	k0, CP0_ENTRYLO0
-	mfc0	k1, CP0_EPC
-	tlbwr
-	jr	k1
-	rfe
-	END(except_vec0_r2300)
-
-	__FINIT
-
-	/* ABUSE of CPP macros 101. */
-
-	/* After this macro runs, the pte faulted on is
-	 * in register PTE, a ptr into the table in which
-	 * the pte belongs is in PTR.
-	 */
-#define LOAD_PTE(pte, ptr) \
-	mfc0	pte, CP0_BADVADDR; \
-	lw	ptr, pgd_current; \
-	srl	pte, pte, 22; \
-	sll	pte, pte, 2; \
-	addu	ptr, ptr, pte; \
-	mfc0	pte, CP0_CONTEXT; \
-	lw	ptr, (ptr); \
-	andi	pte, pte, 0xffc; \
-	addu	ptr, ptr, pte; \
-	lw	pte, (ptr); \
-	nop;
-
-	/* This places the even/odd pte pair in the page
-	 * table at PTR into ENTRYLO0 and ENTRYLO1 using
-	 * TMP as a scratch register.
-	 */
-#define PTE_RELOAD(ptr) \
-	lw	ptr, (ptr)	; \
-	nop			; \
-	mtc0	ptr, CP0_ENTRYLO0; \
-	nop;
-
-#define DO_FAULT(write) \
-	.set	noat; \
-	.set	macro; \
-	SAVE_ALL; \
-	mfc0	a2, CP0_BADVADDR; \
-	KMODE; \
-	.set	at; \
-	move	a0, sp; \
-	jal	do_page_fault; \
-	 li	a1, write; \
-	j	ret_from_exception; \
-	 nop; \
-	.set	noat; \
-	.set	nomacro;
-
-	/* Check is PTE is present, if not then jump to LABEL.
-	 * PTR points to the page table where this PTE is located,
-	 * when the macro is done executing PTE will be restored
-	 * with it's original value.
-	 */
-#define PTE_PRESENT(pte, ptr, label) \
-	andi	pte, pte, (_PAGE_PRESENT | _PAGE_READ); \
-	xori	pte, pte, (_PAGE_PRESENT | _PAGE_READ); \
-	bnez	pte, label; \
-	.set	push;       \
-	.set	reorder;    \
-	 lw	pte, (ptr); \
-	.set	pop;
-
-	/* Make PTE valid, store result in PTR. */
-#define PTE_MAKEVALID(pte, ptr) \
-	ori	pte, pte, (_PAGE_VALID | _PAGE_ACCESSED); \
-	sw	pte, (ptr);
-
-	/* Check if PTE can be written to, if not branch to LABEL.
-	 * Regardless restore PTE with value from PTR when done.
-	 */
-#define PTE_WRITABLE(pte, ptr, label) \
-	andi	pte, pte, (_PAGE_PRESENT | _PAGE_WRITE); \
-	xori	pte, pte, (_PAGE_PRESENT | _PAGE_WRITE); \
-	bnez	pte, label; \
-	.set    push;       \
-	.set    reorder;    \
-	lw      pte, (ptr); \
-	.set    pop;
-
-
-	/* Make PTE writable, update software status bits as well,
-	 * then store at PTR.
-	 */
-#define PTE_MAKEWRITE(pte, ptr) \
-	ori	pte, pte, (_PAGE_ACCESSED | _PAGE_MODIFIED | \
-			   _PAGE_VALID | _PAGE_DIRTY); \
-	sw	pte, (ptr);
-
-/*
- * The index register may have the probe fail bit set,
- * because we would trap on access kseg2, i.e. without refill.
- */
-#define TLB_WRITE(reg) \
-	mfc0	reg, CP0_INDEX; \
-	nop; \
-	bltz    reg, 1f; \
-	 nop; \
-	tlbwi; \
-	j	2f; \
-	 nop; \
-1:	tlbwr; \
-2:
-
-#define RET(reg) \
-	mfc0	reg, CP0_EPC; \
-	nop; \
-	jr	reg; \
-	 rfe
-
-	.set	noreorder
-
-	.align	5
-NESTED(handle_tlbl, PT_SIZE, sp)
-	.set	noat
-
-#ifdef TLB_OPTIMIZE
-	/* Test present bit in entry. */
-	LOAD_PTE(k0, k1)
-        tlbp
-        PTE_PRESENT(k0, k1, nopage_tlbl)
-        PTE_MAKEVALID(k0, k1)
-        PTE_RELOAD(k1)
-	TLB_WRITE(k0)
-	RET(k0)
-nopage_tlbl:
-#endif
-
-	DO_FAULT(0)
-END(handle_tlbl)
-
-NESTED(handle_tlbs, PT_SIZE, sp)
-	.set	noat
-
-#ifdef TLB_OPTIMIZE
-	LOAD_PTE(k0, k1)
-	tlbp                            # find faulting entry
-	PTE_WRITABLE(k0, k1, nopage_tlbs)
-	PTE_MAKEWRITE(k0, k1)
-	PTE_RELOAD(k1)
-	TLB_WRITE(k0)
-	RET(k0)
-nopage_tlbs:
-#endif
-
-	DO_FAULT(1)
-END(handle_tlbs)
-
-	.align	5
-NESTED(handle_mod, PT_SIZE, sp)
-	.set	noat
-#ifdef TLB_OPTIMIZE
-	LOAD_PTE(k0, k1)
-	tlbp					# find faulting entry
-	andi	k0, k0, _PAGE_WRITE
-	beqz	k0, nowrite_mod
-	.set	push
-	.set    reorder
-	lw	k0, (k1)
-	.set    pop
-
-	/* Present and writable bits set, set accessed and dirty bits. */
-	PTE_MAKEWRITE(k0, k1)
-
-	/* Now reload the entry into the tlb. */
-	PTE_RELOAD(k1)
-	tlbwi
-	RET(k0)
-#endif
-
-nowrite_mod:
-	DO_FAULT(1)
-END(handle_mod)
diff -puN /dev/null arch/mips/mm/tlb-r8k.c
--- /dev/null	2003-09-15 06:40:47.000000000 -0700
+++ 25-akpm/arch/mips/mm/tlb-r8k.c	2004-06-21 23:10:45.658278464 -0700
@@ -0,0 +1,253 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
+ * Copyright (C) 1997, 1998, 1999, 2000 Ralf Baechle ralf@gnu.org
+ * Carsten Langgaard, carstenl@mips.com
+ * Copyright (C) 2002 MIPS Technologies, Inc.  All rights reserved.
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+
+#include <asm/cpu.h>
+#include <asm/bootinfo.h>
+#include <asm/mmu_context.h>
+#include <asm/pgtable.h>
+#include <asm/system.h>
+
+extern void except_vec0_generic(void);
+extern void except_vec1_r8k(void);
+
+#define TFP_TLB_SIZE		384
+#define TFP_TLB_SET_SHIFT	7
+
+/* CP0 hazard avoidance. */
+#define BARRIER __asm__ __volatile__(".set noreorder\n\t" \
+				     "nop; nop; nop; nop; nop; nop;\n\t" \
+				     ".set reorder\n\t")
+
+void local_flush_tlb_all(void)
+{
+	unsigned long flags;
+	unsigned long old_ctx;
+	int entry;
+
+	local_irq_save(flags);
+	/* Save old context and create impossible VPN2 value */
+	old_ctx = read_c0_entryhi();
+	write_c0_entrylo(0);
+
+	for (entry = 0; entry < TFP_TLB_SIZE; entry++) {
+		write_c0_tlbset(entry >> TFP_TLB_SET_SHIFT);
+		write_c0_vaddr(entry << PAGE_SHIFT);
+		write_c0_entryhi(CKSEG0 + (entry << (PAGE_SHIFT + 1)));
+		mtc0_tlbw_hazard();
+		tlb_write();
+	}
+	tlbw_use_hazard();
+	write_c0_entryhi(old_ctx);
+	local_irq_restore(flags);
+}
+
+void local_flush_tlb_mm(struct mm_struct *mm)
+{
+	int cpu = smp_processor_id();
+
+	if (cpu_context(cpu, mm) != 0)
+		drop_mmu_context(mm,cpu);
+}
+
+void local_flush_tlb_range(struct vm_area_struct *vma, unsigned long start,
+	unsigned long end)
+{
+	struct mm_struct *mm = vma->vm_mm;
+	int cpu = smp_processor_id();
+	unsigned long flags;
+	int oldpid, newpid, size;
+
+	if (!cpu_context(cpu, mm))
+		return;
+
+	size = (end - start + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+	size = (size + 1) >> 1;
+
+	local_irq_save(flags);
+
+	if (size > TFP_TLB_SIZE / 2) {
+		drop_mmu_context(mm, cpu);
+		goto out_restore;
+	}
+
+	oldpid = read_c0_entryhi();
+	newpid = cpu_asid(cpu, mm);
+
+	write_c0_entrylo(0);
+
+	start &= PAGE_MASK;
+	end += (PAGE_SIZE - 1);
+	end &= PAGE_MASK;
+	while (start < end) {
+		signed long idx;
+
+		write_c0_vaddr(start);
+		write_c0_entryhi(start);
+		start += PAGE_SIZE;
+		tlb_probe();
+		idx = read_c0_tlbset();
+		if (idx < 0)
+			continue;
+
+		write_c0_entryhi(CKSEG0 + (idx << (PAGE_SHIFT + 1)));
+		tlb_write();
+	}
+	write_c0_entryhi(oldpid);
+
+out_restore:
+	local_irq_restore(flags);
+}
+
+/* Usable for KV1 addresses only! */
+void local_flush_tlb_kernel_range(unsigned long start, unsigned long end)
+{
+	unsigned long flags;
+	int size;
+
+	size = (end - start + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+	size = (size + 1) >> 1;
+
+	if (size > TFP_TLB_SIZE / 2) {
+		local_flush_tlb_all();
+		return;
+	}
+
+	local_irq_save(flags);
+
+	write_c0_entrylo(0);
+
+	start &= PAGE_MASK;
+	end += (PAGE_SIZE - 1);
+	end &= PAGE_MASK;
+	while (start < end) {
+		signed long idx;
+
+		write_c0_vaddr(start);
+		write_c0_entryhi(start);
+		start += PAGE_SIZE;
+		tlb_probe();
+		idx = read_c0_tlbset();
+		if (idx < 0)
+			continue;
+
+		write_c0_entryhi(CKSEG0 + (idx << (PAGE_SHIFT + 1)));
+		tlb_write();
+	}
+
+	local_irq_restore(flags);
+}
+
+void local_flush_tlb_page(struct vm_area_struct *vma, unsigned long page)
+{
+	int cpu = smp_processor_id();
+	unsigned long flags;
+	int oldpid, newpid;
+	signed long idx;
+
+	if (!cpu_context(cpu, vma->vm_mm))
+		return;
+
+	newpid = cpu_asid(cpu, vma->vm_mm);
+	page &= PAGE_MASK;
+	local_irq_save(flags);
+	oldpid = read_c0_entryhi();
+	write_c0_vaddr(page);
+	write_c0_entryhi(newpid);
+	tlb_probe();
+	idx = read_c0_tlbset();
+	if (idx < 0)
+		goto finish;
+
+	write_c0_entrylo(0);
+	write_c0_entryhi(CKSEG0 + (idx << (PAGE_SHIFT + 1)));
+	tlb_write();
+
+finish:
+	write_c0_entryhi(oldpid);
+	local_irq_restore(flags);
+}
+
+/*
+ * We will need multiple versions of update_mmu_cache(), one that just
+ * updates the TLB with the new pte(s), and another which also checks
+ * for the R4k "end of page" hardware bug and does the needy.
+ */
+void __update_tlb(struct vm_area_struct * vma, unsigned long address, pte_t pte)
+{
+	unsigned long flags;
+	pgd_t *pgdp;
+	pmd_t *pmdp;
+	pte_t *ptep;
+	int pid;
+
+	/*
+	 * Handle debugger faulting in for debugee.
+	 */
+	if (current->active_mm != vma->vm_mm)
+		return;
+
+	pid = read_c0_entryhi() & ASID_MASK;
+
+	local_irq_save(flags);
+	address &= PAGE_MASK;
+	write_c0_vaddr(address);
+	write_c0_entryhi(pid);
+	pgdp = pgd_offset(vma->vm_mm, address);
+	pmdp = pmd_offset(pgdp, address);
+	ptep = pte_offset_map(pmdp, address);
+	tlb_probe();
+
+	write_c0_entrylo(pte_val(*ptep++) >> 6);
+	tlb_write();
+
+	write_c0_entryhi(pid);
+	local_irq_restore(flags);
+}
+
+static void __init probe_tlb(unsigned long config)
+{
+	struct cpuinfo_mips *c = &current_cpu_data;
+
+	c->tlbsize = 3 * 128;		/* 3 sets each 128 entries */
+}
+
+void __init tlb_init(void)
+{
+	unsigned int config = read_c0_config();
+	unsigned long status;
+
+	probe_tlb(config);
+
+	status = read_c0_status();
+	status &= ~(ST0_UPS | ST0_KPS);
+#ifdef CONFIG_PAGE_SIZE_4KB
+	status |= (TFP_PAGESIZE_4K << 32) | (TFP_PAGESIZE_4K << 36);
+#elif defined(CONFIG_PAGE_SIZE_8KB)
+	status |= (TFP_PAGESIZE_8K << 32) | (TFP_PAGESIZE_8K << 36);
+#elif defined(CONFIG_PAGE_SIZE_16KB)
+	status |= (TFP_PAGESIZE_16K << 32) | (TFP_PAGESIZE_16K << 36);
+#elif defined(CONFIG_PAGE_SIZE_64KB)
+	status |= (TFP_PAGESIZE_64K << 32) | (TFP_PAGESIZE_64K << 36);
+#endif
+	write_c0_status(status);
+
+	write_c0_wired(0);
+
+	local_flush_tlb_all();
+
+	memcpy((void *)(CKSEG0 + 0x00), &except_vec0_generic, 0x80);
+	memcpy((void *)(CKSEG0 + 0x80), except_vec1_r8k, 0x80);
+	flush_icache_range(CKSEG0 + 0x80, CKSEG0 + 0x100);
+}
diff -puN arch/mips/mm/tlb-sb1.c~mips-update arch/mips/mm/tlb-sb1.c
--- 25/arch/mips/mm/tlb-sb1.c~mips-update	2004-06-21 23:10:45.359323912 -0700
+++ 25-akpm/arch/mips/mm/tlb-sb1.c	2004-06-21 23:10:45.660278160 -0700
@@ -125,7 +125,7 @@ void local_flush_tlb_all(void)
  * with the firmware, go back and give all the entries invalid addresses with
  * the normal flush routine.  Wired entries will be killed as well!
  */
-void sb1_sanitize_tlb(void)
+static void __init sb1_sanitize_tlb(void)
 {
 	int entry;
 	long addr = 0;
diff -puN arch/mips/momentum/jaguar_atx/prom.c~mips-update arch/mips/momentum/jaguar_atx/prom.c
--- 25/arch/mips/momentum/jaguar_atx/prom.c~mips-update	2004-06-21 23:10:45.360323760 -0700
+++ 25-akpm/arch/mips/momentum/jaguar_atx/prom.c	2004-06-21 23:10:45.661278008 -0700
@@ -245,20 +245,6 @@ void __init prom_fixup_mem_map(unsigned 
 {
 }
 
-/*
- * SMP support
- */
-int prom_setup_smp(void)
-{
-	int	num_cpus = 2;
-
-	/*
-	 * We know that the RM9000 on the Jaguar ATX board has 2 cores.
-	 * Hence, this can be hardcoded for now.
-	 */
-	return num_cpus;
-}
-
 int prom_boot_secondary(int cpu, unsigned long sp, unsigned long gp)
 {
 	/* Clear the semaphore */
diff -puN arch/mips/momentum/jaguar_atx/setup.c~mips-update arch/mips/momentum/jaguar_atx/setup.c
--- 25/arch/mips/momentum/jaguar_atx/setup.c~mips-update	2004-06-21 23:10:45.362323456 -0700
+++ 25-akpm/arch/mips/momentum/jaguar_atx/setup.c	2004-06-21 23:10:45.663277704 -0700
@@ -46,6 +46,7 @@
 #include <linux/types.h>
 #include <linux/mm.h>
 #include <linux/bootmem.h>
+#include <linux/pci.h>
 #include <linux/swap.h>
 #include <linux/ioport.h>
 #include <linux/sched.h>
@@ -57,7 +58,6 @@
 #include <asm/page.h>
 #include <asm/io.h>
 #include <asm/irq.h>
-#include <asm/pci.h>
 #include <asm/pci_channel.h>
 #include <asm/processor.h>
 #include <asm/ptrace.h>
diff -puN arch/mips/momentum/ocelot_c/irq.c~mips-update arch/mips/momentum/ocelot_c/irq.c
--- 25/arch/mips/momentum/ocelot_c/irq.c~mips-update	2004-06-21 23:10:45.364323152 -0700
+++ 25-akpm/arch/mips/momentum/ocelot_c/irq.c	2004-06-21 23:10:45.663277704 -0700
@@ -44,8 +44,9 @@
 #include <asm/bitops.h>
 #include <asm/bootinfo.h>
 #include <asm/io.h>
-#include <asm/irq.h>
+#include <asm/irq_cpu.h>
 #include <asm/mipsregs.h>
+#include <asm/mv64340.h>
 #include <asm/system.h>
 
 extern asmlinkage void ocelot_handle_int(void);
diff -puN arch/mips/momentum/ocelot_c/Makefile~mips-update arch/mips/momentum/ocelot_c/Makefile
--- 25/arch/mips/momentum/ocelot_c/Makefile~mips-update	2004-06-21 23:10:45.366322848 -0700
+++ 25-akpm/arch/mips/momentum/ocelot_c/Makefile	2004-06-21 23:10:45.664277552 -0700
@@ -2,7 +2,7 @@
 # Makefile for Momentum Computer's Ocelot-C and -CS boards.
 #
 
-obj-y	 		+= cpci-irq.o uart-irq.o int-handler.o irq.o pci-irq.o \
-			   prom.o reset.o setup.o
+obj-y	 		+= cpci-irq.o int-handler.o irq.o prom.o reset.o \
+			   setup.o uart-irq.o
 
 obj-$(CONFIG_KGDB)	+= dbg_io.o
diff -L arch/mips/momentum/ocelot_c/pci-irq.c -puN arch/mips/momentum/ocelot_c/pci-irq.c~mips-update /dev/null
--- 25/arch/mips/momentum/ocelot_c/pci-irq.c
+++ /dev/null	2003-09-15 06:40:47.000000000 -0700
@@ -1,72 +0,0 @@
-/*
- * Copyright 2002 Momentum Computer Inc.
- * Author: Matthew Dharm <mdharm@momenco.com> 
- *
- * Based on work for the Linux port to the Ocelot board, which is
- * Copyright 2001 MontaVista Software Inc.
- * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
- *
- * arch/mips/momentum/ocelot_g/pci.c
- *     Board-specific PCI routines for mv64340 controller.
- *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
- */
-#include <linux/types.h>
-#include <linux/pci.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <asm/pci.h>
-
-
-void __init mv64340_board_pcibios_fixup_bus(struct pci_bus *bus)
-{
-	struct pci_bus *current_bus = bus;
-	struct pci_dev *devices;
-	struct list_head *devices_link;
-	u16 cmd;
-
-	/* loop over all known devices on this bus */
-	list_for_each(devices_link, &(current_bus->devices)) {
-
-		devices = pci_dev_b(devices_link);
-		if (devices == NULL)
-			continue;
-
-		if ((current_bus->number == 0) &&
-			(PCI_SLOT(devices->devfn) == 1) &&
-			(PCI_FUNC(devices->devfn) == 0)) {
-			/* LSI 53C10101R SCSI (A) */
-			devices->irq = 2;
-		} else if ((current_bus->number == 0) &&
-			(PCI_SLOT(devices->devfn) == 1) &&
-			(PCI_FUNC(devices->devfn) == 1)) {
-			/* LSI 53C10101R SCSI (B) */
-			devices->irq = 2;
-		} else if ((current_bus->number == 1) &&
-			(PCI_SLOT(devices->devfn) == 1)) {
-			/* Intel 21555 bridge */
-			devices->irq = 12;
-		} else if ((current_bus->number == 1) &&
-			(PCI_SLOT(devices->devfn) == 2)) {
-			/* PMC Slot */
-			devices->irq = 4;
-		} else {
-			/* We don't have assign interrupts for other devices. */
-			devices->irq = 0xff;
-		}
-
-		/* Assign an interrupt number for the device */
-		bus->ops->write_byte(devices, PCI_INTERRUPT_LINE, devices->irq);
-
-		/* enable master for everything but the MV-64340 */
-		if (((current_bus->number != 0) && (current_bus->number != 1))
-				|| (PCI_SLOT(devices->devfn) != 0)) {
-			bus->ops->read_word(devices, PCI_COMMAND, &cmd);
-			cmd |= PCI_COMMAND_MASTER;
-			bus->ops->write_word(devices, PCI_COMMAND, cmd);
-		}
-	}
-}
diff -puN arch/mips/momentum/ocelot_c/prom.c~mips-update arch/mips/momentum/ocelot_c/prom.c
--- 25/arch/mips/momentum/ocelot_c/prom.c~mips-update	2004-06-21 23:10:45.371322088 -0700
+++ 25-akpm/arch/mips/momentum/ocelot_c/prom.c	2004-06-21 23:10:45.666277248 -0700
@@ -147,13 +147,14 @@ char *arg64(unsigned long addrin, int ar
 #endif  /* CONFIG_MIPS64 */
 
 
-/* [jsun@junsun.net] PMON passes arguments in C main() style */
 void __init prom_init(void)
 {
 	int argc = fw_arg0;
 	char **arg = (char **) fw_arg1;
 	char **env = (char **) fw_arg2;
+	struct callvectors *cv = (struct callvectors *) fw_arg3;
 	int i;
+
 #ifdef CONFIG_MIPS64
 	char *ptr;
 
diff -puN arch/mips/momentum/ocelot_c/setup.c~mips-update arch/mips/momentum/ocelot_c/setup.c
--- 25/arch/mips/momentum/ocelot_c/setup.c~mips-update	2004-06-21 23:10:45.373321784 -0700
+++ 25-akpm/arch/mips/momentum/ocelot_c/setup.c	2004-06-21 23:10:45.668276944 -0700
@@ -193,7 +193,7 @@ int m48t37y_set_time(unsigned long sec)
 	rtc_base[0x7ff9] = BIN2BCD(tm.tm_sec);
 
 	/* day of week -- not really used, but let's keep it up-to-date */
-	rtc_base[0x7ffc] = CONV_BIN2BCD(tm.tm_wday + 1);
+	rtc_base[0x7ffc] = BIN2BCD(tm.tm_wday + 1);
 
 	/* disable writing */
 	rtc_base[0x7ff8] = 0x00;
diff -L arch/mips/momentum/ocelot_g/gt64240_dep.h -puN arch/mips/momentum/ocelot_g/gt64240_dep.h~mips-update /dev/null
--- 25/arch/mips/momentum/ocelot_g/gt64240_dep.h
+++ /dev/null	2003-09-15 06:40:47.000000000 -0700
@@ -1,57 +0,0 @@
-/***********************************************************************
- * Copyright 2001 MontaVista Software Inc.
- * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
- *
- * arch/mips/gt64240/gt64240-dep.h
- *     Board-dependent definitions for GT-64120 chip.
- *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
- ***********************************************************************
- */
-
-#ifndef _ASM_GT64240_DEP_H
-#define _ASM_GT64240_DEP_H
-
-#include <asm/addrspace.h>		/* for KSEG1ADDR() */
-#include <asm/byteorder.h>		/* for cpu_to_le32() */
-
-/*
- * PCI address allocation
- */
-#if 0
-#define GT_PCI_MEM_BASE    (0x22000000)
-#define GT_PCI_MEM_SIZE    GT_DEF_PCI0_MEM0_SIZE
-#define GT_PCI_IO_BASE     (0x20000000)
-#define GT_PCI_IO_SIZE     GT_DEF_PCI0_IO_SIZE
-#endif
-
-extern unsigned long gt64240_base;
-
-#define GT64240_BASE       (gt64240_base)
-
-/*
- * Because of an error/peculiarity in the Galileo chip, we need to swap the
- * bytes when running bigendian.
- */
-
-#define GT_WRITE(ofs, data)  \
-        *(volatile u32 *)(GT64240_BASE+(ofs)) = cpu_to_le32(data)
-#define GT_READ(ofs, data)   \
-        *(data) = le32_to_cpu(*(volatile u32 *)(GT64240_BASE+(ofs)))
-#define GT_READ_DATA(ofs)    \
-        le32_to_cpu(*(volatile u32 *)(GT64240_BASE+(ofs)))
-
-#define GT_WRITE_16(ofs, data)  \
-        *(volatile u16 *)(GT64240_BASE+(ofs)) = cpu_to_le16(data)
-#define GT_READ_16(ofs, data)   \
-        *(data) = le16_to_cpu(*(volatile u16 *)(GT64240_BASE+(ofs)))
-
-#define GT_WRITE_8(ofs, data)  \
-        *(volatile u8 *)(GT64240_BASE+(ofs)) = data
-#define GT_READ_8(ofs, data)   \
-        *(data) = *(volatile u8 *)(GT64240_BASE+(ofs))
-
-#endif  /* _ASM_GT64120_MOMENCO_OCELOT_GT64120_DEP_H */
diff -L arch/mips/momentum/ocelot_g/gt64240.h -puN arch/mips/momentum/ocelot_g/gt64240.h~mips-update /dev/null
--- 25/arch/mips/momentum/ocelot_g/gt64240.h
+++ /dev/null	2003-09-15 06:40:47.000000000 -0700
@@ -1,1238 +0,0 @@
-/* gt64240r.h - GT-64240 Internal registers definition file */
-
-/* Copyright - Galileo technology. */
-
-#ifndef __INCgt64240rh
-#define __INCgt64240rh
-
-#define GTREG(v)        (((v) & 0xff) << 24) | (((v) & 0xff00) << 8) | \
-                        (((v) >> 24) & 0xff) | (((v) >> 8) & 0xff00)
-
-#if 0
-#define GTREG_SHORT(X)	(((X) << 8) | ((X) >> 8))
-
-#define LONG_GTREG(X)	((l64) \
-			(((X)&0x00000000000000ffULL) << 56) | \
-			(((X)&0x000000000000ff00ULL) << 40) | \
-			(((X)&0x0000000000ff0000ULL) << 24) | \
-			(((X)&0x00000000ff000000ULL) << 8)  | \
-			(((X)&0x000000ff00000000ULL) >> 8)  | \
-			(((X)&0x0000ff0000000000ULL) >> 24) | \
-			(((X)&0x00ff000000000000ULL) >> 40) | \
-			(((X)&0xff00000000000000ULL) >> 56))
-#endif
-
-#include "gt64240_dep.h"
-
-/****************************************/
-/* CPU Control Registers		*/
-/****************************************/
-
-#define CPU_CONFIGURATION					0x000
-#define CPU_MODE						0x120
-#define CPU_READ_RESPONSE_CROSSBAR_LOW				0x170
-#define CPU_READ_RESPONSE_CROSSBAR_HIGH				0x178
-
-/****************************************/
-/* Processor Address Space		*/
-/****************************************/
-
-/* Sdram's BAR'S */
-#define SCS_0_LOW_DECODE_ADDRESS				0x008
-#define SCS_0_HIGH_DECODE_ADDRESS				0x010
-#define SCS_1_LOW_DECODE_ADDRESS				0x208
-#define SCS_1_HIGH_DECODE_ADDRESS				0x210
-#define SCS_2_LOW_DECODE_ADDRESS				0x018
-#define SCS_2_HIGH_DECODE_ADDRESS				0x020
-#define SCS_3_LOW_DECODE_ADDRESS				0x218
-#define SCS_3_HIGH_DECODE_ADDRESS				0x220
-/* Devices BAR'S */
-#define CS_0_LOW_DECODE_ADDRESS					0x028
-#define CS_0_HIGH_DECODE_ADDRESS				0x030
-#define CS_1_LOW_DECODE_ADDRESS					0x228
-#define CS_1_HIGH_DECODE_ADDRESS				0x230
-#define CS_2_LOW_DECODE_ADDRESS					0x248
-#define CS_2_HIGH_DECODE_ADDRESS				0x250
-#define CS_3_LOW_DECODE_ADDRESS					0x038
-#define CS_3_HIGH_DECODE_ADDRESS				0x040
-#define BOOTCS_LOW_DECODE_ADDRESS				0x238
-#define BOOTCS_HIGH_DECODE_ADDRESS				0x240
-
-#define PCI_0I_O_LOW_DECODE_ADDRESS				0x048
-#define PCI_0I_O_HIGH_DECODE_ADDRESS				0x050
-#define PCI_0MEMORY0_LOW_DECODE_ADDRESS				0x058
-#define PCI_0MEMORY0_HIGH_DECODE_ADDRESS			0x060
-#define PCI_0MEMORY1_LOW_DECODE_ADDRESS				0x080
-#define PCI_0MEMORY1_HIGH_DECODE_ADDRESS			0x088
-#define PCI_0MEMORY2_LOW_DECODE_ADDRESS				0x258
-#define PCI_0MEMORY2_HIGH_DECODE_ADDRESS			0x260
-#define PCI_0MEMORY3_LOW_DECODE_ADDRESS				0x280
-#define PCI_0MEMORY3_HIGH_DECODE_ADDRESS			0x288
-
-#define PCI_1I_O_LOW_DECODE_ADDRESS				0x090
-#define PCI_1I_O_HIGH_DECODE_ADDRESS				0x098
-#define PCI_1MEMORY0_LOW_DECODE_ADDRESS				0x0a0
-#define PCI_1MEMORY0_HIGH_DECODE_ADDRESS			0x0a8
-#define PCI_1MEMORY1_LOW_DECODE_ADDRESS				0x0b0
-#define PCI_1MEMORY1_HIGH_DECODE_ADDRESS			0x0b8
-#define PCI_1MEMORY2_LOW_DECODE_ADDRESS				0x2a0
-#define PCI_1MEMORY2_HIGH_DECODE_ADDRESS			0x2a8
-#define PCI_1MEMORY3_LOW_DECODE_ADDRESS				0x2b0
-#define PCI_1MEMORY3_HIGH_DECODE_ADDRESS			0x2b8
-
-#define INTERNAL_SPACE_DECODE					0x068
-
-#define CPU_0_LOW_DECODE_ADDRESS                            0x290
-#define CPU_0_HIGH_DECODE_ADDRESS                           0x298
-#define CPU_1_LOW_DECODE_ADDRESS                            0x2c0
-#define CPU_1_HIGH_DECODE_ADDRESS                           0x2c8
-
-#define PCI_0I_O_ADDRESS_REMAP					0x0f0
-#define PCI_0MEMORY0_ADDRESS_REMAP  				0x0f8
-#define PCI_0MEMORY0_HIGH_ADDRESS_REMAP				0x320
-#define PCI_0MEMORY1_ADDRESS_REMAP  				0x100
-#define PCI_0MEMORY1_HIGH_ADDRESS_REMAP				0x328
-#define PCI_0MEMORY2_ADDRESS_REMAP  				0x2f8
-#define PCI_0MEMORY2_HIGH_ADDRESS_REMAP				0x330
-#define PCI_0MEMORY3_ADDRESS_REMAP  			  	0x300
-#define PCI_0MEMORY3_HIGH_ADDRESS_REMAP			   	0x338
-
-#define PCI_1I_O_ADDRESS_REMAP					0x108
-#define PCI_1MEMORY0_ADDRESS_REMAP  				0x110
-#define PCI_1MEMORY0_HIGH_ADDRESS_REMAP				0x340
-#define PCI_1MEMORY1_ADDRESS_REMAP  				0x118
-#define PCI_1MEMORY1_HIGH_ADDRESS_REMAP				0x348
-#define PCI_1MEMORY2_ADDRESS_REMAP  				0x310
-#define PCI_1MEMORY2_HIGH_ADDRESS_REMAP				0x350
-#define PCI_1MEMORY3_ADDRESS_REMAP  				0x318
-#define PCI_1MEMORY3_HIGH_ADDRESS_REMAP				0x358
-
-/****************************************/
-/* CPU Sync Barrier             		*/
-/****************************************/
-
-#define PCI_0SYNC_BARIER_VIRTUAL_REGISTER			0x0c0
-#define PCI_1SYNC_BARIER_VIRTUAL_REGISTER			0x0c8
-
-
-/****************************************/
-/* CPU Access Protect             		*/
-/****************************************/
-
-#define CPU_LOW_PROTECT_ADDRESS_0                           0X180
-#define CPU_HIGH_PROTECT_ADDRESS_0                          0X188
-#define CPU_LOW_PROTECT_ADDRESS_1                           0X190
-#define CPU_HIGH_PROTECT_ADDRESS_1                          0X198
-#define CPU_LOW_PROTECT_ADDRESS_2                           0X1a0
-#define CPU_HIGH_PROTECT_ADDRESS_2                          0X1a8
-#define CPU_LOW_PROTECT_ADDRESS_3                           0X1b0
-#define CPU_HIGH_PROTECT_ADDRESS_3                          0X1b8
-#define CPU_LOW_PROTECT_ADDRESS_4                           0X1c0
-#define CPU_HIGH_PROTECT_ADDRESS_4                          0X1c8
-#define CPU_LOW_PROTECT_ADDRESS_5                           0X1d0
-#define CPU_HIGH_PROTECT_ADDRESS_5                          0X1d8
-#define CPU_LOW_PROTECT_ADDRESS_6                           0X1e0
-#define CPU_HIGH_PROTECT_ADDRESS_6                          0X1e8
-#define CPU_LOW_PROTECT_ADDRESS_7                           0X1f0
-#define CPU_HIGH_PROTECT_ADDRESS_7                          0X1f8
-
-
-/****************************************/
-/*          Snoop Control          		*/
-/****************************************/
-
-#define SNOOP_BASE_ADDRESS_0                                0x380
-#define SNOOP_TOP_ADDRESS_0                                 0x388
-#define SNOOP_BASE_ADDRESS_1                                0x390
-#define SNOOP_TOP_ADDRESS_1                                 0x398
-#define SNOOP_BASE_ADDRESS_2                                0x3a0
-#define SNOOP_TOP_ADDRESS_2                                 0x3a8
-#define SNOOP_BASE_ADDRESS_3                                0x3b0
-#define SNOOP_TOP_ADDRESS_3                                 0x3b8
-
-/****************************************/
-/*          CPU Error Report       		*/
-/****************************************/
-
-#define CPU_ERROR_ADDRESS_LOW 				    0x070
-#define CPU_ERROR_ADDRESS_HIGH 				    0x078
-#define CPU_ERROR_DATA_LOW                                  0x128
-#define CPU_ERROR_DATA_HIGH                                 0x130
-#define CPU_ERROR_PARITY                                    0x138
-#define CPU_ERROR_CAUSE                                     0x140
-#define CPU_ERROR_MASK                                      0x148
-
-/****************************************/
-/*          Pslave Debug           		*/
-/****************************************/
-
-#define X_0_ADDRESS                                         0x360
-#define X_0_COMMAND_ID                                      0x368
-#define X_1_ADDRESS                                         0x370
-#define X_1_COMMAND_ID                                      0x378
-#define WRITE_DATA_LOW                                      0x3c0
-#define WRITE_DATA_HIGH                                     0x3c8
-#define WRITE_BYTE_ENABLE                                   0X3e0
-#define READ_DATA_LOW                                       0x3d0
-#define READ_DATA_HIGH                                      0x3d8
-#define READ_ID                                             0x3e8
-
-
-/****************************************/
-/* SDRAM and Device Address Space	*/
-/****************************************/
-
-
-/****************************************/
-/* SDRAM Configuration			*/
-/****************************************/
-
-#define SDRAM_CONFIGURATION	 			0x448
-#define SDRAM_OPERATION_MODE				0x474
-#define SDRAM_ADDRESS_DECODE				0x47C
-#define SDRAM_TIMING_PARAMETERS                         0x4b4
-#define SDRAM_UMA_CONTROL                               0x4a4
-#define SDRAM_CROSS_BAR_CONTROL_LOW                     0x4a8
-#define SDRAM_CROSS_BAR_CONTROL_HIGH                    0x4ac
-#define SDRAM_CROSS_BAR_TIMEOUT                         0x4b0
-
-
-/****************************************/
-/* SDRAM Parameters			*/
-/****************************************/
-
-#define SDRAM_BANK0PARAMETERS				0x44C
-#define SDRAM_BANK1PARAMETERS				0x450
-#define SDRAM_BANK2PARAMETERS				0x454
-#define SDRAM_BANK3PARAMETERS				0x458
-
-
-/****************************************/
-/* SDRAM Error Report 			*/
-/****************************************/
-
-#define SDRAM_ERROR_DATA_LOW                            0x484
-#define SDRAM_ERROR_DATA_HIGH                           0x480
-#define SDRAM_AND_DEVICE_ERROR_ADDRESS                  0x490
-#define SDRAM_RECEIVED_ECC                              0x488
-#define SDRAM_CALCULATED_ECC                            0x48c
-#define SDRAM_ECC_CONTROL                               0x494
-#define SDRAM_ECC_ERROR_COUNTER                         0x498
-
-
-/****************************************/
-/* SDunit Debug (for internal use)	*/
-/****************************************/
-
-#define X0_ADDRESS                                      0x500
-#define X0_COMMAND_AND_ID                               0x504
-#define X0_WRITE_DATA_LOW                               0x508
-#define X0_WRITE_DATA_HIGH                              0x50c
-#define X0_WRITE_BYTE_ENABLE                            0x518
-#define X0_READ_DATA_LOW                                0x510
-#define X0_READ_DATA_HIGH                               0x514
-#define X0_READ_ID                                      0x51c
-#define X1_ADDRESS                                      0x520
-#define X1_COMMAND_AND_ID                               0x524
-#define X1_WRITE_DATA_LOW                               0x528
-#define X1_WRITE_DATA_HIGH                              0x52c
-#define X1_WRITE_BYTE_ENABLE                            0x538
-#define X1_READ_DATA_LOW                                0x530
-#define X1_READ_DATA_HIGH                               0x534
-#define X1_READ_ID                                      0x53c
-#define X0_SNOOP_ADDRESS                                0x540
-#define X0_SNOOP_COMMAND                                0x544
-#define X1_SNOOP_ADDRESS                                0x548
-#define X1_SNOOP_COMMAND                                0x54c
-
-
-/****************************************/
-/* Device Parameters			*/
-/****************************************/
-
-#define DEVICE_BANK0PARAMETERS				0x45c
-#define DEVICE_BANK1PARAMETERS				0x460
-#define DEVICE_BANK2PARAMETERS				0x464
-#define DEVICE_BANK3PARAMETERS				0x468
-#define DEVICE_BOOT_BANK_PARAMETERS			0x46c
-#define DEVICE_CONTROL                                  0x4c0
-#define DEVICE_CROSS_BAR_CONTROL_LOW                    0x4c8
-#define DEVICE_CROSS_BAR_CONTROL_HIGH                   0x4cc
-#define DEVICE_CROSS_BAR_TIMEOUT                        0x4c4
-
-
-/****************************************/
-/* Device Interrupt 			*/
-/****************************************/
-
-#define DEVICE_INTERRUPT_CAUSE                              0x4d0
-#define DEVICE_INTERRUPT_MASK                               0x4d4
-#define DEVICE_ERROR_ADDRESS                                0x4d8
-
-/****************************************/
-/* DMA Record				*/
-/****************************************/
-
-#define CHANNEL0_DMA_BYTE_COUNT					0x800
-#define CHANNEL1_DMA_BYTE_COUNT	 				0x804
-#define CHANNEL2_DMA_BYTE_COUNT	 				0x808
-#define CHANNEL3_DMA_BYTE_COUNT	 				0x80C
-#define CHANNEL4_DMA_BYTE_COUNT					0x900
-#define CHANNEL5_DMA_BYTE_COUNT	 				0x904
-#define CHANNEL6_DMA_BYTE_COUNT	 				0x908
-#define CHANNEL7_DMA_BYTE_COUNT	 				0x90C
-#define CHANNEL0_DMA_SOURCE_ADDRESS				0x810
-#define CHANNEL1_DMA_SOURCE_ADDRESS				0x814
-#define CHANNEL2_DMA_SOURCE_ADDRESS				0x818
-#define CHANNEL3_DMA_SOURCE_ADDRESS				0x81C
-#define CHANNEL4_DMA_SOURCE_ADDRESS				0x910
-#define CHANNEL5_DMA_SOURCE_ADDRESS				0x914
-#define CHANNEL6_DMA_SOURCE_ADDRESS				0x918
-#define CHANNEL7_DMA_SOURCE_ADDRESS				0x91C
-#define CHANNEL0_DMA_DESTINATION_ADDRESS			0x820
-#define CHANNEL1_DMA_DESTINATION_ADDRESS			0x824
-#define CHANNEL2_DMA_DESTINATION_ADDRESS			0x828
-#define CHANNEL3_DMA_DESTINATION_ADDRESS			0x82C
-#define CHANNEL4_DMA_DESTINATION_ADDRESS			0x920
-#define CHANNEL5_DMA_DESTINATION_ADDRESS			0x924
-#define CHANNEL6_DMA_DESTINATION_ADDRESS			0x928
-#define CHANNEL7_DMA_DESTINATION_ADDRESS			0x92C
-#define CHANNEL0NEXT_RECORD_POINTER				0x830
-#define CHANNEL1NEXT_RECORD_POINTER				0x834
-#define CHANNEL2NEXT_RECORD_POINTER				0x838
-#define CHANNEL3NEXT_RECORD_POINTER				0x83C
-#define CHANNEL4NEXT_RECORD_POINTER				0x930
-#define CHANNEL5NEXT_RECORD_POINTER				0x934
-#define CHANNEL6NEXT_RECORD_POINTER				0x938
-#define CHANNEL7NEXT_RECORD_POINTER				0x93C
-#define CHANNEL0CURRENT_DESCRIPTOR_POINTER			0x870
-#define CHANNEL1CURRENT_DESCRIPTOR_POINTER			0x874
-#define CHANNEL2CURRENT_DESCRIPTOR_POINTER			0x878
-#define CHANNEL3CURRENT_DESCRIPTOR_POINTER			0x87C
-#define CHANNEL4CURRENT_DESCRIPTOR_POINTER			0x970
-#define CHANNEL5CURRENT_DESCRIPTOR_POINTER			0x974
-#define CHANNEL6CURRENT_DESCRIPTOR_POINTER			0x978
-#define CHANNEL7CURRENT_DESCRIPTOR_POINTER			0x97C
-#define CHANNEL0_DMA_SOURCE_HIGH_PCI_ADDRESS			0x890
-#define CHANNEL1_DMA_SOURCE_HIGH_PCI_ADDRESS			0x894
-#define CHANNEL2_DMA_SOURCE_HIGH_PCI_ADDRESS			0x898
-#define CHANNEL3_DMA_SOURCE_HIGH_PCI_ADDRESS			0x89c
-#define CHANNEL4_DMA_SOURCE_HIGH_PCI_ADDRESS			0x990
-#define CHANNEL5_DMA_SOURCE_HIGH_PCI_ADDRESS			0x994
-#define CHANNEL6_DMA_SOURCE_HIGH_PCI_ADDRESS			0x998
-#define CHANNEL7_DMA_SOURCE_HIGH_PCI_ADDRESS			0x99c
-#define CHANNEL0_DMA_DESTINATION_HIGH_PCI_ADDRESS		0x8a0
-#define CHANNEL1_DMA_DESTINATION_HIGH_PCI_ADDRESS		0x8a4
-#define CHANNEL2_DMA_DESTINATION_HIGH_PCI_ADDRESS		0x8a8
-#define CHANNEL3_DMA_DESTINATION_HIGH_PCI_ADDRESS		0x8ac
-#define CHANNEL4_DMA_DESTINATION_HIGH_PCI_ADDRESS		0x9a0
-#define CHANNEL5_DMA_DESTINATION_HIGH_PCI_ADDRESS		0x9a4
-#define CHANNEL6_DMA_DESTINATION_HIGH_PCI_ADDRESS		0x9a8
-#define CHANNEL7_DMA_DESTINATION_HIGH_PCI_ADDRESS		0x9ac
-#define CHANNEL0_DMA_NEXT_RECORD_POINTER_HIGH_PCI_ADDRESS	0x8b0
-#define CHANNEL1_DMA_NEXT_RECORD_POINTER_HIGH_PCI_ADDRESS	0x8b4
-#define CHANNEL2_DMA_NEXT_RECORD_POINTER_HIGH_PCI_ADDRESS	0x8b8
-#define CHANNEL3_DMA_NEXT_RECORD_POINTER_HIGH_PCI_ADDRESS	0x8bc
-#define CHANNEL4_DMA_NEXT_RECORD_POINTER_HIGH_PCI_ADDRESS	0x9b0
-#define CHANNEL5_DMA_NEXT_RECORD_POINTER_HIGH_PCI_ADDRESS	0x9b4
-#define CHANNEL6_DMA_NEXT_RECORD_POINTER_HIGH_PCI_ADDRESS	0x9b8
-#define CHANNEL7_DMA_NEXT_RECORD_POINTER_HIGH_PCI_ADDRESS	0x9bc
-
-/****************************************/
-/* DMA Channel Control			*/
-/****************************************/
-
-#define CHANNEL0CONTROL 					0x840
-#define CHANNEL0CONTROL_HIGH					0x880
-
-#define CHANNEL1CONTROL 					0x844
-#define CHANNEL1CONTROL_HIGH					0x884
-
-#define CHANNEL2CONTROL 					0x848
-#define CHANNEL2CONTROL_HIGH					0x888
-
-#define CHANNEL3CONTROL 					0x84C
-#define CHANNEL3CONTROL_HIGH					0x88C
-
-#define CHANNEL4CONTROL 					0x940
-#define CHANNEL4CONTROL_HIGH					0x980
-
-#define CHANNEL5CONTROL 					0x944
-#define CHANNEL5CONTROL_HIGH					0x984
-
-#define CHANNEL6CONTROL 					0x948
-#define CHANNEL6CONTROL_HIGH					0x988
-
-#define CHANNEL7CONTROL 					0x94C
-#define CHANNEL7CONTROL_HIGH					0x98C
-
-
-/****************************************/
-/* DMA Arbiter				*/
-/****************************************/
-
-#define ARBITER_CONTROL_0_3					0x860
-#define ARBITER_CONTROL_4_7					0x960
-
-
-/****************************************/
-/* DMA Interrupt			*/
-/****************************************/
-
-#define CHANELS0_3_INTERRUPT_CAUSE				0x8c0
-#define CHANELS0_3_INTERRUPT_MASK				0x8c4
-#define CHANELS0_3_ERROR_ADDRESS				0x8c8
-#define CHANELS0_3_ERROR_SELECT					0x8cc
-#define CHANELS4_7_INTERRUPT_CAUSE				0x9c0
-#define CHANELS4_7_INTERRUPT_MASK				0x9c4
-#define CHANELS4_7_ERROR_ADDRESS				0x9c8
-#define CHANELS4_7_ERROR_SELECT					0x9cc
-
-
-/****************************************/
-/* DMA Debug (for internal use)         */
-/****************************************/
-
-#define DMA_X0_ADDRESS                                      0x8e0
-#define DMA_X0_COMMAND_AND_ID                               0x8e4
-#define DMA_X0_WRITE_DATA_LOW                               0x8e8
-#define DMA_X0_WRITE_DATA_HIGH                              0x8ec
-#define DMA_X0_WRITE_BYTE_ENABLE                            0x8f8
-#define DMA_X0_READ_DATA_LOW                                0x8f0
-#define DMA_X0_READ_DATA_HIGH                               0x8f4
-#define DMA_X0_READ_ID                                      0x8fc
-#define DMA_X1_ADDRESS                                      0x9e0
-#define DMA_X1_COMMAND_AND_ID                               0x9e4
-#define DMA_X1_WRITE_DATA_LOW                               0x9e8
-#define DMA_X1_WRITE_DATA_HIGH                              0x9ec
-#define DMA_X1_WRITE_BYTE_ENABLE                            0x9f8
-#define DMA_X1_READ_DATA_LOW                                0x9f0
-#define DMA_X1_READ_DATA_HIGH                               0x9f4
-#define DMA_X1_READ_ID                                      0x9fc
-
-/****************************************/
-/* Timer_Counter 						*/
-/****************************************/
-
-#define TIMER_COUNTER0						0x850
-#define TIMER_COUNTER1						0x854
-#define TIMER_COUNTER2						0x858
-#define TIMER_COUNTER3						0x85C
-#define TIMER_COUNTER_0_3_CONTROL				0x864
-#define TIMER_COUNTER_0_3_INTERRUPT_CAUSE			0x868
-#define TIMER_COUNTER_0_3_INTERRUPT_MASK      			0x86c
-#define TIMER_COUNTER4						0x950
-#define TIMER_COUNTER5						0x954
-#define TIMER_COUNTER6						0x958
-#define TIMER_COUNTER7						0x95C
-#define TIMER_COUNTER_4_7_CONTROL				0x964
-#define TIMER_COUNTER_4_7_INTERRUPT_CAUSE			0x968
-#define TIMER_COUNTER_4_7_INTERRUPT_MASK      			0x96c
-
-/****************************************/
-/* PCI Slave Address Decoding           */
-/****************************************/
-
-#define PCI_0SCS_0_BANK_SIZE					0xc08
-#define PCI_1SCS_0_BANK_SIZE					0xc88
-#define PCI_0SCS_1_BANK_SIZE					0xd08
-#define PCI_1SCS_1_BANK_SIZE					0xd88
-#define PCI_0SCS_2_BANK_SIZE					0xc0c
-#define PCI_1SCS_2_BANK_SIZE					0xc8c
-#define PCI_0SCS_3_BANK_SIZE					0xd0c
-#define PCI_1SCS_3_BANK_SIZE					0xd8c
-#define PCI_0CS_0_BANK_SIZE				    	0xc10
-#define PCI_1CS_0_BANK_SIZE				    	0xc90
-#define PCI_0CS_1_BANK_SIZE				    	0xd10
-#define PCI_1CS_1_BANK_SIZE				    	0xd90
-#define PCI_0CS_2_BANK_SIZE				    	0xd18
-#define PCI_1CS_2_BANK_SIZE				    	0xd98
-#define PCI_0CS_3_BANK_SIZE			       		0xc14
-#define PCI_1CS_3_BANK_SIZE			       		0xc94
-#define PCI_0CS_BOOT_BANK_SIZE					0xd14
-#define PCI_1CS_BOOT_BANK_SIZE					0xd94
-#define PCI_0P2P_MEM0_BAR_SIZE                              0xd1c
-#define PCI_1P2P_MEM0_BAR_SIZE                              0xd9c
-#define PCI_0P2P_MEM1_BAR_SIZE                              0xd20
-#define PCI_1P2P_MEM1_BAR_SIZE                              0xda0
-#define PCI_0P2P_I_O_BAR_SIZE                               0xd24
-#define PCI_1P2P_I_O_BAR_SIZE                               0xda4
-#define PCI_0CPU_BAR_SIZE                                   0xd28
-#define PCI_1CPU_BAR_SIZE                                   0xda8
-#define PCI_0DAC_SCS_0_BANK_SIZE                            0xe00
-#define PCI_1DAC_SCS_0_BANK_SIZE                            0xe80
-#define PCI_0DAC_SCS_1_BANK_SIZE                            0xe04
-#define PCI_1DAC_SCS_1_BANK_SIZE                            0xe84
-#define PCI_0DAC_SCS_2_BANK_SIZE                            0xe08
-#define PCI_1DAC_SCS_2_BANK_SIZE                            0xe88
-#define PCI_0DAC_SCS_3_BANK_SIZE                            0xe0c
-#define PCI_1DAC_SCS_3_BANK_SIZE                            0xe8c
-#define PCI_0DAC_CS_0_BANK_SIZE                             0xe10
-#define PCI_1DAC_CS_0_BANK_SIZE                             0xe90
-#define PCI_0DAC_CS_1_BANK_SIZE                             0xe14
-#define PCI_1DAC_CS_1_BANK_SIZE                             0xe94
-#define PCI_0DAC_CS_2_BANK_SIZE                             0xe18
-#define PCI_1DAC_CS_2_BANK_SIZE                             0xe98
-#define PCI_0DAC_CS_3_BANK_SIZE                             0xe1c
-#define PCI_1DAC_CS_3_BANK_SIZE                             0xe9c
-#define PCI_0DAC_BOOTCS_BANK_SIZE                           0xe20
-#define PCI_1DAC_BOOTCS_BANK_SIZE                           0xea0
-#define PCI_0DAC_P2P_MEM0_BAR_SIZE                          0xe24
-#define PCI_1DAC_P2P_MEM0_BAR_SIZE                          0xea4
-#define PCI_0DAC_P2P_MEM1_BAR_SIZE                          0xe28
-#define PCI_1DAC_P2P_MEM1_BAR_SIZE                          0xea8
-#define PCI_0DAC_CPU_BAR_SIZE                               0xe2c
-#define PCI_1DAC_CPU_BAR_SIZE                               0xeac
-#define PCI_0EXPANSION_ROM_BAR_SIZE                         0xd2c
-#define PCI_1EXPANSION_ROM_BAR_SIZE                         0xdac
-#define PCI_0BASE_ADDRESS_REGISTERS_ENABLE 			0xc3c
-#define PCI_1BASE_ADDRESS_REGISTERS_ENABLE 			0xcbc
-#define PCI_0SCS_0_BASE_ADDRESS_REMAP				0xc48
-#define PCI_1SCS_0_BASE_ADDRESS_REMAP				0xcc8
-#define PCI_0SCS_1_BASE_ADDRESS_REMAP				0xd48
-#define PCI_1SCS_1_BASE_ADDRESS_REMAP				0xdc8
-#define PCI_0SCS_2_BASE_ADDRESS_REMAP				0xc4c
-#define PCI_1SCS_2_BASE_ADDRESS_REMAP				0xccc
-#define PCI_0SCS_3_BASE_ADDRESS_REMAP				0xd4c
-#define PCI_1SCS_3_BASE_ADDRESS_REMAP				0xdcc
-#define PCI_0CS_0_BASE_ADDRESS_REMAP				0xc50
-#define PCI_1CS_0_BASE_ADDRESS_REMAP				0xcd0
-#define PCI_0CS_1_BASE_ADDRESS_REMAP				0xd50
-#define PCI_1CS_1_BASE_ADDRESS_REMAP				0xdd0
-#define PCI_0CS_2_BASE_ADDRESS_REMAP				0xd58
-#define PCI_1CS_2_BASE_ADDRESS_REMAP				0xdd8
-#define PCI_0CS_3_BASE_ADDRESS_REMAP           			0xc54
-#define PCI_1CS_3_BASE_ADDRESS_REMAP           			0xcd4
-#define PCI_0CS_BOOTCS_BASE_ADDRESS_REMAP      			0xd54
-#define PCI_1CS_BOOTCS_BASE_ADDRESS_REMAP      			0xdd4
-#define PCI_0P2P_MEM0_BASE_ADDRESS_REMAP_LOW                0xd5c
-#define PCI_1P2P_MEM0_BASE_ADDRESS_REMAP_LOW                0xddc
-#define PCI_0P2P_MEM0_BASE_ADDRESS_REMAP_HIGH               0xd60
-#define PCI_1P2P_MEM0_BASE_ADDRESS_REMAP_HIGH               0xde0
-#define PCI_0P2P_MEM1_BASE_ADDRESS_REMAP_LOW                0xd64
-#define PCI_1P2P_MEM1_BASE_ADDRESS_REMAP_LOW                0xde4
-#define PCI_0P2P_MEM1_BASE_ADDRESS_REMAP_HIGH               0xd68
-#define PCI_1P2P_MEM1_BASE_ADDRESS_REMAP_HIGH               0xde8
-#define PCI_0P2P_I_O_BASE_ADDRESS_REMAP                     0xd6c
-#define PCI_1P2P_I_O_BASE_ADDRESS_REMAP                     0xdec
-#define PCI_0CPU_BASE_ADDRESS_REMAP                         0xd70
-#define PCI_1CPU_BASE_ADDRESS_REMAP                         0xdf0
-#define PCI_0DAC_SCS_0_BASE_ADDRESS_REMAP                   0xf00
-#define PCI_1DAC_SCS_0_BASE_ADDRESS_REMAP                   0xff0
-#define PCI_0DAC_SCS_1_BASE_ADDRESS_REMAP                   0xf04
-#define PCI_1DAC_SCS_1_BASE_ADDRESS_REMAP                   0xf84
-#define PCI_0DAC_SCS_2_BASE_ADDRESS_REMAP                   0xf08
-#define PCI_1DAC_SCS_2_BASE_ADDRESS_REMAP                   0xf88
-#define PCI_0DAC_SCS_3_BASE_ADDRESS_REMAP                   0xf0c
-#define PCI_1DAC_SCS_3_BASE_ADDRESS_REMAP                   0xf8c
-#define PCI_0DAC_CS_0_BASE_ADDRESS_REMAP                    0xf10
-#define PCI_1DAC_CS_0_BASE_ADDRESS_REMAP                    0xf90
-#define PCI_0DAC_CS_1_BASE_ADDRESS_REMAP                    0xf14
-#define PCI_1DAC_CS_1_BASE_ADDRESS_REMAP                    0xf94
-#define PCI_0DAC_CS_2_BASE_ADDRESS_REMAP                    0xf18
-#define PCI_1DAC_CS_2_BASE_ADDRESS_REMAP                    0xf98
-#define PCI_0DAC_CS_3_BASE_ADDRESS_REMAP                    0xf1c
-#define PCI_1DAC_CS_3_BASE_ADDRESS_REMAP                    0xf9c
-#define PCI_0DAC_BOOTCS_BASE_ADDRESS_REMAP                  0xf20
-#define PCI_1DAC_BOOTCS_BASE_ADDRESS_REMAP                  0xfa0
-#define PCI_0DAC_P2P_MEM0_BASE_ADDRESS_REMAP_LOW            0xf24
-#define PCI_1DAC_P2P_MEM0_BASE_ADDRESS_REMAP_LOW            0xfa4
-#define PCI_0DAC_P2P_MEM0_BASE_ADDRESS_REMAP_HIGH           0xf28
-#define PCI_1DAC_P2P_MEM0_BASE_ADDRESS_REMAP_HIGH           0xfa8
-#define PCI_0DAC_P2P_MEM1_BASE_ADDRESS_REMAP_LOW            0xf2c
-#define PCI_1DAC_P2P_MEM1_BASE_ADDRESS_REMAP_LOW            0xfac
-#define PCI_0DAC_P2P_MEM1_BASE_ADDRESS_REMAP_HIGH           0xf30
-#define PCI_1DAC_P2P_MEM1_BASE_ADDRESS_REMAP_HIGH           0xfb0
-#define PCI_0DAC_CPU_BASE_ADDRESS_REMAP                     0xf34
-#define PCI_1DAC_CPU_BASE_ADDRESS_REMAP                     0xfb4
-#define PCI_0EXPANSION_ROM_BASE_ADDRESS_REMAP               0xf38
-#define PCI_1EXPANSION_ROM_BASE_ADDRESS_REMAP               0xfb8
-#define PCI_0ADDRESS_DECODE_CONTROL                         0xd3c
-#define PCI_1ADDRESS_DECODE_CONTROL                         0xdbc
-
-/****************************************/
-/* PCI Control                          */
-/****************************************/
-
-#define PCI_0COMMAND						0xc00
-#define PCI_1COMMAND						0xc80
-#define PCI_0MODE                                           0xd00
-#define PCI_1MODE                                           0xd80
-#define PCI_0TIMEOUT_RETRY					0xc04
-#define PCI_1TIMEOUT_RETRY					0xc84
-#define PCI_0READ_BUFFER_DISCARD_TIMER                      0xd04
-#define PCI_1READ_BUFFER_DISCARD_TIMER                      0xd84
-#define MSI_0TRIGGER_TIMER                                  0xc38
-#define MSI_1TRIGGER_TIMER                                  0xcb8
-#define PCI_0ARBITER_CONTROL                                0x1d00
-#define PCI_1ARBITER_CONTROL                                0x1d80
-/* changing untill here */
-#define PCI_0CROSS_BAR_CONTROL_LOW                           0x1d08
-#define PCI_0CROSS_BAR_CONTROL_HIGH                          0x1d0c
-#define PCI_0CROSS_BAR_TIMEOUT                               0x1d04
-#define PCI_0READ_RESPONSE_CROSS_BAR_CONTROL_LOW             0x1d18
-#define PCI_0READ_RESPONSE_CROSS_BAR_CONTROL_HIGH            0x1d1c
-#define PCI_0SYNC_BARRIER_VIRTUAL_REGISTER                   0x1d10
-#define PCI_0P2P_CONFIGURATION                               0x1d14
-#define PCI_0ACCESS_CONTROL_BASE_0_LOW                       0x1e00
-#define PCI_0ACCESS_CONTROL_BASE_0_HIGH                      0x1e04
-#define PCI_0ACCESS_CONTROL_TOP_0                            0x1e08
-#define PCI_0ACCESS_CONTROL_BASE_1_LOW                       0c1e10
-#define PCI_0ACCESS_CONTROL_BASE_1_HIGH                      0x1e14
-#define PCI_0ACCESS_CONTROL_TOP_1                            0x1e18
-#define PCI_0ACCESS_CONTROL_BASE_2_LOW                       0c1e20
-#define PCI_0ACCESS_CONTROL_BASE_2_HIGH                      0x1e24
-#define PCI_0ACCESS_CONTROL_TOP_2                            0x1e28
-#define PCI_0ACCESS_CONTROL_BASE_3_LOW                       0c1e30
-#define PCI_0ACCESS_CONTROL_BASE_3_HIGH                      0x1e34
-#define PCI_0ACCESS_CONTROL_TOP_3                            0x1e38
-#define PCI_0ACCESS_CONTROL_BASE_4_LOW                       0c1e40
-#define PCI_0ACCESS_CONTROL_BASE_4_HIGH                      0x1e44
-#define PCI_0ACCESS_CONTROL_TOP_4                            0x1e48
-#define PCI_0ACCESS_CONTROL_BASE_5_LOW                       0c1e50
-#define PCI_0ACCESS_CONTROL_BASE_5_HIGH                      0x1e54
-#define PCI_0ACCESS_CONTROL_TOP_5                            0x1e58
-#define PCI_0ACCESS_CONTROL_BASE_6_LOW                       0c1e60
-#define PCI_0ACCESS_CONTROL_BASE_6_HIGH                      0x1e64
-#define PCI_0ACCESS_CONTROL_TOP_6                            0x1e68
-#define PCI_0ACCESS_CONTROL_BASE_7_LOW                       0c1e70
-#define PCI_0ACCESS_CONTROL_BASE_7_HIGH                      0x1e74
-#define PCI_0ACCESS_CONTROL_TOP_7                            0x1e78
-#define PCI_1CROSS_BAR_CONTROL_LOW                           0x1d88
-#define PCI_1CROSS_BAR_CONTROL_HIGH                          0x1d8c
-#define PCI_1CROSS_BAR_TIMEOUT                               0x1d84
-#define PCI_1READ_RESPONSE_CROSS_BAR_CONTROL_LOW             0x1d98
-#define PCI_1READ_RESPONSE_CROSS_BAR_CONTROL_HIGH            0x1d9c
-#define PCI_1SYNC_BARRIER_VIRTUAL_REGISTER                   0x1d90
-#define PCI_1P2P_CONFIGURATION                               0x1d94
-#define PCI_1ACCESS_CONTROL_BASE_0_LOW                       0x1e80
-#define PCI_1ACCESS_CONTROL_BASE_0_HIGH                      0x1e84
-#define PCI_1ACCESS_CONTROL_TOP_0                            0x1e88
-#define PCI_1ACCESS_CONTROL_BASE_1_LOW                       0c1e90
-#define PCI_1ACCESS_CONTROL_BASE_1_HIGH                      0x1e94
-#define PCI_1ACCESS_CONTROL_TOP_1                            0x1e98
-#define PCI_1ACCESS_CONTROL_BASE_2_LOW                       0c1ea0
-#define PCI_1ACCESS_CONTROL_BASE_2_HIGH                      0x1ea4
-#define PCI_1ACCESS_CONTROL_TOP_2                            0x1ea8
-#define PCI_1ACCESS_CONTROL_BASE_3_LOW                       0c1eb0
-#define PCI_1ACCESS_CONTROL_BASE_3_HIGH                      0x1eb4
-#define PCI_1ACCESS_CONTROL_TOP_3                            0x1eb8
-#define PCI_1ACCESS_CONTROL_BASE_4_LOW                       0c1ec0
-#define PCI_1ACCESS_CONTROL_BASE_4_HIGH                      0x1ec4
-#define PCI_1ACCESS_CONTROL_TOP_4                            0x1ec8
-#define PCI_1ACCESS_CONTROL_BASE_5_LOW                       0c1ed0
-#define PCI_1ACCESS_CONTROL_BASE_5_HIGH                      0x1ed4
-#define PCI_1ACCESS_CONTROL_TOP_5                            0x1ed8
-#define PCI_1ACCESS_CONTROL_BASE_6_LOW                       0c1ee0
-#define PCI_1ACCESS_CONTROL_BASE_6_HIGH                      0x1ee4
-#define PCI_1ACCESS_CONTROL_TOP_6                            0x1ee8
-#define PCI_1ACCESS_CONTROL_BASE_7_LOW                       0c1ef0
-#define PCI_1ACCESS_CONTROL_BASE_7_HIGH                      0x1ef4
-#define PCI_1ACCESS_CONTROL_TOP_7                            0x1ef8
-
-/****************************************/
-/* PCI Snoop Control                    */
-/****************************************/
-
-#define PCI_0SNOOP_CONTROL_BASE_0_LOW                        0x1f00
-#define PCI_0SNOOP_CONTROL_BASE_0_HIGH                       0x1f04
-#define PCI_0SNOOP_CONTROL_TOP_0                             0x1f08
-#define PCI_0SNOOP_CONTROL_BASE_1_0_LOW                      0x1f10
-#define PCI_0SNOOP_CONTROL_BASE_1_0_HIGH                     0x1f14
-#define PCI_0SNOOP_CONTROL_TOP_1                             0x1f18
-#define PCI_0SNOOP_CONTROL_BASE_2_0_LOW                      0x1f20
-#define PCI_0SNOOP_CONTROL_BASE_2_0_HIGH                     0x1f24
-#define PCI_0SNOOP_CONTROL_TOP_2                             0x1f28
-#define PCI_0SNOOP_CONTROL_BASE_3_0_LOW                      0x1f30
-#define PCI_0SNOOP_CONTROL_BASE_3_0_HIGH                     0x1f34
-#define PCI_0SNOOP_CONTROL_TOP_3                             0x1f38
-#define PCI_1SNOOP_CONTROL_BASE_0_LOW                        0x1f80
-#define PCI_1SNOOP_CONTROL_BASE_0_HIGH                       0x1f84
-#define PCI_1SNOOP_CONTROL_TOP_0                             0x1f88
-#define PCI_1SNOOP_CONTROL_BASE_1_0_LOW                      0x1f90
-#define PCI_1SNOOP_CONTROL_BASE_1_0_HIGH                     0x1f94
-#define PCI_1SNOOP_CONTROL_TOP_1                             0x1f98
-#define PCI_1SNOOP_CONTROL_BASE_2_0_LOW                      0x1fa0
-#define PCI_1SNOOP_CONTROL_BASE_2_0_HIGH                     0x1fa4
-#define PCI_1SNOOP_CONTROL_TOP_2                             0x1fa8
-#define PCI_1SNOOP_CONTROL_BASE_3_0_LOW                      0x1fb0
-#define PCI_1SNOOP_CONTROL_BASE_3_0_HIGH                     0x1fb4
-#define PCI_1SNOOP_CONTROL_TOP_3                             0x1fb8
-
-/****************************************/
-/* PCI Configuration Address            */
-/****************************************/
-
-#define PCI_0CONFIGURATION_ADDRESS 				0xcf8
-#define PCI_0CONFIGURATION_DATA_VIRTUAL_REGISTER           	0xcfc
-#define PCI_1CONFIGURATION_ADDRESS 				0xc78
-#define PCI_1CONFIGURATION_DATA_VIRTUAL_REGISTER           	0xc7c
-#define PCI_0INTERRUPT_ACKNOWLEDGE_VIRTUAL_REGISTER		0xc34
-#define PCI_1INTERRUPT_ACKNOWLEDGE_VIRTUAL_REGISTER		0xcb4
-
-/****************************************/
-/* PCI Error Report                     */
-/****************************************/
-
-#define PCI_0SERR_MASK						 0xc28
-#define PCI_0ERROR_ADDRESS_LOW                               0x1d40
-#define PCI_0ERROR_ADDRESS_HIGH                              0x1d44
-#define PCI_0ERROR_DATA_LOW                                  0x1d48
-#define PCI_0ERROR_DATA_HIGH                                 0x1d4c
-#define PCI_0ERROR_COMMAND                                   0x1d50
-#define PCI_0ERROR_CAUSE                                     0x1d58
-#define PCI_0ERROR_MASK                                      0x1d5c
-
-#define PCI_1SERR_MASK						 0xca8
-#define PCI_1ERROR_ADDRESS_LOW                               0x1dc0
-#define PCI_1ERROR_ADDRESS_HIGH                              0x1dc4
-#define PCI_1ERROR_DATA_LOW                                  0x1dc8
-#define PCI_1ERROR_DATA_HIGH                                 0x1dcc
-#define PCI_1ERROR_COMMAND                                   0x1dd0
-#define PCI_1ERROR_CAUSE                                     0x1dd8
-#define PCI_1ERROR_MASK                                      0x1ddc
-
-
-/****************************************/
-/* Lslave Debug  (for internal use)     */
-/****************************************/
-
-#define L_SLAVE_X0_ADDRESS                                  0x1d20
-#define L_SLAVE_X0_COMMAND_AND_ID                           0x1d24
-#define L_SLAVE_X1_ADDRESS                                  0x1d28
-#define L_SLAVE_X1_COMMAND_AND_ID                           0x1d2c
-#define L_SLAVE_WRITE_DATA_LOW                              0x1d30
-#define L_SLAVE_WRITE_DATA_HIGH                             0x1d34
-#define L_SLAVE_WRITE_BYTE_ENABLE                           0x1d60
-#define L_SLAVE_READ_DATA_LOW                               0x1d38
-#define L_SLAVE_READ_DATA_HIGH                              0x1d3c
-#define L_SLAVE_READ_ID                                     0x1d64
-
-/****************************************/
-/* PCI Configuration Function 0         */
-/****************************************/
-
-#define PCI_DEVICE_AND_VENDOR_ID 				0x000
-#define PCI_STATUS_AND_COMMAND					0x004
-#define PCI_CLASS_CODE_AND_REVISION_ID			        0x008
-#define PCI_BIST_HEADER_TYPE_LATENCY_TIMER_CACHE_LINE 		0x00C
-#define PCI_SCS_0_BASE_ADDRESS	    				0x010
-#define PCI_SCS_1_BASE_ADDRESS 					0x014
-#define PCI_SCS_2_BASE_ADDRESS 					0x018
-#define PCI_SCS_3_BASE_ADDRESS      				0x01C
-#define PCI_INTERNAL_REGISTERS_MEMORY_MAPPED_BASE_ADDRESS	0x020
-#define PCI_INTERNAL_REGISTERS_I_OMAPPED_BASE_ADDRESS		0x024
-#define PCI_SUBSYSTEM_ID_AND_SUBSYSTEM_VENDOR_ID		0x02C
-#define PCI_EXPANSION_ROM_BASE_ADDRESS_REGISTER			0x030
-#define PCI_CAPABILTY_LIST_POINTER                          0x034
-#define PCI_INTERRUPT_PIN_AND_LINE 			    0x03C
-#define PCI_POWER_MANAGEMENT_CAPABILITY                     0x040
-#define PCI_POWER_MANAGEMENT_STATUS_AND_CONTROL             0x044
-#define PCI_VPD_ADDRESS                                     0x048
-#define PCI_VPD_DATA                                        0X04c
-#define PCI_MSI_MESSAGE_CONTROL                             0x050
-#define PCI_MSI_MESSAGE_ADDRESS                             0x054
-#define PCI_MSI_MESSAGE_UPPER_ADDRESS                       0x058
-#define PCI_MSI_MESSAGE_DATA                                0x05c
-#define PCI_COMPACT_PCI_HOT_SWAP_CAPABILITY                 0x058
-
-/****************************************/
-/* PCI Configuration Function 1         */
-/****************************************/
-
-#define PCI_CS_0_BASE_ADDRESS	    				0x110
-#define PCI_CS_1_BASE_ADDRESS 					0x114
-#define PCI_CS_2_BASE_ADDRESS 					0x118
-#define PCI_CS_3_BASE_ADDRESS     				0x11c
-#define PCI_BOOTCS_BASE_ADDRESS                     	    0x120
-
-/****************************************/
-/* PCI Configuration Function 2         */
-/****************************************/
-
-#define PCI_P2P_MEM0_BASE_ADDRESS	    			0x210
-#define PCI_P2P_MEM1_BASE_ADDRESS 				0x214
-#define PCI_P2P_I_O_BASE_ADDRESS 				0x218
-#define PCI_CPU_BASE_ADDRESS      				0x21c
-
-/****************************************/
-/* PCI Configuration Function 4         */
-/****************************************/
-
-#define PCI_DAC_SCS_0_BASE_ADDRESS_LOW 				0x410
-#define PCI_DAC_SCS_0_BASE_ADDRESS_HIGH			 	0x414
-#define PCI_DAC_SCS_1_BASE_ADDRESS_LOW   			0x418
-#define PCI_DAC_SCS_1_BASE_ADDRESS_HIGH  		    0x41c
-#define PCI_DAC_P2P_MEM0_BASE_ADDRESS_LOW              	    0x420
-#define PCI_DAC_P2P_MEM0_BASE_ADDRESS_HIGH             	    0x424
-
-
-/****************************************/
-/* PCI Configuration Function 5         */
-/****************************************/
-
-#define PCI_DAC_SCS_2_BASE_ADDRESS_LOW 				0x510
-#define PCI_DAC_SCS_2_BASE_ADDRESS_HIGH				0x514
-#define PCI_DAC_SCS_3_BASE_ADDRESS_LOW   		 	0x518
-#define PCI_DAC_SCS_3_BASE_ADDRESS_HIGH  		 	0x51c
-#define PCI_DAC_P2P_MEM1_BASE_ADDRESS_LOW              	    0x520
-#define PCI_DAC_P2P_MEM1_BASE_ADDRESS_HIGH             	    0x524
-
-
-/****************************************/
-/* PCI Configuration Function 6         */
-/****************************************/
-
-#define PCI_DAC_CS_0_BASE_ADDRESS_LOW 				0x610
-#define PCI_DAC_CS_0_BASE_ADDRESS_HIGH				0x614
-#define PCI_DAC_CS_1_BASE_ADDRESS_LOW   			0x618
-#define PCI_DAC_CS_1_BASE_ADDRESS_HIGH  			0x61c
-#define PCI_DAC_CS_2_BASE_ADDRESS_LOW            	        0x620
-#define PCI_DAC_CS_2_BASE_ADDRESS_HIGH           	        0x624
-
-/****************************************/
-/* PCI Configuration Function 7         */
-/****************************************/
-
-#define PCI_DAC_CS_3_BASE_ADDRESS_LOW 				0x710
-#define PCI_DAC_CS_3_BASE_ADDRESS_HIGH			 	0x714
-#define PCI_DAC_BOOTCS_BASE_ADDRESS_LOW   		 	0x718
-#define PCI_DAC_BOOTCS_BASE_ADDRESS_HIGH  			0x71c
-#define PCI_DAC_CPU_BASE_ADDRESS_LOW            	        0x720
-#define PCI_DAC_CPU_BASE_ADDRESS_HIGH           	        0x724
-
-/****************************************/
-/* Interrupts	  			*/
-/****************************************/
-
-#define LOW_INTERRUPT_CAUSE_REGISTER   				0xc18
-#define HIGH_INTERRUPT_CAUSE_REGISTER				0xc68
-#define CPU_INTERRUPT_MASK_REGISTER_LOW				0xc1c
-#define CPU_INTERRUPT_MASK_REGISTER_HIGH			0xc6c
-#define CPU_SELECT_CAUSE_REGISTER				0xc70
-#define PCI_0INTERRUPT_CAUSE_MASK_REGISTER_LOW			0xc24
-#define PCI_0INTERRUPT_CAUSE_MASK_REGISTER_HIGH			0xc64
-#define PCI_0SELECT_CAUSE                                   0xc74
-#define PCI_1INTERRUPT_CAUSE_MASK_REGISTER_LOW			0xca4
-#define PCI_1INTERRUPT_CAUSE_MASK_REGISTER_HIGH			0xce4
-#define PCI_1SELECT_CAUSE                                   0xcf4
-#define CPU_INT_0_MASK                                      0xe60
-#define CPU_INT_1_MASK                                      0xe64
-#define CPU_INT_2_MASK                                      0xe68
-#define CPU_INT_3_MASK                                      0xe6c
-
-/****************************************/
-/* I20 Support registers		*/
-/****************************************/
-
-#define INBOUND_MESSAGE_REGISTER0_PCI0_SIDE			0x010
-#define INBOUND_MESSAGE_REGISTER1_PCI0_SIDE  			0x014
-#define OUTBOUND_MESSAGE_REGISTER0_PCI0_SIDE 			0x018
-#define OUTBOUND_MESSAGE_REGISTER1_PCI0_SIDE  			0x01C
-#define INBOUND_DOORBELL_REGISTER_PCI0_SIDE  			0x020
-#define INBOUND_INTERRUPT_CAUSE_REGISTER_PCI0_SIDE  		0x024
-#define INBOUND_INTERRUPT_MASK_REGISTER_PCI0_SIDE		0x028
-#define OUTBOUND_DOORBELL_REGISTER_PCI0_SIDE 			0x02C
-#define OUTBOUND_INTERRUPT_CAUSE_REGISTER_PCI0_SIDE   		0x030
-#define OUTBOUND_INTERRUPT_MASK_REGISTER_PCI0_SIDE   		0x034
-#define INBOUND_QUEUE_PORT_VIRTUAL_REGISTER_PCI0_SIDE  		0x040
-#define OUTBOUND_QUEUE_PORT_VIRTUAL_REGISTER_PCI0_SIDE   	0x044
-#define QUEUE_CONTROL_REGISTER_PCI0_SIDE 			0x050
-#define QUEUE_BASE_ADDRESS_REGISTER_PCI0_SIDE 			0x054
-#define INBOUND_FREE_HEAD_POINTER_REGISTER_PCI0_SIDE		0x060
-#define INBOUND_FREE_TAIL_POINTER_REGISTER_PCI0_SIDE  		0x064
-#define INBOUND_POST_HEAD_POINTER_REGISTER_PCI0_SIDE 		0x068
-#define INBOUND_POST_TAIL_POINTER_REGISTER_PCI0_SIDE 		0x06C
-#define OUTBOUND_FREE_HEAD_POINTER_REGISTER_PCI0_SIDE		0x070
-#define OUTBOUND_FREE_TAIL_POINTER_REGISTER_PCI0_SIDE		0x074
-#define OUTBOUND_POST_HEAD_POINTER_REGISTER_PCI0_SIDE		0x0F8
-#define OUTBOUND_POST_TAIL_POINTER_REGISTER_PCI0_SIDE		0x0FC
-
-#define INBOUND_MESSAGE_REGISTER0_PCI1_SIDE				0x090
-#define INBOUND_MESSAGE_REGISTER1_PCI1_SIDE  				0x094
-#define OUTBOUND_MESSAGE_REGISTER0_PCI1_SIDE 				0x098
-#define OUTBOUND_MESSAGE_REGISTER1_PCI1_SIDE  				0x09C
-#define INBOUND_DOORBELL_REGISTER_PCI1_SIDE  				0x0A0
-#define INBOUND_INTERRUPT_CAUSE_REGISTER_PCI1_SIDE  		0x0A4
-#define INBOUND_INTERRUPT_MASK_REGISTER_PCI1_SIDE			0x0A8
-#define OUTBOUND_DOORBELL_REGISTER_PCI1_SIDE 				0x0AC
-#define OUTBOUND_INTERRUPT_CAUSE_REGISTER_PCI1_SIDE   		0x0B0
-#define OUTBOUND_INTERRUPT_MASK_REGISTER_PCI1_SIDE   		0x0B4
-#define INBOUND_QUEUE_PORT_VIRTUAL_REGISTER_PCI1_SIDE  		0x0C0
-#define OUTBOUND_QUEUE_PORT_VIRTUAL_REGISTER_PCI1_SIDE   	0x0C4
-#define QUEUE_CONTROL_REGISTER_PCI1_SIDE 				0x0D0
-#define QUEUE_BASE_ADDRESS_REGISTER_PCI1_SIDE 				0x0D4
-#define INBOUND_FREE_HEAD_POINTER_REGISTER_PCI1_SIDE		0x0E0
-#define INBOUND_FREE_TAIL_POINTER_REGISTER_PCI1_SIDE  		0x0E4
-#define INBOUND_POST_HEAD_POINTER_REGISTER_PCI1_SIDE 		0x0E8
-#define INBOUND_POST_TAIL_POINTER_REGISTER_PCI1_SIDE 		0x0EC
-#define OUTBOUND_FREE_HEAD_POINTER_REGISTER_PCI1_SIDE		0x0F0
-#define OUTBOUND_FREE_TAIL_POINTER_REGISTER_PCI1_SIDE		0x0F4
-#define OUTBOUND_POST_HEAD_POINTER_REGISTER_PCI1_SIDE		0x078
-#define OUTBOUND_POST_TAIL_POINTER_REGISTER_PCI1_SIDE		0x07C
-
-#define INBOUND_MESSAGE_REGISTER0_CPU0_SIDE				0X1C10
-#define INBOUND_MESSAGE_REGISTER1_CPU0_SIDE  				0X1C14
-#define OUTBOUND_MESSAGE_REGISTER0_CPU0_SIDE 				0X1C18
-#define OUTBOUND_MESSAGE_REGISTER1_CPU0_SIDE  				0X1C1C
-#define INBOUND_DOORBELL_REGISTER_CPU0_SIDE  				0X1C20
-#define INBOUND_INTERRUPT_CAUSE_REGISTER_CPU0_SIDE  		0X1C24
-#define INBOUND_INTERRUPT_MASK_REGISTER_CPU0_SIDE			0X1C28
-#define OUTBOUND_DOORBELL_REGISTER_CPU0_SIDE 				0X1C2C
-#define OUTBOUND_INTERRUPT_CAUSE_REGISTER_CPU0_SIDE   		0X1C30
-#define OUTBOUND_INTERRUPT_MASK_REGISTER_CPU0_SIDE   		0X1C34
-#define INBOUND_QUEUE_PORT_VIRTUAL_REGISTER_CPU0_SIDE  		0X1C40
-#define OUTBOUND_QUEUE_PORT_VIRTUAL_REGISTER_CPU0_SIDE   	0X1C44
-#define QUEUE_CONTROL_REGISTER_CPU0_SIDE 				0X1C50
-#define QUEUE_BASE_ADDRESS_REGISTER_CPU0_SIDE 				0X1C54
-#define INBOUND_FREE_HEAD_POINTER_REGISTER_CPU0_SIDE		0X1C60
-#define INBOUND_FREE_TAIL_POINTER_REGISTER_CPU0_SIDE  		0X1C64
-#define INBOUND_POST_HEAD_POINTER_REGISTER_CPU0_SIDE 		0X1C68
-#define INBOUND_POST_TAIL_POINTER_REGISTER_CPU0_SIDE 		0X1C6C
-#define OUTBOUND_FREE_HEAD_POINTER_REGISTER_CPU0_SIDE		0X1C70
-#define OUTBOUND_FREE_TAIL_POINTER_REGISTER_CPU0_SIDE		0X1C74
-#define OUTBOUND_POST_HEAD_POINTER_REGISTER_CPU0_SIDE		0X1CF8
-#define OUTBOUND_POST_TAIL_POINTER_REGISTER_CPU0_SIDE		0X1CFC
-
-#define INBOUND_MESSAGE_REGISTER0_CPU1_SIDE				0X1C90
-#define INBOUND_MESSAGE_REGISTER1_CPU1_SIDE  				0X1C94
-#define OUTBOUND_MESSAGE_REGISTER0_CPU1_SIDE 				0X1C98
-#define OUTBOUND_MESSAGE_REGISTER1_CPU1_SIDE  				0X1C9C
-#define INBOUND_DOORBELL_REGISTER_CPU1_SIDE  				0X1CA0
-#define INBOUND_INTERRUPT_CAUSE_REGISTER_CPU1_SIDE  		0X1CA4
-#define INBOUND_INTERRUPT_MASK_REGISTER_CPU1_SIDE			0X1CA8
-#define OUTBOUND_DOORBELL_REGISTER_CPU1_SIDE 				0X1CAC
-#define OUTBOUND_INTERRUPT_CAUSE_REGISTER_CPU1_SIDE   		0X1CB0
-#define OUTBOUND_INTERRUPT_MASK_REGISTER_CPU1_SIDE   		0X1CB4
-#define INBOUND_QUEUE_PORT_VIRTUAL_REGISTER_CPU1_SIDE  		0X1CC0
-#define OUTBOUND_QUEUE_PORT_VIRTUAL_REGISTER_CPU1_SIDE   	0X1CC4
-#define QUEUE_CONTROL_REGISTER_CPU1_SIDE 				0X1CD0
-#define QUEUE_BASE_ADDRESS_REGISTER_CPU1_SIDE 				0X1CD4
-#define INBOUND_FREE_HEAD_POINTER_REGISTER_CPU1_SIDE		0X1CE0
-#define INBOUND_FREE_TAIL_POINTER_REGISTER_CPU1_SIDE  		0X1CE4
-#define INBOUND_POST_HEAD_POINTER_REGISTER_CPU1_SIDE 		0X1CE8
-#define INBOUND_POST_TAIL_POINTER_REGISTER_CPU1_SIDE 		0X1CEC
-#define OUTBOUND_FREE_HEAD_POINTER_REGISTER_CPU1_SIDE		0X1CF0
-#define OUTBOUND_FREE_TAIL_POINTER_REGISTER_CPU1_SIDE		0X1CF4
-#define OUTBOUND_POST_HEAD_POINTER_REGISTER_CPU1_SIDE		0X1C78
-#define OUTBOUND_POST_TAIL_POINTER_REGISTER_CPU1_SIDE		0X1C7C
-
-/****************************************/
-/* Communication Unit Registers         */
-/****************************************/
-
-#define ETHERNET_0_ADDRESS_CONTROL_LOW
-#define ETHERNET_0_ADDRESS_CONTROL_HIGH                     0xf204
-#define ETHERNET_0_RECEIVE_BUFFER_PCI_HIGH_ADDRESS          0xf208
-#define ETHERNET_0_TRANSMIT_BUFFER_PCI_HIGH_ADDRESS         0xf20c
-#define ETHERNET_0_RECEIVE_DESCRIPTOR_PCI_HIGH_ADDRESS      0xf210
-#define ETHERNET_0_TRANSMIT_DESCRIPTOR_PCI_HIGH_ADDRESS     0xf214
-#define ETHERNET_0_HASH_TABLE_PCI_HIGH_ADDRESS              0xf218
-#define ETHERNET_1_ADDRESS_CONTROL_LOW                      0xf220
-#define ETHERNET_1_ADDRESS_CONTROL_HIGH                     0xf224
-#define ETHERNET_1_RECEIVE_BUFFER_PCI_HIGH_ADDRESS          0xf228
-#define ETHERNET_1_TRANSMIT_BUFFER_PCI_HIGH_ADDRESS         0xf22c
-#define ETHERNET_1_RECEIVE_DESCRIPTOR_PCI_HIGH_ADDRESS      0xf230
-#define ETHERNET_1_TRANSMIT_DESCRIPTOR_PCI_HIGH_ADDRESS     0xf234
-#define ETHERNET_1_HASH_TABLE_PCI_HIGH_ADDRESS              0xf238
-#define ETHERNET_2_ADDRESS_CONTROL_LOW                      0xf240
-#define ETHERNET_2_ADDRESS_CONTROL_HIGH                     0xf244
-#define ETHERNET_2_RECEIVE_BUFFER_PCI_HIGH_ADDRESS          0xf248
-#define ETHERNET_2_TRANSMIT_BUFFER_PCI_HIGH_ADDRESS         0xf24c
-#define ETHERNET_2_RECEIVE_DESCRIPTOR_PCI_HIGH_ADDRESS      0xf250
-#define ETHERNET_2_TRANSMIT_DESCRIPTOR_PCI_HIGH_ADDRESS     0xf254
-#define ETHERNET_2_HASH_TABLE_PCI_HIGH_ADDRESS              0xf258
-#define MPSC_0_ADDRESS_CONTROL_LOW                          0xf280
-#define MPSC_0_ADDRESS_CONTROL_HIGH                         0xf284
-#define MPSC_0_RECEIVE_BUFFER_PCI_HIGH_ADDRESS              0xf288
-#define MPSC_0_TRANSMIT_BUFFER_PCI_HIGH_ADDRESS             0xf28c
-#define MPSC_0_RECEIVE_DESCRIPTOR_PCI_HIGH_ADDRESS          0xf290
-#define MPSC_0_TRANSMIT_DESCRIPTOR_PCI_HIGH_ADDRESS         0xf294
-#define MPSC_1_ADDRESS_CONTROL_LOW                          0xf2a0
-#define MPSC_1_ADDRESS_CONTROL_HIGH                         0xf2a4
-#define MPSC_1_RECEIVE_BUFFER_PCI_HIGH_ADDRESS              0xf2a8
-#define MPSC_1_TRANSMIT_BUFFER_PCI_HIGH_ADDRESS             0xf2ac
-#define MPSC_1_RECEIVE_DESCRIPTOR_PCI_HIGH_ADDRESS          0xf2b0
-#define MPSC_1_TRANSMIT_DESCRIPTOR_PCI_HIGH_ADDRESS         0xf2b4
-#define MPSC_2_ADDRESS_CONTROL_LOW                          0xf2c0
-#define MPSC_2_ADDRESS_CONTROL_HIGH                         0xf2c4
-#define MPSC_2_RECEIVE_BUFFER_PCI_HIGH_ADDRESS              0xf2c8
-#define MPSC_2_TRANSMIT_BUFFER_PCI_HIGH_ADDRESS             0xf2cc
-#define MPSC_2_RECEIVE_DESCRIPTOR_PCI_HIGH_ADDRESS          0xf2d0
-#define MPSC_2_TRANSMIT_DESCRIPTOR_PCI_HIGH_ADDRESS         0xf2d4
-#define SERIAL_INIT_PCI_HIGH_ADDRESS                        0xf320
-#define SERIAL_INIT_LAST_DATA                               0xf324
-#define SERIAL_INIT_STATUS_AND_CONTROL                      0xf328
-#define COMM_UNIT_ARBITER_CONTROL                           0xf300
-#define COMM_UNIT_CROSS_BAR_TIMEOUT                         0xf304
-#define COMM_UNIT_INTERRUPT_CAUSE                           0xf310
-#define COMM_UNIT_INTERRUPT_MASK                            0xf314
-#define COMM_UNIT_ERROR_ADDRESS                             0xf314
-
-/****************************************/
-/* Cunit Debug  (for internal use)     */
-/****************************************/
-
-#define CUNIT_ADDRESS                                       0xf340
-#define CUNIT_COMMAND_AND_ID                                0xf344
-#define CUNIT_WRITE_DATA_LOW                                0xf348
-#define CUNIT_WRITE_DATA_HIGH                               0xf34c
-#define CUNIT_WRITE_BYTE_ENABLE                             0xf358
-#define CUNIT_READ_DATA_LOW                                 0xf350
-#define CUNIT_READ_DATA_HIGH                                0xf354
-#define CUNIT_READ_ID                                       0xf35c
-
-/****************************************/
-/* Fast Ethernet Unit Registers         */
-/****************************************/
-
-/* Ethernet */
-
-#define ETHERNET_PHY_ADDRESS_REGISTER                       0x2000
-#define ETHERNET_SMI_REGISTER                               0x2010
-
-/* Ethernet 0 */
-
-#define ETHERNET0_PORT_CONFIGURATION_REGISTER               0x2400
-#define ETHERNET0_PORT_CONFIGURATION_EXTEND_REGISTER        0x2408
-#define ETHERNET0_PORT_COMMAND_REGISTER                     0x2410
-#define ETHERNET0_PORT_STATUS_REGISTER                      0x2418
-#define ETHERNET0_SERIAL_PARAMETRS_REGISTER                 0x2420
-#define ETHERNET0_HASH_TABLE_POINTER_REGISTER               0x2428
-#define ETHERNET0_FLOW_CONTROL_SOURCE_ADDRESS_LOW           0x2430
-#define ETHERNET0_FLOW_CONTROL_SOURCE_ADDRESS_HIGH          0x2438
-#define ETHERNET0_SDMA_CONFIGURATION_REGISTER               0x2440
-#define ETHERNET0_SDMA_COMMAND_REGISTER                     0x2448
-#define ETHERNET0_INTERRUPT_CAUSE_REGISTER                  0x2450
-#define ETHERNET0_INTERRUPT_MASK_REGISTER                   0x2458
-#define ETHERNET0_FIRST_RX_DESCRIPTOR_POINTER0              0x2480
-#define ETHERNET0_FIRST_RX_DESCRIPTOR_POINTER1              0x2484
-#define ETHERNET0_FIRST_RX_DESCRIPTOR_POINTER2              0x2488
-#define ETHERNET0_FIRST_RX_DESCRIPTOR_POINTER3              0x248c
-#define ETHERNET0_CURRENT_RX_DESCRIPTOR_POINTER0            0x24a0
-#define ETHERNET0_CURRENT_RX_DESCRIPTOR_POINTER1            0x24a4
-#define ETHERNET0_CURRENT_RX_DESCRIPTOR_POINTER2            0x24a8
-#define ETHERNET0_CURRENT_RX_DESCRIPTOR_POINTER3            0x24ac
-#define ETHERNET0_CURRENT_TX_DESCRIPTOR_POINTER0            0x24e0
-#define ETHERNET0_CURRENT_TX_DESCRIPTOR_POINTER1            0x24e4
-#define ETHERNET0_MIB_COUNTER_BASE                          0x2500
-
-/* Ethernet 1 */
-
-#define ETHERNET1_PORT_CONFIGURATION_REGISTER               0x2800
-#define ETHERNET1_PORT_CONFIGURATION_EXTEND_REGISTER        0x2808
-#define ETHERNET1_PORT_COMMAND_REGISTER                     0x2810
-#define ETHERNET1_PORT_STATUS_REGISTER                      0x2818
-#define ETHERNET1_SERIAL_PARAMETRS_REGISTER                 0x2820
-#define ETHERNET1_HASH_TABLE_POINTER_REGISTER               0x2828
-#define ETHERNET1_FLOW_CONTROL_SOURCE_ADDRESS_LOW           0x2830
-#define ETHERNET1_FLOW_CONTROL_SOURCE_ADDRESS_HIGH          0x2838
-#define ETHERNET1_SDMA_CONFIGURATION_REGISTER               0x2840
-#define ETHERNET1_SDMA_COMMAND_REGISTER                     0x2848
-#define ETHERNET1_INTERRUPT_CAUSE_REGISTER                  0x2850
-#define ETHERNET1_INTERRUPT_MASK_REGISTER                   0x2858
-#define ETHERNET1_FIRST_RX_DESCRIPTOR_POINTER0              0x2880
-#define ETHERNET1_FIRST_RX_DESCRIPTOR_POINTER1              0x2884
-#define ETHERNET1_FIRST_RX_DESCRIPTOR_POINTER2              0x2888
-#define ETHERNET1_FIRST_RX_DESCRIPTOR_POINTER3              0x288c
-#define ETHERNET1_CURRENT_RX_DESCRIPTOR_POINTER0            0x28a0
-#define ETHERNET1_CURRENT_RX_DESCRIPTOR_POINTER1            0x28a4
-#define ETHERNET1_CURRENT_RX_DESCRIPTOR_POINTER2            0x28a8
-#define ETHERNET1_CURRENT_RX_DESCRIPTOR_POINTER3            0x28ac
-#define ETHERNET1_CURRENT_TX_DESCRIPTOR_POINTER0            0x28e0
-#define ETHERNET1_CURRENT_TX_DESCRIPTOR_POINTER1            0x28e4
-#define ETHERNET1_MIB_COUNTER_BASE                          0x2900
-
-/* Ethernet 2 */
-
-#define ETHERNET2_PORT_CONFIGURATION_REGISTER               0x2c00
-#define ETHERNET2_PORT_CONFIGURATION_EXTEND_REGISTER        0x2c08
-#define ETHERNET2_PORT_COMMAND_REGISTER                     0x2c10
-#define ETHERNET2_PORT_STATUS_REGISTER                      0x2c18
-#define ETHERNET2_SERIAL_PARAMETRS_REGISTER                 0x2c20
-#define ETHERNET2_HASH_TABLE_POINTER_REGISTER               0x2c28
-#define ETHERNET2_FLOW_CONTROL_SOURCE_ADDRESS_LOW           0x2c30
-#define ETHERNET2_FLOW_CONTROL_SOURCE_ADDRESS_HIGH          0x2c38
-#define ETHERNET2_SDMA_CONFIGURATION_REGISTER               0x2c40
-#define ETHERNET2_SDMA_COMMAND_REGISTER                     0x2c48
-#define ETHERNET2_INTERRUPT_CAUSE_REGISTER                  0x2c50
-#define ETHERNET2_INTERRUPT_MASK_REGISTER                   0x2c58
-#define ETHERNET2_FIRST_RX_DESCRIPTOR_POINTER0              0x2c80
-#define ETHERNET2_FIRST_RX_DESCRIPTOR_POINTER1              0x2c84
-#define ETHERNET2_FIRST_RX_DESCRIPTOR_POINTER2              0x2c88
-#define ETHERNET2_FIRST_RX_DESCRIPTOR_POINTER3              0x2c8c
-#define ETHERNET2_CURRENT_RX_DESCRIPTOR_POINTER0            0x2ca0
-#define ETHERNET2_CURRENT_RX_DESCRIPTOR_POINTER1            0x2ca4
-#define ETHERNET2_CURRENT_RX_DESCRIPTOR_POINTER2            0x2ca8
-#define ETHERNET2_CURRENT_RX_DESCRIPTOR_POINTER3            0x2cac
-#define ETHERNET2_CURRENT_TX_DESCRIPTOR_POINTER0            0x2ce0
-#define ETHERNET2_CURRENT_TX_DESCRIPTOR_POINTER1            0x2ce4
-#define ETHERNET2_MIB_COUNTER_BASE                          0x2d00
-
-/****************************************/
-/* SDMA Registers                       */
-/****************************************/
-
-#define SDMA_GROUP_CONFIGURATION_REGISTER                   0xb1f0
-#define CHANNEL0_CONFIGURATION_REGISTER                     0x4000
-#define CHANNEL0_COMMAND_REGISTER                           0x4008
-#define CHANNEL0_RX_CMD_STATUS                              0x4800
-#define CHANNEL0_RX_PACKET_AND_BUFFER_SIZES                 0x4804
-#define CHANNEL0_RX_BUFFER_POINTER                          0x4808
-#define CHANNEL0_RX_NEXT_POINTER                            0x480c
-#define CHANNEL0_CURRENT_RX_DESCRIPTOR_POINTER              0x4810
-#define CHANNEL0_TX_CMD_STATUS                              0x4C00
-#define CHANNEL0_TX_PACKET_SIZE                             0x4C04
-#define CHANNEL0_TX_BUFFER_POINTER                          0x4C08
-#define CHANNEL0_TX_NEXT_POINTER                            0x4C0c
-#define CHANNEL0_CURRENT_TX_DESCRIPTOR_POINTER              0x4c10
-#define CHANNEL0_FIRST_TX_DESCRIPTOR_POINTER                0x4c14
-#define CHANNEL1_CONFIGURATION_REGISTER                     0x6000
-#define CHANNEL1_COMMAND_REGISTER                           0x6008
-#define CHANNEL1_RX_CMD_STATUS                              0x6800
-#define CHANNEL1_RX_PACKET_AND_BUFFER_SIZES                 0x6804
-#define CHANNEL1_RX_BUFFER_POINTER                          0x6808
-#define CHANNEL1_RX_NEXT_POINTER                            0x680c
-#define CHANNEL1_CURRENT_RX_DESCRIPTOR_POINTER              0x6810
-#define CHANNEL1_TX_CMD_STATUS                              0x6C00
-#define CHANNEL1_TX_PACKET_SIZE                             0x6C04
-#define CHANNEL1_TX_BUFFER_POINTER                          0x6C08
-#define CHANNEL1_TX_NEXT_POINTER                            0x6C0c
-#define CHANNEL1_CURRENT_RX_DESCRIPTOR_POINTER              0x6810
-#define CHANNEL1_CURRENT_TX_DESCRIPTOR_POINTER              0x6c10
-#define CHANNEL1_FIRST_TX_DESCRIPTOR_POINTER                0x6c14
-
-/* SDMA Interrupt */
-
-#define SDMA_CAUSE                                          0xb820
-#define SDMA_MASK                                           0xb8a0
-
-
-/****************************************/
-/* Baude Rate Generators Registers      */
-/****************************************/
-
-/* BRG 0 */
-
-#define BRG0_CONFIGURATION_REGISTER                         0xb200
-#define BRG0_BAUDE_TUNING_REGISTER                          0xb204
-
-/* BRG 1 */
-
-#define BRG1_CONFIGURATION_REGISTER                         0xb208
-#define BRG1_BAUDE_TUNING_REGISTER                          0xb20c
-
-/* BRG 2 */
-
-#define BRG2_CONFIGURATION_REGISTER                         0xb210
-#define BRG2_BAUDE_TUNING_REGISTER                          0xb214
-
-/* BRG Interrupts */
-
-#define BRG_CAUSE_REGISTER                                  0xb834
-#define BRG_MASK_REGISTER                                   0xb8b4
-
-/* MISC */
-
-#define MAIN_ROUTING_REGISTER                               0xb400
-#define RECEIVE_CLOCK_ROUTING_REGISTER                      0xb404
-#define TRANSMIT_CLOCK_ROUTING_REGISTER                     0xb408
-#define COMM_UNIT_ARBITER_CONFIGURATION_REGISTER            0xb40c
-#define WATCHDOG_CONFIGURATION_REGISTER                     0xb410
-#define WATCHDOG_VALUE_REGISTER                             0xb414
-
-
-/****************************************/
-/* Flex TDM Registers                   */
-/****************************************/
-
-/* FTDM Port */
-
-#define FLEXTDM_TRANSMIT_READ_POINTER                       0xa800
-#define FLEXTDM_RECEIVE_READ_POINTER                        0xa804
-#define FLEXTDM_CONFIGURATION_REGISTER                      0xa808
-#define FLEXTDM_AUX_CHANNELA_TX_REGISTER                    0xa80c
-#define FLEXTDM_AUX_CHANNELA_RX_REGISTER                    0xa810
-#define FLEXTDM_AUX_CHANNELB_TX_REGISTER                    0xa814
-#define FLEXTDM_AUX_CHANNELB_RX_REGISTER                    0xa818
-
-/* FTDM Interrupts */
-
-#define FTDM_CAUSE_REGISTER                                 0xb830
-#define FTDM_MASK_REGISTER                                  0xb8b0
-
-
-/****************************************/
-/* GPP Interface Registers              */
-/****************************************/
-
-#define GPP_IO_CONTROL                                      0xf100
-#define GPP_LEVEL_CONTROL                                   0xf110
-#define GPP_VALUE                                           0xf104
-#define GPP_INTERRUPT_CAUSE                                 0xf108
-#define GPP_INTERRUPT_MASK                                  0xf10c
-
-#define MPP_CONTROL0                                        0xf000
-#define MPP_CONTROL1                                        0xf004
-#define MPP_CONTROL2                                        0xf008
-#define MPP_CONTROL3                                        0xf00c
-#define DEBUG_PORT_MULTIPLEX                                0xf014
-#define SERIAL_PORT_MULTIPLEX                               0xf010
-
-/****************************************/
-/* I2C Registers                        */
-/****************************************/
-
-#define I2C_SLAVE_ADDRESS                                   0xc000
-#define I2C_EXTENDED_SLAVE_ADDRESS                          0xc040
-#define I2C_DATA                                            0xc004
-#define I2C_CONTROL                                         0xc008
-#define I2C_STATUS_BAUDE_RATE                               0xc00C
-#define I2C_SOFT_RESET                                      0xc01c
-
-/****************************************/
-/* MPSC Registers                       */
-/****************************************/
-
-/* MPSC0  */
-
-#define MPSC0_MAIN_CONFIGURATION_LOW                        0x8000
-#define MPSC0_MAIN_CONFIGURATION_HIGH                       0x8004
-#define MPSC0_PROTOCOL_CONFIGURATION                        0x8008
-#define CHANNEL0_REGISTER1                                  0x800c
-#define CHANNEL0_REGISTER2                                  0x8010
-#define CHANNEL0_REGISTER3                                  0x8014
-#define CHANNEL0_REGISTER4                                  0x8018
-#define CHANNEL0_REGISTER5                                  0x801c
-#define CHANNEL0_REGISTER6                                  0x8020
-#define CHANNEL0_REGISTER7                                  0x8024
-#define CHANNEL0_REGISTER8                                  0x8028
-#define CHANNEL0_REGISTER9                                  0x802c
-#define CHANNEL0_REGISTER10                                 0x8030
-#define CHANNEL0_REGISTER11                                 0x8034
-
-/* MPSC1  */
-
-#define MPSC1_MAIN_CONFIGURATION_LOW                        0x9000
-#define MPSC1_MAIN_CONFIGURATION_HIGH                       0x9004
-#define MPSC1_PROTOCOL_CONFIGURATION                        0x9008
-#define CHANNEL1_REGISTER1                                  0x900c
-#define CHANNEL1_REGISTER2                                  0x9010
-#define CHANNEL1_REGISTER3                                  0x9014
-#define CHANNEL1_REGISTER4                                  0x9018
-#define CHANNEL1_REGISTER5                                  0x901c
-#define CHANNEL1_REGISTER6                                  0x9020
-#define CHANNEL1_REGISTER7                                  0x9024
-#define CHANNEL1_REGISTER8                                  0x9028
-#define CHANNEL1_REGISTER9                                  0x902c
-#define CHANNEL1_REGISTER10                                 0x9030
-#define CHANNEL1_REGISTER11                                 0x9034
-
-/* MPSCs Interupts  */
-
-#define MPSC0_CAUSE                                         0xb804
-#define MPSC0_MASK                                          0xb884
-#define MPSC1_CAUSE                                         0xb80c
-#define MPSC1_MASK                                          0xb88c
-
-#endif /* __INCgt64240rh */
diff -puN arch/mips/momentum/ocelot_g/gt-irq.c~mips-update arch/mips/momentum/ocelot_g/gt-irq.c
--- 25/arch/mips/momentum/ocelot_g/gt-irq.c~mips-update	2004-06-21 23:10:45.379320872 -0700
+++ 25-akpm/arch/mips/momentum/ocelot_g/gt-irq.c	2004-06-21 23:10:45.679275272 -0700
@@ -17,8 +17,8 @@
 #include <asm/ptrace.h>
 #include <linux/sched.h>
 #include <linux/kernel_stat.h>
+#include <asm/gt64240.h>
 #include <asm/io.h>
-#include "gt64240.h"
 
 unsigned long bus_clock;
 
@@ -108,25 +108,25 @@ int disable_galileo_irq(int int_cause, i
  * we keep this particular structure in the function.
  */
 
-static void gt64240_p0int_irq(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t gt64240_p0int_irq(int irq, void *dev, struct pt_regs *regs)
 {
 	uint32_t irq_src, irq_src_mask;
 	int handled;
 
 	/* get the low interrupt cause register */
-	GT_READ(LOW_INTERRUPT_CAUSE_REGISTER, &irq_src);
+	irq_src = GT_READ(LOW_INTERRUPT_CAUSE_REGISTER);
 
 	/* get the mask register for this pin */
-	GT_READ(PCI_0INTERRUPT_CAUSE_MASK_REGISTER_LOW, &irq_src_mask);
+	irq_src_mask = GT_READ(PCI_0INTERRUPT_CAUSE_MASK_REGISTER_LOW);
 
 	/* mask off only the interrupts we're interested in */
 	irq_src = irq_src & irq_src_mask;
 
-	handled = 0;
+	handled = IRQ_NONE;
 
 	/* Check for timer interrupt */
 	if (irq_src & 0x00000100) {
-		handled = 1;
+		handled = IRQ_HANDLED;
 		irq_src &= ~0x00000100;
 
 		/* Clear any pending cause bits */
@@ -141,90 +141,8 @@ static void gt64240_p0int_irq(int irq, v
 		       "UNKNOWN P0_INT# interrupt received, irq_src=0x%x\n",
 		       irq_src);
 	}
-}
-
-/*
- * Interrupt handler for interrupts coming from the Galileo chip.
- * It could be built in ethernet ports etc...
- */
-static void gt64240_irq(int irq, void *dev_id, struct pt_regs *regs)
-{
-	unsigned int irq_src, int_high_src, irq_src_mask,
-	    int_high_src_mask;
-	int handled;
-
-#if 0
-	GT_READ(GT_INTRCAUSE_OFS, &irq_src);
-	GT_READ(GT_INTRMASK_OFS, &irq_src_mask);
-	GT_READ(GT_HINTRCAUSE_OFS, &int_high_src);
-	GT_READ(GT_HINTRMASK_OFS, &int_high_src_mask);
-#endif
-	irq_src = irq_src & irq_src_mask;
-	int_high_src = int_high_src & int_high_src_mask;
-
-	handled = 0;
-
-	/* Execute all interrupt handlers */
-	/* Check for timer interrupt */
-	if (irq_src & 0x00000800) {
-		handled = 1;
-		irq_src &= ~0x00000800;
-		//    RESET_REG_BITS (INTERRUPT_CAUSE_REGISTER,BIT8);
-		do_timer(regs);
-	}
-
-	if (irq_src) {
-		printk(KERN_INFO
-		       "Other Galileo interrupt received irq_src %x\n",
-		       irq_src);
-#if CURRENTLY_UNUSED
-		for (count = 0; count < MAX_CAUSE_REG_WIDTH; count++) {
-			if (irq_src & (1 << count)) {
-				if (irq_handlers[INT_CAUSE_MAIN][count].
-				    routine) {
-					queue_task(&irq_handlers
-						   [INT_CAUSE_MAIN][count],
-						   &tq_immediate);
-					mark_bh(IMMEDIATE_BH);
-					handled = 1;
-				}
-			}
-		}
-#endif				/*  UNUSED  */
-	}
-#if 0
-	GT_WRITE(GT_INTRCAUSE_OFS, 0);
-	GT_WRITE(GT_HINTRCAUSE_OFS, 0);
-#endif
 
-#undef GALILEO_I2O
-#ifdef GALILEO_I2O
-	/*
-	 * Future I2O support.  We currently attach I2O interrupt handlers to
-	 * the Galileo interrupt (int 4) and handle them in do_IRQ.
-	 */
-	if (isInBoundDoorBellInterruptSet()) {
-		printk(KERN_INFO "I2O doorbell interrupt received.\n");
-		handled = 1;
-	}
-
-	if (isInBoundPostQueueInterruptSet()) {
-		printk(KERN_INFO "I2O Queue interrupt received.\n");
-		handled = 1;
-	}
-
-	/*
-	 * This normally would be outside of the ifdef, but since we're
-	 * handling I2O outside of this handler, this printk shows up every
-	 * time we get a valid I2O interrupt.  So turn this off for now.
-	 */
-	if (handled == 0) {
-		if (counter < 50) {
-			printk("Spurious Galileo interrupt...\n");
-			counter++;
-		}
-	}
-#endif
+	return handled;
 }
 
 /*
diff -puN arch/mips/momentum/ocelot_g/Makefile~mips-update arch/mips/momentum/ocelot_g/Makefile
--- 25/arch/mips/momentum/ocelot_g/Makefile~mips-update	2004-06-21 23:10:45.380320720 -0700
+++ 25-akpm/arch/mips/momentum/ocelot_g/Makefile	2004-06-21 23:10:45.680275120 -0700
@@ -2,8 +2,7 @@
 # Makefile for Momentum Computer's Ocelot-G board.
 #
 
-obj-y	 		+= gt-irq.o pci-irq.o int-handler.o irq.o prom.o \
-			   reset.o setup.o
+obj-y	 		+= int-handler.o irq.o gt-irq.o prom.o reset.o setup.o
 obj-$(CONFIG_KGDB)	+= dbg_io.o
 
 EXTRA_AFLAGS := $(CFLAGS)
diff -L arch/mips/momentum/ocelot_g/pci-irq.c -puN arch/mips/momentum/ocelot_g/pci-irq.c~mips-update /dev/null
--- 25/arch/mips/momentum/ocelot_g/pci-irq.c
+++ /dev/null	2003-09-15 06:40:47.000000000 -0700
@@ -1,73 +0,0 @@
-/*
- * Copyright 2002 Momentum Computer Inc.
- * Author: Matthew Dharm <mdharm@momenco.com>
- *
- * Based on work for the Linux port to the Ocelot board, which is
- * Copyright 2001 MontaVista Software Inc.
- * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
- *
- * arch/mips/momentum/ocelot_g/pci.c
- *     Board-specific PCI routines for gt64240 controller.
- *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
- */
-#include <linux/types.h>
-#include <linux/pci.h>
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <asm/pci.h>
-
-
-void __devinit gt64240_board_pcibios_fixup_bus(struct pci_bus *bus)
-{
-	struct pci_bus *current_bus = bus;
-	struct pci_dev *devices;
-	struct list_head *devices_link;
-	u16 cmd;
-
-	/* loop over all known devices on this bus */
-	list_for_each(devices_link, &(current_bus->devices)) {
-
-		devices = pci_dev_b(devices_link);
-		if (devices == NULL)
-			continue;
-
-		if ((current_bus->number == 0) &&
-				PCI_SLOT(devices->devfn) == 1) {
-			/* Intel 82543 Gigabit MAC */
-			devices->irq = 2;       /* irq_nr is 2 for INT0 */
-		} else if ((current_bus->number == 0) &&
-				PCI_SLOT(devices->devfn) == 2) {
-			/* Intel 82543 Gigabit MAC */
-			devices->irq = 3;       /* irq_nr is 3 for INT1 */
-		} else if ((current_bus->number == 1) &&
-				PCI_SLOT(devices->devfn) == 3) {
-			/* Intel 21555 bridge */
-			devices->irq = 5;       /* irq_nr is 8 for INT6 */
-		} else if ((current_bus->number == 1) &&
-				PCI_SLOT(devices->devfn) == 4) {
-			/* PMC Slot */
-			devices->irq = 9;       /* irq_nr is 9 for INT7 */
-		} else {
-			/* We don't have assign interrupts for other devices. */
-			devices->irq = 0xff;
-		}
-
-		/* Assign an interrupt number for the device */
-		bus->ops->write(current_bus, devices,
-			PCI_INTERRUPT_LINE, 1, devices->irq);
-
-		/* enable master for everything but the GT-64240 */
-		if (((current_bus->number != 0) && (current_bus->number != 1))
-				|| (PCI_SLOT(devices->devfn) != 0)) {
-			bus->ops->read(current_bus, devices,
-					PCI_COMMAND, 2, &cmd);
-			cmd |= PCI_COMMAND_MASTER;
-			bus->ops->write(current_bus, devices,
-					PCI_COMMAND, 2, cmd);
-		}
-	}
-}
diff -puN arch/mips/momentum/ocelot_g/prom.c~mips-update arch/mips/momentum/ocelot_g/prom.c
--- 25/arch/mips/momentum/ocelot_g/prom.c~mips-update	2004-06-21 23:10:45.384320112 -0700
+++ 25-akpm/arch/mips/momentum/ocelot_g/prom.c	2004-06-21 23:10:45.682274816 -0700
@@ -20,8 +20,8 @@
 #include <asm/addrspace.h>
 #include <asm/bootinfo.h>
 #include <asm/pmon.h>
+#include <asm/gt64240.h>
 
-#include "gt64240.h"
 #include "ocelot_pld.h"
 
 struct callvectors* debug_vectors;
@@ -38,10 +38,8 @@ const char *get_system_type(void)
 	return "Momentum Ocelot";
 }
 
-/* [jsun@junsun.net] PMON passes arguments in C main() style */
 void __init prom_init(void)
 {
-	uint32_t tmp;
 	int argc = fw_arg0;
 	char **arg = (char **) fw_arg1;
 	char **env = (char **) fw_arg2;
@@ -78,10 +76,8 @@ void __init prom_init(void)
 			bus_clock = simple_strtol(*env + strlen("busclock="),
 							NULL, 10);
 		}
-		*env++;
+		env++;
 	}
-
-	debug_vectors->printf("Booting Linux kernel...\n");
 }
 
 unsigned long __init prom_free_prom_memory(void)
diff -puN arch/mips/momentum/ocelot_g/setup.c~mips-update arch/mips/momentum/ocelot_g/setup.c
--- 25/arch/mips/momentum/ocelot_g/setup.c~mips-update	2004-06-21 23:10:45.386319808 -0700
+++ 25-akpm/arch/mips/momentum/ocelot_g/setup.c	2004-06-21 23:10:45.684274512 -0700
@@ -1,6 +1,4 @@
 /*
- * setup.c
- *
  * BRIEF MODULE DESCRIPTION
  * Momentum Computer Ocelot-G (CP7000G) - board dependent boot routines
  *
@@ -55,14 +53,14 @@
 #include <asm/bootinfo.h>
 #include <asm/page.h>
 #include <asm/io.h>
+#include <asm/gt64240.h>
 #include <asm/irq.h>
 #include <asm/pci.h>
 #include <asm/processor.h>
 #include <asm/ptrace.h>
 #include <asm/reboot.h>
 #include <linux/bootmem.h>
-#include <linux/blkdev.h>
-#include "gt64240.h"
+
 #include "ocelot_pld.h"
 
 #ifdef CONFIG_GALILLEO_GT64240_ETH
@@ -88,8 +86,6 @@ static unsigned long ENTRYLO(unsigned lo
 		_CACHE_UNCACHED)) >> 6;
 }
 
-static void __init setup_l3cache(unsigned long size);
-
 /* setup code for a handoff from a version 2 PMON 2000 PROM */
 void PMON_v2_setup(void)
 {
@@ -104,8 +100,10 @@ void PMON_v2_setup(void)
 		GT64240 Internal Regs	0xf4000000	0xe0000000
 		UARTs (CS2)		0xfd000000	0xe0001000
 	*/
-	add_wired_entry(ENTRYLO(0xf4000000), ENTRYLO(0xf4010000), 0xf4000000, PM_64K);
-	add_wired_entry(ENTRYLO(0xfd000000), ENTRYLO(0xfd001000), 0xfd000000, PM_4K);
+	add_wired_entry(ENTRYLO(0xf4000000), ENTRYLO(0xf4010000),
+	                0xf4000000, PM_64K);
+	add_wired_entry(ENTRYLO(0xfd000000), ENTRYLO(0xfd001000),
+	                0xfd000000, PM_4K);
 
 	/* Also a temporary entry to let us talk to the Ocelot PLD and NVRAM
 	   in the CS[012] region. We can't use ioremap() yet. The NVRAM
@@ -114,15 +112,57 @@ void PMON_v2_setup(void)
 		Ocelot PLD (CS0)	0xfc000000	0xe0020000
 		NVRAM (CS1)		0xfc800000	0xe0030000
 	*/
-	add_temporary_entry(ENTRYLO(0xfc000000), ENTRYLO(0xfc010000), 0xfc000000, PM_64K);
-	add_temporary_entry(ENTRYLO(0xfc800000), ENTRYLO(0xfc810000), 0xfc800000, PM_64K);
+	add_temporary_entry(ENTRYLO(0xfc000000), ENTRYLO(0xfc010000),
+	                    0xfc000000, PM_64K);
+	add_temporary_entry(ENTRYLO(0xfc800000), ENTRYLO(0xfc810000),
+	                    0xfc800000, PM_64K);
 
 	gt64240_base = 0xf4000000;
 }
 
-static void __init momenco_ocelot_g_setup(void)
+extern int rm7k_tcache_enabled;
+
+/*
+ * This runs in KSEG1. See the verbiage in rm7k.c::probe_scache()
+ */
+#define Page_Invalidate_T 0x16
+static void __init setup_l3cache(unsigned long size)
 {
-	void (*l3func)(unsigned long)=KSEG1ADDR(&setup_l3cache);
+	int register i;
+
+	printk("Enabling L3 cache...");
+
+	/* Enable the L3 cache in the GT64120A's CPU Configuration register */
+	GT_WRITE(0, GT_READ(0) | (1<<14));
+
+	/* Enable the L3 cache in the CPU */
+	set_c0_config(1<<12 /* CONF_TE */);
+
+	/* Clear the cache */
+	write_c0_taglo(0);
+	write_c0_taghi(0);
+
+	for (i=0; i < size; i+= 4096) {
+		__asm__ __volatile__ (
+			".set noreorder\n\t"
+			".set mips3\n\t"
+			"cache %1, (%0)\n\t"
+			".set mips0\n\t"
+			".set reorder"
+			:
+			: "r" (KSEG0ADDR(i)),
+			  "i" (Page_Invalidate_T));
+	}
+
+	/* Let the RM7000 MM code know that the tertiary cache is enabled */
+	rm7k_tcache_enabled = 1;
+
+	printk("Done\n");
+}
+
+static int  __init momenco_ocelot_g_setup(void)
+{
+	void (*l3func)(unsigned long) = (void *) KSEG1ADDR(setup_l3cache);
 	unsigned int tmpword;
 
 	board_time_init = gt64240_time_init;
@@ -200,51 +240,11 @@ static void __init momenco_ocelot_g_setu
 
 	/* FIXME: Fix up the DiskOnChip mapping */
 	GT_WRITE(0x468, 0xfef73);
-}
 
-early_initcall(momenco_ocelot_g_setup);
-
-extern int rm7k_tcache_enabled;
-/*
- * This runs in KSEG1. See the verbiage in rm7k.c::probe_scache()
- */
-#define Page_Invalidate_T 0x16
-static void __init setup_l3cache(unsigned long size)
-{
-	int register i;
-	unsigned long tmp;
-
-	printk("Enabling L3 cache...");
-
-	/* Enable the L3 cache in the GT64120A's CPU Configuration register */
-	GT_READ(0, &tmp);
-	GT_WRITE(0, tmp | (1<<14));
-
-	/* Enable the L3 cache in the CPU */
-	set_c0_config(1<<12 /* CONF_TE */);
-
-	/* Clear the cache */
-	write_c0_taglo(0);
-	write_c0_taghi(0);
-
-	for (i=0; i < size; i+= 4096) {
-		__asm__ __volatile__ (
-			".set noreorder\n\t"
-			".set mips3\n\t"
-			"cache %1, (%0)\n\t"
-			".set mips0\n\t"
-			".set reorder"
-			:
-			: "r" (KSEG0ADDR(i)),
-			  "i" (Page_Invalidate_T));
-	}
-
-	/* Let the RM7000 MM code know that the tertiary cache is enabled */
-	rm7k_tcache_enabled = 1;
-
-	printk("Done\n");
+	return 0;
 }
 
+early_initcall(momenco_ocelot_g_setup);
 
 /* This needs to be one of the first initcalls, because no I/O port access
    can work before this */
@@ -252,12 +252,12 @@ static void __init setup_l3cache(unsigne
 static int io_base_ioremap(void)
 {
 	/* we're mapping PCI accesses from 0xc0000000 to 0xf0000000 */
-	void *io_remap_range = ioremap(0xc0000000, 0x30000000);
+	unsigned long io_remap_range;
 
-	if (!io_remap_range) {
+	io_remap_range = (unsigned long) ioremap(0xc0000000, 0x30000000);
+	if (!io_remap_range)
 		panic("Could not ioremap I/O port range");
-	}
-	printk("io_remap_range set at 0x%08x\n", (uint32_t)io_remap_range);
+
 	set_io_port_base(io_remap_range - 0xc0000000);
 
 	return 0;
diff -puN arch/mips/pci/fixup-capcella.c~mips-update arch/mips/pci/fixup-capcella.c
--- 25/arch/mips/pci/fixup-capcella.c~mips-update	2004-06-21 23:10:45.388319504 -0700
+++ 25-akpm/arch/mips/pci/fixup-capcella.c	2004-06-21 23:10:45.685274360 -0700
@@ -1,17 +1,21 @@
 /*
- * FILE NAME
- *	arch/mips/vr41xx/zao-capcella/pci_fixup.c
+ *  fixup-cappcela.c, The ZAO Networks Capcella specific PCI fixups.
  *
- * BRIEF MODULE DESCRIPTION
- *	The ZAO Networks Capcella specific PCI fixups.
+ *  Copyright (C) 2002,2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
  *
- * Copyright 2002 Yoichi Yuasa
- *                yuasa@hh.iij4u.or.jp
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
  *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License as published by the
- *  Free Software Foundation; either version 2 of the License, or (at your
- *  option) any later version.
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 #include <linux/init.h>
 #include <linux/pci.h>
@@ -38,3 +42,7 @@ int __init pcibios_map_irq(struct pci_de
 {
 	return irq_tab_capcella[slot][pin];
 }
+
+struct pci_fixup pcibios_fixups[] __initdata = {
+	{	.pass = 0,	},
+};
diff -puN /dev/null arch/mips/pci/fixup-jaguar.c
--- /dev/null	2003-09-15 06:40:47.000000000 -0700
+++ 25-akpm/arch/mips/pci/fixup-jaguar.c	2004-06-21 23:10:45.686274208 -0700
@@ -0,0 +1,42 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Marvell MV64340 interrupt fixup code.
+ *
+ * Marvell wants an NDA for their docs so this was written without
+ * documentation.  You've been warned.
+ *
+ * Copyright (C) 2004 Ralf Baechle
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+
+#include <asm/mipsregs.h>
+#include <asm/pci_channel.h>
+
+/*
+ * WARNING: Example of how _NOT_ to do it.
+ */
+int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	int bus = dev->bus->number;
+
+	if (bus == 0 && slot == 1)
+		return 3;	/* PCI-X A */
+	if (bus == 0 && slot == 2)
+		return 4;	/* PCI-X B */
+	if (bus == 1 && slot == 1)
+		return 5;	/* PCI A */
+	if (bus == 1 && slot == 2)
+		return 6;	/* PCI B */
+
+return 0;
+	panic("Whooops in pcibios_map_irq");
+}
+
+struct pci_fixup pcibios_fixups[] = {
+	{0}
+};
diff -puN /dev/null arch/mips/pci/fixup-mpc30x.c
--- /dev/null	2003-09-15 06:40:47.000000000 -0700
+++ 25-akpm/arch/mips/pci/fixup-mpc30x.c	2004-06-21 23:10:45.688273904 -0700
@@ -0,0 +1,48 @@
+/*
+ *  fixup-mpc30x.c, The Victor MP-C303/304 specific PCI fixups.
+ *
+ *  Copyright (C) 2002,2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/init.h>
+#include <linux/pci.h>
+
+#include <asm/vr41xx/mpc30x.h>
+#include <asm/vr41xx/vrc4173.h>
+
+static const int internal_func_irqs[] __initdata = {
+	VRC4173_CASCADE_IRQ,
+	VRC4173_AC97_IRQ,
+	VRC4173_USB_IRQ,
+};
+
+static char irq_tab_mpc30x[] __initdata = {
+ [12] = VRC4173_PCMCIA1_IRQ,
+ [13] = VRC4173_PCMCIA2_IRQ,
+ [29] = MQ200_IRQ,
+};
+
+int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	if (slot == 30)
+		return internal_func_irqs[PCI_FUNC(dev->devfn)];
+
+	return irq_tab_mpc30x[slot];
+}
+
+struct pci_fixup pcibios_fixups[] __initdata = {
+	{	.pass = 0,	},
+};
diff -L arch/mips/pci/fixup-mv64340.c -puN arch/mips/pci/fixup-mv64340.c~mips-update /dev/null
--- 25/arch/mips/pci/fixup-mv64340.c
+++ /dev/null	2003-09-15 06:40:47.000000000 -0700
@@ -1,42 +0,0 @@
-/*
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
- *
- * Marvell MV64340 interrupt fixup code.
- *
- * Marvell wants an NDA for their docs so this was written without
- * documentation.  You've been warned.
- *
- * Copyright (C) 2004 Ralf Baechle
- */
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/pci.h>
-
-#include <asm/mipsregs.h>
-#include <asm/pci_channel.h>
-
-/*
- * WARNING: Example of how _NOT_ to do it.
- */
-int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
-{
-	int bus = dev->bus->number;
-
-	if (bus == 0 && slot == 1)
-		return 3;	/* PCI-X A */
-	if (bus == 0 && slot == 2)
-		return 4;	/* PCI-X B */
-	if (bus == 1 && slot == 1)
-		return 5;	/* PCI A */
-	if (bus == 1 && slot == 2)
-		return 6;	/* PCI B */
-
-return 0;
-	panic("Whooops in pcibios_map_irq");
-}
-
-struct pci_fixup pcibios_fixups[] = {
-	{0}
-};
diff -puN /dev/null arch/mips/pci/fixup-ocelot-c.c
--- /dev/null	2003-09-15 06:40:47.000000000 -0700
+++ 25-akpm/arch/mips/pci/fixup-ocelot-c.c	2004-06-21 23:10:45.689273752 -0700
@@ -0,0 +1,39 @@
+/*
+ * Copyright 2002 Momentum Computer Inc.
+ * Author: Matthew Dharm <mdharm@momenco.com>
+ *
+ * Based on work for the Linux port to the Ocelot board, which is
+ * Copyright 2001 MontaVista Software Inc.
+ * Author: Jun Sun, jsun@mvista.com or jsun@junsun.net
+ *
+ * arch/mips/momentum/ocelot_g/pci.c
+ *     Board-specific PCI routines for mv64340 controller.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	int bus = dev->bus->number;
+
+	if (bus == 0 && slot == 1)
+		return 2;       /* PCI-X A */
+	if (bus == 1 && slot == 1)
+		return 12;      /* PCI-X B */
+	if (bus == 1 && slot == 2)
+		return 4;       /* PCI B */
+
+return 0;
+	panic("Whooops in pcibios_map_irq");
+}
+
+struct pci_fixup pcibios_fixups[] = {
+	{0}
+};
diff -puN /dev/null arch/mips/pci/fixup-ocelot-g.c
--- /dev/null	2003-09-15 06:40:47.000000000 -0700
+++ 25-akpm/arch/mips/pci/fixup-ocelot-g.c	2004-06-21 23:10:45.690273600 -0700
@@ -0,0 +1,35 @@
+/*
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * Copyright (C) 2004 Ralf Baechle (ralf@linux-mips.org)
+ */
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	int bus = dev->bus->number;
+
+	if (bus == 0 && slot == 1)	/* Intel 82543 Gigabit MAC */
+		return 2;		/* irq_nr is 2 for INT0 */
+
+	if (bus == 0 && slot == 2)	/* Intel 82543 Gigabit MAC */
+		return 3;		/* irq_nr is 3 for INT1 */
+
+	if (bus == 1 && slot == 3)	/* Intel 21555 bridge */
+		return 5;		/* irq_nr is 8 for INT6 */
+
+	if (bus == 1 && slot == 4)	/* PMC Slot */
+		return 9;		/* irq_nr is 9 for INT7 */
+
+	return -1;
+}
+
+struct pci_fixup pcibios_fixups[] = {
+	{0}
+};
diff -puN /dev/null arch/mips/pci/fixup-tb0219.c
--- /dev/null	2003-09-15 06:40:47.000000000 -0700
+++ 25-akpm/arch/mips/pci/fixup-tb0219.c	2004-06-21 23:10:45.692273296 -0700
@@ -0,0 +1,64 @@
+/*
+ *  fixup-tb0219.c, The TANBAC TB0219 specific PCI fixups.
+ *
+ *  Copyright (C) 2003  Megasolution Inc. <matsu@megasolution.jp>
+ *  Copyright (C) 2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/init.h>
+#include <linux/pci.h>
+
+#include <asm/vr41xx/tb0219.h>
+
+int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
+{
+	int irq = -1;
+
+	switch (slot) {
+	case 12:
+		vr41xx_set_irq_trigger(TB0219_PCI_SLOT1_PIN,
+				       TRIGGER_LEVEL,
+				       SIGNAL_THROUGH);
+		vr41xx_set_irq_level(TB0219_PCI_SLOT1_PIN,
+				     LEVEL_LOW);
+		irq = TB0219_PCI_SLOT1_IRQ;
+		break;
+	case 13:
+		vr41xx_set_irq_trigger(TB0219_PCI_SLOT2_PIN,
+				       TRIGGER_LEVEL,
+				       SIGNAL_THROUGH);
+		vr41xx_set_irq_level(TB0219_PCI_SLOT2_PIN,
+				     LEVEL_LOW);
+		irq = TB0219_PCI_SLOT2_IRQ;
+		break;
+	case 14:
+		vr41xx_set_irq_trigger(TB0219_PCI_SLOT3_PIN,
+				       TRIGGER_LEVEL,
+				       SIGNAL_THROUGH);
+		vr41xx_set_irq_level(TB0219_PCI_SLOT3_PIN,
+				     LEVEL_LOW);
+		irq = TB0219_PCI_SLOT3_IRQ;
+		break;
+	default:
+		break;
+	}
+
+	return irq;
+}
+
+struct pci_fixup pcibios_fixups[] __initdata = {
+	{	.pass = 0,	},
+};
diff -puN arch/mips/pci/fixup-tb0226.c~mips-update arch/mips/pci/fixup-tb0226.c
--- 25/arch/mips/pci/fixup-tb0226.c~mips-update	2004-06-21 23:10:45.392318896 -0700
+++ 25-akpm/arch/mips/pci/fixup-tb0226.c	2004-06-21 23:10:45.693273144 -0700
@@ -1,78 +1,83 @@
 /*
- * FILE NAME
- *	arch/mips/vr41xx/tanbac-tb0226/pci_fixup.c
+ *  fixup-tb0226.c, The TANBAC TB0226 specific PCI fixups.
  *
- * BRIEF MODULE DESCRIPTION
- *	The TANBAC TB0226 specific PCI fixups.
+ *  Copyright (C) 2002-2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
  *
- * Copyright 2002,2003 Yoichi Yuasa
- *                yuasa@hh.iij4u.or.jp
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
  *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License as published by the
- *  Free Software Foundation; either version 2 of the License, or (at your
- *  option) any later version.
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 #include <linux/init.h>
 #include <linux/pci.h>
 
 #include <asm/vr41xx/tb0226.h>
 
-void __init pcibios_fixup_irqs(void)
+int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
 {
-	struct pci_dev *dev = NULL;
-	u8 slot, pin;
-
-	while ((dev = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, dev)) != NULL) {
-		slot = PCI_SLOT(dev->devfn);
-		dev->irq = 0;
+	int irq = -1;
 
-		switch (slot) {
-		case 12:
-			vr41xx_set_irq_trigger(GD82559_1_PIN,
+	switch (slot) {
+	case 12:
+		vr41xx_set_irq_trigger(GD82559_1_PIN,
+				       TRIGGER_LEVEL,
+				       SIGNAL_THROUGH);
+		vr41xx_set_irq_level(GD82559_1_PIN, LEVEL_LOW);
+		irq = GD82559_1_IRQ;
+		break;
+	case 13:
+		vr41xx_set_irq_trigger(GD82559_2_PIN,
+				       TRIGGER_LEVEL,
+				       SIGNAL_THROUGH);
+		vr41xx_set_irq_level(GD82559_2_PIN, LEVEL_LOW);
+		irq = GD82559_2_IRQ;
+		break;
+	case 14:
+		switch (pin) {
+		case 1:
+			vr41xx_set_irq_trigger(UPD720100_INTA_PIN,
+					       TRIGGER_LEVEL,
+					       SIGNAL_THROUGH);
+			vr41xx_set_irq_level(UPD720100_INTA_PIN,
+					     LEVEL_LOW);
+			irq = UPD720100_INTA_IRQ;
+			break;
+		case 2:
+			vr41xx_set_irq_trigger(UPD720100_INTB_PIN,
 					       TRIGGER_LEVEL,
 					       SIGNAL_THROUGH);
-			vr41xx_set_irq_level(GD82559_1_PIN, LEVEL_LOW);
-			dev->irq = GD82559_1_IRQ;
+			vr41xx_set_irq_level(UPD720100_INTB_PIN,
+					     LEVEL_LOW);
+			irq = UPD720100_INTB_IRQ;
 			break;
-		case 13:
-			vr41xx_set_irq_trigger(GD82559_2_PIN,
+		case 3:
+			vr41xx_set_irq_trigger(UPD720100_INTC_PIN,
 					       TRIGGER_LEVEL,
 					       SIGNAL_THROUGH);
-			vr41xx_set_irq_level(GD82559_2_PIN, LEVEL_LOW);
-			dev->irq = GD82559_2_IRQ;
+			vr41xx_set_irq_level(UPD720100_INTC_PIN,
+					     LEVEL_LOW);
+			irq = UPD720100_INTC_IRQ;
 			break;
-		case 14:
-			pci_read_config_byte(dev, PCI_INTERRUPT_PIN, &pin);
-			switch (pin) {
-			case 1:
-				vr41xx_set_irq_trigger(UPD720100_INTA_PIN,
-						       TRIGGER_LEVEL,
-						       SIGNAL_THROUGH);
-				vr41xx_set_irq_level(UPD720100_INTA_PIN,
-						     LEVEL_LOW);
-				dev->irq = UPD720100_INTA_IRQ;
-				break;
-			case 2:
-				vr41xx_set_irq_trigger(UPD720100_INTB_PIN,
-						       TRIGGER_LEVEL,
-						       SIGNAL_THROUGH);
-				vr41xx_set_irq_level(UPD720100_INTB_PIN,
-						     LEVEL_LOW);
-				dev->irq = UPD720100_INTB_IRQ;
-				break;
-			case 3:
-				vr41xx_set_irq_trigger(UPD720100_INTC_PIN,
-						       TRIGGER_LEVEL,
-						       SIGNAL_THROUGH);
-				vr41xx_set_irq_level(UPD720100_INTC_PIN,
-						     LEVEL_LOW);
-				dev->irq = UPD720100_INTC_IRQ;
-				break;
-			}
+		default:
 			break;
 		}
-
-		pci_write_config_byte(dev, PCI_INTERRUPT_LINE, dev->irq);
+		break;
+	default:
+		break;
 	}
+
+	return irq;
 }
+
+struct pci_fixup pcibios_fixups[] __initdata = {
+	{	.pass = 0,	},
+};
diff -L arch/mips/pci/fixup-tb0229.c -puN arch/mips/pci/fixup-tb0229.c~mips-update /dev/null
--- 25/arch/mips/pci/fixup-tb0229.c
+++ /dev/null	2003-09-15 06:40:47.000000000 -0700
@@ -1,64 +0,0 @@
-/*
- * FILE NAME
- *	arch/mips/vr41xx/tanbac-tb0229/pci_fixup.c
- *
- * BRIEF MODULE DESCRIPTION
- *	The TANBAC TB0229(VR4131DIMM) specific PCI fixups.
- *
- * Copyright 2003 Megasolution Inc.
- *                matsu@megasolution.jp
- *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License as published by the
- *  Free Software Foundation; either version 2 of the License, or (at your
- *  option) any later version.
- */
-#include <linux/config.h>
-#include <linux/init.h>
-#include <linux/pci.h>
-
-#include <asm/vr41xx/tb0229.h>
-
-void __init pcibios_fixup_irqs(void)
-{
-#ifdef CONFIG_TANBAC_TB0219
-	struct pci_dev *dev = NULL;
-	u8 slot;
-
-	while ((dev = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, dev)) != NULL) {
-		slot = PCI_SLOT(dev->devfn);
-		dev->irq = 0;
-
-		switch (slot) {
-		case 12:
-			vr41xx_set_irq_trigger(TB0219_PCI_SLOT1_PIN,
-					       TRIGGER_LEVEL,
-					       SIGNAL_THROUGH);
-			vr41xx_set_irq_level(TB0219_PCI_SLOT1_PIN,
-					     LEVEL_LOW);
-			dev->irq = TB0219_PCI_SLOT1_IRQ;
-			break;
-		case 13:
-			vr41xx_set_irq_trigger(TB0219_PCI_SLOT2_PIN,
-					       TRIGGER_LEVEL,
-					       SIGNAL_THROUGH);
-			vr41xx_set_irq_level(TB0219_PCI_SLOT2_PIN,
-					     LEVEL_LOW);
-			dev->irq = TB0219_PCI_SLOT2_IRQ;
-			break;
-		case 14:
-			vr41xx_set_irq_trigger(TB0219_PCI_SLOT3_PIN,
-					       TRIGGER_LEVEL,
-					       SIGNAL_THROUGH);
-			vr41xx_set_irq_level(TB0219_PCI_SLOT3_PIN,
-					     LEVEL_LOW);
-			dev->irq = TB0219_PCI_SLOT3_IRQ;
-			break;
-		default:
-			break;
-		}
-
-		pci_write_config_byte(dev, PCI_INTERRUPT_LINE, dev->irq);
-	}
-#endif
-}
diff -L arch/mips/pci/fixup-victor-mpc30x.c -puN arch/mips/pci/fixup-victor-mpc30x.c~mips-update /dev/null
--- 25/arch/mips/pci/fixup-victor-mpc30x.c
+++ /dev/null	2003-09-15 06:40:47.000000000 -0700
@@ -1,48 +0,0 @@
-/*
- * FILE NAME
- *	arch/mips/vr41xx/victor-mpc30x/pci_fixup.c
- *
- * BRIEF MODULE DESCRIPTION
- *	The Victor MP-C303/304 specific PCI fixups.
- *
- * Copyright 2002 Yoichi Yuasa
- *                yuasa@hh.iij4u.or.jp
- *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License as published by the
- *  Free Software Foundation; either version 2 of the License, or (at your
- *  option) any later version.
- */
-#include <linux/init.h>
-#include <linux/pci.h>
-
-#include <asm/vr41xx/vrc4173.h>
-#include <asm/vr41xx/mpc30x.h>
-
-/*
- * Shortcuts
- */
-#define PCMCIA1	VRC4173_PCMCIA1_IRQ
-#define PCMCIA2	VRC4173_PCMCIA2_IRQ
-#define MQ	MQ200_IRQ
-
-static const int internal_func_irqs[8] __initdata = {
-	VRC4173_CASCADE_IRQ,
-	VRC4173_AC97_IRQ,
-	VRC4173_USB_IRQ,
-	
-};
-
-static char irq_tab_mpc30x[][5] __initdata = {
- [12] = { PCMCIA1, PCMCIA1, 0, 0 },
- [13] = { PCMCIA2, PCMCIA2, 0, 0 },
- [29] = {      MQ,      MQ, 0, 0 },		/* mediaQ MQ-200 */
-};
-
-int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
-{
-	if (slot == 30)
-		return internal_func_irqs[PCI_FUNC(dev->devfn)];
-
-	return irq_tab_mpc30x[slot][pin];
-}
diff -puN arch/mips/pci/fixup-yosemite.c~mips-update arch/mips/pci/fixup-yosemite.c
--- 25/arch/mips/pci/fixup-yosemite.c~mips-update	2004-06-21 23:10:45.399317832 -0700
+++ 25-akpm/arch/mips/pci/fixup-yosemite.c	2004-06-21 23:10:45.695272840 -0700
@@ -26,21 +26,12 @@
 #include <linux/init.h>
 #include <linux/pci.h>
 
-static char irq_tab_yosemite[8][5] __initdata = {
-	/*       INTA  INTB  INTC  INTD */
-	{    -1,   -1,   -1,   -1,   -1 },
-	{    -1,    3,    3,    3,    3 },
-	{    -1,    4,    4,    4,    4 },
-	{    -1,   -1,   -1,   -1,   -1 },
-	{    -1,   -1,   -1,   -1,   -1 },
-	{    -1,   -1,   -1,   -1,   -1 },
-	{    -1,   -1,   -1,   -1,   -1 },
-	{    -1,   -1,   -1,   -1,   -1 },
-};
-
 int __init pcibios_map_irq(struct pci_dev *dev, u8 slot, u8 pin)
 {
-	return irq_tab_yosemite[slot][pin];
+	if (pin == 0)
+		return -1;
+
+	return 3;			/* Everything goes to one irq bit */
 }
 
 struct pci_fixup pcibios_fixups[] = {
diff -puN arch/mips/pci/Makefile~mips-update arch/mips/pci/Makefile
--- 25/arch/mips/pci/Makefile~mips-update	2004-06-21 23:10:45.401317528 -0700
+++ 25-akpm/arch/mips/pci/Makefile	2004-06-21 23:10:45.697272536 -0700
@@ -16,6 +16,7 @@ obj-$(CONFIG_MIPS_MV64340)	+= ops-mv6434
 obj-$(CONFIG_MIPS_MSC)		+= ops-msc.o
 obj-$(CONFIG_MIPS_NILE4)	+= ops-nile4.o
 obj-$(CONFIG_MIPS_TX3927)	+= ops-jmr3927.o
+obj-$(CONFIG_PCI_VR41XX)	+= ops-vr41xx.o pci-vr41xx.o
 
 #
 # These are still pretty much in the old state, watch, go blind.
@@ -34,20 +35,20 @@ obj-$(CONFIG_MIPS_IVR)		+= fixup-ivr.o
 obj-$(CONFIG_SOC_AU1500)	+= fixup-au1000.o ops-au1000.o
 obj-$(CONFIG_SOC_AU1550)	+= fixup-au1000.o ops-au1000.o
 obj-$(CONFIG_MIPS_MALTA)	+= fixup-malta.o
-obj-$(CONFIG_MIPS_MV64340)	+= fixup-mv64340.o
+obj-$(CONFIG_MOMENCO_JAGUAR_ATX)+= fixup-jaguar.o
 obj-$(CONFIG_MOMENCO_OCELOT)	+= fixup-ocelot.o pci-ocelot.o
-obj-$(CONFIG_MOMENCO_OCELOT_C)	+= pci-ocelot-c.o
-obj-$(CONFIG_MOMENCO_OCELOT_G)	+= pci-ocelot-g.o
+obj-$(CONFIG_MOMENCO_OCELOT_C)	+= fixup-ocelot-c.o pci-ocelot-c.o
+obj-$(CONFIG_MOMENCO_OCELOT_G)	+= fixup-ocelot-g.o ops-gt64240.o pci-ocelot-g.o
 obj-$(CONFIG_NEC_EAGLE)		+= fixup-eagle.o ops-vrc4173.o
-obj-$(CONFIG_PMC_YOSEMITE)	+= fixup-yosemite.o ops-titan.o
+obj-$(CONFIG_PMC_YOSEMITE)	+= fixup-yosemite.o ops-titan.o ops-titan-ht.o \
+				   pci-yosemite.o
 obj-$(CONFIG_SGI_IP27)		+= pci-ip27.o
 obj-$(CONFIG_SGI_IP32)		+= fixup-ip32.o ops-mace.o pci-ip32.o
 obj-$(CONFIG_SIBYTE_SB1250)	+= pci-sb1250.o
 obj-$(CONFIG_SNI_RM200_PCI)	+= fixup-sni.o ops-sni.o
+obj-$(CONFIG_TANBAC_TB0219)	+= fixup-tb0219.o
 obj-$(CONFIG_TANBAC_TB0226)	+= fixup-tb0226.o
-obj-$(CONFIG_TANBAC_TB0229)	+= fixup-tb0229.o
 obj-$(CONFIG_TOSHIBA_JMR3927)	+= fixup-jmr3927.o pci-jmr3927.o
 obj-$(CONFIG_TOSHIBA_RBTX4927)	+= fixup-rbtx4927.o ops-tx4927.o
-obj-$(CONFIG_VICTOR_MPC30X)	+= fixup-capcella.o
-obj-$(CONFIG_MACH_VR41XX)	+= pci-vr41xx.o
-obj-$(CONFIG_ZAO_CAPCELLA)	+= fixup-victor-mpc30x.o
+obj-$(CONFIG_VICTOR_MPC30X)	+= fixup-mpc30x.o
+obj-$(CONFIG_ZAO_CAPCELLA)	+= fixup-capcella.o
diff -puN /dev/null arch/mips/pci/ops-gt64240.c
--- /dev/null	2003-09-15 06:40:47.000000000 -0700
+++ 25-akpm/arch/mips/pci/ops-gt64240.c	2004-06-21 23:10:45.698272384 -0700
@@ -0,0 +1,149 @@
+/*
+ * Copyright 2002 Momentum Computer
+ * Author: Matthew Dharm <mdharm@momenco.com>
+ * Copyright (C) 2004 Ralf Baechle <ralf@linux-mips.org>
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+#include <asm/gt64240.h>
+
+
+#define MASTER_ABORT_BIT 0x100
+
+/*
+ * galileo_pcibios_(read/write)_config_(dword/word/byte) -
+ *
+ * reads/write a dword/word/byte register from the configuration space
+ * of a device.
+ *
+ * Note that bus 0 and bus 1 are local, and we assume all other busses are
+ * bridged from bus 1.  This is a safe assumption, since any other
+ * configuration will require major modifications to the CP7000G
+ *
+ * Inputs :
+ * bus - bus number
+ * dev - device number
+ * offset - register offset in the configuration space
+ * val - value to be written / read
+ *
+ * Outputs :
+ * PCIBIOS_SUCCESSFUL when operation was succesfull
+ * PCIBIOS_DEVICE_NOT_FOUND when the bus or dev is errorneous
+ * PCIBIOS_BAD_REGISTER_NUMBER when accessing non aligned
+ */
+
+
+static int gt_read_config(struct pci_bus *bus, unsigned int devfn, int offset,
+	int size, u32 *val, u32 address_reg, u32 data_reg)
+{
+	uint32_t address;
+	int dev, busno;
+
+	busno = bus->number;
+	dev = PCI_SLOT(devfn);
+
+	/* verify the range */
+	if (dev == 31)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	address = (busno << 16) | (devfn << 8) | (offset & 0xfc) | 0x80000000;
+
+	/* start the configuration cycle */
+	GT_WRITE(address_reg, address);
+
+	switch (size) {
+	case 1:
+		GT_READ_8(data_reg + (offset & 0x3), val);
+		break;
+	case 2:
+		GT_READ_16(data_reg + (offset & 0x3), val);
+		break;
+	case 4:
+		*val = GT_READ(data_reg);
+		break;
+	}
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int gt_write_config(struct pci_bus *bus, unsigned int devfn, int offset,
+	int size, u32 val, u32 address_reg, u32 data_reg)
+{
+	unsigned int address;
+	int dev, busno;
+
+	busno = bus->number;
+	dev = PCI_SLOT(devfn);
+
+	/* verify the range */
+	if (dev == 31)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	address = (busno << 16) | (devfn << 8) | (offset & 0xfc) | 0x80000000;
+
+	/* start the configuration cycle */
+	GT_WRITE(address_reg, address);
+
+	switch (size) {
+	case 1:
+		GT_WRITE_8(data_reg + (offset & 0x3), val);
+		break;
+	case 2:
+		GT_WRITE_16(data_reg + (offset & 0x3), val);
+		break;
+	case 4:
+		GT_WRITE(data_reg, val);
+		break;
+	}
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+#define BUILD_PCI_OPS(host)						\
+									\
+static int gt_bus ## host ## _read_config(struct pci_bus *bus,		\
+	unsigned int devfn, int reg, int size, u32 * val)		\
+{									\
+	return gt_read_config(bus, devfn, reg, size, val,		\
+		PCI_ ## host ## CONFIGURATION_ADDRESS,			\
+		PCI_ ## host ## CONFIGURATION_DATA_VIRTUAL_REGISTER);	\
+}									\
+									\
+static int gt_bus ## host ## _write_config(struct pci_bus *bus,		\
+	unsigned int devfn, int reg, int size, u32 val)			\
+{									\
+	return gt_write_config(bus, devfn, reg, size, val,		\
+		PCI_ ## host ## CONFIGURATION_ADDRESS,			\
+		PCI_ ## host ## CONFIGURATION_DATA_VIRTUAL_REGISTER);	\
+}									\
+									\
+struct pci_ops gt_bus ## host ## _pci_ops = {				\
+	.read	= gt_bus ## host ## _read_config,			\
+	.write	= gt_bus ## host ## _write_config			\
+};
+
+BUILD_PCI_OPS(0)
+BUILD_PCI_OPS(1)
diff -puN arch/mips/pci/ops-msc.c~mips-update arch/mips/pci/ops-msc.c
--- 25/arch/mips/pci/ops-msc.c~mips-update	2004-06-21 23:10:45.404317072 -0700
+++ 25-akpm/arch/mips/pci/ops-msc.c	2004-06-21 23:10:45.700272080 -0700
@@ -48,8 +48,12 @@ static int msc_pcibios_config_access(uns
 	unsigned char type;
 	u32 intr;
 
-	if ((busnum == 0) && (PCI_SLOT(devfn) == 0))
+#ifdef CONFIG_MIPS_BOARDS_GEN
+	if ((busnum == 0) && (PCI_SLOT(devfn) == 17)) {
+		/* MIPS Core boards have SOCit connected as device 17 */
 		return -1;
+	}
+#endif
 
 	/* Clear status register bits. */
 	MSC_WRITE(MSC01_PCI_INTSTAT,
diff -puN arch/mips/pci/ops-titan.c~mips-update arch/mips/pci/ops-titan.c
--- 25/arch/mips/pci/ops-titan.c~mips-update	2004-06-21 23:10:45.405316920 -0700
+++ 25-akpm/arch/mips/pci/ops-titan.c	2004-06-21 23:10:45.702271776 -0700
@@ -39,30 +39,30 @@
 static int titan_read_config(struct pci_bus *bus, unsigned int devfn, int reg,
 	int size, u32 * val)
 {
-	int dev, bus, func;
+	int dev, busno, func;
 	uint32_t address_reg, data_reg;
 	uint32_t address;
 
-	bus = device->bus->number;
-	dev = PCI_SLOT(device->devfn);
-	func = PCI_FUNC(device->devfn);
+	busno = bus->number;
+	dev = PCI_SLOT(devfn);
+	func = PCI_FUNC(devfn);
 
 	address_reg = TITAN_PCI_0_CONFIG_ADDRESS;
 	data_reg = TITAN_PCI_0_CONFIG_DATA;
 
-	address = (bus << 16) | (dev << 11) | (func << 8) |
-		(offset & 0xfc) | 0x80000000;
+	address = (busno << 16) | (dev << 11) | (func << 8) |
+	          (reg & 0xfc) | 0x80000000;
 
 	/* start the configuration cycle */
 	TITAN_WRITE(address_reg, address);
 
 	switch (size) {
 	case 1:
-		TITAN_READ_8(data_reg + (offset & 0x3), val);
+		TITAN_READ_8(data_reg + (reg & 0x3), val);
 		break;
 
 	case 2:
-		TITAN_READ_16(data_reg + (offset & 0x2), val);
+		TITAN_READ_16(data_reg + (reg & 0x2), val);
 		break;
 
 	case 4:
@@ -80,17 +80,17 @@ static int titan_write_config(struct pci
 	int size, u32 val)
 {
 	uint32_t address_reg, data_reg, address;
-	int dev, bus, func;
+	int dev, busno, func;
 
-	bus = device->bus->number;
-	dev = PCI_SLOT(device->devfn);
-	func = PCI_FUNC(device->devfn);
+	busno = bus->number;
+	dev = PCI_SLOT(devfn);
+	func = PCI_FUNC(devfn);
 
 	address_reg = TITAN_PCI_0_CONFIG_ADDRESS;
 	data_reg = TITAN_PCI_0_CONFIG_DATA;
 
-	address = (bus << 16) | (dev << 11) | (func << 8) |
-		(offset & 0xfc) | 0x80000000;
+	address = (busno << 16) | (dev << 11) | (func << 8) |
+		(reg & 0xfc) | 0x80000000;
 
 	/* start the configuration cycle */
 	TITAN_WRITE(address_reg, address);
@@ -98,11 +98,11 @@ static int titan_write_config(struct pci
 	/* write the data */
 	switch (size) {
 	case 1:
-		TITAN_WRITE_8(data_reg + (offset & 0x3), val);
+		TITAN_WRITE_8(data_reg + (reg & 0x3), val);
 		break;
 
 	case 2:
-		TITAN_WRITE_16(data_reg + (offset & 0x2), val);
+		TITAN_WRITE_16(data_reg + (reg & 0x2), val);
 		break;
 
 	case 4:
diff -puN /dev/null arch/mips/pci/ops-titan-ht.c
--- /dev/null	2003-09-15 06:40:47.000000000 -0700
+++ 25-akpm/arch/mips/pci/ops-titan-ht.c	2004-06-21 23:10:45.704271472 -0700
@@ -0,0 +1,125 @@
+/*
+ * Copyright 2003 PMC-Sierra
+ * Author: Manish Lachwani (lachwani@pmc-sierra.com)
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <asm/io.h>
+
+#include <asm/titan_dep.h>
+
+static int titan_ht_config_read_dword(struct pci_bus *bus, unsigned int devfn,
+	int offset, u32 * val)
+{
+	volatile uint32_t address;
+	int busno;
+
+	busno = bus->number;
+
+	address = (busno << 16) | (devfn << 8) | (offset & 0xfc) | 0x80000000;
+	if (busno != 0)
+		address |= 1;
+
+	/*
+	 * RM9000 HT Errata: Issue back to back HT config
+	 * transcations. Issue a BIU sync before and
+	 * after the HT cycle
+	 */
+
+	*(volatile int32_t *) 0xfb0000f0 |= 0x2;
+
+	udelay(30);
+
+	*(volatile int32_t *) 0xfb0006f8 = address;
+	*(val) = *(volatile int32_t *) 0xfb0006fc;
+
+	udelay(30);
+
+	* (volatile int32_t *) 0xfb0000f0 |= 0x2;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int titan_ht_config_read(struct pci_bus *bus, unsigned int devfn,
+	int offset, int size, u32 * val)
+{
+	uint32_t dword;
+
+	titan_ht_config_read_dword(bus, devfn, offset, &dword);
+
+	dword >>= ((offset & 3) << 3);
+	dword &= (0xffffffffU >> ((4 - size) << 8));
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static inline int titan_ht_config_write_dword(struct pci_bus *bus,
+	unsigned int devfn, int offset, u32 val)
+{
+	volatile uint32_t address;
+	int busno;
+
+	busno = bus->number;
+
+	address = (busno << 16) | (devfn << 8) | (offset & 0xfc) | 0x80000000;
+	if (busno != 0)
+		address |= 1;
+
+	*(volatile int32_t *) 0xfb0000f0 |= 0x2;
+
+	udelay(30);
+
+	*(volatile int32_t *) 0xfb0006f8 = address;
+	*(volatile int32_t *) 0xfb0006fc = val;
+
+	udelay(30);
+
+	*(volatile int32_t *) 0xfb0000f0 |= 0x2;
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int titan_ht_config_write(struct pci_bus *bus, unsigned int devfn,
+	int offset, int size, u32 val)
+{
+	uint32_t val1, val2, mask;
+
+	titan_ht_config_read_dword(bus, devfn, offset, &val2);
+
+	val1 = val << ((offset & 3) << 3);
+	mask = ~(0xffffffffU >> ((4 - size) << 8));
+	val2 &= ~(mask << ((offset & 3) << 8));
+
+	titan_ht_config_write_dword(bus, devfn, offset, val1 | val2);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+struct pci_ops titan_ht_pci_ops = {
+	.read	= titan_ht_config_read,
+	.write	= titan_ht_config_write,
+};
diff -puN /dev/null arch/mips/pci/ops-vr41xx.c
--- /dev/null	2003-09-15 06:40:47.000000000 -0700
+++ 25-akpm/arch/mips/pci/ops-vr41xx.c	2004-06-21 23:10:45.705271320 -0700
@@ -0,0 +1,126 @@
+/*
+ *  ops-vr41xx.c, PCI configuration routines for the PCIU of NEC VR4100 series.
+ *
+ *  Copyright (C) 2001-2003 MontaVista Software Inc.
+ *    Author: Yoichi Yuasa <yyuasa@mvista.com or source@mvista.com>
+ *  Copyright (C) 2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/*
+ * Changes:
+ *  MontaVista Software Inc. <yyuasa@mvista.com> or <source@mvista.com>
+ *  - New creation, NEC VR4122 and VR4131 are supported.
+ */
+#include <linux/pci.h>
+#include <linux/types.h>
+
+#include <asm/io.h>
+
+#define PCICONFDREG	KSEG1ADDR(0x0f000c14)
+#define PCICONFAREG	KSEG1ADDR(0x0f000c18)
+
+static inline int set_pci_configuration_address(unsigned char number,
+                                                unsigned int devfn, int where)
+{
+	if (number == 0) {
+		/*
+		 * Type 0 configuration
+		 */
+		if (PCI_SLOT(devfn) < 11 || where > 0xff)
+			return -EINVAL;
+
+		writel((1U << PCI_SLOT(devfn)) | (PCI_FUNC(devfn) << 8) |
+		       (where & 0xfc), PCICONFAREG);
+	} else {
+		/*
+		 * Type 1 configuration
+		 */
+		if (where > 0xff)
+			return -EINVAL;
+
+		writel(((uint32_t)number << 16) | ((devfn & 0xff) << 8) |
+		       (where & 0xfc) | 1U, PCICONFAREG);
+	}
+
+	return 0;
+}
+
+static int pci_config_read(struct pci_bus *bus, unsigned int devfn, int where,
+                           int size, uint32_t *val)
+{
+	uint32_t data;
+
+	*val = 0xffffffffU;
+	if (set_pci_configuration_address(bus->number, devfn, where) < 0)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	data = readl(PCICONFDREG);
+
+	switch (size) {
+	case 1:
+		*val = (data >> ((where & 3) << 3)) & 0xffU;
+		break;
+	case 2:
+		*val = (data >> ((where & 2) << 3)) & 0xffffU;
+		break;
+	case 4:
+		*val = data;
+		break;
+	default:
+		return PCIBIOS_FUNC_NOT_SUPPORTED;
+	}
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int pci_config_write(struct pci_bus *bus, unsigned int devfn, int where,
+                            int size, uint32_t val)
+{
+	uint32_t data;
+	int shift;
+
+	if (set_pci_configuration_address(bus->number, devfn, where) < 0)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	data = readl(PCICONFDREG);
+
+	switch (size) {
+	case 1:
+		shift = (where & 3) << 3;
+		data &= ~(0xffU << shift);
+		data |= ((val & 0xffU) << shift);
+		break;
+	case 2:
+		shift = (where & 2) << 3;
+		data &= ~(0xffffU << shift);
+		data |= ((val & 0xffffU) << shift);
+		break;
+	case 4:
+		data = val;
+		break;
+	default:
+		return PCIBIOS_FUNC_NOT_SUPPORTED;
+	}
+
+	writel(data, PCICONFDREG);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+struct pci_ops vr41xx_pci_ops = {
+	.read	= pci_config_read,
+	.write	= pci_config_write,
+};
diff -puN arch/mips/pci/pci.c~mips-update arch/mips/pci/pci.c
--- 25/arch/mips/pci/pci.c~mips-update	2004-06-21 23:10:45.408316464 -0700
+++ 25-akpm/arch/mips/pci/pci.c	2004-06-21 23:10:45.707271016 -0700
@@ -231,7 +231,7 @@ static void __init pcibios_fixup_device_
 {
 	/* Update device resources.  */
 	struct pci_controller *hose = (struct pci_controller *)bus->sysdata;
-	unsigned long offset;
+	unsigned long offset = 0;
 	int i;
 
 	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
diff -puN arch/mips/pci/pci-ocelot-c.c~mips-update arch/mips/pci/pci-ocelot-c.c
--- 25/arch/mips/pci/pci-ocelot-c.c~mips-update	2004-06-21 23:10:45.409316312 -0700
+++ 25-akpm/arch/mips/pci/pci-ocelot-c.c	2004-06-21 23:10:45.708270864 -0700
@@ -1,61 +1,140 @@
 /*
- * Copyright 2002 Momentum Computer
- * Author: Matthew Dharm <mdharm@momenco.com>
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
  *
- *  This program is free software; you can redistribute  it and/or modify it
- *  under  the terms of  the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the  License, or (at your
- *  option) any later version.
- *
- *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
- *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
- *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
- *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
- *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
- *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *  You should have received a copy of the  GNU General Public License along
- *  with this program; if not, write  to the Free Software Foundation, Inc.,
- *  675 Mass Ave, Cambridge, MA 02139, USA.
+ * Copyright (C) 2004 by Ralf Baechle
  */
+
 #include <linux/types.h>
 #include <linux/pci.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <asm/pci.h>
-#include <asm/io.h>
 #include <asm/mv64340.h>
+#include <asm/pci_channel.h>
 
 #include <linux/init.h>
 
 /*
- * These functions and structures provide the BIOS scan and mapping of the PCI
- * devices.
+ * We assume the address ranges have already been setup appropriately by
+ * the firmware.  PMON in case of the Ocelot C does that.
  */
+static struct resource mv_pci_io_mem0_resource = {
+	.name	= "MV64340 PCI0 IO MEM",
+	.flags	= IORESOURCE_IO
+};
 
-void mv64340_board_pcibios_fixup_bus(struct pci_bus *c);
+static struct resource mv_pci_mem0_resource = {
+	.name	= "MV64340 PCI0 MEM",
+	.flags	= IORESOURCE_MEM
+};
+
+extern struct pci_ops mv64340_bus0_pci_ops;
 
-struct pci_fixup pcibios_fixups[] = {
-	{0}
+static struct pci_controller mv_bus0_controller = {
+	.pci_ops	= &mv64340_bus0_pci_ops,
+	.mem_resource	= &mv_pci_mem0_resource,
+	.io_resource	= &mv_pci_io_mem0_resource,
 };
 
-void __init pcibios_fixup_bus(struct pci_bus *c)
+static uint32_t mv_io_base, mv_io_size;
+
+static void mv64340_pci0_init(void)
 {
-	mv64340_board_pcibios_fixup_bus(c);
+	uint32_t mem0_base, mem0_size;
+	uint32_t io_base, io_size;
+
+	io_base = MV_READ(MV64340_PCI_0_IO_BASE_ADDR) << 16;
+	io_size = (MV_READ(MV64340_PCI_0_IO_SIZE) + 1) << 16;
+	mem0_base = MV_READ(MV64340_PCI_0_MEMORY0_BASE_ADDR) << 16;
+	mem0_size = (MV_READ(MV64340_PCI_0_MEMORY0_SIZE) + 1) << 16;
+
+	mv_pci_io_mem0_resource.start	= 0;
+	mv_pci_io_mem0_resource.end	= io_size - 1;
+	mv_pci_mem0_resource.start	= mem0_base;
+	mv_pci_mem0_resource.end	= mem0_base + mem0_size - 1;
+	mv_bus0_controller.mem_offset	= mem0_base;
+	mv_bus0_controller.io_offset	= 0;
+
+	ioport_resource.end		= io_size - 1;
+
+	register_pci_controller(&mv_bus0_controller);
+
+	mv_io_base = io_base;
+	mv_io_size = io_size;
 }
 
-void __init pcibios_init(void)
+static struct resource mv_pci_io_mem1_resource = {
+	.name	= "MV64340 PCI1 IO MEM",
+	.flags	= IORESOURCE_IO
+};
+
+static struct resource mv_pci_mem1_resource = {
+	.name	= "MV64340 PCI1 MEM",
+	.flags	= IORESOURCE_MEM
+};
+
+extern struct pci_ops mv64340_bus1_pci_ops;
+
+static struct pci_controller mv_bus1_controller = {
+	.pci_ops	= &mv64340_bus1_pci_ops,
+	.mem_resource	= &mv_pci_mem1_resource,
+	.io_resource	= &mv_pci_io_mem1_resource,
+};
+
+static __init void mv64340_pci1_init(void)
+{
+	uint32_t mem0_base, mem0_size;
+	uint32_t io_base, io_size;
+
+	io_base = MV_READ(MV64340_PCI_1_IO_BASE_ADDR) << 16;
+	io_size = (MV_READ(MV64340_PCI_1_IO_SIZE) + 1) << 16;
+	mem0_base = MV_READ(MV64340_PCI_1_MEMORY0_BASE_ADDR) << 16;
+	mem0_size = (MV_READ(MV64340_PCI_1_MEMORY0_SIZE) + 1) << 16;
+
+	/*
+	 * Here we assume the I/O window of second bus to be contiguous with
+	 * the first.  A gap is no problem but would waste address space for
+	 * remapping the port space.
+	 */
+	mv_pci_io_mem1_resource.start	= mv_io_size;
+	mv_pci_io_mem1_resource.end	= mv_io_size + io_size - 1;
+	mv_pci_mem1_resource.start	= mem0_base;
+	mv_pci_mem1_resource.end	= mem0_base + mem0_size - 1;
+	mv_bus1_controller.mem_offset	= mem0_base;
+	mv_bus1_controller.io_offset	= 0;
+
+	ioport_resource.end		= io_base + io_size -mv_io_base - 1;
+
+	register_pci_controller(&mv_bus1_controller);
+
+	mv_io_size = io_base + io_size - mv_io_base;
+}
+
+static __init int __init ocelot_c_pci_init(void)
 {
-	/* Reset PCI I/O and PCI MEM values */
-	ioport_resource.start = 0xe0000000;
-	ioport_resource.end = 0xe0000000 + 0x20000000 - 1;
-	iomem_resource.start = 0xc0000000;
-	iomem_resource.end = 0xc0000000 + 0x20000000 - 1;
+	unsigned long io_v_base;
+	uint32_t enable;
+
+	enable = ~MV_READ(MV64340_BASE_ADDR_ENABLE);
 
-	pci_scan_bus(0, &mv64340_bus0_pci_ops, NULL);
-	pci_scan_bus(1, &mv64340_bus1_pci_ops, NULL);
+	/*
+	 * We require at least one enabled I/O or PCI memory window or we
+	 * will ignore this PCI bus.  We ignore PCI windows 1, 2 and 3.
+	 */
+	if (enable & (0x01 <<  9) || enable & (0x01 << 10))
+		mv64340_pci0_init();
+
+	if (enable & (0x01 << 14) || enable & (0x01 << 15))
+		mv64340_pci1_init();
+
+	if (mv_io_size) {
+		io_v_base = (unsigned long) ioremap(mv_io_base, mv_io_size);
+		if (!io_v_base)
+			panic("Could not ioremap I/O port range");
+
+		set_io_port_base(io_v_base);
+	}
+
+	return 0;
 }
+
+arch_initcall(ocelot_c_pci_init);
diff -puN arch/mips/pci/pci-ocelot-g.c~mips-update arch/mips/pci/pci-ocelot-g.c
--- 25/arch/mips/pci/pci-ocelot-g.c~mips-update	2004-06-21 23:10:45.413315704 -0700
+++ 25-akpm/arch/mips/pci/pci-ocelot-g.c	2004-06-21 23:10:45.712270256 -0700
@@ -1,460 +1,90 @@
 /*
- * Copyright 2002 Momentum Computer
- * Author: Matthew Dharm <mdharm@momenco.com>
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
  *
- *  This program is free software; you can redistribute  it and/or modify it
- *  under  the terms of  the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the  License, or (at your
- *  option) any later version.
+ * Copyright (C) 2004 by Ralf Baechle
  *
- *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
- *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
- *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
- *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
- *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
- *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *  You should have received a copy of the  GNU General Public License along
- *  with this program; if not, write  to the Free Software Foundation, Inc.,
- *  675 Mass Ave, Cambridge, MA 02139, USA.
+ * This doesn't really fly - but I don't have a GT64240 system for testing.
  */
+#include <linux/init.h>
+#include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/pci.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <asm/pci.h>
-#include <asm/io.h>
-#include "gt64240.h"
-
-#include <linux/init.h>
-
-#define SELF 0
-#define MASTER_ABORT_BIT 0x100
+#include <asm/gt64240.h>
+#include <asm/pci_channel.h>
 
 /*
- * These functions and structures provide the BIOS scan and mapping of the PCI
- * devices.
+ * We assume these address ranges have been programmed into the GT-64240 by
+ * the firmware.  PMON in case of the Ocelot G does that.  Note the size of
+ * the I/O range is completly stupid; I/O mappings are limited to at most
+ * 256 bytes by the PCI spec and deprecated; and just to make things worse
+ * apparently many devices don't decode more than 64k of I/O space.
  */
 
-void gt64240_board_pcibios_fixup_bus(struct pci_bus *c);
-
-/*  Functions to implement "pci ops"  */
-static int galileo_pcibios_read_config_word(int bus, int devfn,
-					    int offset, u16 * val);
-static int galileo_pcibios_read_config_byte(int bus, int devfn,
-					    int offset, u8 * val);
-static int galileo_pcibios_read_config_dword(int bus, int devfn,
-					     int offset, u32 * val);
-static int galileo_pcibios_write_config_byte(int bus, int devfn,
-					     int offset, u8 val);
-static int galileo_pcibios_write_config_word(int bus, int devfn,
-					     int offset, u16 val);
-static int galileo_pcibios_write_config_dword(int bus, int devfn,
-					      int offset, u32 val);
-
-static int pci_read(struct pci_bus *bus, unsigned int devfs, int where,
-		    int size, u32 * val);
-static int pci_write(struct pci_bus *bus, unsigned int devfs, int where,
-		     int size, u32 val);
-
-/*
- *  General-purpose PCI functions.
- */
-
-
-/*
- * pci_range_ck -
- *
- * Check if the pci device that are trying to access does really exists
- * on the evaluation board.
- *
- * Inputs :
- * bus - bus number (0 for PCI 0 ; 1 for PCI 1)
- * dev - number of device on the specific pci bus
- *
- * Outpus :
- * 0 - if OK , 1 - if failure
- */
-static __inline__ int pci_range_ck(unsigned char bus, unsigned char dev)
-{
-	/* Accessing device 31 crashes the GT-64240. */
-	if (dev < 5)
-		return 0;
-	return -1;
-}
-
-/*
- * galileo_pcibios_(read/write)_config_(dword/word/byte) -
- *
- * reads/write a dword/word/byte register from the configuration space
- * of a device.
- *
- * Note that bus 0 and bus 1 are local, and we assume all other busses are
- * bridged from bus 1.  This is a safe assumption, since any other
- * configuration will require major modifications to the CP7000G
- *
- * Inputs :
- * bus - bus number
- * dev - device number
- * offset - register offset in the configuration space
- * val - value to be written / read
- *
- * Outputs :
- * PCIBIOS_SUCCESSFUL when operation was succesfull
- * PCIBIOS_DEVICE_NOT_FOUND when the bus or dev is errorneous
- * PCIBIOS_BAD_REGISTER_NUMBER when accessing non aligned
- */
-
-static int galileo_pcibios_read_config_dword(int bus, int devfn,
-					     int offset, u32 * val)
-{
-	int dev, func;
-	uint32_t address_reg, data_reg;
-	uint32_t address;
-
-	dev = PCI_SLOT(devfn);
-	func = PCI_FUNC(devfn);
-
-	/* verify the range */
-	if (pci_range_ck(bus, dev))
-		return PCIBIOS_DEVICE_NOT_FOUND;
-
-	/* select the GT-64240 registers to communicate with the PCI bus */
-	if (bus == 0) {
-		address_reg = PCI_0CONFIGURATION_ADDRESS;
-		data_reg = PCI_0CONFIGURATION_DATA_VIRTUAL_REGISTER;
-		GT_WRITE(PCI_0ERROR_CAUSE, ~MASTER_ABORT_BIT);
-	} else {
-		address_reg = PCI_1CONFIGURATION_ADDRESS;
-		data_reg = PCI_1CONFIGURATION_DATA_VIRTUAL_REGISTER;
-		GT_WRITE(PCI_1ERROR_CAUSE, ~MASTER_ABORT_BIT);
-		if (bus == 1)
-			bus = 0;
-	}
-
-	address = (bus << 16) | (dev << 11) | (func << 8) |
-	    (offset & 0xfc) | 0x80000000;
-
-	/* start the configuration cycle */
-	GT_WRITE(address_reg, address);
-
-	/* read the data */
-	GT_READ(data_reg, val);
-
-	return PCIBIOS_SUCCESSFUL;
-}
-
-
-static int galileo_pcibios_read_config_word(int bus, int devfn,
-					    int offset, u16 * val)
-{
-	int dev, func;
-	uint32_t address_reg, data_reg;
-	uint32_t address;
-
-	dev = PCI_SLOT(devfn);
-	func = PCI_FUNC(devfn);
-
-	/* verify the range */
-	if (pci_range_ck(bus, dev))
-		return PCIBIOS_DEVICE_NOT_FOUND;
-
-	/* select the GT-64240 registers to communicate with the PCI bus */
-	if (bus == 0) {
-		address_reg = PCI_0CONFIGURATION_ADDRESS;
-		data_reg = PCI_0CONFIGURATION_DATA_VIRTUAL_REGISTER;
-		GT_WRITE(PCI_0ERROR_CAUSE, ~MASTER_ABORT_BIT);
-	} else {
-		address_reg = PCI_1CONFIGURATION_ADDRESS;
-		data_reg = PCI_1CONFIGURATION_DATA_VIRTUAL_REGISTER;
-		GT_WRITE(PCI_1ERROR_CAUSE, ~MASTER_ABORT_BIT);
-		if (bus == 1)
-			bus = 0;
-	}
-
-	address = (bus << 16) | (dev << 11) | (func << 8) |
-	    (offset & 0xfc) | 0x80000000;
-
-	/* start the configuration cycle */
-	GT_WRITE(address_reg, address);
-
-	/* read the data */
-	GT_READ_16(data_reg + (offset & 0x3), val);
-
-	return PCIBIOS_SUCCESSFUL;
-}
-
-static int galileo_pcibios_read_config_byte(int bus, int devfn,
-					    int offset, u8 * val)
-{
-	int dev, func;
-	uint32_t address_reg, data_reg;
-	uint32_t address;
-
-	dev = PCI_SLOT(devfn);
-	func = PCI_FUNC(devfn);
-
-	/* verify the range */
-	if (pci_range_ck(bus, dev))
-		return PCIBIOS_DEVICE_NOT_FOUND;
-
-	/* select the GT-64240 registers to communicate with the PCI bus */
-	if (bus == 0) {
-		address_reg = PCI_0CONFIGURATION_ADDRESS;
-		data_reg = PCI_0CONFIGURATION_DATA_VIRTUAL_REGISTER;
-	} else {
-		address_reg = PCI_1CONFIGURATION_ADDRESS;
-		data_reg = PCI_1CONFIGURATION_DATA_VIRTUAL_REGISTER;
-		if (bus == 1)
-			bus = 0;
-	}
-
-	address = (bus << 16) | (dev << 11) | (func << 8) |
-	    (offset & 0xfc) | 0x80000000;
-
-	/* start the configuration cycle */
-	GT_WRITE(address_reg, address);
+#define gt_io_size	0x20000000UL
+#define gt_io_base	0xe0000000UL
 
-	/* write the data */
-	GT_READ_8(data_reg + (offset & 0x3), val);
-
-	return PCIBIOS_SUCCESSFUL;
-}
-
-static int galileo_pcibios_write_config_dword(int bus, int devfn,
-					      int offset, u32 val)
-{
-	int dev, func;
-	uint32_t address_reg, data_reg;
-	uint32_t address;
-
-	dev = PCI_SLOT(devfn);
-	func = PCI_FUNC(devfn);
-
-	/* verify the range */
-	if (pci_range_ck(bus, dev))
-		return PCIBIOS_DEVICE_NOT_FOUND;
-
-	/* select the GT-64240 registers to communicate with the PCI bus */
-	if (bus == 0) {
-		address_reg = PCI_0CONFIGURATION_ADDRESS;
-		data_reg = PCI_0CONFIGURATION_DATA_VIRTUAL_REGISTER;
-	} else {
-		address_reg = PCI_1CONFIGURATION_ADDRESS;
-		data_reg = PCI_1CONFIGURATION_DATA_VIRTUAL_REGISTER;
-		if (bus == 1)
-			bus = 0;
-	}
-
-	address = (bus << 16) | (dev << 11) | (func << 8) |
-	    (offset & 0xfc) | 0x80000000;
-
-	/* start the configuration cycle */
-	GT_WRITE(address_reg, address);
-
-	/* write the data */
-	GT_WRITE(data_reg, val);
-
-	return PCIBIOS_SUCCESSFUL;
-}
-
-
-static int galileo_pcibios_write_config_word(int bus, int devfn,
-					     int offset, u16 val)
-{
-	int dev, func;
-	uint32_t address_reg, data_reg;
-	uint32_t address;
-
-	dev = PCI_SLOT(devfn);
-	func = PCI_FUNC(devfn);
-
-	/* verify the range */
-	if (pci_range_ck(bus, dev))
-		return PCIBIOS_DEVICE_NOT_FOUND;
-
-	/* select the GT-64240 registers to communicate with the PCI bus */
-	if (bus == 0) {
-		address_reg = PCI_0CONFIGURATION_ADDRESS;
-		data_reg = PCI_0CONFIGURATION_DATA_VIRTUAL_REGISTER;
-	} else {
-		address_reg = PCI_1CONFIGURATION_ADDRESS;
-		data_reg = PCI_1CONFIGURATION_DATA_VIRTUAL_REGISTER;
-		if (bus == 1)
-			bus = 0;
-	}
-
-	address = (bus << 16) | (dev << 11) | (func << 8) |
-	    (offset & 0xfc) | 0x80000000;
-
-	/* start the configuration cycle */
-	GT_WRITE(address_reg, address);
-
-	/* write the data */
-	GT_WRITE_16(data_reg + (offset & 0x3), val);
-
-	return PCIBIOS_SUCCESSFUL;
-}
-
-static int galileo_pcibios_write_config_byte(int bus, int devfn,
-					     int offset, u8 val)
-{
-	int dev, func;
-	uint32_t address_reg, data_reg;
-	uint32_t address;
-
-	dev = PCI_SLOT(devfn);
-	func = PCI_FUNC(devfn);
-
-	/* verify the range */
-	if (pci_range_ck(bus, dev))
-		return PCIBIOS_DEVICE_NOT_FOUND;
-
-	/* select the GT-64240 registers to communicate with the PCI bus */
-	if (bus == 0) {
-		address_reg = PCI_0CONFIGURATION_ADDRESS;
-		data_reg = PCI_0CONFIGURATION_DATA_VIRTUAL_REGISTER;
-	} else {
-		address_reg = PCI_1CONFIGURATION_ADDRESS;
-		data_reg = PCI_1CONFIGURATION_DATA_VIRTUAL_REGISTER;
-		if (bus == 1)
-			bus = 0;
-	}
-
-	address = (bus << 16) | (dev << 11) | (func << 8) |
-	    (offset & 0xfc) | 0x80000000;
-
-	/* start the configuration cycle */
-	GT_WRITE(address_reg, address);
-
-	/* write the data */
-	GT_WRITE_8(data_reg + (offset & 0x3), val);
-
-	return PCIBIOS_SUCCESSFUL;
-}
-
-struct pci_ops galileo_pci_ops = {
-	.read = pci_read,
-	.write = pci_write
+static struct resource gt_pci_mem0_resource = {
+	.name	= "MV64240 PCI0 MEM",
+	.start	= 0xc0000000UL,
+	.end	= 0xcfffffffUL,
+	.flags	= IORESOURCE_MEM
 };
 
-static int pci_read(struct pci_bus *bus, unsigned int devfn, int where,
-		    int size, u32 * val)
-{
-	switch (size) {
-	case 1:
-		return galileo_pcibios_read_config_byte(bus->number,
-							devfn, where,
-							(u8 *) val);
-	case 2:
-		return galileo_pcibios_read_config_word(bus->number,
-							devfn, where,
-							(u16 *) val);
-	case 4:
-		return galileo_pcibios_read_config_dword(bus->number,
-							 devfn, where,
-							 (u32 *) val);
-	}
-	return PCIBIOS_FUNC_NOT_SUPPORTED;
-}
-
-static int pci_write(struct pci_bus *bus, unsigned int devfn, int where,
-		     int size, u32 val)
-{
-	switch (size) {
-	case 1:
-		return galileo_pcibios_write_config_byte(bus->number,
-							 devfn, where,
-							 val);
-	case 2:
-		return galileo_pcibios_write_config_word(bus->number,
-							 devfn, where,
-							 val);
-	case 4:
-		return galileo_pcibios_write_config_dword(bus->number,
-							  devfn, where,
-							  val);
-	}
-	return PCIBIOS_FUNC_NOT_SUPPORTED;
-}
-
-struct pci_fixup pcibios_fixups[] = {
-	{0}
+static struct resource gt_pci_io_mem0_resource = {
+	.name	= "MV64240 PCI0 IO MEM",
+	.start	= 0xe0000000UL,
+	.end	= 0xefffffffUL,
+	.flags	= IORESOURCE_IO
 };
 
-void __devinit pcibios_fixup_bus(struct pci_bus *c)
-{
-	gt64240_board_pcibios_fixup_bus(c);
-}
+static struct pci_controller gt_bus0_controller = {
+	.pci_ops	= &gt_bus0_pci_ops,
+	.mem_resource	= &gt_pci_mem0_resource,
+	.mem_offset	= 0xc0000000UL,
+	.io_resource	= &gt_pci_io_mem0_resource,
+	.io_offset	= 0x00000000UL
+};
 
+static struct resource gt_pci_mem1_resource = {
+	.name	= "MV64240 PCI1 MEM",
+	.start	= 0xd0000000UL,
+	.end	= 0xdfffffffUL,
+	.flags	= IORESOURCE_MEM
+};
 
-/********************************************************************
-* pci0P2PConfig - This function set the PCI_0 P2P configurate.
-*                 For more information on the P2P read PCI spec.
-*
-* Inputs:  unsigned int SecondBusLow - Secondery PCI interface Bus Range Lower
-*                                      Boundry.
-*          unsigned int SecondBusHigh - Secondry PCI interface Bus Range upper
-*                                      Boundry.
-*          unsigned int busNum - The CPI bus number to which the PCI interface
-*                                      is connected.
-*          unsigned int devNum - The PCI interface's device number.
-*
-* Returns:  true.
-*/
-void pci0P2PConfig(unsigned int SecondBusLow, unsigned int SecondBusHigh,
-		   unsigned int busNum, unsigned int devNum)
-{
-	uint32_t regData;
+static struct resource gt_pci_io_mem1_resource = {
+	.name	= "MV64240 PCI1 IO MEM",
+	.start	= 0xf0000000UL,
+	.end	= 0xffffffffUL,
+	.flags	= IORESOURCE_IO
+};
 
-	regData = (SecondBusLow & 0xff) | ((SecondBusHigh & 0xff) << 8) |
-	    ((busNum & 0xff) << 16) | ((devNum & 0x1f) << 24);
-	GT_WRITE(PCI_0P2P_CONFIGURATION, regData);
-}
+static struct pci_controller gt_bus1_controller = {
+	.pci_ops	= &gt_bus1_pci_ops,
+	.mem_resource	= &gt_pci_mem1_resource,
+	.mem_offset	= 0xd0000000UL,
+	.io_resource	= &gt_pci_io_mem1_resource,
+	.io_offset	= 0x10000000UL
+};
 
-/********************************************************************
-* pci1P2PConfig - This function set the PCI_1 P2P configurate.
-*                 For more information on the P2P read PCI spec.
-*
-* Inputs:  unsigned int SecondBusLow - Secondery PCI interface Bus Range Lower
-*               Boundry.
-*          unsigned int SecondBusHigh - Secondry PCI interface Bus Range upper
-*               Boundry.
-*          unsigned int busNum - The CPI bus number to which the PCI interface
-*               is connected.
-*          unsigned int devNum - The PCI interface's device number.
-*
-* Returns:  true.
-*/
-void pci1P2PConfig(unsigned int SecondBusLow, unsigned int SecondBusHigh,
-		   unsigned int busNum, unsigned int devNum)
+static __init int __init ocelot_g_pci_init(void)
 {
-	uint32_t regData;
-
-	regData = (SecondBusLow & 0xff) | ((SecondBusHigh & 0xff) << 8) |
-	    ((busNum & 0xff) << 16) | ((devNum & 0x1f) << 24);
-	GT_WRITE(PCI_1P2P_CONFIGURATION, regData);
-}
+	unsigned long io_v_base;
 
-#define PCI0_STATUS_COMMAND_REG                 0x4
-#define PCI1_STATUS_COMMAND_REG                 0x84
+	if (gt_io_size) {
+		io_v_base = (unsigned long) ioremap(gt_io_base, gt_io_size);
+		if (!io_v_base)
+			panic("Could not ioremap I/O port range");
 
-static int __init pcibios_init(void)
-{
-	/* Reset PCI I/O and PCI MEM values */
-	ioport_resource.start = 0xe0000000;
-	ioport_resource.end = 0xe0000000 + 0x20000000 - 1;
-	iomem_resource.start = 0xc0000000;
-	iomem_resource.end = 0xc0000000 + 0x20000000 - 1;
+		set_io_port_base(io_v_base);
+	}
 
-	pci_scan_bus(0, &galileo_pci_ops, NULL);
-	pci_scan_bus(1, &galileo_pci_ops, NULL);
+	register_pci_controller(&gt_bus0_controller);
+	register_pci_controller(&gt_bus1_controller);
 
 	return 0;
 }
 
-subsys_initcall(pcibios_init);
+arch_initcall(ocelot_g_pci_init);
diff -puN arch/mips/pci/pci-vr41xx.c~mips-update arch/mips/pci/pci-vr41xx.c
--- 25/arch/mips/pci/pci-vr41xx.c~mips-update	2004-06-21 23:10:45.415315400 -0700
+++ 25-akpm/arch/mips/pci/pci-vr41xx.c	2004-06-21 23:10:45.715269800 -0700
@@ -1,48 +1,32 @@
 /*
- * FILE NAME
- *	arch/mips/vr41xx/common/pciu.c
+ *  pci-vr41xx.c, PCI Control Unit routines for the NEC VR4100 series.
  *
- * BRIEF MODULE DESCRIPTION
- *	PCI Control Unit routines for the NEC VR4100 series.
+ *  Copyright (C) 2001-2003 MontaVista Software Inc.
+ *    Author: Yoichi Yuasa <yyuasa@mvista.com or source@mvista.com>
+ *  Copyright (C) 2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
  *
- * Author: Yoichi Yuasa
- *         yyuasa@mvista.com or source@mvista.com
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
  *
- * Copyright 2001-2003 MontaVista Software Inc.
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
  *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License as published by the
- *  Free Software Foundation; either version 2 of the License, or (at your
- *  option) any later version.
- *
- *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
- *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
- *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 /*
  * Changes:
- *  Paul Mundt <lethal@chaoticdreams.org>
- *  - Fix deadlock-causing PCIU access race for VR4131.
- *
  *  MontaVista Software Inc. <yyuasa@mvista.com> or <source@mvista.com>
  *  - New creation, NEC VR4122 and VR4131 are supported.
  */
-#include <linux/config.h>
 #include <linux/init.h>
 #include <linux/pci.h>
 #include <linux/types.h>
-#include <linux/delay.h>
 
 #include <asm/cpu.h>
 #include <asm/io.h>
@@ -51,183 +35,257 @@
 
 #include "pci-vr41xx.h"
 
-static inline int vr41xx_pci_config_access(unsigned char bus,
-					   unsigned int devfn, int where)
-{
-	if (bus == 0) {
-		/*
-		 * Type 0 configuration
-		 */
-		if (PCI_SLOT(devfn) < 11 || where > 255)
-			return -1;
-
-		writel((1UL << PCI_SLOT(devfn)) |
-		       (PCI_FUNC(devfn) << 8) |
-		       (where & 0xfc), PCICONFAREG);
-	} else {
-		/*
-		 * Type 1 configuration
-		 */
-		if (where > 255)
-			return -1;
-
-		writel((bus << 16) |
-		       (devfn << 8) | (where & 0xfc) | 1UL, PCICONFAREG);
-	}
-
-	return 0;
-}
-
-static int vr41xx_pci_config_read(struct pci_bus *bus, unsigned int devfn,
-				  int where, int size, u32 * val)
-{
-	u32 data;
+extern struct pci_ops vr41xx_pci_ops;
 
-	*val = 0xffffffffUL;
-	if (vr41xx_pci_config_access(bus->number, devfn, where) < 0)
-		return PCIBIOS_DEVICE_NOT_FOUND;
+static struct pci_master_address_conversion pci_master_memory1 = {
+	.bus_base_address	= PCI_MASTER_MEM1_BUS_BASE_ADDRESS,
+	.address_mask		= PCI_MASTER_MEM1_ADDRESS_MASK,
+	.pci_base_address	= PCI_MASTER_MEM1_PCI_BASE_ADDRESS,
+};
 
-	data = readl(PCICONFDREG);
+static struct pci_target_address_conversion pci_target_memory1 = {
+	.address_mask		= PCI_TARGET_MEM1_ADDRESS_MASK,
+	.bus_base_address	= PCI_TARGET_MEM1_BUS_BASE_ADDRESS,
+};
 
-	switch (size) {
-	case 1:
-		*val = (data >> ((where & 3) << 3)) & 0xffUL;
-		break;
-	case 2:
-		*val = (data >> ((where & 2) << 3)) & 0xffffUL;
-		break;
-	case 4:
-		*val = data;
-		break;
-	default:
-		return PCIBIOS_FUNC_NOT_SUPPORTED;
-	}
+static struct pci_master_address_conversion pci_master_io = {
+	.bus_base_address	= PCI_MASTER_IO_BUS_BASE_ADDRESS,
+	.address_mask		= PCI_MASTER_IO_ADDRESS_MASK,
+	.pci_base_address	= PCI_MASTER_IO_PCI_BASE_ADDRESS,
+};
 
-	return PCIBIOS_SUCCESSFUL;
-}
+static struct pci_mailbox_address pci_mailbox = {
+	.base_address		= PCI_MAILBOX_BASE_ADDRESS,
+};
 
-static int vr41xx_pci_config_write(struct pci_bus *bus, unsigned int devfn,
-				   int where, int size, u32 val)
-{
-	u32 data;
-	int shift;
+static struct pci_target_address_window pci_target_window1 = {
+	.base_address		= PCI_TARGET_WINDOW1_BASE_ADDRESS,
+};
 
-	if (vr41xx_pci_config_access(bus->number, devfn, where) < 0)
-		return PCIBIOS_DEVICE_NOT_FOUND;
+static struct resource pci_mem_resource = {
+	.name   = "PCI Memory resources",
+	.start  = PCI_MEM_RESOURCE_START,
+	.end    = PCI_MEM_RESOURCE_END,
+	.flags  = IORESOURCE_MEM,
+};
 
-	data = readl(PCICONFDREG);
+static struct resource pci_io_resource = {
+	.name   = "PCI I/O resources",
+	.start  = PCI_IO_RESOURCE_START,
+	.end    = PCI_IO_RESOURCE_END,
+	.flags  = IORESOURCE_IO,
+};
 
-	switch (size) {
-	case 1:
-		shift = (where & 3) << 3;
-		data &= ~(0xff << shift);
-		data |= ((val & 0xff) << shift);
-		break;
-	case 2:
-		shift = (where & 2) << 3;
-		data &= ~(0xffff << shift);
-		data |= ((val & 0xffff) << shift);
-		break;
-	case 4:
-		data = val;
-		break;
-	default:
-		return PCIBIOS_FUNC_NOT_SUPPORTED;
-	}
+static struct pci_controller_unit_setup vr41xx_pci_controller_unit_setup = {
+	.master_memory1				= &pci_master_memory1,
+	.target_memory1				= &pci_target_memory1,
+	.master_io				= &pci_master_io,
+	.exclusive_access			= CANNOT_LOCK_FROM_DEVICE,
+	.wait_time_limit_from_irdy_to_trdy	= 0,
+	.mailbox				= &pci_mailbox,
+	.target_window1				= &pci_target_window1,
+	.master_latency_timer			= 0x80,
+	.retry_limit				= 0,
+	.arbiter_priority_control		= PCI_ARBITRATION_MODE_FAIR,
+	.take_away_gnt_mode			= PCI_TAKE_AWAY_GNT_DISABLE,
+};
 
-	writel(data, PCICONFDREG);
+static struct pci_controller vr41xx_pci_controller = {
+	.pci_ops        = &vr41xx_pci_ops,
+	.mem_resource	= &pci_mem_resource,
+	.io_resource	= &pci_io_resource,
+};
 
-	return PCIBIOS_SUCCESSFUL;
+void __init vr41xx_pciu_setup(struct pci_controller_unit_setup *setup)
+{
+	vr41xx_pci_controller_unit_setup = *setup;
 }
 
-struct pci_ops vr41xx_pci_ops = {
-	.read = vr41xx_pci_config_read,
-	.write = vr41xx_pci_config_write,
-};
-
-void __init vr41xx_pciu_init(struct vr41xx_pci_address_map *map)
+static int __init vr41xx_pciu_init(void)
 {
-	struct vr41xx_pci_address_space *s;
-	unsigned long vtclock;
-	u32 config;
-	int n;
+	struct pci_controller_unit_setup *setup;
+	struct pci_master_address_conversion *master;
+	struct pci_target_address_conversion *target;
+	struct pci_mailbox_address *mailbox;
+	struct pci_target_address_window *window;
+	unsigned long vtclock, pci_clock_max;
+	uint32_t val;
 
-	if (!map)
-		return;
+	setup = &vr41xx_pci_controller_unit_setup;
 
 	/* Disable PCI interrupt */
-	writew(0, MPCIINTREG);
+	vr41xx_disable_pciint();
 
 	/* Supply VTClock to PCIU */
 	vr41xx_supply_clock(PCIU_CLOCK);
 
-	/*
-	 * Sleep for 1us after setting MSKPPCIU bit in CMUCLKMSK
-	 * before doing any PCIU access to avoid deadlock on VR4131.
-	 */
-	udelay(1);
+	/* Dummy write, waiting for supply of VTClock. */
+	vr41xx_disable_pciint();
 
 	/* Select PCI clock */
+	if (setup->pci_clock_max != 0)
+		pci_clock_max = setup->pci_clock_max;
+	else
+		pci_clock_max = PCI_CLOCK_MAX;
 	vtclock = vr41xx_get_vtclock_frequency();
-	if (vtclock < MAX_PCI_CLOCK)
+	if (vtclock < pci_clock_max)
 		writel(EQUAL_VTCLOCK, PCICLKSELREG);
-	else if ((vtclock / 2) < MAX_PCI_CLOCK)
+	else if ((vtclock / 2) < pci_clock_max)
 		writel(HALF_VTCLOCK, PCICLKSELREG);
-	else if ((vtclock / 4) < MAX_PCI_CLOCK)
+	else if (current_cpu_data.processor_id >= PRID_VR4131_REV2_1 &&
+	         (vtclock / 3) < pci_clock_max)
+		writel(ONE_THIRD_VTCLOCK, PCICLKSELREG);
+	else if ((vtclock / 4) < pci_clock_max)
 		writel(QUARTER_VTCLOCK, PCICLKSELREG);
-	else
-		printk(KERN_INFO "Warning: PCI Clock is over 33MHz.\n");
+	else {
+		printk(KERN_ERR "PCI Clock is over 33MHz.\n");
+		return -EINVAL;
+	}
 
 	/* Supply PCI clock by PCI bus */
 	vr41xx_supply_clock(PCI_CLOCK);
 
-	/*
-	 * Set PCI memory & I/O space address conversion registers
-	 * for master transaction.
-	 */
-	if (map->mem1 != NULL) {
-		s = map->mem1;
-		config = (s->internal_base & 0xff000000) |
-		    ((s->address_mask & 0x7f000000) >> 11) | (1UL << 12) |
-		    ((s->pci_base & 0xff000000) >> 24);
-		writel(config, PCIMMAW1REG);
-	}
-	if (map->mem2 != NULL) {
-		s = map->mem2;
-		config = (s->internal_base & 0xff000000) |
-		    ((s->address_mask & 0x7f000000) >> 11) | (1UL << 12) |
-		    ((s->pci_base & 0xff000000) >> 24);
-		writel(config, PCIMMAW2REG);
-	}
-	if (map->io != NULL) {
-		s = map->io;
-		config = (s->internal_base & 0xff000000) |
-		    ((s->address_mask & 0x7f000000) >> 11) | (1UL << 12) |
-		    ((s->pci_base & 0xff000000) >> 24);
-		writel(config, PCIMIOAWREG);
-	}
-
-	/* Set target memory windows */
-	writel(0x00081000, PCITAW1REG);
-	writel(0UL, PCITAW2REG);
-	pciu_write_config_dword(PCI_BASE_ADDRESS_0, 0UL);
-	pciu_write_config_dword(PCI_BASE_ADDRESS_1, 0UL);
+	if (setup->master_memory1 != NULL) {
+		master = setup->master_memory1;
+		val = IBA(master->bus_base_address) |
+		      MASTER_MSK(master->address_mask) |
+		      WINEN |
+		      PCIA(master->pci_base_address);
+		writel(val, PCIMMAW1REG);
+	} else {
+		val = readl(PCIMMAW1REG);
+		val &= ~WINEN;
+		writel(val, PCIMMAW1REG);
+	}
+
+	if (setup->master_memory2 != NULL) {
+		master = setup->master_memory2;
+		val = IBA(master->bus_base_address) |
+		      MASTER_MSK(master->address_mask) |
+		      WINEN |
+		      PCIA(master->pci_base_address);
+		writel(val, PCIMMAW2REG);
+	} else {
+		val = readl(PCIMMAW2REG);
+		val &= ~WINEN;
+		writel(val, PCIMMAW2REG);
+	}
 
-	/* Clear bus error */
-	n = readl(BUSERRADREG);
+	if (setup->target_memory1 != NULL) {
+		target = setup->target_memory1;
+		val = TARGET_MSK(target->address_mask) |
+		      WINEN |
+		      ITA(target->bus_base_address);
+		writel(val, PCITAW1REG);
+	} else {
+		val = readl(PCITAW1REG);
+		val &= ~WINEN;
+		writel(val, PCITAW1REG);
+	}
+
+	if (setup->target_memory2 != NULL) {
+		target = setup->target_memory2;
+		val = TARGET_MSK(target->address_mask) |
+		      WINEN |
+		      ITA(target->bus_base_address);
+		writel(val, PCITAW2REG);
+	} else {
+		val = readl(PCITAW2REG);
+		val &= ~WINEN;
+		writel(val, PCITAW2REG);
+	}
 
-	if (current_cpu_data.cputype == CPU_VR4122) {
-		writel(0UL, PCITRDYVREG);
-		pciu_write_config_dword(PCI_CACHE_LINE_SIZE, 0x0000f804);
+	if (setup->master_io != NULL) {
+		master = setup->master_io;
+		val = IBA(master->bus_base_address) |
+		      MASTER_MSK(master->address_mask) |
+		      WINEN |
+		      PCIIA(master->pci_base_address);
+		writel(val, PCIMIOAWREG);
 	} else {
-		writel(100UL, PCITRDYVREG);
-		pciu_write_config_dword(PCI_CACHE_LINE_SIZE, 0x00008004);
+		val = readl(PCIMIOAWREG);
+		val &= ~WINEN;
+		writel(val, PCIMIOAWREG);
+	}
+
+	if (setup->exclusive_access == CANNOT_LOCK_FROM_DEVICE)
+		writel(UNLOCK, PCIEXACCREG);
+	else
+		writel(0, PCIEXACCREG);
+
+	if (current_cpu_data.cputype == CPU_VR4122)
+		writel(TRDYV(setup->wait_time_limit_from_irdy_to_trdy), PCITRDYVREG);
+
+	writel(MLTIM(setup->master_latency_timer), LATTIMEREG);
+
+	if (setup->mailbox != NULL) {
+		mailbox = setup->mailbox;
+		val = MBADD(mailbox->base_address) | TYPE_32BITSPACE |
+		      MSI_MEMORY | PREF_APPROVAL;
+		writel(val, MAILBAREG);
+	}
+
+	if (setup->target_window1) {
+		window = setup->target_window1;
+		val = PMBA(window->base_address) | TYPE_32BITSPACE |
+		      MSI_MEMORY | PREF_APPROVAL;
+		writel(val, PCIMBA1REG);
+	}
+
+	if (setup->target_window2) {
+		window = setup->target_window2;
+		val = PMBA(window->base_address) | TYPE_32BITSPACE |
+		      MSI_MEMORY | PREF_APPROVAL;
+		writel(val, PCIMBA2REG);
 	}
 
+	val = readl(RETVALREG);
+	val &= ~RTYVAL_MASK;
+	val |= RTYVAL(setup->retry_limit);
+	writel(val, RETVALREG);
+
+	val = readl(PCIAPCNTREG);
+	val &= ~(TKYGNT | PAPC);
+
+	switch (setup->arbiter_priority_control) {
+	case PCI_ARBITRATION_MODE_ALTERNATE_0:
+		val |= PAPC_ALTERNATE_0;
+		break;
+	case PCI_ARBITRATION_MODE_ALTERNATE_B:
+		val |= PAPC_ALTERNATE_B;
+		break;
+	default:
+		val |= PAPC_FAIR;
+		break;
+	}
+
+	if (setup->take_away_gnt_mode == PCI_TAKE_AWAY_GNT_ENABLE)
+		val |= TKYGNT_ENABLE;
+
+	writel(val, PCIAPCNTREG);
+
+	writel(PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER |
+	       PCI_COMMAND_PARITY | PCI_COMMAND_SERR, COMMANDREG);
+
+	/* Clear bus error */
+	readl(BUSERRADREG);
+
 	writel(CONFIG_DONE, PCIENREG);
-	pciu_write_config_dword(PCI_COMMAND,
-				PCI_COMMAND_IO |
-				PCI_COMMAND_MEMORY |
-				PCI_COMMAND_MASTER |
-				PCI_COMMAND_PARITY | PCI_COMMAND_SERR);
+
+	if (setup->mem_resource != NULL)
+		vr41xx_pci_controller.mem_resource = setup->mem_resource;
+
+	if (setup->io_resource != NULL) {
+		vr41xx_pci_controller.io_resource = setup->io_resource;
+	} else {
+		set_io_port_base(IO_PORT_BASE);
+		ioport_resource.start = IO_PORT_RESOURCE_START;
+		ioport_resource.end = IO_PORT_RESOURCE_END;
+	}
+
+	register_pci_controller(&vr41xx_pci_controller);
+
+	return 0;
 }
+
+early_initcall(vr41xx_pciu_init);
diff -puN arch/mips/pci/pci-vr41xx.h~mips-update arch/mips/pci/pci-vr41xx.h
--- 25/arch/mips/pci/pci-vr41xx.h~mips-update	2004-06-21 23:10:45.417315096 -0700
+++ 25-akpm/arch/mips/pci/pci-vr41xx.h	2004-06-21 23:10:45.717269496 -0700
@@ -1,164 +1,151 @@
 /*
- * FILE NAME
- *	arch/mips/vr41xx/common/pciu.h
+ *  pci-vr41xx.h, Include file for PCI Control Unit of the NEC VR4100 series.
  *
- * BRIEF MODULE DESCRIPTION
- *	Include file for PCI Control Unit of the NEC VR4100 series.
- *
- * Author: Yoichi Yuasa
- *         yyuasa@mvista.com or source@mvista.com
- *
- * Copyright 2002 MontaVista Software Inc.
- *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License as published by the
- *  Free Software Foundation; either version 2 of the License, or (at your
- *  option) any later version.
- *
- *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
- *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
- *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  675 Mass Ave, Cambridge, MA 02139, USA.
- */
-/*
- * Changes:
- *  MontaVista Software Inc. <yyuasa@mvista.com> or <source@mvista.com>
- *  - New creation, NEC VR4122 and VR4131 are supported.
+ *  Copyright (C) 2002  MontaVista Software Inc.
+ *    Author: Yoichi Yuasa <yyuasa@mvista.com or source@mvista.com>
+ *  Copyright (C) 2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
-#ifndef __VR41XX_PCIU_H
-#define __VR41XX_PCIU_H
-
-#include <linux/config.h>
-#include <asm/addrspace.h>
-
-#define BIT(x)	(1 << (x))
-
-#define PCIMMAW1REG			KSEG1ADDR(0x0f000c00)
-#define PCIMMAW2REG			KSEG1ADDR(0x0f000c04)
-#define PCITAW1REG			KSEG1ADDR(0x0f000c08)
-#define PCITAW2REG			KSEG1ADDR(0x0f000c0c)
-#define PCIMIOAWREG			KSEG1ADDR(0x0f000c10)
-#define INTERNAL_BUS_BASE_ADDRESS	0xff000000
-#define ADDRESS_MASK			0x000fe000
-#define PCI_ACCESS_ENABLE		BIT(12)
-#define PCI_ADDRESS_SETTING		0x000000ff
-
-#define PCICONFDREG			KSEG1ADDR(0x0f000c14)
-#define PCICONFAREG			KSEG1ADDR(0x0f000c18)
-#define PCIMAILREG			KSEG1ADDR(0x0f000c1c)
-
-#define BUSERRADREG			KSEG1ADDR(0x0f000c24)
-#define ERROR_ADDRESS			0xfffffffc
-
-#define INTCNTSTAREG			KSEG1ADDR(0x0f000c28)
-#define MABTCLR				BIT(31)
-#define TRDYCLR				BIT(30)
-#define PARCLR				BIT(29)
-#define MBCLR				BIT(28)
-#define SERRCLR				BIT(27)
-
-#define PCIEXACCREG			KSEG1ADDR(0x0f000c2c)
-#define UNLOCK				BIT(1)
-#define EAREQ				BIT(0)
-
-#define PCIRECONTREG			KSEG1ADDR(0x0f000c30)
-#define RTRYCNT				0x000000ff
+#ifndef __PCI_VR41XX_H
+#define __PCI_VR41XX_H
 
-#define PCIENREG			KSEG1ADDR(0x0f000c34)
-#define CONFIG_DONE			BIT(2)
+#define PCIMMAW1REG		KSEG1ADDR(0x0f000c00)
+#define PCIMMAW2REG		KSEG1ADDR(0x0f000c04)
+#define PCITAW1REG		KSEG1ADDR(0x0f000c08)
+#define PCITAW2REG		KSEG1ADDR(0x0f000c0c)
+#define PCIMIOAWREG		KSEG1ADDR(0x0f000c10)
+ #define IBA(addr)		((addr) & 0xff000000U)
+ #define MASTER_MSK(mask)	(((mask) >> 11) & 0x000fe000U)
+ #define PCIA(addr)		(((addr) >> 24) & 0x000000ffU)
+ #define TARGET_MSK(mask)	(((mask) >> 8) & 0x000fe000U)
+ #define ITA(addr)		(((addr) >> 24) & 0x000000ffU)
+ #define PCIIA(addr)		(((addr) >> 24) & 0x000000ffU)
+ #define WINEN			0x1000U
+#define PCICONFDREG		KSEG1ADDR(0x0f000c14)
+#define PCICONFAREG		KSEG1ADDR(0x0f000c18)
+#define PCIMAILREG		KSEG1ADDR(0x0f000c1c)
+#define BUSERRADREG		KSEG1ADDR(0x0f000c24)
+ #define EA(reg)		((reg) &0xfffffffc)
+
+#define INTCNTSTAREG		KSEG1ADDR(0x0f000c28)
+ #define MABTCLR		0x80000000U
+ #define TRDYCLR		0x40000000U
+ #define PARCLR			0x20000000U
+ #define MBCLR			0x10000000U
+ #define SERRCLR		0x08000000U
+ #define RTYCLR			0x04000000U
+ #define MABCLR			0x02000000U
+ #define TABCLR			0x01000000U
+ /* RFU */
+ #define MABTMSK		0x00008000U
+ #define TRDYMSK		0x00004000U
+ #define PARMSK			0x00002000U
+ #define MBMSK			0x00001000U
+ #define SERRMSK		0x00000800U
+ #define RTYMSK			0x00000400U
+ #define MABMSK			0x00000200U
+ #define TABMSK			0x00000100U
+ #define IBAMABT		0x00000080U
+ #define TRDYRCH		0x00000040U
+ #define PAR			0x00000020U
+ #define MB			0x00000010U
+ #define PCISERR		0x00000008U
+ #define RTYRCH			0x00000004U
+ #define MABORT			0x00000002U
+ #define TABORT			0x00000001U
+
+#define PCIEXACCREG		KSEG1ADDR(0x0f000c2c)
+ #define UNLOCK			0x2U
+ #define EAREQ			0x1U
+#define PCIRECONTREG		KSEG1ADDR(0x0f000c30)
+ #define RTRYCNT(reg)		((reg) & 0x000000ffU)
+#define PCIENREG		KSEG1ADDR(0x0f000c34)
+ #define CONFIG_DONE		0x4U
+#define PCICLKSELREG		KSEG1ADDR(0x0f000c38)
+ #define EQUAL_VTCLOCK		0x2U
+ #define HALF_VTCLOCK		0x0U
+ #define ONE_THIRD_VTCLOCK	0x3U
+ #define QUARTER_VTCLOCK	0x1U
+#define PCITRDYVREG		KSEG1ADDR(0x0f000c3c)
+ #define TRDYV(val)		((uint32_t)(val) & 0xffU)
+#define PCICLKRUNREG		KSEG1ADDR(0x0f000c60)
+
+#define VENDORIDREG		KSEG1ADDR(0x0f000d00)
+#define DEVICEIDREG		KSEG1ADDR(0x0f000d00)
+#define COMMANDREG		KSEG1ADDR(0x0f000d04)
+#define STATUSREG		KSEG1ADDR(0x0f000d04)
+#define REVIDREG		KSEG1ADDR(0x0f000d08)
+#define CLASSREG		KSEG1ADDR(0x0f000d08)
+#define CACHELSREG		KSEG1ADDR(0x0f000d0c)
+#define LATTIMEREG		KSEG1ADDR(0x0f000d0c)
+ #define MLTIM(val)		(((uint32_t)(val) << 7) & 0xff00U)
+#define MAILBAREG		KSEG1ADDR(0x0f000d10)
+#define PCIMBA1REG		KSEG1ADDR(0x0f000d14)
+#define PCIMBA2REG		KSEG1ADDR(0x0f000d18)
+ #define MBADD(base)		((base) & 0xfffff800U)
+ #define PMBA(base)		((base) & 0xffe00000U)
+ #define PREF			0x8U
+ #define PREF_APPROVAL		0x8U
+ #define PREF_DISAPPROVAL	0x0U
+ #define TYPE			0x6U
+ #define TYPE_32BITSPACE	0x0U
+ #define MSI			0x1U
+ #define MSI_MEMORY		0x0U
+#define INTLINEREG		KSEG1ADDR(0x0f000d3c)
+#define INTPINREG		KSEG1ADDR(0x0f000d3c)
+#define RETVALREG		KSEG1ADDR(0x0f000d40)
+#define PCIAPCNTREG		KSEG1ADDR(0x0f000d40)
+ #define TKYGNT			0x04000000U
+ #define TKYGNT_ENABLE		0x04000000U
+ #define TKYGNT_DISABLE		0x00000000U
+ #define PAPC			0x03000000U
+ #define PAPC_ALTERNATE_B	0x02000000U
+ #define PAPC_ALTERNATE_0	0x01000000U
+ #define PAPC_FAIR		0x00000000U
+ #define RTYVAL(val)		(((uint32_t)(val) << 7) & 0xff00U)
+ #define RTYVAL_MASK		0xff00U
 
-#define PCICLKSELREG			KSEG1ADDR(0x0f000c38)
-#define EQUAL_VTCLOCK			0x00000002
-#define HALF_VTCLOCK			0x00000000
-#define QUARTER_VTCLOCK			0x00000001
+#define PCI_CLOCK_MAX		33333333U
 
-#define PCITRDYVREG			KSEG1ADDR(0x0f000c3c)
-
-#define PCICLKRUNREG			KSEG1ADDR(0x0f000c60)
-
-#define PCIU_CONFIGREGS_BASE		KSEG1ADDR(0x0f000d00)
-#define VENDORIDREG			KSEG1ADDR(0x0f000d00)
-#define DEVICEIDREG			KSEG1ADDR(0x0f000d00)
-#define COMMANDREG			KSEG1ADDR(0x0f000d04)
-#define STATUSREG			KSEG1ADDR(0x0f000d04)
-#define REVIDREG			KSEG1ADDR(0x0f000d08)
-#define CLASSREG			KSEG1ADDR(0x0f000d08)
-#define CACHELSREG			KSEG1ADDR(0x0f000d0c)
-#define LATTIMEREG			KSEG1ADDR(0x0f000d0c)
-#define MAILBAREG			KSEG1ADDR(0x0f000d10)
-#define PCIMBA1REG			KSEG1ADDR(0x0f000d14)
-#define PCIMBA2REG			KSEG1ADDR(0x0f000d18)
-#define INTLINEREG			KSEG1ADDR(0x0f000d3c)
-#define INTPINREG			KSEG1ADDR(0x0f000d3c)
-#define RETVALREG			KSEG1ADDR(0x0f000d40)
-#define PCIAPCNTREG			KSEG1ADDR(0x0f000d40)
-
-#define MPCIINTREG			KSEG1ADDR(0x0f0000b2)
-
-#define MAX_PCI_CLOCK			33333333
-
-static inline int pciu_read_config_byte(int where, u8 * val)
-{
-	u32 data;
-
-	data = readl(PCIU_CONFIGREGS_BASE + where);
-	*val = (u8) (data >> ((where & 3) << 3));
-
-	return PCIBIOS_SUCCESSFUL;
-}
-
-static inline int pciu_read_config_word(int where, u16 * val)
-{
-	u32 data;
-
-	if (where & 1)
-		return PCIBIOS_BAD_REGISTER_NUMBER;
-
-	data = readl(PCIU_CONFIGREGS_BASE + where);
-	*val = (u16) (data >> ((where & 2) << 3));
-
-	return PCIBIOS_SUCCESSFUL;
-}
-
-static inline int pciu_read_config_dword(int where, u32 * val)
-{
-	if (where & 3)
-		return PCIBIOS_BAD_REGISTER_NUMBER;
-
-	*val = readl(PCIU_CONFIGREGS_BASE + where);
+/*
+ * Default setup
+ */
+#define PCI_MASTER_MEM1_BUS_BASE_ADDRESS	0x10000000U
+#define PCI_MASTER_MEM1_ADDRESS_MASK		0x7c000000U
+#define PCI_MASTER_MEM1_PCI_BASE_ADDRESS	0x10000000U
 
-	return PCIBIOS_SUCCESSFUL;
-}
+#define PCI_TARGET_MEM1_ADDRESS_MASK		0x08000000U
+#define PCI_TARGET_MEM1_BUS_BASE_ADDRESS	0x00000000U
 
-static inline int pciu_write_config_byte(int where, u8 val)
-{
-	writel(val, PCIU_CONFIGREGS_BASE + where);
+#define PCI_MASTER_IO_BUS_BASE_ADDRESS		0x16000000U
+#define PCI_MASTER_IO_ADDRESS_MASK		0x7e000000U
+#define PCI_MASTER_IO_PCI_BASE_ADDRESS		0x00000000U
 
-	return 0;
-}
+#define PCI_MAILBOX_BASE_ADDRESS		0x00000000U
 
-static inline int pciu_write_config_word(int where, u16 val)
-{
-	writel(val, PCIU_CONFIGREGS_BASE + where);
+#define PCI_TARGET_WINDOW1_BASE_ADDRESS		0x00000000U
 
-	return 0;
-}
+#define IO_PORT_BASE		KSEG1ADDR(PCI_MASTER_IO_BUS_BASE_ADDRESS)
+#define IO_PORT_RESOURCE_START	PCI_MASTER_IO_PCI_BASE_ADDRESS
+#define IO_PORT_RESOURCE_END	(~PCI_MASTER_IO_ADDRESS_MASK & PCI_MASTER_ADDRESS_MASK)
 
-static inline int pciu_write_config_dword(int where, u32 val)
-{
-	writel(val, PCIU_CONFIGREGS_BASE + where);
+#define PCI_IO_RESOURCE_START	0x01000000UL
+#define PCI_IO_RESOURCE_END	0x01ffffffUL
 
-	return 0;
-}
+#define PCI_MEM_RESOURCE_START	0x11000000UL
+#define PCI_MEM_RESOURCE_END	0x13ffffffUL
 
-#endif				/* __VR41XX_PCIU_H */
+#endif /* __PCI_VR41XX_H */
diff -puN /dev/null arch/mips/pci/pci-yosemite.c
--- /dev/null	2003-09-15 06:40:47.000000000 -0700
+++ 25-akpm/arch/mips/pci/pci-yosemite.c	2004-06-21 23:10:45.719269192 -0700
@@ -0,0 +1,37 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2004 by Ralf Baechle
+ *
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <asm/gt64240.h>
+#include <asm/pci_channel.h>
+
+extern struct pci_ops titan_pci_ops;
+
+static struct resource py_mem_resource = {
+	"Titan PCI MEM", 0xe0000000UL, 0xe3ffffffUL, IORESOURCE_MEM
+};
+
+static struct resource py_io_resource = {
+	"Titan IO MEM", 0x00000000UL, 0x00ffffffUL, IORESOURCE_IO,
+};
+
+static struct pci_controller py_controller = {
+	.pci_ops	= &titan_pci_ops,
+	.mem_resource	= &py_mem_resource,
+	.mem_offset	= 0x10000000UL,
+	.io_resource	= &py_io_resource,
+	.io_offset	= 0x00000000UL
+};
+
+static int __init pmc_yosemite_setup(void)
+{
+	register_pci_controller(&py_controller);
+}
diff -puN /dev/null arch/mips/pmc-sierra/yosemite/dbg_io.c
--- /dev/null	2003-09-15 06:40:47.000000000 -0700
+++ 25-akpm/arch/mips/pmc-sierra/yosemite/dbg_io.c	2004-06-21 23:10:45.720269040 -0700
@@ -0,0 +1,184 @@
+/*
+ * Copyright 2003 PMC-Sierra
+ * Author: Manish Lachwani (lachwani@pmc-sierra.com)
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * Support for KGDB for the Yosemite board. We make use of single serial
+ * port to be used for KGDB as well as console. The second serial port
+ * seems to be having a problem. Single IRQ is allocated for both the
+ * ports. Hence, the interrupt routing code needs to figure out whether
+ * the interrupt came from channel A or B.
+ */
+
+#include <linux/config.h>
+
+#if defined(CONFIG_KGDB)
+#include <asm/serial.h>
+
+/*
+ * Baud rate, Parity, Data and Stop bit settings for the
+ * serial port on the Yosemite. Note that the Early printk
+ * patch has been added. So, we should be all set to go
+ */
+#define	YOSEMITE_BAUD_2400	2400
+#define	YOSEMITE_BAUD_4800	4800
+#define	YOSEMITE_BAUD_9600	9600
+#define	YOSEMITE_BAUD_19200	19200
+#define	YOSEMITE_BAUD_38400	38400
+#define	YOSEMITE_BAUD_57600	57600
+#define	YOSEMITE_BAUD_115200	115200
+
+#define	YOSEMITE_PARITY_NONE	0
+#define	YOSEMITE_PARITY_ODD	0x08
+#define	YOSEMITE_PARITY_EVEN	0x18
+#define	YOSEMITE_PARITY_MARK	0x28
+#define	YOSEMITE_PARITY_SPACE	0x38
+
+#define	YOSEMITE_DATA_5BIT	0x0
+#define	YOSEMITE_DATA_6BIT	0x1
+#define	YOSEMITE_DATA_7BIT	0x2
+#define	YOSEMITE_DATA_8BIT	0x3
+
+#define	YOSEMITE_STOP_1BIT	0x0
+#define	YOSEMITE_STOP_2BIT	0x4
+
+/* This is crucial */
+#define	SERIAL_REG_OFS		0x1
+
+#define	SERIAL_RCV_BUFFER	0x0
+#define	SERIAL_TRANS_HOLD	0x0
+#define	SERIAL_SEND_BUFFER	0x0
+#define	SERIAL_INTR_ENABLE	(1 * SERIAL_REG_OFS)
+#define	SERIAL_INTR_ID		(2 * SERIAL_REG_OFS)
+#define	SERIAL_DATA_FORMAT	(3 * SERIAL_REG_OFS)
+#define	SERIAL_LINE_CONTROL	(3 * SERIAL_REG_OFS)
+#define	SERIAL_MODEM_CONTROL	(4 * SERIAL_REG_OFS)
+#define	SERIAL_RS232_OUTPUT	(4 * SERIAL_REG_OFS)
+#define	SERIAL_LINE_STATUS	(5 * SERIAL_REG_OFS)
+#define	SERIAL_MODEM_STATUS	(6 * SERIAL_REG_OFS)
+#define	SERIAL_RS232_INPUT	(6 * SERIAL_REG_OFS)
+#define	SERIAL_SCRATCH_PAD	(7 * SERIAL_REG_OFS)
+
+#define	SERIAL_DIVISOR_LSB	(0 * SERIAL_REG_OFS)
+#define	SERIAL_DIVISOR_MSB	(1 * SERIAL_REG_OFS)
+
+/*
+ * Functions to READ and WRITE to serial port 0
+ */
+#define	SERIAL_READ(ofs)		(*((volatile unsigned char*)	\
+					(TITAN_SERIAL_BASE + ofs)))
+
+#define	SERIAL_WRITE(ofs, val)		((*((volatile unsigned char*)	\
+					(TITAN_SERIAL_BASE + ofs))) = val)
+
+/*
+ * Functions to READ and WRITE to serial port 1
+ */
+#define	SERIAL_READ_1(ofs)		(*((volatile unsigned char*)	\
+					(TITAN_SERIAL_BASE_1 + ofs)
+
+#define	SERIAL_WRITE_1(ofs, val)	((*((volatile unsigned char*)	\
+					(TITAN_SERIAL_BASE_1 + ofs))) = val)
+
+/*
+ * Second serial port initialization
+ */
+void init_second_port(void)
+{
+	/* Disable Interrupts */
+	SERIAL_WRITE_1(SERIAL_LINE_CONTROL, 0x0);
+	SERIAL_WRITE_1(SERIAL_INTR_ENABLE, 0x0);
+
+	{
+		unsigned int divisor;
+
+		SERIAL_WRITE_1(SERIAL_LINE_CONTROL, 0x80);
+		divisor = TITAN_SERIAL_BASE_BAUD / YOSEMITE_BAUD_115200;
+		SERIAL_WRITE_1(SERIAL_DIVISOR_LSB, divisor & 0xff);
+
+		SERIAL_WRITE_1(SERIAL_DIVISOR_MSB,
+			       (divisor & 0xff00) >> 8);
+		SERIAL_WRITE_1(SERIAL_LINE_CONTROL, 0x0);
+	}
+
+	SERIAL_WRITE_1(SERIAL_DATA_FORMAT, YOSEMITE_DATA_8BIT |
+		       YOSEMITE_PARITY_NONE | YOSEMITE_STOP_1BIT);
+
+	/* Enable Interrupts */
+	SERIAL_WRITE_1(SERIAL_INTR_ENABLE, 0xf);
+}
+
+/* Initialize the serial port for KGDB debugging */
+void debugInit(unsigned int baud, unsigned char data, unsigned char parity,
+	       unsigned char stop)
+{
+	/* Disable Interrupts */
+	SERIAL_WRITE(SERIAL_LINE_CONTROL, 0x0);
+	SERIAL_WRITE(SERIAL_INTR_ENABLE, 0x0);
+
+	{
+		unsigned int divisor;
+
+		SERIAL_WRITE(SERIAL_LINE_CONTROL, 0x80);
+
+		divisor = TITAN_SERIAL_BASE_BAUD / baud;
+		SERIAL_WRITE(SERIAL_DIVISOR_LSB, divisor & 0xff);
+
+		SERIAL_WRITE(SERIAL_DIVISOR_MSB, (divisor & 0xff00) >> 8);
+		SERIAL_WRITE(SERIAL_LINE_CONTROL, 0x0);
+	}
+
+	SERIAL_WRITE(SERIAL_DATA_FORMAT, data | parity | stop);
+}
+
+static int remoteDebugInitialized = 0;
+
+unsigned char getDebugChar(void)
+{
+	if (!remoteDebugInitialized) {
+		remoteDebugInitialized = 1;
+		debugInit(YOSEMITE_BAUD_115200,
+			  YOSEMITE_DATA_8BIT,
+			  YOSEMITE_PARITY_NONE, YOSEMITE_STOP_1BIT);
+	}
+
+	while ((SERIAL_READ(SERIAL_LINE_STATUS) & 0x1) == 0);
+	return SERIAL_READ(SERIAL_RCV_BUFFER);
+}
+
+int putDebugChar(unsigned char byte)
+{
+	if (!remoteDebugInitialized) {
+		remoteDebugInitialized = 1;
+		debugInit(YOSEMITE_BAUD_115200,
+			  YOSEMITE_DATA_8BIT,
+			  YOSEMITE_PARITY_NONE, YOSEMITE_STOP_1BIT);
+	}
+
+	while ((SERIAL_READ(SERIAL_LINE_STATUS) & 0x20) == 0);
+	SERIAL_WRITE(SERIAL_SEND_BUFFER, byte);
+
+	return 1;
+}
+#endif
diff -puN /dev/null arch/mips/pmc-sierra/yosemite/i2c-yosemite.c
--- /dev/null	2003-09-15 06:40:47.000000000 -0700
+++ 25-akpm/arch/mips/pmc-sierra/yosemite/i2c-yosemite.c	2004-06-21 23:10:45.722268736 -0700
@@ -0,0 +1,188 @@
+/*
+ *  Copyright (C) 2003 PMC-Sierra Inc.
+ *  Author: Manish Lachwani (lachwani@pmc-sierra.com)
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+/*
+ * Detailed Description:
+ *
+ * This block implements the I2C interface to the slave devices like the
+ * Atmel 24C32 EEPROM and the MAX 1619 Sensors device. The I2C Master interface
+ * can be controlled by the SCMB block. And the SCMB block kicks in only when
+ * using the Ethernet Mode of operation and __not__ the SysAD mode
+ *
+ * The SCMB controls the two modes: MDIO and the I2C. The MDIO mode is used to
+ * communicate with the Quad-PHY from Marvel. The I2C is used to communicate
+ * with the I2C slave devices.  It seems that the driver does not explicitly
+ * deal with the control of SDA and SCL serial lines. So, the driver will set
+ * the slave address, drive the command and then the data.  The SCMB will then
+ * control the two serial lines as required.
+ *
+ * It seems the documents are very unclear abt this. Hence, I took some time
+ * out to write the desciption to have an idea of how the I2C can actually
+ * work. Currently, this Linux driver wont be integrated into the generic Linux
+ * I2C framework. And finally, the I2C interface is also known as the 2BI
+ * interface. 2BI means 2-bit interface referring to SDA and SCL serial lines
+ * respectively.
+ *
+ * - Manish Lachwani (12/09/2003)
+ */
+
+#include "i2c-yosemite.h"
+
+/*
+ * Poll the I2C interface for the BUSY bit.
+ */
+static int titan_i2c_poll(void)
+{
+	int i = 0;
+	unsigned long val = 0;
+
+	for (i = 0; i < TITAN_I2C_MAX_POLL; i++) {
+		val = TITAN_I2C_READ(TITAN_I2C_COMMAND);
+
+		if (!(val & 0x8000))
+			return 0;
+	}
+
+	return TITAN_I2C_ERR_TIMEOUT;
+}
+
+/*
+ * Execute the I2C command
+ */
+int titan_i2c_xfer(unsigned int slave_addr, titan_i2c_command * cmd,
+		   int size, unsigned int *addr)
+{
+	int loop = 0, bytes, i;
+	unsigned int *write_data, data, *read_data;
+	unsigned long reg_val, val;
+
+	write_data = cmd->data;
+	read_data = addr;
+
+	TITAN_I2C_WRITE(TITAN_I2C_SLAVE_ADDRESS, slave_addr);
+
+	if (cmd->type == TITAN_I2C_CMD_WRITE)
+		loop = cmd->write_size;
+	else
+		loop = size;
+
+	while (loop > 0) {
+		if ((cmd->type == TITAN_I2C_CMD_WRITE) ||
+		    (cmd->type == TITAN_I2C_CMD_READ_WRITE)) {
+
+			reg_val = TITAN_I2C_DATA;
+			for (i = 0; i < TITAN_I2C_MAX_WORDS_PER_RW;
+			     ++i, write_data += 2, reg_val += 4) {
+				if (bytes < cmd->write_size) {
+					data = write_data[0];
+					++data;
+				}
+
+				if (bytes < cmd->write_size) {
+					data = write_data[1];
+					++data;
+				}
+
+				TITAN_I2C_WRITE(reg_val, data);
+			}
+		}
+
+		TITAN_I2C_WRITE(TITAN_I2C_COMMAND,
+				(unsigned int) (cmd->type << 13));
+		if (titan_i2c_poll() != TITAN_I2C_ERR_OK)
+			return TITAN_I2C_ERR_TIMEOUT;
+
+		if ((cmd->type == TITAN_I2C_CMD_READ) ||
+		    (cmd->type == TITAN_I2C_CMD_READ_WRITE)) {
+
+			reg_val = TITAN_I2C_DATA;
+			for (i = 0; i < TITAN_I2C_MAX_WORDS_PER_RW;
+			     ++i, read_data += 2, reg_val += 4) {
+				data = TITAN_I2C_READ(reg_val);
+
+				if (bytes < size) {
+					read_data[0] = data & 0xff;
+					++bytes;
+				}
+
+				if (bytes < size) {
+					read_data[1] =
+					    ((data >> 8) & 0xff);
+					++bytes;
+				}
+			}
+		}
+
+		loop -= (TITAN_I2C_MAX_WORDS_PER_RW * 2);
+	}
+
+	/*
+	 * Read the Interrupt status and then return the appropriate error code
+	 */
+
+	val = TITAN_I2C_READ(TITAN_I2C_INTERRUPTS);
+	if (val & 0x0020)
+		return TITAN_I2C_ERR_ARB_LOST;
+
+	if (val & 0x0040)
+		return TITAN_I2C_ERR_NO_RESP;
+
+	if (val & 0x0080)
+		return TITAN_I2C_ERR_DATA_COLLISION;
+
+	return TITAN_I2C_ERR_OK;
+}
+
+/*
+ * Init the I2C subsystem of the PMC-Sierra Yosemite board
+ */
+int titan_i2c_init(titan_i2c_config * config)
+{
+	unsigned int val;
+
+	/*
+	 * Reset the SCMB and program into the I2C mode
+	 */
+	TITAN_I2C_WRITE(TITAN_I2C_SCMB_CONTROL, 0xA000);
+	TITAN_I2C_WRITE(TITAN_I2C_SCMB_CONTROL, 0x2000);
+
+	/*
+	 * Configure the filtera and clka values
+	 */
+	val = TITAN_I2C_READ(TITAN_I2C_SCMB_CLOCK_A);
+	val |= ((val & ~(0xF000)) | ((config->filtera << 12) & 0xF000));
+	val |= ((val & ~(0x03FF)) | (config->clka & 0x03FF));
+	TITAN_I2C_WRITE(TITAN_I2C_SCMB_CLOCK_A, val);
+
+	/*
+	 * Configure the filterb and clkb values
+	 */
+	val = TITAN_I2C_READ(TITAN_I2C_SCMB_CLOCK_B);
+	val |= ((val & ~(0xF000)) | ((config->filterb << 12) & 0xF000));
+	val |= ((val & ~(0x03FF)) | (config->clkb & 0x03FF));
+	TITAN_I2C_WRITE(TITAN_I2C_SCMB_CLOCK_B, val);
+
+	return TITAN_I2C_ERR_OK;
+}
diff -puN arch/mips/pmc-sierra/yosemite/i2c-yosemite.h~mips-update arch/mips/pmc-sierra/yosemite/i2c-yosemite.h
--- 25/arch/mips/pmc-sierra/yosemite/i2c-yosemite.h~mips-update	2004-06-21 23:10:45.419314792 -0700
+++ 25-akpm/arch/mips/pmc-sierra/yosemite/i2c-yosemite.h	2004-06-21 23:10:45.724268432 -0700
@@ -31,7 +31,7 @@
 /* Read and Write operations to the chip */
 
 #define TITAN_I2C_BASE			0xbb000000	/* XXX Needs to change */
-	
+
 #define	TITAN_I2C_WRITE(offset, data)	\
 					*(volatile unsigned long *)(TITAN_I2C_BASE + offset) = data
 
@@ -48,14 +48,14 @@
 #define TITAN_I2C_MAX_POLL		100
 
 /* Registers used for I2C work */
-#define TITAN_I2C_SCMB_CONTROL		0x0180  /* SCMB Control */
-#define TITAN_I2C_SCMB_CLOCK_A		0x0184  /* SCMB Clock A */
-#define TITAN_I2C_SCMB_CLOCK_B		0x0188  /* SCMB Clock B */
-#define	TITAN_I2C_CONFIG		0x01A0  /* I2C Config */
-#define TITAN_I2C_COMMAND		0x01A4  /* I2C Command */
+#define TITAN_I2C_SCMB_CONTROL		0x0180	/* SCMB Control */
+#define TITAN_I2C_SCMB_CLOCK_A		0x0184	/* SCMB Clock A */
+#define TITAN_I2C_SCMB_CLOCK_B		0x0188	/* SCMB Clock B */
+#define	TITAN_I2C_CONFIG		0x01A0	/* I2C Config */
+#define TITAN_I2C_COMMAND		0x01A4	/* I2C Command */
 #define	TITAN_I2C_SLAVE_ADDRESS		0x01A8	/* I2C Slave Address */
-#define TITAN_I2C_DATA			0x01AC  /* I2C Data [15:0] */
-#define TITAN_I2C_INTERRUPTS		0x01BC  /* I2C Interrupts */
+#define TITAN_I2C_DATA			0x01AC	/* I2C Data [15:0] */
+#define TITAN_I2C_INTERRUPTS		0x01BC	/* I2C Interrupts */
 
 /* Error */
 #define	TITAN_I2C_ERR_ARB_LOST		(-9220)
@@ -66,31 +66,31 @@
 
 /* I2C Command Type */
 typedef enum {
-	TITAN_I2C_CMD_WRITE		= 0,
-	TITAN_I2C_CMD_READ		= 1,
-	TITAN_I2C_CMD_READ_WRITE	= 2
+	TITAN_I2C_CMD_WRITE = 0,
+	TITAN_I2C_CMD_READ = 1,
+	TITAN_I2C_CMD_READ_WRITE = 2
 } titan_i2c_cmd_type;
 
 /* I2C structures */
 typedef struct {
-	int	filtera; 		/* Register 0x0184, bits 15 - 12*/
-	int	clka;			/* Register 0x0184, bits 9 - 0 */
-	int	filterb;		/* Register 0x0188, bits 15 - 12 */
-	int	clkb;			/* Register 0x0188, bits 9 - 0 */
+	int filtera;		/* Register 0x0184, bits 15 - 12 */
+	int clka;		/* Register 0x0184, bits 9 - 0 */
+	int filterb;		/* Register 0x0188, bits 15 - 12 */
+	int clkb;		/* Register 0x0188, bits 9 - 0 */
 } titan_i2c_config;
 
 /* I2C command type */
 typedef struct {
-	titan_i2c_cmd_type	type;		/* Type of command */
-	int			num_arb;	/* Register 0x01a0, bits 15 - 12 */
-	int			num_nak;	/* Register 0x01a0, bits 11 - 8 */
-	int			addr_size;	/* Register 0x01a0, bit 7 */
-	int			mst_code;	/* Register 0x01a0, bits 6 - 4 */
-	int			arb_en;		/* Register 0x01a0, bit 1 */
-	int			speed;		/* Register 0x01a0, bit 0 */
-	int			slave_addr;	/* Register 0x01a8 */
-	int			write_size;	/* Register 0x01a4, bits 10 - 8 */
-	unsigned int		*data;		/* Register 0x01ac */
+	titan_i2c_cmd_type type;	/* Type of command */
+	int num_arb;		/* Register 0x01a0, bits 15 - 12 */
+	int num_nak;		/* Register 0x01a0, bits 11 - 8 */
+	int addr_size;		/* Register 0x01a0, bit 7 */
+	int mst_code;		/* Register 0x01a0, bits 6 - 4 */
+	int arb_en;		/* Register 0x01a0, bit 1 */
+	int speed;		/* Register 0x01a0, bit 0 */
+	int slave_addr;		/* Register 0x01a8 */
+	int write_size;		/* Register 0x01a4, bits 10 - 8 */
+	unsigned int *data;	/* Register 0x01ac */
 } titan_i2c_command;
 
-#endif /* __I2C_YOSEMITE_H */ 
+#endif				/* __I2C_YOSEMITE_H */
diff -puN arch/mips/pmc-sierra/yosemite/irq.c~mips-update arch/mips/pmc-sierra/yosemite/irq.c
--- 25/arch/mips/pmc-sierra/yosemite/irq.c~mips-update	2004-06-21 23:10:45.421314488 -0700
+++ 25-akpm/arch/mips/pmc-sierra/yosemite/irq.c	2004-06-21 23:10:45.726268128 -0700
@@ -41,207 +41,116 @@
 #include <asm/bootinfo.h>
 #include <asm/io.h>
 #include <asm/irq.h>
+#include <asm/irq_cpu.h>
 #include <asm/mipsregs.h>
 #include <asm/system.h>
+#include <asm/titan_dep.h>
 
 /* Hypertransport specific */
-#define IRQ_STATUS_REG_CPU0     0xbb001b30 	/* INT# 3 status register on CPU 0*/
-#define	IRQ_STATUS_REG_CPU1	0xbb002b30	/* INT# 3 status register on CPU 1*/
-#define IRQ_ACK_BITS            0x00000000 	/* Ack bits */
-#define IRQ_CLEAR_REG_CPU0      0xbb002b3c 	/* IRQ clear register on CPU 0*/
-#define IRQ_CLEAR_REG_CPU0      0xbb002b3c      /* IRQ clear register on CPU 1*/
-
-#define HYPERTRANSPORT_EOI      0xbb0006E0 	/* End of Interrupt */
-#define HYPERTRANSPORT_INTA     0x78    	/* INTA# */
-#define HYPERTRANSPORT_INTB     0x79    	/* INTB# */
-#define HYPERTRANSPORT_INTC     0x7a    	/* INTC# */
-#define HYPERTRANSPORT_INTD     0x7b    	/* INTD# */
-
-#define read_32bit_cp0_set1_register(source)                    \
-({ int __res;                                                   \
-        __asm__ __volatile__(                                   \
-        ".set\tpush\n\t"                                        \
-        ".set\treorder\n\t"                                     \
-        "cfc0\t%0,"STR(source)"\n\t"                            \
-        ".set\tpop"                                             \
-        : "=r" (__res));                                        \
-        __res;})
-
-#define write_32bit_cp0_set1_register(register,value)           \
-        __asm__ __volatile__(                                   \
-        "ctc0\t%0,"STR(register)"\n\t"                          \
-        "nop"                                                   \
-        : : "r" (value));
+#define IRQ_ACK_BITS            0x00000000	/* Ack bits */
 
-static spinlock_t irq_lock = SPIN_LOCK_UNLOCKED;
-
-/* Function for careful CP0 interrupt mask access */
-static inline void modify_cp0_intmask(unsigned clr_mask_in, unsigned set_mask_in)
-{
-        unsigned long status;
-        unsigned clr_mask;
-        unsigned set_mask;
-
-        /* do the low 8 bits first */
-        clr_mask = 0xff & clr_mask_in;
-        set_mask = 0xff & set_mask_in;
-        status = read_c0_status();
-        status &= ~((clr_mask & 0xFF) << 8);
-        status |= (set_mask & 0xFF) << 8 | 0x0000FF00;
-        write_c0_status(status);
-
-        /* do the high 8 bits */
-        clr_mask = 0xff & (clr_mask_in >> 8);
-        set_mask = 0xff & (set_mask_in >> 8);
-        status = read_32bit_cp0_set1_register(CP0_S1_INTCONTROL);
-        status &= ~((clr_mask & 0xFF) << 8);
-        status |= (set_mask & 0xFF) << 8;
-        write_32bit_cp0_set1_register(CP0_S1_INTCONTROL, status);
-}
-
-static inline void mask_irq(unsigned int irq)
-{
-        modify_cp0_intmask(irq, 0);
-}
-
-static inline void unmask_irq(unsigned int irq)
-{
-        modify_cp0_intmask(0, irq);
-}
-
-static void enable_rm9000_irq(unsigned int irq)
-{
-        unsigned long flags;
-
-        spin_lock_irqsave(&irq_lock, flags);
-        unmask_irq(1 << (irq-1));
-        spin_unlock_irqrestore(&irq_lock, flags);
-}
-
-static unsigned int startup_rm9000_irq(unsigned int irq)
-{
-        enable_rm9000_irq(irq);
-
-        return 0;                               /* never anything pending */
-}
-
-static void disable_rm9000_irq(unsigned int irq)
-{
-        unsigned long flags;
-
-        spin_lock_irqsave(&irq_lock, flags);
-        mask_irq(1 << (irq-1));
-        spin_unlock_irqrestore(&irq_lock, flags);
-}
-
-#define shutdown_rm9000_irq disable_rm9000_irq
-
-static void mask_and_ack_rm9000_irq(unsigned int irq)
-{
-        mask_irq(1 << (irq-1));
-}
-
-static void end_rm9000_irq(unsigned int irq)
-{
-        if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
-                unmask_irq(1 << (irq-1));
-}
-
-static struct hw_interrupt_type rm9000_hpcdma_irq_type = {
-        "RM9000",
-        startup_rm9000_irq,
-        shutdown_rm9000_irq,
-        enable_rm9000_irq,
-        disable_rm9000_irq,
-        mask_and_ack_rm9000_irq,
-        end_rm9000_irq,
-        NULL
-};
+#define HYPERTRANSPORT_INTA     0x78		/* INTA# */
+#define HYPERTRANSPORT_INTB     0x79		/* INTB# */
+#define HYPERTRANSPORT_INTC     0x7a		/* INTC# */
+#define HYPERTRANSPORT_INTD     0x7b		/* INTD# */
 
 extern asmlinkage void titan_handle_int(void);
 extern void jaguar_mailbox_irq(struct pt_regs *);
 
 /* 
- * Handle hypertransport & SMP interrupts. The interrupt lines are scarce. For interprocessor
- * interrupts, the best thing to do is to use the INTMSG register. We use the same external
- * interrupt line, i.e. INTB3 and monitor another status bit
+ * Handle hypertransport & SMP interrupts. The interrupt lines are scarce.
+ * For interprocessor interrupts, the best thing to do is to use the INTMSG
+ * register. We use the same external interrupt line, i.e. INTB3 and monitor
+ * another status bit
  */
 asmlinkage void ll_ht_smp_irq_handler(int irq, struct pt_regs *regs)
 {
-        u32 status;
-        status = *(volatile uint32_t *)(IRQ_STATUS_REG_CPU0);
+        u32 status = OCD_READ(RM9000x2_OCD_INTP0STATUS4);
 
 	/* Ack all the bits that correspond to the interrupt sources */
 	if (status != 0)
-	        *(volatile uint32_t *)(IRQ_STATUS_REG_CPU0) = IRQ_ACK_BITS;
+	        OCD_WRITE(RM9000x2_OCD_INTP0STATUS4, IRQ_ACK_BITS);
 
-	status = *(volatile uint32_t *)(IRQ_STATUS_REG_CPU1);
+	status = OCD_READ(RM9000x2_OCD_INTP1STATUS4);
 	if (status != 0)
-                *(volatile uint32_t *)(IRQ_STATUS_REG_CPU1) = IRQ_ACK_BITS;
+                OCD_WRITE(RM9000x2_OCD_INTP1STATUS4, IRQ_ACK_BITS);
 
-#ifdef CONFIG_SMP
-	if (status == 0x2) {
-		/* This is an SMP IPI sent from one core to another */
-		jaguar_mailbox_irq(regs);
-		goto done;
-	}
-#endif
-	
 #ifdef CONFIG_HT_LEVEL_TRIGGER
-        /*
-         * Level Trigger Mode only. Send the HT EOI message back to the source.
-         */
-        switch (status) {
-                case 0x1000000:
-                        *(volatile uint32_t *)(HYPERTRANSPORT_EOI) = HYPERTRANSPORT_INTA;
-                        break;
-                case 0x2000000:
-                        *(volatile uint32_t *)(HYPERTRANSPORT_EOI) = HYPERTRANSPORT_INTB;
-                        break;
-                case 0x4000000:
-                        *(volatile uint32_t *)(HYPERTRANSPORT_EOI) = HYPERTRANSPORT_INTC;
-                        break;
-                case 0x8000000:
-                        *(volatile uint32_t *)(HYPERTRANSPORT_EOI) = HYPERTRANSPORT_INTD;
-                        break;
-                case 0x0000001:
-                        /* PLX */
-                        *(volatile uint32_t *)(HYPERTRANSPORT_EOI) = 0x20;
-                        *(volatile uint32_t *)(IRQ_CLEAR_REG) = IRQ_ACK_BITS;
-                        break;
-                case 0xf000000:
-                        *(volatile uint32_t *)(HYPERTRANSPORT_EOI) = HYPERTRANSPORT_INTA;
-                        *(volatile uint32_t *)(HYPERTRANSPORT_EOI) = HYPERTRANSPORT_INTB;
-                        *(volatile uint32_t *)(HYPERTRANSPORT_EOI) = HYPERTRANSPORT_INTC;
-                        *(volatile uint32_t *)(HYPERTRANSPORT_EOI) = HYPERTRANSPORT_INTD;
-                        break;
-        }
+	/*
+	 * Level Trigger Mode only. Send the HT EOI message back to the source.
+	 */
+	switch (status) {
+	case 0x1000000:
+		OCD_WRITE(RM9000x2_OCD_HTEOI, HYPERTRANSPORT_INTA);
+		break;
+	case 0x2000000:
+		OCD_WRITE(RM9000x2_OCD_HTEOI, HYPERTRANSPORT_INTB);
+		break;
+	case 0x4000000:
+		OCD_WRITE(RM9000x2_OCD_HTEOI, HYPERTRANSPORT_INTC);
+		break;
+	case 0x8000000:
+		OCD_WRITE(RM9000x2_OCD_HTEOI, HYPERTRANSPORT_INTD);
+		break;
+	case 0x0000001:
+		/* PLX */
+		OCD_WRITE(RM9000x2_OCD_HTEOI, 0x20);
+		OCD_WRITE(IRQ_CLEAR_REG, IRQ_ACK_BITS);
+		break;
+	case 0xf000000:
+		OCD_WRITE(RM9000x2_OCD_HTEOI, HYPERTRANSPORT_INTA);
+		OCD_WRITE(RM9000x2_OCD_HTEOI, HYPERTRANSPORT_INTB);
+		OCD_WRITE(RM9000x2_OCD_HTEOI, HYPERTRANSPORT_INTC);
+		OCD_WRITE(RM9000x2_OCD_HTEOI, HYPERTRANSPORT_INTD);
+		break;
+	}
 #endif /* CONFIG_HT_LEVEL_TRIGGER */
 
-done:
-	if (status != 0x2)
-		/* Not for SMP */
-		do_IRQ(irq, regs);	
+	do_IRQ(irq, regs);
 }
 
+#ifdef CONFIG_KGDB
+extern void init_second_port(void);
+extern void breakpoint(void);
+extern void set_debug_traps(void);
+#endif
+
 /*
  * Initialize the next level interrupt handler
  */
 void __init init_IRQ(void)
 {
-	int	i;
-
-	clear_c0_status(ST0_IM | ST0_BEV);
-	__cli();
+	clear_c0_status(ST0_IM);
 
 	set_except_vector(0, titan_handle_int);
 	init_generic_irq();
+	mips_cpu_irq_init(0);
+	rm7k_cpu_irq_init(8);
 
-	for (i = 0; i < 13; i++) {
-                irq_desc[i].status      = IRQ_DISABLED;
-                irq_desc[i].action      = 0;
-                irq_desc[i].depth       = 1;
-                irq_desc[i].handler     = &rm9000_hpcdma_irq_type;
-        }
+#ifdef CONFIG_KGDB
+	/* At this point, initialize the second serial port */
+	init_second_port();
+	printk("Start kgdb ... \n");
+	set_debug_traps();
+	breakpoint();
+#endif
+
+#ifdef CONFIG_GDB_CONSOLE
+	register_gdb_console();
+#endif
 }
 
+#ifdef CONFIG_KGDB
+/*
+ * The 16550 DUART has two ports, but is allocated one IRQ
+ * for the serial console. Hence, a generic framework for
+ * serial IRQ routing in place. Currently, just calls the
+ * do_IRQ fuction. But, going in the future, need to check
+ * DUART registers for channel A and B, then decide the
+ * appropriate action
+ */
+asmlinkage void yosemite_kgdb_irq(int irq, struct pt_regs *regs)
+{
+	do_IRQ(irq, regs);
+}
+#endif
diff -puN arch/mips/pmc-sierra/yosemite/irq-handler.S~mips-update arch/mips/pmc-sierra/yosemite/irq-handler.S
--- 25/arch/mips/pmc-sierra/yosemite/irq-handler.S~mips-update	2004-06-21 23:10:45.422314336 -0700
+++ 25-akpm/arch/mips/pmc-sierra/yosemite/irq-handler.S	2004-06-21 23:10:45.728267824 -0700
@@ -8,6 +8,10 @@
  * under  the terms of  the GNU General  Public License as published by the
  * Free Software Foundation;  either version 2 of the  License, or (at your
  * option) any later version.
+ *
+ * Titan supports Hypertransport or PCI but not both. Hence, one interrupt
+ * line is shared between the PCI slot A and Hypertransport. This is the
+ * Processor INTB #0.
  */
 
 #include <linux/config.h>
@@ -17,109 +21,90 @@
 #include <asm/regdef.h>
 #include <asm/stackframe.h>
 
-/*
- * IRQ router for the Titan board
- */
-
 		.align	5
 		NESTED(titan_handle_int, PT_SIZE, sp)
 		SAVE_ALL
 		CLI
 		.set	at
+		.set	noreorder
 		mfc0	t0, CP0_CAUSE
 		mfc0	t2, CP0_STATUS
 
 		and	t0, t2
-	
-		andi	t1, t0, STATUSF_IP0	/* INTB0 hardware line */
+
+		andi	t1, t0, STATUSF_IP2	/* INTB0 hardware line */
 		bnez	t1, ll_pcia_irq		/* 64-bit PCI */
-		andi	t1, t0, STATUSF_IP1	/* INTB1 hardware line */
+		andi	t1, t0, STATUSF_IP3	/* INTB1 hardware line */
 		bnez	t1, ll_pcib_irq		/* second 64-bit PCI slot */
-		andi	t1, t0, STATUSF_IP2	/* INTB2 hardware line */
+		andi	t1, t0, STATUSF_IP4	/* INTB2 hardware line */
 		bnez	t1, ll_duart_irq	/* UART	*/
-		andi	t1, t0, STATUSF_IP3	/* INTB3 hardware line*/
-		bnez	t1, ll_ht_smp_irq		/* Hypertransport */
-		andi	t1, t0, STATUSF_IP5	/* INTB5 hardware line */
+		andi    t1, t0, STATUSF_IP5	/* SMP inter-core interrupts */
+		bnez    t1, ll_smp_irq
+		andi	t1, t0, STATUSF_IP6
+		bnez	t1, ll_ht_irq		/* Hypertransport */
+		andi	t1, t0, STATUSF_IP7	/* INTB5 hardware line */
 		bnez	t1, ll_timer_irq	/* Timer */
 
 		nop
 		nop
 
 		/* Extended interrupts */
-		mfc0	t0, CPU_CAUSE
-		cfc0	t1, CP0_S1_INTCONTROL
+                mfc0    t0, CP0_CAUSE
+                cfc0    t1, CP0_S1_INTCONTROL
 
-		sll	t2, t1, 8
-		
-		and	t0, t2
-		srl	t0, t0, 16
-
-		
-		andi	t1, t0, STATUSF_IP6	/* INTB6 hardware line */
-		bnez	t1, ll_phy0_irq		/* Ethernet port 0 */
-		andi	t1, t0, STATUSF_IP7	/* INTB7 hardware line */
-		bnez	t1, ll_phy1_irq		/* Ethernet port 1 */
-		andi	t1, t0, STATUSF_IP8	/* INTB8 hardware line */
-		bnez	t1, ll_phy2_irq		/* Ethernet Port 2 */
+                sll     t2, t1, 8
 
-		nop
-		nop
+                and     t0, t2
+                srl     t0, t0, 16
 
 		.set	reorder
 
-		/* No handler */
 		j	spurious_interrupt
 		nop
 		END(titan_handle_int)
 
 		.align	5
 
-/* Individual Handlers */
-
 ll_pcia_irq:
-		li	a0, 1
-		move	a2, sp
+		li	a0, 2
+		move	a1, sp
+#ifdef CONFIG_HYPERTRANSPORT
+		jal	ll_ht_smp_irq_handler
+#else
 		jal	do_IRQ
+#endif
 		j	ret_from_irq
 
 ll_pcib_irq:
-		li      a0, 2
-                move    a1, sp
-                jal     do_IRQ
-                j       ret_from_irq
-
-ll_duart_irq:
 		li	a0, 3
 		move	a1, sp
 		jal	do_IRQ
 		j	ret_from_irq
 
-ll_ht_irq:
+ll_duart_irq:
 		li	a0, 4
 		move	a1, sp
-		jal	ll_ht_smp_irq_handler 	/* Detailed HT & SMP IRQ handling */
+		jal	do_IRQ
 		j	ret_from_irq
 
-ll_timer_irq:
+ll_smp_irq:
 		li	a0, 5
 		move	a1, sp
+#ifdef CONFIG_SMP
+		jal	jaguar_mailbox_irq
+#else
 		jal	do_IRQ
+#endif
 		j	ret_from_irq
 
-ll_phy0_irq:
+ll_ht_irq:
 		li	a0, 6
 		move	a1, sp
-		jal	do_IRQ
-		j	ret_from_irq	
-
-ll_phy1_irq:
-		li	a0, 7
-		move	a1, sp
-		jal	do_IRQ
+		jal	ll_ht_smp_irq_handler
 		j	ret_from_irq
 
-ll_phy2_irq:
-		li	a0, 8
+ll_timer_irq:
+		li	a0, 7
 		move	a1, sp
 		jal	do_IRQ
 		j	ret_from_irq
diff -puN arch/mips/pmc-sierra/yosemite/Makefile~mips-update arch/mips/pmc-sierra/yosemite/Makefile
--- 25/arch/mips/pmc-sierra/yosemite/Makefile~mips-update	2004-06-21 23:10:45.424314032 -0700
+++ 25-akpm/arch/mips/pmc-sierra/yosemite/Makefile	2004-06-21 23:10:45.729267672 -0700
@@ -1,8 +1,7 @@
 #
-# Makefile for the PMC-Sierra Titan 
+# Makefile for the PMC-Sierra Titan
 #
 
-obj-y    += irq-handler.o irq.o prom.o setup.o
+obj-y    += irq-handler.o irq.o i2c-yosemite.o prom.o py-console.o setup.o
 
-obj-$(CONFIG_SMP)          	+= smp.o
-obj-$(CONFIG_HYPERTRANSPORT)	+= ht-irq.o ht.o
+obj-$(CONFIG_KGDB)		+= dbg_io.o
diff -puN arch/mips/pmc-sierra/yosemite/prom.c~mips-update arch/mips/pmc-sierra/yosemite/prom.c
--- 25/arch/mips/pmc-sierra/yosemite/prom.c~mips-update	2004-06-21 23:10:45.428313424 -0700
+++ 25-akpm/arch/mips/pmc-sierra/yosemite/prom.c	2004-06-21 23:10:45.731267368 -0700
@@ -7,55 +7,44 @@
  * Copyright (C) 2003 PMC-Sierra Inc.
  * Author: Manish Lachwani (lachwani@pmc-sierra.com)
  */
-
+#include <linux/init.h>
 #include <linux/sched.h>
 #include <linux/mm.h>
+#include <linux/delay.h>
+#include <linux/smp.h>
+
 #include <asm/io.h>
 #include <asm/pgtable.h>
 #include <asm/processor.h>
 #include <asm/reboot.h>
 #include <asm/system.h>
-#include <linux/delay.h>
-#include <linux/smp.h>
 #include <asm/bootinfo.h>
+#include <asm/pmon.h>
 
 #include "setup.h"
 
-/* Call Vectors */
-struct callvectors {
-        int     (*open) (char*, int, int);
-        int     (*close) (int);
-        int     (*read) (int, void*, int);
-        int     (*write) (int, void*, int);
-        off_t   (*lseek) (int, off_t, int);
-        int     (*printf) (const char*, ...);
-        void    (*cacheflush) (void);
-        char*   (*gets) (char*);
-};
-
-struct callvectors* debug_vectors;
+struct callvectors *debug_vectors;
 
 extern unsigned long yosemite_base;
 extern unsigned long cpu_clock;
-unsigned char titan_ge_mac_addr_base[6];
 
 const char *get_system_type(void)
 {
-        return "PMC-Sierra Yosemite";
+	return "PMC-Sierra Yosemite";
 }
 
-static void prom_cpu0_exit(void)
+static void prom_cpu0_exit(void *arg)
 {
-	void	*nvram = YOSEMITE_NVRAM_BASE_ADDR;
-	
+	void *nvram = (void *) YOSEMITE_NVRAM_BASE_ADDR;
+
 	/* Ask the NVRAM/RTC/watchdog chip to assert reset in 1/16 second */
-        writeb(0x84, nvram + 0xff7);
+	writeb(0x84, nvram + 0xff7);
 
-        /* wait for the watchdog to go off */
-        mdelay(100+(1000/16));
+	/* wait for the watchdog to go off */
+	mdelay(100 + (1000 / 16));
 
-        /* if the watchdog fails for some reason, let people know */
-        printk(KERN_NOTICE "Watchdog reset failed\n");
+	/* if the watchdog fails for some reason, let people know */
+	printk(KERN_NOTICE "Watchdog reset failed\n");
 }
 
 /*
@@ -68,78 +57,73 @@ static void prom_exit(void)
 		/* CPU 1 */
 		smp_call_function(prom_cpu0_exit, NULL, 1, 1);
 #endif
-	prom_cpu0_exit;
-}
-
-/*
- * Get the MAC address from the EEPROM using the I2C protocol
- */
-void get_mac_address(char dest[6])
-{
-	/* Use the I2C command code in the i2c-yosemite */
+	prom_cpu0_exit(NULL);
 }
 
 /*
- * Halt the system 
+ * Halt the system
  */
 static void prom_halt(void)
 {
 	printk(KERN_NOTICE "\n** You can safely turn off the power\n");
 	while (1)
-                __asm__(".set\tmips3\n\t"
-                        "wait\n\t"
-                        ".set\tmips0");
+		__asm__(".set\tmips3\n\t" "wait\n\t" ".set\tmips0");
 }
 
 /*
  * Init routine which accepts the variables from PMON
  */
-__init prom_init(int argc, char **arg, char **env, struct callvectors *cv)
+void __init prom_init(void)
 {
-	int	i = 0;
+	int argc = fw_arg0;
+	char **arg = (char **) fw_arg1;
+	char **env = (char **) fw_arg2;
+	struct callvectors *cv = (struct callvectors *) fw_arg3;
+	int i = 0;
 
 	/* Callbacks for halt, restart */
-	_machine_restart = (void (*)(char *))prom_exit;	
+	_machine_restart = (void (*)(char *)) prom_exit;
 	_machine_halt = prom_halt;
 	_machine_power_off = prom_halt;
 
-#ifdef CONFIG_MIPS64
-
-	/* Do nothing for the 64-bit for now. Just implement for the 32-bit */
-
-#else /* CONFIG_MIPS64 */
+#ifdef CONFIG_MIPS32
 
 	debug_vectors = cv;
 	arcs_cmdline[0] = '\0';
 
 	/* Get the boot parameters */
 	for (i = 1; i < argc; i++) {
-                if (strlen(arcs_cmdline) + strlen(arg[i] + 1) >= sizeof(arcs_cmdline))
-                        break;
+		if (strlen(arcs_cmdline) + strlen(arg[i] + 1) >=
+		    sizeof(arcs_cmdline))
+			break;
 
 		strcat(arcs_cmdline, arg[i]);
 		strcat(arcs_cmdline, " ");
 	}
 
 	while (*env) {
-		if (strncmp("ocd_base", *env, strlen("ocd_base")) == 0) 
-			yosemite_base = simple_strtol(*env + strlen("ocd_base="),
-							NULL, 16);
-
-		if (strncmp("cpuclock", *env, strlen("cpuclock")) == 0) 
-			cpu_clock = simple_strtol(*env + strlen("cpuclock="),
-							NULL, 10);
-		
+		if (strncmp("ocd_base", *env, strlen("ocd_base")) == 0)
+			yosemite_base =
+			    simple_strtol(*env + strlen("ocd_base="), NULL,
+					  16);
+
+		if (strncmp("cpuclock", *env, strlen("cpuclock")) == 0)
+			cpu_clock =
+			    simple_strtol(*env + strlen("cpuclock="), NULL,
+					  10);
+
 		env++;
 	}
+#endif /* CONFIG_MIPS32 */
+
+#ifdef CONFIG_MIPS64
+
+	/* Do nothing for the 64-bit for now. Just implement for the 32-bit */
+
 #endif /* CONFIG_MIPS64 */
 
 	mips_machgroup = MACH_GROUP_TITAN;
 	mips_machtype = MACH_TITAN_YOSEMITE;
-
-	get_mac_address(titan_ge_mac_addr_base);
-
-	debug_vectors->printf("Booting Linux kernel...\n");
 }
 
 void __init prom_free_prom_memory(void)
@@ -149,41 +133,3 @@ void __init prom_free_prom_memory(void)
 void __init prom_fixup_mem_map(unsigned long start, unsigned long end)
 {
 }
-
-extern void asmlinkage smp_bootstrap(void);
-
-/*
- * SMP support
- */
-int prom_setup_smp(void)
-{
-        int     num_cpus = 2;
-
-        /*
-         * We know that the RM9000 on the Jaguar ATX board has 2 cores. Hence, this
-         * can be hardcoded for now.
-         */
-        return num_cpus;
-}
-
-int prom_boot_secondary(int cpu, unsigned long sp, unsigned long gp)
-{
-        /* Clear the semaphore */
-        *(volatile uint32_t *)(0xbb000a68) = 0x80000000;
-
-        return 1;
-}
-
-void prom_init_secondary(void)
-{
-        clear_c0_config(CONF_CM_CMASK);
-        set_c0_config(0x2);
-
-        clear_c0_status(ST0_IM);
-        set_c0_status(0x1ffff);
-}
-
-void prom_smp_finish(void)
-{
-}
-	
diff -puN /dev/null arch/mips/pmc-sierra/yosemite/py-console.c
--- /dev/null	2003-09-15 06:40:47.000000000 -0700
+++ 25-akpm/arch/mips/pmc-sierra/yosemite/py-console.c	2004-06-21 23:10:45.733267064 -0700
@@ -0,0 +1,130 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001, 2002, 2004 Ralf Baechle
+ */
+#include <linux/init.h>
+#include <linux/console.h>
+#include <linux/kdev_t.h>
+#include <linux/major.h>
+#include <linux/termios.h>
+#include <linux/sched.h>
+#include <linux/tty.h>
+
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <asm/serial.h>
+#include <asm/io.h>
+
+/* SUPERIO uart register map */
+struct yo_uartregs {
+	union {
+		volatile u8	rbr;	/* read only, DLAB == 0 */
+		volatile u8	thr;	/* write only, DLAB == 0 */
+		volatile u8	dll;	/* DLAB == 1 */
+	} u1;
+	union {
+		volatile u8	ier;	/* DLAB == 0 */
+		volatile u8	dlm;	/* DLAB == 1 */
+	} u2;
+	union {
+		volatile u8	iir;	/* read only */
+		volatile u8	fcr;	/* write only */
+	} u3;
+	volatile u8	iu_lcr;
+	volatile u8	iu_mcr;
+	volatile u8	iu_lsr;
+	volatile u8	iu_msr;
+	volatile u8	iu_scr;
+} yo_uregs_t;
+
+#define iu_rbr u1.rbr
+#define iu_thr u1.thr
+#define iu_dll u1.dll
+#define iu_ier u2.ier
+#define iu_dlm u2.dlm
+#define iu_iir u3.iir
+#define iu_fcr u3.fcr
+
+extern unsigned long uart_base;
+
+#define IO_BASE_64	0x9000000000000000ULL
+
+static unsigned char readb_outer_space(unsigned long phys)
+{
+	unsigned long long vaddr = IO_BASE_64 | phys;
+	unsigned char res;
+	unsigned int sr;
+
+	sr = read_c0_status();
+	write_c0_status((sr | ST0_KX) & ~ ST0_IE);
+	__asm__("sll	$0, $0, 2\n");
+	__asm__("sll	$0, $0, 2\n");
+	__asm__("sll	$0, $0, 2\n");
+	__asm__("sll	$0, $0, 2\n");
+
+	__asm__ __volatile__ (
+	"	.set	mips3		\n"
+	"	ld	%0, (%0)	\n"
+	"	lbu	%0, (%0)	\n"
+	"	.set	mips0		\n"
+	: "=r" (res)
+	: "0" (&vaddr));
+
+	write_c0_status(sr);
+	__asm__("sll	$0, $0, 2\n");
+	__asm__("sll	$0, $0, 2\n");
+	__asm__("sll	$0, $0, 2\n");
+	__asm__("sll	$0, $0, 2\n");
+
+	return res;
+}
+
+static void writeb_outer_space(unsigned long phys, unsigned char c)
+{
+	unsigned long long vaddr = IO_BASE_64 | phys;
+	unsigned long tmp;
+	unsigned int sr;
+
+	sr = read_c0_status();
+	write_c0_status((sr | ST0_KX) & ~ ST0_IE);
+	__asm__("sll	$0, $0, 2\n");
+	__asm__("sll	$0, $0, 2\n");
+	__asm__("sll	$0, $0, 2\n");
+	__asm__("sll	$0, $0, 2\n");
+
+	__asm__ __volatile__ (
+	"	.set	mips3		\n"
+	"	ld	%0, (%1)	\n"
+	"	sb	%2, (%0)	\n"
+	"	.set	mips0		\n"
+	: "=r" (tmp)
+	: "r" (&vaddr), "r" (c));
+
+	write_c0_status(sr);
+	__asm__("sll	$0, $0, 2\n");
+	__asm__("sll	$0, $0, 2\n");
+	__asm__("sll	$0, $0, 2\n");
+	__asm__("sll	$0, $0, 2\n");
+}
+
+static inline struct yo_uartregs *console_uart(void)
+{
+	return (struct yo_uartregs *) (uart_base + 8);
+}
+
+void prom_putchar(char c)
+{
+	unsigned long lsr = 0xfd000008UL + offsetof(struct yo_uartregs, iu_lsr);
+	unsigned long thr = 0xfd000008UL + offsetof(struct yo_uartregs, iu_thr);
+
+	while ((readb_outer_space(lsr) & 0x20) == 0);
+	writeb_outer_space(thr, c);
+}
+
+char __init prom_getchar(void)
+{
+	return 0;
+}
diff -puN arch/mips/pmc-sierra/yosemite/setup.c~mips-update arch/mips/pmc-sierra/yosemite/setup.c
--- 25/arch/mips/pmc-sierra/yosemite/setup.c~mips-update	2004-06-21 23:10:45.430313120 -0700
+++ 25-akpm/arch/mips/pmc-sierra/yosemite/setup.c	2004-06-21 23:10:45.735266760 -0700
@@ -1,6 +1,4 @@
 /*
- *  arch/mips/pmc-sierra/yosemite/setup.c
- *
  *  Copyright (C) 2003 PMC-Sierra Inc.
  *  Author: Manish Lachwani (lachwani@pmc-sierra.com)
  *
@@ -24,19 +22,18 @@
  *  with this program; if not, write  to the Free Software Foundation, Inc.,
  *  675 Mass Ave, Cambridge, MA 02139, USA.
  */
-
+#include <linux/bcd.h>
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/types.h>
-#include <linux/mc146818rtc.h>
 #include <linux/mm.h>
+#include <linux/bootmem.h>
 #include <linux/swap.h>
 #include <linux/ioport.h>
 #include <linux/sched.h>
 #include <linux/interrupt.h>
-#include <linux/pci.h>
 #include <linux/timex.h>
-#include <linux/vmalloc.h>
+
 #include <asm/time.h>
 #include <asm/bootinfo.h>
 #include <asm/page.h>
@@ -46,36 +43,46 @@
 #include <asm/processor.h>
 #include <asm/ptrace.h>
 #include <asm/reboot.h>
-#include <linux/version.h>
-#include <linux/bootmem.h>
-#include <linux/blk.h>
+#include <asm/pci_channel.h>
+#include <asm/serial.h>
+#include <linux/termios.h>
+#include <linux/tty.h>
+#include <linux/serial.h>
+#include <linux/serial_core.h>
+#include <asm/titan_dep.h>
 
 #include "setup.h"
 
+unsigned char titan_ge_mac_addr_base[6] = {
+	0x00, 0x03, 0xcc, 0x1d, 0x22, 0x00
+};
+
 unsigned long cpu_clock;
 unsigned long yosemite_base;
 
-void __init bus_error_init(void) 
-{ 
-	/* Do nothing */ 
+void __init bus_error_init(void)
+{
+	/* Do nothing */
 }
 
 unsigned long m48t37y_get_time(void)
 {
-	unsigned char	*rtc_base = YOSEMITE_RTC_BASE;
-	unsigned int	year, month, day, hour, min, sec;
+	//unsigned char *rtc_base = (unsigned char *) YOSEMITE_RTC_BASE;
+	unsigned char *rtc_base = (unsigned char *) 0xfc000000UL;
+	unsigned int year, month, day, hour, min, sec;
+return;
 
 	/* Stop the update to the time */
 	rtc_base[0x7ff8] = 0x40;
 
-	year = CONV_BCD_TO_BIN(rtc_base[0x7fff]);
-	year += CONV_BCD_TO_BIN(rtc_base[0x7fff1]) * 100;
+	year = BCD2BIN(rtc_base[0x7fff]);
+	year += BCD2BIN(rtc_base[0x7fff1]) * 100;
 
-	month = CONV_BCD_TO_BIN(rtc_base[0x7ffe]);
-	day = CONV_BCD_TO_BIN(rtc_base[0x7ffd]);
-	hour = CONV_BCD_TO_BIN(rtc_base[0x7ffb]);
-	min = CONV_BCD_TO_BIN(rtc_base[0x7ffa]);
-	sec = CONV_BCD_TO_BIN(rtc_base[0x7ff9]);
+	month = BCD2BIN(rtc_base[0x7ffe]);
+	day = BCD2BIN(rtc_base[0x7ffd]);
+	hour = BCD2BIN(rtc_base[0x7ffb]);
+	min = BCD2BIN(rtc_base[0x7ffa]);
+	sec = BCD2BIN(rtc_base[0x7ff9]);
 
 	/* Start the update to the time again */
 	rtc_base[0x7ff8] = 0x00;
@@ -85,83 +92,119 @@ unsigned long m48t37y_get_time(void)
 
 int m48t37y_set_time(unsigned long sec)
 {
-	unsigned char   *rtc_base = YOSEMITE_RTC_BASE;
-        unsigned int    year, month, day, hour, min, sec;
-
-        struct rtc_time tm;
+	unsigned char *rtc_base = (unsigned char *) YOSEMITE_RTC_BASE;
+	struct rtc_time tm;
+return;
 
-        /* convert to a more useful format -- note months count from 0 */
-        to_tm(sec, &tm);
-        tm.tm_mon += 1;
+	/* convert to a more useful format -- note months count from 0 */
+	to_tm(sec, &tm);
+	tm.tm_mon += 1;
 
-        /* enable writing */
-        rtc_base[0x7ff8] = 0x80;
+	/* enable writing */
+	rtc_base[0x7ff8] = 0x80;
 
-        /* year */
-        rtc_base[0x7fff] = CONV_BIN_TO_BCD(tm.tm_year % 100);
-        rtc_base[0x7ff1] = CONV_BIN_TO_BCD(tm.tm_year / 100);
+	/* year */
+	rtc_base[0x7fff] = BIN2BCD(tm.tm_year % 100);
+	rtc_base[0x7ff1] = BIN2BCD(tm.tm_year / 100);
 
-        /* month */
-        rtc_base[0x7ffe] = CONV_BIN_TO_BCD(tm.tm_mon);
+	/* month */
+	rtc_base[0x7ffe] = BIN2BCD(tm.tm_mon);
 
-        /* day */
-        rtc_base[0x7ffd] = CONV_BIN_TO_BCD(tm.tm_mday);
+	/* day */
+	rtc_base[0x7ffd] = BIN2BCD(tm.tm_mday);
 
-        /* hour/min/sec */
-        rtc_base[0x7ffb] = CONV_BIN_TO_BCD(tm.tm_hour);
-        rtc_base[0x7ffa] = CONV_BIN_TO_BCD(tm.tm_min);
-        rtc_base[0x7ff9] = CONV_BIN_TO_BCD(tm.tm_sec);
+	/* hour/min/sec */
+	rtc_base[0x7ffb] = BIN2BCD(tm.tm_hour);
+	rtc_base[0x7ffa] = BIN2BCD(tm.tm_min);
+	rtc_base[0x7ff9] = BIN2BCD(tm.tm_sec);
 
-        /* day of week -- not really used, but let's keep it up-to-date */
-        rtc_base[0x7ffc] = CONV_BIN_TO_BCD(tm.tm_wday + 1);
+	/* day of week -- not really used, but let's keep it up-to-date */
+	rtc_base[0x7ffc] = BIN2BCD(tm.tm_wday + 1);
 
-        /* disable writing */
-        rtc_base[0x7ff8] = 0x00;
+	/* disable writing */
+	rtc_base[0x7ff8] = 0x00;
 
-        return 0;
+	return 0;
 }
 
 void yosemite_timer_setup(struct irqaction *irq)
 {
-	setup_irq(6, irq);
+	setup_irq(7, irq);
 }
 
 void yosemite_time_init(void)
 {
-	mips_counter_frequency = cpu_clock / 2;
 	board_timer_setup = yosemite_timer_setup;
+	mips_hpt_frequency = cpu_clock / 2;
 
 	rtc_get_time = m48t37y_get_time;
 	rtc_set_time = m48t37y_set_time;
 }
 
+unsigned long uart_base = 0xfd000000L;
+
+/* No other usable initialization hook than this ...  */
+extern void (*late_time_init)(void);
+
+unsigned long ocd_base;
+
+EXPORT_SYMBOL(ocd_base);
+
+/*
+ * Common setup before any secondaries are started
+ */
+
+#define TITAN_UART_CLK		3686400
+#define TITAN_SERIAL_BASE_BAUD	(TITAN_UART_CLK / 16)
+#define TITAN_SERIAL_IRQ	4
+#define TITAN_SERIAL_BASE	0xfd000008UL
+
+static void __init py_map_ocd(void)
+{
+        struct uart_port up;
+
+	/*
+	 * Not specifically interrupt stuff but in case of SMP core_send_ipi
+	 * needs this first so I'm mapping it here ...
+	 */
+	ocd_base = (unsigned long) ioremap(OCD_BASE, OCD_SIZE);
+	if (!ocd_base)
+		panic("Mapping OCD failed - game over.  Your score is 0.");
+
+	/*
+	 * Register to interrupt zero because we share the interrupt with
+	 * the serial driver which we don't properly support yet.
+	 */
+	memset(&up, 0, sizeof(up));
+	up.membase      = (unsigned char *) ioremap(TITAN_SERIAL_BASE, 8);
+	up.irq          = TITAN_SERIAL_IRQ;
+	up.uartclk      = TITAN_UART_CLK;
+	up.regshift     = 0;
+	up.iotype       = UPIO_MEM;
+	up.flags        = ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST;
+	up.line         = 0;
+
+	if (early_serial_setup(&up))
+		printk(KERN_ERR "Early serial init of port 0 failed\n");
+}
+
 static int __init pmc_yosemite_setup(void)
 {
-	unsigned long	val = 0;
+	extern void pmon_smp_bootstrap(void);
 
-	printk("PMC-Sierra Yosemite Board Setup  \n");
 	board_time_init = yosemite_time_init;
+	late_time_init = py_map_ocd;
 
 	/* Add memory regions */
 	add_memory_region(0x00000000, 0x10000000, BOOT_MEM_RAM);
-	add_memory_region(0x10000000, 0x10000000, BOOT_MEM_RAM);
-
-	/* Setup the HT controller */
-	val = *(volatile uint32_t *)(HYPERTRANSPORT_CONFIG_REG);
-	val |= HYPERTRANSPORT_ENABLE;
-        *(volatile uint32_t *)(HYPERTRANSPORT_CONFIG_REG) = val;
-
-        /* Set the BAR. Shifted mode */
-        *(volatile uint32_t *)(HYPERTRANSPORT_BAR0_REG) = HYPERTRANSPORT_BAR0_ADDR;
-        *(volatile uint32_t *)(HYPERTRANSPORT_SIZE0_REG) = HYPERTRANSPORT_SIZE0;
-
-#ifdef CONFIG_PCI
-	ioport_resource.start = 0xe0000000;
-	ioport_resource.end   = 0xe0000000 + 0x20000000 - 1;
-	iomem_resource.start  = 0xc0000000;
-	iomem_resource.end    = 0xc0000000 + 0x20000000 - 1;
 
-	pci_scan_bus(0, &titan_pci_ops, NULL);
+#if 0 /* XXX Crash ...  */
+	OCD_WRITE(RM9000x2_OCD_HTSC,
+	          OCD_READ(RM9000x2_OCD_HTSC) | HYPERTRANSPORT_ENABLE);
+
+	/* Set the BAR. Shifted mode */
+	OCD_WRITE(RM9000x2_OCD_HTBAR0, HYPERTRANSPORT_BAR0_ADDR);
+	OCD_WRITE(RM9000x2_OCD_HTMASK0, HYPERTRANSPORT_SIZE0);
 #endif
 
 	return 0;
diff -puN arch/mips/pmc-sierra/yosemite/setup.h~mips-update arch/mips/pmc-sierra/yosemite/setup.h
--- 25/arch/mips/pmc-sierra/yosemite/setup.h~mips-update	2004-06-21 23:10:45.431312968 -0700
+++ 25-akpm/arch/mips/pmc-sierra/yosemite/setup.h	2004-06-21 23:10:45.736266608 -0700
@@ -9,27 +9,13 @@
  * Free Software Foundation;  either version 2 of the  License, or (at your
  * option) any later version.
  */
-
 #ifndef __SETUP_H__
 #define __SETUP_H__
 
-/* Real Time Clock base */
-#define	YOSEMITE_RTC_BASE
-#define CONV_BCD_TO_BIN(val)    (((val) & 0xf) + (((val) >> 4) * 10))
-#define CONV_BIN_TO_BCD(val)    (((val) % 10) + (((val) / 10) << 4))
-
 /* NVRAM Base */
 #define	YOSEMITE_NVRAM_BASE_ADDR	0xbb000678	/* XXX Need change */
 #define	YOSEMITE_RTC_BASE		0xbb000679	/* XXX Need change */
 
-/*
- * Hypertransport Specific 
- */
-#define HYPERTRANSPORT_CONFIG_REG       0xbb000604
-#define HYPERTRANSPORT_BAR0_REG         0xbb000610
-#define HYPERTRANSPORT_SIZE0_REG        0xbb000688
-#define HYPERTRANSPORT_BAR0_ATTR_REG    0xbb000680
-
 #define HYPERTRANSPORT_BAR0_ADDR        0x00000006
 #define HYPERTRANSPORT_SIZE0            0x0fffffff
 #define HYPERTRANSPORT_BAR0_ATTR        0x00002000
@@ -37,11 +23,9 @@
 #define HYPERTRANSPORT_ENABLE           0x6
 
 /*
- * EEPROM Size 
+ * EEPROM Size
  */
 #define	TITAN_ATMEL_24C32_SIZE		32768
 #define	TITAN_ATMEL_24C64_SIZE		65536
 
-
 #endif /* __SETUP_H__ */
-
diff -puN arch/mips/ramdisk/Makefile~mips-update arch/mips/ramdisk/Makefile
--- 25/arch/mips/ramdisk/Makefile~mips-update	2004-06-21 23:10:45.435312360 -0700
+++ 25-akpm/arch/mips/ramdisk/Makefile	2004-06-21 23:10:45.737266456 -0700
@@ -12,7 +12,7 @@ img := $(subst $(src)//,/,$(src)/$(img))
 
 quiet_cmd_ramdisk = LD      $@
 define cmd_ramdisk
-	$(LD) -T $(src)/ld.script -b binary --oformat $(O_FORMAT) -o $@ $(img)
+	$(LD) $(LDFLAGS) -T $(src)/ld.script -b binary --oformat $(O_FORMAT) -o $@ $(img)
 endef
 
 $(obj)/ramdisk.o: $(img) $(src)/ld.script
diff -puN arch/mips/sgi-ip22/ip22-setup.c~mips-update arch/mips/sgi-ip22/ip22-setup.c
--- 25/arch/mips/sgi-ip22/ip22-setup.c~mips-update	2004-06-21 23:10:45.437312056 -0700
+++ 25-akpm/arch/mips/sgi-ip22/ip22-setup.c	2004-06-21 23:10:45.738266304 -0700
@@ -10,6 +10,7 @@
 #include <linux/kernel.h>
 #include <linux/kdev_t.h>
 #include <linux/types.h>
+#include <linux/module.h>
 #include <linux/console.h>
 #include <linux/sched.h>
 #include <linux/tty.h>
@@ -54,6 +55,8 @@ void ip22_do_break(void)
 	ArcEnterInteractiveMode();
 }
 
+EXPORT_SYMBOL(ip22_do_break);
+
 extern void ip22_be_init(void) __init;
 extern void ip22_time_init(void) __init;
 
diff -puN arch/mips/vr41xx/common/bcu.c~mips-update arch/mips/vr41xx/common/bcu.c
--- 25/arch/mips/vr41xx/common/bcu.c~mips-update	2004-06-21 23:10:45.440311600 -0700
+++ 25-akpm/arch/mips/vr41xx/common/bcu.c	2004-06-21 23:10:45.740266000 -0700
@@ -1,34 +1,23 @@
 /*
- * FILE NAME
- *	arch/mips/vr41xx/common/bcu.c
+ *  bcu.c, Bus Control Unit routines for the NEC VR4100 series.
  *
- * BRIEF MODULE DESCRIPTION
- *	Bus Control Unit routines for the NEC VR4100 series.
- *
- * Author: Yoichi Yuasa
- *         yyuasa@mvista.com or source@mvista.com
- *
- * Copyright 2002 MontaVista Software Inc.
- *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License as published by the
- *  Free Software Foundation; either version 2 of the License, or (at your
- *  option) any later version.
- *
- *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
- *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
- *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *  Copyright (C) 2002  MontaVista Software Inc.
+ *    Author: Yoichi Yuasa <yyuasa@mvista.com, or source@mvista.com>
+ *  Copyright (C) 2003-2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 /*
  * Changes:
@@ -40,12 +29,16 @@
  *  - Added support for NEC VR4133.
  */
 #include <linux/init.h>
+#include <linux/ioport.h>
 #include <linux/smp.h>
 #include <linux/types.h>
 
 #include <asm/cpu.h>
 #include <asm/io.h>
 
+#define IO_MEM_RESOURCE_START	0UL
+#define IO_MEM_RESOURCE_END	0x1fffffffUL
+
 #define CLKSPEEDREG_TYPE1	KSEG1ADDR(0x0b000014)
 #define CLKSPEEDREG_TYPE2	KSEG1ADDR(0x0f000014)
  #define CLKSP(x)		((x) & 0x001f)
@@ -213,7 +206,7 @@ static inline unsigned long calculate_tc
 	return tclock;
 }
 
-void __init vr41xx_bcu_init(void)
+static int __init vr41xx_bcu_init(void)
 {
 	unsigned long pclock;
 	uint16_t clkspeed;
@@ -223,4 +216,11 @@ void __init vr41xx_bcu_init(void)
 	pclock = calculate_pclock(clkspeed);
 	vr41xx_vtclock = calculate_vtclock(clkspeed, pclock);
 	vr41xx_tclock = calculate_tclock(clkspeed, pclock, vr41xx_vtclock);
+
+	iomem_resource.start = IO_MEM_RESOURCE_START;
+	iomem_resource.end = IO_MEM_RESOURCE_END;
+
+	return 0;
 }
+
+early_initcall(vr41xx_bcu_init);
diff -puN arch/mips/vr41xx/common/cmu.c~mips-update arch/mips/vr41xx/common/cmu.c
--- 25/arch/mips/vr41xx/common/cmu.c~mips-update	2004-06-21 23:10:45.442311296 -0700
+++ 25-akpm/arch/mips/vr41xx/common/cmu.c	2004-06-21 23:10:45.741265848 -0700
@@ -200,7 +200,7 @@ void vr41xx_mask_clock(vr41xx_clock_t cl
 	spin_unlock_irq(&cmu_lock);
 }
 
-void __init vr41xx_cmu_init(void)
+static int __init vr41xx_cmu_init(void)
 {
 	switch (current_cpu_data.cputype) {
         case CPU_VR4111:
@@ -223,4 +223,8 @@ void __init vr41xx_cmu_init(void)
 	cmuclkmsk = read_cmuclkmsk();
 
 	spin_lock_init(&cmu_lock);
+
+	return 0;
 }
+
+early_initcall(vr41xx_cmu_init);
diff -puN arch/mips/vr41xx/common/giu.c~mips-update arch/mips/vr41xx/common/giu.c
--- 25/arch/mips/vr41xx/common/giu.c~mips-update	2004-06-21 23:10:45.444310992 -0700
+++ 25-akpm/arch/mips/vr41xx/common/giu.c	2004-06-21 23:10:45.745265240 -0700
@@ -28,10 +28,12 @@
  *  - Added support for NEC VR4133.
  *  - Removed board_irq_init.
  */
+#include <linux/config.h>
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/irq.h>
 #include <linux/kernel.h>
+#include <linux/module.h>
 #include <linux/smp.h>
 #include <linux/types.h>
 
@@ -64,6 +66,8 @@ static uint32_t giu_base;
 #define read_giuint(offset)		readw(giu_base + (offset))
 #define write_giuint(val, offset)	writew((val), giu_base + (offset))
 
+#define GIUINT_HIGH_OFFSET	16
+
 static inline uint16_t set_giuint(uint8_t offset, uint16_t set)
 {
 	uint16_t res;
@@ -86,35 +90,121 @@ static inline uint16_t clear_giuint(uint
 	return res;
 }
 
-void vr41xx_enable_giuint(int pin)
+static unsigned int startup_giuint_low_irq(unsigned int irq)
 {
-	if (pin < 16)
-		set_giuint(GIUINTENL, (uint16_t)1 << pin);
-	else
-		set_giuint(GIUINTENH, (uint16_t)1 << (pin - 16));
+	unsigned int pin;
+
+	pin = GIU_IRQ_TO_PIN(irq);
+	write_giuint((uint16_t)1 << pin, GIUINTSTATL);
+	set_giuint(GIUINTENL, (uint16_t)1 << pin);
+
+	return 0;
 }
 
-void vr41xx_disable_giuint(int pin)
+static void shutdown_giuint_low_irq(unsigned int irq)
 {
-	if (pin < 16)
-		clear_giuint(GIUINTENL, (uint16_t)1 << pin);
-	else
-		clear_giuint(GIUINTENH, (uint16_t)1 << (pin - 16));
+	clear_giuint(GIUINTENL, (uint16_t)1 << GIU_IRQ_TO_PIN(irq));
 }
 
-void vr41xx_clear_giuint(int pin)
+static void enable_giuint_low_irq(unsigned int irq)
 {
-	if (pin < 16)
-		write_giuint((uint16_t)1 << pin, GIUINTSTATL);
-	else
-		write_giuint((uint16_t)1 << (pin - 16), GIUINTSTATH);
+	set_giuint(GIUINTENL, (uint16_t)1 << GIU_IRQ_TO_PIN(irq));
+}
+
+#define disable_giuint_low_irq	shutdown_giuint_low_irq
+
+static void ack_giuint_low_irq(unsigned int irq)
+{
+	unsigned int pin;
+
+	pin = GIU_IRQ_TO_PIN(irq);
+	clear_giuint(GIUINTENL, (uint16_t)1 << pin);
+	write_giuint((uint16_t)1 << pin, GIUINTSTATL);
+}
+
+static void end_giuint_low_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS)))
+		set_giuint(GIUINTENL, (uint16_t)1 << GIU_IRQ_TO_PIN(irq));
+}
+
+static struct hw_interrupt_type giuint_low_irq_type = {
+	.typename	= "GIUINTL",
+	.startup	= startup_giuint_low_irq,
+	.shutdown	= shutdown_giuint_low_irq,
+	.enable		= enable_giuint_low_irq,
+	.disable	= disable_giuint_low_irq,
+	.ack		= ack_giuint_low_irq,
+	.end		= end_giuint_low_irq,
+};
+
+static unsigned int startup_giuint_high_irq(unsigned int irq)
+{
+	unsigned int pin;
+
+	pin = GIU_IRQ_TO_PIN(irq - GIUINT_HIGH_OFFSET);
+	write_giuint((uint16_t)1 << pin, GIUINTSTATH);
+	set_giuint(GIUINTENH, (uint16_t)1 << pin);
+
+	return 0;
+}
+
+static void shutdown_giuint_high_irq(unsigned int irq)
+{
+	clear_giuint(GIUINTENH, (uint16_t)1 << GIU_IRQ_TO_PIN(irq - GIUINT_HIGH_OFFSET));
+}
+
+static void enable_giuint_high_irq(unsigned int irq)
+{
+	set_giuint(GIUINTENH, (uint16_t)1 << GIU_IRQ_TO_PIN(irq - GIUINT_HIGH_OFFSET));
+}
+
+#define disable_giuint_high_irq	shutdown_giuint_high_irq
+
+static void ack_giuint_high_irq(unsigned int irq)
+{
+	unsigned int pin;
+
+	pin = GIU_IRQ_TO_PIN(irq - GIUINT_HIGH_OFFSET);
+	clear_giuint(GIUINTENH, (uint16_t)1 << pin);
+	write_giuint((uint16_t)1 << pin, GIUINTSTATH);
+}
+
+static void end_giuint_high_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS)))
+		set_giuint(GIUINTENH, (uint16_t)1 << GIU_IRQ_TO_PIN(irq - GIUINT_HIGH_OFFSET));
+}
+
+static struct hw_interrupt_type giuint_high_irq_type = {
+	.typename	= "GIUINTH",
+	.startup	= startup_giuint_high_irq,
+	.shutdown	= shutdown_giuint_high_irq,
+	.enable		= enable_giuint_high_irq,
+	.disable	= disable_giuint_high_irq,
+	.ack		= ack_giuint_high_irq,
+	.end		= end_giuint_high_irq,
+};
+
+void __init init_vr41xx_giuint_irq(void)
+{
+	int i;
+
+	for (i = GIU_IRQ_BASE; i <= GIU_IRQ_LAST; i++) {
+		if (i < (GIU_IRQ_BASE + GIUINT_HIGH_OFFSET))
+			irq_desc[i].handler = &giuint_low_irq_type;
+		else
+			irq_desc[i].handler = &giuint_high_irq_type;
+	}
+
+	setup_irq(GIUINT_CASCADE_IRQ, &giu_cascade);
 }
 
 void vr41xx_set_irq_trigger(int pin, int trigger, int hold)
 {
 	uint16_t mask;
 
-	if (pin < 16) {
+	if (pin < GIUINT_HIGH_OFFSET) {
 		mask = (uint16_t)1 << pin;
 		if (trigger != TRIGGER_LEVEL) {
         		set_giuint(GIUINTTYPL, mask);
@@ -142,8 +232,9 @@ void vr41xx_set_irq_trigger(int pin, int
 			clear_giuint(GIUINTTYPL, mask);
 			clear_giuint(GIUINTHTSELL, mask);
 		}
+		write_giuint(mask, GIUINTSTATL);
 	} else {
-		mask = (uint16_t)1 << (pin - 16);
+		mask = (uint16_t)1 << (pin - GIUINT_HIGH_OFFSET);
 		if (trigger != TRIGGER_LEVEL) {
 			set_giuint(GIUINTTYPH, mask);
 			if (hold == SIGNAL_HOLD)
@@ -170,32 +261,35 @@ void vr41xx_set_irq_trigger(int pin, int
 			clear_giuint(GIUINTTYPH, mask);
 			clear_giuint(GIUINTHTSELH, mask);
 		}
+		write_giuint(mask, GIUINTSTATH);
 	}
-
-	vr41xx_clear_giuint(pin);
 }
 
+EXPORT_SYMBOL(vr41xx_set_irq_trigger);
+
 void vr41xx_set_irq_level(int pin, int level)
 {
 	uint16_t mask;
 
-	if (pin < 16) {
+	if (pin < GIUINT_HIGH_OFFSET) {
 		mask = (uint16_t)1 << pin;
 		if (level == LEVEL_HIGH)
 			set_giuint(GIUINTALSELL, mask);
 		else
 			clear_giuint(GIUINTALSELL, mask);
+		write_giuint(mask, GIUINTSTATL);
 	} else {
-		mask = (uint16_t)1 << (pin - 16);
+		mask = (uint16_t)1 << (pin - GIUINT_HIGH_OFFSET);
 		if (level == LEVEL_HIGH)
 			set_giuint(GIUINTALSELH, mask);
 		else
 			clear_giuint(GIUINTALSELH, mask);
+		write_giuint(mask, GIUINTSTATH);
 	}
-
-	vr41xx_clear_giuint(pin);
 }
 
+EXPORT_SYMBOL(vr41xx_set_irq_level);
+
 #define GIUINT_NR_IRQS		32
 
 enum {
@@ -232,7 +326,7 @@ int vr41xx_cascade_irq(unsigned int irq,
 	giuint_cascade[pin].get_irq_number = get_irq_number;
 
 	retval = setup_irq(irq, &giu_cascade);
-	if (retval) {
+	if (retval != 0) {
 		giuint_cascade[pin].flag = GIUINT_NO_CASCADE;
 		giuint_cascade[pin].get_irq_number = no_irq_number;
 	}
@@ -240,29 +334,89 @@ int vr41xx_cascade_irq(unsigned int irq,
 	return retval;
 }
 
-unsigned int giuint_do_IRQ(int pin, struct pt_regs *regs)
+EXPORT_SYMBOL(vr41xx_cascade_irq);
+
+static inline int get_irq_pin_number(void)
+{
+	uint16_t pendl, pendh, maskl, maskh;
+	int i;
+
+	pendl = read_giuint(GIUINTSTATL);
+	pendh = read_giuint(GIUINTSTATH);
+	maskl = read_giuint(GIUINTENL);
+	maskh = read_giuint(GIUINTENH);
+
+	maskl &= pendl;
+	maskh &= pendh;
+
+	if (maskl) {
+		for (i = 0; i < 16; i++) {
+			if (maskl & ((uint16_t)1 << i))
+				return i;
+		}
+	} else if (maskh) {
+		for (i = 0; i < 16; i++) {
+			if (maskh & ((uint16_t)1 << i))
+				return i + GIUINT_HIGH_OFFSET;
+		}
+	}
+
+	printk(KERN_ERR "spurious GIU interrupt: %04x(%04x),%04x(%04x)\n",
+	       maskl, pendl, maskh, pendh);
+
+	atomic_inc(&irq_err_count);
+
+	return -1;
+}
+
+static inline void ack_giuint_irq(int pin)
+{
+	if (pin < GIUINT_HIGH_OFFSET) {
+		clear_giuint(GIUINTENL, (uint16_t)1 << pin);
+		write_giuint((uint16_t)1 << pin, GIUINTSTATL);
+	} else {
+		pin -= GIUINT_HIGH_OFFSET;
+		clear_giuint(GIUINTENH, (uint16_t)1 << pin);
+		write_giuint((uint16_t)1 << pin, GIUINTSTATH);
+	}
+}
+
+static inline void end_giuint_irq(int pin)
+{
+	if (pin < GIUINT_HIGH_OFFSET)
+		set_giuint(GIUINTENL, (uint16_t)1 << pin);
+	else
+		set_giuint(GIUINTENH, (uint16_t)1 << (pin - GIUINT_HIGH_OFFSET));
+}
+
+void giuint_irq_dispatch(struct pt_regs *regs)
 {
 	struct vr41xx_giuint_cascade *cascade;
-	unsigned int retval = 0;
-	int giuint_irq, cascade_irq;
+	unsigned int giuint_irq;
+	int pin;
+
+	pin = get_irq_pin_number();
+	if (pin < 0)
+		return;
 
 	disable_irq(GIUINT_CASCADE_IRQ);
+
 	cascade = &giuint_cascade[pin];
 	giuint_irq = GIU_IRQ(pin);
 	if (cascade->flag == GIUINT_CASCADE) {
-		cascade_irq = cascade->get_irq_number(giuint_irq);
-		disable_irq(giuint_irq);
-		if (cascade_irq > 0)
-			retval = do_IRQ(cascade_irq, regs);
-		enable_irq(giuint_irq);
-	} else
-		retval = do_IRQ(giuint_irq, regs);
-	enable_irq(GIUINT_CASCADE_IRQ);
+		int irq = cascade->get_irq_number(giuint_irq);
+		ack_giuint_irq(pin);
+		if (irq >= 0)
+			do_IRQ(irq, regs);
+		end_giuint_irq(pin);
+	} else {
+		do_IRQ(giuint_irq, regs);
+	}
 
-	return retval;
+	enable_irq(GIUINT_CASCADE_IRQ);
 }
 
-void __init vr41xx_giuint_init(void)
+static int __init vr41xx_giu_init(void)
 {
 	int i;
 
@@ -277,16 +431,20 @@ void __init vr41xx_giuint_init(void)
 		giu_base = GIUIOSELL_TYPE2;
 		break;
 	default:
-		panic("GIU: Unexpected CPU of NEC VR4100 series");
-		break;
+		printk(KERN_ERR "GIU: Unexpected CPU of NEC VR4100 series\n");
+		return -EINVAL;
 	}
 
 	for (i = 0; i < GIUINT_NR_IRQS; i++) {
-                vr41xx_disable_giuint(i);
+		if (i < GIUINT_HIGH_OFFSET)
+			clear_giuint(GIUINTENL, (uint16_t)1 << i);
+		else
+			clear_giuint(GIUINTENH, (uint16_t)1 << (i - GIUINT_HIGH_OFFSET));
 		giuint_cascade[i].flag = GIUINT_NO_CASCADE;
 		giuint_cascade[i].get_irq_number = no_irq_number;
 	}
 
-	if (setup_irq(GIUINT_CASCADE_IRQ, &giu_cascade))
-		printk("GIUINT: Can not cascade IRQ %d.\n", GIUINT_CASCADE_IRQ);
+	return 0;
 }
+
+early_initcall(vr41xx_giu_init);
diff -puN arch/mips/vr41xx/common/icu.c~mips-update arch/mips/vr41xx/common/icu.c
--- 25/arch/mips/vr41xx/common/icu.c~mips-update	2004-06-21 23:10:45.445310840 -0700
+++ 25-akpm/arch/mips/vr41xx/common/icu.c	2004-06-21 23:10:45.749264632 -0700
@@ -28,10 +28,12 @@
  *  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
  *  - Coped with INTASSIGN of NEC VR4133.
  */
+#include <linux/config.h>
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/irq.h>
+#include <linux/module.h>
 #include <linux/smp.h>
 #include <linux/types.h>
 
@@ -43,11 +45,8 @@
 
 extern asmlinkage void vr41xx_handle_interrupt(void);
 
-extern void vr41xx_giuint_init(void);
-extern void vr41xx_enable_giuint(int pin);
-extern void vr41xx_disable_giuint(int pin);
-extern void vr41xx_clear_giuint(int pin);
-extern unsigned int giuint_do_IRQ(int pin, struct pt_regs *regs);
+extern void init_vr41xx_giuint_irq(void);
+extern void giuint_irq_dispatch(struct pt_regs *regs);
 
 static uint32_t icu1_base;
 static uint32_t icu2_base;
@@ -64,11 +63,17 @@ static unsigned char sysint2_assign[16] 
 #define SYSINT2REG_TYPE2	KSEG1ADDR(0x0f0000a0)
 
 #define SYSINT1REG	0x00
+#define PIUINTREG	0x02
 #define INTASSIGN0	0x04
 #define INTASSIGN1	0x06
 #define GIUINTLREG	0x08
+#define DSIUINTREG	0x0a
 #define MSYSINT1REG	0x0c
+#define MPIUINTREG	0x0e
+#define MAIUINTREG	0x10
+#define MKIUINTREG	0x12
 #define MGIUINTLREG	0x14
+#define MDSIUINTREG	0x16
 #define NMIREG		0x18
 #define SOFTREG		0x1a
 #define INTASSIGN2	0x1c
@@ -76,11 +81,21 @@ static unsigned char sysint2_assign[16] 
 
 #define SYSINT2REG	0x00
 #define GIUINTHREG	0x02
+#define FIRINTREG	0x04
 #define MSYSINT2REG	0x06
 #define MGIUINTHREG	0x08
-
-#define MDSIUINTREG	KSEG1ADDR(0x0f000096)
- #define INTDSIU	0x0800
+#define MFIRINTREG	0x0a
+#define PCIINTREG	0x0c
+ #define PCIINT0	0x0001
+#define SCUINTREG	0x0e
+ #define SCUINT0	0x0001
+#define CSIINTREG	0x10
+#define MPCIINTREG	0x12
+#define MSCUINTREG	0x14
+#define MCSIINTREG	0x16
+#define BCUINTREG	0x18
+ #define BCUINTR	0x0001
+#define MBCUINTREG	0x1a
 
 #define SYSINT1_IRQ_TO_PIN(x)	((x) - SYSINT1_IRQ_BASE)	/* Pin 0-15 */
 #define SYSINT2_IRQ_TO_PIN(x)	((x) - SYSINT2_IRQ_BASE)	/* Pin 0-15 */
@@ -140,212 +155,298 @@ static inline uint16_t clear_icu2(uint8_
 
 /*=======================================================================*/
 
-void vr41xx_enable_dsiuint(void)
+void vr41xx_enable_piuint(uint16_t mask)
 {
-	writew(INTDSIU, MDSIUINTREG);
+	irq_desc_t *desc = irq_desc + PIU_IRQ;
+	unsigned long flags;
+	uint16_t val;
+
+	spin_lock_irqsave(&desc->lock, flags);
+	val = read_icu1(MPIUINTREG);
+	val |= mask;
+	write_icu1(val, MPIUINTREG);
+	spin_unlock_irqrestore(&desc->lock, flags);
 }
 
-void vr41xx_disable_dsiuint(void)
+void vr41xx_disable_piuint(uint16_t mask)
 {
-	writew(0, MDSIUINTREG);
+	irq_desc_t *desc = irq_desc + PIU_IRQ;
+	unsigned long flags;
+	uint16_t val;
+
+	spin_lock_irqsave(&desc->lock, flags);
+	val = read_icu1(MPIUINTREG);
+	val &= ~mask;
+	write_icu1(val, MPIUINTREG);
+	spin_unlock_irqrestore(&desc->lock, flags);
 }
 
-/*=======================================================================*/
+void vr41xx_enable_aiuint(uint16_t mask)
+{
+	irq_desc_t *desc = irq_desc + AIU_IRQ;
+	unsigned long flags;
+	uint16_t val;
 
-static void enable_sysint1_irq(unsigned int irq)
+	spin_lock_irqsave(&desc->lock, flags);
+	val = read_icu1(MAIUINTREG);
+	val |= mask;
+	write_icu1(val, MAIUINTREG);
+	spin_unlock_irqrestore(&desc->lock, flags);
+}
+
+void vr41xx_disable_aiuint(uint16_t mask)
 {
-	set_icu1(MSYSINT1REG, (uint16_t)1 << SYSINT1_IRQ_TO_PIN(irq));
+	irq_desc_t *desc = irq_desc + AIU_IRQ;
+	unsigned long flags;
+	uint16_t val;
+
+	spin_lock_irqsave(&desc->lock, flags);
+	val = read_icu1(MAIUINTREG);
+	val &= ~mask;
+	write_icu1(val, MAIUINTREG);
+	spin_unlock_irqrestore(&desc->lock, flags);
 }
 
-static void disable_sysint1_irq(unsigned int irq)
+void vr41xx_enable_kiuint(uint16_t mask)
 {
-	clear_icu1(MSYSINT1REG, (uint16_t)1 << SYSINT1_IRQ_TO_PIN(irq));
+	irq_desc_t *desc = irq_desc + KIU_IRQ;
+	unsigned long flags;
+	uint16_t val;
+
+	spin_lock_irqsave(&desc->lock, flags);
+	val = read_icu1(MKIUINTREG);
+	val |= mask;
+	write_icu1(val, MKIUINTREG);
+	spin_unlock_irqrestore(&desc->lock, flags);
 }
 
-static unsigned int startup_sysint1_irq(unsigned int irq)
+void vr41xx_disable_kiuint(uint16_t mask)
 {
-	set_icu1(MSYSINT1REG, (uint16_t)1 << SYSINT1_IRQ_TO_PIN(irq));
+	irq_desc_t *desc = irq_desc + KIU_IRQ;
+	unsigned long flags;
+	uint16_t val;
 
-	return 0; /* never anything pending */
+	spin_lock_irqsave(&desc->lock, flags);
+	val = read_icu1(MKIUINTREG);
+	val &= ~mask;
+	write_icu1(val, MKIUINTREG);
+	spin_unlock_irqrestore(&desc->lock, flags);
 }
 
-#define shutdown_sysint1_irq	disable_sysint1_irq
-#define ack_sysint1_irq		disable_sysint1_irq
+void vr41xx_enable_dsiuint(uint16_t mask)
+{
+	irq_desc_t *desc = irq_desc + DSIU_IRQ;
+	unsigned long flags;
+	uint16_t val;
 
-static void end_sysint1_irq(unsigned int irq)
+	spin_lock_irqsave(&desc->lock, flags);
+	val = read_icu1(MDSIUINTREG);
+	val |= mask;
+	write_icu1(val, MDSIUINTREG);
+	spin_unlock_irqrestore(&desc->lock, flags);
+}
+
+void vr41xx_disable_dsiuint(uint16_t mask)
 {
-	if (!(irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS)))
-		set_icu1(MSYSINT1REG, (uint16_t)1 << SYSINT1_IRQ_TO_PIN(irq));
+	irq_desc_t *desc = irq_desc + DSIU_IRQ;
+	unsigned long flags;
+	uint16_t val;
+
+	spin_lock_irqsave(&desc->lock, flags);
+	val = read_icu1(MDSIUINTREG);
+	val &= ~mask;
+	write_icu1(val, MDSIUINTREG);
+	spin_unlock_irqrestore(&desc->lock, flags);
 }
 
-static struct hw_interrupt_type sysint1_irq_type = {
-	.typename	= "SYSINT1",
-	.startup	= startup_sysint1_irq,
-	.shutdown	= shutdown_sysint1_irq,
-	.enable		= enable_sysint1_irq,
-	.disable	= disable_sysint1_irq,
-	.ack		= ack_sysint1_irq,
-	.end		= end_sysint1_irq,
-};
+void vr41xx_enable_firint(uint16_t mask)
+{
+	irq_desc_t *desc = irq_desc + FIR_IRQ;
+	unsigned long flags;
+	uint16_t val;
 
-/*=======================================================================*/
+	spin_lock_irqsave(&desc->lock, flags);
+	val = read_icu2(MFIRINTREG);
+	val |= mask;
+	write_icu2(val, MFIRINTREG);
+	spin_unlock_irqrestore(&desc->lock, flags);
+}
 
-static void enable_sysint2_irq(unsigned int irq)
+void vr41xx_disable_firint(uint16_t mask)
 {
-	set_icu2(MSYSINT2REG, (uint16_t)1 << SYSINT2_IRQ_TO_PIN(irq));
+	irq_desc_t *desc = irq_desc + FIR_IRQ;
+	unsigned long flags;
+	uint16_t val;
+
+	spin_lock_irqsave(&desc->lock, flags);
+	val = read_icu2(MFIRINTREG);
+	val &= ~mask;
+	write_icu2(val, MFIRINTREG);
+	spin_unlock_irqrestore(&desc->lock, flags);
 }
 
-static void disable_sysint2_irq(unsigned int irq)
+void vr41xx_enable_pciint(void)
 {
-	clear_icu2(MSYSINT2REG, (uint16_t)1 << SYSINT2_IRQ_TO_PIN(irq));
+	irq_desc_t *desc = irq_desc + PCI_IRQ;
+	unsigned long flags;
+
+	spin_lock_irqsave(&desc->lock, flags);
+	write_icu2(PCIINT0, MPCIINTREG);
+	spin_unlock_irqrestore(&desc->lock, flags);
 }
 
-static unsigned int startup_sysint2_irq(unsigned int irq)
+void vr41xx_disable_pciint(void)
 {
-	set_icu2(MSYSINT2REG, (uint16_t)1 << SYSINT2_IRQ_TO_PIN(irq));
+	irq_desc_t *desc = irq_desc + PCI_IRQ;
+	unsigned long flags;
 
-	return 0; /* never anything pending */
+	spin_lock_irqsave(&desc->lock, flags);
+	write_icu2(0, MPCIINTREG);
+	spin_unlock_irqrestore(&desc->lock, flags);
 }
 
-#define shutdown_sysint2_irq	disable_sysint2_irq
-#define ack_sysint2_irq		disable_sysint2_irq
+void vr41xx_enable_scuint(void)
+{
+	irq_desc_t *desc = irq_desc + SCU_IRQ;
+	unsigned long flags;
 
-static void end_sysint2_irq(unsigned int irq)
+	spin_lock_irqsave(&desc->lock, flags);
+	write_icu2(SCUINT0, MSCUINTREG);
+	spin_unlock_irqrestore(&desc->lock, flags);
+}
+
+void vr41xx_disable_scuint(void)
 {
-	if (!(irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS)))
-		set_icu2(MSYSINT2REG, (uint16_t)1 << SYSINT2_IRQ_TO_PIN(irq));
+	irq_desc_t *desc = irq_desc + SCU_IRQ;
+	unsigned long flags;
+
+	spin_lock_irqsave(&desc->lock, flags);
+	write_icu2(0, MSCUINTREG);
+	spin_unlock_irqrestore(&desc->lock, flags);
 }
 
-static struct hw_interrupt_type sysint2_irq_type = {
-	.typename	= "SYSINT2",
-	.startup	= startup_sysint2_irq,
-	.shutdown	= shutdown_sysint2_irq,
-	.enable		= enable_sysint2_irq,
-	.disable	= disable_sysint2_irq,
-	.ack		= ack_sysint2_irq,
-	.end		= end_sysint2_irq,
-};
+void vr41xx_enable_csiint(uint16_t mask)
+{
+	irq_desc_t *desc = irq_desc + CSI_IRQ;
+	unsigned long flags;
+	uint16_t val;
 
-/*=======================================================================*/
+	spin_lock_irqsave(&desc->lock, flags);
+	val = read_icu2(MCSIINTREG);
+	val |= mask;
+	write_icu2(val, MCSIINTREG);
+	spin_unlock_irqrestore(&desc->lock, flags);
+}
 
-static void enable_giuint_irq(unsigned int irq)
+void vr41xx_disable_csiint(uint16_t mask)
 {
-	int pin;
+	irq_desc_t *desc = irq_desc + CSI_IRQ;
+	unsigned long flags;
+	uint16_t val;
 
-	pin = GIU_IRQ_TO_PIN(irq);
-	if (pin < 16)
-		set_icu1(MGIUINTLREG, (uint16_t)1 << pin);
-	else
-		set_icu2(MGIUINTHREG, (uint16_t)1 << (pin - 16));
-	vr41xx_enable_giuint(pin);
+	spin_lock_irqsave(&desc->lock, flags);
+	val = read_icu2(MCSIINTREG);
+	val &= ~mask;
+	write_icu2(val, MCSIINTREG);
+	spin_unlock_irqrestore(&desc->lock, flags);
 }
 
-static void disable_giuint_irq(unsigned int irq)
+void vr41xx_enable_bcuint(void)
 {
-	int pin;
+	irq_desc_t *desc = irq_desc + BCU_IRQ;
+	unsigned long flags;
 
-	pin = GIU_IRQ_TO_PIN(irq);
-	vr41xx_disable_giuint(pin);
-	if (pin < 16)
-		clear_icu1(MGIUINTLREG, (uint16_t)1 << pin);
-	else
-		clear_icu2(MGIUINTHREG, (uint16_t)1 << (pin - 16));
+	spin_lock_irqsave(&desc->lock, flags);
+	write_icu2(BCUINTR, MBCUINTREG);
+	spin_unlock_irqrestore(&desc->lock, flags);
 }
 
-static unsigned int startup_giuint_irq(unsigned int irq)
+void vr41xx_disable_bcuint(void)
 {
-	vr41xx_clear_giuint(GIU_IRQ_TO_PIN(irq));
+	irq_desc_t *desc = irq_desc + BCU_IRQ;
+	unsigned long flags;
 
-	enable_giuint_irq(irq);
+	spin_lock_irqsave(&desc->lock, flags);
+	write_icu2(0, MBCUINTREG);
+	spin_unlock_irqrestore(&desc->lock, flags);
+}
+
+/*=======================================================================*/
+
+static unsigned int startup_sysint1_irq(unsigned int irq)
+{
+	set_icu1(MSYSINT1REG, (uint16_t)1 << SYSINT1_IRQ_TO_PIN(irq));
 
 	return 0; /* never anything pending */
 }
 
-#define shutdown_giuint_irq	disable_giuint_irq
-
-static void ack_giuint_irq(unsigned int irq)
+static void shutdown_sysint1_irq(unsigned int irq)
 {
-	disable_giuint_irq(irq);
+	clear_icu1(MSYSINT1REG, (uint16_t)1 << SYSINT1_IRQ_TO_PIN(irq));
+}
 
-	vr41xx_clear_giuint(GIU_IRQ_TO_PIN(irq));
+static void enable_sysint1_irq(unsigned int irq)
+{
+	set_icu1(MSYSINT1REG, (uint16_t)1 << SYSINT1_IRQ_TO_PIN(irq));
 }
 
-static void end_giuint_irq(unsigned int irq)
+#define disable_sysint1_irq	shutdown_sysint1_irq
+#define ack_sysint1_irq		shutdown_sysint1_irq
+
+static void end_sysint1_irq(unsigned int irq)
 {
 	if (!(irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS)))
-		enable_giuint_irq(irq);
+		set_icu1(MSYSINT1REG, (uint16_t)1 << SYSINT1_IRQ_TO_PIN(irq));
 }
 
-static struct hw_interrupt_type giuint_irq_type = {
-	.typename	= "GIUINT",
-	.startup	= startup_giuint_irq,
-	.shutdown	= shutdown_giuint_irq,
-	.enable		= enable_giuint_irq,
-	.disable	= disable_giuint_irq,
-	.ack		= ack_giuint_irq,
-	.end		= end_giuint_irq,
+static struct hw_interrupt_type sysint1_irq_type = {
+	.typename	= "SYSINT1",
+	.startup	= startup_sysint1_irq,
+	.shutdown	= shutdown_sysint1_irq,
+	.enable		= enable_sysint1_irq,
+	.disable	= disable_sysint1_irq,
+	.ack		= ack_sysint1_irq,
+	.end		= end_sysint1_irq,
 };
 
 /*=======================================================================*/
 
-static struct irqaction icu_cascade = {no_action, 0, CPU_MASK_NONE, "cascade", NULL, NULL};
-
-static void __init vr41xx_icu_init(void)
+static unsigned int startup_sysint2_irq(unsigned int irq)
 {
-	int i;
-
-	switch (current_cpu_data.cputype) {
-	case CPU_VR4111:
-	case CPU_VR4121:
-		icu1_base = SYSINT1REG_TYPE1;
-		icu2_base = SYSINT2REG_TYPE1;
-		break;
-	case CPU_VR4122:
-	case CPU_VR4131:
-	case CPU_VR4133:
-		icu1_base = SYSINT1REG_TYPE2;
-		icu2_base = SYSINT2REG_TYPE2;
-		break;
-	default:
-		panic("Unexpected CPU of NEC VR4100 series");
-		break;
-	}
-
-	write_icu1(0, MSYSINT1REG);
-	write_icu1(0, MGIUINTLREG);
-
-	write_icu2(0, MSYSINT2REG);
-	write_icu2(0, MGIUINTHREG);
-
-	for (i = SYSINT1_IRQ_BASE; i <= GIU_IRQ_LAST; i++) {
-		if (i >= SYSINT1_IRQ_BASE && i <= SYSINT1_IRQ_LAST)
-			irq_desc[i].handler = &sysint1_irq_type;
-		else if (i >= SYSINT2_IRQ_BASE && i <= SYSINT2_IRQ_LAST)
-			irq_desc[i].handler = &sysint2_irq_type;
-		else if (i >= GIU_IRQ_BASE && i <= GIU_IRQ_LAST)
-			irq_desc[i].handler = &giuint_irq_type;
-	}
+	set_icu2(MSYSINT2REG, (uint16_t)1 << SYSINT2_IRQ_TO_PIN(irq));
 
-	setup_irq(INT0_CASCADE_IRQ, &icu_cascade);
-	setup_irq(INT1_CASCADE_IRQ, &icu_cascade);
-	setup_irq(INT2_CASCADE_IRQ, &icu_cascade);
-	setup_irq(INT3_CASCADE_IRQ, &icu_cascade);
-	setup_irq(INT4_CASCADE_IRQ, &icu_cascade);
+	return 0; /* never anything pending */
 }
 
-void __init init_IRQ(void)
+static void shutdown_sysint2_irq(unsigned int irq)
 {
-	memset(irq_desc, 0, sizeof(irq_desc));
+	clear_icu2(MSYSINT2REG, (uint16_t)1 << SYSINT2_IRQ_TO_PIN(irq));
+}
 
-	init_generic_irq();
-	mips_cpu_irq_init(MIPS_CPU_IRQ_BASE);
-	vr41xx_icu_init();
+static void enable_sysint2_irq(unsigned int irq)
+{
+	set_icu2(MSYSINT2REG, (uint16_t)1 << SYSINT2_IRQ_TO_PIN(irq));
+}
 
-	vr41xx_giuint_init();
+#define disable_sysint2_irq	shutdown_sysint2_irq
+#define ack_sysint2_irq		shutdown_sysint2_irq
 
-	set_except_vector(0, vr41xx_handle_interrupt);
+static void end_sysint2_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS)))
+		set_icu2(MSYSINT2REG, (uint16_t)1 << SYSINT2_IRQ_TO_PIN(irq));
 }
 
+static struct hw_interrupt_type sysint2_irq_type = {
+	.typename	= "SYSINT2",
+	.startup	= startup_sysint2_irq,
+	.shutdown	= shutdown_sysint2_irq,
+	.enable		= enable_sysint2_irq,
+	.disable	= disable_sysint2_irq,
+	.ack		= ack_sysint2_irq,
+	.end		= end_sysint2_irq,
+};
+
 /*=======================================================================*/
 
 static inline int set_sysint1_assign(unsigned int irq, unsigned char assign)
@@ -492,34 +593,14 @@ int vr41xx_set_intassign(unsigned int ir
 	return retval;
 }
 
-/*=======================================================================*/
-
-static inline void giuint_irq_dispatch(uint16_t pendl, uint16_t pendh,
-                                       struct pt_regs *regs)
-{
-	int i;
+EXPORT_SYMBOL(vr41xx_set_intassign);
 
-	if (pendl) {
-		for (i = 0; i < 16; i++) {
-			if (pendl & ((uint16_t)1 << i)) {
-				giuint_do_IRQ(i, regs);
-				return;
-			}
-		}
-	} else {
-		for (i = 0; i < 16; i++) {
-			if (pendh & ((uint16_t)1 << i)) {
-				giuint_do_IRQ(i + 16, regs);
-				return;
-			}
-		}
-	}
-}
+/*=======================================================================*/
 
 asmlinkage void irq_dispatch(unsigned char intnum, struct pt_regs *regs)
 {
-	uint16_t pend1, pend2, pendl, pendh;
-	uint16_t mask1, mask2, maskl, maskh;
+	uint16_t pend1, pend2;
+	uint16_t mask1, mask2;
 	int i;
 
 	pend1 = read_icu1(SYSINT1REG);
@@ -528,28 +609,18 @@ asmlinkage void irq_dispatch(unsigned ch
 	pend2 = read_icu2(SYSINT2REG);
 	mask2 = read_icu2(MSYSINT2REG);
 
-	pendl = read_icu1(GIUINTLREG);
-	maskl = read_icu1(MGIUINTLREG);
-
-	pendh = read_icu2(GIUINTHREG);
-	maskh = read_icu2(MGIUINTHREG);
-
 	mask1 &= pend1;
 	mask2 &= pend2;
-	maskl &= pendl;
-	maskh &= pendh;
 
 	if (mask1) {
 		for (i = 0; i < 16; i++) {
 			if (intnum == sysint1_assign[i] &&
 			    (mask1 & ((uint16_t)1 << i))) {
-				if (i == 8 && (maskl | maskh)) {
-					giuint_irq_dispatch(maskl, maskh, regs);
-					return;
-				} else {
+				if (i == 8)
+					giuint_irq_dispatch(regs);
+				else
 					do_IRQ(SYSINT1_IRQ(i), regs);
-					return;
-				}
+				return;
 			}
 		}
 	}
@@ -564,6 +635,72 @@ asmlinkage void irq_dispatch(unsigned ch
 		}
 	}
 
-	printk(KERN_ERR "spurious interrupt: %04x,%04x,%04x,%04x\n", pend1, pend2, pendl, pendh);
+	printk(KERN_ERR "spurious ICU interrupt: %04x,%04x\n", pend1, pend2);
+
 	atomic_inc(&irq_err_count);
 }
+
+/*=======================================================================*/
+
+static int __init vr41xx_icu_init(void)
+{
+	switch (current_cpu_data.cputype) {
+	case CPU_VR4111:
+	case CPU_VR4121:
+		icu1_base = SYSINT1REG_TYPE1;
+		icu2_base = SYSINT2REG_TYPE1;
+		break;
+	case CPU_VR4122:
+	case CPU_VR4131:
+	case CPU_VR4133:
+		icu1_base = SYSINT1REG_TYPE2;
+		icu2_base = SYSINT2REG_TYPE2;
+		break;
+	default:
+		printk(KERN_ERR "ICU: Unexpected CPU of NEC VR4100 series\n");
+		return -EINVAL;
+	}
+
+	write_icu1(0, MSYSINT1REG);
+	write_icu1(0xffff, MGIUINTLREG);
+
+	write_icu2(0, MSYSINT2REG);
+	write_icu2(0xffff, MGIUINTHREG);
+
+	return 0;
+}
+
+early_initcall(vr41xx_icu_init);
+
+/*=======================================================================*/
+
+static struct irqaction icu_cascade = {no_action, 0, 0, "cascade", NULL, NULL};
+
+static inline void init_vr41xx_icu_irq(void)
+{
+	int i;
+
+	for (i = SYSINT1_IRQ_BASE; i <= SYSINT1_IRQ_LAST; i++)
+		irq_desc[i].handler = &sysint1_irq_type;
+
+	for (i = SYSINT2_IRQ_BASE; i <= SYSINT2_IRQ_LAST; i++)
+		irq_desc[i].handler = &sysint2_irq_type;
+
+	setup_irq(INT0_CASCADE_IRQ, &icu_cascade);
+	setup_irq(INT1_CASCADE_IRQ, &icu_cascade);
+	setup_irq(INT2_CASCADE_IRQ, &icu_cascade);
+	setup_irq(INT3_CASCADE_IRQ, &icu_cascade);
+	setup_irq(INT4_CASCADE_IRQ, &icu_cascade);
+}
+
+void __init init_IRQ(void)
+{
+	memset(irq_desc, 0, sizeof(irq_desc));
+
+	init_generic_irq();
+	mips_cpu_irq_init(MIPS_CPU_IRQ_BASE);
+	init_vr41xx_icu_irq();
+	init_vr41xx_giuint_irq();
+
+	set_except_vector(0, vr41xx_handle_interrupt);
+}
diff -puN arch/mips/vr41xx/common/init.c~mips-update arch/mips/vr41xx/common/init.c
--- 25/arch/mips/vr41xx/common/init.c~mips-update	2004-06-21 23:10:45.447310536 -0700
+++ 25-akpm/arch/mips/vr41xx/common/init.c	2004-06-21 23:10:45.749264632 -0700
@@ -18,16 +18,9 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 #include <linux/init.h>
-#include <linux/ioport.h>
 #include <linux/string.h>
 
 #include <asm/bootinfo.h>
-#include <asm/vr41xx/vr41xx.h>
-
-extern void vr41xx_bcu_init(void);
-extern void vr41xx_cmu_init(void);
-extern void vr41xx_pmu_init(void);
-extern void vr41xx_rtc_init(void);
 
 void __init prom_init(void)
 {
@@ -42,14 +35,6 @@ void __init prom_init(void)
 		if (i < (argc - 1))
 			strcat(arcs_cmdline, " ");
 	}
-
-	iomem_resource.start = IO_MEM_RESOURCE_START;
-	iomem_resource.end = IO_MEM_RESOURCE_END;
-
-	vr41xx_bcu_init();
-	vr41xx_cmu_init();
-	vr41xx_pmu_init();
-	vr41xx_rtc_init();
 }
 
 unsigned long __init prom_free_prom_memory (void)
diff -puN arch/mips/vr41xx/common/ksyms.c~mips-update arch/mips/vr41xx/common/ksyms.c
--- 25/arch/mips/vr41xx/common/ksyms.c~mips-update	2004-06-21 23:10:45.448310384 -0700
+++ 25-akpm/arch/mips/vr41xx/common/ksyms.c	2004-06-21 23:10:45.750264480 -0700
@@ -25,8 +25,6 @@
 EXPORT_SYMBOL(vr41xx_get_vtclock_frequency);
 EXPORT_SYMBOL(vr41xx_get_tclock_frequency);
 
-EXPORT_SYMBOL(vr41xx_set_intassign);
-
 EXPORT_SYMBOL(vr41xx_set_rtclong1_cycle);
 EXPORT_SYMBOL(vr41xx_read_rtclong1_counter);
 EXPORT_SYMBOL(vr41xx_set_rtclong2_cycle);
diff -puN arch/mips/vr41xx/common/pmu.c~mips-update arch/mips/vr41xx/common/pmu.c
--- 25/arch/mips/vr41xx/common/pmu.c~mips-update	2004-06-21 23:10:45.450310080 -0700
+++ 25-akpm/arch/mips/vr41xx/common/pmu.c	2004-06-21 23:10:45.751264328 -0700
@@ -1,7 +1,7 @@
 /*
  *  pmu.c, Power Management Unit routines for NEC VR4100 series.
  *
- *  Copyright (C) 2003  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *  Copyright (C) 2003-2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -68,9 +68,13 @@ static void vr41xx_power_off(void)
 	while (1) ;
 }
 
-void __init vr41xx_pmu_init(void)
+static int __init vr41xx_pmu_init(void)
 {
 	_machine_restart = vr41xx_restart;
 	_machine_halt = vr41xx_halt;
 	_machine_power_off = vr41xx_power_off;
+
+	return 0;
 }
+
+early_initcall(vr41xx_pmu_init);
diff -puN arch/mips/vr41xx/common/rtc.c~mips-update arch/mips/vr41xx/common/rtc.c
--- 25/arch/mips/vr41xx/common/rtc.c~mips-update	2004-06-21 23:10:45.452309776 -0700
+++ 25-akpm/arch/mips/vr41xx/common/rtc.c	2004-06-21 23:10:45.753264024 -0700
@@ -1,7 +1,7 @@
 /*
  *  rtc.c, RTC(has only timer function) routines for NEC VR4100 series.
  *
- *  Copyright (C) 2003  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *  Copyright (C) 2003-2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -310,8 +310,12 @@ static void __init vr41xx_timer_setup(st
 	setup_irq(ELAPSEDTIME_IRQ, irq);
 }
 
-void __init vr41xx_rtc_init(void)
+static int __init vr41xx_rtc_init(void)
 {
 	board_time_init = vr41xx_time_init;
 	board_timer_setup = vr41xx_timer_setup;
+
+	return 0;
 }
+
+early_initcall(vr41xx_rtc_init);
diff -puN arch/mips/vr41xx/common/serial.c~mips-update arch/mips/vr41xx/common/serial.c
--- 25/arch/mips/vr41xx/common/serial.c~mips-update	2004-06-21 23:10:45.454309472 -0700
+++ 25-akpm/arch/mips/vr41xx/common/serial.c	2004-06-21 23:10:45.754263872 -0700
@@ -168,7 +168,7 @@ void __init vr41xx_dsiu_init(void)
 	if (port.membase != NULL) {
 		if (early_serial_setup(&port) == 0) {
 			vr41xx_supply_clock(DSIU_CLOCK);
-			vr41xx_enable_dsiuint();
+			vr41xx_enable_dsiuint(DSIUINT_ALL);
 			vr41xx_serial_ports++;
 			return;
 		}
diff -puN arch/mips/vr41xx/common/vrc4173.c~mips-update arch/mips/vr41xx/common/vrc4173.c
--- 25/arch/mips/vr41xx/common/vrc4173.c~mips-update	2004-06-21 23:10:45.456309168 -0700
+++ 25-akpm/arch/mips/vr41xx/common/vrc4173.c	2004-06-21 23:10:45.758263264 -0700
@@ -1,143 +1,336 @@
 /*
- * FILE NAME
- *	drivers/char/vrc4173.c
- * 
- * BRIEF MODULE DESCRIPTION
- *	NEC VRC4173 driver for NEC VR4122/VR4131.
+ *  vrc4173.c, NEC VRC4173 base driver for NEC VR4122/VR4131.
  *
- * Author: Yoichi Yuasa
- *         yyuasa@mvista.com or source@mvista.com
+ *  Copyright (C) 2001-2003  MontaVista Software Inc.
+ *    Author: Yoichi Yuasa <yyuasa@mvista.com, or source@mvista.com>
+ *  Copyright (C) 2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
  *
- * Copyright 2001,2002 MontaVista Software Inc.
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
  *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License as published by the
- *  Free Software Foundation; either version 2 of the License, or (at your
- *  option) any later version.
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
  *
- *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
- *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
- *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
- *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
- *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
- *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
- *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  675 Mass Ave, Cambridge, MA 02139, USA.
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
+#include <linux/config.h>
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/interrupt.h>
 #include <linux/irq.h>
 #include <linux/pci.h>
+#include <linux/spinlock.h>
 #include <linux/types.h>
 
 #include <asm/vr41xx/vr41xx.h>
 #include <asm/vr41xx/vrc4173.h>
 
-MODULE_DESCRIPTION("NEC VRC4173 driver for NEC VR4122/4131");
+MODULE_DESCRIPTION("NEC VRC4173 base driver for NEC VR4122/4131");
 MODULE_AUTHOR("Yoichi Yuasa <yyuasa@mvista.com>");
 MODULE_LICENSE("GPL");
 
 #define VRC4173_CMUCLKMSK	0x040
+ #define MSKPIU			0x0001
+ #define MSKKIU			0x0002
+ #define MSKAIU			0x0004
+ #define MSKPS2CH1		0x0008
+ #define MSKPS2CH2		0x0010
+ #define MSKUSB			0x0020
+ #define MSKCARD1		0x0040
+ #define MSKCARD2		0x0080
+ #define MSKAC97		0x0100
+ #define MSK48MUSB		0x0400
+ #define MSK48MPIN		0x0800
+ #define MSK48MOSC		0x1000
 #define VRC4173_CMUSRST		0x042
-
-#define VRC4173_SELECTREG	0x09e
+ #define USBRST			0x0001
+ #define CARD1RST		0x0002
+ #define CARD2RST		0x0004
+ #define AC97RST		0x0008
 
 #define VRC4173_SYSINT1REG	0x060
 #define VRC4173_MSYSINT1REG	0x06c
 
-static struct pci_device_id vrc4173_table[] = {
-	{PCI_VENDOR_ID_NEC, PCI_DEVICE_ID_NEC_VRC4173, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{0, }
+#define VRC4173_SELECTREG	0x09e
+ #define SEL3			0x0008
+ #define SEL2			0x0004
+ #define SEL1			0x0002
+ #define SEL0			0x0001
+
+static struct pci_device_id vrc4173_id_table[] __devinitdata = {
+	{	.vendor		= PCI_VENDOR_ID_NEC,
+		.device		= PCI_DEVICE_ID_NEC_VRC4173,
+		.subvendor	= PCI_ANY_ID,
+		.subdevice	= PCI_ANY_ID,			},
+	{	.vendor		= 0,				},
 };
 
 unsigned long vrc4173_io_offset = 0;
 
 EXPORT_SYMBOL(vrc4173_io_offset);
 
-static u16 vrc4173_cmuclkmsk;
 static int vrc4173_initialized;
+static uint16_t vrc4173_cmuclkmsk;
+static uint16_t vrc4173_selectreg;
+static spinlock_t vrc4173_cmu_lock;
+static spinlock_t vrc4173_giu_lock;
 
-void vrc4173_clock_supply(u16 mask)
+static inline void set_cmusrst(uint16_t val)
+{
+	uint16_t cmusrst;
+
+	cmusrst = vrc4173_inw(VRC4173_CMUSRST);
+	cmusrst |= val;
+	vrc4173_outw(cmusrst, VRC4173_CMUSRST);
+}
+
+static inline void clear_cmusrst(uint16_t val)
+{
+	uint16_t cmusrst;
+
+	cmusrst = vrc4173_inw(VRC4173_CMUSRST);
+	cmusrst &= ~val;
+	vrc4173_outw(cmusrst, VRC4173_CMUSRST);
+}
+
+void vrc4173_supply_clock(vrc4173_clock_t clock)
 {
 	if (vrc4173_initialized) {
-		vrc4173_cmuclkmsk |= mask;
+		spin_lock_irq(&vrc4173_cmu_lock);
+
+		switch (clock) {
+		case VRC4173_PIU_CLOCK:
+			vrc4173_cmuclkmsk |= MSKPIU;
+			break;
+		case VRC4173_KIU_CLOCK:
+			vrc4173_cmuclkmsk |= MSKKIU;
+			break;
+		case VRC4173_AIU_CLOCK:
+			vrc4173_cmuclkmsk |= MSKAIU;
+			break;
+		case VRC4173_PS2_CH1_CLOCK:
+			vrc4173_cmuclkmsk |= MSKPS2CH1;
+			break;
+		case VRC4173_PS2_CH2_CLOCK:
+			vrc4173_cmuclkmsk |= MSKPS2CH2;
+			break;
+		case VRC4173_USBU_PCI_CLOCK:
+			set_cmusrst(USBRST);
+			vrc4173_cmuclkmsk |= MSKUSB;
+			break;
+		case VRC4173_CARDU1_PCI_CLOCK:
+			set_cmusrst(CARD1RST);
+			vrc4173_cmuclkmsk |= MSKCARD1;
+			break;
+		case VRC4173_CARDU2_PCI_CLOCK:
+			set_cmusrst(CARD2RST);
+			vrc4173_cmuclkmsk |= MSKCARD2;
+			break;
+		case VRC4173_AC97U_PCI_CLOCK:
+			set_cmusrst(AC97RST);
+			vrc4173_cmuclkmsk |= MSKAC97;
+			break;
+		case VRC4173_USBU_48MHz_CLOCK:
+			set_cmusrst(USBRST);
+			vrc4173_cmuclkmsk |= MSK48MUSB;
+			break;
+		case VRC4173_EXT_48MHz_CLOCK:
+			if (vrc4173_cmuclkmsk & MSK48MOSC)
+				vrc4173_cmuclkmsk |= MSK48MPIN;
+			else
+				printk(KERN_WARNING
+				       "vrc4173_supply_clock: "
+				       "Please supply VRC4173_48MHz_CLOCK first "
+				       "rather than VRC4173_EXT_48MHz_CLOCK.\n");
+			break;
+		case VRC4173_48MHz_CLOCK:
+			vrc4173_cmuclkmsk |= MSK48MOSC;
+			break;
+		default:
+			printk(KERN_WARNING
+			       "vrc4173_supply_clock: Invalid CLOCK value %u\n", clock);
+			break;
+		}
+
 		vrc4173_outw(vrc4173_cmuclkmsk, VRC4173_CMUCLKMSK);
+
+		switch (clock) {
+		case VRC4173_USBU_PCI_CLOCK:
+		case VRC4173_USBU_48MHz_CLOCK:
+			clear_cmusrst(USBRST);
+			break;
+		case VRC4173_CARDU1_PCI_CLOCK:
+			clear_cmusrst(CARD1RST);
+			break;
+		case VRC4173_CARDU2_PCI_CLOCK:
+			clear_cmusrst(CARD2RST);
+			break;
+		case VRC4173_AC97U_PCI_CLOCK:
+			clear_cmusrst(AC97RST);
+			break;
+		default:
+			break;
+		}
+
+		spin_unlock_irq(&vrc4173_cmu_lock);
 	}
 }
 
-void vrc4173_clock_mask(u16 mask)
+EXPORT_SYMBOL(vrc4173_supply_clock);
+
+void vrc4173_mask_clock(vrc4173_clock_t clock)
 {
 	if (vrc4173_initialized) {
-		vrc4173_cmuclkmsk &= ~mask;
+		spin_lock_irq(&vrc4173_cmu_lock);
+
+		switch (clock) {
+		case VRC4173_PIU_CLOCK:
+			vrc4173_cmuclkmsk &= ~MSKPIU;
+			break;
+		case VRC4173_KIU_CLOCK:
+			vrc4173_cmuclkmsk &= ~MSKKIU;
+			break;
+		case VRC4173_AIU_CLOCK:
+			vrc4173_cmuclkmsk &= ~MSKAIU;
+			break;
+		case VRC4173_PS2_CH1_CLOCK:
+			vrc4173_cmuclkmsk &= ~MSKPS2CH1;
+			break;
+		case VRC4173_PS2_CH2_CLOCK:
+			vrc4173_cmuclkmsk &= ~MSKPS2CH2;
+			break;
+		case VRC4173_USBU_PCI_CLOCK:
+			set_cmusrst(USBRST);
+			vrc4173_cmuclkmsk &= ~MSKUSB;
+			break;
+		case VRC4173_CARDU1_PCI_CLOCK:
+			set_cmusrst(CARD1RST);
+			vrc4173_cmuclkmsk &= ~MSKCARD1;
+			break;
+		case VRC4173_CARDU2_PCI_CLOCK:
+			set_cmusrst(CARD2RST);
+			vrc4173_cmuclkmsk &= ~MSKCARD2;
+			break;
+		case VRC4173_AC97U_PCI_CLOCK:
+			set_cmusrst(AC97RST);
+			vrc4173_cmuclkmsk &= ~MSKAC97;
+			break;
+		case VRC4173_USBU_48MHz_CLOCK:
+			set_cmusrst(USBRST);
+			vrc4173_cmuclkmsk &= ~MSK48MUSB;
+			break;
+		case VRC4173_EXT_48MHz_CLOCK:
+			vrc4173_cmuclkmsk &= ~MSK48MPIN;
+			break;
+		case VRC4173_48MHz_CLOCK:
+			vrc4173_cmuclkmsk &= ~MSK48MOSC;
+			break;
+		default:
+			printk(KERN_WARNING "vrc4173_mask_clock: Invalid CLOCK value %u\n", clock);
+			break;
+		}
+
 		vrc4173_outw(vrc4173_cmuclkmsk, VRC4173_CMUCLKMSK);
+
+		switch (clock) {
+		case VRC4173_USBU_PCI_CLOCK:
+		case VRC4173_USBU_48MHz_CLOCK:
+			clear_cmusrst(USBRST);
+			break;
+		case VRC4173_CARDU1_PCI_CLOCK:
+			clear_cmusrst(CARD1RST);
+			break;
+		case VRC4173_CARDU2_PCI_CLOCK:
+			clear_cmusrst(CARD2RST);
+			break;
+		case VRC4173_AC97U_PCI_CLOCK:
+			clear_cmusrst(AC97RST);
+			break;
+		default:
+			break;
+		}
+
+		spin_unlock_irq(&vrc4173_cmu_lock);
 	}
 }
 
+EXPORT_SYMBOL(vrc4173_mask_clock);
+
 static inline void vrc4173_cmu_init(void)
 {
 	vrc4173_cmuclkmsk = vrc4173_inw(VRC4173_CMUCLKMSK);
-}
 
-EXPORT_SYMBOL(vrc4173_clock_supply);
-EXPORT_SYMBOL(vrc4173_clock_mask);
+	spin_lock_init(&vrc4173_cmu_lock);
+}
 
-void vrc4173_select_function(int func)
+void vrc4173_select_function(vrc4173_function_t function)
 {
-	u16 val;
-
 	if (vrc4173_initialized) {
-		val = vrc4173_inw(VRC4173_SELECTREG);
-		switch(func) {
-		case PS2CH1_SELECT:
-			val |= 0x0004;
+		spin_lock_irq(&vrc4173_giu_lock);
+
+		switch(function) {
+		case PS2_CHANNEL1:
+			vrc4173_selectreg |= SEL2;
 			break;
-		case PS2CH2_SELECT:
-			val |= 0x0002;
+		case PS2_CHANNEL2:
+			vrc4173_selectreg |= SEL1;
 			break;
-		case TOUCHPANEL_SELECT:
-			val &= 0x0007;
+		case TOUCHPANEL:
+			vrc4173_selectreg &= SEL2 | SEL1 | SEL0;
 			break;
-		case KIU8_SELECT:
-			val &= 0x000e;
+		case KEYBOARD_8SCANLINES:
+			vrc4173_selectreg &= SEL3 | SEL2 | SEL1;
 			break;
-		case KIU10_SELECT:
-			val &= 0x000c;
+		case KEYBOARD_10SCANLINES:
+			vrc4173_selectreg &= SEL3 | SEL2;
 			break;
-		case KIU12_SELECT:
-			val &= 0x0008;
+		case KEYBOARD_12SCANLINES:
+			vrc4173_selectreg &= SEL3;
 			break;
-		case GPIO_SELECT:
-			val |= 0x0008;
+		case GPIO_0_15PINS:
+			vrc4173_selectreg |= SEL0;
+			break;
+		case GPIO_16_20PINS:
+			vrc4173_selectreg |= SEL3;
 			break;
 		}
-		vrc4173_outw(val, VRC4173_SELECTREG);
+
+		vrc4173_outw(vrc4173_selectreg, VRC4173_SELECTREG);
+
+		spin_unlock_irq(&vrc4173_giu_lock);
 	}
 }
 
 EXPORT_SYMBOL(vrc4173_select_function);
 
+static inline void vrc4173_giu_init(void)
+{
+	vrc4173_selectreg = vrc4173_inw(VRC4173_SELECTREG);
+
+	spin_lock_init(&vrc4173_giu_lock);
+}
+
 static void enable_vrc4173_irq(unsigned int irq)
 {
-	u16 val;
+	uint16_t val;
 
 	val = vrc4173_inw(VRC4173_MSYSINT1REG);
-	val |= (u16)1 << (irq - VRC4173_IRQ_BASE);
+	val |= (uint16_t)1 << (irq - VRC4173_IRQ_BASE);
 	vrc4173_outw(val, VRC4173_MSYSINT1REG);
 }
 
 static void disable_vrc4173_irq(unsigned int irq)
 {
-	u16 val;
+	uint16_t val;
 
 	val = vrc4173_inw(VRC4173_MSYSINT1REG);
-	val &= ~((u16)1 << (irq - VRC4173_IRQ_BASE));
+	val &= ~((uint16_t)1 << (irq - VRC4173_IRQ_BASE));
 	vrc4173_outw(val, VRC4173_MSYSINT1REG);
 }
 
@@ -157,19 +350,18 @@ static void end_vrc4173_irq(unsigned int
 }
 
 static struct hw_interrupt_type vrc4173_irq_type = {
-	"VRC4173",
-	startup_vrc4173_irq,
-	shutdown_vrc4173_irq,
-	enable_vrc4173_irq,
-	disable_vrc4173_irq,
-	ack_vrc4173_irq,
-	end_vrc4173_irq,
-	NULL
+	.typename	= "VRC4173",
+	.startup	= startup_vrc4173_irq,
+	.shutdown	= shutdown_vrc4173_irq,
+	.enable		= enable_vrc4173_irq,
+	.disable	= disable_vrc4173_irq,
+	.ack		= ack_vrc4173_irq,
+	.end		= end_vrc4173_irq,
 };
 
 static int vrc4173_get_irq_number(int irq)
 {
-	u16 status, mask;
+	uint16_t status, mask;
 	int i;
 
         status = vrc4173_inw(VRC4173_SYSINT1REG);
@@ -179,18 +371,18 @@ static int vrc4173_get_irq_number(int ir
 	if (status) {
 		for (i = 0; i < 16; i++)
 			if (status & (0x0001 << i))
-				return VRC4173_IRQ_BASE + i;
+				return VRC4173_IRQ(i);
 	}
 
 	return -EINVAL;
 }
 
-static inline void vrc4173_icu_init(int cascade_irq)
+static inline int vrc4173_icu_init(int cascade_irq)
 {
 	int i;
 
 	if (cascade_irq < GIU_IRQ(0) || cascade_irq > GIU_IRQ(15))
-		return;
+		return -EINVAL;
 	
 	vrc4173_outw(0, VRC4173_MSYSINT1REG);
 
@@ -199,33 +391,38 @@ static inline void vrc4173_icu_init(int 
 
 	for (i = VRC4173_IRQ_BASE; i <= VRC4173_IRQ_LAST; i++)
                 irq_desc[i].handler = &vrc4173_irq_type;
+
+	return 0;
 }
 
-static int __devinit vrc4173_probe(struct pci_dev *pdev,
-                                   const struct pci_device_id *ent)
+static int __devinit vrc4173_probe(struct pci_dev *dev,
+                                   const struct pci_device_id *id)
 {
 	unsigned long start, flags;
 	int err;
 
-	if ((err = pci_enable_device(pdev)) < 0) {
-		printk(KERN_ERR "vrc4173: failed to enable device -- err=%d\n", err);
+	err = pci_enable_device(dev);
+	if (err < 0) {
+		printk(KERN_ERR "vrc4173: Failed to enable PCI device, aborting\n");
 		return err;
 	}
 
-	pci_set_master(pdev);
+	pci_set_master(dev);
 
-	start = pci_resource_start(pdev, 0);
-	if (!start) {
-		printk(KERN_ERR "vrc4173:No PCI I/O resources, aborting\n");
-		return -ENODEV;
+	start = pci_resource_start(dev, 0);
+	if (start == 0) {
+		printk(KERN_ERR "vrc4173:No such PCI I/O resource, aborting\n");
+		return -ENXIO;
 	}
 
-	if (!start || (((flags = pci_resource_flags(pdev, 0)) & IORESOURCE_IO) == 0)) {
-		printk(KERN_ERR "vrc4173: No PCI I/O resources, aborting\n");
-		return -ENODEV;
+	flags = pci_resource_flags(dev, 0);
+	if ((flags & IORESOURCE_IO) == 0) {
+		printk(KERN_ERR "vrc4173: No such PCI I/O resource, aborting\n");
+		return -ENXIO;
 	}
 
-	if ((err = pci_request_regions(pdev, "NEC VRC4173")) < 0) {
+	err = pci_request_regions(dev, "NEC VRC4173");
+	if (err < 0) {
 		printk(KERN_ERR "vrc4173: PCI resources are busy, aborting\n");
 		return err;
 	}
@@ -233,33 +430,46 @@ static int __devinit vrc4173_probe(struc
 	set_vrc4173_io_offset(start);
 
 	vrc4173_cmu_init();
+	vrc4173_giu_init();
 
-	vrc4173_icu_init(pdev->irq);
+	err = vrc4173_icu_init(dev->irq);
+	if (err < 0) {
+		printk(KERN_ERR "vrc4173: Invalid IRQ %d, aborting\n", dev->irq);
+		return err;
+	}
 
-	if ((err = vr41xx_cascade_irq(pdev->irq, vrc4173_get_irq_number)) < 0) {
-		printk(KERN_ERR
-		       "vrc4173: IRQ resource %d is busy, aborting\n", pdev->irq);
+	err = vr41xx_cascade_irq(dev->irq, vrc4173_get_irq_number);
+	if (err < 0) {
+		printk(KERN_ERR "vrc4173: IRQ resource %d is busy, aborting\n", dev->irq);
 		return err;
 	}
 
 	printk(KERN_INFO
-	       "NEC VRC4173 at 0x%#08lx, IRQ is cascaded to %d\n", start, pdev->irq);
+	       "NEC VRC4173 at 0x%#08lx, IRQ is cascaded to %d\n", start, dev->irq);
 
 	return 0;
 }
 
+static void vrc4173_remove(struct pci_dev *dev)
+{
+	free_irq(dev->irq, NULL);
+
+	pci_release_regions(dev);
+}
+
 static struct pci_driver vrc4173_driver = {
 	.name		= "NEC VRC4173",
 	.probe		= vrc4173_probe,
-	.remove		= NULL,
-	.id_table	= vrc4173_table,
+	.remove		= vrc4173_remove,
+	.id_table	= vrc4173_id_table,
 };
 
 static int __devinit vrc4173_init(void)
 {
 	int err;
 
-	if ((err = pci_module_init(&vrc4173_driver)) < 0)
+	err = pci_module_init(&vrc4173_driver);
+	if (err < 0)
 		return err;
 
 	vrc4173_initialized = 1;
diff -puN arch/mips/vr41xx/tanbac-tb0226/setup.c~mips-update arch/mips/vr41xx/tanbac-tb0226/setup.c
--- 25/arch/mips/vr41xx/tanbac-tb0226/setup.c~mips-update	2004-06-21 23:10:45.457309016 -0700
+++ 25-akpm/arch/mips/vr41xx/tanbac-tb0226/setup.c	2004-06-21 23:10:45.759263112 -0700
@@ -18,59 +18,8 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 #include <linux/config.h>
-#include <linux/ioport.h>
 
-#include <asm/io.h>
-#include <asm/pci_channel.h>
-#include <asm/vr41xx/tb0226.h>
-
-#ifdef CONFIG_PCI
-static struct resource vr41xx_pci_io_resource = {
-	.name	= "PCI I/O space",
-	.start	= VR41XX_PCI_IO_START,
-	.end	= VR41XX_PCI_IO_END,
-	.flags	= IORESOURCE_IO,
-};
-
-static struct resource vr41xx_pci_mem_resource = {
-	.name	= "PCI memory space",
-	.start	= VR41XX_PCI_MEM_START,
-	.end	= VR41XX_PCI_MEM_END,
-	.flags	= IORESOURCE_MEM,
-};
-
-extern struct pci_ops vr41xx_pci_ops;
-
-struct pci_controller vr41xx_controller[] = {
-	.pci_ops	= &vr41xx_pci_ops,
-	.io_resource	= &vr41xx_pci_io_resource,
-	.mem_resource	= &vr41xx_pci_mem_resource,
-};
-
-struct vr41xx_pci_address_space vr41xx_pci_mem1 = {
-	.internal_base	= VR41XX_PCI_MEM1_BASE,
-	.address_mask	= VR41XX_PCI_MEM1_MASK,
-	.pci_base	= IO_MEM1_RESOURCE_START,
-};
-
-struct vr41xx_pci_address_space vr41xx_pci_mem2 = {
-	.internal_base	= VR41XX_PCI_MEM2_BASE,
-	.address_mask	= VR41XX_PCI_MEM2_MASK,
-	.pci_base	= IO_MEM2_RESOURCE_START,
-};
-
-struct vr41xx_pci_address_space vr41xx_pci_io = {
-	.internal_base	= VR41XX_PCI_IO_BASE,
-	.address_mask	= VR41XX_PCI_IO_MASK,
-	.pci_base	= IO_PORT_RESOURCE_START,
-};
-
-static struct vr41xx_pci_address_map pci_address_map = {
-	.mem1	= &vr41xx_pci_mem1,
-	.mem2	= &vr41xx_pci_mem2,
-	.io	= &vr41xx_pci_io,
-};
-#endif
+#include <asm/vr41xx/vr41xx.h>
 
 const char *get_system_type(void)
 {
@@ -79,19 +28,11 @@ const char *get_system_type(void)
 
 static int tanbac_tb0226_setup(void)
 {
-	set_io_port_base(IO_PORT_BASE);
-	ioport_resource.start = IO_PORT_RESOURCE_START;
-	ioport_resource.end = IO_PORT_RESOURCE_END;
-
 #ifdef CONFIG_SERIAL_8250
 	vr41xx_select_siu_interface(SIU_RS232C, IRDA_NONE);
 	vr41xx_siu_init();
 #endif
 
-#ifdef CONFIG_PCI
-	vr41xx_pciu_init(&pci_address_map);
-#endif
-
 	return 0;
 }
 
diff -puN arch/mips/vr41xx/tanbac-tb0229/Makefile~mips-update arch/mips/vr41xx/tanbac-tb0229/Makefile
--- 25/arch/mips/vr41xx/tanbac-tb0229/Makefile~mips-update	2004-06-21 23:10:45.460308560 -0700
+++ 25-akpm/arch/mips/vr41xx/tanbac-tb0229/Makefile	2004-06-21 23:10:45.760262960 -0700
@@ -4,4 +4,4 @@
 
 obj-y				:= setup.o
 
-obj-$(CONFIG_TANBAC_TB0219)	+= reboot.o
+obj-$(CONFIG_TANBAC_TB0219)	+= tb0219.o
diff -L arch/mips/vr41xx/tanbac-tb0229/reboot.c -puN arch/mips/vr41xx/tanbac-tb0229/reboot.c~mips-update /dev/null
--- 25/arch/mips/vr41xx/tanbac-tb0229/reboot.c
+++ /dev/null	2003-09-15 06:40:47.000000000 -0700
@@ -1,27 +0,0 @@
-/*
- * FILE NAME
- *	arch/mips/vr41xx/tanbac-tb0229/reboot.c
- *
- * BRIEF MODULE DESCRIPTION
- *	Depending on TANBAC TB0229(VR4131DIMM) of reboot system call.
- *
- * Copyright 2003 Megasolution Inc.
- *                matsu@megasolution.jp
- *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License as published by the
- *  Free Software Foundation; either version 2 of the License, or (at your
- *  option) any later version.
- */
-#include <linux/config.h>
-#include <asm/io.h>
-#include <asm/vr41xx/tb0229.h>
-
-#define tb0229_hard_reset()	writew(0, TB0219_RESET_REGS)
-
-void tanbac_tb0229_restart(char *command)
-{
-	local_irq_disable();
-	tb0229_hard_reset();
-	while (1);
-}
diff -puN arch/mips/vr41xx/tanbac-tb0229/setup.c~mips-update arch/mips/vr41xx/tanbac-tb0229/setup.c
--- 25/arch/mips/vr41xx/tanbac-tb0229/setup.c~mips-update	2004-06-21 23:10:45.464307952 -0700
+++ 25-akpm/arch/mips/vr41xx/tanbac-tb0229/setup.c	2004-06-21 23:10:45.761262808 -0700
@@ -21,60 +21,8 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 #include <linux/config.h>
-#include <linux/ioport.h>
 
-#include <asm/io.h>
-#include <asm/pci_channel.h>
-#include <asm/reboot.h>
-#include <asm/vr41xx/tb0229.h>
-
-#ifdef CONFIG_PCI
-static struct resource vr41xx_pci_io_resource = {
-	.name	= "PCI I/O space",
-	.start	= VR41XX_PCI_IO_START,
-	.end	= VR41XX_PCI_IO_END,
-	.flags	= IORESOURCE_IO,
-};
-
-static struct resource vr41xx_pci_mem_resource = {
-	.name	= "PCI memory space",
-	.start	= VR41XX_PCI_MEM_START,
-	.end	= VR41XX_PCI_MEM_END,
-	.flags	= IORESOURCE_MEM,
-};
-
-extern struct pci_ops vr41xx_pci_ops;
-
-struct pci_controller vr41xx_controller = {
-	.pci_ops	= &vr41xx_pci_ops,
-	.io_resource	= &vr41xx_pci_io_resource,
-	.mem_resource	= &vr41xx_pci_mem_resource,
-};
-
-struct vr41xx_pci_address_space vr41xx_pci_mem1 = {
-	.internal_base	= VR41XX_PCI_MEM1_BASE,
-	.address_mask	= VR41XX_PCI_MEM1_MASK,
-	.pci_base	= IO_MEM1_RESOURCE_START,
-};
-
-struct vr41xx_pci_address_space vr41xx_pci_mem2 = {
-	.internal_base	= VR41XX_PCI_MEM2_BASE,
-	.address_mask	= VR41XX_PCI_MEM2_MASK,
-	.pci_base	= IO_MEM2_RESOURCE_START,
-};
-
-struct vr41xx_pci_address_space vr41xx_pci_io = {
-	.internal_base	= VR41XX_PCI_IO_BASE,
-	.address_mask	= VR41XX_PCI_IO_MASK,
-	.pci_base	= IO_PORT_RESOURCE_START
-};
-
-static struct vr41xx_pci_address_map pci_address_map = {
-	.mem1	= &vr41xx_pci_mem1,
-	.mem2	= &vr41xx_pci_mem2,
-	.io	= &vr41xx_pci_io,
-};
-#endif
+#include <asm/vr41xx/vr41xx.h>
 
 const char *get_system_type(void)
 {
@@ -83,24 +31,12 @@ const char *get_system_type(void)
 
 static int tanbac_tb0229_setup(void)
 {
-	set_io_port_base(IO_PORT_BASE);
-	ioport_resource.start = IO_PORT_RESOURCE_START;
-	ioport_resource.end = IO_PORT_RESOURCE_END;
-
 #ifdef CONFIG_SERIAL_8250
 	vr41xx_select_siu_interface(SIU_RS232C, IRDA_NONE);
 	vr41xx_siu_init();
 	vr41xx_dsiu_init();
 #endif
 
-#ifdef CONFIG_PCI
-	vr41xx_pciu_init(&pci_address_map);
-#endif
-
-#ifdef CONFIG_TANBAC_TB0219
-	_machine_restart = tanbac_tb0229_restart;
-#endif
-
 	return 0;
 }
 
diff -puN /dev/null arch/mips/vr41xx/tanbac-tb0229/tb0219.c
--- /dev/null	2003-09-15 06:40:47.000000000 -0700
+++ 25-akpm/arch/mips/vr41xx/tanbac-tb0229/tb0219.c	2004-06-21 23:10:45.763262504 -0700
@@ -0,0 +1,44 @@
+/*
+ *  tb0219.c, Setup for the TANBAC TB0219
+ *
+ *  Copyright (C) 2003  Megasolution Inc. <matsu@megasolution.jp>
+ *  Copyright (C) 2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#include <linux/init.h>
+
+#include <asm/io.h>
+#include <asm/reboot.h>
+
+#define TB0219_RESET_REGS	KSEG1ADDR(0x0a00000e)
+
+#define tb0219_hard_reset()	writew(0, TB0219_RESET_REGS)
+
+static void tanbac_tb0219_restart(char *command)
+{
+	local_irq_disable();
+	tb0219_hard_reset();
+	while (1);
+}
+
+static int __init tanbac_tb0219_setup(void)
+{
+	_machine_restart = tanbac_tb0219_restart;
+
+	return 0;
+}
+
+early_initcall(tanbac_tb0219_setup);
diff -puN arch/mips/vr41xx/victor-mpc30x/setup.c~mips-update arch/mips/vr41xx/victor-mpc30x/setup.c
--- 25/arch/mips/vr41xx/victor-mpc30x/setup.c~mips-update	2004-06-21 23:10:45.466307648 -0700
+++ 25-akpm/arch/mips/vr41xx/victor-mpc30x/setup.c	2004-06-21 23:10:45.764262352 -0700
@@ -18,59 +18,8 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 #include <linux/config.h>
-#include <linux/ioport.h>
 
-#include <asm/io.h>
-#include <asm/pci_channel.h>
-#include <asm/vr41xx/mpc30x.h>
-
-#ifdef CONFIG_PCI
-static struct resource vr41xx_pci_io_resource = {
-	"PCI I/O space",
-	VR41XX_PCI_IO_START,
-	VR41XX_PCI_IO_END,
-	IORESOURCE_IO
-};
-
-static struct resource vr41xx_pci_mem_resource = {
-	"PCI memory space",
-	VR41XX_PCI_MEM_START,
-	VR41XX_PCI_MEM_END,
-	IORESOURCE_MEM
-};
-
-extern struct pci_ops vr41xx_pci_ops;
-
-struct pci_controller vr41xx_controller[] = {
-	.pci_ops	= &vr41xx_pci_ops,
-	.io_resource	= &vr41xx_pci_io_resource,
-	.mem_resource	= &vr41xx_pci_mem_resource,
-};
-
-struct vr41xx_pci_address_space vr41xx_pci_mem1 = {
-	VR41XX_PCI_MEM1_BASE,
-	VR41XX_PCI_MEM1_MASK,
-	IO_MEM1_RESOURCE_START
-};
-
-struct vr41xx_pci_address_space vr41xx_pci_mem2 = {
-	VR41XX_PCI_MEM2_BASE,
-	VR41XX_PCI_MEM2_MASK,
-	IO_MEM2_RESOURCE_START
-};
-
-struct vr41xx_pci_address_space vr41xx_pci_io = {
-	VR41XX_PCI_IO_BASE,
-	VR41XX_PCI_IO_MASK,
-	IO_PORT_RESOURCE_START
-};
-
-static struct vr41xx_pci_address_map pci_address_map = {
-	&vr41xx_pci_mem1,
-	&vr41xx_pci_mem2,
-	&vr41xx_pci_io
-};
-#endif
+#include <asm/vr41xx/vr41xx.h>
 
 const char *get_system_type(void)
 {
@@ -79,19 +28,11 @@ const char *get_system_type(void)
 
 static int victor_mpc30x_setup(void)
 {
-	set_io_port_base(IO_PORT_BASE);
-	ioport_resource.start = IO_PORT_RESOURCE_START;
-	ioport_resource.end = IO_PORT_RESOURCE_END;
-
 #ifdef CONFIG_SERIAL_8250
 	vr41xx_select_siu_interface(SIU_RS232C, IRDA_NONE);
 	vr41xx_siu_init();
 #endif
 
-#ifdef CONFIG_PCI
-	vr41xx_pciu_init(&pci_address_map);
-#endif
-
 	return 0;
 }
 
diff -puN arch/mips/vr41xx/zao-capcella/setup.c~mips-update arch/mips/vr41xx/zao-capcella/setup.c
--- 25/arch/mips/vr41xx/zao-capcella/setup.c~mips-update	2004-06-21 23:10:45.468307344 -0700
+++ 25-akpm/arch/mips/vr41xx/zao-capcella/setup.c	2004-06-21 23:10:45.765262200 -0700
@@ -18,59 +18,8 @@
  *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 #include <linux/config.h>
-#include <linux/ioport.h>
 
-#include <asm/io.h>
-#include <asm/pci_channel.h>
-#include <asm/vr41xx/capcella.h>
-
-#ifdef CONFIG_PCI
-static struct resource vr41xx_pci_io_resource = {
-	"PCI I/O space",
-	VR41XX_PCI_IO_START,
-	VR41XX_PCI_IO_END,
-	IORESOURCE_IO
-};
-
-static struct resource vr41xx_pci_mem_resource = {
-	"PCI memory space",
-	VR41XX_PCI_MEM_START,
-	VR41XX_PCI_MEM_END,
-	IORESOURCE_MEM
-};
-
-extern struct pci_ops vr41xx_pci_ops;
-
-struct pci_controller vr41xx_controller = {
-	.pci_ops	= &vr41xx_pci_ops,
-	.io_resource	= &vr41xx_pci_io_resource,
-	.mem_resource	= &vr41xx_pci_mem_resource,
-};
-
-struct vr41xx_pci_address_space vr41xx_pci_mem1 = {
-	VR41XX_PCI_MEM1_BASE,
-	VR41XX_PCI_MEM1_MASK,
-	IO_MEM1_RESOURCE_START
-};
-
-struct vr41xx_pci_address_space vr41xx_pci_mem2 = {
-	VR41XX_PCI_MEM2_BASE,
-	VR41XX_PCI_MEM2_MASK,
-	IO_MEM2_RESOURCE_START
-};
-
-struct vr41xx_pci_address_space vr41xx_pci_io = {
-	VR41XX_PCI_IO_BASE,
-	VR41XX_PCI_IO_MASK,
-	IO_PORT_RESOURCE_START
-};
-
-static struct vr41xx_pci_address_map pci_address_map = {
-	&vr41xx_pci_mem1,
-	&vr41xx_pci_mem2,
-	&vr41xx_pci_io
-};
-#endif
+#include <asm/vr41xx/vr41xx.h>
 
 const char *get_system_type(void)
 {
@@ -79,20 +28,12 @@ const char *get_system_type(void)
 
 static int zao_capcella_setup(void)
 {
-	set_io_port_base(IO_PORT_BASE);
-	ioport_resource.start = IO_PORT_RESOURCE_START;
-	ioport_resource.end = IO_PORT_RESOURCE_END;
-
 #ifdef CONFIG_SERIAL_8250
 	vr41xx_select_siu_interface(SIU_RS232C, IRDA_NONE);
 	vr41xx_siu_init();
 	vr41xx_dsiu_init();
 #endif
 
-#ifdef CONFIG_PCI
-	vr41xx_pciu_init(&pci_address_map);
-#endif
-
 	return 0;
 }
 
diff -puN include/asm-mips/asmmacro.h~mips-update include/asm-mips/asmmacro.h
--- 25/include/asm-mips/asmmacro.h~mips-update	2004-06-21 23:10:45.471306888 -0700
+++ 25-akpm/include/asm-mips/asmmacro.h	2004-06-21 23:10:45.767261896 -0700
@@ -9,6 +9,7 @@
 #define _ASM_ASMMACRO_H
  
 #include <linux/config.h>
+#include <asm/hazards.h>
  
 #ifdef CONFIG_MIPS32
 #include <asm/asmmacro-32.h>
@@ -21,6 +22,7 @@
 	mfc0	\reg, CP0_STATUS
 	ori	\reg, \reg, 1
 	mtc0	\reg, CP0_STATUS
+	irq_enable_hazard
 	.endm
 
 	.macro	local_irq_disable reg=t0
@@ -28,7 +30,7 @@
 	ori	\reg, \reg, 1
 	xori	\reg, \reg, 1
 	mtc0	\reg, CP0_STATUS
-	SSNOP; SSNOP; SSNOP
+	irq_disable_hazard
 	.endm
 
 #ifdef CONFIG_CPU_SB1
diff -puN include/asm-mips/atomic.h~mips-update include/asm-mips/atomic.h
--- 25/include/asm-mips/atomic.h~mips-update	2004-06-21 23:10:45.474306432 -0700
+++ 25-akpm/include/asm-mips/atomic.h	2004-06-21 23:10:45.770261440 -0700
@@ -9,7 +9,7 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 1996, 97, 99, 2000, 03 by Ralf Baechle
+ * Copyright (C) 1996, 97, 99, 2000, 03, 04 by Ralf Baechle
  */
 
 /*
@@ -127,6 +127,32 @@ static __inline__ int atomic_sub_return(
 	return result;
 }
 
+/*
+ * atomic_sub_if_positive - add integer to atomic variable
+ * @v: pointer of type atomic_t
+ *
+ * Atomically test @v and decrement if it is greater than 0.
+ * The function returns the old value of @v minus 1.
+ */
+static __inline__ int atomic_sub_if_positive(int i, atomic_t * v)
+{
+	unsigned long temp, result;
+
+	__asm__ __volatile__(
+	"1:	ll	%1, %2		# atomic_sub_if_positive\n"
+	"	subu	%0, %1, %3				\n"
+	"	bltz	%0, 1f					\n"
+	"	sc	%0, %2					\n"
+	"	beqz	%0, 1b					\n"
+	"	sync						\n"
+	"1:							\n"
+	: "=&r" (result), "=&r" (temp), "=m" (v->counter)
+	: "Ir" (i), "m" (v->counter)
+	: "memory");
+
+	return result;
+}
+
 #else
 
 /*
@@ -192,6 +218,28 @@ static __inline__ int atomic_sub_return(
 	return temp;
 }
 
+/*
+ * atomic_sub_if_positive - add integer to atomic variable
+ * @v: pointer of type atomic_t
+ *
+ * Atomically test @v and decrement if it is greater than 0.
+ * The function returns the old value of @v minus 1.
+ */
+static __inline__ int atomic_sub_if_positive(int i, atomic_t * v)
+{
+	unsigned long flags;
+	int temp;
+
+	spin_lock_irqsave(&atomic_lock, flags);
+	temp = v->counter;
+	temp -= i;
+	if (temp >= 0)
+		v->counter = temp;
+	spin_unlock_irqrestore(&atomic_lock, flags);
+
+	return temp;
+}
+
 #endif /* CONFIG_CPU_HAS_LLSC */
 
 #define atomic_dec_return(v) atomic_sub_return(1,(v))
@@ -229,6 +277,12 @@ static __inline__ int atomic_sub_return(
 #define atomic_dec_and_test(v) (atomic_sub_return(1, (v)) == 0)
 
 /*
+ * atomic_dec_if_positive - decrement by 1 if old value positive
+ * @v: pointer of type atomic_t
+ */
+#define atomic_dec_if_positive(v)	atomic_sub_if_positive(1, v)
+
+/*
  * atomic_inc - increment atomic variable
  * @v: pointer of type atomic_t
  *
@@ -284,7 +338,7 @@ typedef struct { volatile __s64 counter;
  *
  * Atomically adds @i to @v.
  */
-static __inline__ void atomic64_add(int i, atomic64_t * v)
+static __inline__ void atomic64_add(long i, atomic64_t * v)
 {
 	unsigned long temp;
 
@@ -304,7 +358,7 @@ static __inline__ void atomic64_add(int 
  *
  * Atomically subtracts @i from @v.
  */
-static __inline__ void atomic64_sub(int i, atomic64_t * v)
+static __inline__ void atomic64_sub(long i, atomic64_t * v)
 {
 	unsigned long temp;
 
@@ -320,7 +374,7 @@ static __inline__ void atomic64_sub(int 
 /*
  * Same as above, but return the result value
  */
-static __inline__ int atomic64_add_return(int i, atomic64_t * v)
+static __inline__ long atomic64_add_return(long i, atomic64_t * v)
 {
 	unsigned long temp, result;
 
@@ -338,7 +392,7 @@ static __inline__ int atomic64_add_retur
 	return result;
 }
 
-static __inline__ int atomic64_sub_return(int i, atomic64_t * v)
+static __inline__ long atomic64_sub_return(long i, atomic64_t * v)
 {
 	unsigned long temp, result;
 
@@ -356,6 +410,32 @@ static __inline__ int atomic64_sub_retur
 	return result;
 }
 
+/*
+ * atomic64_sub_if_positive - add integer to atomic variable
+ * @v: pointer of type atomic64_t
+ *
+ * Atomically test @v and decrement if it is greater than 0.
+ * The function returns the old value of @v minus 1.
+ */
+static __inline__ long atomic64_sub_if_positive(long i, atomic64_t * v)
+{
+	unsigned long temp, result;
+
+	__asm__ __volatile__(
+	"1:	lld	%1, %2		# atomic64_sub_if_positive\n"
+	"	dsubu	%0, %1, %3				\n"
+	"	bltz	%0, 1f					\n"
+	"	scd	%0, %2					\n"
+	"	beqz	%0, 1b					\n"
+	"	sync						\n"
+	"1:							\n"
+	: "=&r" (result), "=&r" (temp), "=m" (v->counter)
+	: "Ir" (i), "m" (v->counter)
+	: "memory");
+
+	return result;
+}
+
 #else
 
 /*
@@ -368,7 +448,7 @@ static __inline__ int atomic64_sub_retur
  *
  * Atomically adds @i to @v.
  */
-static __inline__ void atomic64_add(int i, atomic64_t * v)
+static __inline__ void atomic64_add(long i, atomic64_t * v)
 {
 	unsigned long flags;
 
@@ -384,7 +464,7 @@ static __inline__ void atomic64_add(int 
  *
  * Atomically subtracts @i from @v.
  */
-static __inline__ void atomic64_sub(int i, atomic64_t * v)
+static __inline__ void atomic64_sub(long i, atomic64_t * v)
 {
 	unsigned long flags;
 
@@ -393,10 +473,10 @@ static __inline__ void atomic64_sub(int 
 	spin_unlock_irqrestore(&atomic_lock, flags);
 }
 
-static __inline__ int atomic64_add_return(int i, atomic64_t * v)
+static __inline__ long atomic64_add_return(long i, atomic64_t * v)
 {
 	unsigned long flags;
-	int temp;
+	long temp;
 
 	spin_lock_irqsave(&atomic_lock, flags);
 	temp = v->counter;
@@ -407,10 +487,10 @@ static __inline__ int atomic64_add_retur
 	return temp;
 }
 
-static __inline__ int atomic64_sub_return(int i, atomic64_t * v)
+static __inline__ long atomic64_sub_return(long i, atomic64_t * v)
 {
 	unsigned long flags;
-	int temp;
+	long temp;
 
 	spin_lock_irqsave(&atomic_lock, flags);
 	temp = v->counter;
@@ -421,6 +501,28 @@ static __inline__ int atomic64_sub_retur
 	return temp;
 }
 
+/*
+ * atomic64_sub_if_positive - add integer to atomic variable
+ * @v: pointer of type atomic64_t
+ *
+ * Atomically test @v and decrement if it is greater than 0.
+ * The function returns the old value of @v minus 1.
+ */
+static __inline__ long atomic64_sub_if_positive(long i, atomic64_t * v)
+{
+	unsigned long flags;
+	long temp;
+
+	spin_lock_irqsave(&atomic_lock, flags);
+	temp = v->counter;
+	temp -= i;
+	if (temp >= 0)
+		v->counter = temp;
+	spin_unlock_irqrestore(&atomic_lock, flags);
+
+	return temp;
+}
+
 #endif /* CONFIG_CPU_HAS_LLDSCD */
 
 #define atomic64_dec_return(v) atomic64_sub_return(1,(v))
@@ -458,6 +560,12 @@ static __inline__ int atomic64_sub_retur
 #define atomic64_dec_and_test(v) (atomic64_sub_return(1, (v)) == 0)
 
 /*
+ * atomic64_dec_if_positive - decrement by 1 if old value positive
+ * @v: pointer of type atomic64_t
+ */
+#define atomic64_dec_if_positive(v)	atomic64_sub_if_positive(1, v)
+
+/*
  * atomic64_inc - increment atomic variable
  * @v: pointer of type atomic64_t
  *
diff -puN include/asm-mips/cache.h~mips-update include/asm-mips/cache.h
--- 25/include/asm-mips/cache.h~mips-update	2004-06-21 23:10:45.475306280 -0700
+++ 25-akpm/include/asm-mips/cache.h	2004-06-21 23:10:45.770261440 -0700
@@ -18,4 +18,6 @@
 #define SMP_CACHE_SHIFT		L1_CACHE_SHIFT
 #define SMP_CACHE_BYTES		L1_CACHE_BYTES
 
+#define ARCH_KMALLOC_MINALIGN	8
+
 #endif /* _ASM_CACHE_H */
diff -puN /dev/null include/asm-mips/gt64240.h
--- /dev/null	2003-09-15 06:40:47.000000000 -0700
+++ 25-akpm/include/asm-mips/gt64240.h	2004-06-21 23:10:45.779260072 -0700
@@ -0,0 +1,1264 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright - Galileo technology.
+ * Copyright (C) 2004 by Ralf Baechle
+ */
+#ifndef __ASM_MIPS_MV64240_H
+#define __ASM_MIPS_MV64240_H
+
+#include <asm/addrspace.h>
+#include <asm/byteorder.h>
+
+/*
+ * CPU Control Registers
+ */
+
+#define CPU_CONFIGURATION					0x000
+#define CPU_MODE						0x120
+#define CPU_READ_RESPONSE_CROSSBAR_LOW				0x170
+#define CPU_READ_RESPONSE_CROSSBAR_HIGH				0x178
+
+/*
+ * Processor Address Space
+ */
+
+/* Sdram's BAR'S */
+#define SCS_0_LOW_DECODE_ADDRESS				0x008
+#define SCS_0_HIGH_DECODE_ADDRESS				0x010
+#define SCS_1_LOW_DECODE_ADDRESS				0x208
+#define SCS_1_HIGH_DECODE_ADDRESS				0x210
+#define SCS_2_LOW_DECODE_ADDRESS				0x018
+#define SCS_2_HIGH_DECODE_ADDRESS				0x020
+#define SCS_3_LOW_DECODE_ADDRESS				0x218
+#define SCS_3_HIGH_DECODE_ADDRESS				0x220
+/* Devices BAR'S */
+#define CS_0_LOW_DECODE_ADDRESS					0x028
+#define CS_0_HIGH_DECODE_ADDRESS				0x030
+#define CS_1_LOW_DECODE_ADDRESS					0x228
+#define CS_1_HIGH_DECODE_ADDRESS				0x230
+#define CS_2_LOW_DECODE_ADDRESS					0x248
+#define CS_2_HIGH_DECODE_ADDRESS				0x250
+#define CS_3_LOW_DECODE_ADDRESS					0x038
+#define CS_3_HIGH_DECODE_ADDRESS				0x040
+#define BOOTCS_LOW_DECODE_ADDRESS				0x238
+#define BOOTCS_HIGH_DECODE_ADDRESS				0x240
+
+#define PCI_0I_O_LOW_DECODE_ADDRESS				0x048
+#define PCI_0I_O_HIGH_DECODE_ADDRESS				0x050
+#define PCI_0MEMORY0_LOW_DECODE_ADDRESS				0x058
+#define PCI_0MEMORY0_HIGH_DECODE_ADDRESS			0x060
+#define PCI_0MEMORY1_LOW_DECODE_ADDRESS				0x080
+#define PCI_0MEMORY1_HIGH_DECODE_ADDRESS			0x088
+#define PCI_0MEMORY2_LOW_DECODE_ADDRESS				0x258
+#define PCI_0MEMORY2_HIGH_DECODE_ADDRESS			0x260
+#define PCI_0MEMORY3_LOW_DECODE_ADDRESS				0x280
+#define PCI_0MEMORY3_HIGH_DECODE_ADDRESS			0x288
+
+#define PCI_1I_O_LOW_DECODE_ADDRESS				0x090
+#define PCI_1I_O_HIGH_DECODE_ADDRESS				0x098
+#define PCI_1MEMORY0_LOW_DECODE_ADDRESS				0x0a0
+#define PCI_1MEMORY0_HIGH_DECODE_ADDRESS			0x0a8
+#define PCI_1MEMORY1_LOW_DECODE_ADDRESS				0x0b0
+#define PCI_1MEMORY1_HIGH_DECODE_ADDRESS			0x0b8
+#define PCI_1MEMORY2_LOW_DECODE_ADDRESS				0x2a0
+#define PCI_1MEMORY2_HIGH_DECODE_ADDRESS			0x2a8
+#define PCI_1MEMORY3_LOW_DECODE_ADDRESS				0x2b0
+#define PCI_1MEMORY3_HIGH_DECODE_ADDRESS			0x2b8
+
+#define INTERNAL_SPACE_DECODE					0x068
+
+#define CPU_0_LOW_DECODE_ADDRESS				0x290
+#define CPU_0_HIGH_DECODE_ADDRESS				0x298
+#define CPU_1_LOW_DECODE_ADDRESS				0x2c0
+#define CPU_1_HIGH_DECODE_ADDRESS				0x2c8
+
+#define PCI_0I_O_ADDRESS_REMAP					0x0f0
+#define PCI_0MEMORY0_ADDRESS_REMAP				0x0f8
+#define PCI_0MEMORY0_HIGH_ADDRESS_REMAP				0x320
+#define PCI_0MEMORY1_ADDRESS_REMAP				0x100
+#define PCI_0MEMORY1_HIGH_ADDRESS_REMAP				0x328
+#define PCI_0MEMORY2_ADDRESS_REMAP				0x2f8
+#define PCI_0MEMORY2_HIGH_ADDRESS_REMAP				0x330
+#define PCI_0MEMORY3_ADDRESS_REMAP				0x300
+#define PCI_0MEMORY3_HIGH_ADDRESS_REMAP				0x338
+
+#define PCI_1I_O_ADDRESS_REMAP					0x108
+#define PCI_1MEMORY0_ADDRESS_REMAP				0x110
+#define PCI_1MEMORY0_HIGH_ADDRESS_REMAP				0x340
+#define PCI_1MEMORY1_ADDRESS_REMAP				0x118
+#define PCI_1MEMORY1_HIGH_ADDRESS_REMAP				0x348
+#define PCI_1MEMORY2_ADDRESS_REMAP				0x310
+#define PCI_1MEMORY2_HIGH_ADDRESS_REMAP				0x350
+#define PCI_1MEMORY3_ADDRESS_REMAP				0x318
+#define PCI_1MEMORY3_HIGH_ADDRESS_REMAP				0x358
+
+/*
+ * CPU Sync Barrier
+ */
+
+#define PCI_0SYNC_BARIER_VIRTUAL_REGISTER			0x0c0
+#define PCI_1SYNC_BARIER_VIRTUAL_REGISTER			0x0c8
+
+
+/*
+ * CPU Access Protect
+ */
+
+#define CPU_LOW_PROTECT_ADDRESS_0				0X180
+#define CPU_HIGH_PROTECT_ADDRESS_0				0X188
+#define CPU_LOW_PROTECT_ADDRESS_1				0X190
+#define CPU_HIGH_PROTECT_ADDRESS_1				0X198
+#define CPU_LOW_PROTECT_ADDRESS_2				0X1a0
+#define CPU_HIGH_PROTECT_ADDRESS_2				0X1a8
+#define CPU_LOW_PROTECT_ADDRESS_3				0X1b0
+#define CPU_HIGH_PROTECT_ADDRESS_3				0X1b8
+#define CPU_LOW_PROTECT_ADDRESS_4				0X1c0
+#define CPU_HIGH_PROTECT_ADDRESS_4				0X1c8
+#define CPU_LOW_PROTECT_ADDRESS_5				0X1d0
+#define CPU_HIGH_PROTECT_ADDRESS_5				0X1d8
+#define CPU_LOW_PROTECT_ADDRESS_6				0X1e0
+#define CPU_HIGH_PROTECT_ADDRESS_6				0X1e8
+#define CPU_LOW_PROTECT_ADDRESS_7				0X1f0
+#define CPU_HIGH_PROTECT_ADDRESS_7				0X1f8
+
+
+/*
+ * Snoop Control
+ */
+
+#define SNOOP_BASE_ADDRESS_0					0x380
+#define SNOOP_TOP_ADDRESS_0					0x388
+#define SNOOP_BASE_ADDRESS_1					0x390
+#define SNOOP_TOP_ADDRESS_1					0x398
+#define SNOOP_BASE_ADDRESS_2					0x3a0
+#define SNOOP_TOP_ADDRESS_2					0x3a8
+#define SNOOP_BASE_ADDRESS_3					0x3b0
+#define SNOOP_TOP_ADDRESS_3					0x3b8
+
+/*
+ * CPU Error Report
+ */
+
+#define CPU_ERROR_ADDRESS_LOW					0x070
+#define CPU_ERROR_ADDRESS_HIGH					0x078
+#define CPU_ERROR_DATA_LOW					0x128
+#define CPU_ERROR_DATA_HIGH					0x130
+#define CPU_ERROR_PARITY					0x138
+#define CPU_ERROR_CAUSE						0x140
+#define CPU_ERROR_MASK						0x148
+
+/*
+ * Pslave Debug
+ */
+
+#define X_0_ADDRESS						0x360
+#define X_0_COMMAND_ID						0x368
+#define X_1_ADDRESS						0x370
+#define X_1_COMMAND_ID						0x378
+#define WRITE_DATA_LOW						0x3c0
+#define WRITE_DATA_HIGH						0x3c8
+#define WRITE_BYTE_ENABLE					0X3e0
+#define READ_DATA_LOW						0x3d0
+#define READ_DATA_HIGH						0x3d8
+#define READ_ID							0x3e8
+
+
+/*
+ * SDRAM and Device Address Space
+ */
+
+
+/*
+ * SDRAM Configuration
+ */
+
+#define SDRAM_CONFIGURATION					0x448
+#define SDRAM_OPERATION_MODE					0x474
+#define SDRAM_ADDRESS_DECODE					0x47C
+#define SDRAM_TIMING_PARAMETERS					0x4b4
+#define SDRAM_UMA_CONTROL					0x4a4
+#define SDRAM_CROSS_BAR_CONTROL_LOW				0x4a8
+#define SDRAM_CROSS_BAR_CONTROL_HIGH				0x4ac
+#define SDRAM_CROSS_BAR_TIMEOUT					0x4b0
+
+
+/*
+ * SDRAM Parameters
+ */
+
+#define SDRAM_BANK0PARAMETERS					0x44C
+#define SDRAM_BANK1PARAMETERS					0x450
+#define SDRAM_BANK2PARAMETERS					0x454
+#define SDRAM_BANK3PARAMETERS					0x458
+
+
+/*
+ * SDRAM Error Report
+ */
+
+#define SDRAM_ERROR_DATA_LOW					0x484
+#define SDRAM_ERROR_DATA_HIGH					0x480
+#define SDRAM_AND_DEVICE_ERROR_ADDRESS				0x490
+#define SDRAM_RECEIVED_ECC					0x488
+#define SDRAM_CALCULATED_ECC					0x48c
+#define SDRAM_ECC_CONTROL					0x494
+#define SDRAM_ECC_ERROR_COUNTER					0x498
+
+
+/*
+ * SDunit Debug (for internal use)
+ */
+
+#define X0_ADDRESS						0x500
+#define X0_COMMAND_AND_ID					0x504
+#define X0_WRITE_DATA_LOW					0x508
+#define X0_WRITE_DATA_HIGH					0x50c
+#define X0_WRITE_BYTE_ENABLE					0x518
+#define X0_READ_DATA_LOW					0x510
+#define X0_READ_DATA_HIGH					0x514
+#define X0_READ_ID						0x51c
+#define X1_ADDRESS						0x520
+#define X1_COMMAND_AND_ID					0x524
+#define X1_WRITE_DATA_LOW					0x528
+#define X1_WRITE_DATA_HIGH					0x52c
+#define X1_WRITE_BYTE_ENABLE					0x538
+#define X1_READ_DATA_LOW					0x530
+#define X1_READ_DATA_HIGH					0x534
+#define X1_READ_ID						0x53c
+#define X0_SNOOP_ADDRESS					0x540
+#define X0_SNOOP_COMMAND					0x544
+#define X1_SNOOP_ADDRESS					0x548
+#define X1_SNOOP_COMMAND					0x54c
+
+
+/*
+ * Device Parameters
+ */
+
+#define DEVICE_BANK0PARAMETERS					0x45c
+#define DEVICE_BANK1PARAMETERS					0x460
+#define DEVICE_BANK2PARAMETERS					0x464
+#define DEVICE_BANK3PARAMETERS					0x468
+#define DEVICE_BOOT_BANK_PARAMETERS				0x46c
+#define DEVICE_CONTROL						0x4c0
+#define DEVICE_CROSS_BAR_CONTROL_LOW				0x4c8
+#define DEVICE_CROSS_BAR_CONTROL_HIGH				0x4cc
+#define DEVICE_CROSS_BAR_TIMEOUT				0x4c4
+
+
+/*
+ * Device Interrupt
+ */
+
+#define DEVICE_INTERRUPT_CAUSE					0x4d0
+#define DEVICE_INTERRUPT_MASK					0x4d4
+#define DEVICE_ERROR_ADDRESS					0x4d8
+
+/*
+ * DMA Record
+ */
+
+#define CHANNEL0_DMA_BYTE_COUNT					0x800
+#define CHANNEL1_DMA_BYTE_COUNT					0x804
+#define CHANNEL2_DMA_BYTE_COUNT					0x808
+#define CHANNEL3_DMA_BYTE_COUNT					0x80C
+#define CHANNEL4_DMA_BYTE_COUNT					0x900
+#define CHANNEL5_DMA_BYTE_COUNT					0x904
+#define CHANNEL6_DMA_BYTE_COUNT					0x908
+#define CHANNEL7_DMA_BYTE_COUNT					0x90C
+#define CHANNEL0_DMA_SOURCE_ADDRESS				0x810
+#define CHANNEL1_DMA_SOURCE_ADDRESS				0x814
+#define CHANNEL2_DMA_SOURCE_ADDRESS				0x818
+#define CHANNEL3_DMA_SOURCE_ADDRESS				0x81C
+#define CHANNEL4_DMA_SOURCE_ADDRESS				0x910
+#define CHANNEL5_DMA_SOURCE_ADDRESS				0x914
+#define CHANNEL6_DMA_SOURCE_ADDRESS				0x918
+#define CHANNEL7_DMA_SOURCE_ADDRESS				0x91C
+#define CHANNEL0_DMA_DESTINATION_ADDRESS			0x820
+#define CHANNEL1_DMA_DESTINATION_ADDRESS			0x824
+#define CHANNEL2_DMA_DESTINATION_ADDRESS			0x828
+#define CHANNEL3_DMA_DESTINATION_ADDRESS			0x82C
+#define CHANNEL4_DMA_DESTINATION_ADDRESS			0x920
+#define CHANNEL5_DMA_DESTINATION_ADDRESS			0x924
+#define CHANNEL6_DMA_DESTINATION_ADDRESS			0x928
+#define CHANNEL7_DMA_DESTINATION_ADDRESS			0x92C
+#define CHANNEL0NEXT_RECORD_POINTER				0x830
+#define CHANNEL1NEXT_RECORD_POINTER				0x834
+#define CHANNEL2NEXT_RECORD_POINTER				0x838
+#define CHANNEL3NEXT_RECORD_POINTER				0x83C
+#define CHANNEL4NEXT_RECORD_POINTER				0x930
+#define CHANNEL5NEXT_RECORD_POINTER				0x934
+#define CHANNEL6NEXT_RECORD_POINTER				0x938
+#define CHANNEL7NEXT_RECORD_POINTER				0x93C
+#define CHANNEL0CURRENT_DESCRIPTOR_POINTER			0x870
+#define CHANNEL1CURRENT_DESCRIPTOR_POINTER			0x874
+#define CHANNEL2CURRENT_DESCRIPTOR_POINTER			0x878
+#define CHANNEL3CURRENT_DESCRIPTOR_POINTER			0x87C
+#define CHANNEL4CURRENT_DESCRIPTOR_POINTER			0x970
+#define CHANNEL5CURRENT_DESCRIPTOR_POINTER			0x974
+#define CHANNEL6CURRENT_DESCRIPTOR_POINTER			0x978
+#define CHANNEL7CURRENT_DESCRIPTOR_POINTER			0x97C
+#define CHANNEL0_DMA_SOURCE_HIGH_PCI_ADDRESS			0x890
+#define CHANNEL1_DMA_SOURCE_HIGH_PCI_ADDRESS			0x894
+#define CHANNEL2_DMA_SOURCE_HIGH_PCI_ADDRESS			0x898
+#define CHANNEL3_DMA_SOURCE_HIGH_PCI_ADDRESS			0x89c
+#define CHANNEL4_DMA_SOURCE_HIGH_PCI_ADDRESS			0x990
+#define CHANNEL5_DMA_SOURCE_HIGH_PCI_ADDRESS			0x994
+#define CHANNEL6_DMA_SOURCE_HIGH_PCI_ADDRESS			0x998
+#define CHANNEL7_DMA_SOURCE_HIGH_PCI_ADDRESS			0x99c
+#define CHANNEL0_DMA_DESTINATION_HIGH_PCI_ADDRESS		0x8a0
+#define CHANNEL1_DMA_DESTINATION_HIGH_PCI_ADDRESS		0x8a4
+#define CHANNEL2_DMA_DESTINATION_HIGH_PCI_ADDRESS		0x8a8
+#define CHANNEL3_DMA_DESTINATION_HIGH_PCI_ADDRESS		0x8ac
+#define CHANNEL4_DMA_DESTINATION_HIGH_PCI_ADDRESS		0x9a0
+#define CHANNEL5_DMA_DESTINATION_HIGH_PCI_ADDRESS		0x9a4
+#define CHANNEL6_DMA_DESTINATION_HIGH_PCI_ADDRESS		0x9a8
+#define CHANNEL7_DMA_DESTINATION_HIGH_PCI_ADDRESS		0x9ac
+#define CHANNEL0_DMA_NEXT_RECORD_POINTER_HIGH_PCI_ADDRESS	0x8b0
+#define CHANNEL1_DMA_NEXT_RECORD_POINTER_HIGH_PCI_ADDRESS	0x8b4
+#define CHANNEL2_DMA_NEXT_RECORD_POINTER_HIGH_PCI_ADDRESS	0x8b8
+#define CHANNEL3_DMA_NEXT_RECORD_POINTER_HIGH_PCI_ADDRESS	0x8bc
+#define CHANNEL4_DMA_NEXT_RECORD_POINTER_HIGH_PCI_ADDRESS	0x9b0
+#define CHANNEL5_DMA_NEXT_RECORD_POINTER_HIGH_PCI_ADDRESS	0x9b4
+#define CHANNEL6_DMA_NEXT_RECORD_POINTER_HIGH_PCI_ADDRESS	0x9b8
+#define CHANNEL7_DMA_NEXT_RECORD_POINTER_HIGH_PCI_ADDRESS	0x9bc
+
+/*
+ * DMA Channel Control
+ */
+
+#define CHANNEL0CONTROL						0x840
+#define CHANNEL0CONTROL_HIGH					0x880
+
+#define CHANNEL1CONTROL						0x844
+#define CHANNEL1CONTROL_HIGH					0x884
+
+#define CHANNEL2CONTROL						0x848
+#define CHANNEL2CONTROL_HIGH					0x888
+
+#define CHANNEL3CONTROL						0x84C
+#define CHANNEL3CONTROL_HIGH					0x88C
+
+#define CHANNEL4CONTROL						0x940
+#define CHANNEL4CONTROL_HIGH					0x980
+
+#define CHANNEL5CONTROL						0x944
+#define CHANNEL5CONTROL_HIGH					0x984
+
+#define CHANNEL6CONTROL						0x948
+#define CHANNEL6CONTROL_HIGH					0x988
+
+#define CHANNEL7CONTROL						0x94C
+#define CHANNEL7CONTROL_HIGH					0x98C
+
+
+/*
+ * DMA Arbiter
+ */
+
+#define ARBITER_CONTROL_0_3					0x860
+#define ARBITER_CONTROL_4_7					0x960
+
+
+/*
+ * DMA Interrupt
+ */
+
+#define CHANELS0_3_INTERRUPT_CAUSE				0x8c0
+#define CHANELS0_3_INTERRUPT_MASK				0x8c4
+#define CHANELS0_3_ERROR_ADDRESS				0x8c8
+#define CHANELS0_3_ERROR_SELECT					0x8cc
+#define CHANELS4_7_INTERRUPT_CAUSE				0x9c0
+#define CHANELS4_7_INTERRUPT_MASK				0x9c4
+#define CHANELS4_7_ERROR_ADDRESS				0x9c8
+#define CHANELS4_7_ERROR_SELECT					0x9cc
+
+
+/*
+ * DMA Debug (for internal use)
+ */
+
+#define DMA_X0_ADDRESS						0x8e0
+#define DMA_X0_COMMAND_AND_ID					0x8e4
+#define DMA_X0_WRITE_DATA_LOW					0x8e8
+#define DMA_X0_WRITE_DATA_HIGH					0x8ec
+#define DMA_X0_WRITE_BYTE_ENABLE				0x8f8
+#define DMA_X0_READ_DATA_LOW					0x8f0
+#define DMA_X0_READ_DATA_HIGH					0x8f4
+#define DMA_X0_READ_ID						0x8fc
+#define DMA_X1_ADDRESS						0x9e0
+#define DMA_X1_COMMAND_AND_ID					0x9e4
+#define DMA_X1_WRITE_DATA_LOW					0x9e8
+#define DMA_X1_WRITE_DATA_HIGH					0x9ec
+#define DMA_X1_WRITE_BYTE_ENABLE				0x9f8
+#define DMA_X1_READ_DATA_LOW					0x9f0
+#define DMA_X1_READ_DATA_HIGH					0x9f4
+#define DMA_X1_READ_ID						0x9fc
+
+/*
+ * Timer_Counter
+ */
+
+#define TIMER_COUNTER0						0x850
+#define TIMER_COUNTER1						0x854
+#define TIMER_COUNTER2						0x858
+#define TIMER_COUNTER3						0x85C
+#define TIMER_COUNTER_0_3_CONTROL				0x864
+#define TIMER_COUNTER_0_3_INTERRUPT_CAUSE			0x868
+#define TIMER_COUNTER_0_3_INTERRUPT_MASK			0x86c
+#define TIMER_COUNTER4						0x950
+#define TIMER_COUNTER5						0x954
+#define TIMER_COUNTER6						0x958
+#define TIMER_COUNTER7						0x95C
+#define TIMER_COUNTER_4_7_CONTROL				0x964
+#define TIMER_COUNTER_4_7_INTERRUPT_CAUSE			0x968
+#define TIMER_COUNTER_4_7_INTERRUPT_MASK			0x96c
+
+/*
+ * PCI Slave Address Decoding
+ */
+
+#define PCI_0SCS_0_BANK_SIZE					0xc08
+#define PCI_1SCS_0_BANK_SIZE					0xc88
+#define PCI_0SCS_1_BANK_SIZE					0xd08
+#define PCI_1SCS_1_BANK_SIZE					0xd88
+#define PCI_0SCS_2_BANK_SIZE					0xc0c
+#define PCI_1SCS_2_BANK_SIZE					0xc8c
+#define PCI_0SCS_3_BANK_SIZE					0xd0c
+#define PCI_1SCS_3_BANK_SIZE					0xd8c
+#define PCI_0CS_0_BANK_SIZE					0xc10
+#define PCI_1CS_0_BANK_SIZE					0xc90
+#define PCI_0CS_1_BANK_SIZE					0xd10
+#define PCI_1CS_1_BANK_SIZE					0xd90
+#define PCI_0CS_2_BANK_SIZE					0xd18
+#define PCI_1CS_2_BANK_SIZE					0xd98
+#define PCI_0CS_3_BANK_SIZE					0xc14
+#define PCI_1CS_3_BANK_SIZE					0xc94
+#define PCI_0CS_BOOT_BANK_SIZE					0xd14
+#define PCI_1CS_BOOT_BANK_SIZE					0xd94
+#define PCI_0P2P_MEM0_BAR_SIZE					0xd1c
+#define PCI_1P2P_MEM0_BAR_SIZE					0xd9c
+#define PCI_0P2P_MEM1_BAR_SIZE					0xd20
+#define PCI_1P2P_MEM1_BAR_SIZE					0xda0
+#define PCI_0P2P_I_O_BAR_SIZE					0xd24
+#define PCI_1P2P_I_O_BAR_SIZE					0xda4
+#define PCI_0CPU_BAR_SIZE					0xd28
+#define PCI_1CPU_BAR_SIZE					0xda8
+#define PCI_0DAC_SCS_0_BANK_SIZE				0xe00
+#define PCI_1DAC_SCS_0_BANK_SIZE				0xe80
+#define PCI_0DAC_SCS_1_BANK_SIZE				0xe04
+#define PCI_1DAC_SCS_1_BANK_SIZE				0xe84
+#define PCI_0DAC_SCS_2_BANK_SIZE				0xe08
+#define PCI_1DAC_SCS_2_BANK_SIZE				0xe88
+#define PCI_0DAC_SCS_3_BANK_SIZE				0xe0c
+#define PCI_1DAC_SCS_3_BANK_SIZE				0xe8c
+#define PCI_0DAC_CS_0_BANK_SIZE					0xe10
+#define PCI_1DAC_CS_0_BANK_SIZE					0xe90
+#define PCI_0DAC_CS_1_BANK_SIZE					0xe14
+#define PCI_1DAC_CS_1_BANK_SIZE					0xe94
+#define PCI_0DAC_CS_2_BANK_SIZE					0xe18
+#define PCI_1DAC_CS_2_BANK_SIZE					0xe98
+#define PCI_0DAC_CS_3_BANK_SIZE					0xe1c
+#define PCI_1DAC_CS_3_BANK_SIZE					0xe9c
+#define PCI_0DAC_BOOTCS_BANK_SIZE				0xe20
+#define PCI_1DAC_BOOTCS_BANK_SIZE				0xea0
+#define PCI_0DAC_P2P_MEM0_BAR_SIZE				0xe24
+#define PCI_1DAC_P2P_MEM0_BAR_SIZE				0xea4
+#define PCI_0DAC_P2P_MEM1_BAR_SIZE				0xe28
+#define PCI_1DAC_P2P_MEM1_BAR_SIZE				0xea8
+#define PCI_0DAC_CPU_BAR_SIZE					0xe2c
+#define PCI_1DAC_CPU_BAR_SIZE					0xeac
+#define PCI_0EXPANSION_ROM_BAR_SIZE				0xd2c
+#define PCI_1EXPANSION_ROM_BAR_SIZE				0xdac
+#define PCI_0BASE_ADDRESS_REGISTERS_ENABLE			0xc3c
+#define PCI_1BASE_ADDRESS_REGISTERS_ENABLE			0xcbc
+#define PCI_0SCS_0_BASE_ADDRESS_REMAP				0xc48
+#define PCI_1SCS_0_BASE_ADDRESS_REMAP				0xcc8
+#define PCI_0SCS_1_BASE_ADDRESS_REMAP				0xd48
+#define PCI_1SCS_1_BASE_ADDRESS_REMAP				0xdc8
+#define PCI_0SCS_2_BASE_ADDRESS_REMAP				0xc4c
+#define PCI_1SCS_2_BASE_ADDRESS_REMAP				0xccc
+#define PCI_0SCS_3_BASE_ADDRESS_REMAP				0xd4c
+#define PCI_1SCS_3_BASE_ADDRESS_REMAP				0xdcc
+#define PCI_0CS_0_BASE_ADDRESS_REMAP				0xc50
+#define PCI_1CS_0_BASE_ADDRESS_REMAP				0xcd0
+#define PCI_0CS_1_BASE_ADDRESS_REMAP				0xd50
+#define PCI_1CS_1_BASE_ADDRESS_REMAP				0xdd0
+#define PCI_0CS_2_BASE_ADDRESS_REMAP				0xd58
+#define PCI_1CS_2_BASE_ADDRESS_REMAP				0xdd8
+#define PCI_0CS_3_BASE_ADDRESS_REMAP				0xc54
+#define PCI_1CS_3_BASE_ADDRESS_REMAP				0xcd4
+#define PCI_0CS_BOOTCS_BASE_ADDRESS_REMAP			0xd54
+#define PCI_1CS_BOOTCS_BASE_ADDRESS_REMAP			0xdd4
+#define PCI_0P2P_MEM0_BASE_ADDRESS_REMAP_LOW			0xd5c
+#define PCI_1P2P_MEM0_BASE_ADDRESS_REMAP_LOW			0xddc
+#define PCI_0P2P_MEM0_BASE_ADDRESS_REMAP_HIGH			0xd60
+#define PCI_1P2P_MEM0_BASE_ADDRESS_REMAP_HIGH			0xde0
+#define PCI_0P2P_MEM1_BASE_ADDRESS_REMAP_LOW			0xd64
+#define PCI_1P2P_MEM1_BASE_ADDRESS_REMAP_LOW			0xde4
+#define PCI_0P2P_MEM1_BASE_ADDRESS_REMAP_HIGH			0xd68
+#define PCI_1P2P_MEM1_BASE_ADDRESS_REMAP_HIGH			0xde8
+#define PCI_0P2P_I_O_BASE_ADDRESS_REMAP				0xd6c
+#define PCI_1P2P_I_O_BASE_ADDRESS_REMAP				0xdec
+#define PCI_0CPU_BASE_ADDRESS_REMAP				0xd70
+#define PCI_1CPU_BASE_ADDRESS_REMAP				0xdf0
+#define PCI_0DAC_SCS_0_BASE_ADDRESS_REMAP			0xf00
+#define PCI_1DAC_SCS_0_BASE_ADDRESS_REMAP			0xff0
+#define PCI_0DAC_SCS_1_BASE_ADDRESS_REMAP			0xf04
+#define PCI_1DAC_SCS_1_BASE_ADDRESS_REMAP			0xf84
+#define PCI_0DAC_SCS_2_BASE_ADDRESS_REMAP			0xf08
+#define PCI_1DAC_SCS_2_BASE_ADDRESS_REMAP			0xf88
+#define PCI_0DAC_SCS_3_BASE_ADDRESS_REMAP			0xf0c
+#define PCI_1DAC_SCS_3_BASE_ADDRESS_REMAP			0xf8c
+#define PCI_0DAC_CS_0_BASE_ADDRESS_REMAP			0xf10
+#define PCI_1DAC_CS_0_BASE_ADDRESS_REMAP			0xf90
+#define PCI_0DAC_CS_1_BASE_ADDRESS_REMAP			0xf14
+#define PCI_1DAC_CS_1_BASE_ADDRESS_REMAP			0xf94
+#define PCI_0DAC_CS_2_BASE_ADDRESS_REMAP			0xf18
+#define PCI_1DAC_CS_2_BASE_ADDRESS_REMAP			0xf98
+#define PCI_0DAC_CS_3_BASE_ADDRESS_REMAP			0xf1c
+#define PCI_1DAC_CS_3_BASE_ADDRESS_REMAP			0xf9c
+#define PCI_0DAC_BOOTCS_BASE_ADDRESS_REMAP			0xf20
+#define PCI_1DAC_BOOTCS_BASE_ADDRESS_REMAP			0xfa0
+#define PCI_0DAC_P2P_MEM0_BASE_ADDRESS_REMAP_LOW		0xf24
+#define PCI_1DAC_P2P_MEM0_BASE_ADDRESS_REMAP_LOW		0xfa4
+#define PCI_0DAC_P2P_MEM0_BASE_ADDRESS_REMAP_HIGH		0xf28
+#define PCI_1DAC_P2P_MEM0_BASE_ADDRESS_REMAP_HIGH		0xfa8
+#define PCI_0DAC_P2P_MEM1_BASE_ADDRESS_REMAP_LOW		0xf2c
+#define PCI_1DAC_P2P_MEM1_BASE_ADDRESS_REMAP_LOW		0xfac
+#define PCI_0DAC_P2P_MEM1_BASE_ADDRESS_REMAP_HIGH		0xf30
+#define PCI_1DAC_P2P_MEM1_BASE_ADDRESS_REMAP_HIGH		0xfb0
+#define PCI_0DAC_CPU_BASE_ADDRESS_REMAP				0xf34
+#define PCI_1DAC_CPU_BASE_ADDRESS_REMAP				0xfb4
+#define PCI_0EXPANSION_ROM_BASE_ADDRESS_REMAP			0xf38
+#define PCI_1EXPANSION_ROM_BASE_ADDRESS_REMAP			0xfb8
+#define PCI_0ADDRESS_DECODE_CONTROL				0xd3c
+#define PCI_1ADDRESS_DECODE_CONTROL				0xdbc
+
+/*
+ * PCI Control
+ */
+
+#define PCI_0COMMAND						0xc00
+#define PCI_1COMMAND						0xc80
+#define PCI_0MODE						0xd00
+#define PCI_1MODE						0xd80
+#define PCI_0TIMEOUT_RETRY					0xc04
+#define PCI_1TIMEOUT_RETRY					0xc84
+#define PCI_0READ_BUFFER_DISCARD_TIMER				0xd04
+#define PCI_1READ_BUFFER_DISCARD_TIMER				0xd84
+#define MSI_0TRIGGER_TIMER					0xc38
+#define MSI_1TRIGGER_TIMER					0xcb8
+#define PCI_0ARBITER_CONTROL					0x1d00
+#define PCI_1ARBITER_CONTROL					0x1d80
+/* changing untill here */
+#define PCI_0CROSS_BAR_CONTROL_LOW				 0x1d08
+#define PCI_0CROSS_BAR_CONTROL_HIGH				 0x1d0c
+#define PCI_0CROSS_BAR_TIMEOUT					 0x1d04
+#define PCI_0READ_RESPONSE_CROSS_BAR_CONTROL_LOW		 0x1d18
+#define PCI_0READ_RESPONSE_CROSS_BAR_CONTROL_HIGH		 0x1d1c
+#define PCI_0SYNC_BARRIER_VIRTUAL_REGISTER			 0x1d10
+#define PCI_0P2P_CONFIGURATION					 0x1d14
+#define PCI_0ACCESS_CONTROL_BASE_0_LOW				 0x1e00
+#define PCI_0ACCESS_CONTROL_BASE_0_HIGH				 0x1e04
+#define PCI_0ACCESS_CONTROL_TOP_0				 0x1e08
+#define PCI_0ACCESS_CONTROL_BASE_1_LOW				 0c1e10
+#define PCI_0ACCESS_CONTROL_BASE_1_HIGH				 0x1e14
+#define PCI_0ACCESS_CONTROL_TOP_1				 0x1e18
+#define PCI_0ACCESS_CONTROL_BASE_2_LOW				 0c1e20
+#define PCI_0ACCESS_CONTROL_BASE_2_HIGH				 0x1e24
+#define PCI_0ACCESS_CONTROL_TOP_2				 0x1e28
+#define PCI_0ACCESS_CONTROL_BASE_3_LOW				 0c1e30
+#define PCI_0ACCESS_CONTROL_BASE_3_HIGH				 0x1e34
+#define PCI_0ACCESS_CONTROL_TOP_3				 0x1e38
+#define PCI_0ACCESS_CONTROL_BASE_4_LOW				 0c1e40
+#define PCI_0ACCESS_CONTROL_BASE_4_HIGH				 0x1e44
+#define PCI_0ACCESS_CONTROL_TOP_4				 0x1e48
+#define PCI_0ACCESS_CONTROL_BASE_5_LOW				 0c1e50
+#define PCI_0ACCESS_CONTROL_BASE_5_HIGH				 0x1e54
+#define PCI_0ACCESS_CONTROL_TOP_5				 0x1e58
+#define PCI_0ACCESS_CONTROL_BASE_6_LOW				 0c1e60
+#define PCI_0ACCESS_CONTROL_BASE_6_HIGH				 0x1e64
+#define PCI_0ACCESS_CONTROL_TOP_6				 0x1e68
+#define PCI_0ACCESS_CONTROL_BASE_7_LOW				 0c1e70
+#define PCI_0ACCESS_CONTROL_BASE_7_HIGH				 0x1e74
+#define PCI_0ACCESS_CONTROL_TOP_7				 0x1e78
+#define PCI_1CROSS_BAR_CONTROL_LOW				 0x1d88
+#define PCI_1CROSS_BAR_CONTROL_HIGH				 0x1d8c
+#define PCI_1CROSS_BAR_TIMEOUT					 0x1d84
+#define PCI_1READ_RESPONSE_CROSS_BAR_CONTROL_LOW		 0x1d98
+#define PCI_1READ_RESPONSE_CROSS_BAR_CONTROL_HIGH		 0x1d9c
+#define PCI_1SYNC_BARRIER_VIRTUAL_REGISTER			 0x1d90
+#define PCI_1P2P_CONFIGURATION					 0x1d94
+#define PCI_1ACCESS_CONTROL_BASE_0_LOW				 0x1e80
+#define PCI_1ACCESS_CONTROL_BASE_0_HIGH				 0x1e84
+#define PCI_1ACCESS_CONTROL_TOP_0				 0x1e88
+#define PCI_1ACCESS_CONTROL_BASE_1_LOW				 0c1e90
+#define PCI_1ACCESS_CONTROL_BASE_1_HIGH				 0x1e94
+#define PCI_1ACCESS_CONTROL_TOP_1				 0x1e98
+#define PCI_1ACCESS_CONTROL_BASE_2_LOW				 0c1ea0
+#define PCI_1ACCESS_CONTROL_BASE_2_HIGH				 0x1ea4
+#define PCI_1ACCESS_CONTROL_TOP_2				 0x1ea8
+#define PCI_1ACCESS_CONTROL_BASE_3_LOW				 0c1eb0
+#define PCI_1ACCESS_CONTROL_BASE_3_HIGH				 0x1eb4
+#define PCI_1ACCESS_CONTROL_TOP_3				 0x1eb8
+#define PCI_1ACCESS_CONTROL_BASE_4_LOW				 0c1ec0
+#define PCI_1ACCESS_CONTROL_BASE_4_HIGH				 0x1ec4
+#define PCI_1ACCESS_CONTROL_TOP_4				 0x1ec8
+#define PCI_1ACCESS_CONTROL_BASE_5_LOW				 0c1ed0
+#define PCI_1ACCESS_CONTROL_BASE_5_HIGH				 0x1ed4
+#define PCI_1ACCESS_CONTROL_TOP_5				 0x1ed8
+#define PCI_1ACCESS_CONTROL_BASE_6_LOW				 0c1ee0
+#define PCI_1ACCESS_CONTROL_BASE_6_HIGH				 0x1ee4
+#define PCI_1ACCESS_CONTROL_TOP_6				 0x1ee8
+#define PCI_1ACCESS_CONTROL_BASE_7_LOW				 0c1ef0
+#define PCI_1ACCESS_CONTROL_BASE_7_HIGH				 0x1ef4
+#define PCI_1ACCESS_CONTROL_TOP_7				 0x1ef8
+
+/*
+ * PCI Snoop Control
+ */
+
+#define PCI_0SNOOP_CONTROL_BASE_0_LOW				 0x1f00
+#define PCI_0SNOOP_CONTROL_BASE_0_HIGH				 0x1f04
+#define PCI_0SNOOP_CONTROL_TOP_0				 0x1f08
+#define PCI_0SNOOP_CONTROL_BASE_1_0_LOW				 0x1f10
+#define PCI_0SNOOP_CONTROL_BASE_1_0_HIGH			 0x1f14
+#define PCI_0SNOOP_CONTROL_TOP_1				 0x1f18
+#define PCI_0SNOOP_CONTROL_BASE_2_0_LOW				 0x1f20
+#define PCI_0SNOOP_CONTROL_BASE_2_0_HIGH			 0x1f24
+#define PCI_0SNOOP_CONTROL_TOP_2				 0x1f28
+#define PCI_0SNOOP_CONTROL_BASE_3_0_LOW				 0x1f30
+#define PCI_0SNOOP_CONTROL_BASE_3_0_HIGH			 0x1f34
+#define PCI_0SNOOP_CONTROL_TOP_3				 0x1f38
+#define PCI_1SNOOP_CONTROL_BASE_0_LOW				 0x1f80
+#define PCI_1SNOOP_CONTROL_BASE_0_HIGH				 0x1f84
+#define PCI_1SNOOP_CONTROL_TOP_0				 0x1f88
+#define PCI_1SNOOP_CONTROL_BASE_1_0_LOW				 0x1f90
+#define PCI_1SNOOP_CONTROL_BASE_1_0_HIGH			 0x1f94
+#define PCI_1SNOOP_CONTROL_TOP_1				 0x1f98
+#define PCI_1SNOOP_CONTROL_BASE_2_0_LOW				 0x1fa0
+#define PCI_1SNOOP_CONTROL_BASE_2_0_HIGH			 0x1fa4
+#define PCI_1SNOOP_CONTROL_TOP_2				 0x1fa8
+#define PCI_1SNOOP_CONTROL_BASE_3_0_LOW				 0x1fb0
+#define PCI_1SNOOP_CONTROL_BASE_3_0_HIGH			 0x1fb4
+#define PCI_1SNOOP_CONTROL_TOP_3				 0x1fb8
+
+/*
+ * PCI Configuration Address
+ */
+
+#define PCI_0CONFIGURATION_ADDRESS				0xcf8
+#define PCI_0CONFIGURATION_DATA_VIRTUAL_REGISTER		0xcfc
+#define PCI_1CONFIGURATION_ADDRESS				0xc78
+#define PCI_1CONFIGURATION_DATA_VIRTUAL_REGISTER		0xc7c
+#define PCI_0INTERRUPT_ACKNOWLEDGE_VIRTUAL_REGISTER		0xc34
+#define PCI_1INTERRUPT_ACKNOWLEDGE_VIRTUAL_REGISTER		0xcb4
+
+/*
+ * PCI Error Report
+ */
+
+#define PCI_0SERR_MASK						 0xc28
+#define PCI_0ERROR_ADDRESS_LOW					 0x1d40
+#define PCI_0ERROR_ADDRESS_HIGH					 0x1d44
+#define PCI_0ERROR_DATA_LOW					 0x1d48
+#define PCI_0ERROR_DATA_HIGH					 0x1d4c
+#define PCI_0ERROR_COMMAND					 0x1d50
+#define PCI_0ERROR_CAUSE					 0x1d58
+#define PCI_0ERROR_MASK						 0x1d5c
+
+#define PCI_1SERR_MASK						 0xca8
+#define PCI_1ERROR_ADDRESS_LOW					 0x1dc0
+#define PCI_1ERROR_ADDRESS_HIGH					 0x1dc4
+#define PCI_1ERROR_DATA_LOW					 0x1dc8
+#define PCI_1ERROR_DATA_HIGH					 0x1dcc
+#define PCI_1ERROR_COMMAND					 0x1dd0
+#define PCI_1ERROR_CAUSE					 0x1dd8
+#define PCI_1ERROR_MASK						 0x1ddc
+
+
+/*
+ * Lslave Debug	 (for internal use)
+ */
+
+#define L_SLAVE_X0_ADDRESS					0x1d20
+#define L_SLAVE_X0_COMMAND_AND_ID				0x1d24
+#define L_SLAVE_X1_ADDRESS					0x1d28
+#define L_SLAVE_X1_COMMAND_AND_ID				0x1d2c
+#define L_SLAVE_WRITE_DATA_LOW					0x1d30
+#define L_SLAVE_WRITE_DATA_HIGH					0x1d34
+#define L_SLAVE_WRITE_BYTE_ENABLE				0x1d60
+#define L_SLAVE_READ_DATA_LOW					0x1d38
+#define L_SLAVE_READ_DATA_HIGH					0x1d3c
+#define L_SLAVE_READ_ID						0x1d64
+
+#if 0 /* Disabled because PCI_* namespace belongs to PCI subsystem ... */
+
+/*
+ * PCI Configuration Function 0
+ */
+
+#define PCI_DEVICE_AND_VENDOR_ID				0x000
+#define PCI_STATUS_AND_COMMAND					0x004
+#define PCI_CLASS_CODE_AND_REVISION_ID				0x008
+#define PCI_BIST_HEADER_TYPE_LATENCY_TIMER_CACHE_LINE		0x00C
+#define PCI_SCS_0_BASE_ADDRESS					0x010
+#define PCI_SCS_1_BASE_ADDRESS					0x014
+#define PCI_SCS_2_BASE_ADDRESS					0x018
+#define PCI_SCS_3_BASE_ADDRESS					0x01C
+#define PCI_INTERNAL_REGISTERS_MEMORY_MAPPED_BASE_ADDRESS	0x020
+#define PCI_INTERNAL_REGISTERS_I_OMAPPED_BASE_ADDRESS		0x024
+#define PCI_SUBSYSTEM_ID_AND_SUBSYSTEM_VENDOR_ID		0x02C
+#define PCI_EXPANSION_ROM_BASE_ADDRESS_REGISTER			0x030
+#define PCI_CAPABILTY_LIST_POINTER				0x034
+#define PCI_INTERRUPT_PIN_AND_LINE				0x03C
+#define PCI_POWER_MANAGEMENT_CAPABILITY				0x040
+#define PCI_POWER_MANAGEMENT_STATUS_AND_CONTROL			0x044
+#define PCI_VPD_ADDRESS						0x048
+#define PCI_VPD_DATA						0X04c
+#define PCI_MSI_MESSAGE_CONTROL					0x050
+#define PCI_MSI_MESSAGE_ADDRESS					0x054
+#define PCI_MSI_MESSAGE_UPPER_ADDRESS				0x058
+#define PCI_MSI_MESSAGE_DATA					0x05c
+#define PCI_COMPACT_PCI_HOT_SWAP_CAPABILITY			0x058
+
+/*
+ * PCI Configuration Function 1
+ */
+
+#define PCI_CS_0_BASE_ADDRESS					0x110
+#define PCI_CS_1_BASE_ADDRESS					0x114
+#define PCI_CS_2_BASE_ADDRESS					0x118
+#define PCI_CS_3_BASE_ADDRESS					0x11c
+#define PCI_BOOTCS_BASE_ADDRESS					0x120
+
+/*
+ * PCI Configuration Function 2
+ */
+
+#define PCI_P2P_MEM0_BASE_ADDRESS				0x210
+#define PCI_P2P_MEM1_BASE_ADDRESS				0x214
+#define PCI_P2P_I_O_BASE_ADDRESS				0x218
+#define PCI_CPU_BASE_ADDRESS					0x21c
+
+/*
+ * PCI Configuration Function 4
+ */
+
+#define PCI_DAC_SCS_0_BASE_ADDRESS_LOW				0x410
+#define PCI_DAC_SCS_0_BASE_ADDRESS_HIGH				0x414
+#define PCI_DAC_SCS_1_BASE_ADDRESS_LOW				0x418
+#define PCI_DAC_SCS_1_BASE_ADDRESS_HIGH				0x41c
+#define PCI_DAC_P2P_MEM0_BASE_ADDRESS_LOW			0x420
+#define PCI_DAC_P2P_MEM0_BASE_ADDRESS_HIGH			0x424
+
+
+/*
+ * PCI Configuration Function 5
+ */
+
+#define PCI_DAC_SCS_2_BASE_ADDRESS_LOW				0x510
+#define PCI_DAC_SCS_2_BASE_ADDRESS_HIGH				0x514
+#define PCI_DAC_SCS_3_BASE_ADDRESS_LOW				0x518
+#define PCI_DAC_SCS_3_BASE_ADDRESS_HIGH				0x51c
+#define PCI_DAC_P2P_MEM1_BASE_ADDRESS_LOW			0x520
+#define PCI_DAC_P2P_MEM1_BASE_ADDRESS_HIGH			0x524
+
+
+/*
+ * PCI Configuration Function 6
+ */
+
+#define PCI_DAC_CS_0_BASE_ADDRESS_LOW				0x610
+#define PCI_DAC_CS_0_BASE_ADDRESS_HIGH				0x614
+#define PCI_DAC_CS_1_BASE_ADDRESS_LOW				0x618
+#define PCI_DAC_CS_1_BASE_ADDRESS_HIGH				0x61c
+#define PCI_DAC_CS_2_BASE_ADDRESS_LOW				0x620
+#define PCI_DAC_CS_2_BASE_ADDRESS_HIGH				0x624
+
+/*
+ * PCI Configuration Function 7
+ */
+
+#define PCI_DAC_CS_3_BASE_ADDRESS_LOW				0x710
+#define PCI_DAC_CS_3_BASE_ADDRESS_HIGH				0x714
+#define PCI_DAC_BOOTCS_BASE_ADDRESS_LOW				0x718
+#define PCI_DAC_BOOTCS_BASE_ADDRESS_HIGH			0x71c
+#define PCI_DAC_CPU_BASE_ADDRESS_LOW				0x720
+#define PCI_DAC_CPU_BASE_ADDRESS_HIGH				0x724
+#endif
+
+/*
+ * Interrupts
+ */
+
+#define LOW_INTERRUPT_CAUSE_REGISTER				0xc18
+#define HIGH_INTERRUPT_CAUSE_REGISTER				0xc68
+#define CPU_INTERRUPT_MASK_REGISTER_LOW				0xc1c
+#define CPU_INTERRUPT_MASK_REGISTER_HIGH			0xc6c
+#define CPU_SELECT_CAUSE_REGISTER				0xc70
+#define PCI_0INTERRUPT_CAUSE_MASK_REGISTER_LOW			0xc24
+#define PCI_0INTERRUPT_CAUSE_MASK_REGISTER_HIGH			0xc64
+#define PCI_0SELECT_CAUSE					0xc74
+#define PCI_1INTERRUPT_CAUSE_MASK_REGISTER_LOW			0xca4
+#define PCI_1INTERRUPT_CAUSE_MASK_REGISTER_HIGH			0xce4
+#define PCI_1SELECT_CAUSE					0xcf4
+#define CPU_INT_0_MASK						0xe60
+#define CPU_INT_1_MASK						0xe64
+#define CPU_INT_2_MASK						0xe68
+#define CPU_INT_3_MASK						0xe6c
+
+/*
+ * I20 Support registers
+ */
+
+#define INBOUND_MESSAGE_REGISTER0_PCI0_SIDE			0x010
+#define INBOUND_MESSAGE_REGISTER1_PCI0_SIDE			0x014
+#define OUTBOUND_MESSAGE_REGISTER0_PCI0_SIDE			0x018
+#define OUTBOUND_MESSAGE_REGISTER1_PCI0_SIDE			0x01C
+#define INBOUND_DOORBELL_REGISTER_PCI0_SIDE			0x020
+#define INBOUND_INTERRUPT_CAUSE_REGISTER_PCI0_SIDE		0x024
+#define INBOUND_INTERRUPT_MASK_REGISTER_PCI0_SIDE		0x028
+#define OUTBOUND_DOORBELL_REGISTER_PCI0_SIDE			0x02C
+#define OUTBOUND_INTERRUPT_CAUSE_REGISTER_PCI0_SIDE		0x030
+#define OUTBOUND_INTERRUPT_MASK_REGISTER_PCI0_SIDE		0x034
+#define INBOUND_QUEUE_PORT_VIRTUAL_REGISTER_PCI0_SIDE		0x040
+#define OUTBOUND_QUEUE_PORT_VIRTUAL_REGISTER_PCI0_SIDE		0x044
+#define QUEUE_CONTROL_REGISTER_PCI0_SIDE			0x050
+#define QUEUE_BASE_ADDRESS_REGISTER_PCI0_SIDE			0x054
+#define INBOUND_FREE_HEAD_POINTER_REGISTER_PCI0_SIDE		0x060
+#define INBOUND_FREE_TAIL_POINTER_REGISTER_PCI0_SIDE		0x064
+#define INBOUND_POST_HEAD_POINTER_REGISTER_PCI0_SIDE		0x068
+#define INBOUND_POST_TAIL_POINTER_REGISTER_PCI0_SIDE		0x06C
+#define OUTBOUND_FREE_HEAD_POINTER_REGISTER_PCI0_SIDE		0x070
+#define OUTBOUND_FREE_TAIL_POINTER_REGISTER_PCI0_SIDE		0x074
+#define OUTBOUND_POST_HEAD_POINTER_REGISTER_PCI0_SIDE		0x0F8
+#define OUTBOUND_POST_TAIL_POINTER_REGISTER_PCI0_SIDE		0x0FC
+
+#define INBOUND_MESSAGE_REGISTER0_PCI1_SIDE			0x090
+#define INBOUND_MESSAGE_REGISTER1_PCI1_SIDE			0x094
+#define OUTBOUND_MESSAGE_REGISTER0_PCI1_SIDE			0x098
+#define OUTBOUND_MESSAGE_REGISTER1_PCI1_SIDE			0x09C
+#define INBOUND_DOORBELL_REGISTER_PCI1_SIDE			0x0A0
+#define INBOUND_INTERRUPT_CAUSE_REGISTER_PCI1_SIDE		0x0A4
+#define INBOUND_INTERRUPT_MASK_REGISTER_PCI1_SIDE		0x0A8
+#define OUTBOUND_DOORBELL_REGISTER_PCI1_SIDE			0x0AC
+#define OUTBOUND_INTERRUPT_CAUSE_REGISTER_PCI1_SIDE		0x0B0
+#define OUTBOUND_INTERRUPT_MASK_REGISTER_PCI1_SIDE		0x0B4
+#define INBOUND_QUEUE_PORT_VIRTUAL_REGISTER_PCI1_SIDE		0x0C0
+#define OUTBOUND_QUEUE_PORT_VIRTUAL_REGISTER_PCI1_SIDE		0x0C4
+#define QUEUE_CONTROL_REGISTER_PCI1_SIDE			0x0D0
+#define QUEUE_BASE_ADDRESS_REGISTER_PCI1_SIDE			0x0D4
+#define INBOUND_FREE_HEAD_POINTER_REGISTER_PCI1_SIDE		0x0E0
+#define INBOUND_FREE_TAIL_POINTER_REGISTER_PCI1_SIDE		0x0E4
+#define INBOUND_POST_HEAD_POINTER_REGISTER_PCI1_SIDE		0x0E8
+#define INBOUND_POST_TAIL_POINTER_REGISTER_PCI1_SIDE		0x0EC
+#define OUTBOUND_FREE_HEAD_POINTER_REGISTER_PCI1_SIDE		0x0F0
+#define OUTBOUND_FREE_TAIL_POINTER_REGISTER_PCI1_SIDE		0x0F4
+#define OUTBOUND_POST_HEAD_POINTER_REGISTER_PCI1_SIDE		0x078
+#define OUTBOUND_POST_TAIL_POINTER_REGISTER_PCI1_SIDE		0x07C
+
+#define INBOUND_MESSAGE_REGISTER0_CPU0_SIDE			0X1C10
+#define INBOUND_MESSAGE_REGISTER1_CPU0_SIDE			0X1C14
+#define OUTBOUND_MESSAGE_REGISTER0_CPU0_SIDE			0X1C18
+#define OUTBOUND_MESSAGE_REGISTER1_CPU0_SIDE			0X1C1C
+#define INBOUND_DOORBELL_REGISTER_CPU0_SIDE			0X1C20
+#define INBOUND_INTERRUPT_CAUSE_REGISTER_CPU0_SIDE		0X1C24
+#define INBOUND_INTERRUPT_MASK_REGISTER_CPU0_SIDE		0X1C28
+#define OUTBOUND_DOORBELL_REGISTER_CPU0_SIDE			0X1C2C
+#define OUTBOUND_INTERRUPT_CAUSE_REGISTER_CPU0_SIDE		0X1C30
+#define OUTBOUND_INTERRUPT_MASK_REGISTER_CPU0_SIDE		0X1C34
+#define INBOUND_QUEUE_PORT_VIRTUAL_REGISTER_CPU0_SIDE		0X1C40
+#define OUTBOUND_QUEUE_PORT_VIRTUAL_REGISTER_CPU0_SIDE		0X1C44
+#define QUEUE_CONTROL_REGISTER_CPU0_SIDE			0X1C50
+#define QUEUE_BASE_ADDRESS_REGISTER_CPU0_SIDE			0X1C54
+#define INBOUND_FREE_HEAD_POINTER_REGISTER_CPU0_SIDE		0X1C60
+#define INBOUND_FREE_TAIL_POINTER_REGISTER_CPU0_SIDE		0X1C64
+#define INBOUND_POST_HEAD_POINTER_REGISTER_CPU0_SIDE		0X1C68
+#define INBOUND_POST_TAIL_POINTER_REGISTER_CPU0_SIDE		0X1C6C
+#define OUTBOUND_FREE_HEAD_POINTER_REGISTER_CPU0_SIDE		0X1C70
+#define OUTBOUND_FREE_TAIL_POINTER_REGISTER_CPU0_SIDE		0X1C74
+#define OUTBOUND_POST_HEAD_POINTER_REGISTER_CPU0_SIDE		0X1CF8
+#define OUTBOUND_POST_TAIL_POINTER_REGISTER_CPU0_SIDE		0X1CFC
+
+#define INBOUND_MESSAGE_REGISTER0_CPU1_SIDE			0X1C90
+#define INBOUND_MESSAGE_REGISTER1_CPU1_SIDE			0X1C94
+#define OUTBOUND_MESSAGE_REGISTER0_CPU1_SIDE			0X1C98
+#define OUTBOUND_MESSAGE_REGISTER1_CPU1_SIDE			0X1C9C
+#define INBOUND_DOORBELL_REGISTER_CPU1_SIDE			0X1CA0
+#define INBOUND_INTERRUPT_CAUSE_REGISTER_CPU1_SIDE		0X1CA4
+#define INBOUND_INTERRUPT_MASK_REGISTER_CPU1_SIDE		0X1CA8
+#define OUTBOUND_DOORBELL_REGISTER_CPU1_SIDE			0X1CAC
+#define OUTBOUND_INTERRUPT_CAUSE_REGISTER_CPU1_SIDE		0X1CB0
+#define OUTBOUND_INTERRUPT_MASK_REGISTER_CPU1_SIDE		0X1CB4
+#define INBOUND_QUEUE_PORT_VIRTUAL_REGISTER_CPU1_SIDE		0X1CC0
+#define OUTBOUND_QUEUE_PORT_VIRTUAL_REGISTER_CPU1_SIDE		0X1CC4
+#define QUEUE_CONTROL_REGISTER_CPU1_SIDE			0X1CD0
+#define QUEUE_BASE_ADDRESS_REGISTER_CPU1_SIDE			0X1CD4
+#define INBOUND_FREE_HEAD_POINTER_REGISTER_CPU1_SIDE		0X1CE0
+#define INBOUND_FREE_TAIL_POINTER_REGISTER_CPU1_SIDE		0X1CE4
+#define INBOUND_POST_HEAD_POINTER_REGISTER_CPU1_SIDE		0X1CE8
+#define INBOUND_POST_TAIL_POINTER_REGISTER_CPU1_SIDE		0X1CEC
+#define OUTBOUND_FREE_HEAD_POINTER_REGISTER_CPU1_SIDE		0X1CF0
+#define OUTBOUND_FREE_TAIL_POINTER_REGISTER_CPU1_SIDE		0X1CF4
+#define OUTBOUND_POST_HEAD_POINTER_REGISTER_CPU1_SIDE		0X1C78
+#define OUTBOUND_POST_TAIL_POINTER_REGISTER_CPU1_SIDE		0X1C7C
+
+/*
+ * Communication Unit Registers
+ */
+
+#define ETHERNET_0_ADDRESS_CONTROL_LOW
+#define ETHERNET_0_ADDRESS_CONTROL_HIGH				0xf204
+#define ETHERNET_0_RECEIVE_BUFFER_PCI_HIGH_ADDRESS		0xf208
+#define ETHERNET_0_TRANSMIT_BUFFER_PCI_HIGH_ADDRESS		0xf20c
+#define ETHERNET_0_RECEIVE_DESCRIPTOR_PCI_HIGH_ADDRESS		0xf210
+#define ETHERNET_0_TRANSMIT_DESCRIPTOR_PCI_HIGH_ADDRESS		0xf214
+#define ETHERNET_0_HASH_TABLE_PCI_HIGH_ADDRESS			0xf218
+#define ETHERNET_1_ADDRESS_CONTROL_LOW				0xf220
+#define ETHERNET_1_ADDRESS_CONTROL_HIGH				0xf224
+#define ETHERNET_1_RECEIVE_BUFFER_PCI_HIGH_ADDRESS		0xf228
+#define ETHERNET_1_TRANSMIT_BUFFER_PCI_HIGH_ADDRESS		0xf22c
+#define ETHERNET_1_RECEIVE_DESCRIPTOR_PCI_HIGH_ADDRESS		0xf230
+#define ETHERNET_1_TRANSMIT_DESCRIPTOR_PCI_HIGH_ADDRESS		0xf234
+#define ETHERNET_1_HASH_TABLE_PCI_HIGH_ADDRESS			0xf238
+#define ETHERNET_2_ADDRESS_CONTROL_LOW				0xf240
+#define ETHERNET_2_ADDRESS_CONTROL_HIGH				0xf244
+#define ETHERNET_2_RECEIVE_BUFFER_PCI_HIGH_ADDRESS		0xf248
+#define ETHERNET_2_TRANSMIT_BUFFER_PCI_HIGH_ADDRESS		0xf24c
+#define ETHERNET_2_RECEIVE_DESCRIPTOR_PCI_HIGH_ADDRESS		0xf250
+#define ETHERNET_2_TRANSMIT_DESCRIPTOR_PCI_HIGH_ADDRESS		0xf254
+#define ETHERNET_2_HASH_TABLE_PCI_HIGH_ADDRESS			0xf258
+#define MPSC_0_ADDRESS_CONTROL_LOW				0xf280
+#define MPSC_0_ADDRESS_CONTROL_HIGH				0xf284
+#define MPSC_0_RECEIVE_BUFFER_PCI_HIGH_ADDRESS			0xf288
+#define MPSC_0_TRANSMIT_BUFFER_PCI_HIGH_ADDRESS			0xf28c
+#define MPSC_0_RECEIVE_DESCRIPTOR_PCI_HIGH_ADDRESS		0xf290
+#define MPSC_0_TRANSMIT_DESCRIPTOR_PCI_HIGH_ADDRESS		0xf294
+#define MPSC_1_ADDRESS_CONTROL_LOW				0xf2a0
+#define MPSC_1_ADDRESS_CONTROL_HIGH				0xf2a4
+#define MPSC_1_RECEIVE_BUFFER_PCI_HIGH_ADDRESS			0xf2a8
+#define MPSC_1_TRANSMIT_BUFFER_PCI_HIGH_ADDRESS			0xf2ac
+#define MPSC_1_RECEIVE_DESCRIPTOR_PCI_HIGH_ADDRESS		0xf2b0
+#define MPSC_1_TRANSMIT_DESCRIPTOR_PCI_HIGH_ADDRESS		0xf2b4
+#define MPSC_2_ADDRESS_CONTROL_LOW				0xf2c0
+#define MPSC_2_ADDRESS_CONTROL_HIGH				0xf2c4
+#define MPSC_2_RECEIVE_BUFFER_PCI_HIGH_ADDRESS			0xf2c8
+#define MPSC_2_TRANSMIT_BUFFER_PCI_HIGH_ADDRESS			0xf2cc
+#define MPSC_2_RECEIVE_DESCRIPTOR_PCI_HIGH_ADDRESS		0xf2d0
+#define MPSC_2_TRANSMIT_DESCRIPTOR_PCI_HIGH_ADDRESS		0xf2d4
+#define SERIAL_INIT_PCI_HIGH_ADDRESS				0xf320
+#define SERIAL_INIT_LAST_DATA					0xf324
+#define SERIAL_INIT_STATUS_AND_CONTROL				0xf328
+#define COMM_UNIT_ARBITER_CONTROL				0xf300
+#define COMM_UNIT_CROSS_BAR_TIMEOUT				0xf304
+#define COMM_UNIT_INTERRUPT_CAUSE				0xf310
+#define COMM_UNIT_INTERRUPT_MASK				0xf314
+#define COMM_UNIT_ERROR_ADDRESS					0xf314
+
+/*
+ * Cunit Debug	(for internal use)
+ */
+
+#define CUNIT_ADDRESS						0xf340
+#define CUNIT_COMMAND_AND_ID					0xf344
+#define CUNIT_WRITE_DATA_LOW					0xf348
+#define CUNIT_WRITE_DATA_HIGH					0xf34c
+#define CUNIT_WRITE_BYTE_ENABLE					0xf358
+#define CUNIT_READ_DATA_LOW					0xf350
+#define CUNIT_READ_DATA_HIGH					0xf354
+#define CUNIT_READ_ID						0xf35c
+
+/*
+ * Fast Ethernet Unit Registers
+ */
+
+/* Ethernet */
+
+#define ETHERNET_PHY_ADDRESS_REGISTER				0x2000
+#define ETHERNET_SMI_REGISTER					0x2010
+
+/* Ethernet 0 */
+
+#define ETHERNET0_PORT_CONFIGURATION_REGISTER			0x2400
+#define ETHERNET0_PORT_CONFIGURATION_EXTEND_REGISTER		0x2408
+#define ETHERNET0_PORT_COMMAND_REGISTER				0x2410
+#define ETHERNET0_PORT_STATUS_REGISTER				0x2418
+#define ETHERNET0_SERIAL_PARAMETRS_REGISTER			0x2420
+#define ETHERNET0_HASH_TABLE_POINTER_REGISTER			0x2428
+#define ETHERNET0_FLOW_CONTROL_SOURCE_ADDRESS_LOW		0x2430
+#define ETHERNET0_FLOW_CONTROL_SOURCE_ADDRESS_HIGH		0x2438
+#define ETHERNET0_SDMA_CONFIGURATION_REGISTER			0x2440
+#define ETHERNET0_SDMA_COMMAND_REGISTER				0x2448
+#define ETHERNET0_INTERRUPT_CAUSE_REGISTER			0x2450
+#define ETHERNET0_INTERRUPT_MASK_REGISTER			0x2458
+#define ETHERNET0_FIRST_RX_DESCRIPTOR_POINTER0			0x2480
+#define ETHERNET0_FIRST_RX_DESCRIPTOR_POINTER1			0x2484
+#define ETHERNET0_FIRST_RX_DESCRIPTOR_POINTER2			0x2488
+#define ETHERNET0_FIRST_RX_DESCRIPTOR_POINTER3			0x248c
+#define ETHERNET0_CURRENT_RX_DESCRIPTOR_POINTER0		0x24a0
+#define ETHERNET0_CURRENT_RX_DESCRIPTOR_POINTER1		0x24a4
+#define ETHERNET0_CURRENT_RX_DESCRIPTOR_POINTER2		0x24a8
+#define ETHERNET0_CURRENT_RX_DESCRIPTOR_POINTER3		0x24ac
+#define ETHERNET0_CURRENT_TX_DESCRIPTOR_POINTER0		0x24e0
+#define ETHERNET0_CURRENT_TX_DESCRIPTOR_POINTER1		0x24e4
+#define ETHERNET0_MIB_COUNTER_BASE				0x2500
+
+/* Ethernet 1 */
+
+#define ETHERNET1_PORT_CONFIGURATION_REGISTER			0x2800
+#define ETHERNET1_PORT_CONFIGURATION_EXTEND_REGISTER		0x2808
+#define ETHERNET1_PORT_COMMAND_REGISTER				0x2810
+#define ETHERNET1_PORT_STATUS_REGISTER				0x2818
+#define ETHERNET1_SERIAL_PARAMETRS_REGISTER			0x2820
+#define ETHERNET1_HASH_TABLE_POINTER_REGISTER			0x2828
+#define ETHERNET1_FLOW_CONTROL_SOURCE_ADDRESS_LOW		0x2830
+#define ETHERNET1_FLOW_CONTROL_SOURCE_ADDRESS_HIGH		0x2838
+#define ETHERNET1_SDMA_CONFIGURATION_REGISTER			0x2840
+#define ETHERNET1_SDMA_COMMAND_REGISTER				0x2848
+#define ETHERNET1_INTERRUPT_CAUSE_REGISTER			0x2850
+#define ETHERNET1_INTERRUPT_MASK_REGISTER			0x2858
+#define ETHERNET1_FIRST_RX_DESCRIPTOR_POINTER0			0x2880
+#define ETHERNET1_FIRST_RX_DESCRIPTOR_POINTER1			0x2884
+#define ETHERNET1_FIRST_RX_DESCRIPTOR_POINTER2			0x2888
+#define ETHERNET1_FIRST_RX_DESCRIPTOR_POINTER3			0x288c
+#define ETHERNET1_CURRENT_RX_DESCRIPTOR_POINTER0		0x28a0
+#define ETHERNET1_CURRENT_RX_DESCRIPTOR_POINTER1		0x28a4
+#define ETHERNET1_CURRENT_RX_DESCRIPTOR_POINTER2		0x28a8
+#define ETHERNET1_CURRENT_RX_DESCRIPTOR_POINTER3		0x28ac
+#define ETHERNET1_CURRENT_TX_DESCRIPTOR_POINTER0		0x28e0
+#define ETHERNET1_CURRENT_TX_DESCRIPTOR_POINTER1		0x28e4
+#define ETHERNET1_MIB_COUNTER_BASE				0x2900
+
+/* Ethernet 2 */
+
+#define ETHERNET2_PORT_CONFIGURATION_REGISTER			0x2c00
+#define ETHERNET2_PORT_CONFIGURATION_EXTEND_REGISTER		0x2c08
+#define ETHERNET2_PORT_COMMAND_REGISTER				0x2c10
+#define ETHERNET2_PORT_STATUS_REGISTER				0x2c18
+#define ETHERNET2_SERIAL_PARAMETRS_REGISTER			0x2c20
+#define ETHERNET2_HASH_TABLE_POINTER_REGISTER			0x2c28
+#define ETHERNET2_FLOW_CONTROL_SOURCE_ADDRESS_LOW		0x2c30
+#define ETHERNET2_FLOW_CONTROL_SOURCE_ADDRESS_HIGH		0x2c38
+#define ETHERNET2_SDMA_CONFIGURATION_REGISTER			0x2c40
+#define ETHERNET2_SDMA_COMMAND_REGISTER				0x2c48
+#define ETHERNET2_INTERRUPT_CAUSE_REGISTER			0x2c50
+#define ETHERNET2_INTERRUPT_MASK_REGISTER			0x2c58
+#define ETHERNET2_FIRST_RX_DESCRIPTOR_POINTER0			0x2c80
+#define ETHERNET2_FIRST_RX_DESCRIPTOR_POINTER1			0x2c84
+#define ETHERNET2_FIRST_RX_DESCRIPTOR_POINTER2			0x2c88
+#define ETHERNET2_FIRST_RX_DESCRIPTOR_POINTER3			0x2c8c
+#define ETHERNET2_CURRENT_RX_DESCRIPTOR_POINTER0		0x2ca0
+#define ETHERNET2_CURRENT_RX_DESCRIPTOR_POINTER1		0x2ca4
+#define ETHERNET2_CURRENT_RX_DESCRIPTOR_POINTER2		0x2ca8
+#define ETHERNET2_CURRENT_RX_DESCRIPTOR_POINTER3		0x2cac
+#define ETHERNET2_CURRENT_TX_DESCRIPTOR_POINTER0		0x2ce0
+#define ETHERNET2_CURRENT_TX_DESCRIPTOR_POINTER1		0x2ce4
+#define ETHERNET2_MIB_COUNTER_BASE				0x2d00
+
+/*
+ * SDMA Registers
+ */
+
+#define SDMA_GROUP_CONFIGURATION_REGISTER			0xb1f0
+#define CHANNEL0_CONFIGURATION_REGISTER				0x4000
+#define CHANNEL0_COMMAND_REGISTER				0x4008
+#define CHANNEL0_RX_CMD_STATUS					0x4800
+#define CHANNEL0_RX_PACKET_AND_BUFFER_SIZES			0x4804
+#define CHANNEL0_RX_BUFFER_POINTER				0x4808
+#define CHANNEL0_RX_NEXT_POINTER				0x480c
+#define CHANNEL0_CURRENT_RX_DESCRIPTOR_POINTER			0x4810
+#define CHANNEL0_TX_CMD_STATUS					0x4C00
+#define CHANNEL0_TX_PACKET_SIZE					0x4C04
+#define CHANNEL0_TX_BUFFER_POINTER				0x4C08
+#define CHANNEL0_TX_NEXT_POINTER				0x4C0c
+#define CHANNEL0_CURRENT_TX_DESCRIPTOR_POINTER			0x4c10
+#define CHANNEL0_FIRST_TX_DESCRIPTOR_POINTER			0x4c14
+#define CHANNEL1_CONFIGURATION_REGISTER				0x6000
+#define CHANNEL1_COMMAND_REGISTER				0x6008
+#define CHANNEL1_RX_CMD_STATUS					0x6800
+#define CHANNEL1_RX_PACKET_AND_BUFFER_SIZES			0x6804
+#define CHANNEL1_RX_BUFFER_POINTER				0x6808
+#define CHANNEL1_RX_NEXT_POINTER				0x680c
+#define CHANNEL1_CURRENT_RX_DESCRIPTOR_POINTER			0x6810
+#define CHANNEL1_TX_CMD_STATUS					0x6C00
+#define CHANNEL1_TX_PACKET_SIZE					0x6C04
+#define CHANNEL1_TX_BUFFER_POINTER				0x6C08
+#define CHANNEL1_TX_NEXT_POINTER				0x6C0c
+#define CHANNEL1_CURRENT_RX_DESCRIPTOR_POINTER			0x6810
+#define CHANNEL1_CURRENT_TX_DESCRIPTOR_POINTER			0x6c10
+#define CHANNEL1_FIRST_TX_DESCRIPTOR_POINTER			0x6c14
+
+/* SDMA Interrupt */
+
+#define SDMA_CAUSE						0xb820
+#define SDMA_MASK						0xb8a0
+
+
+/*
+ * Baude Rate Generators Registers
+ */
+
+/* BRG 0 */
+
+#define BRG0_CONFIGURATION_REGISTER				0xb200
+#define BRG0_BAUDE_TUNING_REGISTER				0xb204
+
+/* BRG 1 */
+
+#define BRG1_CONFIGURATION_REGISTER				0xb208
+#define BRG1_BAUDE_TUNING_REGISTER				0xb20c
+
+/* BRG 2 */
+
+#define BRG2_CONFIGURATION_REGISTER				0xb210
+#define BRG2_BAUDE_TUNING_REGISTER				0xb214
+
+/* BRG Interrupts */
+
+#define BRG_CAUSE_REGISTER					0xb834
+#define BRG_MASK_REGISTER					0xb8b4
+
+/* MISC */
+
+#define MAIN_ROUTING_REGISTER					0xb400
+#define RECEIVE_CLOCK_ROUTING_REGISTER				0xb404
+#define TRANSMIT_CLOCK_ROUTING_REGISTER				0xb408
+#define COMM_UNIT_ARBITER_CONFIGURATION_REGISTER		0xb40c
+#define WATCHDOG_CONFIGURATION_REGISTER				0xb410
+#define WATCHDOG_VALUE_REGISTER					0xb414
+
+
+/*
+ * Flex TDM Registers
+ */
+
+/* FTDM Port */
+
+#define FLEXTDM_TRANSMIT_READ_POINTER				0xa800
+#define FLEXTDM_RECEIVE_READ_POINTER				0xa804
+#define FLEXTDM_CONFIGURATION_REGISTER				0xa808
+#define FLEXTDM_AUX_CHANNELA_TX_REGISTER			0xa80c
+#define FLEXTDM_AUX_CHANNELA_RX_REGISTER			0xa810
+#define FLEXTDM_AUX_CHANNELB_TX_REGISTER			0xa814
+#define FLEXTDM_AUX_CHANNELB_RX_REGISTER			0xa818
+
+/* FTDM Interrupts */
+
+#define FTDM_CAUSE_REGISTER					0xb830
+#define FTDM_MASK_REGISTER					0xb8b0
+
+
+/*
+ * GPP Interface Registers
+ */
+
+#define GPP_IO_CONTROL						0xf100
+#define GPP_LEVEL_CONTROL					0xf110
+#define GPP_VALUE						0xf104
+#define GPP_INTERRUPT_CAUSE					0xf108
+#define GPP_INTERRUPT_MASK					0xf10c
+
+#define MPP_CONTROL0						0xf000
+#define MPP_CONTROL1						0xf004
+#define MPP_CONTROL2						0xf008
+#define MPP_CONTROL3						0xf00c
+#define DEBUG_PORT_MULTIPLEX					0xf014
+#define SERIAL_PORT_MULTIPLEX					0xf010
+
+/*
+ * I2C Registers
+ */
+
+#define I2C_SLAVE_ADDRESS					0xc000
+#define I2C_EXTENDED_SLAVE_ADDRESS				0xc040
+#define I2C_DATA						0xc004
+#define I2C_CONTROL						0xc008
+#define I2C_STATUS_BAUDE_RATE					0xc00C
+#define I2C_SOFT_RESET						0xc01c
+
+/*
+ * MPSC Registers
+ */
+
+/*
+ * MPSC0
+ */
+
+#define MPSC0_MAIN_CONFIGURATION_LOW				0x8000
+#define MPSC0_MAIN_CONFIGURATION_HIGH				0x8004
+#define MPSC0_PROTOCOL_CONFIGURATION				0x8008
+#define CHANNEL0_REGISTER1					0x800c
+#define CHANNEL0_REGISTER2					0x8010
+#define CHANNEL0_REGISTER3					0x8014
+#define CHANNEL0_REGISTER4					0x8018
+#define CHANNEL0_REGISTER5					0x801c
+#define CHANNEL0_REGISTER6					0x8020
+#define CHANNEL0_REGISTER7					0x8024
+#define CHANNEL0_REGISTER8					0x8028
+#define CHANNEL0_REGISTER9					0x802c
+#define CHANNEL0_REGISTER10					0x8030
+#define CHANNEL0_REGISTER11					0x8034
+
+/*
+ * MPSC1
+ */
+
+#define MPSC1_MAIN_CONFIGURATION_LOW				0x9000
+#define MPSC1_MAIN_CONFIGURATION_HIGH				0x9004
+#define MPSC1_PROTOCOL_CONFIGURATION				0x9008
+#define CHANNEL1_REGISTER1					0x900c
+#define CHANNEL1_REGISTER2					0x9010
+#define CHANNEL1_REGISTER3					0x9014
+#define CHANNEL1_REGISTER4					0x9018
+#define CHANNEL1_REGISTER5					0x901c
+#define CHANNEL1_REGISTER6					0x9020
+#define CHANNEL1_REGISTER7					0x9024
+#define CHANNEL1_REGISTER8					0x9028
+#define CHANNEL1_REGISTER9					0x902c
+#define CHANNEL1_REGISTER10					0x9030
+#define CHANNEL1_REGISTER11					0x9034
+
+/*
+ * MPSCs Interupts
+ */
+
+#define MPSC0_CAUSE						0xb804
+#define MPSC0_MASK						0xb884
+#define MPSC1_CAUSE						0xb80c
+#define MPSC1_MASK						0xb88c
+
+extern unsigned long gt64240_base;
+
+#define GT64240_BASE	   (gt64240_base)
+
+/*
+ * Because of an error/peculiarity in the Galileo chip, we need to swap the
+ * bytes when running bigendian.
+ */
+#define __GT_READ(ofs)							\
+	(*(volatile u32 *)(GT64240_BASE+(ofs)))
+#define __GT_WRITE(ofs, data)						\
+	do { *(volatile u32 *)(GT64240_BASE+(ofs)) = (data); } while (0)
+
+#define GT_READ(ofs)		le32_to_cpu(__GT_READ(ofs))
+#define GT_WRITE(ofs, data)	__GT_WRITE(ofs, cpu_to_le32(data))
+
+#define GT_READ_16(ofs, data)						\
+        le16_to_cpu(*(volatile u16 *)(GT64240_BASE+(ofs)))
+#define GT_WRITE_16(ofs, data)  \
+        *(volatile u16 *)(GT64240_BASE+(ofs)) = cpu_to_le16(data)
+
+#define GT_READ_8(ofs, data)						\
+        *(data) = *(volatile u8 *)(GT64240_BASE+(ofs))
+#define GT_WRITE_8(ofs, data)						\
+        *(volatile u8 *)(GT64240_BASE+(ofs)) = data
+
+extern struct pci_ops gt_bus0_pci_ops;
+extern struct pci_ops gt_bus1_pci_ops;
+
+#endif	/* __ASM_MIPS_MV64240_H */
diff -puN include/asm-mips/hazards.h~mips-update include/asm-mips/hazards.h
--- 25/include/asm-mips/hazards.h~mips-update	2004-06-21 23:10:45.477305976 -0700
+++ 25-akpm/include/asm-mips/hazards.h	2004-06-21 23:10:45.780259920 -0700
@@ -12,22 +12,27 @@
 
 #ifdef __ASSEMBLY__
 
+	.macro	_ssnop
+	sll	$0, $2, 1
+	.endm
+
 /*
  * RM9000 hazards.  When the JTLB is updated by tlbwi or tlbwr, a subsequent
  * use of the JTLB for instructions should not occur for 4 cpu cycles and use
  * for data translations should not occur for 3 cpu cycles.
  */
 #ifdef CONFIG_CPU_RM9000
+
 #define mtc0_tlbw_hazard						\
 	.set	push;							\
 	.set	mips32;							\
-	ssnop; ssnop; ssnop; ssnop;					\
+	_ssnop; _ssnop; _ssnop; _ssnop;					\
 	.set	pop
 
 #define tlbw_eret_hazard						\
 	.set	push;							\
 	.set	mips32;							\
-	ssnop; ssnop; ssnop; ssnop;					\
+	_ssnop; _ssnop; _ssnop; _ssnop;					\
 	.set	pop
 
 #else
@@ -43,6 +48,33 @@
 #define tlbw_eret_hazard
 #endif
 
+/*
+ * mtc0->mfc0 hazard
+ * The 24K has a 2 cycle mtc0/mfc0 execution hazard.
+ * It is a MIPS32R2 processor so ehb will clear the hazard.
+ */
+
+#ifdef CONFIG_CPU_MIPSR2
+/*
+ * Use a macro for ehb unless explicit support for MIPSR2 is enabled
+ */
+	.macro	ehb
+	sll	$0, $0, 3
+	.endm
+
+#define irq_enable_hazard						\
+	ehb		# irq_enable_hazard
+
+#define irq_disable_hazard						\
+	ehb		# irq_disable_hazard
+
+#else
+
+#define irq_enable_hazard
+#define irq_disable_hazard
+
+#endif
+
 #else /* __ASSEMBLY__ */
 
 /*
@@ -55,13 +87,13 @@
 #define mtc0_tlbw_hazard()						\
 	__asm__ __volatile__(						\
 		".set\tmips32\n\t"					\
-		"ssnop; ssnop; ssnop; ssnop\n\t"			\
+		"_ssnop; _ssnop; _ssnop; _ssnop\n\t"			\
 		".set\tmips0")
 
 #define tlbw_use_hazard()						\
 	__asm__ __volatile__(						\
 		".set\tmips32\n\t"					\
-		"ssnop; ssnop; ssnop; ssnop\n\t"			\
+		"_ssnop; _ssnop; _ssnop; _ssnop\n\t"			\
 		".set\tmips0")
 #else
 
@@ -82,6 +114,83 @@
 
 #endif
 
+/*
+ * mtc0->mfc0 hazard
+ * The 24K has a 2 cycle mtc0/mfc0 execution hazard.
+ * It is a MIPS32R2 processor so ehb will clear the hazard.
+ */
+
+#ifdef CONFIG_CPU_MIPSR2
+/*
+ * Use a macro for ehb unless explicit support for MIPSR2 is enabled
+ */
+__asm__(
+	"	.macro	ehb					\n\t"
+	"	sll	$0, $0, 3				\n\t"
+	"	.endm						\n\t"
+	"							\n\t"
+	"	.macro\tirq_enable_hazard			\n\t"
+	"	ehb						\n\t"
+	"	.endm						\n\t"
+	"							\n\t"
+	"	.macro\tirq_disable_hazard			\n\t"
+	"	ehb						\n\t"
+	"	.endm");
+
+#define irq_enable_hazard()						\
+	__asm__ __volatile__(						\
+	"ehb\t\t\t\t# irq_enable_hazard")
+
+#define irq_disable_hazard()						\
+	__asm__ __volatile__(						\
+	"ehb\t\t\t\t# irq_disable_hazard")
+
+#elif defined(CONFIG_CPU_R10000)
+
+/*
+ * R10000 rocks - all hazards handled in hardware, so this becomes a nobrainer.
+ */
+
+__asm__(
+	"	.macro\tirq_enable_hazard			\n\t"
+	"	.endm						\n\t"
+	"							\n\t"
+	"	.macro\tirq_disable_hazard			\n\t"
+	"	.endm");
+
+#define irq_enable_hazard()	do { } while (0)
+#define irq_disable_hazard()	do { } while (0)
+
+#else
+
+/*
+ * Default for classic MIPS processors.  Assume worst case hazards but don't
+ * care about the irq_enable_hazard - sooner or later the hardware will
+ * enable it and we don't care when exactly.
+ */
+
+__asm__(
+	"	.macro	_ssnop					\n\t"
+	"	sll	$0, $2, 1				\n\t"
+	"	.endm						\n\t"
+	"							\n\t"
+	"	#						\n\t"
+	"	# There is a hazard but we do not care		\n\t"
+	"	#						\n\t"
+	"	.macro\tirq_enable_hazard			\n\t"
+	"	.endm						\n\t"
+	"							\n\t"
+	"	.macro\tirq_disable_hazard			\n\t"
+	"	_ssnop; _ssnop; _ssnop				\n\t"
+	"	.endm");
+
+#define irq_enable_hazard()	do { } while (0)
+#define irq_disable_hazard()						\
+	__asm__ __volatile__(						\
+	"_ssnop; _ssnop; _ssnop;\t\t# irq_disable_hazard")
+
+#endif
+
 #endif /* __ASSEMBLY__ */
 
 #endif /* _ASM_HAZARDS_H */
diff -puN /dev/null include/asm-mips/mach-yosemite/cpu-feature-overrides.h
--- /dev/null	2003-09-15 06:40:47.000000000 -0700
+++ 25-akpm/include/asm-mips/mach-yosemite/cpu-feature-overrides.h	2004-06-21 23:10:45.782259616 -0700
@@ -0,0 +1,38 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2003, 2004 Ralf Baechle
+ */
+#ifndef __ASM_MACH_YOSEMITE_CPU_FEATURE_OVERRIDES_H
+#define __ASM_MACH_YOSEMITE_CPU_FEATURE_OVERRIDES_H
+
+/*
+ * Momentum Jaguar ATX always has the RM9000 processor.
+ */
+#define cpu_has_watch		1
+#define cpu_has_mips16		0
+#define cpu_has_divec		0
+#define cpu_has_vce		0
+#define cpu_has_cache_cdex_p	0
+#define cpu_has_cache_cdex_s	0
+#define cpu_has_prefetch	1
+#define cpu_has_mcheck		0
+#define cpu_has_ejtag		0
+
+#define cpu_has_llsc		1
+#define cpu_has_vtag_icache	0
+#define cpu_has_dc_aliases	0
+#define cpu_has_ic_fills_f_dc	0
+
+#define cpu_has_nofpuex		0
+#define cpu_has_64bits		1
+
+#define cpu_has_subset_pcaches	0
+
+#define cpu_dcache_line_size()	32
+#define cpu_icache_line_size()	32
+#define cpu_scache_line_size()	32
+
+#endif /* __ASM_MACH_YOSEMITE_CPU_FEATURE_OVERRIDES_H */
diff -puN include/asm-mips/mipsregs.h~mips-update include/asm-mips/mipsregs.h
--- 25/include/asm-mips/mipsregs.h~mips-update	2004-06-21 23:10:45.480305520 -0700
+++ 25-akpm/include/asm-mips/mipsregs.h	2004-06-21 23:10:45.784259312 -0700
@@ -632,7 +632,7 @@ do {									\
 } while (0)
 
 /*
- * On The RM7000 these are use to access cop0 set 1 registers
+ * On RM7000/RM9000 these are uses to access cop0 set 1 registers
  */
 #define __read_32bit_c0_ctrl_register(source)				\
 ({ int __res;								\
diff -puN include/asm-mips/mmu_context.h~mips-update include/asm-mips/mmu_context.h
--- 25/include/asm-mips/mmu_context.h~mips-update	2004-06-21 23:10:45.482305216 -0700
+++ 25-akpm/include/asm-mips/mmu_context.h	2004-06-21 23:10:45.784259312 -0700
@@ -45,12 +45,17 @@ extern unsigned long pgd_current[];
 #define ASID_INC	0x40
 #define ASID_MASK	0xfc0
 
+#elif defined(CONFIG_CPU_R8000)
+
+#define ASID_INC	0x10
+#define ASID_MASK	0xff0
+
 #elif defined(CONFIG_CPU_RM9000)
 
 #define ASID_INC	0x1
 #define ASID_MASK	0xfff
 
-#else /* FIXME: not correct for R6000, R8000 */
+#else /* FIXME: not correct for R6000 */
 
 #define ASID_INC	0x1
 #define ASID_MASK	0xff
@@ -78,9 +83,8 @@ get_new_mmu_context(struct mm_struct *mm
 	unsigned long asid = asid_cache(cpu);
 
 	if (! ((asid += ASID_INC) & ASID_MASK) ) {
-#ifdef CONFIG_VTAG_ICACHE
-		flush_icache_all();
-#endif
+		if (cpu_has_vtag_icache)
+			flush_icache_all();
 		local_flush_tlb_all();	/* start new asid cycle */
 		if (!asid)		/* fix version if needed */
 			asid = ASID_FIRST_VERSION;
diff -puN include/asm-mips/module.h~mips-update include/asm-mips/module.h
--- 25/include/asm-mips/module.h~mips-update	2004-06-21 23:10:45.483305064 -0700
+++ 25-akpm/include/asm-mips/module.h	2004-06-21 23:10:45.785259160 -0700
@@ -2,11 +2,14 @@
 #define _ASM_MODULE_H
 
 #include <linux/config.h>
+#include <linux/list.h>
+#include <asm/uaccess.h>
 
 struct mod_arch_specific {
 	/* Data Bus Error exception tables */
-	const struct exception_table_entry *dbe_table_start;
-	const struct exception_table_entry *dbe_table_end;
+	struct list_head dbe_list;
+	const struct exception_table_entry *dbe_start;
+	const struct exception_table_entry *dbe_end;
 };
 
 typedef uint8_t Elf64_Byte;		/* Type for a 8-bit quantity.  */
@@ -38,4 +41,16 @@ typedef struct
 
 #endif
 
+#ifdef CONFIG_MODULES
+/* Given an address, look for it in the exception tables. */
+const struct exception_table_entry*search_module_dbetables(unsigned long addr);
+#else
+/* Given an address, look for it in the exception tables. */
+static inline const struct exception_table_entry *
+search_module_dbetables(unsigned long addr)
+{
+	return NULL;
+}
+#endif
+
 #endif /* _ASM_MODULE_H */
diff -puN include/asm-mips/page.h~mips-update include/asm-mips/page.h
--- 25/include/asm-mips/page.h~mips-update	2004-06-21 23:10:45.485304760 -0700
+++ 25-akpm/include/asm-mips/page.h	2004-06-21 23:10:45.787258856 -0700
@@ -10,16 +10,20 @@
 #define _ASM_PAGE_H
 
 #include <linux/config.h>
-#include <spaces.h>
 
 #ifdef __KERNEL__
 
+#include <spaces.h>
+
 /*
  * PAGE_SHIFT determines the page size
  */
 #ifdef CONFIG_PAGE_SIZE_4KB
 #define PAGE_SHIFT	12
 #endif
+#ifdef CONFIG_PAGE_SIZE_8KB
+#define PAGE_SHIFT	13
+#endif
 #ifdef CONFIG_PAGE_SIZE_16KB
 #define PAGE_SHIFT	14
 #endif
diff -puN include/asm-mips/pci.h~mips-update include/asm-mips/pci.h
--- 25/include/asm-mips/pci.h~mips-update	2004-06-21 23:10:45.487304456 -0700
+++ 25-akpm/include/asm-mips/pci.h	2004-06-21 23:10:45.788258704 -0700
@@ -87,6 +87,9 @@ extern void pci_dac_dma_sync_single_for_
 extern void pci_dac_dma_sync_single_for_device(struct pci_dev *pdev,
 	dma64_addr_t dma_addr, size_t len, int direction);
 
+extern void pcibios_resource_to_bus(struct pci_dev *dev,
+	struct pci_bus_region *region, struct resource *res);
+
 #endif /* __KERNEL__ */
 
 /* implement the pci_ DMA API in terms of the generic device dma_ one */
diff -puN include/asm-mips/pgtable-32.h~mips-update include/asm-mips/pgtable-32.h
--- 25/include/asm-mips/pgtable-32.h~mips-update	2004-06-21 23:10:45.490304000 -0700
+++ 25-akpm/include/asm-mips/pgtable-32.h	2004-06-21 23:10:45.789258552 -0700
@@ -141,35 +141,8 @@ static inline void pgd_clear(pgd_t *pgdp
 #define pfn_pte(pfn, prot)	__pte(((pfn) << PAGE_SHIFT) | pgprot_val(prot))
 #endif
 
-#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
-
-/*
- * Bits 0, 1, 2, 9 and 10 are taken, split up the 27 bits of offset
- * into this range:
- */
-#define pte_to_pgoff(_pte) \
-	((((_pte).pte >> 3) & 0x3f ) + (((_pte).pte >> 11) << 8 ))
-
-#define pgoff_to_pte(off) \
-	((pte_t) { (((off) & 0x3f) << 3) + (((off) >> 8) << 11) + _PAGE_FILE })
-
-#else
-
-/*
- * Bits 0, 1, 2, 7 and 8 are taken, split up the 27 bits of offset
- * into this range:
- */
-#define pte_to_pgoff(_pte) \
-	((((_pte).pte >> 3) & 0x1f ) + (((_pte).pte >> 9) << 6 ))
- 
-#define pgoff_to_pte(off) \
-	((pte_t) { (((off) & 0x1f) << 3) + (((off) >> 6) << 9) + _PAGE_FILE })
-
-#endif
-
 #define __pgd_offset(address)	pgd_index(address)
-#define __pmd_offset(address) \
-	(((address) >> PMD_SHIFT) & (PTRS_PER_PMD-1))
+#define __pmd_offset(address)	(((address) >> PMD_SHIFT) & (PTRS_PER_PMD-1))
 
 /* to find an entry in a kernel page-table-directory */
 #define pgd_offset_k(address) pgd_offset(&init_mm, address)
@@ -200,17 +173,46 @@ static inline pmd_t *pmd_offset(pgd_t *d
 #define pte_unmap(pte) ((void)(pte))
 #define pte_unmap_nested(pte) ((void)(pte))
 
-/* Swap entries must have VALID and GLOBAL bits cleared. */
 #if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
 
-#define __swp_type(x)		(((x).val >> 1) & 0x7f)
-#define __swp_offset(x)		((x).val >> 10)
-#define __swp_entry(type,offset)	((swp_entry_t) { ((type) << 1) | ((offset) << 10) })
+/* Swap entries must have VALID bit cleared. */
+#define __swp_type(x)		(((x).val >> 10) & 0x1f)
+#define __swp_offset(x)		((x).val >> 15)
+#define __swp_entry(type,offset)	\
+	((swp_entry_t) { ((type) << 10) | ((offset) << 15) })
+
+/*
+ * Bits 0, 1, 2, 9 and 10 are taken, split up the 27 bits of offset
+ * into this range:
+ */
+#define PTE_FILE_MAX_BITS	27
+
+#define pte_to_pgoff(_pte) \
+	((((_pte).pte >> 3) & 0x3f ) + (((_pte).pte >> 11) << 8 ))
+
+#define pgoff_to_pte(off) \
+	((pte_t) { (((off) & 0x3f) << 3) + (((off) >> 8) << 11) + _PAGE_FILE })
+
 #else
 
-#define __swp_type(x)		(((x).val >> 1) & 0x1f)
-#define __swp_offset(x)		((x).val >> 8)
-#define __swp_entry(type,offset)	((swp_entry_t) { ((type) << 1) | ((offset) << 8) })
+/* Swap entries must have VALID and GLOBAL bits cleared. */
+#define __swp_type(x)		(((x).val >> 8) & 0x1f)
+#define __swp_offset(x)		((x).val >> 13)
+#define __swp_entry(type,offset)	\
+		((swp_entry_t) { ((type) << 8) | ((offset) << 13) })
+
+/*
+ * Bits 0, 1, 2, 7 and 8 are taken, split up the 27 bits of offset
+ * into this range:
+ */
+#define PTE_FILE_MAX_BITS	27
+
+#define pte_to_pgoff(_pte) \
+	((((_pte).pte >> 3) & 0x1f ) + (((_pte).pte >> 9) << 6 ))
+
+#define pgoff_to_pte(off) \
+	((pte_t) { (((off) & 0x1f) << 3) + (((off) >> 6) << 9) + _PAGE_FILE })
+
 #endif
 
 #define __pte_to_swp_entry(pte)	((swp_entry_t) { pte_val(pte) })
diff -puN include/asm-mips/pgtable-64.h~mips-update include/asm-mips/pgtable-64.h
--- 25/include/asm-mips/pgtable-64.h~mips-update	2004-06-21 23:10:45.491303848 -0700
+++ 25-akpm/include/asm-mips/pgtable-64.h	2004-06-21 23:10:45.791258248 -0700
@@ -53,7 +53,11 @@
  * We used to implement 41 bits by having an order 1 pmd level but that seemed
  * rather pointless.
  *
- * For 16kB page size we use a 2 level page tree which permit a total of
+ * For 8kB page size we use a 3 level page tree which permits a total of
+ * 8TB of address space.  Alternatively a 33-bit / 8GB organization using
+ * two levels would be easy to implement.
+ *
+ * For 16kB page size we use a 2 level page tree which permits a total of
  * 36 bits of virtual address space.  We could add a third leve. but it seems
  * like at the moment there's no need for this.
  *
@@ -65,6 +69,11 @@
 #define PMD_ORDER		1
 #define PTE_ORDER		0
 #endif
+#ifdef CONFIG_PAGE_SIZE_8KB
+#define PGD_ORDER		0
+#define PMD_ORDER		0
+#define PTE_ORDER		0
+#endif
 #ifdef CONFIG_PAGE_SIZE_16KB
 #define PGD_ORDER		0
 #define PMD_ORDER		0
@@ -148,16 +157,6 @@ static inline void pgd_clear(pgd_t *pgdp
 #define pfn_pte(pfn, prot)	__pte(((pfn) << PAGE_SHIFT) | pgprot_val(prot))
 #endif
 
-/*
- * Bits 0, 1, 2, 7 and 8 are taken, split up the 27 bits of offset
- * into this range:
- */
-#define pte_to_pgoff(_pte) \
-	((((_pte).pte >> 3) & 0x1f ) + (((_pte).pte >> 9) << 6 ))
-
-#define pgoff_to_pte(off) \
-	((pte_t) { (((off) & 0x1f) << 3) + (((off) >> 6) << 9) + _PAGE_FILE })
-
 #define __pgd_offset(address)	pgd_index(address)
 #define page_pte(page) page_pte_prot(page, __pgprot(0))
 
@@ -215,6 +214,18 @@ static inline pte_t mk_swap_pte(unsigned
 #define __swp_entry_to_pte(x)	((pte_t) { (x).val })
 
 /*
+ * Bits 0, 1, 2, 7 and 8 are taken, split up the 32 bits of offset
+ * into this range:
+ */
+#define PTE_FILE_MAX_BITS	32
+
+#define pte_to_pgoff(_pte) \
+	((((_pte).pte >> 3) & 0x1f ) + (((_pte).pte >> 9) << 6 ))
+
+#define pgoff_to_pte(off) \
+	((pte_t) { (((off) & 0x1f) << 3) + (((off) >> 6) << 9) + _PAGE_FILE })
+
+/*
  * Used for the b0rked handling of kernel pagetables on the 64-bit kernel.
  */
 extern pte_t kptbl[(PAGE_SIZE << PGD_ORDER)/sizeof(pte_t)];
diff -puN include/asm-mips/pgtable-bits.h~mips-update include/asm-mips/pgtable-bits.h
--- 25/include/asm-mips/pgtable-bits.h~mips-update	2004-06-21 23:10:45.493303544 -0700
+++ 25-akpm/include/asm-mips/pgtable-bits.h	2004-06-21 23:10:45.792258096 -0700
@@ -60,7 +60,7 @@
 #define _PAGE_SILENT_WRITE          (1<<8)
 #define _CACHE_MASK                 (7<<9)
 
-#if defined(CONFIG_CPU_SB1)
+#ifdef CONFIG_CPU_SB1
 
 /* No penalty for being coherent on the SB1, so just
    use it for "noncoherent" spaces, too.  Shouldn't hurt. */
@@ -70,6 +70,20 @@
 #define _CACHE_CACHABLE_NONCOHERENT (5<<9)
 #define _CACHE_UNCACHED_ACCELERATED (7<<9)
 
+#elif defined(CONFIG_CPU_RM9000)
+
+#define _CACHE_WT			(0 << 9)
+#define _CACHE_WTWA			(1 << 9)
+#define _CACHE_UC_B			(2 << 9)
+#define _CACHE_WB			(3 << 9)
+#define _CACHE_CWBEA			(4 << 9)
+#define _CACHE_CWB			(5 << 9)
+#define _CACHE_UCNB			(6 << 9)
+#define _CACHE_FPC			(7 << 9)
+
+#define _CACHE_UNCACHED			_CACHE_UC_B
+#define _CACHE_CACHABLE_NONCOHERENT	_CACHE_UC_B
+
 #else
 
 #define _CACHE_CACHABLE_NO_WA       (0<<9)  /* R4600 only              */
@@ -93,6 +107,8 @@
 #define PAGE_CACHABLE_DEFAULT	_CACHE_UNCACHED
 #elif defined(CONFIG_DMA_NONCOHERENT)
 #define PAGE_CACHABLE_DEFAULT	_CACHE_CACHABLE_NONCOHERENT
+#elif defined(CONFIG_CPU_RM9000)
+#define PAGE_CACHABLE_DEFAULT	_CACHE_CWBEA
 #else
 #define PAGE_CACHABLE_DEFAULT	_CACHE_CACHABLE_COW
 #endif
diff -puN include/asm-mips/pgtable.h~mips-update include/asm-mips/pgtable.h
--- 25/include/asm-mips/pgtable.h~mips-update	2004-06-21 23:10:45.495303240 -0700
+++ 25-akpm/include/asm-mips/pgtable.h	2004-06-21 23:10:45.793257944 -0700
@@ -125,8 +125,6 @@ static inline void pte_clear(pte_t *ptep
 
 extern pgd_t swapper_pg_dir[PTRS_PER_PGD];
 
-#define PTE_FILE_MAX_BITS	27
-
 /*
  * The following only work if pte_present() is true.
  * Undefined behaviour if not..
diff -puN include/asm-mips/pmon.h~mips-update include/asm-mips/pmon.h
--- 25/include/asm-mips/pmon.h~mips-update	2004-06-21 23:10:45.496303088 -0700
+++ 25-akpm/include/asm-mips/pmon.h	2004-06-21 23:10:45.795257640 -0700
@@ -17,6 +17,9 @@ struct callvectors {
 	int	(*printf) (const char*, ...);		/*	20 */
 	void	(*cacheflush) (void);			/*	24 */
 	char*	(*gets) (char*);			/*	28 */
+	int	(*cpustart) (int, void *, int, int);	/*	32 */
 };
 
+extern struct callvectors *debug_vectors;
+
 #endif /* _ASM_PMON_H */
diff -puN include/asm-mips/processor.h~mips-update include/asm-mips/processor.h
--- 25/include/asm-mips/processor.h~mips-update	2004-06-21 23:10:45.499302632 -0700
+++ 25-akpm/include/asm-mips/processor.h	2004-06-21 23:10:45.797257336 -0700
@@ -280,15 +280,6 @@ unsigned long get_wchan(struct task_stru
  */
 #define return_address() ({__asm__ __volatile__("":::"$31");__builtin_return_address(0);})
 
-/*
- * For now.  The 32-bit cycle counter is screwed up so solving this nicely takes a little
- * brainwork ...
- */
-static inline unsigned long long sched_clock(void)
-{
-	return 0ULL;
-}
-
 #ifdef CONFIG_CPU_HAS_PREFETCH
 
 #define ARCH_HAS_PREFETCH
diff -puN include/asm-mips/semaphore.h~mips-update include/asm-mips/semaphore.h
--- 25/include/asm-mips/semaphore.h~mips-update	2004-06-21 23:10:45.501302328 -0700
+++ 25-akpm/include/asm-mips/semaphore.h	2004-06-21 23:10:45.798257184 -0700
@@ -4,61 +4,70 @@
  * for more details.
  *
  * Copyright (C) 1996  Linus Torvalds
- * Copyright (C) 1998, 99, 2000, 01  Ralf Baechle
+ * Copyright (C) 1998, 99, 2000, 01, 04  Ralf Baechle
  * Copyright (C) 1999, 2000, 01  Silicon Graphics, Inc.
  * Copyright (C) 2000, 01 MIPS Technologies, Inc.
+ *
+ * In all honesty, little of the old MIPS code left - the PPC64 variant was
+ * just looking nice and portable so I ripped it.  Credits to whoever wrote
+ * it.
  */
-#ifndef _ASM_SEMAPHORE_H
-#define _ASM_SEMAPHORE_H
+#ifndef __ASM_SEMAPHORE_H
+#define __ASM_SEMAPHORE_H
+
+/*
+ * Remove spinlock-based RW semaphores; RW semaphore definitions are
+ * now in rwsem.h and we use the generic lib/rwsem.c implementation.
+ * Rework semaphores to use atomic_dec_if_positive.
+ * -- Paul Mackerras (paulus@samba.org)
+ */
+
+#ifdef __KERNEL__
 
-#include <linux/compiler.h>
-#include <linux/config.h>
-#include <linux/spinlock.h>
+#include <asm/atomic.h>
+#include <asm/system.h>
 #include <linux/wait.h>
 #include <linux/rwsem.h>
-#include <asm/atomic.h>
 
 struct semaphore {
-#ifdef __MIPSEB__
-	atomic_t count;
-	atomic_t waking;
-#else
-	atomic_t waking;
+	/*
+	 * Note that any negative value of count is equivalent to 0,
+	 * but additionally indicates that some process(es) might be
+	 * sleeping on `wait'.
+	 */
 	atomic_t count;
-#endif
 	wait_queue_head_t wait;
-#if WAITQUEUE_DEBUG
+#ifdef WAITQUEUE_DEBUG
 	long __magic;
 #endif
-} __attribute__((aligned(8)));
+};
 
-#if WAITQUEUE_DEBUG
-# define __SEM_DEBUG_INIT(name) , .__magic = (long)&(name).__magic
+#ifdef WAITQUEUE_DEBUG
+# define __SEM_DEBUG_INIT(name) \
+		, (long)&(name).__magic
 #else
 # define __SEM_DEBUG_INIT(name)
 #endif
 
-#define __SEMAPHORE_INITIALIZER(name,_count) {				\
-	.count	= ATOMIC_INIT(_count),					\
-	.waking	= ATOMIC_INIT(0),					\
-	.wait	= __WAIT_QUEUE_HEAD_INITIALIZER((name).wait)		\
-	__SEM_DEBUG_INIT(name)						\
-}
+#define __SEMAPHORE_INITIALIZER(name, count) \
+	{ ATOMIC_INIT(count), \
+	  __WAIT_QUEUE_HEAD_INITIALIZER((name).wait) \
+	  __SEM_DEBUG_INIT(name) }
 
-#define __MUTEX_INITIALIZER(name) __SEMAPHORE_INITIALIZER(name, 1)
+#define __MUTEX_INITIALIZER(name) \
+	__SEMAPHORE_INITIALIZER(name, 1)
 
-#define __DECLARE_SEMAPHORE_GENERIC(name,count) \
-	struct semaphore name = __SEMAPHORE_INITIALIZER(name, count)
+#define __DECLARE_SEMAPHORE_GENERIC(name, count) \
+	struct semaphore name = __SEMAPHORE_INITIALIZER(name,count)
 
-#define DECLARE_MUTEX(name) __DECLARE_SEMAPHORE_GENERIC(name, 1)
-#define DECLARE_MUTEX_LOCKED(name) __DECLARE_SEMAPHORE_GENERIC(name,0)
+#define DECLARE_MUTEX(name)		__DECLARE_SEMAPHORE_GENERIC(name, 1)
+#define DECLARE_MUTEX_LOCKED(name)	__DECLARE_SEMAPHORE_GENERIC(name, 0)
 
 static inline void sema_init (struct semaphore *sem, int val)
 {
 	atomic_set(&sem->count, val);
-	atomic_set(&sem->waking, 0);
 	init_waitqueue_head(&sem->wait);
-#if WAITQUEUE_DEBUG
+#ifdef WAITQUEUE_DEBUG
 	sem->__magic = (long)&sem->__magic;
 #endif
 }
@@ -73,211 +82,57 @@ static inline void init_MUTEX_LOCKED (st
 	sema_init(sem, 0);
 }
 
-#ifndef CONFIG_CPU_HAS_LLDSCD
-/*
- * On machines without lld/scd we need a spinlock to make the manipulation of
- * sem->count and sem->waking atomic.
- */
-extern spinlock_t semaphore_lock;
-#endif
-
-extern void __down_failed(struct semaphore * sem);
-extern int  __down_failed_interruptible(struct semaphore * sem);
-extern void __up_wakeup(struct semaphore * sem);
+extern void __down(struct semaphore * sem);
+extern int  __down_interruptible(struct semaphore * sem);
+extern void __up(struct semaphore * sem);
 
 static inline void down(struct semaphore * sem)
 {
-	int count;
-
-#if WAITQUEUE_DEBUG
+#ifdef WAITQUEUE_DEBUG
 	CHECK_MAGIC(sem->__magic);
 #endif
 	might_sleep();
-	count = atomic_dec_return(&sem->count);
-	if (unlikely(count < 0))
-		__down_failed(sem);
+
+	/*
+	 * Try to get the semaphore, take the slow path if we fail.
+	 */
+	if (unlikely(atomic_dec_return(&sem->count) < 0))
+		__down(sem);
 }
 
-/*
- * Interruptible try to acquire a semaphore.  If we obtained
- * it, return zero.  If we were interrupted, returns -EINTR
- */
 static inline int down_interruptible(struct semaphore * sem)
 {
-	int count;
+	int ret = 0;
 
-#if WAITQUEUE_DEBUG
+#ifdef WAITQUEUE_DEBUG
 	CHECK_MAGIC(sem->__magic);
 #endif
 	might_sleep();
-	count = atomic_dec_return(&sem->count);
-	if (unlikely(count < 0))
-		return __down_failed_interruptible(sem);
-
-	return 0;
-}
-
-#ifdef CONFIG_CPU_HAS_LLDSCD
-
-/*
- * down_trylock returns 0 on success, 1 if we failed to get the lock.
- *
- * We must manipulate count and waking simultaneously and atomically.
- * Here, we do this by using lld/scd on the pair of 32-bit words.
- *
- * Pseudocode:
- *
- *   Decrement(sem->count)
- *   If(sem->count >=0) {
- *	Return(SUCCESS)			// resource is free
- *   } else {
- *	If(sem->waking <= 0) {		// if no wakeup pending
- *	   Increment(sem->count)	// undo decrement
- *	   Return(FAILURE)
- *      } else {
- *	   Decrement(sem->waking)	// otherwise "steal" wakeup
- *	   Return(SUCCESS)
- *	}
- *   }
- */
-static inline int down_trylock(struct semaphore * sem)
-{
-	long ret, tmp, tmp2, sub;
-
-#if WAITQUEUE_DEBUG
-	CHECK_MAGIC(sem->__magic);
-#endif
-
-	__asm__ __volatile__(
-	"	.set	mips3			# down_trylock		\n"
-	"0:	lld	%1, %4						\n"
-	"	dli	%3, 0x0000000100000000	# count -= 1		\n"
-	"	dsubu	%1, %3						\n"
-	"	li	%0, 0			# ret = 0		\n"
-	"	bgez	%1, 2f			# if count >= 0		\n"
-	"	sll	%2, %1, 0		# extract waking	\n"
-	"	blez	%2, 1f			# if waking < 0 -> 1f	\n"
-	"	daddiu	%1, %1, -1		# waking -= 1		\n"
-	"	b	2f						\n"
-	"1:	daddu	%1, %1, %3		# count += 1		\n"
-	"	li	%0, 1			# ret = 1		\n"
-	"2:	scd	%1, %4						\n"
-	"	beqz	%1, 0b						\n"
-	"	sync							\n"
-	"	.set	mips0						\n"
-	: "=&r"(ret), "=&r"(tmp), "=&r"(tmp2), "=&r"(sub)
-	: "m"(*sem)
-	: "memory");
 
+	if (unlikely(atomic_dec_return(&sem->count) < 0))
+		ret = __down_interruptible(sem);
 	return ret;
 }
 
-/*
- * Note! This is subtle. We jump to wake people up only if
- * the semaphore was negative (== somebody was waiting on it).
- */
-static inline void up(struct semaphore * sem)
-{
-	unsigned long tmp, tmp2;
-	int count;
-
-#if WAITQUEUE_DEBUG
-	CHECK_MAGIC(sem->__magic);
-#endif
-	/*
-	 * We must manipulate count and waking simultaneously and atomically.
-	 * Otherwise we have races between up and __down_failed_interruptible
-	 * waking up on a signal.
-	 */
-
-	__asm__ __volatile__(
-	"	.set	mips3					\n"
-	"	sync			# up			\n"
-	"1:	lld	%1, %3					\n"
-	"	dsra32	%0, %1, 0	# extract count to %0	\n"
-	"	daddiu	%0, 1		# count += 1		\n"
-	"	slti	%2, %0, 1	# %3 = (%0 <= 0)	\n"
-	"	daddu	%1, %2		# waking += %3		\n"
-	"	dsll32 %1, %1, 0	# zero-extend %1	\n"
-	"	dsrl32 %1, %1, 0				\n"
-	"	dsll32	%2, %0, 0	# Reassemble union	\n"
-	"	or	%1, %2		# from count and waking	\n"
-	"	scd	%1, %3					\n"
-	"	beqz	%1, 1b					\n"
-	"	.set	mips0					\n"
-	: "=&r"(count), "=&r"(tmp), "=&r"(tmp2), "+m"(*sem)
-	:
-	: "memory");
-
-	if (unlikely(count <= 0))
-		__up_wakeup(sem);
-}
-
-#else
-
-/*
- * Non-blockingly attempt to down() a semaphore.
- * Returns zero if we acquired it
- */
 static inline int down_trylock(struct semaphore * sem)
 {
-	unsigned long flags;
-	int count, waking;
-	int ret = 0;
-
-#if WAITQUEUE_DEBUG
+#ifdef WAITQUEUE_DEBUG
 	CHECK_MAGIC(sem->__magic);
 #endif
 
-	spin_lock_irqsave(&semaphore_lock, flags);
-	count = atomic_read(&sem->count) - 1;
-	atomic_set(&sem->count, count);
-	if (unlikely(count < 0)) {
-		waking = atomic_read(&sem->waking);
-		if (waking <= 0) {
-			atomic_set(&sem->count, count + 1);
-			ret = 1;
-		} else {
-			atomic_set(&sem->waking, waking - 1);
-			ret = 0;
-		}
-	}
-	spin_unlock_irqrestore(&semaphore_lock, flags);
-
-	return ret;
+	return atomic_dec_if_positive(&sem->count) < 0;
 }
 
-/*
- * Note! This is subtle. We jump to wake people up only if
- * the semaphore was negative (== somebody was waiting on it).
- */
 static inline void up(struct semaphore * sem)
 {
-	unsigned long flags;
-	int count, waking;
-
-#if WAITQUEUE_DEBUG
+#ifdef WAITQUEUE_DEBUG
 	CHECK_MAGIC(sem->__magic);
 #endif
-	/*
-	 * We must manipulate count and waking simultaneously and atomically.
-	 * Otherwise we have races between up and __down_failed_interruptible
-	 * waking up on a signal.
-	 */
-
-	spin_lock_irqsave(&semaphore_lock, flags);
-	count = atomic_read(&sem->count) + 1;
-	waking = atomic_read(&sem->waking);
-	if (count <= 0)
-		waking++;
-	atomic_set(&sem->count, count);
-	atomic_set(&sem->waking, waking);
-	spin_unlock_irqrestore(&semaphore_lock, flags);
 
-	if (unlikely(count <= 0))
-		__up_wakeup(sem);
+	if (unlikely(atomic_inc_return(&sem->count) <= 0))
+		__up(sem);
 }
 
-#endif /* CONFIG_CPU_HAS_LLDSCD */
+#endif /* __KERNEL__ */
 
-#endif /* _ASM_SEMAPHORE_H */
+#endif /* __ASM_SEMAPHORE_H */
diff -puN include/asm-mips/serial.h~mips-update include/asm-mips/serial.h
--- 25/include/asm-mips/serial.h~mips-update	2004-06-21 23:10:45.503302024 -0700
+++ 25-akpm/include/asm-mips/serial.h	2004-06-21 23:10:45.801256728 -0700
@@ -315,24 +315,6 @@
 #define MOMENCO_OCELOT_C_SERIAL_PORT_DEFNS
 #endif
 
-#ifdef CONFIG_TITAN_SERIAL
-/* 16552 20 MHz crystal */
-#define TITAN_SERIAL_BASE_BAUD	( 20000000 / 16 )
-#define	TITAN_SERIAL_IRQ	XXX
-#define	TITAN_SERIAL_BASE	0xffffffff
-
-#define	_TITAN_SERIAL_INIT(int, base)					\
-	{ baud_base: TITAN_SERIAL_BASE_BAUD, irq: int,			\
-	  flags: STD_COM_FLAGS,	iomem_base: (u8 *) base,		\
-	  iomem_reg_shift: 2, io_type: SERIAL_IO_MEM			\
-	}
-
-#define TITAN_SERIAL_PORT_DEFNS						\
-	_TITAN_SERIAL_INIT(TITAN_SERIAL_IRQ, TITAN_SERIAL_BASE)
-#else
-#define TITAN_SERIAL_PORT_DEFNS
-#endif
-
 #ifdef CONFIG_DDB5477
 #include <asm/ddb5xxx/ddb5477.h>
 #define DDB5477_SERIAL_PORT_DEFNS                                       \
@@ -371,7 +353,6 @@
 	MOMENCO_OCELOT_G_SERIAL_PORT_DEFNS		\
 	MOMENCO_OCELOT_C_SERIAL_PORT_DEFNS		\
 	MOMENCO_OCELOT_SERIAL_PORT_DEFNS		\
-	TITAN_SERIAL_PORT_DEFNS				\
 	TXX927_SERIAL_PORT_DEFNS                        \
 	AU1000_SERIAL_PORT_DEFNS
 
diff -puN include/asm-mips/smp.h~mips-update include/asm-mips/smp.h
--- 25/include/asm-mips/smp.h~mips-update	2004-06-21 23:10:45.505301720 -0700
+++ 25-akpm/include/asm-mips/smp.h	2004-06-21 23:10:45.801256728 -0700
@@ -51,8 +51,6 @@ extern cpumask_t phys_cpu_present_map;
 extern cpumask_t cpu_online_map;
 #define cpu_possible_map	phys_cpu_present_map
 
-#define cpu_online(cpu)		cpu_isset(cpu, cpu_online_map)
-
 extern cpumask_t cpu_callout_map;
 /* We don't mark CPUs online until __cpu_up(), so we need another measure */
 static inline int num_booting_cpus(void)
@@ -91,12 +89,6 @@ extern void prom_init_secondary(void);
 extern void prom_prepare_cpus(unsigned int max_cpus);
 
 /*
- * Do whatever setup needs to be done for SMP at the board level.  Return
- * the number of cpus in the system, including this one
- */
-extern int prom_setup_smp(void);
-
-/*
  * Last chance for the board code to finish SMP initialization before
  * the CPU is "online".
  */
diff -puN include/asm-mips/stackframe.h~mips-update include/asm-mips/stackframe.h
--- 25/include/asm-mips/stackframe.h~mips-update	2004-06-21 23:10:45.507301416 -0700
+++ 25-akpm/include/asm-mips/stackframe.h	2004-06-21 23:10:45.802256576 -0700
@@ -302,6 +302,7 @@
 		or	t0, t1
 		xori	t0, 0x1f
 		mtc0	t0, CP0_STATUS
+		irq_disable_hazard
 		.endm
 
 /*
@@ -314,6 +315,7 @@
 		or	t0, t1
 		xori	t0, 0x1e
 		mtc0	t0, CP0_STATUS
+		irq_enable_hazard
 		.endm
 
 /*
@@ -326,6 +328,7 @@
 		or	t0, t1
 		xori	t0, 0x1e
 		mtc0	t0, CP0_STATUS
+		irq_disable_hazard
 		.endm
 
 #endif /* _ASM_STACKFRAME_H */
diff -puN include/asm-mips/system.h~mips-update include/asm-mips/system.h
--- 25/include/asm-mips/system.h~mips-update	2004-06-21 23:10:45.509301112 -0700
+++ 25-akpm/include/asm-mips/system.h	2004-06-21 23:10:45.805256120 -0700
@@ -19,6 +19,7 @@
 
 #include <asm/addrspace.h>
 #include <asm/ptrace.h>
+#include <asm/hazards.h>
 
 __asm__ (
 	".macro\tlocal_irq_enable\n\t"
@@ -29,6 +30,7 @@ __asm__ (
 	"ori\t$1,0x1f\n\t"
 	"xori\t$1,0x1e\n\t"
 	"mtc0\t$1,$12\n\t"
+	"irq_enable_hazard\n\t"
 	".set\tpop\n\t"
 	".endm");
 
@@ -57,9 +59,7 @@ __asm__ (
 	"xori\t$1,1\n\t"
 	".set\tnoreorder\n\t"
 	"mtc0\t$1,$12\n\t"
-	"sll\t$0, $0, 1\t\t\t# nop\n\t"
-	"sll\t$0, $0, 1\t\t\t# nop\n\t"
-	"sll\t$0, $0, 1\t\t\t# nop\n\t"
+	"irq_disable_hazard\n\t"
 	".set\tpop\n\t"
 	".endm");
 
@@ -80,7 +80,7 @@ __asm__ (
 	".set\tpop\n\t"
 	".endm");
 
-#define local_save_flags(x)							\
+#define local_save_flags(x)						\
 __asm__ __volatile__(							\
 	"local_save_flags %0"						\
 	: "=r" (x))
@@ -95,9 +95,7 @@ __asm__ (
 	"xori\t$1, 1\n\t"
 	".set\tnoreorder\n\t"
 	"mtc0\t$1, $12\n\t"
-	"sll\t$0, $0, 1\t\t\t# nop\n\t"
-	"sll\t$0, $0, 1\t\t\t# nop\n\t"
-	"sll\t$0, $0, 1\t\t\t# nop\n\t"
+	"irq_disable_hazard\n\t"
 	".set\tpop\n\t"
 	".endm");
 
@@ -108,7 +106,8 @@ __asm__ __volatile__(							\
 	: /* no inputs */						\
 	: "memory")
 
-__asm__(".macro\tlocal_irq_restore flags\n\t"
+__asm__ (
+	".macro\tlocal_irq_restore flags\n\t"
 	".set\tnoreorder\n\t"
 	".set\tnoat\n\t"
 	"mfc0\t$1, $12\n\t"
@@ -117,14 +116,12 @@ __asm__(".macro\tlocal_irq_restore flags
 	"xori\t$1, 1\n\t"
 	"or\t\\flags, $1\n\t"
 	"mtc0\t\\flags, $12\n\t"
-	"sll\t$0, $0, 1\t\t\t# nop\n\t"
-	"sll\t$0, $0, 1\t\t\t# nop\n\t"
-	"sll\t$0, $0, 1\t\t\t# nop\n\t"
+	"irq_disable_hazard\n\t"
 	".set\tat\n\t"
 	".set\treorder\n\t"
 	".endm");
 
-#define local_irq_restore(flags)						\
+#define local_irq_restore(flags)					\
 do {									\
 	unsigned long __tmp1;						\
 									\
diff -puN include/asm-mips/thread_info.h~mips-update include/asm-mips/thread_info.h
--- 25/include/asm-mips/thread_info.h~mips-update	2004-06-21 23:10:45.510300960 -0700
+++ 25-akpm/include/asm-mips/thread_info.h	2004-06-21 23:10:45.805256120 -0700
@@ -68,6 +68,9 @@ register struct thread_info *__current_t
 #if defined(CONFIG_PAGE_SIZE_4KB) && defined(CONFIG_MIPS64)
 #define THREAD_SIZE_ORDER (2)
 #endif
+#ifdef CONFIG_PAGE_SIZE_8KB
+#define THREAD_SIZE_ORDER (1)
+#endif
 #ifdef CONFIG_PAGE_SIZE_16KB
 #define THREAD_SIZE_ORDER (0)
 #endif
diff -puN include/asm-mips/titan_dep.h~mips-update include/asm-mips/titan_dep.h
--- 25/include/asm-mips/titan_dep.h~mips-update	2004-06-21 23:10:45.512300656 -0700
+++ 25-akpm/include/asm-mips/titan_dep.h	2004-06-21 23:10:45.807255816 -0700
@@ -16,9 +16,6 @@
 #include <asm/addrspace.h>              /* for KSEG1ADDR() */
 #include <asm/byteorder.h>              /* for cpu_to_le32() */
 
-/* Turn on serial */
-#define	CONFIG_TITAN_SERIAL
-
 /* PCI */
 #define	TITAN_PCI_BASE			0xbb000000
 
@@ -50,8 +47,181 @@
  */
 #define RM9000x2_HTLINK_REG     0xbb000644
 #define RM9000x2_BASE_ADDR      0xbb000000
-#define RM9000x2_OCD_HTCFGA     0x06f8
-#define RM9000x2_OCD_HTCFGD     0x06fc
+
+#define OCD_BASE                0xfb000000UL
+#define OCD_SIZE                0x3000UL
+
+extern unsigned long ocd_base;
+
+/*
+ * OCD Registers
+ */
+#define RM9000x2_OCD_LKB5		0x0128		/* Ethernet */
+#define RM9000x2_OCD_LKM5		0x012c
+
+#define RM9000x2_OCD_LKB7		0x0138		/* HT Region 0 */
+#define RM9000x2_OCD_LKM7		0x013c
+#define RM9000x2_OCD_LKB8		0x0140		/* HT Region 1 */
+#define RM9000x2_OCD_LKM8		0x0144
+
+#define RM9000x2_OCD_LKB9		0x0148		/* Local Bus */
+#define RM9000x2_OCD_LKM9		0x014c
+#define RM9000x2_OCD_LKB10		0x0150
+#define RM9000x2_OCD_LKM10		0x0154
+#define RM9000x2_OCD_LKB11		0x0158
+#define RM9000x2_OCD_LKM11		0x015c
+#define RM9000x2_OCD_LKB12		0x0160
+#define RM9000x2_OCD_LKM12		0x0164
+
+#define RM9000x2_OCD_LKB13		0x0168		/* Scratch RAM */
+#define RM9000x2_OCD_LKM13		0x016c
+
+#define RM9000x2_OCD_LPD0		0x0200		/* Local Bus */
+#define RM9000x2_OCD_LPD1		0x0210
+#define RM9000x2_OCD_LPD2		0x0220
+#define RM9000x2_OCD_LPD3		0x0230
+
+#define RM9000x2_OCD_HTDVID		0x0600	/* HT Device Header */
+#define RM9000x2_OCD_HTSC		0x0604
+#define RM9000x2_OCD_HTCCR		0x0608
+#define RM9000x2_OCD_HTBHL		0x060c
+#define RM9000x2_OCD_HTBAR0		0x0610
+#define RM9000x2_OCD_HTBAR1		0x0614
+#define RM9000x2_OCD_HTBAR2		0x0618
+#define RM9000x2_OCD_HTBAR3		0x061c
+#define RM9000x2_OCD_HTBAR4		0x0620
+#define RM9000x2_OCD_HTBAR5		0x0624
+#define RM9000x2_OCD_HTCBCPT		0x0628
+#define RM9000x2_OCD_HTSDVID		0x062c
+#define RM9000x2_OCD_HTXRA		0x0630
+#define RM9000x2_OCD_HTCAP1		0x0634
+#define RM9000x2_OCD_HTIL		0x063c
+
+#define RM9000x2_OCD_HTLCC		0x0640	/* HT Capability Block */
+#define RM9000x2_OCD_HTLINK		0x0644
+#define RM9000x2_OCD_HTFQREV		0x0648
+
+#define RM9000x2_OCD_HTERCTL		0x0668	/* HT Controller */
+#define RM9000x2_OCD_HTRXDB		0x066c
+#define RM9000x2_OCD_HTIMPED		0x0670
+#define RM9000x2_OCD_HTSWIMP		0x0674
+#define RM9000x2_OCD_HTCAL		0x0678
+
+#define RM9000x2_OCD_HTBAA30		0x0680
+#define RM9000x2_OCD_HTBAA54		0x0684
+#define RM9000x2_OCD_HTMASK0		0x0688
+#define RM9000x2_OCD_HTMASK1		0x068c
+#define RM9000x2_OCD_HTMASK2		0x0690
+#define RM9000x2_OCD_HTMASK3		0x0694
+#define RM9000x2_OCD_HTMASK4		0x0698
+#define RM9000x2_OCD_HTMASK5		0x069c
+
+#define RM9000x2_OCD_HTIFCTL		0x06a0
+#define RM9000x2_OCD_HTPLL		0x06a4
+
+#define RM9000x2_OCD_HTSRI		0x06b0
+#define RM9000x2_OCD_HTRXNUM		0x06b4
+#define RM9000x2_OCD_HTTXNUM		0x06b8
+
+#define RM9000x2_OCD_HTTXCNT		0x06c8
+
+#define RM9000x2_OCD_HTERROR		0x06d8
+#define RM9000x2_OCD_HTRCRCE		0x06dc
+#define RM9000x2_OCD_HTEOI		0x06e0
+
+#define RM9000x2_OCD_CRCR		0x06f0
+
+#define RM9000x2_OCD_HTCFGA		0x06f8
+#define RM9000x2_OCD_HTCFGD		0x06fc
+
+#define RM9000x2_OCD_INTMSG		0x0a00
+
+#define RM9000x2_OCD_INTPIN0		0x0a40
+#define RM9000x2_OCD_INTPIN1		0x0a44
+#define RM9000x2_OCD_INTPIN2		0x0a48
+#define RM9000x2_OCD_INTPIN3		0x0a4c
+#define RM9000x2_OCD_INTPIN4		0x0a50
+#define RM9000x2_OCD_INTPIN5		0x0a54
+#define RM9000x2_OCD_INTPIN6		0x0a58
+#define RM9000x2_OCD_INTPIN7		0x0a5c
+#define RM9000x2_OCD_SEM		0x0a60
+#define RM9000x2_OCD_SEMSET		0x0a64
+#define RM9000x2_OCD_SEMCLR		0x0a68
+
+#define RM9000x2_OCD_TKT		0x0a70
+#define RM9000x2_OCD_TKTINC		0x0a74
+
+#define RM9000x2_OCD_NMICONFIG		0x0ac0		/* Interrupts */
+#define RM9000x2_OCD_INTP0PRI		0x1a80
+#define RM9000x2_OCD_INTP1PRI		0x1a80
+#define RM9000x2_OCD_INTP0STATUS0	0x1b00
+#define RM9000x2_OCD_INTP0MASK0		0x1b04
+#define RM9000x2_OCD_INTP0SET0		0x1b08
+#define RM9000x2_OCD_INTP0CLEAR0	0x1b0c
+#define RM9000x2_OCD_INTP0STATUS1	0x1b10
+#define RM9000x2_OCD_INTP0MASK1		0x1b14
+#define RM9000x2_OCD_INTP0SET1		0x1b18
+#define RM9000x2_OCD_INTP0CLEAR1	0x1b1c
+#define RM9000x2_OCD_INTP0STATUS2	0x1b20
+#define RM9000x2_OCD_INTP0MASK2		0x1b24
+#define RM9000x2_OCD_INTP0SET2		0x1b28
+#define RM9000x2_OCD_INTP0CLEAR2	0x1b2c
+#define RM9000x2_OCD_INTP0STATUS3	0x1b30
+#define RM9000x2_OCD_INTP0MASK3		0x1b34
+#define RM9000x2_OCD_INTP0SET3		0x1b38
+#define RM9000x2_OCD_INTP0CLEAR3	0x1b3c
+#define RM9000x2_OCD_INTP0STATUS4	0x1b40
+#define RM9000x2_OCD_INTP0MASK4		0x1b44
+#define RM9000x2_OCD_INTP0SET4		0x1b48
+#define RM9000x2_OCD_INTP0CLEAR4	0x1b4c
+#define RM9000x2_OCD_INTP0STATUS5	0x1b50
+#define RM9000x2_OCD_INTP0MASK5		0x1b54
+#define RM9000x2_OCD_INTP0SET5		0x1b58
+#define RM9000x2_OCD_INTP0CLEAR5	0x1b5c
+#define RM9000x2_OCD_INTP0STATUS6	0x1b60
+#define RM9000x2_OCD_INTP0MASK6		0x1b64
+#define RM9000x2_OCD_INTP0SET6		0x1b68
+#define RM9000x2_OCD_INTP0CLEAR6	0x1b6c
+#define RM9000x2_OCD_INTP0STATUS7	0x1b70
+#define RM9000x2_OCD_INTP0MASK7		0x1b74
+#define RM9000x2_OCD_INTP0SET7		0x1b78
+#define RM9000x2_OCD_INTP0CLEAR7	0x1b7c
+#define RM9000x2_OCD_INTP1STATUS0	0x2b00
+#define RM9000x2_OCD_INTP1MASK0		0x2b04
+#define RM9000x2_OCD_INTP1SET0		0x2b08
+#define RM9000x2_OCD_INTP1CLEAR0	0x2b0c
+#define RM9000x2_OCD_INTP1STATUS1	0x2b10
+#define RM9000x2_OCD_INTP1MASK1		0x2b14
+#define RM9000x2_OCD_INTP1SET1		0x2b18
+#define RM9000x2_OCD_INTP1CLEAR1	0x2b1c
+#define RM9000x2_OCD_INTP1STATUS2	0x2b20
+#define RM9000x2_OCD_INTP1MASK2		0x2b24
+#define RM9000x2_OCD_INTP1SET2		0x2b28
+#define RM9000x2_OCD_INTP1CLEAR2	0x2b2c
+#define RM9000x2_OCD_INTP1STATUS3	0x2b30
+#define RM9000x2_OCD_INTP1MASK3		0x2b34
+#define RM9000x2_OCD_INTP1SET3		0x2b38
+#define RM9000x2_OCD_INTP1CLEAR3	0x2b3c
+#define RM9000x2_OCD_INTP1STATUS4	0x2b40
+#define RM9000x2_OCD_INTP1MASK4		0x2b44
+#define RM9000x2_OCD_INTP1SET4		0x2b48
+#define RM9000x2_OCD_INTP1CLEAR4	0x2b4c
+#define RM9000x2_OCD_INTP1STATUS5	0x2b50
+#define RM9000x2_OCD_INTP1MASK5		0x2b54
+#define RM9000x2_OCD_INTP1SET5		0x2b58
+#define RM9000x2_OCD_INTP1CLEAR5	0x2b5c
+#define RM9000x2_OCD_INTP1STATUS6	0x2b60
+#define RM9000x2_OCD_INTP1MASK6		0x2b64
+#define RM9000x2_OCD_INTP1SET6		0x2b68
+#define RM9000x2_OCD_INTP1CLEAR6	0x2b6c
+#define RM9000x2_OCD_INTP1STATUS7	0x2b70
+#define RM9000x2_OCD_INTP1MASK7		0x2b74
+#define RM9000x2_OCD_INTP1SET7		0x2b78
+#define RM9000x2_OCD_INTP1CLEAR7	0x2b7c
+
+#define OCD_READ(reg)		(*(volatile unsigned int *)(ocd_base + (reg)))
+#define OCD_WRITE(reg, val)					\
+	do { *(volatile unsigned int *)(ocd_base + (reg)) = (val); } while (0)
 
 /*
  * Hypertransport specific macros
@@ -65,4 +235,3 @@
 #define RM9K_READ_16(ofs, val)  *(val) = *(volatile u16 *)(RM9000x2_BASE_ADDR+ofs)
 
 #endif 
-
diff -puN include/asm-mips/unistd.h~mips-update include/asm-mips/unistd.h
--- 25/include/asm-mips/unistd.h~mips-update	2004-06-21 23:10:45.514300352 -0700
+++ 25-akpm/include/asm-mips/unistd.h	2004-06-21 23:10:45.810255360 -0700
@@ -297,16 +297,17 @@
 #define __NR_mq_timedreceive		(__NR_Linux + 274)
 #define __NR_mq_notify			(__NR_Linux + 275)
 #define __NR_mq_getsetattr		(__NR_Linux + 276)
+#define __NR_vserver			(__NR_Linux + 277)
 
 /*
  * Offset of the last Linux o32 flavoured syscall
  */
-#define __NR_Linux_syscalls		276
+#define __NR_Linux_syscalls		277
 
 #endif /* _MIPS_SIM == _MIPS_SIM_ABI32 */
 
 #define __NR_O32_Linux			4000
-#define __NR_O32_Linux_syscalls		276
+#define __NR_O32_Linux_syscalls		277
 
 #if _MIPS_SIM == _MIPS_SIM_ABI64
 
@@ -550,16 +551,17 @@
 #define __NR_mq_timedreceive		(__NR_Linux + 233)
 #define __NR_mq_notify			(__NR_Linux + 234)
 #define __NR_mq_getsetattr		(__NR_Linux + 235)
+#define __NR_vserver			(__NR_Linux + 236)
 
 /*
  * Offset of the last Linux flavoured syscall
  */
-#define __NR_Linux_syscalls		235
+#define __NR_Linux_syscalls		236
 
 #endif /* _MIPS_SIM == _MIPS_SIM_ABI64 */
 
 #define __NR_64_Linux			5000
-#define __NR_64_Linux_syscalls		235
+#define __NR_64_Linux_syscalls		236
 
 #if _MIPS_SIM == _MIPS_SIM_NABI32
 
@@ -807,16 +809,17 @@
 #define __NR_mq_timedreceive		(__NR_Linux + 237)
 #define __NR_mq_notify			(__NR_Linux + 238)
 #define __NR_mq_getsetattr		(__NR_Linux + 239)
+#define __NR_vserver			(__NR_Linux + 240)
 
 /*
  * Offset of the last N32 flavoured syscall
  */
-#define __NR_Linux_syscalls		239
+#define __NR_Linux_syscalls		240
 
 #endif /* _MIPS_SIM == _MIPS_SIM_NABI32 */
 
 #define __NR_N32_Linux			6000
-#define __NR_N32_Linux_syscalls		239
+#define __NR_N32_Linux_syscalls		240
 
 #ifndef __ASSEMBLY__
 
diff -puN include/asm-mips/vr41xx/capcella.h~mips-update include/asm-mips/vr41xx/capcella.h
--- 25/include/asm-mips/vr41xx/capcella.h~mips-update	2004-06-21 23:10:45.516300048 -0700
+++ 25-akpm/include/asm-mips/vr41xx/capcella.h	2004-06-21 23:10:45.810255360 -0700
@@ -1,54 +1,28 @@
 /*
- * FILE NAME
- *	include/asm-mips/vr41xx/capcella.h
+ *  capcella.h, Include file for ZAO Networks Capcella.
  *
- * BRIEF MODULE DESCRIPTION
- *	Include file for ZAO Networks Capcella.
+ *  Copyright (C) 2002-2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
  *
- * Copyright 2002,2003 Yoichi Yuasa
- *                yuasa@hh.iij4u.or.jp
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
  *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License as published by the
- *  Free Software Foundation; either version 2 of the License, or (at your
- *  option) any later version.
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 #ifndef __ZAO_CAPCELLA_H
 #define __ZAO_CAPCELLA_H
 
-#include <asm/addrspace.h>
 #include <asm/vr41xx/vr41xx.h>
 
 /*
- * Board specific address mapping
- */
-#define VR41XX_PCI_MEM1_BASE		0x10000000
-#define VR41XX_PCI_MEM1_SIZE		0x04000000
-#define VR41XX_PCI_MEM1_MASK		0x7c000000
-
-#define VR41XX_PCI_MEM2_BASE		0x14000000
-#define VR41XX_PCI_MEM2_SIZE		0x02000000
-#define VR41XX_PCI_MEM2_MASK		0x7e000000
-
-#define VR41XX_PCI_IO_BASE		0x16000000
-#define VR41XX_PCI_IO_SIZE		0x02000000
-#define VR41XX_PCI_IO_MASK		0x7e000000
-
-#define VR41XX_PCI_IO_START		0x01000000
-#define VR41XX_PCI_IO_END		0x01ffffff
-
-#define VR41XX_PCI_MEM_START		0x12000000
-#define VR41XX_PCI_MEM_END		0x15ffffff
-
-#define IO_PORT_BASE			KSEG1ADDR(VR41XX_PCI_IO_BASE)
-#define IO_PORT_RESOURCE_START		0
-#define IO_PORT_RESOURCE_END		VR41XX_PCI_IO_SIZE
-#define IO_MEM1_RESOURCE_START		VR41XX_PCI_MEM1_BASE
-#define IO_MEM1_RESOURCE_END		(VR41XX_PCI_MEM1_BASE + VR41XX_PCI_MEM1_SIZE)
-#define IO_MEM2_RESOURCE_START		VR41XX_PCI_MEM2_BASE
-#define IO_MEM2_RESOURCE_END		(VR41XX_PCI_MEM2_BASE + VR41XX_PCI_MEM2_SIZE)
-
-/*
  * General-Purpose I/O Pin Number
  */
 #define PC104PLUS_INTA_PIN		2
diff -puN include/asm-mips/vr41xx/mpc30x.h~mips-update include/asm-mips/vr41xx/mpc30x.h
--- 25/include/asm-mips/vr41xx/mpc30x.h~mips-update	2004-06-21 23:10:45.518299744 -0700
+++ 25-akpm/include/asm-mips/vr41xx/mpc30x.h	2004-06-21 23:10:45.812255056 -0700
@@ -1,54 +1,28 @@
 /*
- * FILE NAME
- *	include/asm-mips/vr41xx/mpc30x.h
+ *  mpc30x.h, Include file for Victor MP-C303/304.
  *
- * BRIEF MODULE DESCRIPTION
- *	Include file for Victor MP-C303/304.
+ *  Copyright (C) 2002-2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
  *
- * Copyright 2002,2003 Yoichi Yuasa
- *                yuasa@hh.iij4u.or.jp
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
  *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License as published by the
- *  Free Software Foundation; either version 2 of the License, or (at your
- *  option) any later version.
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 #ifndef __VICTOR_MPC30X_H
 #define __VICTOR_MPC30X_H
 
-#include <asm/addrspace.h>
 #include <asm/vr41xx/vr41xx.h>
 
 /*
- * Board specific address mapping
- */
-#define VR41XX_PCI_MEM1_BASE		0x10000000
-#define VR41XX_PCI_MEM1_SIZE		0x04000000
-#define VR41XX_PCI_MEM1_MASK		0x7c000000
-
-#define VR41XX_PCI_MEM2_BASE		0x14000000
-#define VR41XX_PCI_MEM2_SIZE		0x02000000
-#define VR41XX_PCI_MEM2_MASK		0x7e000000
-
-#define VR41XX_PCI_IO_BASE		0x16000000
-#define VR41XX_PCI_IO_SIZE		0x02000000
-#define VR41XX_PCI_IO_MASK		0x7e000000
-
-#define VR41XX_PCI_IO_START		0x01000000
-#define VR41XX_PCI_IO_END		0x01ffffff
-
-#define VR41XX_PCI_MEM_START		0x12000000
-#define VR41XX_PCI_MEM_END		0x15ffffff
-
-#define IO_PORT_BASE			KSEG1ADDR(VR41XX_PCI_IO_BASE)
-#define IO_PORT_RESOURCE_START		0
-#define IO_PORT_RESOURCE_END		VR41XX_PCI_IO_SIZE
-#define IO_MEM1_RESOURCE_START		VR41XX_PCI_MEM1_BASE
-#define IO_MEM1_RESOURCE_END		(VR41XX_PCI_MEM1_BASE + VR41XX_PCI_MEM1_SIZE)
-#define IO_MEM2_RESOURCE_START		VR41XX_PCI_MEM2_BASE
-#define IO_MEM2_RESOURCE_END		(VR41XX_PCI_MEM2_BASE + VR41XX_PCI_MEM2_SIZE)
-
-/*
  * General-Purpose I/O Pin Number
  */
 #define VRC4173_PIN			1
diff -puN /dev/null include/asm-mips/vr41xx/tb0219.h
--- /dev/null	2003-09-15 06:40:47.000000000 -0700
+++ 25-akpm/include/asm-mips/vr41xx/tb0219.h	2004-06-21 23:10:45.813254904 -0700
@@ -0,0 +1,42 @@
+/*
+ *  tb0219.h, Include file for TANBAC TB0219.
+ *
+ *  Copyright (C) 2002-2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *
+ *  Modified for TANBAC TB0219:
+ *  Copyright (C) 2003 Megasolution Inc.  <matsu@megasolution.jp>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __TANBAC_TB0219_H
+#define __TANBAC_TB0219_H
+
+#include <asm/vr41xx/vr41xx.h>
+
+/*
+ * General-Purpose I/O Pin Number
+ */
+#define TB0219_PCI_SLOT1_PIN		2
+#define TB0219_PCI_SLOT2_PIN		3
+#define TB0219_PCI_SLOT3_PIN		4
+
+/*
+ * Interrupt Number
+ */
+#define TB0219_PCI_SLOT1_IRQ		GIU_IRQ(TB0219_PCI_SLOT1_PIN)
+#define TB0219_PCI_SLOT2_IRQ		GIU_IRQ(TB0219_PCI_SLOT2_PIN)
+#define TB0219_PCI_SLOT3_IRQ		GIU_IRQ(TB0219_PCI_SLOT3_PIN)
+
+#endif /* __TANBAC_TB0219_H */
diff -puN include/asm-mips/vr41xx/tb0226.h~mips-update include/asm-mips/vr41xx/tb0226.h
--- 25/include/asm-mips/vr41xx/tb0226.h~mips-update	2004-06-21 23:10:45.520299440 -0700
+++ 25-akpm/include/asm-mips/vr41xx/tb0226.h	2004-06-21 23:10:45.815254600 -0700
@@ -1,54 +1,28 @@
 /*
- * FILE NAME
- *	include/asm-mips/vr41xx/tb0226.h
+ *  tb0226.h, Include file for TANBAC TB0226.
  *
- * BRIEF MODULE DESCRIPTION
- *	Include file for TANBAC TB0226.
+ *  Copyright (C) 2002-2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
  *
- * Copyright 2002,2003 Yoichi Yuasa
- *                yuasa@hh.iij4u.or.jp
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
  *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License as published by the
- *  Free Software Foundation; either version 2 of the License, or (at your
- *  option) any later version.
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 #ifndef __TANBAC_TB0226_H
 #define __TANBAC_TB0226_H
 
-#include <asm/addrspace.h>
 #include <asm/vr41xx/vr41xx.h>
 
 /*
- * Board specific address mapping
- */
-#define VR41XX_PCI_MEM1_BASE		0x10000000
-#define VR41XX_PCI_MEM1_SIZE		0x04000000
-#define VR41XX_PCI_MEM1_MASK		0x7c000000
-
-#define VR41XX_PCI_MEM2_BASE		0x14000000
-#define VR41XX_PCI_MEM2_SIZE		0x02000000
-#define VR41XX_PCI_MEM2_MASK		0x7e000000
-
-#define VR41XX_PCI_IO_BASE		0x16000000
-#define VR41XX_PCI_IO_SIZE		0x02000000
-#define VR41XX_PCI_IO_MASK		0x7e000000
-
-#define VR41XX_PCI_IO_START		0x01000000
-#define VR41XX_PCI_IO_END		0x01ffffff
-
-#define VR41XX_PCI_MEM_START		0x12000000
-#define VR41XX_PCI_MEM_END		0x15ffffff
-
-#define IO_PORT_BASE			KSEG1ADDR(VR41XX_PCI_IO_BASE)
-#define IO_PORT_RESOURCE_START		0
-#define IO_PORT_RESOURCE_END		VR41XX_PCI_IO_SIZE
-#define IO_MEM1_RESOURCE_START		VR41XX_PCI_MEM1_BASE
-#define IO_MEM1_RESOURCE_END		(VR41XX_PCI_MEM1_BASE + VR41XX_PCI_MEM1_SIZE)
-#define IO_MEM2_RESOURCE_START		VR41XX_PCI_MEM2_BASE
-#define IO_MEM2_RESOURCE_END		(VR41XX_PCI_MEM2_BASE + VR41XX_PCI_MEM2_SIZE)
-
-/*
  * General-Purpose I/O Pin Number
  */
 #define GD82559_1_PIN			2
diff -L include/asm-mips/vr41xx/tb0229.h -puN include/asm-mips/vr41xx/tb0229.h~mips-update /dev/null
--- 25/include/asm-mips/vr41xx/tb0229.h
+++ /dev/null	2003-09-15 06:40:47.000000000 -0700
@@ -1,73 +0,0 @@
-/*
- * FILE NAME
- *	include/asm-mips/vr41xx/tb0229.h
- *
- * BRIEF MODULE DESCRIPTION
- *	Include file for TANBAC TB0229 and TB0219.
- *
- * Copyright 2002,2003 Yoichi Yuasa
- *                yuasa@hh.iij4u.or.jp
- *
- * Modified for TANBAC TB0229:
- * Copyright 2003 Megasolution Inc.
- *                matsu@megasolution.jp
- *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License as published by the
- *  Free Software Foundation; either version 2 of the License, or (at your
- *  option) any later version.
- */
-#ifndef __TANBAC_TB0229_H
-#define __TANBAC_TB0229_H
-
-#include <asm/addrspace.h>
-#include <asm/vr41xx/vr41xx.h>
-
-/*
- * Board specific address mapping
- */
-#define VR41XX_PCI_MEM1_BASE		0x10000000
-#define VR41XX_PCI_MEM1_SIZE		0x04000000
-#define VR41XX_PCI_MEM1_MASK		0x7c000000
-
-#define VR41XX_PCI_MEM2_BASE		0x14000000
-#define VR41XX_PCI_MEM2_SIZE		0x02000000
-#define VR41XX_PCI_MEM2_MASK		0x7e000000
-
-#define VR41XX_PCI_IO_BASE		0x16000000
-#define VR41XX_PCI_IO_SIZE		0x02000000
-#define VR41XX_PCI_IO_MASK		0x7e000000
-
-#define VR41XX_PCI_IO_START		0x01000000
-#define VR41XX_PCI_IO_END		0x01ffffff
-
-#define VR41XX_PCI_MEM_START		0x12000000
-#define VR41XX_PCI_MEM_END		0x15ffffff
-
-#define IO_PORT_BASE			KSEG1ADDR(VR41XX_PCI_IO_BASE)
-#define IO_PORT_RESOURCE_START		0
-#define IO_PORT_RESOURCE_END		VR41XX_PCI_IO_SIZE
-#define IO_MEM1_RESOURCE_START		VR41XX_PCI_MEM1_BASE
-#define IO_MEM1_RESOURCE_END		(VR41XX_PCI_MEM1_BASE + VR41XX_PCI_MEM1_SIZE)
-#define IO_MEM2_RESOURCE_START		VR41XX_PCI_MEM2_BASE
-#define IO_MEM2_RESOURCE_END		(VR41XX_PCI_MEM2_BASE + VR41XX_PCI_MEM2_SIZE)
-
-/*
- * General-Purpose I/O Pin Number
- */
-#define TB0219_PCI_SLOT1_PIN		2
-#define TB0219_PCI_SLOT2_PIN		3
-#define TB0219_PCI_SLOT3_PIN		4
-
-/*
- * Interrupt Number
- */
-#define TB0219_PCI_SLOT1_IRQ		GIU_IRQ(TB0219_PCI_SLOT1_PIN)
-#define TB0219_PCI_SLOT2_IRQ		GIU_IRQ(TB0219_PCI_SLOT2_PIN)
-#define TB0219_PCI_SLOT3_IRQ		GIU_IRQ(TB0219_PCI_SLOT3_PIN)
-
-#define TB0219_RESET_REGS		KSEG1ADDR(0x0a00000e)
-
-extern void tanbac_tb0229_restart(char *command);
-
-#endif /* __TANBAC_TB0229_H */
diff -puN include/asm-mips/vr41xx/vr41xx.h~mips-update include/asm-mips/vr41xx/vr41xx.h
--- 25/include/asm-mips/vr41xx/vr41xx.h~mips-update	2004-06-21 23:10:45.524298832 -0700
+++ 25-akpm/include/asm-mips/vr41xx/vr41xx.h	2004-06-21 23:10:45.818254144 -0700
@@ -43,12 +43,6 @@
 #define PRID_VR4133		0x00000c84
 
 /*
- * Memory resource
- */
-#define IO_MEM_RESOURCE_START	0UL
-#define IO_MEM_RESOURCE_END	0x1fffffffUL
-
-/*
  * Bus Control Uint
  */
 extern unsigned long vr41xx_get_vtclock_frequency(void);
@@ -136,8 +130,71 @@ extern void vr41xx_mask_clock(vr41xx_clo
 extern int vr41xx_set_intassign(unsigned int irq, unsigned char intassign);
 extern int vr41xx_cascade_irq(unsigned int irq, int (*get_irq_number)(int irq));
 
-extern void vr41xx_enable_dsiuint(void);
-extern void vr41xx_disable_dsiuint(void);
+#define PIUINT_COMMAND		0x0040
+#define PIUINT_DATA		0x0020
+#define PIUINT_PAGE1		0x0010
+#define PIUINT_PAGE0		0x0008
+#define PIUINT_DATALOST		0x0004
+#define PIUINT_STATUSCHANGE	0x0001
+
+extern void vr41xx_enable_piuint(uint16_t mask);
+extern void vr41xx_disable_piuint(uint16_t mask);
+
+#define AIUINT_INPUT_DMAEND	0x0800
+#define AIUINT_INPUT_DMAHALT	0x0400
+#define AIUINT_INPUT_DATALOST	0x0200
+#define AIUINT_INPUT_DATA	0x0100
+#define AIUINT_OUTPUT_DMAEND	0x0008
+#define AIUINT_OUTPUT_DMAHALT	0x0004
+#define AIUINT_OUTPUT_NODATA	0x0002
+
+extern void vr41xx_enable_aiuint(uint16_t mask);
+extern void vr41xx_disable_aiuint(uint16_t mask);
+
+#define KIUINT_DATALOST		0x0004
+#define KIUINT_DATAREADY	0x0002
+#define KIUINT_SCAN		0x0001
+
+extern void vr41xx_enable_kiuint(uint16_t mask);
+extern void vr41xx_disable_kiuint(uint16_t mask);
+
+#define DSIUINT_CTS		0x0800
+#define DSIUINT_RXERR		0x0400
+#define DSIUINT_RX		0x0200
+#define DSIUINT_TX		0x0100
+#define DSIUINT_ALL		0x0f00
+
+extern void vr41xx_enable_dsiuint(uint16_t mask);
+extern void vr41xx_disable_dsiuint(uint16_t mask);
+
+#define FIRINT_UNIT		0x0010
+#define FIRINT_RX_DMAEND	0x0008
+#define FIRINT_RX_DMAHALT	0x0004
+#define FIRINT_TX_DMAEND	0x0002
+#define FIRINT_TX_DMAHALT	0x0001
+
+extern void vr41xx_enable_firint(uint16_t mask);
+extern void vr41xx_disable_firint(uint16_t mask);
+
+extern void vr41xx_enable_pciint(void);
+extern void vr41xx_disable_pciint(void);
+
+extern void vr41xx_enable_scuint(void);
+extern void vr41xx_disable_scuint(void);
+
+#define CSIINT_TX_DMAEND	0x0040
+#define CSIINT_TX_DMAHALT	0x0020
+#define CSIINT_TX_DATA		0x0010
+#define CSIINT_TX_FIFOEMPTY	0x0008
+#define CSIINT_RX_DMAEND	0x0004
+#define CSIINT_RX_DMAHALT	0x0002
+#define CSIINT_RX_FIFOEMPTY	0x0001
+
+extern void vr41xx_enable_csiint(uint16_t mask);
+extern void vr41xx_disable_csiint(uint16_t mask);
+
+extern void vr41xx_enable_bcuint(void);
+extern void vr41xx_disable_bcuint(void);
 
 /*
  * Power Management Unit
@@ -220,18 +277,71 @@ extern void vr41xx_dsiu_init(void);
 /*
  * PCI Control Unit
  */
-struct vr41xx_pci_address_space {
-	u32 internal_base;
-	u32 address_mask;
-	u32 pci_base;
+#define PCI_MASTER_ADDRESS_MASK	0x7fffffffU
+
+struct pci_master_address_conversion {
+	uint32_t bus_base_address;
+	uint32_t address_mask;
+	uint32_t pci_base_address;
+};
+
+struct pci_target_address_conversion {
+	uint32_t address_mask;
+	uint32_t bus_base_address;
+};
+
+typedef enum {
+	CANNOT_LOCK_FROM_DEVICE,
+	CAN_LOCK_FROM_DEVICE,
+} pci_exclusive_access_t;
+
+struct pci_mailbox_address {
+	uint32_t base_address;
+};
+
+struct pci_target_address_window {
+	uint32_t base_address;
 };
 
-struct vr41xx_pci_address_map {
-	struct vr41xx_pci_address_space *mem1;
-	struct vr41xx_pci_address_space *mem2;
-	struct vr41xx_pci_address_space *io;
+typedef enum {
+	PCI_ARBITRATION_MODE_FAIR,
+	PCI_ARBITRATION_MODE_ALTERNATE_0,
+	PCI_ARBITRATION_MODE_ALTERNATE_B,
+} pci_arbiter_priority_control_t;
+
+typedef enum {
+	PCI_TAKE_AWAY_GNT_DISABLE,
+	PCI_TAKE_AWAY_GNT_ENABLE,
+} pci_take_away_gnt_mode_t;
+
+struct pci_controller_unit_setup {
+	struct pci_master_address_conversion *master_memory1;
+	struct pci_master_address_conversion *master_memory2;
+
+	struct pci_target_address_conversion *target_memory1;
+	struct pci_target_address_conversion *target_memory2;
+
+	struct pci_master_address_conversion *master_io;
+
+	pci_exclusive_access_t exclusive_access;
+
+	uint32_t pci_clock_max;
+	uint8_t wait_time_limit_from_irdy_to_trdy;	/* Only VR4122 is supported */
+
+	struct pci_mailbox_address *mailbox;
+	struct pci_target_address_window *target_window1;
+	struct pci_target_address_window *target_window2;
+
+	uint8_t master_latency_timer;
+	uint8_t retry_limit;
+
+	pci_arbiter_priority_control_t arbiter_priority_control;
+	pci_take_away_gnt_mode_t take_away_gnt_mode;
+
+	struct resource *mem_resource;
+	struct resource *io_resource;
 };
 
-extern void vr41xx_pciu_init(struct vr41xx_pci_address_map *map);
+extern void vr41xx_pciu_setup(struct pci_controller_unit_setup *setup);
 
 #endif /* __NEC_VR41XX_H */
diff -puN include/asm-mips/vr41xx/vrc4173.h~mips-update include/asm-mips/vr41xx/vrc4173.h
--- 25/include/asm-mips/vr41xx/vrc4173.h~mips-update	2004-06-21 23:10:45.525298680 -0700
+++ 25-akpm/include/asm-mips/vr41xx/vrc4173.h	2004-06-21 23:10:45.819253992 -0700
@@ -1,19 +1,24 @@
 /*
- * FILE NAME
- *	include/asm-mips/vr41xx/vrc4173.h
+ *  vrc4173.h, Include file for NEC VRC4173.
  *
- * BRIEF MODULE DESCRIPTION
- *	Include file for NEC VRC4173.
+ *  Copyright (C) 2000  Michael R. McDonald
+ *  Copyright (C) 2001-2003 Montavista Software Inc.
+ *    Author: Yoichi Yuasa <yyuasa@mvista.com, or source@mvista.com>
+ *  Copyright (C) 2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
  *
- * This file is subject to the terms and conditions of the GNU General Public
- * License.  See the file "COPYING" in the main directory of this archive
- * for more details.
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
  *
- * Copyright (C) 2000 by Michael R. McDonald
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
  *
- * Copyright 2001-2003 Montavista Software Inc.
- * Author: Yoichi Yuasa
- *         yyuasa@mvista.com or source@mvista.com
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 #ifndef __NEC_VRC4173_H 
 #define __NEC_VRC4173_H 
@@ -72,35 +77,38 @@ extern unsigned long vrc4173_io_offset;
 /*
  * Clock Mask Unit
  */
-#define VRC4173_PIU_CLOCK		0x0001
-#define VRC4173_KIU_CLOCK		0x0002
-#define VRC4173_AIU_CLOCK		0x0004
-#define VRC4173_PS2CH1_CLOCK		0x0008
-#define VRC4173_PS2CH2_CLOCK		0x0010
-#define VRC4173_USBU_PCI_CLOCK		0x0020
-#define VRC4173_CARDU1_PCI_CLOCK	0x0040
-#define VRC4173_CARDU2_PCI_CLOCK	0x0080
-#define VRC4173_AC97U_PCI_CLOCK		0x0100
-#define VRC4173_USBU_48MHz_CLOCK	0x0400
-#define VRC4173_EXT_48MHz_CLOCK		0x0800
-#define VRC4173_48MHz_CLOCK		0x1000
+typedef enum vrc4173_clock {
+	VRC4173_PIU_CLOCK,
+	VRC4173_KIU_CLOCK,
+	VRC4173_AIU_CLOCK,
+	VRC4173_PS2_CH1_CLOCK,
+	VRC4173_PS2_CH2_CLOCK,
+	VRC4173_USBU_PCI_CLOCK,
+	VRC4173_CARDU1_PCI_CLOCK,
+	VRC4173_CARDU2_PCI_CLOCK,
+	VRC4173_AC97U_PCI_CLOCK,
+	VRC4173_USBU_48MHz_CLOCK,
+	VRC4173_EXT_48MHz_CLOCK,
+	VRC4173_48MHz_CLOCK,
+} vrc4173_clock_t;
 
-extern void vrc4173_clock_supply(u16 mask);
-extern void vrc4173_clock_mask(u16 mask);
+extern void vrc4173_supply_clock(vrc4173_clock_t clock);
+extern void vrc4173_mask_clock(vrc4173_clock_t clock);
 
 /*
  * General-Purpose I/O Unit
  */
-enum {
-	PS2CH1_SELECT,
-	PS2CH2_SELECT,
-	TOUCHPANEL_SELECT,
-	KIU8_SELECT,
-	KIU10_SELECT,
-	KIU12_SELECT,
-	GPIO_SELECT
-};
+typedef enum vrc4173_function {
+	PS2_CHANNEL1,
+	PS2_CHANNEL2,
+	TOUCHPANEL,
+	KEYBOARD_8SCANLINES,
+	KEYBOARD_10SCANLINES,
+	KEYBOARD_12SCANLINES,
+	GPIO_0_15PINS,
+	GPIO_16_20PINS,
+} vrc4173_function_t;
 
-extern void vrc4173_select_function(int func);
+extern void vrc4173_select_function(vrc4173_function_t function);
 
 #endif /* __NEC_VRC4173_H */
_
