bk://linux-scsi.bkbits.net/scsi-misc-2.6
hch@lst.de|ChangeSet|20040620135832|17843 hch

# This is a BitKeeper generated diff -Nru style patch.
#
# ChangeSet
#   2004/06/20 13:21:22-07:00 akpm@bix.(none) 
#   Merge bk://linux-scsi.bkbits.net/scsi-misc-2.6
#   into bix.(none):/usr/src/bk-scsi
# 
# drivers/scsi/scsi_syms.c
#   2004/06/20 13:21:19-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# drivers/scsi/scsi_ioctl.c
#   2004/06/20 13:21:19-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# drivers/scsi/pcmcia/nsp_cs.c
#   2004/06/20 13:21:19-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# drivers/message/fusion/mptctl.c
#   2004/06/20 13:21:19-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/06/20 08:58:32-05:00 hch@lst.de 
#   [PATCH] switch scsi core and sd to <scsi/*.h> headers
#   
#   Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>
# 
# drivers/scsi/sd.c
#   2004/06/19 09:38:40-05:00 hch@lst.de +11 -9
#   switch scsi core and sd to <scsi/*.h> headers
# 
# drivers/scsi/scsicam.c
#   2004/06/19 09:45:02-05:00 hch@lst.de +2 -3
#   switch scsi core and sd to <scsi/*.h> headers
# 
# drivers/scsi/scsi_sysfs.c
#   2004/06/19 09:50:30-05:00 hch@lst.de +2 -1
#   switch scsi core and sd to <scsi/*.h> headers
# 
# drivers/scsi/scsi_syms.c
#   2004/06/19 09:52:12-05:00 hch@lst.de +5 -14
#   switch scsi core and sd to <scsi/*.h> headers
# 
# drivers/scsi/scsi_scan.c
#   2004/06/19 09:49:19-05:00 hch@lst.de +3 -1
#   switch scsi core and sd to <scsi/*.h> headers
# 
# drivers/scsi/scsi_proc.c
#   2004/06/19 09:55:42-05:00 hch@lst.de +2 -1
#   switch scsi core and sd to <scsi/*.h> headers
# 
# drivers/scsi/scsi_lib.c
#   2004/06/19 09:40:25-05:00 hch@lst.de +8 -4
#   switch scsi core and sd to <scsi/*.h> headers
# 
# drivers/scsi/scsi_ioctl.c
#   2004/06/19 09:42:28-05:00 hch@lst.de +6 -8
#   switch scsi core and sd to <scsi/*.h> headers
# 
# drivers/scsi/scsi_error.c
#   2004/06/19 09:47:16-05:00 hch@lst.de +7 -3
#   switch scsi core and sd to <scsi/*.h> headers
# 
# drivers/scsi/scsi_devinfo.c
#   2004/06/19 09:48:22-05:00 hch@lst.de +3 -2
#   switch scsi core and sd to <scsi/*.h> headers
# 
# drivers/scsi/scsi.c
#   2004/06/19 09:38:34-05:00 hch@lst.de +10 -4
#   switch scsi core and sd to <scsi/*.h> headers
# 
# drivers/scsi/hosts.c
#   2004/06/19 09:35:38-05:00 hch@lst.de +1 -3
#   switch scsi core and sd to <scsi/*.h> headers
# 
# drivers/scsi/constants.c
#   2004/06/19 09:43:56-05:00 hch@lst.de +6 -3
#   switch scsi core and sd to <scsi/*.h> headers
# 
# ChangeSet
#   2004/06/20 08:54:39-05:00 arjanv@redhat.com 
#   [PATCH] final hosts.h usage removal
#   
#   the patch below finishes off the removal of the obsolete hosts.h usage, and
#   now that the users are gone, it's safe to turn on the warning to
#   prevent accidental future use... Please apply
#   
#   Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>
# 
# drivers/usb/image/microtek.c
#   2004/06/19 10:25:20-05:00 arjanv@redhat.com +1 -1
#   final hosts.h usage removal
# 
# drivers/usb/image/hpusbscsi.c
#   2004/06/19 10:25:04-05:00 arjanv@redhat.com +1 -1
#   final hosts.h usage removal
# 
# drivers/scsi/pcmcia/nsp_cs.c
#   2004/06/19 10:26:24-05:00 arjanv@redhat.com +1 -1
#   final hosts.h usage removal
# 
# drivers/scsi/hosts.h
#   2004/06/19 19:00:00-05:00 arjanv@redhat.com +1 -1
#   final hosts.h usage removal
# 
# drivers/scsi/gdth.c
#   2004/06/19 10:26:00-05:00 arjanv@redhat.com +1 -1
#   final hosts.h usage removal
# 
# drivers/scsi/arm/powertec.c
#   2004/06/19 10:53:32-05:00 arjanv@redhat.com +1 -1
#   final hosts.h usage removal
# 
# drivers/scsi/arm/oak.c
#   2004/06/19 10:53:31-05:00 arjanv@redhat.com +1 -1
#   final hosts.h usage removal
# 
# drivers/scsi/arm/fas216.c
#   2004/06/19 10:53:28-05:00 arjanv@redhat.com +1 -1
#   final hosts.h usage removal
# 
# drivers/scsi/arm/eesox.c
#   2004/06/19 10:53:26-05:00 arjanv@redhat.com +1 -1
#   final hosts.h usage removal
# 
# drivers/scsi/arm/ecoscsi.c
#   2004/06/19 10:53:25-05:00 arjanv@redhat.com +1 -1
#   final hosts.h usage removal
# 
# drivers/scsi/arm/cumana_2.c
#   2004/06/19 10:53:24-05:00 arjanv@redhat.com +1 -1
#   final hosts.h usage removal
# 
# drivers/scsi/arm/cumana_1.c
#   2004/06/19 10:53:23-05:00 arjanv@redhat.com +1 -1
#   final hosts.h usage removal
# 
# drivers/scsi/arm/arxescsi.c
#   2004/06/19 10:53:22-05:00 arjanv@redhat.com +1 -1
#   final hosts.h usage removal
# 
# drivers/scsi/arm/acornscsi.c
#   2004/06/19 10:53:20-05:00 arjanv@redhat.com +1 -1
#   final hosts.h usage removal
# 
# drivers/scsi/aha152x.c
#   2004/06/19 10:25:38-05:00 arjanv@redhat.com +1 -1
#   final hosts.h usage removal
# 
# drivers/net/fc/iph5526.c
#   2004/06/19 10:54:02-05:00 arjanv@redhat.com +1 -1
#   final hosts.h usage removal
# 
# drivers/message/fusion/mptctl.c
#   2004/06/19 10:24:45-05:00 arjanv@redhat.com +1 -1
#   final hosts.h usage removal
# 
# drivers/ieee1394/sbp2.c
#   2004/06/19 10:24:29-05:00 arjanv@redhat.com +1 -1
#   final hosts.h usage removal
# 
# drivers/fc4/fc.c
#   2004/06/19 10:53:00-05:00 arjanv@redhat.com +1 -1
#   final hosts.h usage removal
# 
# drivers/block/cciss_scsi.c
#   2004/06/19 10:24:11-05:00 arjanv@redhat.com +1 -1
#   final hosts.h usage removal
# 
# ChangeSet
#   2004/06/18 18:50:56-05:00 brking@us.ibm.com 
#   [PATCH] ipr bump version to 2.0.10
#   
#   Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>
# 
# drivers/scsi/ipr.h
#   2004/06/07 17:11:42-05:00 brking@us.ibm.com +2 -2
#   ipr bump version to 2.0.10
# 
# ChangeSet
#   2004/06/18 18:49:28-05:00 brking@us.ibm.com 
#   [PATCH] ipr only tcq cancel all
#   
#   Some SCSI-IDE cdrom drives take up to 15 seconds to respond following
#   an abort being issued to them. This patch changes ipr to only send
#   a cancel all to a device as part of request sense processing when
#   the device is running tagged command queueing.
#   
#   Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>
# 
# drivers/scsi/ipr.c
#   2004/06/07 17:11:05-05:00 brking@us.ibm.com +5 -0
#   ipr only tcq cancel all
# 
# ChangeSet
#   2004/06/18 18:47:36-05:00 brking@us.ibm.com 
#   [PATCH] ipr abort hang fix
#   
#   The following patch fixes a hang that occurs when an abort
#   is issued by the midlayer. The hang is the result of overriding
#   a field in the union of the ipr_cmd struct. It is fixed by moving
#   this pointer outside of the union, since it is not mutually exclusive
#   with the other fields in the union.
#   
#   Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>
# 
# drivers/scsi/ipr.h
#   2004/06/07 11:21:15-05:00 brking@us.ibm.com +1 -1
#   ipr abort hang fix
# 
# drivers/scsi/ipr.c
#   2004/06/07 11:21:15-05:00 brking@us.ibm.com +8 -7
#   ipr abort hang fix
# 
# ChangeSet
#   2004/06/18 12:27:23-07:00 akpm@bix.(none) 
#   Merge bix.(none):/usr/src/bk25 into bix.(none):/usr/src/bk-scsi
# 
# include/linux/pci_ids.h
#   2004/06/18 12:27:19-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# drivers/scsi/ide-scsi.c
#   2004/06/18 12:27:19-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# drivers/scsi/Kconfig
#   2004/06/18 12:27:19-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# MAINTAINERS
#   2004/06/18 12:27:19-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/06/18 10:01:56-05:00 jeremy@sgi.com 
#   [PATCH] SCSI whitelist changes
#   
#   The BLIST_REPORTLUN2 blacklist item has exactly the behavior that
#   the MYLEX DACARMRB (and SGI TP9100, which is really a 2Gb upgrade
#   to the DACARMRB) need.
#   
#   These devices use a PQ of 1 instead of 3 for unconfigured luns,
#   which means that every RAID has 32 luns, many or most of which
#   are just phantoms.
#   
#   However, it does support Report Luns, and it returns the correct
#   data.
#   
#   Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>
# 
# drivers/scsi/scsi_devinfo.c
#   2004/06/17 17:22:09-05:00 jeremy@sgi.com +2 -2
#   SCSI whitelist changes
# 
# ChangeSet
#   2004/06/18 09:58:05-05:00 James.Bottomley@steeleye.com 
#   [PATCH] SCSI Flexible timout intfrastructure
#   
#   The object of this infrastructure is to give HBAs early warning that
#   error handling is about to happen and also provide them with the
#   opportunity to do something about it.
#   
#   It introduces the extra template callback:
#   
#   eh_timed_out()
#   
#   which scsi_times_out() will call if it is populated to notify the LLD
#   that an outstanding command took a timeout.
#   
#   There are three possible returns:
#   
#   EH_HANDLED:	I've fixed the problem, please complete the command for me
#   (as soon as the timer fires, scsi_done will do nothing, so the timer
#   itself will call a special version of scsi_done that doesn't check the
#   timer).
#   
#   EH_NOT_HANDLED:	Invoke error recovery as normal
#   
#   EH_RESET_TIMER:	The command will complete, reset the timer to its
#   original value and start it ticking again.
#   
#   Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>
#   Based on work by Christoph Hellwig and Luben Tuikov
# 
# include/scsi/scsi_host.h
#   2004/06/16 14:36:04-05:00 James.Bottomley@steeleye.com +20 -0
#   Flexible timout intfrastructure
# 
# drivers/scsi/scsi_priv.h
#   2004/06/16 10:45:44-05:00 James.Bottomley@steeleye.com +1 -0
#   Flexible timout intfrastructure
# 
# drivers/scsi/scsi_error.c
#   2004/06/16 10:53:02-05:00 James.Bottomley@steeleye.com +18 -0
#   Flexible timout intfrastructure
# 
# drivers/scsi/scsi.c
#   2004/06/16 10:47:05-05:00 James.Bottomley@steeleye.com +8 -2
#   Flexible timout intfrastructure
# 
# Documentation/scsi/scsi_mid_low_api.txt
#   2004/06/16 14:53:28-05:00 James.Bottomley@steeleye.com +27 -0
#   Flexible timout intfrastructure
# 
# ChangeSet
#   2004/06/18 09:55:35-05:00 alan@redhat.com 
#   [PATCH] PATCH: Further aacraid work
#   
#   I've been going through Mark's changes with a fine toothcomb and this merges
#   most of them. Its tested on 64bit SMP hardware and seems to be fine. There
#   are a couple of Mark's changes I've left out for now but there isnt really
#   an easy way to break down the changes further.
#   
#   This fixes a whole host of problems including random hangs under high load
#   
#   Signed-off-by: Alan Cox <alan@redhat.com>
#           
#   Original contribution under GPL from Adaptec, updates checking by Red Hat
#   
#   Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>
# 
# drivers/scsi/aacraid/sa.c
#   2004/05/30 12:16:25-05:00 alan@redhat.com +3 -5
#   PATCH: Further aacraid work
# 
# drivers/scsi/aacraid/rx.c
#   2004/05/30 12:34:16-05:00 alan@redhat.com +49 -13
#   PATCH: Further aacraid work
# 
# drivers/scsi/aacraid/rkt.c
#   2004/05/30 12:35:26-05:00 alan@redhat.com +44 -12
#   PATCH: Further aacraid work
# 
# drivers/scsi/aacraid/linit.c
#   2004/05/30 12:25:14-05:00 alan@redhat.com +15 -11
#   PATCH: Further aacraid work
# 
# drivers/scsi/aacraid/comminit.c
#   2004/05/11 14:20:37-05:00 alan@redhat.com +8 -3
#   PATCH: Further aacraid work
# 
# drivers/scsi/aacraid/commctrl.c
#   2004/05/30 12:22:05-05:00 alan@redhat.com +1 -1
#   PATCH: Further aacraid work
# 
# drivers/scsi/aacraid/aacraid.h
#   2004/05/30 12:34:35-05:00 alan@redhat.com +43 -22
#   PATCH: Further aacraid work
# 
# drivers/scsi/aacraid/aachba.c
#   2004/05/30 12:27:32-05:00 alan@redhat.com +45 -71
#   PATCH: Further aacraid work
# 
# drivers/scsi/aacraid/TODO
#   2004/05/30 11:41:11-05:00 alan@redhat.com +2 -0
#   PATCH: Further aacraid work
# 
# drivers/scsi/aacraid/README
#   2004/05/30 11:40:52-05:00 alan@redhat.com +10 -8
#   PATCH: Further aacraid work
# 
# ChangeSet
#   2004/06/18 09:53:45-05:00 jejb@mulgrave.(none) 
#   Enable clustering in the 53c700 driver
#   
#   Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>
# 
# drivers/scsi/53c700.c
#   2004/06/18 09:53:25-05:00 jejb@mulgrave.(none) +1 -1
#   Enable clustering in the 53c700 driver
# 
# ChangeSet
#   2004/06/17 20:19:27-07:00 akpm@bix.(none) 
#   Merge bk://linux-scsi.bkbits.net/scsi-misc-2.6
#   into bix.(none):/usr/src/bk-scsi
# 
# drivers/scsi/scsi_debug.c
#   2004/06/17 20:19:24-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/06/15 22:11:25-07:00 akpm@bix.(none) 
#   Merge
# 
# drivers/scsi/qlogicpti.c
#   2004/06/15 22:11:22-07:00 akpm@bix.(none) +1 -0
#   SCCS merged
# 
# drivers/scsi/esp.c
#   2004/06/15 22:11:16-07:00 akpm@bix.(none) +1 -0
#   SCCS merged
# 
# include/linux/pci_ids.h
#   2004/06/15 22:01:31-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# drivers/scsi/st.c
#   2004/06/15 22:01:31-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# drivers/scsi/scsi_debug.c
#   2004/06/15 22:01:31-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# drivers/scsi/osst.c
#   2004/06/15 22:01:31-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# drivers/scsi/cpqfcTScontrol.c
#   2004/06/15 22:01:31-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# drivers/scsi/Kconfig
#   2004/06/15 22:01:31-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# MAINTAINERS
#   2004/06/15 22:01:31-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/06/15 22:00:37-07:00 akpm@bix.(none) 
#   Merge bix.(none):/usr/src/bk25 into bix.(none):/usr/src/bk-scsi
# 
# include/linux/pci_ids.h
#   2004/06/15 22:00:33-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# drivers/scsi/ide-scsi.c
#   2004/06/15 22:00:33-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/06/13 11:30:19-07:00 akpm@bix.(none) 
#   Merge bix.(none):/usr/src/bk25 into bix.(none):/usr/src/bk-scsi
# 
# MAINTAINERS
#   2004/06/13 11:30:16-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/06/10 13:07:05-07:00 akpm@bix.(none) 
#   Merge bix.(none):/usr/src/bk25 into bix.(none):/usr/src/bk-scsi
# 
# drivers/scsi/Kconfig
#   2004/06/10 13:07:02-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/06/09 12:14:09-07:00 akpm@bix.(none) 
#   Merge bix.(none):/usr/src/bk25 into bix.(none):/usr/src/bk-scsi
# 
# drivers/scsi/cpqfcTScontrol.c
#   2004/06/09 12:14:06-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# drivers/scsi/Kconfig
#   2004/06/09 12:14:06-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/06/06 22:38:18-07:00 akpm@bix.(none) 
#   Merge
# 
# drivers/scsi/qlogicpti.c
#   2004/06/06 22:38:14-07:00 akpm@bix.(none) +1 -0
#   SCCS merged
# 
# drivers/scsi/esp.c
#   2004/06/06 22:38:05-07:00 akpm@bix.(none) +1 -0
#   SCCS merged
# 
# include/linux/pci_ids.h
#   2004/06/06 22:06:48-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# drivers/scsi/st.c
#   2004/06/06 22:06:48-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# drivers/scsi/scsi_debug.c
#   2004/06/06 22:06:48-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# drivers/scsi/osst.c
#   2004/06/06 22:06:48-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# MAINTAINERS
#   2004/06/06 22:06:48-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
diff -Nru a/Documentation/scsi/scsi_mid_low_api.txt b/Documentation/scsi/scsi_mid_low_api.txt
--- a/Documentation/scsi/scsi_mid_low_api.txt	2004-06-20 13:22:08 -07:00
+++ b/Documentation/scsi/scsi_mid_low_api.txt	2004-06-20 13:22:08 -07:00
@@ -827,6 +827,7 @@
 Summary:
    bios_param - fetch head, sector, cylinder info for a disk
    detect - detects HBAs this driver wants to control
+   eh_timed_out - notify the host that a command timer expired
    eh_abort_handler - abort given command
    eh_bus_reset_handler - issue SCSI bus reset
    eh_device_reset_handler - issue SCSI device reset
@@ -892,6 +893,32 @@
  *                       not invoked in "hotplug initialization mode")
  **/
     int detect(struct scsi_host_template * shtp)
+
+
+/**
+ *      eh_timed_out - The timer for the command has just fired
+ *      @scp: identifies command timing out
+ *
+ *      Returns:
+ *
+ *	EH_HANDLED:		I fixed the error, please complete the command
+ *	EH_RESET_TIMER:		I need more time, reset the timer and
+ *				begin counting again
+ *	EH_NOT_HANDLED		Begin normal error recovery
+
+ *
+ *      Locks: None held
+ *
+ *      Calling context: interrupt
+ *
+ *	Notes: This is to give the LLD an opportunity to do local recovery.
+ *	This recovery is limited to determining if the outstanding command
+ *	will ever complete.  You may not abort and restart the command from
+ *	this callback.
+ *
+ *      Optionally defined in: LLD
+ **/
+     int eh_timed_out(struct scsi_cmnd * scp)
 
 
 /**
diff -Nru a/drivers/block/cciss_scsi.c b/drivers/block/cciss_scsi.c
--- a/drivers/block/cciss_scsi.c	2004-06-20 13:22:07 -07:00
+++ b/drivers/block/cciss_scsi.c	2004-06-20 13:22:07 -07:00
@@ -29,7 +29,7 @@
    physical nor logical disks are presented through the scsi layer. */
 
 #include "../scsi/scsi.h" 
-#include "../scsi/hosts.h" 
+#include <scsi/scsi_host.h>
 #include <asm/atomic.h>
 #include <linux/timer.h>
 #include <linux/completion.h>
diff -Nru a/drivers/fc4/fc.c b/drivers/fc4/fc.c
--- a/drivers/fc4/fc.c	2004-06-20 13:22:08 -07:00
+++ b/drivers/fc4/fc.c	2004-06-20 13:22:08 -07:00
@@ -38,7 +38,7 @@
 #include <asm/irq.h>
 #include <asm/semaphore.h>
 #include "fcp_impl.h"
-#include "../scsi/hosts.h"
+#include <scsi/scsi_host.h>
 
 /* #define FCDEBUG */
 
diff -Nru a/drivers/ieee1394/sbp2.c b/drivers/ieee1394/sbp2.c
--- a/drivers/ieee1394/sbp2.c	2004-06-20 13:22:07 -07:00
+++ b/drivers/ieee1394/sbp2.c	2004-06-20 13:22:07 -07:00
@@ -65,7 +65,7 @@
 #include <asm/scatterlist.h>
 
 #include "../scsi/scsi.h"
-#include "../scsi/hosts.h"
+#include <scsi/scsi_host.h>
 
 #include "csr1212.h"
 #include "ieee1394.h"
diff -Nru a/drivers/message/fusion/mptctl.c b/drivers/message/fusion/mptctl.c
--- a/drivers/message/fusion/mptctl.c	2004-06-20 13:22:07 -07:00
+++ b/drivers/message/fusion/mptctl.c	2004-06-20 13:22:07 -07:00
@@ -91,7 +91,7 @@
 #include <linux/kdev_t.h>	/* needed for access to Scsi_Host struct */
 #include <linux/blkdev.h>
 #include "../../scsi/scsi.h"
-#include "../../scsi/hosts.h"
+#include <scsi/scsi_host.h>
 
 #define COPYRIGHT	"Copyright (c) 1999-2004 LSI Logic Corporation"
 #define MODULEAUTHOR	"Steven J. Ralston, Noah Romer, Pamela Delaney"
diff -Nru a/drivers/net/fc/iph5526.c b/drivers/net/fc/iph5526.c
--- a/drivers/net/fc/iph5526.c	2004-06-20 13:22:07 -07:00
+++ b/drivers/net/fc/iph5526.c	2004-06-20 13:22:07 -07:00
@@ -52,7 +52,7 @@
 			       others + includes if_fcdevice.h */
 
 #include "../../scsi/scsi.h"
-#include "../../scsi/hosts.h"
+#include <scsi/scsi_host.h>
 #include "../../fc4/fcp.h"
 
 #include <asm/system.h>
diff -Nru a/drivers/scsi/53c700.c b/drivers/scsi/53c700.c
--- a/drivers/scsi/53c700.c	2004-06-20 13:22:07 -07:00
+++ b/drivers/scsi/53c700.c	2004-06-20 13:22:07 -07:00
@@ -332,7 +332,7 @@
 	tpnt->can_queue = NCR_700_COMMAND_SLOTS_PER_HOST;
 	tpnt->sg_tablesize = NCR_700_SG_SEGMENTS;
 	tpnt->cmd_per_lun = NCR_700_CMD_PER_LUN;
-	tpnt->use_clustering = DISABLE_CLUSTERING;
+	tpnt->use_clustering = ENABLE_CLUSTERING;
 	tpnt->slave_configure = NCR_700_slave_configure;
 	tpnt->slave_destroy = NCR_700_slave_destroy;
 	
diff -Nru a/drivers/scsi/aacraid/README b/drivers/scsi/aacraid/README
--- a/drivers/scsi/aacraid/README	2004-06-20 13:22:07 -07:00
+++ b/drivers/scsi/aacraid/README	2004-06-20 13:22:07 -07:00
@@ -10,20 +10,22 @@
 
 Supported Cards/Chipsets
 -------------------------
+	AAR-2410SA SATA
+	Adaptec 2120S
+	Adaptec 2200S
+	Adaptec 2230S
+	Adaptec 3230S
+	Adaptec 3240S
+	Adaptec 5400S
+	ASR-2020S PCI-X
 	Dell PERC 2 Quad Channel
 	Dell PERC 2/Si
 	Dell PERC 3/Si
 	Dell PERC 3/Di
+	Dell CERC 2
 	HP NetRAID-4M
-	ADAPTEC 2120S
-	ADAPTEC 2200S
-	ADAPTEC 5400S
 	Legend S220
 	Legend S230
-	Adaptec 3230S
-	Adaptec 3240S
-	ASR-2020S PCI-X
-	AAR-2410SA SATA
 
 People
 -------------------------
@@ -46,7 +48,7 @@
 
 Mailing List
 -------------------------
-linux-aacraid-devel@dell.com (Interested parties troll here)
+linux-scsi@vger.kernel.org (Interested parties troll here)
 http://mbserver.adaptec.com/ (Currently more Community Support than Devel Support)
 Also note this is very different to Brian's original driver
 so don't expect him to support it.
diff -Nru a/drivers/scsi/aacraid/TODO b/drivers/scsi/aacraid/TODO
--- a/drivers/scsi/aacraid/TODO	2004-06-20 13:22:07 -07:00
+++ b/drivers/scsi/aacraid/TODO	2004-06-20 13:22:07 -07:00
@@ -2,3 +2,5 @@
 o	More testing
 o	Feature request: display the firmware/bios/etc revisions in the
 	/proc info
+o	Drop irq_mask, basically unused
+o	I/O size increase
diff -Nru a/drivers/scsi/aacraid/aachba.c b/drivers/scsi/aacraid/aachba.c
--- a/drivers/scsi/aacraid/aachba.c	2004-06-20 13:22:08 -07:00
+++ b/drivers/scsi/aacraid/aachba.c	2004-06-20 13:22:08 -07:00
@@ -53,35 +53,11 @@
 #define	INQD_PDT_DMASK	0x1F	/* Peripheral Device Type Mask */
 #define	INQD_PDT_QMASK	0xE0	/* Peripheral Device Qualifer Mask */
 
-#define	TARGET_LUN_TO_CONTAINER(target, lun)	(target)
-#define CONTAINER_TO_TARGET(cont)		((cont))
-#define CONTAINER_TO_LUN(cont)			(0)
-
 #define MAX_FIB_DATA (sizeof(struct hw_fib) - sizeof(FIB_HEADER))
 
 #define MAX_DRIVER_SG_SEGMENT_COUNT 17
 
 /*
- *	Sense keys
- */
-#define SENKEY_NO_SENSE      0x00	
-#define SENKEY_UNDEFINED     0x01	
-#define SENKEY_NOT_READY     0x02	
-#define SENKEY_MEDIUM_ERR    0x03	
-#define SENKEY_HW_ERR        0x04	
-#define SENKEY_ILLEGAL       0x05	
-#define SENKEY_ATTENTION     0x06	
-#define SENKEY_PROTECTED     0x07	
-#define SENKEY_BLANK         0x08	
-#define SENKEY_V_UNIQUE      0x09	
-#define SENKEY_CPY_ABORT     0x0A	
-#define SENKEY_ABORT         0x0B	
-#define SENKEY_EQUAL         0x0C	
-#define SENKEY_VOL_OVERFLOW  0x0D	
-#define SENKEY_MISCOMP       0x0E	
-#define SENKEY_RESERVED      0x0F	
-
-/*
  *	Sense codes
  */
  
@@ -195,7 +171,6 @@
  *              M O D U L E   G L O B A L S
  */
  
-static struct fsa_scsi_hba *fsa_dev[MAXIMUM_NUM_ADAPTERS];	/*  SCSI Device Instance Pointers */
 static struct sense_data sense_data[MAXIMUM_NUM_CONTAINERS];
 static unsigned long aac_build_sg(struct scsi_cmnd* scsicmd, struct sgmap* sgmap);
 static unsigned long aac_build_sg64(struct scsi_cmnd* scsicmd, struct sgmap64* psg);
@@ -264,7 +239,6 @@
 		}
 	}
 	fib_free(fibptr);
-	fsa_dev[instance] = fsa_dev_ptr;
 	return status;
 }
 
@@ -424,14 +398,14 @@
 	} else
 		sense_buf[2] = sense_key;	/* Sense key */
 
-	if (sense_key == SENKEY_ILLEGAL)
+	if (sense_key == ILLEGAL_REQUEST)
 		sense_buf[7] = 10;	/* Additional sense length */
 	else
 		sense_buf[7] = 6;	/* Additional sense length */
 
 	sense_buf[12] = sense_code;	/* Additional sense code */
 	sense_buf[13] = a_sense_code;	/* Additional sense code qualifier */
-	if (sense_key == SENKEY_ILLEGAL) {
+	if (sense_key == ILLEGAL_REQUEST) {
 		sense_buf[15] = 0;
 
 		if (sense_code == SENCODE_INVALID_PARAM_FIELD)
@@ -514,11 +488,12 @@
 		dev->nondasd_support = (nondasd!=0);
 	}
 	if(dev->nondasd_support != 0){
-		printk(KERN_INFO"%s%d: Non-DASD support enabled\n",dev->name, dev->id);
+		printk(KERN_INFO "%s%d: Non-DASD support enabled.\n",dev->name, dev->id);
 	}
 
 	dev->pae_support = 0;
 	if( (sizeof(dma_addr_t) > 4) && (dev->adapter_info.options & AAC_OPT_SGMAP_HOST64)){
+		printk(KERN_INFO "%s%d: 64bit support enabled.\n", dev->name, dev->id);
 		dev->pae_support = 1;
 	}
 
@@ -548,7 +523,7 @@
 	scsicmd = (struct scsi_cmnd *) context;
 
 	dev = (struct aac_dev *)scsicmd->device->host->hostdata;
-	cid =TARGET_LUN_TO_CONTAINER(scsicmd->device->id, scsicmd->device->lun);
+	cid = ID_LUN_TO_CONTAINER(scsicmd->device->id, scsicmd->device->lun);
 
 	lba = ((scsicmd->cmnd[1] & 0x1F) << 16) | (scsicmd->cmnd[2] << 8) | scsicmd->cmnd[3];
 	dprintk((KERN_DEBUG "read_callback[cpu %d]: lba = %u, t = %ld.\n", smp_processor_id(), lba, jiffies));
@@ -572,10 +547,11 @@
 		printk(KERN_WARNING "read_callback: read failed, status = %d\n", readreply->status);
 		scsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8 | SAM_STAT_CHECK_CONDITION;
 		set_sense((u8 *) &sense_data[cid],
-				    SENKEY_HW_ERR,
+				    HARDWARE_ERROR,
 				    SENCODE_INTERNAL_TARGET_FAILURE,
 				    ASENCODE_INTERNAL_TARGET_FAILURE, 0, 0,
 				    0, 0);
+		memcpy(scsicmd->sense_buffer, &sense_data[cid], sizeof(struct sense_data));
 	}
 	fib_complete(fibptr);
 	fib_free(fibptr);
@@ -593,7 +569,7 @@
 
 	scsicmd = (struct scsi_cmnd *) context;
 	dev = (struct aac_dev *)scsicmd->device->host->hostdata;
-	cid = TARGET_LUN_TO_CONTAINER(scsicmd->device->id, scsicmd->device->lun);
+	cid = ID_LUN_TO_CONTAINER(scsicmd->device->id, scsicmd->device->lun);
 
 	lba = ((scsicmd->cmnd[1] & 0x1F) << 16) | (scsicmd->cmnd[2] << 8) | scsicmd->cmnd[3];
 	dprintk((KERN_DEBUG "write_callback[cpu %d]: lba = %u, t = %ld.\n", smp_processor_id(), lba, jiffies));
@@ -617,10 +593,11 @@
 		printk(KERN_WARNING "write_callback: write failed, status = %d\n", writereply->status);
 		scsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8 | SAM_STAT_CHECK_CONDITION;
 		set_sense((u8 *) &sense_data[cid],
-				    SENKEY_HW_ERR,
+				    HARDWARE_ERROR,
 				    SENCODE_INTERNAL_TARGET_FAILURE,
 				    ASENCODE_INTERNAL_TARGET_FAILURE, 0, 0,
 				    0, 0);
+		memcpy(scsicmd->sense_buffer, &sense_data[cid], sizeof(struct sense_data));
 	}
 
 	fib_complete(fibptr);
@@ -644,7 +621,7 @@
 	 */
 	if (scsicmd->cmnd[0] == READ_6)	/* 6 byte command */
 	{
-		dprintk((KERN_DEBUG "aachba: received a read(6) command on target %d.\n", cid));
+		dprintk((KERN_DEBUG "aachba: received a read(6) command on id %d.\n", cid));
 
 		lba = ((scsicmd->cmnd[1] & 0x1F) << 16) | (scsicmd->cmnd[2] << 8) | scsicmd->cmnd[3];
 		count = scsicmd->cmnd[4];
@@ -652,7 +629,7 @@
 		if (count == 0)
 			count = 256;
 	} else {
-		dprintk((KERN_DEBUG "aachba: received a read(10) command on target %d.\n", cid));
+		dprintk((KERN_DEBUG "aachba: received a read(10) command on id %d.\n", cid));
 
 		lba = (scsicmd->cmnd[2] << 24) | (scsicmd->cmnd[3] << 16) | (scsicmd->cmnd[4] << 8) | scsicmd->cmnd[5];
 		count = (scsicmd->cmnd[7] << 8) | scsicmd->cmnd[8];
@@ -662,9 +639,7 @@
 	 *	Alocate and initialize a Fib
 	 */
 	if (!(cmd_fibcontext = fib_alloc(dev))) {
-		scsicmd->result = DID_ERROR << 16;
-		aac_io_done(scsicmd);
-		return (-1);
+		return -1;
 	}
 
 	fib_init(cmd_fibcontext);
@@ -726,7 +701,10 @@
 	 *	Check that the command queued to the controller
 	 */
 	if (status == -EINPROGRESS) 
+	{
+		dprintk("read queued.\n");
 		return 0;
+	}
 		
 	printk(KERN_WARNING "aac_read: fib_send failed with status: %d.\n", status);
 	/*
@@ -759,7 +737,7 @@
 		if (count == 0)
 			count = 256;
 	} else {
-		dprintk((KERN_DEBUG "aachba: received a write(10) command on target %d.\n", cid));
+		dprintk((KERN_DEBUG "aachba: received a write(10) command on id %d.\n", cid));
 		lba = (scsicmd->cmnd[2] << 24) | (scsicmd->cmnd[3] << 16) | (scsicmd->cmnd[4] << 8) | scsicmd->cmnd[5];
 		count = (scsicmd->cmnd[7] << 8) | scsicmd->cmnd[8];
 	}
@@ -832,7 +810,10 @@
 	 *	Check that the command queued to the controller
 	 */
 	if (status == -EINPROGRESS)
+	{
+		dprintk("write queued.\n");
 		return 0;
+	}
 
 	printk(KERN_WARNING "aac_write: fib_send failed with status: %d\n", status);
 	/*
@@ -850,7 +831,6 @@
 /**
  *	aac_scsi_cmd()		-	Process SCSI command
  *	@scsicmd:		SCSI command block
- *	@wait:			1 if the user wants to await completion
  *
  *	Emulate a SCSI command and queue the required request for the
  *	aacraid firmware.
@@ -859,29 +839,25 @@
 int aac_scsi_cmd(struct scsi_cmnd * scsicmd)
 {
 	u32 cid = 0;
-	struct fsa_scsi_hba *fsa_dev_ptr;
-	int cardtype;
 	int ret;
 	struct Scsi_Host *host = scsicmd->device->host;
 	struct aac_dev *dev = (struct aac_dev *)host->hostdata;
+	struct fsa_scsi_hba *fsa_dev_ptr = &dev->fsa_dev;
+	int cardtype = dev->cardtype;
 	
-	cardtype = dev->cardtype;
-
-	fsa_dev_ptr = fsa_dev[host->unique_id];
-
 	/*
-	 *	If the bus, target or lun is out of range, return fail
+	 *	If the bus, id or lun is out of range, return fail
 	 *	Test does not apply to ID 16, the pseudo id for the controller
 	 *	itself.
 	 */
 	if (scsicmd->device->id != host->this_id) {
 		if ((scsicmd->device->channel == 0) ){
-			if( (scsicmd->device->id >= AAC_MAX_TARGET) || (scsicmd->device->lun != 0)){ 
+			if( (scsicmd->device->id >= MAXIMUM_NUM_CONTAINERS) || (scsicmd->device->lun != 0)){
 				scsicmd->result = DID_NO_CONNECT << 16;
 				__aac_io_done(scsicmd);
 				return 0;
 			}
-			cid = TARGET_LUN_TO_CONTAINER(scsicmd->device->id, scsicmd->device->lun);
+			cid = ID_LUN_TO_CONTAINER(scsicmd->device->id, scsicmd->device->lun);
 
 			/*
 			 *	If the target container doesn't exist, it may have
@@ -911,7 +887,7 @@
 			if (fsa_dev_ptr->valid[cid] == 0) {
 				scsicmd->result = DID_BAD_TARGET << 16;
 				__aac_io_done(scsicmd);
-				return -1;
+				return 0;
 			}
 		} else {  /* check for physical non-dasd devices */
 			if(dev->nondasd_support == 1){
@@ -932,11 +908,12 @@
 		dprintk((KERN_WARNING "Only INQUIRY & TUR command supported for controller, rcvd = 0x%x.\n", scsicmd->cmnd[0]));
 		scsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8 | SAM_STAT_CHECK_CONDITION;
 		set_sense((u8 *) &sense_data[cid],
-			    SENKEY_ILLEGAL,
+			    ILLEGAL_REQUEST,
 			    SENCODE_INVALID_COMMAND,
 			    ASENCODE_INVALID_COMMAND, 0, 0, 0, 0);
 		__aac_io_done(scsicmd);
-		return -1;
+		memcpy(scsicmd->sense_buffer, &sense_data[cid], sizeof(struct sense_data));
+		return 0;
 	}
 
 
@@ -1034,7 +1011,7 @@
 		memset(&sense_data[cid], 0, sizeof (struct sense_data));
 		scsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8 | SAM_STAT_GOOD;
 		__aac_io_done(scsicmd);
-		return (0);
+		return 0;
 
 	case ALLOW_MEDIUM_REMOVAL:
 		dprintk((KERN_DEBUG "LOCK command.\n"));
@@ -1058,7 +1035,7 @@
 	case START_STOP:
 		scsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8 | SAM_STAT_GOOD;
 		__aac_io_done(scsicmd);
-		return (0);
+		return 0;
 	}
 
 	switch (scsicmd->cmnd[0]) 
@@ -1094,10 +1071,12 @@
 			printk(KERN_WARNING "Unhandled SCSI Command: 0x%x.\n", scsicmd->cmnd[0]);
 			scsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8 | SAM_STAT_CHECK_CONDITION;
 			set_sense((u8 *) &sense_data[cid],
-				SENKEY_ILLEGAL, SENCODE_INVALID_COMMAND,
+				ILLEGAL_REQUEST, SENCODE_INVALID_COMMAND,
 			ASENCODE_INVALID_COMMAND, 0, 0, 0, 0);
+			memcpy(scsicmd->sense_buffer, &sense_data[cid],
+				sizeof(struct sense_data));
 			__aac_io_done(scsicmd);
-			return -1;
+			return 0;
 	}
 }
 
@@ -1110,14 +1089,14 @@
 	if (copy_from_user(&qd, arg, sizeof (struct aac_query_disk)))
 		return -EFAULT;
 	if (qd.cnum == -1)
-		qd.cnum = TARGET_LUN_TO_CONTAINER(qd.target, qd.lun);
-	else if ((qd.bus == -1) && (qd.target == -1) && (qd.lun == -1)) 
+		qd.cnum = ID_LUN_TO_CONTAINER(qd.id, qd.lun);
+	else if ((qd.bus == -1) && (qd.id == -1) && (qd.lun == -1))
 	{
 		if (qd.cnum < 0 || qd.cnum >= MAXIMUM_NUM_CONTAINERS)
 			return -EINVAL;
 		qd.instance = dev->scsi_host_ptr->host_no;
 		qd.bus = 0;
-		qd.target = CONTAINER_TO_TARGET(qd.cnum);
+		qd.id = CONTAINER_TO_ID(qd.cnum);
 		qd.lun = CONTAINER_TO_LUN(qd.cnum);
 	}
 	else return -EINVAL;
@@ -1228,8 +1207,11 @@
 
 	srbreply = (struct aac_srb_reply *) fib_data(fibptr);
 
-	scsicmd->sense_buffer[0] = '\0';  // initialize sense valid flag to false
-	// calculate resid for sg 
+	scsicmd->sense_buffer[0] = '\0';  /* Initialize sense valid flag to false */
+	/*
+	 *	Calculate resid for sg
+	 */
+
 	scsicmd->resid = scsicmd->request_bufflen - srbreply->data_xfer_length;
 
 	if(scsicmd->use_sg)
@@ -1376,7 +1358,7 @@
 		scsicmd->result |= SAM_STAT_CHECK_CONDITION;
 		len = (srbreply->sense_data_size > sizeof(scsicmd->sense_buffer))?
 				sizeof(scsicmd->sense_buffer):srbreply->sense_data_size;
-		printk(KERN_WARNING "aac_srb_callback: check condition, status = %d len=%d\n", le32_to_cpu(srbreply->status), len);
+		dprintk((KERN_WARNING "aac_srb_callback: check condition, status = %d len=%d\n", le32_to_cpu(srbreply->status), len));
 		memcpy(scsicmd->sense_buffer, srbreply->sense_data, len);
 		
 	}
@@ -1437,8 +1419,6 @@
 	 *	Allocate and initialize a Fib then setup a BlockWrite command
 	 */
 	if (!(cmd_fibcontext = fib_alloc(dev))) {
-		scsicmd->result = DID_ERROR << 16;
-		__aac_io_done(scsicmd);
 		return -1;
 	}
 	fib_init(cmd_fibcontext);
@@ -1446,7 +1426,7 @@
 	srbcmd = (struct aac_srb*) fib_data(cmd_fibcontext);
 	srbcmd->function = cpu_to_le32(SRBF_ExecuteScsi);
 	srbcmd->channel  = cpu_to_le32(aac_logical_to_phys(scsicmd->device->channel));
-	srbcmd->target   = cpu_to_le32(scsicmd->device->id);
+	srbcmd->id   = cpu_to_le32(scsicmd->device->id);
 	srbcmd->lun      = cpu_to_le32(scsicmd->device->lun);
 	srbcmd->flags    = cpu_to_le32(flag);
 	timeout = (scsicmd->timeout-jiffies)/HZ;
@@ -1498,12 +1478,6 @@
 	}
 
 	printk(KERN_WARNING "aac_srb: fib_send failed with status: %d\n", status);
-	/*
-	 *	For some reason, the Fib didn't queue, return QUEUE_FULL
-	 */
-	scsicmd->result = DID_OK << 16 | COMMAND_COMPLETE << 8 | SAM_STAT_TASK_SET_FULL;
-	__aac_io_done(scsicmd);
-
 	fib_complete(cmd_fibcontext);
 	fib_free(cmd_fibcontext);
 
diff -Nru a/drivers/scsi/aacraid/aacraid.h b/drivers/scsi/aacraid/aacraid.h
--- a/drivers/scsi/aacraid/aacraid.h	2004-06-20 13:22:07 -07:00
+++ b/drivers/scsi/aacraid/aacraid.h	2004-06-20 13:22:07 -07:00
@@ -6,14 +6,12 @@
  *              D E F I N E S
  *----------------------------------------------------------------------------*/
 
-#define MAXIMUM_NUM_CONTAINERS	31
+#define MAXIMUM_NUM_CONTAINERS	32
 #define MAXIMUM_NUM_ADAPTERS	8
 
-#define AAC_NUM_FIB		578
-//#define AAC_NUM_IO_FIB	512
+#define AAC_NUM_FIB		(256 + 64)
 #define AAC_NUM_IO_FIB		100
 
-#define AAC_MAX_TARGET 		(MAXIMUM_NUM_CONTAINERS+1)
 #define AAC_MAX_LUN		(8)
 
 #define AAC_MAX_HOSTPHYSMEMPAGES (0xfffff)
@@ -21,7 +19,12 @@
 /*
  * These macros convert from physical channels to virtual channels
  */
-#define CONTAINER_CHANNEL	(0)
+#define CONTAINER_CHANNEL		(0)
+#define ID_LUN_TO_CONTAINER(id, lun)	(id)
+#define CONTAINER_TO_CHANNEL(cont)	(CONTAINER_CHANNEL)
+#define CONTAINER_TO_ID(cont)		(cont)
+#define CONTAINER_TO_LUN(cont)		(0)
+
 #define aac_phys_to_logical(x)  (x+1)
 #define aac_logical_to_phys(x)  (x?x-1:0)
 
@@ -73,7 +76,7 @@
 #define		FT_SOCK		6	/* socket */
 #define		FT_FIFO		7	/* fifo */
 #define		FT_FILESYS	8	/* ADAPTEC's "FSA"(tm) filesystem */
-#define		FT_DRIVE	9	/* physical disk - addressable in scsi by bus/target/lun */
+#define		FT_DRIVE	9	/* physical disk - addressable in scsi by bus/id/lun */
 #define		FT_SLICE	10	/* virtual disk - raw volume - slice */
 #define		FT_PARTITION	11	/* FSA partition - carved out of a slice - building block for containers */
 #define		FT_VOLUME	12	/* Container - Volume Set */
@@ -433,7 +436,7 @@
 
 struct aac_driver_ident
 {
-	int 	(*init)(struct aac_dev *dev, unsigned long num);
+	int 	(*init)(struct aac_dev *dev);
 	char *	name;
 	char *	vname;
 	char *	model;
@@ -596,6 +599,9 @@
 #define	InboundMailbox2		IndexRegs.Mailbox[2]
 #define	InboundMailbox3		IndexRegs.Mailbox[3]
 #define	InboundMailbox4		IndexRegs.Mailbox[4]
+#define	InboundMailbox5		IndexRegs.Mailbox[5]
+#define	InboundMailbox6		IndexRegs.Mailbox[6]
+#define	InboundMailbox7		IndexRegs.Mailbox[7]
 
 #define	INBOUNDDOORBELL_0	cpu_to_le32(0x00000001)
 #define INBOUNDDOORBELL_1	cpu_to_le32(0x00000002)
@@ -825,9 +831,8 @@
 	} regs;
 	u32			OIMR; /* Mask Register Cache */
 	/*
-	 *	The following is the number of the individual adapter
+	 *	AIF thread states
 	 */
-	u32			devnum;
 	u32			aif_thread;
 	struct completion	aif_completion;
 	struct aac_adapter_info adapter_info;
@@ -839,19 +844,19 @@
 };
 
 #define AllocateAndMapFibSpace(dev, MapFibContext) \
-	dev->a_ops.AllocateAndMapFibSpace(dev, MapFibContext)
+	(dev)->a_ops.AllocateAndMapFibSpace(dev, MapFibContext)
 
 #define UnmapAndFreeFibSpace(dev, MapFibContext) \
-	dev->a_ops.UnmapAndFreeFibSpace(dev, MapFibContext)
+	(dev)->a_ops.UnmapAndFreeFibSpace(dev, MapFibContext)
 
 #define aac_adapter_interrupt(dev) \
-	dev->a_ops.adapter_interrupt(dev)
+	(dev)->a_ops.adapter_interrupt(dev)
 
 #define aac_adapter_notify(dev, event) \
-	dev->a_ops.adapter_notify(dev, event)
+	(dev)->a_ops.adapter_notify(dev, event)
 
 #define aac_adapter_enable_int(dev, event) \
-	dev->a_ops.adapter_enable_int(dev, event)
+	(dev)->a_ops.adapter_enable_int(dev, event)
 
 #define aac_adapter_disable_int(dev, event) \
 	dev->a_ops.adapter_disable_int(dev, event)
@@ -1023,7 +1028,7 @@
 {
 	u32		function;
 	u32		channel;
-	u32		target;
+	u32		id;
 	u32		lun;
 	u32		timeout;
 	u32		flags;
@@ -1212,7 +1217,7 @@
 {
 	s32	cnum;
 	s32	bus;
-	s32	target;
+	s32	id;
 	s32	lun;
 	u32	valid;
 	u32	locked;
@@ -1323,6 +1328,7 @@
 #define WRITE_PERMANENT_PARAMETERS	cpu_to_le32(0x0000000b)
 #define HOST_CRASHING			cpu_to_le32(0x0000000d)
 #define	SEND_SYNCHRONOUS_FIB		cpu_to_le32(0x0000000c)
+#define	COMMAND_POST_RESULTS		cpu_to_le32(0x00000014)
 #define GET_ADAPTER_PROPERTIES		cpu_to_le32(0x00000019)
 #define RE_INIT_ADAPTER			cpu_to_le32(0x000000ee)
 
@@ -1347,14 +1353,16 @@
  *	Phases are bit oriented.  It is NOT valid  to have multiple bits set						
  */					
 
-#define	SELF_TEST_FAILED		cpu_to_le32(0x00000004)
-#define	KERNEL_UP_AND_RUNNING		cpu_to_le32(0x00000080)
-#define	KERNEL_PANIC			cpu_to_le32(0x00000100)
+#define	SELF_TEST_FAILED		(cpu_to_le32(0x00000004))
+#define MONITOR_PANIC			(cpu_to_le32(0x00000020))
+#define	KERNEL_UP_AND_RUNNING		(cpu_to_le32(0x00000080))
+#define	KERNEL_PANIC			(cpu_to_le32(0x00000100))
 
 /*
  *	Doorbell bit defines
  */
 
+#define DoorBellSyncCmdAvailable	cpu_to_le32(1<<0)	// Host -> Adapter
 #define DoorBellPrintfDone		cpu_to_le32(1<<5)	// Host -> Adapter
 #define DoorBellAdapterNormCmdReady	cpu_to_le32(1<<1)	// Adapter -> Host
 #define DoorBellAdapterNormRespReady	cpu_to_le32(1<<2)	// Adapter -> Host
@@ -1368,9 +1376,22 @@
  */
  
 #define 	AifCmdEventNotify	1	/* Notify of event */
+#define			AifEnConfigChange	3	/* Adapter configuration change */
+#define			AifEnContainerChange	4	/* Container configuration change */
+#define			AifEnDeviceFailure	5	/* SCSI device failed */
+#define			AifEnAddContainer	15	/* A new array was created */
+#define			AifEnDeleteContainer	16	/* A container was deleted */
+#define			AifEnExpEvent		23	/* Firmware Event Log */
+#define			AifExeFirmwarePanic	3	/* Firmware Event Panic */
+#define			AifHighPriority		3	/* Highest Priority Event */
+
 #define		AifCmdJobProgress	2	/* Progress report */
+#define			AifJobCtrZero	101	/* Array Zero progress */
+#define			AifJobStsSuccess 1	/* Job completes */
 #define		AifCmdAPIReport		3	/* Report from other user of API */
 #define		AifCmdDriverNotify	4	/* Notify host driver of event */
+#define			AifDenMorphComplete 200	/* A morph operation completed */
+#define			AifDenVolumeExtendComplete 201 /* A volume extend completed */
 #define		AifReqJobList		100	/* Gets back complete job list */
 #define		AifReqJobsForCtr	101	/* Gets back jobs for specific container */
 #define		AifReqJobsForScsi	102	/* Gets back jobs for specific SCSI device */ 
@@ -1427,9 +1448,9 @@
 int aac_scsi_cmd(struct scsi_cmnd *cmd);
 int aac_dev_ioctl(struct aac_dev *dev, int cmd, void *arg);
 int aac_do_ioctl(struct aac_dev * dev, int cmd, void *arg);
-int aac_rx_init(struct aac_dev *dev, unsigned long devNumber);
-int aac_rkt_init(struct aac_dev *dev, unsigned long devNumber);
-int aac_sa_init(struct aac_dev *dev, unsigned long devNumber);
+int aac_rx_init(struct aac_dev *dev);
+int aac_rkt_init(struct aac_dev *dev);
+int aac_sa_init(struct aac_dev *dev);
 unsigned int aac_response_normal(struct aac_queue * q);
 unsigned int aac_command_normal(struct aac_queue * q);
 int aac_command_thread(struct aac_dev * dev);
diff -Nru a/drivers/scsi/aacraid/commctrl.c b/drivers/scsi/aacraid/commctrl.c
--- a/drivers/scsi/aacraid/commctrl.c	2004-06-20 13:22:07 -07:00
+++ b/drivers/scsi/aacraid/commctrl.c	2004-06-20 13:22:07 -07:00
@@ -431,7 +431,7 @@
 	// Fix up srb for endian and force some values
 	srbcmd->function = cpu_to_le32(SRBF_ExecuteScsi);	// Force this
 	srbcmd->channel  = cpu_to_le32(srbcmd->channel);
-	srbcmd->target   = cpu_to_le32(srbcmd->target);
+	srbcmd->id	 = cpu_to_le32(srbcmd->id);
 	srbcmd->lun      = cpu_to_le32(srbcmd->lun);
 	srbcmd->flags    = cpu_to_le32(srbcmd->flags);
 	srbcmd->timeout  = cpu_to_le32(srbcmd->timeout);
diff -Nru a/drivers/scsi/aacraid/comminit.c b/drivers/scsi/aacraid/comminit.c
--- a/drivers/scsi/aacraid/comminit.c	2004-06-20 13:22:07 -07:00
+++ b/drivers/scsi/aacraid/comminit.c	2004-06-20 13:22:07 -07:00
@@ -95,13 +95,18 @@
 	 * with the math overloading past 32 bits, thus we must limit this
 	 * field.
 	 *
-	 * FIXME: this assumes the memory is mapped zero->n, which isnt
-	 * always true on real computers.
+	 * This assumes the memory is mapped zero->n, which isnt
+	 * always true on real computers. It also has some slight problems
+	 * with the GART on x86-64. I've btw never tried DMA from PCI space
+	 * on this platform but don't be suprised if its problematic.
 	 */
+#ifndef CONFIG_GART_IOMMU
 	if ((num_physpages << (PAGE_SHIFT - 12)) <= AAC_MAX_HOSTPHYSMEMPAGES) {
 		init->HostPhysMemPages = 
 			cpu_to_le32(num_physpages << (PAGE_SHIFT-12));
-	} else {
+	} else
+#endif
+	{
 		init->HostPhysMemPages = cpu_to_le32(AAC_MAX_HOSTPHYSMEMPAGES);
 	}
 
diff -Nru a/drivers/scsi/aacraid/linit.c b/drivers/scsi/aacraid/linit.c
--- a/drivers/scsi/aacraid/linit.c	2004-06-20 13:22:07 -07:00
+++ b/drivers/scsi/aacraid/linit.c	2004-06-20 13:22:07 -07:00
@@ -27,7 +27,7 @@
  * Abstract: Linux Driver entry module for Adaptec RAID Array Controller
  */
 
-#define AAC_DRIVER_VERSION		"1.1.2-lk1"
+#define AAC_DRIVER_VERSION		"1.1.2-lk2"
 #define AAC_DRIVER_BUILD_DATE		__DATE__
 #define AAC_DRIVERNAME			"aacraid"
 
@@ -355,13 +355,15 @@
 	struct Scsi_Host * host = dev->host;
 	struct scsi_cmnd * command;
 	int count;
+	struct aac_dev * aac;
 	unsigned long flags;
 
 	printk(KERN_ERR "%s: Host adapter reset request. SCSI hang ?\n", 
 					AAC_DRIVERNAME);
 
 
-	if (aac_adapter_check_health((struct aac_dev *)host->hostdata)) {
+	aac = (struct aac_dev *)host->hostdata;
+	if (aac_adapter_check_health(aac)) {
 		printk(KERN_ERR "%s: Host adapter appears dead\n", 
 				AAC_DRIVERNAME);
 		return -ENODEV;
@@ -381,15 +383,13 @@
 				}
 			}
 			spin_unlock_irqrestore(&dev->list_lock, flags);
-			if (active)
-				break;
 
+			/*
+			 * We can exit If all the commands are complete
+			 */
+			if (active == 0)
+				return SUCCESS;
 		}
-		/*
-		 * We can exit If all the commands are complete
-		 */
-		if (active == 0)
-			return SUCCESS;
 		spin_unlock_irq(host->host_lock);
 		scsi_sleep(HZ);
 		spin_lock_irq(host->host_lock);
@@ -461,7 +461,11 @@
 	.this_id        		= 16,
 	.sg_tablesize   		= 16,
 	.max_sectors    		= 128,
+#if (AAC_NUM_IO_FIB > 256)
+	.cmd_per_lun			= 256,
+#else
 	.cmd_per_lun    		= AAC_NUM_IO_FIB, 
+#endif
 	.use_clustering			= ENABLE_CLUSTERING,
 };
 
@@ -521,7 +525,7 @@
 	for (container = 0; container < MAXIMUM_NUM_CONTAINERS; container++)
 		fsa_dev_ptr->devname[container][0] = '\0';
 
-	if ((*aac_drivers[index].init)(aac , shost->unique_id))
+	if ((*aac_drivers[index].init)(aac))
 		goto out_free_fibs;
 
 	/*
@@ -552,7 +556,7 @@
 	 * dmb - we may need to move the setting of these parms somewhere else once
 	 * we get a fib that can report the actual numbers
 	 */
-	shost->max_id = AAC_MAX_TARGET;
+	shost->max_id = MAXIMUM_NUM_CONTAINERS;
 	shost->max_lun = AAC_MAX_LUN;
 
 	error = scsi_add_host(shost, &pdev->dev);
diff -Nru a/drivers/scsi/aacraid/rkt.c b/drivers/scsi/aacraid/rkt.c
--- a/drivers/scsi/aacraid/rkt.c	2004-06-20 13:22:08 -07:00
+++ b/drivers/scsi/aacraid/rkt.c	2004-06-20 13:22:08 -07:00
@@ -38,6 +38,7 @@
 #include <linux/blkdev.h>
 #include <linux/delay.h>
 #include <linux/completion.h>
+#include <linux/time.h>
 #include <linux/interrupt.h>
 #include <asm/semaphore.h>
 
@@ -67,8 +68,8 @@
 			rkt_writel(dev, InboundDoorbellReg,DoorBellPrintfDone);
 		}
 		else if (bellbits & DoorBellAdapterNormCmdReady) {
-			aac_command_normal(&dev->queues->queue[HostNormCmdQueue]);
 			rkt_writel(dev, MUnit.ODR, DoorBellAdapterNormCmdReady);
+			aac_command_normal(&dev->queues->queue[HostNormCmdQueue]);
 		}
 		else if (bellbits & DoorBellAdapterNormRespReady) {
 			aac_response_normal(&dev->queues->queue[HostNormRespQueue]);
@@ -305,7 +306,7 @@
 	struct aac_init *init;
 
 	init = dev->init;
-	init->HostElapsedSeconds = cpu_to_le32(jiffies/HZ);
+	init->HostElapsedSeconds = cpu_to_le32(get_seconds());
 	/*
 	 *	Tell the adapter we are back and up and running so it will scan
 	 *	its command queues and enable our interrupts
@@ -341,12 +342,38 @@
 	if (status & SELF_TEST_FAILED)
 		return -1;
 	/*
-	 *	Check to see if the board panic'd while booting.
+	 *	Check to see if the board panic'd.
 	 */
 	if (status & KERNEL_PANIC)
-		return -2;
+	{
+		char * buffer = kmalloc(512, GFP_KERNEL|__GFP_DMA);
+		struct POSTSTATUS {
+			u32 Post_Command;
+			u32 Post_Address;
+		} * post = kmalloc(sizeof(struct POSTSTATUS), GFP_KERNEL);
+		dma_addr_t paddr = pci_map_single(dev->pdev, post, sizeof(struct POSTSTATUS), 2);
+		dma_addr_t baddr = pci_map_single(dev->pdev, buffer, 512, 1);
+		u32 status = -1;
+		int ret = -2;
+
+		memset(buffer, 0, 512);
+		post->Post_Command = cpu_to_le32(COMMAND_POST_RESULTS);
+		post->Post_Address = cpu_to_le32(baddr);
+		rkt_writel(dev, MUnit.IMRx[0], cpu_to_le32(paddr));
+		rkt_sync_cmd(dev, COMMAND_POST_RESULTS, baddr, &status);
+		pci_unmap_single(dev->pdev, paddr, sizeof(struct POSTSTATUS),2);
+		kfree(post);
+		if ((buffer[0] == '0') && (buffer[1] == 'x')) {
+			ret = (buffer[2] <= '9') ? (buffer[2] - '0') : (buffer[2] - 'A' + 10);
+			ret <<= 4;
+			ret += (buffer[3] <= '9') ? (buffer[3] - '0') : (buffer[3] - 'A' + 10);
+		}
+		pci_unmap_single(dev->pdev, baddr, 512, 1);
+		kfree(buffer);
+		return ret;
+	}
 	/*
-	 *	Wait for the adapter to be up and running. Wait up to 3 minutes
+	 *	Wait for the adapter to be up and running.
 	 */
 	if (!(status & KERNEL_UP_AND_RUNNING))
 		return -3;
@@ -354,26 +381,24 @@
 	 *	Everything is OK
 	 */
 	return 0;
-} /* aac_rkt_check_health */
+}
 
 /**
  *	aac_rkt_init	-	initialize an i960 based AAC card
  *	@dev: device to configure
- *	@devnum: adapter number
  *
  *	Allocate and set up resources for the i960 based AAC variants. The 
  *	device_interface in the commregion will be allocated and linked 
  *	to the comm region.
  */
 
-int aac_rkt_init(struct aac_dev *dev, unsigned long num)
+int aac_rkt_init(struct aac_dev *dev)
 {
 	unsigned long start;
 	unsigned long status;
 	int instance;
 	const char * name;
 
-	dev->devnum = num;
 	instance = dev->id;
 	name     = dev->name;
 
@@ -388,14 +413,21 @@
 	/*
 	 *	Check to see if the board failed any self tests.
 	 */
-	if (rkt_readl(dev, IndexRegs.Mailbox[7]) & SELF_TEST_FAILED) {
+	if (rkt_readl(dev, MUnit.OMRx[0]) & SELF_TEST_FAILED) {
 		printk(KERN_ERR "%s%d: adapter self-test failed.\n", dev->name, instance);
 		return -1;
 	}
 	/*
+	 *	Check to see if the monitor panic'd while booting.
+	 */
+	if (rkt_readl(dev, MUnit.OMRx[0]) & MONITOR_PANIC) {
+		printk(KERN_ERR "%s%d: adapter monitor panic.\n", dev->name, instance);
+		return -1;
+	}
+	/*
 	 *	Check to see if the board panic'd while booting.
 	 */
-	if (rkt_readl(dev, IndexRegs.Mailbox[7]) & KERNEL_PANIC) {
+	if (rkt_readl(dev, MUnit.OMRx[0]) & KERNEL_PANIC) {
 		printk(KERN_ERR "%s%d: adapter kernel panic'd.\n", dev->name, instance);
 		return -1;
 	}
@@ -403,7 +435,7 @@
 	/*
 	 *	Wait for the adapter to be up and running. Wait up to 3 minutes
 	 */
-	while (!(rkt_readl(dev, IndexRegs.Mailbox[7]) & KERNEL_UP_AND_RUNNING)) 
+	while (!(rkt_readl(dev, MUnit.OMRx[0]) & KERNEL_UP_AND_RUNNING))
 	{
 		if(time_after(jiffies, start+180*HZ))
 		{
diff -Nru a/drivers/scsi/aacraid/rx.c b/drivers/scsi/aacraid/rx.c
--- a/drivers/scsi/aacraid/rx.c	2004-06-20 13:22:08 -07:00
+++ b/drivers/scsi/aacraid/rx.c	2004-06-20 13:22:08 -07:00
@@ -38,6 +38,7 @@
 #include <linux/blkdev.h>
 #include <linux/delay.h>
 #include <linux/completion.h>
+#include <linux/time.h>
 #include <linux/interrupt.h>
 #include <asm/semaphore.h>
 
@@ -67,8 +68,8 @@
 			rx_writel(dev, InboundDoorbellReg,DoorBellPrintfDone);
 		}
 		else if (bellbits & DoorBellAdapterNormCmdReady) {
-			aac_command_normal(&dev->queues->queue[HostNormCmdQueue]);
 			rx_writel(dev, MUnit.ODR, DoorBellAdapterNormCmdReady);
+			aac_command_normal(&dev->queues->queue[HostNormCmdQueue]);
 		}
 		else if (bellbits & DoorBellAdapterNormRespReady) {
 			aac_response_normal(&dev->queues->queue[HostNormRespQueue]);
@@ -305,7 +306,7 @@
 	struct aac_init *init;
 
 	init = dev->init;
-	init->HostElapsedSeconds = cpu_to_le32(jiffies/HZ);
+	init->HostElapsedSeconds = cpu_to_le32(get_seconds());
 	/*
 	 *	Tell the adapter we are back and up and running so it will scan
 	 *	its command queues and enable our interrupts
@@ -341,12 +342,36 @@
 	if (status & SELF_TEST_FAILED)
 		return -1;
 	/*
-	 *	Check to see if the board panic'd while booting.
+	 *	Check to see if the board panic'd.
 	 */
-	if (status & KERNEL_PANIC)
-		return -2;
+	if (status & KERNEL_PANIC) {
+		char * buffer = kmalloc(512, GFP_KERNEL);
+		struct POSTSTATUS {
+			u32 Post_Command;
+			u32 Post_Address;
+		} * post = kmalloc(sizeof(struct POSTSTATUS), GFP_KERNEL);
+		dma_addr_t paddr = pci_map_single(dev->pdev, post, sizeof(struct POSTSTATUS), 2);
+		dma_addr_t baddr = pci_map_single(dev->pdev, buffer, 512, 1);
+		u32 status = -1;
+		int ret = -2;
+		memset(buffer, 0, 512);
+		post->Post_Command = cpu_to_le32(COMMAND_POST_RESULTS);
+		post->Post_Address = cpu_to_le32(baddr);
+		rx_writel(dev, MUnit.IMRx[0], cpu_to_le32(paddr));
+		rx_sync_cmd(dev, COMMAND_POST_RESULTS, baddr, &status);
+		pci_unmap_single(dev->pdev, paddr, sizeof(struct POSTSTATUS), 2);
+		kfree(post);
+		if ((buffer[0] == '0') && (buffer[1] == 'x')) {
+			ret = (buffer[2] <= '9') ? (buffer[2] - '0') : (buffer[2] - 'A' + 10);
+			ret <<= 4;
+			ret += (buffer[3] <= '9') ? (buffer[3] - '0') : (buffer[3] - 'A' + 10);
+		}
+		pci_unmap_single(dev->pdev, baddr, 512, 1);
+		kfree(buffer);
+		return ret;
+	}
 	/*
-	 *	Wait for the adapter to be up and running. Wait up to 3 minutes
+	 *	Wait for the adapter to be up and running.
 	 */
 	if (!(status & KERNEL_UP_AND_RUNNING))
 		return -3;
@@ -359,21 +384,19 @@
 /**
  *	aac_rx_init	-	initialize an i960 based AAC card
  *	@dev: device to configure
- *	@devnum: adapter number
  *
  *	Allocate and set up resources for the i960 based AAC variants. The 
  *	device_interface in the commregion will be allocated and linked 
  *	to the comm region.
  */
 
-int aac_rx_init(struct aac_dev *dev, unsigned long num)
+int aac_rx_init(struct aac_dev *dev)
 {
 	unsigned long start;
 	unsigned long status;
 	int instance;
 	const char * name;
 
-	dev->devnum = num;
 	instance = dev->id;
 	name     = dev->name;
 
@@ -388,22 +411,30 @@
 	/*
 	 *	Check to see if the board failed any self tests.
 	 */
-	if (rx_readl(dev, IndexRegs.Mailbox[7]) & SELF_TEST_FAILED) {
+	if (rx_readl(dev, MUnit.OMRx[0]) & SELF_TEST_FAILED) {
 		printk(KERN_ERR "%s%d: adapter self-test failed.\n", dev->name, instance);
 		return -1;
 	}
 	/*
 	 *	Check to see if the board panic'd while booting.
 	 */
-	if (rx_readl(dev, IndexRegs.Mailbox[7]) & KERNEL_PANIC) {
-		printk(KERN_ERR "%s%d: adapter kernel panic'd.\n", dev->name, instance);
+	if (rx_readl(dev, MUnit.OMRx[0]) & KERNEL_PANIC) {
+		printk(KERN_ERR "%s%d: adapter kernel panic.\n", dev->name, instance);
+		return -1;
+	}
+	/*
+	 *	Check to see if the monitor panic'd while booting.
+	 */
+	if (rx_readl(dev, MUnit.OMRx[0]) & MONITOR_PANIC) {
+		printk(KERN_ERR "%s%d: adapter monitor panic.\n", dev->name, instance);
 		return -1;
 	}
 	start = jiffies;
 	/*
 	 *	Wait for the adapter to be up and running. Wait up to 3 minutes
 	 */
-	while (!(rx_readl(dev, IndexRegs.Mailbox[7]) & KERNEL_UP_AND_RUNNING)) 
+	while ((!(rx_readl(dev, IndexRegs.Mailbox[7]) & KERNEL_UP_AND_RUNNING))
+		|| (!(rx_readl(dev, MUnit.OMRx[0]) & KERNEL_UP_AND_RUNNING)))
 	{
 		if(time_after(jiffies, start+180*HZ))
 		{
@@ -435,6 +466,11 @@
 	 *	Start any kernel threads needed
 	 */
 	dev->thread_pid = kernel_thread((int (*)(void *))aac_command_thread, dev, 0);
+	if(dev->thread_pid < 0)
+	{
+		printk(KERN_ERR "aacraid: Unable to create rx thread.\n");
+		return -1;
+	}
 	/*
 	 *	Tell the adapter that all is configured, and it can start
 	 *	accepting requests
diff -Nru a/drivers/scsi/aacraid/sa.c b/drivers/scsi/aacraid/sa.c
--- a/drivers/scsi/aacraid/sa.c	2004-06-20 13:22:08 -07:00
+++ b/drivers/scsi/aacraid/sa.c	2004-06-20 13:22:08 -07:00
@@ -38,6 +38,7 @@
 #include <linux/blkdev.h>
 #include <linux/delay.h>
 #include <linux/completion.h>
+#include <linux/time.h>
 #include <linux/interrupt.h>
 #include <asm/semaphore.h>
 
@@ -329,26 +330,23 @@
 	 *	Everything is OK
 	 */
 	return 0;
-} /* aac_sa_check_health */
+}
 
 /**
  *	aac_sa_init	-	initialize an ARM based AAC card
  *	@dev: device to configure
- *	@devnum: adapter number
  *
  *	Allocate and set up resources for the ARM based AAC variants. The 
  *	device_interface in the commregion will be allocated and linked 
  *	to the comm region.
  */
 
-int aac_sa_init(struct aac_dev *dev, unsigned long devnum)
+int aac_sa_init(struct aac_dev *dev)
 {
 	unsigned long start;
 	unsigned long status;
 	int instance;
 	const char *name;
-
-	dev->devnum = devnum;
 
 	dprintk(("PREINST\n"));
 	instance = dev->id;
diff -Nru a/drivers/scsi/aha152x.c b/drivers/scsi/aha152x.c
--- a/drivers/scsi/aha152x.c	2004-06-20 13:22:07 -07:00
+++ b/drivers/scsi/aha152x.c	2004-06-20 13:22:07 -07:00
@@ -257,7 +257,7 @@
 #include <scsi/scsicam.h>
 
 #include "scsi.h"
-#include "hosts.h"
+#include <scsi/scsi_host.h>
 #include "aha152x.h"
 
 
diff -Nru a/drivers/scsi/arm/acornscsi.c b/drivers/scsi/arm/acornscsi.c
--- a/drivers/scsi/arm/acornscsi.c	2004-06-20 13:22:08 -07:00
+++ b/drivers/scsi/arm/acornscsi.c	2004-06-20 13:22:08 -07:00
@@ -150,7 +150,7 @@
 #include <asm/ecard.h>
 
 #include "../scsi.h"
-#include "../hosts.h"
+#include <scsi/scsi_host.h>
 #include "acornscsi.h"
 #include "msgqueue.h"
 #include "scsi.h"
diff -Nru a/drivers/scsi/arm/arxescsi.c b/drivers/scsi/arm/arxescsi.c
--- a/drivers/scsi/arm/arxescsi.c	2004-06-20 13:22:08 -07:00
+++ b/drivers/scsi/arm/arxescsi.c	2004-06-20 13:22:08 -07:00
@@ -37,7 +37,7 @@
 #include <asm/ecard.h>
 
 #include "../scsi.h"
-#include "../hosts.h"
+#include <scsi/scsi_host.h>
 #include "fas216.h"
 
 struct arxescsi_info {
diff -Nru a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
--- a/drivers/scsi/arm/cumana_1.c	2004-06-20 13:22:07 -07:00
+++ b/drivers/scsi/arm/cumana_1.c	2004-06-20 13:22:07 -07:00
@@ -17,7 +17,7 @@
 #include <asm/system.h>
 
 #include "../scsi.h"
-#include "../hosts.h"
+#include <scsi/scsi_host.h>
 
 #include <scsi/scsicam.h>
 
diff -Nru a/drivers/scsi/arm/cumana_2.c b/drivers/scsi/arm/cumana_2.c
--- a/drivers/scsi/arm/cumana_2.c	2004-06-20 13:22:08 -07:00
+++ b/drivers/scsi/arm/cumana_2.c	2004-06-20 13:22:08 -07:00
@@ -35,7 +35,7 @@
 #include <asm/pgtable.h>
 
 #include "../scsi.h"
-#include "../hosts.h"
+#include <scsi/scsi_host.h>
 #include "fas216.h"
 #include "scsi.h"
 
diff -Nru a/drivers/scsi/arm/ecoscsi.c b/drivers/scsi/arm/ecoscsi.c
--- a/drivers/scsi/arm/ecoscsi.c	2004-06-20 13:22:08 -07:00
+++ b/drivers/scsi/arm/ecoscsi.c	2004-06-20 13:22:08 -07:00
@@ -33,7 +33,7 @@
 #include <asm/system.h>
 
 #include "../scsi.h"
-#include "../hosts.h"
+#include <scsi/scsi_host.h>
 
 #define NCR5380_implementation_fields	int port, ctrl
 #define NCR5380_local_declare()		struct Scsi_Host *_instance
diff -Nru a/drivers/scsi/arm/eesox.c b/drivers/scsi/arm/eesox.c
--- a/drivers/scsi/arm/eesox.c	2004-06-20 13:22:08 -07:00
+++ b/drivers/scsi/arm/eesox.c	2004-06-20 13:22:08 -07:00
@@ -41,7 +41,7 @@
 #include <asm/pgtable.h>
 
 #include "../scsi.h"
-#include "../hosts.h"
+#include <scsi/scsi_host.h>
 #include "fas216.h"
 #include "scsi.h"
 
diff -Nru a/drivers/scsi/arm/fas216.c b/drivers/scsi/arm/fas216.c
--- a/drivers/scsi/arm/fas216.c	2004-06-20 13:22:08 -07:00
+++ b/drivers/scsi/arm/fas216.c	2004-06-20 13:22:08 -07:00
@@ -52,7 +52,7 @@
 #include <asm/ecard.h>
 
 #include "../scsi.h"
-#include "../hosts.h"
+#include <scsi/scsi_host.h>
 #include "fas216.h"
 #include "scsi.h"
 
diff -Nru a/drivers/scsi/arm/oak.c b/drivers/scsi/arm/oak.c
--- a/drivers/scsi/arm/oak.c	2004-06-20 13:22:07 -07:00
+++ b/drivers/scsi/arm/oak.c	2004-06-20 13:22:07 -07:00
@@ -17,7 +17,7 @@
 #include <asm/system.h>
 
 #include "../scsi.h"
-#include "../hosts.h"
+#include <scsi/scsi_host.h>
 
 #define AUTOSENSE
 /*#define PSEUDO_DMA*/
diff -Nru a/drivers/scsi/arm/powertec.c b/drivers/scsi/arm/powertec.c
--- a/drivers/scsi/arm/powertec.c	2004-06-20 13:22:08 -07:00
+++ b/drivers/scsi/arm/powertec.c	2004-06-20 13:22:08 -07:00
@@ -26,7 +26,7 @@
 #include <asm/pgtable.h>
 
 #include "../scsi.h"
-#include "../hosts.h"
+#include <scsi/scsi_host.h>
 #include "fas216.h"
 #include "scsi.h"
 
diff -Nru a/drivers/scsi/constants.c b/drivers/scsi/constants.c
--- a/drivers/scsi/constants.c	2004-06-20 13:22:08 -07:00
+++ b/drivers/scsi/constants.c	2004-06-20 13:22:08 -07:00
@@ -6,13 +6,16 @@
  *   by D. Gilbert and aeb (20020609)
  */
 
-#include <linux/module.h>
-
 #include <linux/config.h>
 #include <linux/blkdev.h>
+#include <linux/module.h>
 #include <linux/kernel.h>
-#include "scsi.h"
+
+#include <scsi/scsi.h>
+#include <scsi/scsi_device.h>
 #include <scsi/scsi_host.h>
+#include <scsi/scsi_request.h>
+
 
 #define CONST_COMMAND   0x01
 #define CONST_STATUS    0x02
diff -Nru a/drivers/scsi/esp.c b/drivers/scsi/esp.c
--- a/drivers/scsi/esp.c	2004-06-20 13:22:08 -07:00
+++ b/drivers/scsi/esp.c	2004-06-20 13:22:08 -07:00
@@ -27,6 +27,8 @@
 #include <linux/interrupt.h>
 #include <linux/module.h>
 
+#include "scsi.h"
+#include <scsi/scsi_host.h>
 #include "esp.h"
 
 #include <asm/sbus.h>
diff -Nru a/drivers/scsi/gdth.c b/drivers/scsi/gdth.c
--- a/drivers/scsi/gdth.c	2004-06-20 13:22:08 -07:00
+++ b/drivers/scsi/gdth.c	2004-06-20 13:22:08 -07:00
@@ -410,7 +410,7 @@
 #endif
 
 #include "scsi.h"
-#include "hosts.h"
+#include <scsi/scsi_host.h>
 #include "gdth.h"
 
 static void gdth_delay(int milliseconds);
diff -Nru a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
--- a/drivers/scsi/hosts.c	2004-06-20 13:22:07 -07:00
+++ b/drivers/scsi/hosts.c	2004-06-20 13:22:07 -07:00
@@ -27,13 +27,11 @@
 #include <linux/string.h>
 #include <linux/mm.h>
 #include <linux/init.h>
-#include <linux/list.h>
 #include <linux/completion.h>
-#include <linux/unistd.h>
 
+#include <scsi/scsi_device.h>
 #include <scsi/scsi_host.h>
 #include <scsi/scsi_transport.h>
-#include "scsi.h"
 
 #include "scsi_priv.h"
 #include "scsi_logging.h"
diff -Nru a/drivers/scsi/hosts.h b/drivers/scsi/hosts.h
--- a/drivers/scsi/hosts.h	2004-06-20 13:22:07 -07:00
+++ b/drivers/scsi/hosts.h	2004-06-20 13:22:07 -07:00
@@ -1,2 +1,2 @@
-// #warning "This file is obsolete, please use <scsi/scsi_host.h> instead"
+#warning "This file is obsolete, please use <scsi/scsi_host.h> instead"
 #include <scsi/scsi_host.h>
diff -Nru a/drivers/scsi/ipr.c b/drivers/scsi/ipr.c
--- a/drivers/scsi/ipr.c	2004-06-20 13:22:08 -07:00
+++ b/drivers/scsi/ipr.c	2004-06-20 13:22:08 -07:00
@@ -448,6 +448,7 @@
 {
 	ipr_reinit_ipr_cmnd(ipr_cmd);
 	ipr_cmd->u.scratch = 0;
+	ipr_cmd->sibling = NULL;
 	init_timer(&ipr_cmd->timer);
 }
 
@@ -676,8 +677,8 @@
  **/
 static void ipr_internal_cmd_done(struct ipr_cmnd *ipr_cmd)
 {
-	if (ipr_cmd->u.sibling)
-		ipr_cmd->u.sibling = NULL;
+	if (ipr_cmd->sibling)
+		ipr_cmd->sibling = NULL;
 	else
 		complete(&ipr_cmd->completion);
 }
@@ -3015,10 +3016,10 @@
 	 * If abort has not completed, indicate the reset has, else call the
 	 * abort's done function to wake the sleeping eh thread
 	 */
-	if (ipr_cmd->u.sibling->u.sibling)
-		ipr_cmd->u.sibling->u.sibling = NULL;
+	if (ipr_cmd->sibling->sibling)
+		ipr_cmd->sibling->sibling = NULL;
 	else
-		ipr_cmd->u.sibling->done(ipr_cmd->u.sibling);
+		ipr_cmd->sibling->done(ipr_cmd->sibling);
 
 	list_add_tail(&ipr_cmd->queue, &ioa_cfg->free_q);
 	LEAVE;
@@ -3051,8 +3052,8 @@
 
 	ipr_sdev_err(ipr_cmd->u.sdev, "Abort timed out. Resetting bus\n");
 	reset_cmd = ipr_get_free_ipr_cmnd(ioa_cfg);
-	ipr_cmd->u.sibling = reset_cmd;
-	reset_cmd->u.sibling = ipr_cmd;
+	ipr_cmd->sibling = reset_cmd;
+	reset_cmd->sibling = ipr_cmd;
 	reset_cmd->ioarcb.res_handle = ipr_cmd->ioarcb.res_handle;
 	cmd_pkt = &reset_cmd->ioarcb.cmd_pkt;
 	cmd_pkt->request_type = IPR_RQTYPE_IOACMD;
@@ -3533,6 +3534,11 @@
 	res->in_erp = 1;
 
 	ipr_reinit_ipr_cmnd_for_erp(ipr_cmd);
+
+	if (!res->tcq_active) {
+		ipr_erp_request_sense(ipr_cmd);
+		return;
+	}
 
 	cmd_pkt = &ipr_cmd->ioarcb.cmd_pkt;
 	cmd_pkt->request_type = IPR_RQTYPE_IOACMD;
diff -Nru a/drivers/scsi/ipr.h b/drivers/scsi/ipr.h
--- a/drivers/scsi/ipr.h	2004-06-20 13:22:07 -07:00
+++ b/drivers/scsi/ipr.h	2004-06-20 13:22:07 -07:00
@@ -36,8 +36,8 @@
 /*
  * Literals
  */
-#define IPR_DRIVER_VERSION "2.0.9"
-#define IPR_DRIVER_DATE "(May 26, 2004)"
+#define IPR_DRIVER_VERSION "2.0.10"
+#define IPR_DRIVER_DATE "(June 7, 2004)"
 
 /*
  * IPR_DBG_TRACE: Setting this to 1 will turn on some general function tracing
@@ -932,13 +932,13 @@
 	dma_addr_t sense_buffer_dma;
 	unsigned short dma_use_sg;
 	dma_addr_t dma_handle;
+	struct ipr_cmnd *sibling;
 	union {
 		enum ipr_shutdown_type shutdown_type;
 		struct ipr_hostrcb *hostrcb;
 		unsigned long time_left;
 		unsigned long scratch;
 		struct ipr_resource_entry *res;
-		struct ipr_cmnd *sibling;
 		struct scsi_device *sdev;
 	} u;
 
diff -Nru a/drivers/scsi/pcmcia/nsp_cs.c b/drivers/scsi/pcmcia/nsp_cs.c
--- a/drivers/scsi/pcmcia/nsp_cs.c	2004-06-20 13:22:08 -07:00
+++ b/drivers/scsi/pcmcia/nsp_cs.c	2004-06-20 13:22:08 -07:00
@@ -46,7 +46,7 @@
 #include <asm/irq.h>
 
 #include <../drivers/scsi/scsi.h>
-#include <../drivers/scsi/hosts.h>
+#include <scsi/scsi_host.h>
 
 #include <scsi/scsi.h>
 #include <scsi/scsi_ioctl.h>
diff -Nru a/drivers/scsi/qlogicpti.c b/drivers/scsi/qlogicpti.c
--- a/drivers/scsi/qlogicpti.c	2004-06-20 13:22:08 -07:00
+++ b/drivers/scsi/qlogicpti.c	2004-06-20 13:22:08 -07:00
@@ -27,6 +27,8 @@
 
 #include <asm/byteorder.h>
 
+#include "scsi.h"
+#include <scsi/scsi_host.h>
 #include "qlogicpti.h"
 
 #include <asm/sbus.h>
diff -Nru a/drivers/scsi/scsi.c b/drivers/scsi/scsi.c
--- a/drivers/scsi/scsi.c	2004-06-20 13:22:08 -07:00
+++ b/drivers/scsi/scsi.c	2004-06-20 13:22:08 -07:00
@@ -56,8 +56,14 @@
 #include <linux/notifier.h>
 #include <linux/cpu.h>
 
+#include <scsi/scsi.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_dbg.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_eh.h>
 #include <scsi/scsi_host.h>
-#include "scsi.h"
+#include <scsi/scsi_tcq.h>
+#include <scsi/scsi_request.h>
 
 #include "scsi_priv.h"
 #include "scsi_logging.h"
@@ -400,7 +406,7 @@
 			 * output in scsi_log_completion.
 			 */
 			printk("                 ");
-			print_command(cmd->cmnd);
+			scsi_print_command(cmd);
 			if (level > 3) {
 				printk(KERN_INFO "buffer = 0x%p, bufflen = %d,"
 				       " done = 0x%p, queuecommand 0x%p\n",
@@ -468,13 +474,13 @@
 				printk("UNKNOWN");
 			}
 			printk(" %8x ", cmd->result);
-			print_command(cmd->cmnd);
+			scsi_print_command(cmd);
 			if (status_byte(cmd->result) & CHECK_CONDITION) {
 				/*
 				 * XXX The print_sense formatting/prefix
 				 * doesn't match this function.
 				 */
-				print_sense("", cmd);
+				scsi_print_sense("", cmd);
 			}
 			if (level > 3) {
 				printk(KERN_INFO "scsi host busy %d failed %d\n",
@@ -689,8 +695,6 @@
  */
 void scsi_done(struct scsi_cmnd *cmd)
 {
-	unsigned long flags;
-
 	/*
 	 * We don't have to worry about this one timing out any more.
 	 * If we are unable to remove the timer, then the command
@@ -701,6 +705,14 @@
 	 */
 	if (!scsi_delete_timer(cmd))
 		return;
+	__scsi_done(cmd);
+}
+
+/* Private entry to scsi_done() to complete a command when the timer
+ * isn't running --- used by scsi_times_out */
+void __scsi_done(struct scsi_cmnd *cmd)
+{
+	unsigned long flags;
 
 	/*
 	 * Set the serial numbers back to zero
diff -Nru a/drivers/scsi/scsi_devinfo.c b/drivers/scsi/scsi_devinfo.c
--- a/drivers/scsi/scsi_devinfo.c	2004-06-20 13:22:07 -07:00
+++ b/drivers/scsi/scsi_devinfo.c	2004-06-20 13:22:07 -07:00
@@ -6,12 +6,13 @@
 #include <linux/moduleparam.h>
 #include <linux/proc_fs.h>
 #include <linux/seq_file.h>
+
+#include <scsi/scsi_device.h>
 #include <scsi/scsi_devinfo.h>
 
-#include "scsi.h"
-#include <scsi/scsi_host.h>
 #include "scsi_priv.h"
 
+
 /*
  * scsi_dev_info_list: structure to hold black/white listed devices.
  */
@@ -163,7 +164,7 @@
 	{"Medion", "Flash XL  MMC/SD", "2.6D", BLIST_FORCELUN},
 	{"MegaRAID", "LD", NULL, BLIST_FORCELUN},
 	{"MICROP", "4110", NULL, BLIST_NOTQ},
-	{"MYLEX", "DACARMRB", "*", BLIST_SPARSELUN | BLIST_LARGELUN},
+	{"MYLEX", "DACARMRB", "*", BLIST_REPORTLUN2},
 	{"nCipher", "Fastness Crypto", NULL, BLIST_FORCELUN},
 	{"NAKAMICH", "MJ-4.8S", NULL, BLIST_FORCELUN | BLIST_SINGLELUN},
 	{"NAKAMICH", "MJ-5.16S", NULL, BLIST_FORCELUN | BLIST_SINGLELUN},
@@ -177,7 +178,7 @@
 	{"SanDisk", "ImageMate CF-SD1", NULL, BLIST_FORCELUN},
 	{"SGI", "RAID3", "*", BLIST_SPARSELUN},
 	{"SGI", "RAID5", "*", BLIST_SPARSELUN},
-	{"SGI", "TP9100", "*", BLIST_SPARSELUN | BLIST_LARGELUN},
+	{"SGI", "TP9100", "*", BLIST_REPORTLUN2},
 	{"SMSC", "USB 2 HS-CF", NULL, BLIST_SPARSELUN},
 	{"SONY", "CD-ROM CDU-8001", NULL, BLIST_BORKEN},
 	{"SONY", "TSL", NULL, BLIST_FORCELUN},		/* DDS3 & DDS4 autoloaders */
diff -Nru a/drivers/scsi/scsi_error.c b/drivers/scsi/scsi_error.c
--- a/drivers/scsi/scsi_error.c	2004-06-20 13:22:07 -07:00
+++ b/drivers/scsi/scsi_error.c	2004-06-20 13:22:07 -07:00
@@ -23,10 +23,14 @@
 #include <linux/interrupt.h>
 #include <linux/blkdev.h>
 #include <linux/smp_lock.h>
-#include <scsi/scsi_ioctl.h>
 
-#include "scsi.h"
+#include <scsi/scsi.h>
+#include <scsi/scsi_dbg.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_eh.h>
 #include <scsi/scsi_host.h>
+#include <scsi/scsi_ioctl.h>
+#include <scsi/scsi_request.h>
 
 #include "scsi_priv.h"
 #include "scsi_logging.h"
@@ -162,6 +166,24 @@
 void scsi_times_out(struct scsi_cmnd *scmd)
 {
 	scsi_log_completion(scmd, TIMEOUT_ERROR);
+
+	if (scmd->device->host->hostt->eh_timed_out)
+		switch (scmd->device->host->hostt->eh_timed_out(scmd)) {
+		case EH_HANDLED:
+			__scsi_done(scmd);
+			return;
+		case EH_RESET_TIMER:
+			/* This allows a single retry even of a command
+			 * with allowed == 0 */
+			if (scmd->retries++ > scmd->allowed)
+				break;
+			scsi_add_timer(scmd, scmd->timeout_per_command,
+				       scsi_times_out);
+			return;
+		case EH_NOT_HANDLED:
+			break;
+		}
+
 	if (unlikely(!scsi_eh_scmd_add(scmd, SCSI_EH_CANCEL_CMD))) {
 		panic("Error handler thread not present at %p %p %s %d",
 		      scmd, scmd->device->host, __FILE__, __LINE__);
@@ -655,7 +677,7 @@
 		SCSI_LOG_ERROR_RECOVERY(3, printk("sense requested for %p"
 						  " result %x\n", scmd,
 						  scmd->result));
-		SCSI_LOG_ERROR_RECOVERY(3, print_sense("bh", scmd));
+		SCSI_LOG_ERROR_RECOVERY(3, scsi_print_sense("bh", scmd));
 
 		rtn = scsi_decide_disposition(scmd);
 
diff -Nru a/drivers/scsi/scsi_ioctl.c b/drivers/scsi/scsi_ioctl.c
--- a/drivers/scsi/scsi_ioctl.c	2004-06-20 13:22:08 -07:00
+++ b/drivers/scsi/scsi_ioctl.c	2004-06-20 13:22:08 -07:00
@@ -5,23 +5,21 @@
  *   for the ones that remain
  */
 #include <linux/module.h>
-
-#include <asm/io.h>
-#include <asm/uaccess.h>
-#include <asm/system.h>
-#include <asm/page.h>
-
+#include <linux/blkdev.h>
 #include <linux/interrupt.h>
 #include <linux/errno.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/mm.h>
 #include <linux/string.h>
+#include <asm/uaccess.h>
 
-#include <linux/blkdev.h>
-#include "scsi.h"
+#include <scsi/scsi.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_eh.h>
 #include <scsi/scsi_host.h>
 #include <scsi/scsi_ioctl.h>
+#include <scsi/scsi_request.h>
 
 #include "scsi_logging.h"
 
diff -Nru a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c
--- a/drivers/scsi/scsi_lib.c	2004-06-20 13:22:08 -07:00
+++ b/drivers/scsi/scsi_lib.c	2004-06-20 13:22:08 -07:00
@@ -16,9 +16,13 @@
 #include <linux/init.h>
 #include <linux/pci.h>
 
+#include <scsi/scsi.h>
+#include <scsi/scsi_dbg.h>
+#include <scsi/scsi_device.h>
 #include <scsi/scsi_driver.h>
+#include <scsi/scsi_eh.h>
 #include <scsi/scsi_host.h>
-#include "scsi.h"
+#include <scsi/scsi_request.h>
 
 #include "scsi_priv.h"
 #include "scsi_logging.h"
@@ -837,8 +841,8 @@
 			printk("scsi%d: ERROR on channel %d, id %d, lun %d, CDB: ",
 			       cmd->device->host->host_no, (int) cmd->device->channel,
 			       (int) cmd->device->id, (int) cmd->device->lun);
-			print_command(cmd->data_cmnd);
-			print_sense("", cmd);
+			__scsi_print_command(cmd->data_cmnd);
+			scsi_print_sense("", cmd);
 			cmd = scsi_end_request(cmd, 0, block_bytes, 1);
 			return;
 		default:
@@ -862,7 +866,7 @@
 		       cmd->device->lun, result);
 
 		if (driver_byte(result) & DRIVER_SENSE)
-			print_sense("", cmd);
+			scsi_print_sense("", cmd);
 		/*
 		 * Mark a single buffer as not uptodate.  Queue the remainder.
 		 * We sometimes get this cruft in the event that a medium error
diff -Nru a/drivers/scsi/scsi_priv.h b/drivers/scsi/scsi_priv.h
--- a/drivers/scsi/scsi_priv.h	2004-06-20 13:22:08 -07:00
+++ b/drivers/scsi/scsi_priv.h	2004-06-20 13:22:08 -07:00
@@ -82,6 +82,7 @@
 extern void scsi_init_cmd_from_req(struct scsi_cmnd *cmd,
 		struct scsi_request *sreq);
 extern void __scsi_release_request(struct scsi_request *sreq);
+extern void __scsi_done(struct scsi_cmnd *cmd);
 #ifdef CONFIG_SCSI_LOGGING
 void scsi_log_send(struct scsi_cmnd *cmd);
 void scsi_log_completion(struct scsi_cmnd *cmd, int disposition);
diff -Nru a/drivers/scsi/scsi_proc.c b/drivers/scsi/scsi_proc.c
--- a/drivers/scsi/scsi_proc.c	2004-06-20 13:22:07 -07:00
+++ b/drivers/scsi/scsi_proc.c	2004-06-20 13:22:07 -07:00
@@ -27,8 +27,9 @@
 #include <linux/seq_file.h>
 #include <asm/uaccess.h>
 
+#include <scsi/scsi.h>
+#include <scsi/scsi_device.h>
 #include <scsi/scsi_host.h>
-#include "scsi.h"
 
 #include "scsi_priv.h"
 #include "scsi_logging.h"
diff -Nru a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c
--- a/drivers/scsi/scsi_scan.c	2004-06-20 13:22:08 -07:00
+++ b/drivers/scsi/scsi_scan.c	2004-06-20 13:22:08 -07:00
@@ -32,11 +32,13 @@
 #include <linux/blkdev.h>
 #include <asm/semaphore.h>
 
+#include <scsi/scsi.h>
+#include <scsi/scsi_device.h>
 #include <scsi/scsi_driver.h>
 #include <scsi/scsi_devinfo.h>
 #include <scsi/scsi_host.h>
+#include <scsi/scsi_request.h>
 #include <scsi/scsi_transport.h>
-#include "scsi.h"
 
 #include "scsi_priv.h"
 #include "scsi_logging.h"
diff -Nru a/drivers/scsi/scsi_syms.c b/drivers/scsi/scsi_syms.c
--- a/drivers/scsi/scsi_syms.c	2004-06-20 13:22:08 -07:00
+++ b/drivers/scsi/scsi_syms.c	2004-06-20 13:22:08 -07:00
@@ -5,24 +5,15 @@
 #include <linux/config.h>
 #include <linux/module.h>
 
-#include <linux/sched.h>
-#include <linux/timer.h>
-#include <linux/string.h>
-#include <linux/slab.h>
-#include <linux/ioport.h>
-#include <linux/kernel.h>
-#include <linux/blkdev.h>
-#include <linux/fs.h>
-
-#include <asm/system.h>
-#include <asm/irq.h>
-#include <asm/dma.h>
-
+#include <scsi/scsi.h>
+#include <scsi/scsi_dbg.h>
+#include <scsi/scsi_device.h>
 #include <scsi/scsi_driver.h>
+#include <scsi/scsi_eh.h>
 #include <scsi/scsi_host.h>
 #include <scsi/scsi_ioctl.h>
+#include <scsi/scsi_request.h>
 #include <scsi/scsicam.h>
-#include "scsi.h"
 
 #include "scsi_logging.h"
 
diff -Nru a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c
--- a/drivers/scsi/scsi_sysfs.c	2004-06-20 13:22:07 -07:00
+++ b/drivers/scsi/scsi_sysfs.c	2004-06-20 13:22:07 -07:00
@@ -12,9 +12,10 @@
 #include <linux/blkdev.h>
 #include <linux/device.h>
 
+#include <scsi/scsi.h>
+#include <scsi/scsi_device.h>
 #include <scsi/scsi_host.h>
 #include <scsi/scsi_transport.h>
-#include "scsi.h"
 
 #include "scsi_priv.h"
 #include "scsi_logging.h"
diff -Nru a/drivers/scsi/scsicam.c b/drivers/scsi/scsicam.c
--- a/drivers/scsi/scsicam.c	2004-06-20 13:22:08 -07:00
+++ b/drivers/scsi/scsicam.c	2004-06-20 13:22:08 -07:00
@@ -11,16 +11,15 @@
  */
 
 #include <linux/module.h>
-
 #include <linux/fs.h>
 #include <linux/genhd.h>
 #include <linux/kernel.h>
 #include <linux/blkdev.h>
 #include <linux/buffer_head.h>
 #include <asm/unaligned.h>
-#include "scsi.h"
-#include <scsi/scsi_host.h>
+
 #include <scsi/scsicam.h>
+
 
 static int setsize(unsigned long capacity, unsigned int *cyls, unsigned int *hds,
 		   unsigned int *secs);
diff -Nru a/drivers/scsi/sd.c b/drivers/scsi/sd.c
--- a/drivers/scsi/sd.c	2004-06-20 13:22:08 -07:00
+++ b/drivers/scsi/sd.c	2004-06-20 13:22:08 -07:00
@@ -44,18 +44,20 @@
 #include <linux/errno.h>
 #include <linux/interrupt.h>
 #include <linux/init.h>
-#include <linux/reboot.h>
-#include <linux/vmalloc.h>
 #include <linux/blkdev.h>
 #include <linux/blkpg.h>
 #include <linux/kref.h>
 #include <asm/uaccess.h>
 
-#include "scsi.h"
-#include <scsi/scsi_host.h>
-
+#include <scsi/scsi.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_dbg.h>
+#include <scsi/scsi_device.h>
 #include <scsi/scsi_driver.h>
+#include <scsi/scsi_eh.h>
+#include <scsi/scsi_host.h>
 #include <scsi/scsi_ioctl.h>
+#include <scsi/scsi_request.h>
 #include <scsi/scsicam.h>
 
 #include "scsi_logging.h"
@@ -769,7 +771,7 @@
 			 * Inform the user, but make sure that it's not treated
 			 * as a hard error.
 			 */
-			print_sense("sd", SCpnt);
+			scsi_print_sense("sd", SCpnt);
 			SCpnt->result = 0;
 			SCpnt->sense_buffer[0] = 0x0;
 			good_bytes = this_count;
@@ -918,7 +920,7 @@
 			 * probably pointless to loop */
 			if(!spintime) {
 				printk(KERN_NOTICE "%s: Unit Not Ready, sense:\n", diskname);
-				print_req_sense("", SRpnt);
+				scsi_print_req_sense("", SRpnt);
 			}
 			break;
 		}
@@ -987,7 +989,7 @@
 		       driver_byte(the_result));
 
 		if (driver_byte(the_result) & DRIVER_SENSE)
-			print_req_sense("sd", SRpnt);
+			scsi_print_req_sense("sd", SRpnt);
 		else
 			printk("%s : sense not available. \n", diskname);
 
@@ -1542,7 +1544,7 @@
 				    status_byte(res), msg_byte(res),
 				    host_byte(res), driver_byte(res));
 			if (driver_byte(res) & DRIVER_SENSE)
-				print_req_sense("sd", sreq);
+				scsi_print_req_sense("sd", sreq);
 	}
 	
 	scsi_release_request(sreq);
diff -Nru a/drivers/usb/image/hpusbscsi.c b/drivers/usb/image/hpusbscsi.c
--- a/drivers/usb/image/hpusbscsi.c	2004-06-20 13:22:08 -07:00
+++ b/drivers/usb/image/hpusbscsi.c	2004-06-20 13:22:08 -07:00
@@ -11,7 +11,7 @@
 #include <asm/atomic.h>
 #include <linux/blkdev.h>
 #include "../../scsi/scsi.h"
-#include "../../scsi/hosts.h"
+#include <scsi/scsi_host.h>
 
 #include "hpusbscsi.h"
 
diff -Nru a/drivers/usb/image/microtek.c b/drivers/usb/image/microtek.c
--- a/drivers/usb/image/microtek.c	2004-06-20 13:22:08 -07:00
+++ b/drivers/usb/image/microtek.c	2004-06-20 13:22:08 -07:00
@@ -136,7 +136,7 @@
 #include <asm/atomic.h>
 #include <linux/blkdev.h>
 #include "../../scsi/scsi.h"
-#include "../../scsi/hosts.h"
+#include <scsi/scsi_host.h>
 
 #include "microtek.h"
 
diff -Nru a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h
--- a/include/scsi/scsi_host.h	2004-06-20 13:22:07 -07:00
+++ b/include/scsi/scsi_host.h	2004-06-20 13:22:07 -07:00
@@ -30,6 +30,12 @@
 #define DISABLE_CLUSTERING 0
 #define ENABLE_CLUSTERING 1
 
+enum scsi_eh_timer_return {
+	EH_NOT_HANDLED,
+	EH_HANDLED,
+	EH_RESET_TIMER,
+};
+
 
 struct scsi_host_template {
 	struct module *module;
@@ -124,6 +130,20 @@
 	int (* eh_device_reset_handler)(struct scsi_cmnd *);
 	int (* eh_bus_reset_handler)(struct scsi_cmnd *);
 	int (* eh_host_reset_handler)(struct scsi_cmnd *);
+
+	/*
+	 * This is an optional routine to notify the host that the scsi
+	 * timer just fired.  The returns tell the timer routine what to
+	 * do about this:
+	 *
+	 * EH_HANDLED:		I fixed the error, please complete the command
+	 * EH_RESET_TIMER:	I need more time, reset the timer and
+	 *			begin counting again
+	 * EH_NOT_HANDLED	Begin normal error recovery
+	 *
+	 * Status: OPTIONAL
+	 */
+	enum scsi_eh_timer_return (* eh_timed_out)(struct scsi_cmnd *);
 
 	/*
 	 * Old EH handlers, no longer used. Make them warn the user of old
