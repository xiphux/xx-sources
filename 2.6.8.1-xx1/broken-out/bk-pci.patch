bk://kernel.bkbits.net/gregkh/linux/pci-2.6
sziwan@hell.org.pl|ChangeSet|20040809233949|21223 sziwan

# This is a BitKeeper generated diff -Nru style patch.
#
# drivers/pci/hotplug/rpaphp_pci.c
#   2004/07/02 08:59:36-07:00 lxiep@us.ibm.com +18 -3
#   PCI Hotplug: rpaphp_add_slot.patch
# 
# ChangeSet
#   2004/08/09 16:39:49-07:00 sziwan@hell.org.pl 
#   [PATCH] PCI: ASUS L3C SMBus fixup
#   
#   Following the notes on bug #2976, here's the patch to add ASUS L3C notebook
#   to the list of machines hiding SMBus chip. The patch is against
#   2.6.8-rc3-mm1.
#   
#   
#   From: Karol Kozimor <sziwan@hell.org.pl>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/pci/quirks.c
#   2004/08/07 16:34:55-07:00 sziwan@hell.org.pl +2 -0
#   PCI: ASUS L3C SMBus fixup
# 
# ChangeSet
#   2004/08/09 14:40:00-07:00 killekulla@rdrz.de 
#   [PATCH] PCI: fix PCI access mode dependences in arch/i386/Kconfig again
#   
#   While all ACPI stuff is deselected, and PCI access mode is set to "Any",
#   CONFIG_ACPI_BOOT is going to be set because of CONFIG_PCI_MMCONFIG.
#   
#   If CONFIG_ACPI_BOOT is not allready set by other stuff, setting PCI access
#   mode to "Any" shouldn't set CONFIG_PCI_MMCONFIG.  Anyhow, setting PCI
#   access mode to "MMConfig" should select CONFIG_ACPI_BOOT.
#   
#   Signed-off-by: Raphael Zimmerer <killekulla@rdrz.de>
#   Signed-off-by: Andrew Morton <akpm@osdl.org>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# arch/i386/Kconfig
#   2004/08/08 23:59:05-07:00 killekulla@rdrz.de +1 -1
#   PCI: fix PCI access mode dependences in arch/i386/Kconfig again
# 
# ChangeSet
#   2004/08/09 14:39:20-07:00 rl@hellgate.ch 
#   [PATCH] PCI: saved_config_space -> u32
#   
#   Match what the functions working on it expect.
#   
#   Signed-off-by: Roger Luethi <rl@hellgate.ch>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# include/linux/pci.h
#   2004/08/07 05:37:57-07:00 rl@hellgate.ch +1 -1
#   PCI: saved_config_space -> u32
# 
# ChangeSet
#   2004/08/09 14:26:14-07:00 greg@kroah.com 
#   PCI Hotplug: fix compiler warnings in pciehp driver.
# 
# drivers/pci/hotplug/pciehp_hpc.c
#   2004/08/09 14:24:44-07:00 greg@kroah.com +2 -2
#   PCI Hotplug: fix compiler warnings in pciehp driver.
# 
# ChangeSet
#   2004/08/09 13:42:54-07:00 khali@linux-fr.org 
#   [PATCH] I2C: fix for previous lm83 driver update
#   
#   Signed-off-by: Jean Delvare <khali at linux-fr dot org>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/chips/lm83.c
#   2004/08/09 11:26:52-07:00 khali@linux-fr.org +3 -3
#   I2C: fix for previous lm83 driver update
# 
# ChangeSet
#   2004/08/09 10:48:22-07:00 greg@kroah.com 
#   [PATCH] W1: removed some unneeded global symbols from the w1_smem module.
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/w1/w1_smem.c
#   2004/08/09 10:43:04-07:00 greg@kroah.com +2 -2
#   W1: removed some unneeded global symbols from the w1_smem module.
# 
# ChangeSet
#   2004/08/09 10:47:35-07:00 greg@kroah.com 
#   [PATCH] W1: fix some improper '{' style code.
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/w1/w1_therm.c
#   2004/08/09 10:42:59-07:00 greg@kroah.com +2 -4
#   W1: fix some improper '{' style code.
# 
# drivers/w1/w1_io.c
#   2004/08/09 10:42:59-07:00 greg@kroah.com +2 -4
#   W1: fix some improper '{' style code.
# 
# drivers/w1/w1.c
#   2004/08/09 10:42:59-07:00 greg@kroah.com +2 -4
#   W1: fix some improper '{' style code.
# 
# drivers/w1/dscore.c
#   2004/08/09 10:42:59-07:00 greg@kroah.com +5 -10
#   W1: fix some improper '{' style code.
# 
# drivers/w1/ds_w1_bridge.c
#   2004/08/09 10:42:59-07:00 greg@kroah.com +2 -4
#   W1: fix some improper '{' style code.
# 
# ChangeSet
#   2004/08/09 10:46:36-07:00 khali@linux-fr.org 
#   [PATCH] I2C: port smsc47m1 to 2.6
#   
#   Here is my port of the smsc47m1 i2c hardware monitoring driver to Linux
#   2.6. The original driver was written by Mark D. Studebaker, and my work
#   is based on a preliminary port by Gabriele Gorla, who came in with an
#   almost finished driver, but vanished before cleaning it up. I finished
#   the job and improved things a bit. Credits go to Ivars Strazdins and
#   Cassio Freitas for testing the driver (having no hardware, I couldn't
#   test the code myself).
#   
#   
#   Signed-off-by: Jean Delvare <khali at linux-fr dot org>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/chips/Makefile
#   2004/07/19 12:58:44-07:00 khali@linux-fr.org +1 -0
#   I2C: port smsc47m1 to 2.6
# 
# drivers/i2c/chips/smsc47m1.c
#   2004/08/05 00:01:06-07:00 khali@linux-fr.org +579 -0
#   I2C: port smsc47m1 to 2.6
# 
# drivers/i2c/chips/Kconfig
#   2004/07/21 11:02:28-07:00 khali@linux-fr.org +13 -0
#   I2C: port smsc47m1 to 2.6
# 
# drivers/i2c/chips/smsc47m1.c
#   2004/08/05 00:01:06-07:00 khali@linux-fr.org +0 -0
#   BitKeeper file /home/greg/linux/BK/pci-2.6/drivers/i2c/chips/smsc47m1.c
# 
# ChangeSet
#   2004/08/09 10:45:27-07:00 khali@linux-fr.org 
#   [PATCH] I2C: update the lm83 driver
#   
#   This is an update to the Linux 2.6 lm83 hardware monitoring driver.
#   
#   * Follow the sysfs interface naming conventions.
#   * Fix the "force" module parameter.
#   * Fix limit settings checks.
#   * Driver is no longer tagged experimental.
#   
#   These changes are the result of me finally succeeding in getting my LM83
#   evaluation board to work. If there are norms and standards about how
#   evaluation boards can be wired, I guess I did not respect any of them,
#   but it works ;)
#   
#   
#   Signed-off-by: Jean Delvare <khali at linux-fr dot org>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/chips/lm83.c
#   2004/08/08 12:39:28-07:00 khali@linux-fr.org +18 -5
#   I2C: update the lm83 driver
# 
# drivers/i2c/chips/Kconfig
#   2004/08/08 12:45:49-07:00 khali@linux-fr.org +1 -1
#   I2C: update the lm83 driver
# 
# ChangeSet
#   2004/08/09 10:44:46-07:00 johnpol@2ka.mipt.ru 
#   [PATCH] w1: Added dynamic slave removal mechanism. Fixed bug when we have multiple slave with different families.
#   
#   Added dynamic slave removal mechanism by introducing u32 flags; in each slave.
#           If slave was found during search process then set flag.
#           If after search complete we have slave entryes without magic flag then remove them.
#   Fixed bug when we have multiple slave with different families.
#           Since attributes were static then each new family will rewrite static values with new
#           function pointers... badly broken.
#   
#   Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/w1/w1.h
#   2004/08/04 06:32:03-07:00 johnpol@2ka.mipt.ru +6 -0
#   w1: Added dynamic slave removal mechanism. Fixed bug when we have multiple slave with different families.
# 
# drivers/w1/w1.c
#   2004/08/04 06:45:27-07:00 johnpol@2ka.mipt.ru +46 -13
#   w1: Added dynamic slave removal mechanism. Fixed bug when we have multiple slave with different families.
# 
# ChangeSet
#   2004/08/07 19:08:19-07:00 akpm@bix.(none) 
#   Merge bix.(none):/usr/src/bk25 into bix.(none):/usr/src/bk-pci
# 
# arch/ppc64/kernel/pSeries_pci.c
#   2004/08/07 19:08:15-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/08/06 15:46:38-07:00 johnpol@2ka.mipt.ru 
#   [PATCH] w1: Added driver for Dallas' DS9490* USB <-> W1 master.
#   
#   Added driver for Dallas' DS9490* USB <-> W1 master.
#   Should handle any device based on DS2490 chip.
#   
#   Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/w1/dscore.h
#   2004/08/04 07:10:58-07:00 johnpol@2ka.mipt.ru +173 -0
#   w1: Added driver for Dallas' DS9490* USB <-> W1 master.
# 
# drivers/w1/ds_w1_bridge.c
#   2004/08/04 07:10:58-07:00 johnpol@2ka.mipt.ru +176 -0
#   w1: Added driver for Dallas' DS9490* USB <-> W1 master.
# 
# drivers/w1/dscore.h
#   2004/08/04 07:10:58-07:00 johnpol@2ka.mipt.ru +0 -0
#   BitKeeper file /home/greg/linux/BK/pci-2.6/drivers/w1/dscore.h
# 
# drivers/w1/dscore.c
#   2004/08/04 07:10:58-07:00 johnpol@2ka.mipt.ru +788 -0
#   w1: Added driver for Dallas' DS9490* USB <-> W1 master.
# 
# drivers/w1/ds_w1_bridge.c
#   2004/08/04 07:10:58-07:00 johnpol@2ka.mipt.ru +0 -0
#   BitKeeper file /home/greg/linux/BK/pci-2.6/drivers/w1/ds_w1_bridge.c
# 
# drivers/w1/Makefile
#   2004/08/04 07:13:35-07:00 johnpol@2ka.mipt.ru +6 -0
#   w1: Added driver for Dallas' DS9490* USB <-> W1 master.
# 
# drivers/w1/Kconfig
#   2004/08/04 07:16:35-07:00 johnpol@2ka.mipt.ru +19 -0
#   w1: Added driver for Dallas' DS9490* USB <-> W1 master.
# 
# drivers/w1/dscore.c
#   2004/08/04 07:10:58-07:00 johnpol@2ka.mipt.ru +0 -0
#   BitKeeper file /home/greg/linux/BK/pci-2.6/drivers/w1/dscore.c
# 
# ChangeSet
#   2004/08/06 15:46:04-07:00 johnpol@2ka.mipt.ru 
#   [PATCH] w1: Added  w1_smem.c - driver for simple 64bit ROM devices.
#   
#   Added w1_smem.c - driver for simple 64bit ROM devices.
#   Simple iButtons with ds2401/ds2411/ds1990* are handled by this driver.
#   
#   Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/w1/w1_smem.c
#   2004/08/04 07:05:26-07:00 johnpol@2ka.mipt.ru +118 -0
#   w1: Added  w1_smem.c - driver for simple 64bit ROM devices.
# 
# drivers/w1/Makefile
#   2004/08/04 07:05:54-07:00 johnpol@2ka.mipt.ru +1 -0
#   w1: Added  w1_smem.c - driver for simple 64bit ROM devices.
# 
# drivers/w1/Kconfig
#   2004/08/04 07:06:26-07:00 johnpol@2ka.mipt.ru +7 -0
#   w1: Added  w1_smem.c - driver for simple 64bit ROM devices.
# 
# drivers/w1/w1_smem.c
#   2004/08/04 07:05:26-07:00 johnpol@2ka.mipt.ru +0 -0
#   BitKeeper file /home/greg/linux/BK/pci-2.6/drivers/w1/w1_smem.c
# 
# ChangeSet
#   2004/08/06 15:43:00-07:00 johnpol@2ka.mipt.ru 
#   [PATCH] w1: Spelling fix.
#   
#   Spelling fix.
#   
#   Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/w1/matrox_w1.c
#   2004/08/04 06:46:15-07:00 johnpol@2ka.mipt.ru +1 -1
#   w1: Spelling fix.
# 
# ChangeSet
#   2004/08/06 15:32:54-07:00 johnpol@2ka.mipt.ru 
#   [PATCH] w1: Debug output cleanup. memcpy instead of direct structure copying.
#   
#   Debug output cleanup. memcpy instead of direct structure copying.
#   
#   Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/w1/w1.c
#   2004/08/04 06:45:28-07:00 johnpol@2ka.mipt.ru +4 -4
#   w1: Debug output cleanup. memcpy instead of direct structure copying.
# 
# ChangeSet
#   2004/08/06 15:31:43-07:00 johnpol@2ka.mipt.ru 
#   [PATCH] w1: Netlink update - changed event generating/processing.
#   
#   Added following self-explanatory netlink events.
#   
#           W1_SLAVE_ADD = 0,
#           W1_SLAVE_REMOVE,
#           W1_MASTER_ADD,
#           W1_MASTER_REMOVE,
#   
#   Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/w1/w1_netlink.h
#   2004/08/04 06:43:08-07:00 johnpol@2ka.mipt.ru +14 -1
#   w1: Netlink update - changed event generating/processing.
# 
# drivers/w1/w1_int.c
#   2004/08/04 06:43:00-07:00 johnpol@2ka.mipt.ru +13 -0
#   w1: Netlink update - changed event generating/processing.
# 
# drivers/w1/w1.c
#   2004/08/04 06:40:18-07:00 johnpol@2ka.mipt.ru +12 -9
#   w1: Netlink update - changed event generating/processing.
# 
# ChangeSet
#   2004/08/06 15:30:24-07:00 johnpol@2ka.mipt.ru 
#   [PATCH] w1: Changed define for W1_FAMILY_SMEM.
#   
#     -#define W1_FAMILY_IBUT 0xff /* ? */
#     +#define W1_FAMILY_SMEM 0x01
#   
#   Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/w1/w1_family.h
#   2004/08/04 06:23:57-07:00 johnpol@2ka.mipt.ru +1 -1
#   w1: Changed define for W1_FAMILY_SMEM.
# 
# ChangeSet
#   2004/08/06 15:28:47-07:00 johnpol@2ka.mipt.ru 
#   [PATCH] w1: Changed printing format for slave names.
#   
#   %llx -> %012llx
#   %x -> %02x
#   
#   Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/w1/w1.c
#   2004/08/06 15:13:38-07:00 johnpol@2ka.mipt.ru +2 -2
#   w1: Changed printing format for slave names.
# 
# ChangeSet
#   2004/08/06 15:26:03-07:00 johnpol@2ka.mipt.ru 
#   [PATCH] w1: Added w1_check_family().
#   
#   w1_check_family() checks new family before registering it.
#   
#   Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/w1/w1_family.c
#   2004/08/04 06:21:02-07:00 johnpol@2ka.mipt.ru +11 -0
#   w1: Added w1_check_family().
# 
# ChangeSet
#   2004/08/06 15:25:13-07:00 johnpol@2ka.mipt.ru 
#   [PATCH] w1: Added w1_read_block() and w1_write_block() callbacks.
#   
#   Added w1_read_block() and w1_write_block().
#   w1_therm.c now uses them.
#   w1_therm: Chnaged snprintf to sprintf in w1_therm_read_bin() and added max_trying -
#           number of tryings to read temperature before failng. By default it is 10.
#           Added w1_therm_check_rom() - checks if read rom is in black list.
#           If rom is in black list it is probably due to unsufficient of "power" in the sensor -
#           either add strong pullup or connect it to Vcc.
#   
#   Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/w1/w1_therm.c
#   2004/08/04 06:17:09-07:00 johnpol@2ka.mipt.ru +58 -43
#   w1: Added w1_read_block() and w1_write_block() callbacks.
# 
# drivers/w1/w1_io.h
#   2004/08/04 06:11:49-07:00 johnpol@2ka.mipt.ru +3 -0
#   w1: Added w1_read_block() and w1_write_block() callbacks.
# 
# drivers/w1/w1_io.c
#   2004/08/04 06:07:42-07:00 johnpol@2ka.mipt.ru +60 -11
#   w1: Added w1_read_block() and w1_write_block() callbacks.
# 
# drivers/w1/w1.h
#   2004/08/04 06:05:03-07:00 johnpol@2ka.mipt.ru +10 -0
#   w1: Added w1_read_block() and w1_write_block() callbacks.
# 
# ChangeSet
#   2004/08/06 15:23:51-07:00 johnpol@2ka.mipt.ru 
#   [PATCH] w1: attributes split, timeout unit changed.
#   
#   Creates w1_master_attribute_* attributes and 2 routings to control them:
#           w1_create_master_attributes() and w1_destroy_master_attributes().
#   
#   Timeout unit was changed from jiffies to seconds.
#   
#   Signed-off-by: Evgeniy Polyakov <johnpol@2ka.mipt.ru>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/w1/w1_int.c
#   2004/08/04 05:57:34-07:00 johnpol@2ka.mipt.ru +1 -2
#   w1: attributes split, timeout unit changed.
# 
# drivers/w1/w1.h
#   2004/08/04 05:56:42-07:00 johnpol@2ka.mipt.ru +3 -0
#   w1: attributes split, timeout unit changed.
# 
# drivers/w1/w1.c
#   2004/08/04 05:56:34-07:00 johnpol@2ka.mipt.ru +166 -22
#   w1: attributes split, timeout unit changed.
# 
# ChangeSet
#   2004/08/06 12:42:19-07:00 akpm@osdl.org 
#   [PATCH] I2C: scx200_i2c build fix
#   
#   drivers/i2c/busses/scx200_i2c.c: In function `__check_scl':
#   drivers/i2c/busses/scx200_i2c.c:41: `scl' undeclared (first use in this function)
#   drivers/i2c/busses/scx200_i2c.c:41: (Each undeclared identifier is reported only once
#   
#   
#   Signed-off-by: Andrew Morton <akpm@osdl.org>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/busses/scx200_i2c.c
#   2004/08/05 23:38:08-07:00 akpm@osdl.org +3 -3
#   I2C: scx200_i2c build fix
# 
# ChangeSet
#   2004/08/06 11:08:00-07:00 greg@kroah.com 
#   MODULE: delete local static copy of param_set_byte as we now have a real version of it.
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# kernel/module.c
#   2004/08/06 11:07:38-07:00 greg@kroah.com +0 -13
#   MODULE: delete local static copy of param_set_byte as we now have a real version of it.
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# ChangeSet
#   2004/08/05 16:55:54-07:00 greg@kroah.com 
#   Merge I2C and PCI trees together due to PCI quirks conflicts.
# 
# drivers/pci/quirks.c
#   2004/08/05 16:55:44-07:00 greg@kroah.com +2 -0
#   Merge I2C and PCI trees together due to PCI quirks conflicts.
# 
# ChangeSet
#   2004/08/05 16:46:18-07:00 icampbell@arcom.com 
#   [PATCH] I2C: algorithm and bus driver for PCA9564
#   
#   Attached is a driver for the PCA9564 "Parallel to I2C" chip, it is
#   similar in principle to the PCF8584 which is supported by the
#   i2c-algo-pcf and i2c-elektor code, however it's not code compatible in
#   any way: http://www.semiconductors.philips.com/pip/PCA9564PW.html
#   
#   The patch contains the PCA algorithm driver and a bus driver for an ISA
#   card. It only supports master send and receive but I'm not sure that the
#   Linux i2c stack supports client side operation anyhow, and I have no
#   hardware to test on.
#   
#   It was tested on a PC104 card containing the PCA chip and an Atmel TPM
#   device and also on a separate PC104 card with a DS1307 RTC hotwired onto
#   it for testing purposes.
#   
#   The driver is against a 2.6 BK tree pulled on Friday. I also have a
#   fairly trivial 2.4 backport if that is of interest.
#   
#   From: Ian Campbell <icampbell@arcom.com>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# include/linux/i2c-algo-pca.h
#   2004/07/29 08:06:29-07:00 icampbell@arcom.com +17 -0
#   I2C: algorithm and bus driver for PCA9564
# 
# drivers/i2c/busses/i2c-pca-isa.c
#   2004/08/02 02:09:21-07:00 icampbell@arcom.com +184 -0
#   I2C: algorithm and bus driver for PCA9564
# 
# drivers/i2c/algos/i2c-algo-pca.h
#   2004/07/29 08:06:29-07:00 icampbell@arcom.com +26 -0
#   I2C: algorithm and bus driver for PCA9564
# 
# include/linux/i2c-id.h
#   2004/07/29 08:06:29-07:00 icampbell@arcom.com +4 -0
#   I2C: algorithm and bus driver for PCA9564
# 
# include/linux/i2c-algo-pca.h
#   2004/07/29 08:06:29-07:00 icampbell@arcom.com +0 -0
#   BitKeeper file /home/greg/linux/BK/i2c-2.6/include/linux/i2c-algo-pca.h
# 
# drivers/i2c/busses/i2c-pca-isa.c
#   2004/08/02 02:09:21-07:00 icampbell@arcom.com +0 -0
#   BitKeeper file /home/greg/linux/BK/i2c-2.6/drivers/i2c/busses/i2c-pca-isa.c
# 
# drivers/i2c/busses/Makefile
#   2004/07/29 08:06:29-07:00 icampbell@arcom.com +1 -0
#   I2C: algorithm and bus driver for PCA9564
# 
# drivers/i2c/busses/Kconfig
#   2004/07/29 08:06:29-07:00 icampbell@arcom.com +11 -0
#   I2C: algorithm and bus driver for PCA9564
# 
# drivers/i2c/algos/i2c-algo-pca.h
#   2004/07/29 08:06:29-07:00 icampbell@arcom.com +0 -0
#   BitKeeper file /home/greg/linux/BK/i2c-2.6/drivers/i2c/algos/i2c-algo-pca.h
# 
# drivers/i2c/algos/Makefile
#   2004/07/29 08:06:29-07:00 icampbell@arcom.com +1 -0
#   I2C: algorithm and bus driver for PCA9564
# 
# drivers/i2c/algos/Kconfig
#   2004/07/29 08:06:29-07:00 icampbell@arcom.com +11 -0
#   I2C: algorithm and bus driver for PCA9564
# 
# drivers/i2c/algos/i2c-algo-pca.c
#   2004/08/02 02:09:21-07:00 icampbell@arcom.com +395 -0
#   I2C: algorithm and bus driver for PCA9564
# 
# drivers/i2c/algos/i2c-algo-pca.c
#   2004/08/02 02:09:21-07:00 icampbell@arcom.com +0 -0
#   BitKeeper file /home/greg/linux/BK/i2c-2.6/drivers/i2c/algos/i2c-algo-pca.c
# 
# ChangeSet
#   2004/08/05 16:39:27-07:00 R.Marek@sh.cvut.cz 
#   [PATCH] I2C: automatic VRM detection part2
#   
#   This is second part, which just adds the functionality to existing code
#   base, also including support of vid inputs for it8712 chip.
#   
#   This patch was also briefly reviewed by Jean Delvare.
#   
#   Signed-off-by: Rudolf Marek <r.marek@sh.cvut.cz>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/chips/w83781d.c
#   2004/07/22 00:49:22-07:00 R.Marek@sh.cvut.cz +1 -1
#   I2C: automatic VRM detection part2
# 
# drivers/i2c/chips/w83627hf.c
#   2004/07/22 00:49:22-07:00 R.Marek@sh.cvut.cz +1 -1
#   I2C: automatic VRM detection part2
# 
# drivers/i2c/chips/lm85.c
#   2004/07/22 00:53:04-07:00 R.Marek@sh.cvut.cz +1 -4
#   I2C: automatic VRM detection part2
# 
# drivers/i2c/chips/it87.c
#   2004/07/22 00:51:45-07:00 R.Marek@sh.cvut.cz +52 -4
#   I2C: automatic VRM detection part2
# 
# drivers/i2c/chips/asb100.c
#   2004/07/22 00:50:51-07:00 R.Marek@sh.cvut.cz +1 -4
#   I2C: automatic VRM detection part2
# 
# drivers/i2c/chips/adm1025.c
#   2004/07/22 00:49:22-07:00 R.Marek@sh.cvut.cz +1 -1
#   I2C: automatic VRM detection part2
# 
# ChangeSet
#   2004/08/05 16:38:57-07:00 R.Marek@sh.cvut.cz 
#   [PATCH] I2C: automatic VRM detection part1
#   
#   This patch forms composite module with i2c-sensor.c and new file
#   i2c-sensor-vid.c, which provides i2c_which_vrm function for detecting VRM
#   version of processor using cpuid_eax func. Resulting module has unchanged
#   name (i2c-sensor).
#   
#   Before applaying this patch, please rename i2c-sensor.c to
#   i2c-sensor-detect.c
#   
#   This patch was briefly reviewed by Jean Delvare.
#   
#   Signed-off-by: Rudolf Marek <r.marek@sh.cvut.cz>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# include/linux/i2c-vid.h
#   2004/07/22 00:49:11-07:00 R.Marek@sh.cvut.cz +4 -1
#   I2C: automatic VRM detection part1
# 
# drivers/i2c/i2c-sensor-vid.c
#   2004/07/22 00:49:11-07:00 R.Marek@sh.cvut.cz +99 -0
#   I2C: automatic VRM detection part1
# 
# drivers/i2c/i2c-sensor-detect.c
#   2004/07/22 00:49:11-07:00 R.Marek@sh.cvut.cz +5 -3
#   I2C: automatic VRM detection part1
# 
# drivers/i2c/Makefile
#   2004/07/22 00:49:11-07:00 R.Marek@sh.cvut.cz +3 -0
#   I2C: automatic VRM detection part1
# 
# drivers/i2c/i2c-sensor-vid.c
#   2004/07/22 00:49:11-07:00 R.Marek@sh.cvut.cz +0 -0
#   BitKeeper file /home/greg/linux/BK/i2c-2.6/drivers/i2c/i2c-sensor-vid.c
# 
# ChangeSet
#   2004/08/05 16:35:57-07:00 greg@kroah.com 
#   I2C: rename i2c-sensor.c file to prepare for Rudolf's VRM patch.
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/i2c-sensor-detect.c
#   2004/08/05 16:34:20-07:00 greg@kroah.com +0 -0
#   I2C: rename i2c-sensor.c file to prepare for Rudolf's VRM patch.
# 
# ChangeSet
#   2004/08/05 15:34:23-07:00 bjorn.helgaas@hp.com 
#   [PATCH] PCI: Document pci_disable_device()
#   
#   Add documentation for pci_disable_device().  We don't actually
#   deallocate IRQ resources in pci_disable_device() yet, but I suspect
#   we'll need to do so soon.
#   
#   Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# Documentation/pci.txt
#   2004/08/03 13:20:22-07:00 bjorn.helgaas@hp.com +9 -2
#   PCI: Document pci_disable_device()
# 
# ChangeSet
#   2004/08/05 15:33:44-07:00 johnrose@austin.ibm.com 
#   [PATCH] PCI: rpaphp build break - remove eeh register
#   
#   The following patch removes eeh function calls that currently break the
#   RPA PCI Hotplug module.  The functions in question were rejected from
#   mainline, and an alternate solution is being worked.
# 
# drivers/pci/hotplug/rpaphp_core.c
#   2004/08/03 03:38:57-07:00 johnrose@austin.ibm.com +0 -8
#   PCI: rpaphp build break - remove eeh register
# 
# ChangeSet
#   2004/08/05 14:03:11-07:00 greg@kroah.com 
#   [PATCH] I2C: fix up the order of bus drivers in the Kconfig and Makefile
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/busses/Makefile
#   2004/08/05 14:01:57-07:00 greg@kroah.com +2 -2
#   I2C: fix up the order of bus drivers in the Kconfig and Makefile
# 
# drivers/i2c/busses/Kconfig
#   2004/08/05 14:01:57-07:00 greg@kroah.com +12 -12
#   I2C: fix up the order of bus drivers in the Kconfig and Makefile
# 
# ChangeSet
#   2004/08/05 14:02:46-07:00 adrian@humboldt.co.uk 
#   [PATCH] I2C: bus driver for multiple PowerPCs
#   
#   The attached patch for Linux 2.6 adds an I2C driver for the MPC107 host
#   bridge, plus the integrated controllers in the MPC824x, MPC85xx, and
#   MPC52xx PowerPCs.  The driver has been tested on a variety of systems,
#   by people on the linuxppc-embedded list.
#   
#   
#   Signed-off-by: Adrian Cox <adrian@humboldt.co.uk>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# include/asm-ppc/fsl_ocp.h
#   2004/08/04 04:07:50-07:00 adrian@humboldt.co.uk +1 -1
#   I2C: bus driver for multiple PowerPCs
# 
# drivers/i2c/busses/Makefile
#   2004/08/04 04:07:50-07:00 adrian@humboldt.co.uk +1 -0
#   I2C: bus driver for multiple PowerPCs
# 
# drivers/i2c/busses/Kconfig
#   2004/08/04 04:07:50-07:00 adrian@humboldt.co.uk +12 -0
#   I2C: bus driver for multiple PowerPCs
# 
# drivers/i2c/busses/i2c-mpc.c
#   2004/08/04 04:07:50-07:00 adrian@humboldt.co.uk +392 -0
#   I2C: bus driver for multiple PowerPCs
# 
# drivers/i2c/busses/i2c-mpc.c
#   2004/08/04 04:07:50-07:00 adrian@humboldt.co.uk +0 -0
#   BitKeeper file /home/greg/linux/BK/i2c-2.6/drivers/i2c/busses/i2c-mpc.c
# 
# ChangeSet
#   2004/08/05 13:11:29-07:00 greg@kroah.com 
#   I2C: convert all drivers from MODULE_PARM to module_param
# 
# include/linux/i2c.h
#   2004/08/05 13:11:01-07:00 greg@kroah.com +3 -1
#   I2C: convert all drivers from MODULE_PARM to module_param
# 
# drivers/i2c/chips/w83781d.c
#   2004/08/05 13:11:01-07:00 greg@kroah.com +1 -1
#   I2C: convert all drivers from MODULE_PARM to module_param
# 
# drivers/i2c/chips/w83627hf.c
#   2004/08/05 13:11:00-07:00 greg@kroah.com +5 -5
#   I2C: convert all drivers from MODULE_PARM to module_param
# 
# drivers/i2c/chips/via686a.c
#   2004/08/05 13:11:01-07:00 greg@kroah.com +2 -2
#   I2C: convert all drivers from MODULE_PARM to module_param
# 
# drivers/i2c/chips/rtc8564.c
#   2004/08/05 13:11:01-07:00 greg@kroah.com +2 -2
#   I2C: convert all drivers from MODULE_PARM to module_param
# 
# drivers/i2c/chips/pcf8591.c
#   2004/08/05 13:11:00-07:00 greg@kroah.com +1 -1
#   I2C: convert all drivers from MODULE_PARM to module_param
# 
# drivers/i2c/chips/it87.c
#   2004/08/05 13:11:01-07:00 greg@kroah.com +2 -2
#   I2C: convert all drivers from MODULE_PARM to module_param
# 
# drivers/i2c/chips/eeprom.c
#   2004/08/05 13:11:01-07:00 greg@kroah.com +1 -1
#   I2C: convert all drivers from MODULE_PARM to module_param
# 
# drivers/i2c/chips/ds1621.c
#   2004/08/05 13:11:01-07:00 greg@kroah.com +1 -1
#   I2C: convert all drivers from MODULE_PARM to module_param
# 
# drivers/i2c/chips/adm1021.c
#   2004/08/05 13:11:01-07:00 greg@kroah.com +1 -1
#   I2C: convert all drivers from MODULE_PARM to module_param
# 
# drivers/i2c/busses/scx200_i2c.c
#   2004/08/05 13:11:00-07:00 greg@kroah.com +2 -2
#   I2C: convert all drivers from MODULE_PARM to module_param
# 
# drivers/i2c/busses/scx200_acb.c
#   2004/08/05 13:11:01-07:00 greg@kroah.com +2 -1
#   I2C: convert all drivers from MODULE_PARM to module_param
# 
# drivers/i2c/busses/i2c-viapro.c
#   2004/08/05 13:11:01-07:00 greg@kroah.com +3 -3
#   I2C: convert all drivers from MODULE_PARM to module_param
# 
# drivers/i2c/busses/i2c-sis630.c
#   2004/08/05 13:11:01-07:00 greg@kroah.com +7 -7
#   I2C: convert all drivers from MODULE_PARM to module_param
# 
# drivers/i2c/busses/i2c-sis5595.c
#   2004/08/05 13:11:01-07:00 greg@kroah.com +2 -2
#   I2C: convert all drivers from MODULE_PARM to module_param
# 
# drivers/i2c/busses/i2c-parport.h
#   2004/08/05 13:11:00-07:00 greg@kroah.com +1 -1
#   I2C: convert all drivers from MODULE_PARM to module_param
# 
# drivers/i2c/busses/i2c-parport-light.c
#   2004/08/05 13:11:01-07:00 greg@kroah.com +2 -2
#   I2C: convert all drivers from MODULE_PARM to module_param
# 
# drivers/i2c/busses/i2c-keywest.c
#   2004/08/05 13:11:00-07:00 greg@kroah.com +2 -2
#   I2C: convert all drivers from MODULE_PARM to module_param
# 
# drivers/i2c/busses/i2c-ite.c
#   2004/08/05 13:11:01-07:00 greg@kroah.com +8 -8
#   I2C: convert all drivers from MODULE_PARM to module_param
# 
# drivers/i2c/busses/i2c-ibm_iic.c
#   2004/08/05 13:11:01-07:00 greg@kroah.com +4 -4
#   I2C: convert all drivers from MODULE_PARM to module_param
# 
# drivers/i2c/busses/i2c-i801.c
#   2004/08/05 13:11:01-07:00 greg@kroah.com +2 -2
#   I2C: convert all drivers from MODULE_PARM to module_param
# 
# drivers/i2c/busses/i2c-elektor.c
#   2004/08/05 13:11:01-07:00 greg@kroah.com +5 -5
#   I2C: convert all drivers from MODULE_PARM to module_param
# 
# drivers/i2c/busses/i2c-ali15x3.c
#   2004/08/05 13:11:01-07:00 greg@kroah.com +2 -2
#   I2C: convert all drivers from MODULE_PARM to module_param
# 
# drivers/i2c/algos/i2c-algo-pcf.c
#   2004/08/05 13:11:01-07:00 greg@kroah.com +2 -4
#   I2C: convert all drivers from MODULE_PARM to module_param
# 
# drivers/i2c/algos/i2c-algo-ite.c
#   2004/08/05 13:11:01-07:00 greg@kroah.com +4 -10
#   I2C: convert all drivers from MODULE_PARM to module_param
# 
# drivers/i2c/algos/i2c-algo-bit.c
#   2004/08/05 13:11:01-07:00 greg@kroah.com +2 -2
#   I2C: convert all drivers from MODULE_PARM to module_param
# 
# ChangeSet
#   2004/08/05 13:10:16-07:00 greg@kroah.com 
#   MODULE: add byte type of module paramater, like the comments say we support...
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# kernel/params.c
#   2004/08/05 13:09:49-07:00 greg@kroah.com +3 -0
#   MODULE: add byte type of module paramater, like the comments say we support...
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# include/linux/moduleparam.h
#   2004/08/05 13:09:49-07:00 greg@kroah.com +4 -0
#   MODULE: add byte type of module paramater, like the comments say we support...
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# ChangeSet
#   2004/08/04 18:34:36-07:00 greg@kroah.com 
#   PCI: oops, forgot to check in the pci.h changes so that the quirk cleanups will work
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# include/linux/pci.h
#   2004/08/04 18:34:11-07:00 greg@kroah.com +5 -4
#   PCI: oops, forgot to check in the pci.h changes so that the quirk cleanups will work
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# ChangeSet
#   2004/08/04 18:26:31-07:00 greg@kroah.com 
#   PCI: clean up code formatting of quirks.c
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/pci/quirks.c
#   2004/08/04 18:25:53-07:00 greg@kroah.com +27 -63
#   PCI: clean up code formatting of quirks.c
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# ChangeSet
#   2004/08/04 18:23:24-07:00 greg@kroah.com 
#   PCI: fix compiler warning in quirks file, and other minor quirks cleanup
#       
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/pci/quirks.c
#   2004/08/04 18:20:19-07:00 greg@kroah.com +8 -12
#   PCI: fix compiler warning in quirks file, and other minor quirks cleanup
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/pci/probe.c
#   2004/08/04 18:20:19-07:00 greg@kroah.com +1 -1
#   PCI: fix compiler warning in quirks file, and other minor quirks cleanup
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/pci/pci.c
#   2004/08/04 18:20:19-07:00 greg@kroah.com +1 -1
#   PCI: fix compiler warning in quirks file, and other minor quirks cleanup
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# ChangeSet
#   2004/08/04 17:55:19-07:00 akpm@bix.(none) 
#   Merge bk://kernel.bkbits.net/gregkh/linux/pci-2.6
#   into bix.(none):/usr/src/bk-pci
# 
# include/linux/pci_ids.h
#   2004/08/04 17:55:15-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/08/04 14:48:42-07:00 greg@kroah.com 
#   Merge kroah.com:/home/greg/linux/BK/bleed-2.6
#   into kroah.com:/home/greg/linux/BK/pci-2.6
# 
# include/linux/pci_ids.h
#   2004/08/04 14:48:28-07:00 greg@kroah.com +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/08/04 08:45:13-04:00 dwmw2@shinybook.infradead.org 
#   PCI quirks -- other architectures
#   
#   Mostly just removing empty pcibios_fixups[] arrays.
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# arch/v850/kernel/rte_mb_a_pci.c
#   2004/08/04 08:44:54-04:00 dwmw2@shinybook.infradead.org +0 -2
#   Remove pcibios_fixups[]
# 
# arch/sparc64/kernel/pci.c
#   2004/08/04 08:44:54-04:00 dwmw2@shinybook.infradead.org +0 -4
#   Remove pcibios_fixups[]
# 
# arch/sparc/kernel/pcic.c
#   2004/08/04 08:44:54-04:00 dwmw2@shinybook.infradead.org +0 -4
#   Remove pcibios_fixups[]
# 
# arch/sh64/kernel/pci_sh5.c
#   2004/08/04 08:44:54-04:00 dwmw2@shinybook.infradead.org +1 -6
#   Remove pcibios_fixups[]
# 
# arch/sh/drivers/pci/pci-st40.c
#   2004/08/04 08:44:53-04:00 dwmw2@shinybook.infradead.org +1 -7
#   Remove pcibios_fixups[]
# 
# arch/sh/drivers/pci/pci-sh7751.c
#   2004/08/04 08:44:53-04:00 dwmw2@shinybook.infradead.org +1 -8
#   Remove pcibios_fixups[]
# 
# arch/sh/drivers/pci/fixups-dreamcast.c
#   2004/08/04 08:44:53-04:00 dwmw2@shinybook.infradead.org +1 -5
#   Remove pcibios_fixups[]
# 
# arch/sh/boards/overdrive/galileo.c
#   2004/08/04 08:44:53-04:00 dwmw2@shinybook.infradead.org +1 -7
#   Remove pcibios_fixups[]
# 
# arch/sh/boards/mpc1211/pci.c
#   2004/08/04 08:44:53-04:00 dwmw2@shinybook.infradead.org +1 -8
#   Remove pcibios_fixups[]
# 
# arch/m68knommu/kernel/comempci.c
#   2004/08/04 08:44:53-04:00 dwmw2@shinybook.infradead.org +0 -2
#   Remove pcibios_fixups[]
# 
# arch/m68k/kernel/bios32.c
#   2004/08/04 08:44:53-04:00 dwmw2@shinybook.infradead.org +0 -5
#   Remove pcibios_fixups[]
# 
# arch/ia64/pci/pci.c
#   2004/08/04 08:44:53-04:00 dwmw2@shinybook.infradead.org +0 -2
#   Remove pcibios_fixups[]
# 
# arch/i386/pci/numa.c
#   2004/08/04 08:44:53-04:00 dwmw2@shinybook.infradead.org +1 -4
#   Remove pcibios_fixup[]
# 
# arch/alpha/kernel/pci.c
#   2004/08/04 08:44:53-04:00 dwmw2@shinybook.infradead.org +5 -10
#   Remove pcibios_fixups[]
# 
# ChangeSet
#   2004/08/04 08:43:07-04:00 dwmw2@shinybook.infradead.org 
#   PCI quirks -- ppc64
#   
#   Remove pcibios_fixups[] array and move the declarations to live with
#   the implementations. Remove unneeded pcibios_name_device() on iSeries.
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# arch/ppc64/kernel/pmac_pci.c
#   2004/08/04 08:42:49-04:00 dwmw2@shinybook.infradead.org +1 -0
#   Declare own fixup for SATA
# 
# arch/ppc64/kernel/pci.c
#   2004/08/04 08:42:48-04:00 dwmw2@shinybook.infradead.org +2 -20
#   Remove pcibios_fixups[].
# 
# arch/ppc64/kernel/pSeries_pci.c
#   2004/08/04 08:42:48-04:00 dwmw2@shinybook.infradead.org +3 -2
#   Declare own fixup for pcibios_name_device(), keep it all in #if 0
# 
# arch/ppc64/kernel/iSeries_pci.c
#   2004/08/04 08:42:48-04:00 dwmw2@shinybook.infradead.org +0 -4
#   Remove pcibios_name_device()
# 
# ChangeSet
#   2004/08/04 08:37:35-04:00 dwmw2@shinybook.infradead.org 
#   PCI quirks -- parisc. 
#   
#   Remove pcibios_fixups[] from core code and declare the one fixup in
#   the same place it's implemented.
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/parisc/superio.c
#   2004/08/04 08:37:17-04:00 dwmw2@shinybook.infradead.org +1 -0
#   Declare our own PCI fixup locally -- the central array went away.
# 
# arch/parisc/kernel/pci.c
#   2004/08/04 08:37:17-04:00 dwmw2@shinybook.infradead.org +0 -9
#   Remove pcibios_fixups array.
# 
# ChangeSet
#   2004/08/04 08:01:20-04:00 dsaxena@plexity.net 
#   [5/3][ARM] PCI quirks update for ARM
#   
#   Good idea.  Following is ARM patch.
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# arch/arm/kernel/bios32.c
#   2004/08/04 08:01:02-04:00 dsaxena@plexity.net +7 -32
#   [5/3][ARM] PCI quirks update for ARM
# 
# ChangeSet
#   2004/08/04 07:59:31-04:00 ralf@linux-mips.org 
#   [4/3] PCI quirks -- MIPS.
#   
#   Remove the bazillion of pcibios_fixups[] arrays on MIPS and replace them
#   with DECLARE_PCI_FIXUP_HEADER / DECLARE_PCI_FIXUP_FINAL where the array
#   definition was non-empty.
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# arch/mips/pmc-sierra/yosemite/ht.c
#   2004/08/04 07:59:12-04:00 ralf@linux-mips.org +0 -5
#   Remove the bazillion of pcibios_fixups[] arrays on MIPS and replace them
#   with DECLARE_PCI_FIXUP_HEADER / DECLARE_PCI_FIXUP_FINAL where the array
#   definition was non-empty.
# 
# arch/mips/pci/pci-sb1250.c
#   2004/08/04 07:59:12-04:00 ralf@linux-mips.org +0 -4
#   Remove the bazillion of pcibios_fixups[] arrays on MIPS and replace them
#   with DECLARE_PCI_FIXUP_HEADER / DECLARE_PCI_FIXUP_FINAL where the array
#   definition was non-empty.
# 
# arch/mips/pci/pci-ip27.c
#   2004/08/04 07:59:12-04:00 ralf@linux-mips.org +10 -11
#   Remove the bazillion of pcibios_fixups[] arrays on MIPS and replace them
#   with DECLARE_PCI_FIXUP_HEADER / DECLARE_PCI_FIXUP_FINAL where the array
#   definition was non-empty.
# 
# arch/mips/pci/fixup-yosemite.c
#   2004/08/04 07:59:12-04:00 ralf@linux-mips.org +0 -4
#   Remove the bazillion of pcibios_fixups[] arrays on MIPS and replace them
#   with DECLARE_PCI_FIXUP_HEADER / DECLARE_PCI_FIXUP_FINAL where the array
#   definition was non-empty.
# 
# arch/mips/pci/fixup-tb0226.c
#   2004/08/04 07:59:12-04:00 ralf@linux-mips.org +0 -4
#   Remove the bazillion of pcibios_fixups[] arrays on MIPS and replace them
#   with DECLARE_PCI_FIXUP_HEADER / DECLARE_PCI_FIXUP_FINAL where the array
#   definition was non-empty.
# 
# arch/mips/pci/fixup-tb0219.c
#   2004/08/04 07:59:12-04:00 ralf@linux-mips.org +0 -4
#   Remove the bazillion of pcibios_fixups[] arrays on MIPS and replace them
#   with DECLARE_PCI_FIXUP_HEADER / DECLARE_PCI_FIXUP_FINAL where the array
#   definition was non-empty.
# 
# arch/mips/pci/fixup-sni.c
#   2004/08/04 07:59:12-04:00 ralf@linux-mips.org +0 -4
#   Remove the bazillion of pcibios_fixups[] arrays on MIPS and replace them
#   with DECLARE_PCI_FIXUP_HEADER / DECLARE_PCI_FIXUP_FINAL where the array
#   definition was non-empty.
# 
# arch/mips/pci/fixup-ocelot-g.c
#   2004/08/04 07:59:12-04:00 ralf@linux-mips.org +0 -4
#   Remove the bazillion of pcibios_fixups[] arrays on MIPS and replace them
#   with DECLARE_PCI_FIXUP_HEADER / DECLARE_PCI_FIXUP_FINAL where the array
#   definition was non-empty.
# 
# arch/mips/pci/fixup-ocelot-c.c
#   2004/08/04 07:59:12-04:00 ralf@linux-mips.org +0 -4
#   Remove the bazillion of pcibios_fixups[] arrays on MIPS and replace them
#   with DECLARE_PCI_FIXUP_HEADER / DECLARE_PCI_FIXUP_FINAL where the array
#   definition was non-empty.
# 
# arch/mips/pci/fixup-mpc30x.c
#   2004/08/04 07:59:12-04:00 ralf@linux-mips.org +0 -4
#   Remove the bazillion of pcibios_fixups[] arrays on MIPS and replace them
#   with DECLARE_PCI_FIXUP_HEADER / DECLARE_PCI_FIXUP_FINAL where the array
#   definition was non-empty.
# 
# arch/mips/pci/fixup-malta.c
#   2004/08/04 07:59:12-04:00 ralf@linux-mips.org +4 -7
#   Remove the bazillion of pcibios_fixups[] arrays on MIPS and replace them
#   with DECLARE_PCI_FIXUP_HEADER / DECLARE_PCI_FIXUP_FINAL where the array
#   definition was non-empty.
# 
# arch/mips/pci/fixup-lasat.c
#   2004/08/04 07:59:12-04:00 ralf@linux-mips.org +0 -4
#   Remove the bazillion of pcibios_fixups[] arrays on MIPS and replace them
#   with DECLARE_PCI_FIXUP_HEADER / DECLARE_PCI_FIXUP_FINAL where the array
#   definition was non-empty.
# 
# arch/mips/pci/fixup-jaguar.c
#   2004/08/04 07:59:12-04:00 ralf@linux-mips.org +0 -4
#   Remove the bazillion of pcibios_fixups[] arrays on MIPS and replace them
#   with DECLARE_PCI_FIXUP_HEADER / DECLARE_PCI_FIXUP_FINAL where the array
#   definition was non-empty.
# 
# arch/mips/pci/fixup-ip32.c
#   2004/08/04 07:59:12-04:00 ralf@linux-mips.org +0 -4
#   Remove the bazillion of pcibios_fixups[] arrays on MIPS and replace them
#   with DECLARE_PCI_FIXUP_HEADER / DECLARE_PCI_FIXUP_FINAL where the array
#   definition was non-empty.
# 
# arch/mips/pci/fixup-ddb5477.c
#   2004/08/04 07:59:12-04:00 ralf@linux-mips.org +7 -9
#   Remove the bazillion of pcibios_fixups[] arrays on MIPS and replace them
#   with DECLARE_PCI_FIXUP_HEADER / DECLARE_PCI_FIXUP_FINAL where the array
#   definition was non-empty.
# 
# arch/mips/pci/fixup-ddb5074.c
#   2004/08/04 07:59:12-04:00 ralf@linux-mips.org +2 -5
#   Remove the bazillion of pcibios_fixups[] arrays on MIPS and replace them
#   with DECLARE_PCI_FIXUP_HEADER / DECLARE_PCI_FIXUP_FINAL where the array
#   definition was non-empty.
# 
# arch/mips/pci/fixup-cobalt.c
#   2004/08/04 07:59:12-04:00 ralf@linux-mips.org +5 -7
#   Remove the bazillion of pcibios_fixups[] arrays on MIPS and replace them
#   with DECLARE_PCI_FIXUP_HEADER / DECLARE_PCI_FIXUP_FINAL where the array
#   definition was non-empty.
# 
# arch/mips/pci/fixup-capcella.c
#   2004/08/04 07:59:12-04:00 ralf@linux-mips.org +0 -4
#   Remove the bazillion of pcibios_fixups[] arrays on MIPS and replace them
#   with DECLARE_PCI_FIXUP_HEADER / DECLARE_PCI_FIXUP_FINAL where the array
#   definition was non-empty.
# 
# arch/mips/pci/fixup-au1000.c
#   2004/08/04 07:59:12-04:00 ralf@linux-mips.org +0 -4
#   Remove the bazillion of pcibios_fixups[] arrays on MIPS and replace them
#   with DECLARE_PCI_FIXUP_HEADER / DECLARE_PCI_FIXUP_FINAL where the array
#   definition was non-empty.
# 
# arch/mips/pci/fixup-atlas.c
#   2004/08/04 07:59:12-04:00 ralf@linux-mips.org +2 -8
#   Remove the bazillion of pcibios_fixups[] arrays on MIPS and replace them
#   with DECLARE_PCI_FIXUP_HEADER / DECLARE_PCI_FIXUP_FINAL where the array
#   definition was non-empty.
# 
# ChangeSet
#   2004/08/04 07:57:35-04:00 dwmw2@shinybook.infradead.org 
#   [3/3] PCI quirks -- i386.
#   
#   Probably best to make i386 build again too... people bitch if their
#   favourite legacy architecture breaks.
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# arch/i386/pci/fixup.c
#   2004/08/04 07:57:17-04:00 dwmw2@shinybook.infradead.org +18 -111
#   Use new method of declaring PCI quirks.
# 
# ChangeSet
#   2004/08/04 07:56:07-04:00 dwmw2@shinybook.infradead.org 
#   [2/3] PCI quirks -- PPC.
#   
#   Remove up the PPC pcibios_fixups[] array. Remove the ifdefs on
#   CONFIG_PPC_PMAC in the kernel PPC code, moving that stuff into
#   pmac-specific files where it lives. Add a quirk for the CardBus
#   controller on WindRiver SBC8260.
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# arch/ppc/platforms/sbc82xx.c
#   2004/08/04 07:55:48-04:00 dwmw2@shinybook.infradead.org +20 -0
#   Add PCI quirk to set up the CardBus controller.
# 
# arch/ppc/platforms/pmac_pci.c
#   2004/08/04 07:55:48-04:00 dwmw2@shinybook.infradead.org +5 -0
#   Declare our own PCI quirks.
# 
# arch/ppc/kernel/pci.c
#   2004/08/04 07:55:48-04:00 dwmw2@shinybook.infradead.org +4 -19
#   Remove PMAC PCI quirks, convert others to new declaration method.
# 
# ChangeSet
#   2004/08/04 07:54:19-04:00 dwmw2@shinybook.infradead.org 
#   [1/3] Split pci quirks array to allow separate declarations.
#   
#   It's a pain in the arse to set up platform-specific PCI quirks -- you
#   have to put your platform-specific quirk into the generic (or at least
#   the architecture) array. This patch fixes that, allowing you to
#   DECLARE_PCI_FIXUP_HEADER() or DECLARE_PCI_FIXUP_FINAL() anywhere you
#   like.
#   
#   Note that a lot of the quirks can now be moved out of
#   drivers/pci/quirks.c and put somewhere closer to where they belong.
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# include/linux/pci.h
#   2004/08/04 07:54:00-04:00 dwmw2@shinybook.infradead.org +12 -3
#   Remove old quirks array, add DECLARE_PCI_FIXUP_{FINAL,HEADER}
# 
# include/asm-generic/vmlinux.lds.h
#   2004/08/04 07:54:00-04:00 dwmw2@shinybook.infradead.org +10 -0
#   Add PCI quirks to RODATA
# 
# drivers/pci/quirks.c
#   2004/08/04 07:54:00-04:00 dwmw2@shinybook.infradead.org +126 -135
#   Split pci quirks array to allow separate declarations.
# 
# ChangeSet
#   2004/08/04 02:57:45-07:00 akpm@bix.(none) 
#   Merge bk://kernel.bkbits.net/gregkh/linux/pci-2.6
#   into bix.(none):/usr/src/bk-pci
# 
# drivers/pci/pci.ids
#   2004/08/04 02:57:42-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/08/02 16:28:17-07:00 nacc@us.ibm.com 
#   [PATCH] PCI: replace schedule_timeout() with msleep()
#   
#   Use msleep() instead of schedule_timeout() to guarantee
#   the task delays for the desired time.
#   
#   Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/pci/pci.c
#   2004/07/02 19:45:16-07:00 nacc@us.ibm.com +1 -4
#   PCI: replace schedule_timeout() with msleep()
# 
# ChangeSet
#   2004/08/02 16:12:12-07:00 akpm@osdl.org 
#   [PATCH] I2C: activate SMBus device on hp d300l
#   
#   From: Dominik Brodowski <linux@dominikbrodowski.de>
#   
#   HP hides the SMBus on the HP D330L. Original patch by Stoyan Martinov.
#   
#   Signed-off-by: Örjan Persson <orange@fobie.net>
#   Signed-off-by: Dominik Brodowski <linux@brodo.de>
#   Signed-off-by: Andrew Morton <akpm@osdl.org>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/pci/quirks.c
#   2004/07/27 07:24:16-07:00 akpm@osdl.org +7 -0
#   I2C: activate SMBus device on hp d300l
# 
# ChangeSet
#   2004/08/02 16:11:29-07:00 nacc@us.ibm.com 
#   [PATCH] I2C: scx200_acb: replace schedule_timeout() with msleep()
#   
#   Uses msleep() instead of schedule_timeout() to guarantee
#   the task delays the requested time.
#   
#   Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/busses/scx200_acb.c
#   2004/07/21 09:55:39-07:00 nacc@us.ibm.com +2 -1
#   I2C: scx200_acb: replace schedule_timeout() with msleep()
# 
# ChangeSet
#   2004/08/02 16:11:06-07:00 nacc@us.ibm.com 
#   [PATCH] I2C: i2c-nforce2: replace schedule_timeout() with msleep()
#   
#   Uses msleep() instead of schedule_timeout() to guarantee
#   the task delays at least the desired time amount.
#   
#   Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/busses/i2c-nforce2.c
#   2004/07/12 11:06:23-07:00 nacc@us.ibm.com +1 -2
#   I2C: i2c-nforce2: replace schedule_timeout() with msleep()
# 
# ChangeSet
#   2004/08/02 16:10:33-07:00 amalysh@web.de 
#   [PATCH] I2C: new device for sis630
#   
#   this patch adds SiS 1039:0018 to PCI device list of sis630.c. This is needed,
#   due to changes in pci quirks that cause sis630/sis730 LPC to change id from
#   008 -> 0018. This patch doesn't have any side effects, because i2c-sis630
#   checks for supported devices.
#   
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/busses/i2c-sis630.c
#   2004/07/06 01:55:29-07:00 amalysh@web.de +1 -0
#   I2C: new device for sis630
# 
# ChangeSet
#   2004/08/02 16:10:06-07:00 khali@linux-fr.org 
#   [PATCH] I2C: Fix debug in w83781d driver
#   
#   The trivial patch below fixes two debug prints in the w83781d driver
#   (one needless dereference and one debug print without device info).
#   
#   Signed-off-by: Jean Delvare <khali at linux-fr dot org>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/chips/w83781d.c
#   2004/07/31 13:03:04-07:00 khali@linux-fr.org +2 -3
#   I2C: Fix debug in w83781d driver
# 
# ChangeSet
#   2004/08/02 16:09:44-07:00 dsaxena@plexity.net 
#   [PATCH] I2C: Add Intel IXP2000 GPIO-based I2C adapter
#   
#   Following patch adds support for using GPIO pins on Intel's IXP2000
#   Network Processor as a bit-bang I2C adapter. IXP2000 support will
#   be coming in via ARM updates once all the various drivers have been
#   merged upstream.
#   
#   Signed-off-by: Deepak Saxena <dsaxena@plexity.net>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/busses/i2c-ixp2000.c
#   2004/07/27 09:01:52-07:00 dsaxena@plexity.net +171 -0
#   I2C: Add Intel IXP2000 GPIO-based I2C adapter
# 
# drivers/i2c/busses/Makefile
#   2004/07/27 09:01:52-07:00 dsaxena@plexity.net +1 -0
#   I2C: Add Intel IXP2000 GPIO-based I2C adapter
# 
# drivers/i2c/busses/Kconfig
#   2004/07/27 09:01:52-07:00 dsaxena@plexity.net +11 -0
#   I2C: Add Intel IXP2000 GPIO-based I2C adapter
# 
# drivers/i2c/busses/i2c-ixp2000.c
#   2004/07/27 09:01:52-07:00 dsaxena@plexity.net +0 -0
#   BitKeeper file /home/greg/linux/BK/i2c-2.6/drivers/i2c/busses/i2c-ixp2000.c
# 
# ChangeSet
#   2004/08/02 16:09:18-07:00 nacc@us.ibm.com 
#   [PATCH] I2C: i2c-ite: replace schedule_timeout() with msleep()
#   
#   Remove iic_ite_sleep() and replace invocations with msleep().
#   
#   Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/busses/i2c-ite.c
#   2004/07/02 10:53:08-07:00 nacc@us.ibm.com +0 -8
#   I2C: i2c-ite: replace schedule_timeout() with msleep()
# 
# ChangeSet
#   2004/08/02 16:07:56-07:00 nacc@us.ibm.com 
#   [PATCH] I2C: i2c-algo-pcf: replace schedule_timeout() with msleep()
#   
#   Remove pcf_sleep() and replace invocations with msleep().
#   
#   Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/algos/i2c-algo-pcf.c
#   2004/07/02 10:48:33-07:00 nacc@us.ibm.com +0 -6
#   I2C: i2c-algo-pcf: replace schedule_timeout() with msleep()
# 
# ChangeSet
#   2004/08/02 16:05:14-07:00 nacc@us.ibm.com 
#   [PATCH] I2C: i2c-keywest: replace schedule_timeout() with msleep()
#   
#   Uses msleep() instead of schedule_timeout() to guarantee
#   the task delays at least the desired time amount.
#   
#   Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/i2c/busses/i2c-keywest.c
#   2004/07/02 10:54:11-07:00 nacc@us.ibm.com +1 -2
#   I2C: i2c-keywest: replace schedule_timeout() with msleep()
# 
# ChangeSet
#   2004/08/02 15:37:32-07:00 greg@kroah.com 
#   [PATCH] PCI Hotplug: fix build warnings due to msleep() patches.
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/pci/hotplug/shpchp_hpc.c
#   2004/08/02 15:32:26-07:00 greg@kroah.com +1 -0
#   PCI Hotplug: fix build warnings due to msleep() patches.
# 
# drivers/pci/hotplug/ibmphp_hpc.c
#   2004/08/02 15:32:26-07:00 greg@kroah.com +1 -0
#   PCI Hotplug: fix build warnings due to msleep() patches.
# 
# drivers/pci/hotplug/cpci_hotplug_core.c
#   2004/08/02 15:32:26-07:00 greg@kroah.com +1 -0
#   PCI Hotplug: fix build warnings due to msleep() patches.
# 
# ChangeSet
#   2004/08/02 15:36:46-07:00 killekulla@rdrz.de 
#   [PATCH] PCI: fix PCI access mode dependences in arch/i386/Kconfig
#   
#   While all ACPI stuff is deselected, and PCI access mode is set to "Any",
#   CONFIG_ACPI_BOOT is going to be set because of CONFIG_PCI_MMCONFIG.
#   
#   If CONFIG_ACPI_BOOT is not allready set by other stuff, setting PCI access
#   mode to "Any" shouldn't set CONFIG_PCI_MMCONFIG.  Anyhow, setting PCI
#   access mode to "MMConfig" should select CONFIG_ACPI_BOOT.
#   
#   Signed-off-by: Raphael Zimmerer <killekulla@rdrz.de>
#   Signed-off-by: Andrew Morton <akpm@osdl.org>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# arch/i386/Kconfig
#   2004/07/31 17:52:11-07:00 killekulla@rdrz.de +1 -1
#   PCI: fix PCI access mode dependences in arch/i386/Kconfig
# 
# ChangeSet
#   2004/08/02 15:36:27-07:00 nacc@us.ibm.com 
#   [PATCH] PCI Hotplug: shpchp_hpc: replace schedule_timeout() with msleep()
#   
#   Uses msleep() instead of schedule_timeout() to guarantee
#   the task delays the desired time.
#   
#   Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/pci/hotplug/shpchp_hpc.c
#   2004/07/12 15:19:24-07:00 nacc@us.ibm.com +1 -2
#   PCI Hotplug: shpchp_hpc: replace schedule_timeout() with msleep()
# 
# ChangeSet
#   2004/08/02 15:36:10-07:00 nacc@us.ibm.com 
#   [PATCH] PCI Hotplug: ibmphp_hpc: replace long_delay() with msleep()
#   
#   Replace long_delay() with msleep() to guarantee the task
#   delays as desired.
#   
#   Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/pci/hotplug/ibmphp_hpc.c
#   2004/07/12 15:12:43-07:00 nacc@us.ibm.com +9 -10
#   PCI Hotplug: ibmphp_hpc: replace long_delay() with msleep()
# 
# ChangeSet
#   2004/08/02 15:35:52-07:00 nacc@us.ibm.com 
#   [PATCH] PCI Hotplug: ibmphp_core: replace long_delay() with msleep()
#   
#   Replace long_delay() with msleep() to guarantee the task
#   delays as desired.
#   
#   Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/pci/hotplug/ibmphp_core.c
#   2004/07/08 17:05:25-07:00 nacc@us.ibm.com +2 -2
#   PCI Hotplug: ibmphp_core: replace long_delay() with msleep()
# 
# ChangeSet
#   2004/08/02 15:35:34-07:00 domen@coderock.org 
#   [PATCH] PCI: use list_for_each() drivers/pci/setup-bus.c
#   
#   From: Domen Puncer <domen@coderock.org>
#   Signed-off-by: Maximilian Attems <janitor@sternwelten.at>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/pci/setup-bus.c
#   2004/07/11 05:41:20-07:00 domen@coderock.org +3 -2
#   PCI: use list_for_each() drivers/pci/setup-bus.c
# 
# ChangeSet
#   2004/08/02 15:34:59-07:00 nacc@us.ibm.com 
#   [PATCH] PCI Hotplug: ibmphp: remove long_delay
#   
#   Remove unused function long_delay().
#   
#   Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/pci/hotplug/ibmphp.h
#   2004/07/08 17:05:07-07:00 nacc@us.ibm.com +0 -6
#   PCI Hotplug: ibmphp: remove long_delay
# 
# ChangeSet
#   2004/08/02 15:34:38-07:00 nacc@us.ibm.com 
#   [PATCH] PCI Hotplug: cpci_hotplug_core: replace schedule_timeout() with msleep()
#   
#   Uses msleep() instead of schedule_timeout() to guarantee
#   the task delays the desired time.
#   
#   Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/pci/hotplug/cpci_hotplug_core.c
#   2004/07/12 15:10:14-07:00 nacc@us.ibm.com +7 -10
#   PCI Hotplug: cpci_hotplug_core: replace schedule_timeout() with msleep()
# 
# ChangeSet
#   2004/08/02 15:34:05-07:00 domen@coderock.org 
#   [PATCH] PCI: use list_for_each() i386/pci/common.c
#   
#   From: Domen Puncer <domen@coderock.org>
#   Signed-off-by: Maximilian Attems <janitor@sternwelten.at>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# arch/i386/pci/common.c
#   2004/07/11 05:41:10-07:00 domen@coderock.org +1 -1
#   PCI: use list_for_each() i386/pci/common.c
# 
# ChangeSet
#   2004/08/02 15:33:31-07:00 domen@coderock.org 
#   [PATCH] PCI: use list_for_each() i386/pci/pcbios.c
#   
#   From: Domen Puncer <domen@coderock.org>
#   Signed-off-by: Maximilian Attems <janitor@sternwelten.at>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# arch/i386/pci/pcbios.c
#   2004/07/11 05:41:13-07:00 domen@coderock.org +1 -1
#   PCI: use list_for_each() i386/pci/pcbios.c
# 
# ChangeSet
#   2004/08/02 15:24:01-07:00 greg@kroah.com 
#   PCI: update pci.ids from sf.net site.
#   
#   Patch taken from http://www.codemonkey.org.uk/projects/pci/pci.ids-2004-08-02.diff
#   and tweaked by hand to build with no warnings.
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/pci/pci.ids
#   2004/08/02 15:22:50-07:00 greg@kroah.com +389 -152
#   PCI: update pci.ids from sf.net site.
#   
#   Patch taken from http://www.codemonkey.org.uk/projects/pci/pci.ids-2004-08-02.diff
#   and tweaked by hand to build with no warnings.
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# ChangeSet
#   2004/08/02 13:30:07-07:00 akpm@bix.(none) 
#   Merge bix.(none):/usr/src/bk25 into bix.(none):/usr/src/bk-pci
# 
# arch/i386/pci/irq.c
#   2004/08/02 13:30:03-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/08/01 00:12:39-07:00 akpm@bix.(none) 
#   Merge bix.(none):/usr/src/bk25 into bix.(none):/usr/src/bk-pci
# 
# include/linux/pci_ids.h
#   2004/08/01 00:12:36-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/07/30 22:35:06-07:00 akpm@bix.(none) 
#   Merge bix.(none):/usr/src/bk25 into bix.(none):/usr/src/bk-pci
# 
# include/linux/pci_ids.h
#   2004/07/30 22:35:02-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/07/16 18:41:52-07:00 akpm@bix.(none) 
#   Merge bk://kernel.bkbits.net/gregkh/linux/pci-2.6
#   into bix.(none):/usr/src/bk-pci
# 
# include/linux/pci_ids.h
#   2004/07/16 18:41:48-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# drivers/pci/pci.ids
#   2004/07/16 18:41:48-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/07/16 18:40:58-07:00 akpm@bix.(none) 
#   Merge bix.(none):/usr/src/bk25 into bix.(none):/usr/src/bk-pci
# 
# include/linux/pci_ids.h
#   2004/07/16 18:40:54-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/07/14 16:22:57-07:00 greg@kroah.com 
#   Merge kroah.com:/home/greg/linux/BK/bleed-2.6
#   into kroah.com:/home/greg/linux/BK/pci-2.6
# 
# include/linux/pci_ids.h
#   2004/07/14 16:22:52-07:00 greg@kroah.com +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/07/14 13:31:39-07:00 lxiep@us.ibm.com 
#   [PATCH] PCI Hotplug: rpaphp_add_slot.patch
#   
#   I found a bug in rpaphp code during DLPAR I/O testing.   When DLPAR ADD
#   a non-empty I/O slot to a partition,  an adapter  in the slot  didn't
#   get configured. The attached patch fixes that.
#   
#   Signed-off-by: Linda Xie <lxie@us.ibm.com>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# ChangeSet
#   2004/07/14 13:31:00-07:00 buytenh@wantstofly.org 
#   [PATCH] PCI: more New PCI vendor/device ID for Radisys ENP-2611 board
#   
#   OK, sorry to bother, some more bits.
#   
#   - Add PCI IDs for the IXP2400 and IXP2800 network processors.
#   - Fix typo in description for 8086:9000.
#   - Correct tab->space after #define in definition of IXP4xx device ID.
#   - ENP-2611 can appear behind a 21555.
#   
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# include/linux/pci_ids.h
#   2004/07/02 15:18:42-07:00 buytenh@wantstofly.org +3 -1
#   PCI: more New PCI vendor/device ID for Radisys ENP-2611 board
# 
# drivers/pci/pci.ids
#   2004/07/02 15:19:15-07:00 buytenh@wantstofly.org +4 -1
#   PCI: more New PCI vendor/device ID for Radisys ENP-2611 board
# 
# ChangeSet
#   2004/07/14 13:30:11-07:00 vernux@us.ibm.com 
#   [PATCH] PCI Hotplug: acpiphp extension for 2.6.7 part 2
#   
#   This patch adds the first driver that actually uses the callback
#   function for attention LEDs that the acpiphp-attention patch
#   adds.  It searches the ACPI namespace for IBM hardware, sets up
#   the callbacks and sets up a handler to read ACPI events and
#   forward them on to /proc/acpi/event.  It also exports an ACPI
#   table that shows current hotplug status to userland.
#   
#   
#   Signed-off-by: Vernon Mauery <vernux@us.ibm.com>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/pci/hotplug/acpiphp_ibm.c
#   2004/07/08 16:54:15-07:00 vernux@us.ibm.com +474 -0
#   PCI Hotplug: acpiphp extension for 2.6.7 part 2
# 
# drivers/pci/hotplug/Makefile
#   2004/07/08 16:54:15-07:00 vernux@us.ibm.com +1 -0
#   PCI Hotplug: acpiphp extension for 2.6.7 part 2
# 
# drivers/pci/hotplug/Kconfig
#   2004/07/08 16:54:15-07:00 vernux@us.ibm.com +12 -0
#   PCI Hotplug: acpiphp extension for 2.6.7 part 2
# 
# drivers/pci/hotplug/acpiphp_ibm.c
#   2004/07/08 16:54:15-07:00 vernux@us.ibm.com +0 -0
#   BitKeeper file /home/greg/linux/BK/pci-2.6/drivers/pci/hotplug/acpiphp_ibm.c
# 
# ChangeSet
#   2004/07/14 13:29:31-07:00 vernux@us.ibm.com 
#   [PATCH] PCI Hotplug: acpiphp extension for 2.6.7, part 1
#   
#   This patch adds the ability to register callback functions with
#   the acpiphp core to set and get the current attention LED
#   status.  The reason this is needed is because there is not set
#   ACPI standard for how this is done so each hardware platform may
#   implement it differently.  To keep hardware specific code out of
#   acpiphp, we allow other modules to register their code with it.
#   
#   
#   
#   Signed-off-by: Vernon Mauery <vernux@us.ibm.com>
#   Signed-off-by: Greg Kroah-Hartman <greg@kroah.com>
# 
# drivers/pci/hotplug/acpiphp_glue.c
#   2004/07/08 16:54:08-07:00 vernux@us.ibm.com +0 -14
#   PCI Hotplug: acpiphp extension for 2.6.7, part 1
# 
# drivers/pci/hotplug/acpiphp_core.c
#   2004/07/08 16:54:08-07:00 vernux@us.ibm.com +99 -28
#   PCI Hotplug: acpiphp extension for 2.6.7, part 1
# 
# drivers/pci/hotplug/acpiphp.h
#   2004/07/08 16:54:08-07:00 vernux@us.ibm.com +16 -0
#   PCI Hotplug: acpiphp extension for 2.6.7, part 1
# 
# ChangeSet
#   2004/07/11 13:41:14-07:00 akpm@bix.(none) 
#   Merge bix.(none):/usr/src/bk25 into bix.(none):/usr/src/bk-pci
# 
# arch/i386/kernel/dmi_scan.c
#   2004/07/11 13:41:11-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/07/05 13:06:46-07:00 akpm@bix.(none) 
#   Merge bix.(none):/usr/src/bk25 into bix.(none):/usr/src/bk-pci
# 
# arch/i386/kernel/dmi_scan.c
#   2004/07/05 13:06:42-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/07/02 15:26:07-07:00 akpm@bix.(none) 
#   Merge bix.(none):/usr/src/bk25 into bix.(none):/usr/src/bk-pci
# 
# include/linux/pci_ids.h
#   2004/07/02 15:26:03-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# drivers/pci/pci.ids
#   2004/07/02 15:26:03-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/07/01 01:43:28-07:00 akpm@bix.(none) 
#   Merge bix.(none):/usr/src/bk25 into bix.(none):/usr/src/bk-pci
# 
# include/linux/pci_ids.h
#   2004/07/01 01:43:24-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/06/28 00:32:35-07:00 akpm@bix.(none) 
#   Merge bix.(none):/usr/src/bk25 into bix.(none):/usr/src/bk-pci
# 
# arch/i386/pci/irq.c
#   2004/06/28 00:32:31-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# arch/i386/kernel/dmi_scan.c
#   2004/06/28 00:32:31-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/06/24 18:25:30-07:00 akpm@bix.(none) 
#   Merge bix.(none):/usr/src/bk25 into bix.(none):/usr/src/bk-pci
# 
# include/linux/pci_ids.h
#   2004/06/24 18:25:26-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# arch/i386/pci/irq.c
#   2004/06/24 18:25:26-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/06/24 12:53:53-07:00 akpm@bix.(none) 
#   Merge bix.(none):/usr/src/bk25 into bix.(none):/usr/src/bk-pci
# 
# include/linux/pci_ids.h
#   2004/06/24 12:53:49-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/06/23 20:35:25-07:00 akpm@bix.(none) 
#   Merge bix.(none):/usr/src/bk25 into bix.(none):/usr/src/bk-pci
# 
# arch/i386/pci/irq.c
#   2004/06/23 20:35:21-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/06/23 02:01:10-07:00 akpm@bix.(none) 
#   Merge bk://kernel.bkbits.net/gregkh/linux/pci-2.6
#   into bix.(none):/usr/src/bk-pci
# 
# include/linux/pci_ids.h
#   2004/06/23 02:01:06-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# arch/i386/pci/irq.c
#   2004/06/23 02:01:06-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# arch/i386/kernel/dmi_scan.c
#   2004/06/23 02:01:06-07:00 akpm@bix.(none) +0 -7
#   Auto merged
# 
# ChangeSet
#   2004/06/20 23:49:50-07:00 akpm@bix.(none) 
#   Merge
# 
# arch/i386/pci/irq.c
#   2004/06/20 23:49:47-07:00 akpm@bix.(none) +0 -0
#   SCCS merged
# 
# arch/i386/kernel/dmi_scan.c
#   2004/06/20 23:49:26-07:00 akpm@bix.(none) +7 -0
#   SCCS merged
# 
# ChangeSet
#   2004/06/18 12:23:56-07:00 akpm@bix.(none) 
#   Merge bix.(none):/usr/src/bk25 into bix.(none):/usr/src/bk-pci
# 
# include/linux/pci_ids.h
#   2004/06/18 12:23:53-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# arch/i386/kernel/dmi_scan.c
#   2004/06/18 12:23:53-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/06/15 21:56:51-07:00 akpm@bix.(none) 
#   Merge bix.(none):/usr/src/bk25 into bix.(none):/usr/src/bk-pci
# 
# include/linux/pci_ids.h
#   2004/06/15 21:56:48-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# drivers/pci/pci.ids
#   2004/06/15 21:56:48-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/06/08 21:55:31-07:00 akpm@bix.(none) 
#   Merge bk://kernel.bkbits.net/gregkh/linux/pci-2.6
#   into bix.(none):/usr/src/bk-pci
# 
# arch/i386/kernel/dmi_scan.c
#   2004/06/08 21:55:27-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/06/03 10:37:43-07:00 akpm@bix.(none) 
#   Merge bix.(none):/usr/src/bk25 into bix.(none):/usr/src/bk-pci
# 
# include/linux/pci_ids.h
#   2004/06/03 10:37:40-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/06/02 13:31:47-07:00 akpm@bix.(none) 
#   Merge bix.(none):/usr/src/bk25 into bix.(none):/usr/src/bk-pci
# 
# include/linux/pci_ids.h
#   2004/06/02 13:31:44-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/05/28 14:10:25-07:00 akpm@bix.(none) 
#   Merge bk://kernel.bkbits.net/gregkh/linux/pci-2.6
#   into bix.(none):/usr/src/bk-pci
# 
# include/linux/pci_ids.h
#   2004/05/28 14:10:22-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# drivers/pci/pci.ids
#   2004/05/28 14:10:22-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/05/28 14:09:37-07:00 akpm@bix.(none) 
#   Merge bix.(none):/usr/src/bk25 into bix.(none):/usr/src/bk-pci
# 
# include/linux/pci_ids.h
#   2004/05/28 14:09:34-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/05/24 11:42:00-07:00 akpm@bix.(none) 
#   Merge bix.(none):/usr/src/bk25 into bix.(none):/usr/src/bk-pci
# 
# include/linux/pci_ids.h
#   2004/05/24 11:41:57-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/05/22 23:42:26-07:00 akpm@bix.(none) 
#   Merge bix.(none):/usr/src/bk25 into bix.(none):/usr/src/bk-pci
# 
# include/linux/pci_ids.h
#   2004/05/22 23:42:23-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
# ChangeSet
#   2004/05/19 14:16:27-07:00 akpm@bix.(none) 
#   Merge bk://kernel.bkbits.net/gregkh/linux/pci-2.6
#   into bix.(none):/usr/src/bk-pci
# 
# drivers/pci/pci.ids
#   2004/05/19 14:16:24-07:00 akpm@bix.(none) +0 -0
#   Auto merged
# 
Index: xx-sources/Documentation/pci.txt
===================================================================
--- xx-sources.orig/Documentation/pci.txt	2004-08-14 01:36:57.000000000 -0400
+++ xx-sources/Documentation/pci.txt	2004-08-14 13:17:24.618793808 -0400
@@ -25,6 +25,7 @@
 	Discover resources (addresses and IRQ numbers) provided by the device
 	Allocate these resources
 	Communicate with the device
+	Disable the device
 
 Most of these topics are covered by the following sections, for the rest
 look at <linux/pci.h>, it's hopefully well commented.
@@ -162,8 +163,8 @@
 count on these devices by calling pci_dev_put().
 
 
-3. Enabling devices
-~~~~~~~~~~~~~~~~~~~
+3. Enabling and disabling devices
+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    Before you do anything with the device you've found, you need to enable
 it by calling pci_enable_device() which enables I/O and memory regions of
 the device, allocates an IRQ if necessary, assigns missing resources if
@@ -180,6 +181,12 @@
 Make sure to check the return value of pci_set_mwi(), not all architectures
 may support Memory-Write-Invalidate.
 
+   If your driver decides to stop using the device (e.g., there was an
+error while setting it up or the driver module is being unloaded), it
+should call pci_disable_device() to deallocate any IRQ resources, disable
+PCI bus-mastering, etc.  You should not do anything with the device after
+calling pci_disable_device().
+
 4. How to access PCI config space
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    You can use pci_(read|write)_config_(byte|word|dword) to access the config
Index: xx-sources/arch/alpha/kernel/pci.c
===================================================================
--- xx-sources.orig/arch/alpha/kernel/pci.c	2004-08-14 01:36:14.000000000 -0400
+++ xx-sources/arch/alpha/kernel/pci.c	2004-08-14 13:17:24.620793504 -0400
@@ -67,6 +67,7 @@
 {
 	dev->class = PCI_CLASS_BRIDGE_ISA << 8;
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82378, quirk_isa_bridge);
 
 static void __init
 quirk_cypress(struct pci_dev *dev)
@@ -100,6 +101,7 @@
 		}
 	}
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_CONTAQ, PCI_DEVICE_ID_CONTAQ_82C693, quirk_cypress);
 
 /* Called for each device after PCI setup is done. */
 static void __init
@@ -112,17 +114,10 @@
 		isa_bridge = dev;
 	}
 }
+DECLARE_PCI_FIXUP_FINAL(PCI_ANY_ID, PCI_ANY_ID, pcibios_fixup_final);
 
-struct pci_fixup pcibios_fixups[] __initdata = {
-	{ PCI_FIXUP_HEADER, PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82378,
-	  quirk_isa_bridge },
-	{ PCI_FIXUP_HEADER, PCI_VENDOR_ID_CONTAQ, PCI_DEVICE_ID_CONTAQ_82C693,
-	  quirk_cypress },
-	{ PCI_FIXUP_FINAL,  PCI_ANY_ID,	PCI_ANY_ID,
-	  pcibios_fixup_final },
-	{ 0 }
-};
-
+/* Just declaring that the power-of-ten prefixes are actually the
+   power-of-two ones doesn't make it true :) */
 #define KB			1024
 #define MB			(1024*KB)
 #define GB			(1024*MB)
Index: xx-sources/arch/arm/kernel/bios32.c
===================================================================
--- xx-sources.orig/arch/arm/kernel/bios32.c	2004-08-14 01:36:56.000000000 -0400
+++ xx-sources/arch/arm/kernel/bios32.c	2004-08-14 13:17:24.622793200 -0400
@@ -128,12 +128,14 @@
 	pci_write_config_word(dev, 0x44, 0xb000);
 	outb(0x08, 0x4d1);
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_WINBOND, PCI_DEVICE_ID_WINBOND_83C553, pci_fixup_83c553);
 
 static void __devinit pci_fixup_unassign(struct pci_dev *dev)
 {
 	dev->resource[0].end -= dev->resource[0].start;
 	dev->resource[0].start = 0;
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_WINBOND2, PCI_DEVICE_ID_WINBOND2_89C940F, pci_fixup_unassign);
 
 /*
  * Prevent the PCI layer from seeing the resources allocated to this device
@@ -154,6 +156,7 @@
 		}
 	}
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_DEC, PCI_DEVICE_ID_DEC_21285, pci_fixup_dec21285);
 
 /*
  * Same as above. The PrPMC800 carrier board for the PrPMC1100 
@@ -178,6 +181,7 @@
 		}
 	}
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_IXP4XX, pci_fixup_prpmc1100);
 
 /*
  * PCI IDE controllers use non-standard I/O port decoding, respect it.
@@ -198,6 +202,7 @@
 		}
 	}
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, pci_fixup_ide_bases);
 
 /*
  * Put the DEC21142 to sleep
@@ -206,6 +211,7 @@
 {
 	pci_write_config_dword(dev, 0x40, 0x80000000);
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_DEC, PCI_DEVICE_ID_DEC_21142, pci_fixup_dec21142);
 
 /*
  * The CY82C693 needs some rather major fixups to ensure that it does
@@ -271,38 +277,7 @@
 		pci_write_config_byte(dev, 0x45, 0x03);
 	}
 }
-
-struct pci_fixup pcibios_fixups[] = {
-	{
-		PCI_FIXUP_HEADER,
-		PCI_VENDOR_ID_CONTAQ,	PCI_DEVICE_ID_CONTAQ_82C693,
-		pci_fixup_cy82c693
-	}, {
-		PCI_FIXUP_HEADER,
-		PCI_VENDOR_ID_DEC,	PCI_DEVICE_ID_DEC_21142,
-		pci_fixup_dec21142
-	}, {
-		PCI_FIXUP_HEADER,
-		PCI_VENDOR_ID_DEC,	PCI_DEVICE_ID_DEC_21285,
-		pci_fixup_dec21285
-	}, {
-		PCI_FIXUP_HEADER,
-		PCI_VENDOR_ID_WINBOND,	PCI_DEVICE_ID_WINBOND_83C553,
-		pci_fixup_83c553
-	}, {
-		PCI_FIXUP_HEADER,
-		PCI_VENDOR_ID_WINBOND2,	PCI_DEVICE_ID_WINBOND2_89C940F,
-		pci_fixup_unassign
-	}, {
-		PCI_FIXUP_HEADER,
-		PCI_ANY_ID,		PCI_ANY_ID,
-		pci_fixup_ide_bases
-	}, {
-		PCI_FIXUP_HEADER,
-		PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_IXP4XX,
-		pci_fixup_prpmc1100
-	}, { 0 }
-};
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_CONTAQ, PCI_DEVICE_ID_CONTAQ_82C693, pci_fixup_cy82c693);
 
 void __devinit pcibios_update_irq(struct pci_dev *dev, int irq)
 {
Index: xx-sources/arch/i386/Kconfig
===================================================================
--- xx-sources.orig/arch/i386/Kconfig	2004-08-14 01:36:17.000000000 -0400
+++ xx-sources/arch/i386/Kconfig	2004-08-14 13:17:24.626792592 -0400
@@ -1105,7 +1105,7 @@
 
 config PCI_MMCONFIG
 	bool
-	depends on PCI && (PCI_GOMMCONFIG || PCI_GOANY)
+	depends on PCI && (PCI_GOMMCONFIG || (PCI_GOANY && ACPI))
 	select ACPI_BOOT
 	default y
 
Index: xx-sources/arch/i386/pci/common.c
===================================================================
--- xx-sources.orig/arch/i386/pci/common.c	2004-08-14 01:36:56.000000000 -0400
+++ xx-sources/arch/i386/pci/common.c	2004-08-14 13:17:24.639790616 -0400
@@ -70,7 +70,7 @@
 	int i;
 
 	DBG("PCI: Scanning for ghost devices on bus %d\n", b->number);
-	for (ln=b->devices.next; ln != &b->devices; ln=ln->next) {
+	list_for_each(ln, &b->devices) {
 		d = pci_dev_b(ln);
 		if ((d->class >> 8) == PCI_CLASS_BRIDGE_HOST)
 			seen_host_bridge++;
Index: xx-sources/arch/i386/pci/fixup.c
===================================================================
--- xx-sources.orig/arch/i386/pci/fixup.c	2004-08-14 01:37:26.000000000 -0400
+++ xx-sources/arch/i386/pci/fixup.c	2004-08-14 13:17:24.643790008 -0400
@@ -29,6 +29,7 @@
 	}
 	pcibios_last_bus = -1;
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82451NX, pci_fixup_i450nx);
 
 static void __devinit pci_fixup_i450gx(struct pci_dev *d)
 {
@@ -42,6 +43,7 @@
 	pci_scan_bus(busno, &pci_root_ops, NULL);
 	pcibios_last_bus = -1;
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82454GX, pci_fixup_i450gx);
 
 static void __devinit  pci_fixup_umc_ide(struct pci_dev *d)
 {
@@ -55,6 +57,7 @@
 	for(i=0; i<4; i++)
 		d->resource[i].flags |= PCI_BASE_ADDRESS_SPACE_IO;
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_UMC, PCI_DEVICE_ID_UMC_UM8886BF, pci_fixup_umc_ide);
 
 static void __devinit  pci_fixup_ncr53c810(struct pci_dev *d)
 {
@@ -67,6 +70,7 @@
 		d->class = PCI_CLASS_STORAGE_SCSI << 8;
 	}
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_NCR, PCI_DEVICE_ID_NCR_53C810, pci_fixup_ncr53c810);
 
 static void __devinit pci_fixup_ide_bases(struct pci_dev *d)
 {
@@ -86,6 +90,7 @@
 		}
 	}
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, pci_fixup_ide_bases);
 
 static void __devinit  pci_fixup_ide_trash(struct pci_dev *d)
 {
@@ -108,6 +113,10 @@
 	for(i=0; i<4; i++)
 		d->resource[i].start = d->resource[i].end = d->resource[i].flags = 0;
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_SI, PCI_DEVICE_ID_SI_5513, pci_fixup_ide_trash);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801CA_10, pci_fixup_ide_trash);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801CA_11, pci_fixup_ide_trash);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82801DB_9, pci_fixup_ide_trash);
 
 static void __devinit  pci_fixup_latency(struct pci_dev *d)
 {
@@ -118,6 +127,8 @@
 	DBG("PCI: Setting max latency to 32\n");
 	pcibios_max_latency = 32;
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_SI, PCI_DEVICE_ID_SI_5597, pci_fixup_latency);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_SI, PCI_DEVICE_ID_SI_5598, pci_fixup_latency);
 
 static void __devinit pci_fixup_piix4_acpi(struct pci_dev *d)
 {
@@ -126,6 +137,7 @@
 	 */
 	d->irq = 9;
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82371AB_3, pci_fixup_piix4_acpi);
 
 /*
  * Addresses issues with problems in the memory write queue timer in
@@ -179,6 +191,10 @@
 		pci_write_config_byte(d, where, v);
 	}
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8363_0, pci_fixup_via_northbridge_bug);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8622, pci_fixup_via_northbridge_bug);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8361, pci_fixup_via_northbridge_bug);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8367_0, pci_fixup_via_northbridge_bug);
 
 /*
  * For some reasons Intel decided that certain parts of their
@@ -195,6 +211,7 @@
 	    (dev->device & 0xff00) == 0x2400)
 		dev->transparent = 1;
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, PCI_ANY_ID, pci_fixup_transparent_bridge);
 
 /*
  * Fixup for C1 Halt Disconnect problem on nForce2 systems.
@@ -236,115 +253,5 @@
 		pci_write_config_dword(dev, 0x6c, fixed_val);
 	}
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_NVIDIA, PCI_DEVICE_ID_NVIDIA_NFORCE2, pci_fixup_nforce2);
 
-struct pci_fixup pcibios_fixups[] = {
-	{
-		.pass		= PCI_FIXUP_HEADER,
-		.vendor		= PCI_VENDOR_ID_INTEL,
-		.device		= PCI_DEVICE_ID_INTEL_82451NX,
-		.hook		= pci_fixup_i450nx
-	},
-	{
-		.pass		= PCI_FIXUP_HEADER,
-		.vendor		= PCI_VENDOR_ID_INTEL,
-		.device		= PCI_DEVICE_ID_INTEL_82454GX,
-		.hook		= pci_fixup_i450gx
-	},
-	{
-		.pass		= PCI_FIXUP_HEADER,
-		.vendor		= PCI_VENDOR_ID_UMC,
-		.device		= PCI_DEVICE_ID_UMC_UM8886BF,
-		.hook		= pci_fixup_umc_ide
-	},
-	{
-		.pass		= PCI_FIXUP_HEADER,
-		.vendor		= PCI_VENDOR_ID_SI,
-		.device		= PCI_DEVICE_ID_SI_5513,
-		.hook		= pci_fixup_ide_trash
-	},
-	{
-		.pass		= PCI_FIXUP_HEADER,
-		.vendor		= PCI_ANY_ID,
-		.device		= PCI_ANY_ID,
-		.hook		= pci_fixup_ide_bases
-	},
-	{
-		.pass		= PCI_FIXUP_HEADER,
-		.vendor		= PCI_VENDOR_ID_SI,
-		.device		= PCI_DEVICE_ID_SI_5597,
-		.hook		= pci_fixup_latency
-	},
-	{
-		.pass		= PCI_FIXUP_HEADER,
-		.vendor		= PCI_VENDOR_ID_SI,
-		.device		= PCI_DEVICE_ID_SI_5598,
-		.hook		= pci_fixup_latency
-	},
- 	{
-		.pass		= PCI_FIXUP_HEADER,
-		.vendor		= PCI_VENDOR_ID_INTEL,
-		.device		= PCI_DEVICE_ID_INTEL_82371AB_3,
-		.hook		= pci_fixup_piix4_acpi
-	},
- 	{
-		.pass		= PCI_FIXUP_HEADER,
-		.vendor		= PCI_VENDOR_ID_INTEL,
-		.device		= PCI_DEVICE_ID_INTEL_82801CA_10,
-		.hook		= pci_fixup_ide_trash
-	},
- 	{
-		.pass		= PCI_FIXUP_HEADER,
-		.vendor		= PCI_VENDOR_ID_INTEL,
-		.device		= PCI_DEVICE_ID_INTEL_82801CA_11,
-		.hook		= pci_fixup_ide_trash
-	},
- 	{
-		.pass		= PCI_FIXUP_HEADER,
-		.vendor		= PCI_VENDOR_ID_INTEL,
-		.device		= PCI_DEVICE_ID_INTEL_82801DB_9,
-		.hook		= pci_fixup_ide_trash
-	},
-	{
-		.pass		= PCI_FIXUP_HEADER,
-		.vendor		= PCI_VENDOR_ID_VIA,
-		.device		= PCI_DEVICE_ID_VIA_8363_0,
-		.hook		= pci_fixup_via_northbridge_bug
-	},
-	{
-		.pass		= PCI_FIXUP_HEADER,
-		.vendor		= PCI_VENDOR_ID_VIA,
-		.device		= PCI_DEVICE_ID_VIA_8622,
-		.hook		= pci_fixup_via_northbridge_bug
-	},
-	{
-		.pass		= PCI_FIXUP_HEADER,
-		.vendor		= PCI_VENDOR_ID_VIA,
-		.device		= PCI_DEVICE_ID_VIA_8361,
-		.hook		= pci_fixup_via_northbridge_bug
-	},
-	{
-		.pass		= PCI_FIXUP_HEADER,
-		.vendor		= PCI_VENDOR_ID_VIA,
-		.device		= PCI_DEVICE_ID_VIA_8367_0,
-		.hook		= pci_fixup_via_northbridge_bug
-	},
-	{
-		.pass		= PCI_FIXUP_HEADER,
-		.vendor		= PCI_VENDOR_ID_NCR,
-		.device		= PCI_DEVICE_ID_NCR_53C810,
-		.hook		= pci_fixup_ncr53c810
-	},
-	{
-		.pass		= PCI_FIXUP_HEADER,
-		.vendor		= PCI_VENDOR_ID_INTEL,
-		.device		= PCI_ANY_ID,
-		.hook		= pci_fixup_transparent_bridge
-	},
-	{
-		.pass		= PCI_FIXUP_HEADER,
-		.vendor		= PCI_VENDOR_ID_NVIDIA,
-		.device		= PCI_DEVICE_ID_NVIDIA_NFORCE2,
-		.hook		= pci_fixup_nforce2
-	},
-	{ .pass = 0 }
-};
Index: xx-sources/arch/i386/pci/numa.c
===================================================================
--- xx-sources.orig/arch/i386/pci/numa.c	2004-08-14 01:36:32.000000000 -0400
+++ xx-sources/arch/i386/pci/numa.c	2004-08-14 13:17:24.644789856 -0400
@@ -100,10 +100,7 @@
 	}
 	pcibios_last_bus = -1;
 }
-
-struct pci_fixup pcibios_fixups[] = {
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82451NX,	pci_fixup_i450nx },
-};
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82451NX, pci_fixup_i450nx);
 
 static int __init pci_numa_init(void)
 {
Index: xx-sources/arch/i386/pci/pcbios.c
===================================================================
--- xx-sources.orig/arch/i386/pci/pcbios.c	2004-08-14 01:36:14.000000000 -0400
+++ xx-sources/arch/i386/pci/pcbios.c	2004-08-14 13:17:24.645789704 -0400
@@ -365,7 +365,7 @@
 		idx = found = 0;
 		while (pci_bios_find_device(dev->vendor, dev->device, idx, &bus, &devfn) == PCIBIOS_SUCCESSFUL) {
 			idx++;
-			for (ln=pci_devices.next; ln != &pci_devices; ln=ln->next) {
+			list_for_each(ln, &pci_devices) {
 				d = pci_dev_g(ln);
 				if (d->bus->number == bus && d->devfn == devfn) {
 					list_del(&d->global_list);
Index: xx-sources/arch/ia64/pci/pci.c
===================================================================
--- xx-sources.orig/arch/ia64/pci/pci.c	2004-08-14 01:36:57.000000000 -0400
+++ xx-sources/arch/ia64/pci/pci.c	2004-08-14 13:17:24.646789552 -0400
@@ -46,8 +46,6 @@
 #define DBG(x...)
 #endif
 
-struct pci_fixup pcibios_fixups[1];
-
 /*
  * Low-level SAL-based PCI configuration access functions. Note that SAL
  * calls are already serialized (via sal_lock), so we don't need another
Index: xx-sources/arch/m68k/kernel/bios32.c
===================================================================
--- xx-sources.orig/arch/m68k/kernel/bios32.c	2004-08-14 01:36:59.000000000 -0400
+++ xx-sources/arch/m68k/kernel/bios32.c	2004-08-14 13:17:24.647789400 -0400
@@ -77,11 +77,6 @@
 static unsigned int io_base;
 static unsigned int mem_base;
 
-struct pci_fixup pcibios_fixups[] =
-{
-	{ 0 }
-};
-
 /*
  * static void disable_dev(struct pci_dev *dev)
  *
Index: xx-sources/arch/m68knommu/kernel/comempci.c
===================================================================
--- xx-sources.orig/arch/m68knommu/kernel/comempci.c	2004-08-14 01:36:58.000000000 -0400
+++ xx-sources/arch/m68knommu/kernel/comempci.c	2004-08-14 13:17:24.649789096 -0400
@@ -351,8 +351,6 @@
 }
 /*****************************************************************************/
 
-struct pci_fixup pcibios_fixups[] = { { 0 } };
-
 void pcibios_fixup_bus(struct pci_bus *b)
 {
 }
Index: xx-sources/arch/mips/pci/fixup-atlas.c
===================================================================
--- xx-sources.orig/arch/mips/pci/fixup-atlas.c	2004-08-14 01:36:11.000000000 -0400
+++ xx-sources/arch/mips/pci/fixup-atlas.c	2004-08-14 13:17:24.650788944 -0400
@@ -60,13 +60,7 @@
 	printk ("saa9730_base = %x\n", saa9730_base);
 }
 
-#endif
-
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_PHILIPS, PCI_DEVICE_ID_PHILIPS_SAA9730,
+	atlas_saa9730_base_fixup);
 
-struct pci_fixup pcibios_fixups[] __initdata = {
-#ifdef CONFIG_KGDB
-	{PCI_FIXUP_HEADER, PCI_VENDOR_ID_PHILIPS, PCI_DEVICE_ID_PHILIPS_SAA9730,
-	 atlas_saa9730_base_fixup},
 #endif
-	{ 0 }
-};
Index: xx-sources/arch/mips/pci/fixup-au1000.c
===================================================================
--- xx-sources.orig/arch/mips/pci/fixup-au1000.c	2004-08-14 01:36:16.000000000 -0400
+++ xx-sources/arch/mips/pci/fixup-au1000.c	2004-08-14 13:17:24.651788792 -0400
@@ -102,7 +102,3 @@
 {
 return irq_tab_alchemy[slot][pin];
 }
-
-struct pci_fixup pcibios_fixups[] __initdata = {
-{ 0 }
-};
Index: xx-sources/arch/mips/pci/fixup-capcella.c
===================================================================
--- xx-sources.orig/arch/mips/pci/fixup-capcella.c	2004-08-14 01:36:56.000000000 -0400
+++ xx-sources/arch/mips/pci/fixup-capcella.c	2004-08-14 13:17:24.651788792 -0400
@@ -42,7 +42,3 @@
 {
 	return irq_tab_capcella[slot][pin];
 }
-
-struct pci_fixup pcibios_fixups[] __initdata = {
-	{	.pass = 0,	},
-};
Index: xx-sources/arch/mips/pci/fixup-cobalt.c
===================================================================
--- xx-sources.orig/arch/mips/pci/fixup-cobalt.c	2004-08-14 01:36:57.000000000 -0400
+++ xx-sources/arch/mips/pci/fixup-cobalt.c	2004-08-14 13:17:24.652788640 -0400
@@ -41,6 +41,9 @@
 	pci_write_config_byte(dev, PCI_CACHE_LINE_SIZE, 7);
 }
 
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_82C586_1,
+	 qube_raq_via_bmIDE_fixup);
+
 static void qube_raq_galileo_fixup(struct pci_dev *dev)
 {
 	unsigned short galileo_id;
@@ -73,13 +76,8 @@
 	}
 }
 
-struct pci_fixup pcibios_fixups[] __initdata = {
-	{PCI_FIXUP_HEADER, PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_82C586_1,
-	 qube_raq_via_bmIDE_fixup},
-	{PCI_FIXUP_HEADER, PCI_VENDOR_ID_GALILEO, PCI_ANY_ID,
-	 qube_raq_galileo_fixup},
-	0
-};
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_GALILEO, PCI_ANY_ID,
+	qube_raq_galileo_fixup);
 
 static char irq_tab_cobalt[] __initdata = {
   [COBALT_PCICONF_CPU]     = 0,
Index: xx-sources/arch/mips/pci/fixup-ddb5074.c
===================================================================
--- xx-sources.orig/arch/mips/pci/fixup-ddb5074.c	2004-08-14 01:36:17.000000000 -0400
+++ xx-sources/arch/mips/pci/fixup-ddb5074.c	2004-08-14 13:17:24.653788488 -0400
@@ -17,8 +17,5 @@
 	pci_write_config_byte(dev, 0x7e, t8);
 }
 
-struct pci_fixup pcibios_fixups[] __initdata = {
-	{ PCI_FIXUP_FINAL, PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M7101,
-	  ddb5074_fixup },
-	{0}
-};
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M7101,
+	ddb5074_fixup);
Index: xx-sources/arch/mips/pci/fixup-ddb5477.c
===================================================================
--- xx-sources.orig/arch/mips/pci/fixup-ddb5477.c	2004-08-14 01:36:59.000000000 -0400
+++ xx-sources/arch/mips/pci/fixup-ddb5477.c	2004-08-14 13:17:24.653788488 -0400
@@ -41,6 +41,11 @@
 	pci_write_config_byte(dev, 0x41, old | 0xd0);
 }
 
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M1533,
+	  ddb5477_fixup);
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M1535,
+	  ddb5477_fixup);
+
 /*
  * Fixup baseboard AMD chip so that tx does not underflow.
  *      bcr_18 |= 0x0800
@@ -69,12 +74,5 @@
 	outw(temp, ioaddr + PCNET32_WIO_BDP);
 }
 
-struct pci_fixup pcibios_fixups[] __initdata = {
-	{ PCI_FIXUP_FINAL, PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M1533,
-	  ddb5477_fixup },
-	{ PCI_FIXUP_FINAL, PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M1535,
-	  ddb5477_fixup },
-	{ PCI_FIXUP_FINAL, PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_LANCE,
-	  ddb5477_amd_lance_fixup },
-	{0}
-};
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_LANCE,
+          ddb5477_amd_lance_fixup);
Index: xx-sources/arch/mips/pci/fixup-ip32.c
===================================================================
--- xx-sources.orig/arch/mips/pci/fixup-ip32.c	2004-08-14 01:37:55.000000000 -0400
+++ xx-sources/arch/mips/pci/fixup-ip32.c	2004-08-14 13:17:24.654788336 -0400
@@ -44,7 +44,3 @@
 {
 	return irq_tab_mace[slot][pin];
 }
-
-struct pci_fixup pcibios_fixups[] = {
-	{0}
-};
Index: xx-sources/arch/mips/pci/fixup-jaguar.c
===================================================================
--- xx-sources.orig/arch/mips/pci/fixup-jaguar.c	2004-08-14 01:38:11.000000000 -0400
+++ xx-sources/arch/mips/pci/fixup-jaguar.c	2004-08-14 13:17:24.654788336 -0400
@@ -36,7 +36,3 @@
 return 0;
 	panic("Whooops in pcibios_map_irq");
 }
-
-struct pci_fixup pcibios_fixups[] = {
-	{0}
-};
Index: xx-sources/arch/mips/pci/fixup-lasat.c
===================================================================
--- xx-sources.orig/arch/mips/pci/fixup-lasat.c	2004-08-14 01:36:58.000000000 -0400
+++ xx-sources/arch/mips/pci/fixup-lasat.c	2004-08-14 13:17:24.655788184 -0400
@@ -4,7 +4,3 @@
 void __init pcibios_fixup_irqs(void)
 {
 }
-
-struct pci_fixup pcibios_fixups[] __initdata = {
-    { 0 }
-};
Index: xx-sources/arch/mips/pci/fixup-malta.c
===================================================================
--- xx-sources.orig/arch/mips/pci/fixup-malta.c	2004-08-14 01:36:16.000000000 -0400
+++ xx-sources/arch/mips/pci/fixup-malta.c	2004-08-14 13:17:24.656788032 -0400
@@ -79,6 +79,8 @@
 	}
 }
 
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82371AB_0,
+	 malta_piix_func0_fixup);
 
 static void __init malta_piix_func1_fixup(struct pci_dev *pdev)
 {
@@ -96,10 +98,5 @@
 	}
 }
 
-struct pci_fixup pcibios_fixups[] __initdata = {
-	{PCI_FIXUP_HEADER, PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82371AB_0,
-	 malta_piix_func0_fixup},
-	{PCI_FIXUP_HEADER, PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82371AB,
-	 malta_piix_func1_fixup},
-	{ 0 }
-};
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_82371AB,
+	malta_piix_func1_fixup);
Index: xx-sources/arch/mips/pci/fixup-mpc30x.c
===================================================================
--- xx-sources.orig/arch/mips/pci/fixup-mpc30x.c	2004-08-14 01:36:59.000000000 -0400
+++ xx-sources/arch/mips/pci/fixup-mpc30x.c	2004-08-14 13:17:24.656788032 -0400
@@ -42,7 +42,3 @@
 
 	return irq_tab_mpc30x[slot];
 }
-
-struct pci_fixup pcibios_fixups[] __initdata = {
-	{	.pass = 0,	},
-};
Index: xx-sources/arch/mips/pci/fixup-ocelot-c.c
===================================================================
--- xx-sources.orig/arch/mips/pci/fixup-ocelot-c.c	2004-08-14 01:38:11.000000000 -0400
+++ xx-sources/arch/mips/pci/fixup-ocelot-c.c	2004-08-14 13:17:24.657787880 -0400
@@ -33,7 +33,3 @@
 return 0;
 	panic("Whooops in pcibios_map_irq");
 }
-
-struct pci_fixup pcibios_fixups[] = {
-	{0}
-};
Index: xx-sources/arch/mips/pci/fixup-ocelot-g.c
===================================================================
--- xx-sources.orig/arch/mips/pci/fixup-ocelot-g.c	2004-08-14 01:36:56.000000000 -0400
+++ xx-sources/arch/mips/pci/fixup-ocelot-g.c	2004-08-14 13:17:24.657787880 -0400
@@ -29,7 +29,3 @@
 
 	return -1;
 }
-
-struct pci_fixup pcibios_fixups[] = {
-	{0}
-};
Index: xx-sources/arch/mips/pci/fixup-sni.c
===================================================================
--- xx-sources.orig/arch/mips/pci/fixup-sni.c	2004-08-14 01:36:32.000000000 -0400
+++ xx-sources/arch/mips/pci/fixup-sni.c	2004-08-14 13:17:24.658787728 -0400
@@ -82,7 +82,3 @@
 
 	return irq_tab_rm200[slot][pin];
 }
-
-struct pci_fixup pcibios_fixups[] = {
-	{0}
-};
Index: xx-sources/arch/mips/pci/fixup-tb0219.c
===================================================================
--- xx-sources.orig/arch/mips/pci/fixup-tb0219.c	2004-08-14 01:37:42.000000000 -0400
+++ xx-sources/arch/mips/pci/fixup-tb0219.c	2004-08-14 13:17:24.659787576 -0400
@@ -58,7 +58,3 @@
 
 	return irq;
 }
-
-struct pci_fixup pcibios_fixups[] __initdata = {
-	{	.pass = 0,	},
-};
Index: xx-sources/arch/mips/pci/fixup-tb0226.c
===================================================================
--- xx-sources.orig/arch/mips/pci/fixup-tb0226.c	2004-08-14 01:37:30.000000000 -0400
+++ xx-sources/arch/mips/pci/fixup-tb0226.c	2004-08-14 13:17:24.660787424 -0400
@@ -77,7 +77,3 @@
 
 	return irq;
 }
-
-struct pci_fixup pcibios_fixups[] __initdata = {
-	{	.pass = 0,	},
-};
Index: xx-sources/arch/mips/pci/fixup-yosemite.c
===================================================================
--- xx-sources.orig/arch/mips/pci/fixup-yosemite.c	2004-08-14 01:36:56.000000000 -0400
+++ xx-sources/arch/mips/pci/fixup-yosemite.c	2004-08-14 13:17:24.661787272 -0400
@@ -33,7 +33,3 @@
 
 	return 3;			/* Everything goes to one irq bit */
 }
-
-struct pci_fixup pcibios_fixups[] = {
-	{0}
-};
Index: xx-sources/arch/mips/pci/pci-ip27.c
===================================================================
--- xx-sources.orig/arch/mips/pci/pci-ip27.c	2004-08-14 01:38:09.000000000 -0400
+++ xx-sources/arch/mips/pci/pci-ip27.c	2004-08-14 13:17:24.662787120 -0400
@@ -329,6 +329,9 @@
 	pci_disable_swapping(d);
 }
 
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_SGI, PCI_DEVICE_ID_SGI_IOC3,
+	 pci_fixup_ioc3);
+
 static void __init pci_fixup_isp1020(struct pci_dev *d)
 {
 	struct bridge_controller *bc = BRIDGE_CONTROLLER(d->bus);
@@ -353,6 +356,9 @@
 	pci_enable_swapping(d);
 }
 
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP1020,
+	 pci_fixup_isp1020);
+
 static void __init pci_fixup_isp2x00(struct pci_dev *d)
 {
 	struct bridge_controller *bc = BRIDGE_CONTROLLER(d->bus);
@@ -427,14 +433,7 @@
 	/*d->resource[1].flags |= 1; */
 }
 
-struct pci_fixup pcibios_fixups[] = {
-	{PCI_FIXUP_HEADER, PCI_VENDOR_ID_SGI, PCI_DEVICE_ID_SGI_IOC3,
-	 pci_fixup_ioc3},
-	{PCI_FIXUP_HEADER, PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP1020,
-	 pci_fixup_isp1020},
-	{PCI_FIXUP_HEADER, PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP2100,
-	 pci_fixup_isp2x00},
-	{PCI_FIXUP_HEADER, PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP2200,
-	 pci_fixup_isp2x00},
-	{0}
-};
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP2100,
+	 pci_fixup_isp2x00);
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP2200,
+	 pci_fixup_isp2x00);
Index: xx-sources/arch/mips/pci/pci-sb1250.c
===================================================================
--- xx-sources.orig/arch/mips/pci/pci-sb1250.c	2004-08-14 01:36:17.000000000 -0400
+++ xx-sources/arch/mips/pci/pci-sb1250.c	2004-08-14 13:17:24.662787120 -0400
@@ -279,7 +279,3 @@
 	return 0;
 }
 arch_initcall(sb1250_pcibios_init);
-
-struct pci_fixup pcibios_fixups[] = {
-	{0}
-};
Index: xx-sources/arch/mips/pmc-sierra/yosemite/ht.c
===================================================================
--- xx-sources.orig/arch/mips/pmc-sierra/yosemite/ht.c	2004-08-14 01:36:56.000000000 -0400
+++ xx-sources/arch/mips/pmc-sierra/yosemite/ht.c	2004-08-14 13:17:24.664786816 -0400
@@ -414,11 +414,6 @@
         titan_ht_config_write_dword
 };
 
-
-struct pci_fixup pcibios_fixups[] = {
-        {0}
-};
-
 void __init pcibios_fixup_bus(struct pci_bus *c)
 {
         titan_ht_pcibios_fixup_bus(c);
Index: xx-sources/arch/parisc/kernel/pci.c
===================================================================
--- xx-sources.orig/arch/parisc/kernel/pci.c	2004-08-14 01:36:10.000000000 -0400
+++ xx-sources/arch/parisc/kernel/pci.c	2004-08-14 13:17:24.665786664 -0400
@@ -146,15 +146,6 @@
 	return str;
 }
 
-/* Used in drivers/pci/quirks.c */
-struct pci_fixup pcibios_fixups[] = { 
-#ifdef CONFIG_SUPERIO
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_NS,	PCI_DEVICE_ID_NS_87415,	superio_fixup_pci },
-#endif
-	{ 0 }
-};
-
-
 /*
  * Called by pci_set_master() - a driver interface.
  *
Index: xx-sources/arch/ppc/kernel/pci.c
===================================================================
--- xx-sources.orig/arch/ppc/kernel/pci.c	2004-08-14 01:36:57.000000000 -0400
+++ xx-sources/arch/ppc/kernel/pci.c	2004-08-14 13:17:24.667786360 -0400
@@ -45,11 +45,6 @@
 static int reparent_resources(struct resource *parent, struct resource *res);
 static void fixup_rev1_53c810(struct pci_dev* dev);
 static void fixup_cpc710_pci64(struct pci_dev* dev);
-#ifdef CONFIG_PPC_PMAC
-extern void pmac_pci_fixup_cardbus(struct pci_dev* dev);
-extern void pmac_pci_fixup_pciata(struct pci_dev* dev);
-extern void pmac_pci_fixup_k2_sata(struct pci_dev* dev);
-#endif
 #ifdef CONFIG_PPC_OF
 static u8* pci_to_OF_bus_map;
 #endif
@@ -64,20 +59,6 @@
 
 static int pci_bus_count;
 
-struct pci_fixup pcibios_fixups[] = {
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_TRIDENT,	PCI_ANY_ID,			fixup_broken_pcnet32 },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_NCR,	PCI_DEVICE_ID_NCR_53C810,	fixup_rev1_53c810 },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_IBM,	PCI_DEVICE_ID_IBM_CPC710_PCI64,	fixup_cpc710_pci64},
-	{ PCI_FIXUP_HEADER,	PCI_ANY_ID,		PCI_ANY_ID,			pcibios_fixup_resources },
-#ifdef CONFIG_PPC_PMAC
-	/* We should add per-machine fixup support in xxx_setup.c or xxx_pci.c */
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_TI,	PCI_ANY_ID,			pmac_pci_fixup_cardbus },
-	{ PCI_FIXUP_FINAL,	PCI_ANY_ID,		PCI_ANY_ID,			pmac_pci_fixup_pciata },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_SERVERWORKS, 0x0240,			pmac_pci_fixup_k2_sata },
-#endif /* CONFIG_PPC_PMAC */
- 	{ 0 }
-};
-
 static void
 fixup_rev1_53c810(struct pci_dev* dev)
 {
@@ -90,6 +71,7 @@
 		dev->class = PCI_CLASS_STORAGE_SCSI;
 	}
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_NCR,	PCI_DEVICE_ID_NCR_53C810,	fixup_rev1_53c810);
 
 static void
 fixup_broken_pcnet32(struct pci_dev* dev)
@@ -100,6 +82,7 @@
 		pci_name_device(dev);
 	}
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_TRIDENT,	PCI_ANY_ID,			fixup_broken_pcnet32);
 
 static void
 fixup_cpc710_pci64(struct pci_dev* dev)
@@ -112,6 +95,7 @@
 	dev->resource[1].start = dev->resource[1].end = 0;
 	dev->resource[1].flags = 0;
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_IBM,	PCI_DEVICE_ID_IBM_CPC710_PCI64,	fixup_cpc710_pci64);
 
 static void
 pcibios_fixup_resources(struct pci_dev *dev)
@@ -158,6 +142,7 @@
 	if (ppc_md.pcibios_fixup_resources)
 		ppc_md.pcibios_fixup_resources(dev);
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID,		PCI_ANY_ID,			pcibios_fixup_resources);
 
 void
 pcibios_resource_to_bus(struct pci_dev *dev, struct pci_bus_region *region,
Index: xx-sources/arch/ppc/platforms/pmac_pci.c
===================================================================
--- xx-sources.orig/arch/ppc/platforms/pmac_pci.c	2004-08-14 01:36:58.000000000 -0400
+++ xx-sources/arch/ppc/platforms/pmac_pci.c	2004-08-14 13:17:24.668786208 -0400
@@ -1034,6 +1034,8 @@
 	}
 }
 
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_TI, PCI_ANY_ID, pmac_pci_fixup_cardbus);
+
 void pmac_pci_fixup_pciata(struct pci_dev* dev)
 {
        u8 progif = 0;
@@ -1074,6 +1076,8 @@
 			printk(KERN_ERR "Rewrite of PROGIF failed !\n");
 	}
 }
+DECLARE_PCI_FIXUP_FINAL(PCI_ANY_ID, PCI_ANY_ID, pmac_pci_fixup_pciata);
+
 
 /*
  * Disable second function on K2-SATA, it's broken
@@ -1104,3 +1108,4 @@
 		}
 	}
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_SERVERWORKS, 0x0240, pmac_pci_fixup_k2_sata);
Index: xx-sources/arch/ppc/platforms/sbc82xx.c
===================================================================
--- xx-sources.orig/arch/ppc/platforms/sbc82xx.c	2004-08-14 01:36:32.000000000 -0400
+++ xx-sources/arch/ppc/platforms/sbc82xx.c	2004-08-14 13:17:24.669786056 -0400
@@ -20,6 +20,7 @@
 #include <linux/stddef.h>
 #include <linux/interrupt.h>
 #include <linux/irq.h>
+#include <linux/pci.h>
 
 #include <asm/mpc8260.h>
 #include <asm/machdep.h>
@@ -237,6 +238,25 @@
 }
 
 
+static void __devinit quirk_sbc8260_cardbus(struct pci_dev *pdev)
+{
+	uint32_t ctrl;
+
+	if (pdev->bus->number != 0 || pdev->devfn != PCI_DEVFN(17, 0))
+		return;
+
+	printk(KERN_INFO "Setting up CardBus controller\n");
+
+	/* Set P2CCLK bit in System Control Register */
+	pci_read_config_dword(pdev, 0x80, &ctrl);
+	ctrl |= (1<<27);
+	pci_write_config_dword(pdev, 0x80, ctrl);
+
+	/* Set MFUNC up for PCI IRQ routing via INTA and INTB, and LEDs. */
+	pci_write_config_dword(pdev, 0x8c, 0x00c01d22);
+
+}
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_TI, PCI_DEVICE_ID_TI_1420, quirk_sbc8260_cardbus);
 
 void __init
 platform_init(unsigned long r3, unsigned long r4, unsigned long r5,
Index: xx-sources/arch/ppc64/kernel/iSeries_pci.c
===================================================================
--- xx-sources.orig/arch/ppc64/kernel/iSeries_pci.c	2004-08-14 01:38:09.000000000 -0400
+++ xx-sources/arch/ppc64/kernel/iSeries_pci.c	2004-08-14 13:17:24.672785600 -0400
@@ -820,7 +820,3 @@
 	} while (CheckReturnCode("WWL", DevNode, rc) != 0);
 }
 EXPORT_SYMBOL(iSeries_Write_Long);
-
-void pcibios_name_device(struct pci_dev *dev)
-{
-}
Index: xx-sources/arch/ppc64/kernel/pSeries_pci.c
===================================================================
--- xx-sources.orig/arch/ppc64/kernel/pSeries_pci.c	2004-08-14 01:38:11.000000000 -0400
+++ xx-sources/arch/ppc64/kernel/pSeries_pci.c	2004-08-14 13:17:24.674785296 -0400
@@ -519,9 +519,9 @@
 	return 0;
 }
 
+#if 0
 void pcibios_name_device(struct pci_dev *dev)
 {
-#if 0
 	struct device_node *dn;
 
 	/*
@@ -541,8 +541,9 @@
 			}
 		}
 	}
-#endif
 }   
+DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, pcibios_name_device);
+#endif
 
 void __devinit pcibios_fixup_device_resources(struct pci_dev *dev,
 					   struct pci_bus *bus)
Index: xx-sources/arch/ppc64/kernel/pci.c
===================================================================
--- xx-sources.orig/arch/ppc64/kernel/pci.c	2004-08-14 01:37:40.000000000 -0400
+++ xx-sources/arch/ppc64/kernel/pci.c	2004-08-14 13:17:24.676784992 -0400
@@ -55,12 +55,6 @@
 unsigned long isa_io_base;	/* NULL if no ISA bus */
 unsigned long pci_io_base;
 
-void pcibios_name_device(struct pci_dev* dev);
-void pcibios_final_fixup(void);
-static void fixup_broken_pcnet32(struct pci_dev* dev);
-static void fixup_windbond_82c105(struct pci_dev* dev);
-extern void fixup_k2_sata(struct pci_dev* dev);
-
 void iSeries_pcibios_init(void);
 
 struct pci_controller *hose_head;
@@ -74,20 +68,6 @@
 /* Cached ISA bridge dev. */
 struct pci_dev *ppc64_isabridge_dev = NULL;
 
-struct pci_fixup pcibios_fixups[] = {
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_TRIDENT,		PCI_ANY_ID,
-	  fixup_broken_pcnet32 },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_WINBOND,		PCI_DEVICE_ID_WINBOND_82C105,
-	  fixup_windbond_82c105 },
-	{ PCI_FIXUP_HEADER,	PCI_ANY_ID,    			PCI_ANY_ID,
-	  pcibios_name_device },
-#ifdef CONFIG_PPC_PMAC
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_SERVERWORKS,	0x0240,
-	  fixup_k2_sata },
-#endif
-	{ 0 }
-};
-
 static void fixup_broken_pcnet32(struct pci_dev* dev)
 {
 	if ((dev->class>>8 == PCI_CLASS_NETWORK_ETHERNET)) {
@@ -96,6 +76,7 @@
 		pci_name_device(dev);
 	}
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_TRIDENT, PCI_ANY_ID, fixup_broken_pcnet32);
 
 static void fixup_windbond_82c105(struct pci_dev* dev)
 {
@@ -118,6 +99,7 @@
 			dev->resource[i].flags &= ~IORESOURCE_IO;
 	}
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_WINBOND, PCI_DEVICE_ID_WINBOND_82C105, fixup_windbond_82c105);
 
 void 
 pcibios_resource_to_bus(struct pci_dev *dev, struct pci_bus_region *region,
Index: xx-sources/arch/ppc64/kernel/pmac_pci.c
===================================================================
--- xx-sources.orig/arch/ppc64/kernel/pmac_pci.c	2004-08-14 01:37:26.000000000 -0400
+++ xx-sources/arch/ppc64/kernel/pmac_pci.c	2004-08-14 13:17:24.680784384 -0400
@@ -777,3 +777,4 @@
 		}
 	}
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_SERVERWORKS, 0x0240, fixup_k2_sata);
Index: xx-sources/arch/sh/boards/mpc1211/pci.c
===================================================================
--- xx-sources.orig/arch/sh/boards/mpc1211/pci.c	2004-08-14 01:37:39.000000000 -0400
+++ xx-sources/arch/sh/boards/mpc1211/pci.c	2004-08-14 13:17:24.681784232 -0400
@@ -176,14 +176,7 @@
 	dev->resource[4].end   = 0xf00f;
 	dev->resource[4].flags = IORESOURCE_IO;
 }
-
-
-/* Add future fixups here... */
-struct pci_fixup pcibios_fixups[] = {
-	{ PCI_FIXUP_HEADER, PCI_VENDOR_ID_AL,
-	  PCI_DEVICE_ID_AL_M5229, quirk_ali_ide_ports },
-	{ 0 }
-};
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_AL, PCI_DEVICE_ID_AL_M5229, quirk_ali_ide_ports);
 
 char * __devinit pcibios_setup(char *str)
 {
Index: xx-sources/arch/sh/boards/overdrive/galileo.c
===================================================================
--- xx-sources.orig/arch/sh/boards/overdrive/galileo.c	2004-08-14 01:36:32.000000000 -0400
+++ xx-sources/arch/sh/boards/overdrive/galileo.c	2004-08-14 13:17:24.683783928 -0400
@@ -455,13 +455,7 @@
 		}
 	}
 }
-
-
-/* Add future fixups here... */
-struct pci_fixup pcibios_fixups[] = {
-	{ PCI_FIXUP_HEADER,	PCI_ANY_ID,	PCI_ANY_ID,	pci_fixup_ide_bases },
-	{ 0 }
-};
+DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, pci_fixup_ide_bases);
 
 void __init pcibios_init(void)
 {
Index: xx-sources/arch/sh/drivers/pci/fixups-dreamcast.c
===================================================================
--- xx-sources.orig/arch/sh/drivers/pci/fixups-dreamcast.c	2004-08-14 01:38:04.000000000 -0400
+++ xx-sources/arch/sh/drivers/pci/fixups-dreamcast.c	2004-08-14 13:17:24.683783928 -0400
@@ -47,11 +47,7 @@
 	}
 }
 
-struct pci_fixup pcibios_fixups[] = {
-	{ PCI_FIXUP_HEADER, PCI_ANY_ID,
-	  PCI_ANY_ID, gapspci_fixup_resources },
-	{ 0, }
-};
+DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, gapspci_fixup_resources);
 
 void __init pcibios_fixup_bus(struct pci_bus *bus)
 {
Index: xx-sources/arch/sh/drivers/pci/pci-sh7751.c
===================================================================
--- xx-sources.orig/arch/sh/drivers/pci/pci-sh7751.c	2004-08-14 01:37:38.000000000 -0400
+++ xx-sources/arch/sh/drivers/pci/pci-sh7751.c	2004-08-14 13:17:24.684783776 -0400
@@ -177,16 +177,9 @@
 		}
 	}
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, pci_fixup_ide_bases);
 #endif
 
-/* Add future fixups here... */
-struct pci_fixup pcibios_fixups[] = {
-#if !defined(CONFIG_SH_HS7751RVOIP) && !defined(CONFIG_SH_RTS7751R2D)
-	{ PCI_FIXUP_HEADER,	PCI_ANY_ID,	PCI_ANY_ID,	pci_fixup_ide_bases },
-#endif
-	{ 0 }
-};
-
 /*
  *  Called after each bus is probed, but before its children
  *  are examined.
Index: xx-sources/arch/sh/drivers/pci/pci-st40.c
===================================================================
--- xx-sources.orig/arch/sh/drivers/pci/pci-st40.c	2004-08-14 01:37:15.000000000 -0400
+++ xx-sources/arch/sh/drivers/pci/pci-st40.c	2004-08-14 13:17:24.685783624 -0400
@@ -160,13 +160,7 @@
 		}
 	}
 }
-
-
-/* Add future fixups here... */
-struct pci_fixup pcibios_fixups[] = {
-	{ PCI_FIXUP_HEADER,	PCI_ANY_ID,	PCI_ANY_ID,	pci_fixup_ide_bases },
-	{ 0 }
-};
+DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, pci_fixup_ide_bases);
 
 int __init st40pci_init(unsigned memStart, unsigned memSize)
 {
Index: xx-sources/arch/sh64/kernel/pci_sh5.c
===================================================================
--- xx-sources.orig/arch/sh64/kernel/pci_sh5.c	2004-08-14 01:38:10.000000000 -0400
+++ xx-sources/arch/sh64/kernel/pci_sh5.c	2004-08-14 13:17:24.686783472 -0400
@@ -48,12 +48,7 @@
 		}
 	}
 }
-
-/* Add future fixups here... */
-struct pci_fixup pcibios_fixups[] = {
-	{ PCI_FIXUP_HEADER,	PCI_ANY_ID,	PCI_ANY_ID,	pci_fixup_ide_bases },
-	{ 0 }
-};
+DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID, PCI_ANY_ID, pci_fixup_ide_bases);
 
 char * __init pcibios_setup(char *str)
 {
Index: xx-sources/arch/sparc/kernel/pcic.c
===================================================================
--- xx-sources.orig/arch/sparc/kernel/pcic.c	2004-08-14 01:36:59.000000000 -0400
+++ xx-sources/arch/sparc/kernel/pcic.c	2004-08-14 13:17:24.688783168 -0400
@@ -36,10 +36,6 @@
 #include <asm/uaccess.h>
 
 
-struct pci_fixup pcibios_fixups[] = {
-	{ 0 }
-};
-
 unsigned int pcic_pin_to_irq(unsigned int pin, char *name);
 
 /*
Index: xx-sources/arch/sparc64/kernel/pci.c
===================================================================
--- xx-sources.orig/arch/sparc64/kernel/pci.c	2004-08-14 01:36:10.000000000 -0400
+++ xx-sources/arch/sparc64/kernel/pci.c	2004-08-14 13:17:24.689783016 -0400
@@ -351,10 +351,6 @@
 
 subsys_initcall(pcibios_init);
 
-struct pci_fixup pcibios_fixups[] = {
-	{ 0 }
-};
-
 void pcibios_fixup_bus(struct pci_bus *pbus)
 {
 	struct pci_pbm_info *pbm = pbus->sysdata;
Index: xx-sources/arch/v850/kernel/rte_mb_a_pci.c
===================================================================
--- xx-sources.orig/arch/v850/kernel/rte_mb_a_pci.c	2004-08-14 01:36:32.000000000 -0400
+++ xx-sources/arch/v850/kernel/rte_mb_a_pci.c	2004-08-14 13:17:24.690782864 -0400
@@ -322,8 +322,6 @@
 
 /* Stubs for things we don't use.  */
 
-struct pci_fixup pcibios_fixups[] = { { 0 } };
-
 /* Called after each bus is probed, but before its children are examined. */
 void pcibios_fixup_bus(struct pci_bus *b)
 {
Index: xx-sources/drivers/i2c/Makefile
===================================================================
--- xx-sources.orig/drivers/i2c/Makefile	2004-08-14 01:36:12.000000000 -0400
+++ xx-sources/drivers/i2c/Makefile	2004-08-14 13:17:24.691782712 -0400
@@ -7,6 +7,9 @@
 obj-$(CONFIG_I2C_SENSOR)	+= i2c-sensor.o
 obj-y				+= busses/ chips/ algos/
 
+i2c-sensor-objs := i2c-sensor-detect.o i2c-sensor-vid.o
+
+
 ifeq ($(CONFIG_I2C_DEBUG_CORE),y)
 EXTRA_CFLAGS += -DDEBUG
 endif
Index: xx-sources/drivers/i2c/algos/Kconfig
===================================================================
--- xx-sources.orig/drivers/i2c/algos/Kconfig	2004-08-14 01:37:39.000000000 -0400
+++ xx-sources/drivers/i2c/algos/Kconfig	2004-08-14 13:17:24.692782560 -0400
@@ -27,6 +27,17 @@
 	  This support is also available as a module.  If so, the module 
 	  will be called i2c-algo-pcf.
 
+config I2C_ALGOPCA
+	tristate "I2C PCA 9564 interfaces"
+	depends on I2C
+	help
+	  This allows you to use a range of I2C adapters called PCA adapters.
+	  Say Y if you own an I2C adapter belonging to this class and then say
+	  Y to the specific driver for you adapter below.
+
+	  This support is also available as a module.  If so, the module
+	  will be called i2c-algo-pca.
+
 config I2C_ALGOITE
 	tristate "ITE I2C Algorithm"
 	depends on MIPS_ITE8172 && I2C
Index: xx-sources/drivers/i2c/algos/Makefile
===================================================================
--- xx-sources.orig/drivers/i2c/algos/Makefile	2004-08-14 01:37:27.000000000 -0400
+++ xx-sources/drivers/i2c/algos/Makefile	2004-08-14 13:17:24.693782408 -0400
@@ -4,6 +4,7 @@
 
 obj-$(CONFIG_I2C_ALGOBIT)	+= i2c-algo-bit.o
 obj-$(CONFIG_I2C_ALGOPCF)	+= i2c-algo-pcf.o
+obj-$(CONFIG_I2C_ALGOPCA)	+= i2c-algo-pca.o
 obj-$(CONFIG_I2C_ALGOITE)	+= i2c-algo-ite.o
 
 ifeq ($(CONFIG_I2C_DEBUG_ALGO),y)
Index: xx-sources/drivers/i2c/algos/i2c-algo-bit.c
===================================================================
--- xx-sources.orig/drivers/i2c/algos/i2c-algo-bit.c	2004-08-14 01:36:58.000000000 -0400
+++ xx-sources/drivers/i2c/algos/i2c-algo-bit.c	2004-08-14 13:17:24.694782256 -0400
@@ -565,8 +565,8 @@
 MODULE_DESCRIPTION("I2C-Bus bit-banging algorithm");
 MODULE_LICENSE("GPL");
 
-MODULE_PARM(bit_test, "i");
-MODULE_PARM(i2c_debug,"i");
+module_param(bit_test, bool, 0);
+module_param(i2c_debug, int, S_IRUGO | S_IWUSR);
 
 MODULE_PARM_DESC(bit_test, "Test the lines of the bus to see if it is stuck");
 MODULE_PARM_DESC(i2c_debug,
Index: xx-sources/drivers/i2c/algos/i2c-algo-ite.c
===================================================================
--- xx-sources.orig/drivers/i2c/algos/i2c-algo-ite.c	2004-08-14 01:37:40.000000000 -0400
+++ xx-sources/drivers/i2c/algos/i2c-algo-ite.c	2004-08-14 13:17:24.695782104 -0400
@@ -52,21 +52,15 @@
 #define	PM_IBSR		IT8172_PCI_IO_BASE + IT_PM_DSR + 0x04 
 #define GPIO_CCR	IT8172_PCI_IO_BASE + IT_GPCCR
 
-/* ----- global defines ----------------------------------------------- */
-#define DEB(x) if (i2c_debug>=1) x
 #define DEB2(x) if (i2c_debug>=2) x
 #define DEB3(x) if (i2c_debug>=3) x /* print several statistical values*/
-#define DEBPROTO(x) if (i2c_debug>=9) x;
- 	/* debug the protocol by showing transferred bits */
 #define DEF_TIMEOUT 16
 
 
-/* ----- global variables ---------------------------------------------	*/
-
 /* module parameters:
  */
-static int i2c_debug=1;
-static int iic_test=0;	/* see if the line-setting functions work	*/
+static int i2c_debug;
+static int iic_test;	/* see if the line-setting functions work	*/
 
 /* --- setting states on the bus with the right timing: ---------------	*/
 
@@ -804,8 +798,8 @@
 MODULE_DESCRIPTION("ITE iic algorithm");
 MODULE_LICENSE("GPL");
 
-MODULE_PARM(iic_test, "i");
-MODULE_PARM(i2c_debug,"i");
+module_param(iic_test, bool, 0);
+module_param(i2c_debug, int, S_IRUGO | S_IWUSR);
 
 MODULE_PARM_DESC(iic_test, "Test if the I2C bus is available");
 MODULE_PARM_DESC(i2c_debug,
Index: xx-sources/drivers/i2c/algos/i2c-algo-pca.c
===================================================================
--- xx-sources.orig/drivers/i2c/algos/i2c-algo-pca.c	2004-05-31 17:36:38.000000000 -0400
+++ xx-sources/drivers/i2c/algos/i2c-algo-pca.c	2004-08-14 13:17:24.696781952 -0400
@@ -0,0 +1,395 @@
+/*
+ *  i2c-algo-pca.c i2c driver algorithms for PCA9564 adapters
+ *    Copyright (C) 2004 Arcom Control Systems
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/i2c.h>
+#include <linux/i2c-algo-pca.h>
+#include "i2c-algo-pca.h"
+
+#define DRIVER "i2c-algo-pca"
+
+#define DEB1(fmt, args...) do { if (i2c_debug>=1) printk(fmt, ## args); } while(0)
+#define DEB2(fmt, args...) do { if (i2c_debug>=2) printk(fmt, ## args); } while(0)
+#define DEB3(fmt, args...) do { if (i2c_debug>=3) printk(fmt, ## args); } while(0)
+
+static int i2c_debug=0;
+
+#define pca_outw(adap, reg, val) adap->write_byte(adap, reg, val)
+#define pca_inw(adap, reg) adap->read_byte(adap, reg)
+
+#define pca_status(adap) pca_inw(adap, I2C_PCA_STA)
+#define pca_clock(adap) adap->get_clock(adap)
+#define pca_own(adap) adap->get_own(adap)
+#define pca_set_con(adap, val) pca_outw(adap, I2C_PCA_CON, val)
+#define pca_get_con(adap) pca_inw(adap, I2C_PCA_CON)
+#define pca_wait(adap) adap->wait_for_interrupt(adap)
+
+/*
+ * Generate a start condition on the i2c bus.
+ *
+ * returns after the start condition has occured
+ */
+static void pca_start(struct i2c_algo_pca_data *adap)
+{
+	int sta = pca_get_con(adap);
+	DEB2("=== START\n");
+	sta |= I2C_PCA_CON_STA;
+	sta &= ~(I2C_PCA_CON_STO|I2C_PCA_CON_SI);
+	pca_set_con(adap, sta);
+	pca_wait(adap);
+}
+
+/*
+ * Generate a repeated start condition on the i2c bus
+ *
+ * return after the repeated start condition has occured
+ */
+static void pca_repeated_start(struct i2c_algo_pca_data *adap)
+{
+	int sta = pca_get_con(adap);
+	DEB2("=== REPEATED START\n");
+	sta |= I2C_PCA_CON_STA;
+	sta &= ~(I2C_PCA_CON_STO|I2C_PCA_CON_SI);
+	pca_set_con(adap, sta);
+	pca_wait(adap);
+}
+
+/*
+ * Generate a stop condition on the i2c bus
+ *
+ * returns after the stop condition has been generated
+ *
+ * STOPs do not generate an interrupt or set the SI flag, since the
+ * part returns the the idle state (0xf8). Hence we don't need to
+ * pca_wait here.
+ */
+static void pca_stop(struct i2c_algo_pca_data *adap)
+{
+	int sta = pca_get_con(adap);
+	DEB2("=== STOP\n");
+	sta |= I2C_PCA_CON_STO;
+	sta &= ~(I2C_PCA_CON_STA|I2C_PCA_CON_SI);
+	pca_set_con(adap, sta);
+}
+
+/*
+ * Send the slave address and R/W bit
+ *
+ * returns after the address has been sent
+ */
+static void pca_address(struct i2c_algo_pca_data *adap,
+			struct i2c_msg *msg)
+{
+	int sta = pca_get_con(adap);
+	int addr;
+
+	addr = ( (0x7f & msg->addr) << 1 );
+	if (msg->flags & I2C_M_RD )
+		addr |= 1;
+	DEB2("=== SLAVE ADDRESS %#04x+%c=%#04x\n",
+	     msg->addr, msg->flags & I2C_M_RD ? 'R' : 'W', addr);
+
+	pca_outw(adap, I2C_PCA_DAT, addr);
+
+	sta &= ~(I2C_PCA_CON_STO|I2C_PCA_CON_STA|I2C_PCA_CON_SI);
+	pca_set_con(adap, sta);
+
+	pca_wait(adap);
+}
+
+/*
+ * Transmit a byte.
+ *
+ * Returns after the byte has been transmitted
+ */
+static void pca_tx_byte(struct i2c_algo_pca_data *adap,
+			__u8 b)
+{
+	int sta = pca_get_con(adap);
+	DEB2("=== WRITE %#04x\n", b);
+	pca_outw(adap, I2C_PCA_DAT, b);
+
+	sta &= ~(I2C_PCA_CON_STO|I2C_PCA_CON_STA|I2C_PCA_CON_SI);
+	pca_set_con(adap, sta);
+
+	pca_wait(adap);
+}
+
+/*
+ * Receive a byte
+ *
+ * returns immediately.
+ */
+static void pca_rx_byte(struct i2c_algo_pca_data *adap,
+			__u8 *b, int ack)
+{
+	*b = pca_inw(adap, I2C_PCA_DAT);
+	DEB2("=== READ %#04x %s\n", *b, ack ? "ACK" : "NACK");
+}
+
+/*
+ * Setup ACK or NACK for next received byte and wait for it to arrive.
+ *
+ * Returns after next byte has arrived.
+ */
+static void pca_rx_ack(struct i2c_algo_pca_data *adap,
+		       int ack)
+{
+	int sta = pca_get_con(adap);
+
+	sta &= ~(I2C_PCA_CON_STO|I2C_PCA_CON_STA|I2C_PCA_CON_SI|I2C_PCA_CON_AA);
+
+	if ( ack )
+		sta |= I2C_PCA_CON_AA;
+
+	pca_set_con(adap, sta);
+	pca_wait(adap);
+}
+
+/*
+ * Reset the i2c bus / SIO
+ */
+static void pca_reset(struct i2c_algo_pca_data *adap)
+{
+	/* apparently only an external reset will do it. not a lot can be done */
+	printk(KERN_ERR DRIVER ": Haven't figured out how to do a reset yet\n");
+}
+
+static int pca_xfer(struct i2c_adapter *i2c_adap,
+                    struct i2c_msg msgs[],
+                    int num)
+{
+        struct i2c_algo_pca_data *adap = i2c_adap->algo_data;
+        struct i2c_msg *msg = NULL;
+        int curmsg;
+	int numbytes = 0;
+	int state;
+
+	state = pca_status(adap);
+	if ( state != 0xF8 ) {
+		printk(KERN_ERR DRIVER ": bus is not idle. status is %#04x\n", state );
+		/* FIXME: what to do. Force stop ? */
+		return -EREMOTEIO;
+	}
+
+	DEB1("{{{ XFER %d messages\n", num);
+
+	if (i2c_debug>=2) {
+		for (curmsg = 0; curmsg < num; curmsg++) {
+			int addr, i;
+			msg = &msgs[curmsg];
+
+			addr = (0x7f & msg->addr) ;
+
+			if (msg->flags & I2C_M_RD )
+				printk(KERN_INFO "    [%02d] RD %d bytes from %#02x [%#02x, ...]\n",
+				       curmsg, msg->len, addr, (addr<<1) | 1);
+			else {
+				printk(KERN_INFO "    [%02d] WR %d bytes to %#02x [%#02x%s",
+				       curmsg, msg->len, addr, addr<<1,
+				       msg->len == 0 ? "" : ", ");
+				for(i=0; i < msg->len; i++)
+					printk("%#04x%s", msg->buf[i], i == msg->len - 1 ? "" : ", ");
+				printk("]\n");
+			}
+		}
+	}
+
+	curmsg = 0;
+	while (curmsg < num) {
+		state = pca_status(adap);
+
+		DEB3("STATE is 0x%02x\n", state);
+		msg = &msgs[curmsg];
+
+		switch (state) {
+		case 0xf8: /* On reset or stop the bus is idle */
+			pca_start(adap);
+			break;
+
+		case 0x08: /* A START condition has been transmitted */
+		case 0x10: /* A repeated start condition has been transmitted */
+			pca_address(adap, msg);
+			break;
+
+		case 0x18: /* SLA+W has been transmitted; ACK has been received */
+		case 0x28: /* Data byte in I2CDAT has been transmitted; ACK has been received */
+			if (numbytes < msg->len) {
+				pca_tx_byte(adap, msg->buf[numbytes]);
+				numbytes++;
+				break;
+			}
+			curmsg++; numbytes = 0;
+			if (curmsg == num)
+				pca_stop(adap);
+			else
+				pca_repeated_start(adap);
+			break;
+
+		case 0x20: /* SLA+W has been transmitted; NOT ACK has been received */
+			DEB2("NOT ACK recieved after SLA+W\n");
+			pca_stop(adap);
+			return -EREMOTEIO;
+
+		case 0x40: /* SLA+R has been transmitted; ACK has been received */
+			pca_rx_ack(adap, msg->len > 1);
+			break;
+
+		case 0x50: /* Data bytes has been received; ACK has been returned */
+			if (numbytes < msg->len) {
+				pca_rx_byte(adap, &msg->buf[numbytes], 1);
+				numbytes++;
+				pca_rx_ack(adap, numbytes < msg->len - 1);
+				break;
+			}
+			curmsg++; numbytes = 0;
+			if (curmsg == num)
+				pca_stop(adap);
+			else
+				pca_repeated_start(adap);
+			break;
+
+		case 0x48: /* SLA+R has been transmitted; NOT ACK has been received */
+			DEB2("NOT ACK received after SLA+R\n");
+			pca_stop(adap);
+			return -EREMOTEIO;
+
+		case 0x30: /* Data byte in I2CDAT has been transmitted; NOT ACK has been received */
+			DEB2("NOT ACK recieved after data byte\n");
+			return -EREMOTEIO;
+
+		case 0x38: /* Arbitration lost during SLA+W, SLA+R or data bytes */
+			DEB2("Arbitration lost\n");
+			return -EREMOTEIO;
+
+		case 0x58: /* Data byte has been received; NOT ACK has been returned */
+			if ( numbytes == msg->len - 1 ) {
+				pca_rx_byte(adap, &msg->buf[numbytes], 0);
+				curmsg++; numbytes = 0;
+				if (curmsg == num)
+					pca_stop(adap);
+				else
+					pca_repeated_start(adap);
+			} else {
+				DEB2("NOT ACK sent after data byte received. "
+				     "Not final byte. numbytes %d. len %d\n",
+				     numbytes, msg->len);
+				pca_stop(adap);
+				return -EREMOTEIO;
+			}
+			break;
+		case 0x70: /* Bus error - SDA stuck low */
+			DEB2("BUS ERROR - SDA Stuck low\n");
+			pca_reset(adap);
+			return -EREMOTEIO;
+		case 0x90: /* Bus error - SCL stuck low */
+			DEB2("BUS ERROR - SCL Stuck low\n");
+			pca_reset(adap);
+			return -EREMOTEIO;
+		case 0x00: /* Bus error during master or slave mode due to illegal START or STOP condition */
+			DEB2("BUS ERROR - Illegal START or STOP\n");
+			pca_reset(adap);
+			return -EREMOTEIO;
+		default:
+			printk(KERN_ERR DRIVER ": unhandled SIO state 0x%02x\n", state);
+			break;
+		}
+
+	}
+
+	DEB1(KERN_CRIT "}}} transfered %d messages. "
+	     "status is %#04x. control is %#04x\n",
+	     num, pca_status(adap),
+	     pca_get_con(adap));
+	return curmsg;
+}
+
+static u32 pca_func(struct i2c_adapter *adap)
+{
+        return I2C_FUNC_SMBUS_EMUL;
+}
+
+static int pca_init(struct i2c_algo_pca_data *adap)
+{
+	static int freqs[] = {330,288,217,146,88,59,44,36};
+	int own, clock;
+
+	own = pca_own(adap);
+	clock = pca_clock(adap);
+	DEB1(KERN_INFO DRIVER ": own address is %#04x\n", own);
+	DEB1(KERN_INFO DRIVER ": clock freqeuncy is %dkHz\n", freqs[clock]);
+
+	pca_outw(adap, I2C_PCA_ADR, own << 1);
+
+	pca_set_con(adap, I2C_PCA_CON_ENSIO | clock);
+	udelay(500); /* 500 µs for oscilator to stabilise */
+
+	return 0;
+}
+
+static struct i2c_algorithm pca_algo = {
+	.name		= "PCA9564 algorithm",
+	.id		= I2C_ALGO_PCA,
+	.master_xfer	= pca_xfer,
+	.functionality	= pca_func,
+};
+
+/*
+ * registering functions to load algorithms at runtime
+ */
+int i2c_pca_add_bus(struct i2c_adapter *adap)
+{
+	struct i2c_algo_pca_data *pca_adap = adap->algo_data;
+	int rval;
+
+	/* register new adapter to i2c module... */
+
+	adap->id |= pca_algo.id;
+	adap->algo = &pca_algo;
+
+	adap->timeout = 100;		/* default values, should	*/
+	adap->retries = 3;		/* be replaced by defines	*/
+
+	rval = pca_init(pca_adap);
+
+	if (!rval)
+		i2c_add_adapter(adap);
+
+	return rval;
+}
+
+int i2c_pca_del_bus(struct i2c_adapter *adap)
+{
+	return i2c_del_adapter(adap);
+}
+
+EXPORT_SYMBOL(i2c_pca_add_bus);
+EXPORT_SYMBOL(i2c_pca_del_bus);
+
+MODULE_AUTHOR("Ian Campbell <icampbell@arcom.com>");
+MODULE_DESCRIPTION("I2C-Bus PCA9564 algorithm");
+MODULE_LICENSE("GPL");
+
+module_param(i2c_debug, int, 0);
Index: xx-sources/drivers/i2c/algos/i2c-algo-pca.h
===================================================================
--- xx-sources.orig/drivers/i2c/algos/i2c-algo-pca.h	2004-05-31 17:36:38.000000000 -0400
+++ xx-sources/drivers/i2c/algos/i2c-algo-pca.h	2004-08-14 13:17:24.697781800 -0400
@@ -0,0 +1,26 @@
+#ifndef I2C_PCA9564_H
+#define I2C_PCA9564_H 1
+
+#define I2C_PCA_STA		0x00 /* STATUS  Read Only  */
+#define I2C_PCA_TO		0x00 /* TIMEOUT Write Only */
+#define I2C_PCA_DAT		0x01 /* DATA    Read/Write */
+#define I2C_PCA_ADR		0x02 /* OWN ADR Read/Write */
+#define I2C_PCA_CON		0x03 /* CONTROL Read/Write */
+
+#define I2C_PCA_CON_AA		0x80 /* Assert Acknowledge */
+#define I2C_PCA_CON_ENSIO	0x40 /* Enable */
+#define I2C_PCA_CON_STA		0x20 /* Start */
+#define I2C_PCA_CON_STO		0x10 /* Stop */
+#define I2C_PCA_CON_SI		0x08 /* Serial Interrupt */
+#define I2C_PCA_CON_CR		0x07 /* Clock Rate (MASK) */
+
+#define I2C_PCA_CON_330kHz	0x00
+#define I2C_PCA_CON_288kHz	0x01
+#define I2C_PCA_CON_217kHz	0x02
+#define I2C_PCA_CON_146kHz	0x03
+#define I2C_PCA_CON_88kHz	0x04
+#define I2C_PCA_CON_59kHz	0x05
+#define I2C_PCA_CON_44kHz	0x06
+#define I2C_PCA_CON_36kHz	0x07
+
+#endif /* I2C_PCA9564_H */
Index: xx-sources/drivers/i2c/algos/i2c-algo-pcf.c
===================================================================
--- xx-sources.orig/drivers/i2c/algos/i2c-algo-pcf.c	2004-08-14 01:37:38.000000000 -0400
+++ xx-sources/drivers/i2c/algos/i2c-algo-pcf.c	2004-08-14 13:17:24.698781648 -0400
@@ -38,8 +38,6 @@
 #include "i2c-algo-pcf.h"
 
 
-/* ----- global defines ----------------------------------------------- */
-#define DEB(x) if (i2c_debug>=1) x
 #define DEB2(x) if (i2c_debug>=2) x
 #define DEB3(x) if (i2c_debug>=3) x /* print several statistical values*/
 #define DEBPROTO(x) if (i2c_debug>=9) x;
@@ -48,7 +46,7 @@
 
 /* module parameters:
  */
-static int i2c_debug=0;
+static int i2c_debug;
 
 /* --- setting states on the bus with the right timing: ---------------	*/
 
@@ -101,12 +99,6 @@
 }
 
 
-static inline void pcf_sleep(unsigned long timeout)
-{
-	schedule_timeout( timeout * HZ);
-}
-
-
 static int wait_for_pin(struct i2c_algo_pcf_data *adap, int *status) {
 
 	int timeout = DEF_TIMEOUT;
@@ -472,6 +464,6 @@
 MODULE_DESCRIPTION("I2C-Bus PCF8584 algorithm");
 MODULE_LICENSE("GPL");
 
-MODULE_PARM(i2c_debug,"i");
+module_param(i2c_debug, int, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(i2c_debug,
         "debug level - 0 off; 1 normal; 2,3 more verbose; 9 pcf-protocol");
Index: xx-sources/drivers/i2c/busses/Kconfig
===================================================================
--- xx-sources.orig/drivers/i2c/busses/Kconfig	2004-08-14 01:37:40.000000000 -0400
+++ xx-sources/drivers/i2c/busses/Kconfig	2004-08-14 13:17:24.699781496 -0400
@@ -164,6 +164,17 @@
 	  This support is also available as a module. If so, the module
 	  will be called i2c-ixp4xx.
 
+config I2C_IXP2000
+	tristate "IXP2000 GPIO-Based I2C Interface"
+	depends on I2C && ARCH_IXP2000
+	select I2C_ALGOBIT
+	help
+	  Say Y here if you have an Intel IXP2000(2400, 2800, 2850) based
+	  system and are using GPIO lines for an I2C bus.
+
+	  This support is also available as a module. If so, the module
+	  will be called i2c-ixp2000.
+
 config I2C_KEYWEST
 	tristate "Powermac Keywest I2C interface"
 	depends on I2C && PPC_PMAC
@@ -174,6 +185,18 @@
 	  This support is also available as a module.  If so, the module 
 	  will be called i2c-keywest.
 
+config I2C_MPC
+	tristate "MPC107/824x/85xx/52xx"
+	depends on I2C && FSL_OCP
+	help
+	  If you say yes to this option, support will be included for the
+	  built-in I2C interface on the MPC107/Tsi107/MPC8240/MPC8245 and
+	  MPC85xx family processors. The driver may also work on 52xx
+	  family processors, though interrupts are known not to work.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called i2c-mpc.
+
 config I2C_NFORCE2
 	tristate "Nvidia Nforce2"
 	depends on I2C && PCI && EXPERIMENTAL
@@ -396,4 +419,15 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-voodoo3.
 
+config I2C_PCA_ISA
+	tristate "PCA9564 on an ISA bus"
+	depends on I2C
+	select I2C_ALGOPCA
+	help
+	  This driver supports ISA boards using the Philips PCA 9564
+	  Parallel bus to I2C bus controller
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called i2c-pca-isa.
+
 endmenu
Index: xx-sources/drivers/i2c/busses/Makefile
===================================================================
--- xx-sources.orig/drivers/i2c/busses/Makefile	2004-08-14 01:36:14.000000000 -0400
+++ xx-sources/drivers/i2c/busses/Makefile	2004-08-14 13:17:24.700781344 -0400
@@ -15,11 +15,14 @@
 obj-$(CONFIG_I2C_IOP3XX)	+= i2c-iop3xx.o
 obj-$(CONFIG_I2C_ISA)		+= i2c-isa.o
 obj-$(CONFIG_I2C_ITE)		+= i2c-ite.o
+obj-$(CONFIG_I2C_IXP2000)	+= i2c-ixp2000.o
 obj-$(CONFIG_I2C_IXP4XX)	+= i2c-ixp4xx.o
 obj-$(CONFIG_I2C_KEYWEST)	+= i2c-keywest.o
+obj-$(CONFIG_I2C_MPC)		+= i2c-mpc.o
 obj-$(CONFIG_I2C_NFORCE2)	+= i2c-nforce2.o
 obj-$(CONFIG_I2C_PARPORT)	+= i2c-parport.o
 obj-$(CONFIG_I2C_PARPORT_LIGHT)	+= i2c-parport-light.o
+obj-$(CONFIG_I2C_PCA_ISA)	+= i2c-pca-isa.o
 obj-$(CONFIG_I2C_PIIX4)		+= i2c-piix4.o
 obj-$(CONFIG_I2C_PROSAVAGE)	+= i2c-prosavage.o
 obj-$(CONFIG_I2C_RPXLITE)	+= i2c-rpx.o
Index: xx-sources/drivers/i2c/busses/i2c-ali15x3.c
===================================================================
--- xx-sources.orig/drivers/i2c/busses/i2c-ali15x3.c	2004-08-14 01:36:58.000000000 -0400
+++ xx-sources/drivers/i2c/busses/i2c-ali15x3.c	2004-08-14 13:17:24.701781192 -0400
@@ -126,8 +126,8 @@
 
 /* If force_addr is set to anything different from 0, we forcibly enable
    the device at the given address. */
-static int force_addr = 0;
-MODULE_PARM(force_addr, "i");
+static u16 force_addr = 0;
+module_param(force_addr, ushort, 0);
 MODULE_PARM_DESC(force_addr,
 		 "Initialize the base address of the i2c controller");
 
Index: xx-sources/drivers/i2c/busses/i2c-elektor.c
===================================================================
--- xx-sources.orig/drivers/i2c/busses/i2c-elektor.c	2004-08-14 01:36:12.000000000 -0400
+++ xx-sources/drivers/i2c/busses/i2c-elektor.c	2004-08-14 13:17:24.702781040 -0400
@@ -269,11 +269,11 @@
 MODULE_DESCRIPTION("I2C-Bus adapter routines for PCF8584 ISA bus adapter");
 MODULE_LICENSE("GPL");
 
-MODULE_PARM(base, "i");
-MODULE_PARM(irq, "i");
-MODULE_PARM(clock, "i");
-MODULE_PARM(own, "i");
-MODULE_PARM(mmapped, "i");
+module_param(base, int, 0);
+module_param(irq, int, 0);
+module_param(clock, int, 0);
+module_param(own, int, 0);
+module_param(mmapped, int, 0);
 
 module_init(i2c_pcfisa_init);
 module_exit(i2c_pcfisa_exit);
Index: xx-sources/drivers/i2c/busses/i2c-i801.c
===================================================================
--- xx-sources.orig/drivers/i2c/busses/i2c-i801.c	2004-08-14 01:36:58.000000000 -0400
+++ xx-sources/drivers/i2c/busses/i2c-i801.c	2004-08-14 13:17:24.703780888 -0400
@@ -98,8 +98,8 @@
 
 /* If force_addr is set to anything different from 0, we forcibly enable
    the I801 at the given address. VERY DANGEROUS! */
-static int force_addr = 0;
-MODULE_PARM(force_addr, "i");
+static u16 force_addr;
+module_param(force_addr, ushort, 0);
 MODULE_PARM_DESC(force_addr,
 		 "Forcibly enable the I801 at the given address. "
 		 "EXTREMELY DANGEROUS!");
Index: xx-sources/drivers/i2c/busses/i2c-ibm_iic.c
===================================================================
--- xx-sources.orig/drivers/i2c/busses/i2c-ibm_iic.c	2004-08-14 01:37:27.000000000 -0400
+++ xx-sources/drivers/i2c/busses/i2c-ibm_iic.c	2004-08-14 13:17:24.704780736 -0400
@@ -50,12 +50,12 @@
 MODULE_DESCRIPTION("IBM IIC driver v" DRIVER_VERSION);
 MODULE_LICENSE("GPL");
 
-static int iic_force_poll = 0;
-MODULE_PARM(iic_force_poll, "i");
+static int iic_force_poll;
+module_param(iic_force_poll, bool, 0);
 MODULE_PARM_DESC(iic_force_poll, "Force polling mode");
 
-static int iic_force_fast = 0;
-MODULE_PARM(iic_force_fast, "i");
+static int iic_force_fast;
+module_param(iic_force_fast, bool, 0);
 MODULE_PARM_DESC(iic_fast_poll, "Force fast mode (400 kHz)");
 
 #define DBG_LEVEL 0
Index: xx-sources/drivers/i2c/busses/i2c-ite.c
===================================================================
--- xx-sources.orig/drivers/i2c/busses/i2c-ite.c	2004-08-14 01:36:32.000000000 -0400
+++ xx-sources/drivers/i2c/busses/i2c-ite.c	2004-08-14 13:17:24.705780584 -0400
@@ -54,10 +54,10 @@
 #define DEFAULT_CLOCK 0x1b0e	/* default 16MHz/(27+14) = 400KHz */
 #define DEFAULT_OWN   0x55
 
-static int base  = 0;
-static int irq   = 0;
-static int clock = 0;
-static int own   = 0;
+static int base;
+static int irq;
+static int clock;
+static int own;
 
 static struct iic_ite gpi;
 static wait_queue_head_t iic_wait;
@@ -102,14 +102,6 @@
 }
 
 
-#if 0
-static void iic_ite_sleep(unsigned long timeout)
-{
-	schedule_timeout( timeout * HZ);
-}
-#endif
-
-
 /* Put this process to sleep.  We will wake up when the
  * IIC controller interrupts.
  */
@@ -254,10 +246,10 @@
 MODULE_DESCRIPTION("I2C-Bus adapter routines for ITE IIC bus adapter");
 MODULE_LICENSE("GPL");
 
-MODULE_PARM(base, "i");
-MODULE_PARM(irq, "i");
-MODULE_PARM(clock, "i");
-MODULE_PARM(own, "i");
+module_param(base, int, 0);
+module_param(irq, int, 0);
+module_param(clock, int, 0);
+module_param(own, int, 0);
 
 
 /* Called when module is loaded or when kernel is initialized.
Index: xx-sources/drivers/i2c/busses/i2c-ixp2000.c
===================================================================
--- xx-sources.orig/drivers/i2c/busses/i2c-ixp2000.c	2004-05-31 17:36:38.000000000 -0400
+++ xx-sources/drivers/i2c/busses/i2c-ixp2000.c	2004-08-14 13:17:24.706780432 -0400
@@ -0,0 +1,171 @@
+/*
+ * drivers/i2c/busses/i2c-ixp2000.c
+ *
+ * I2C adapter for IXP2000 systems using GPIOs for I2C bus
+ *
+ * Author: Deepak Saxena <dsaxena@plexity.net>
+ * Based on IXDP2400 code by: Naeem M. Afzal <naeem.m.afzal@intel.com>
+ * Made generic by: Jeff Daly <jeffrey.daly@intel.com>
+ *
+ * Copyright (c) 2003-2004 MontaVista Software Inc.
+ *
+ * This file is licensed under  the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ *
+ * From Jeff Daly:
+ *
+ * I2C adapter driver for Intel IXDP2xxx platforms. This should work for any
+ * IXP2000 platform if it uses the HW GPIO in the same manner.  Basically,
+ * SDA and SCL GPIOs have external pullups.  Setting the respective GPIO to
+ * an input will make the signal a '1' via the pullup.  Setting them to
+ * outputs will pull them down.
+ *
+ * The GPIOs are open drain signals and are used as configuration strap inputs
+ * during power-up so there's generally a buffer on the board that needs to be
+ * 'enabled' to drive the GPIOs.
+ */
+
+#include <linux/config.h>
+#ifdef CONFIG_I2C_DEBUG_BUS
+#define DEBUG	1
+#endif
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+
+#include <asm/hardware.h>	/* Pick up IXP42000-specific bits */
+
+static inline int ixp2000_scl_pin(void *data)
+{
+	return ((struct ixp2000_i2c_pins*)data)->scl_pin;
+}
+
+static inline int ixp2000_sda_pin(void *data)
+{
+	return ((struct ixp2000_i2c_pins*)data)->sda_pin;
+}
+
+
+static void ixp2000_bit_setscl(void *data, int val)
+{
+	int i = 5000;
+
+	if (val) {
+		gpio_line_config(ixp2000_scl_pin(data), GPIO_IN);
+		while(!gpio_line_get(ixp2000_scl_pin(data)) && i--);
+	} else {
+		gpio_line_config(ixp2000_scl_pin(data), GPIO_OUT);
+	}
+}
+
+static void ixp2000_bit_setsda(void *data, int val)
+{
+	if (val) {
+		gpio_line_config(ixp2000_sda_pin(data), GPIO_IN);
+	} else {
+		gpio_line_config(ixp2000_sda_pin(data), GPIO_OUT);
+	}
+}
+
+static int ixp2000_bit_getscl(void *data)
+{
+	return gpio_line_get(ixp2000_scl_pin(data));
+}
+
+static int ixp2000_bit_getsda(void *data)
+{
+	return gpio_line_get(ixp2000_sda_pin(data));
+}
+
+struct ixp2000_i2c_data {
+	struct ixp2000_i2c_pins *gpio_pins;
+	struct i2c_adapter adapter;
+	struct i2c_algo_bit_data algo_data;
+};
+
+static int ixp2000_i2c_remove(struct device *dev)
+{
+	struct platform_device *plat_dev = to_platform_device(dev);
+	struct ixp2000_i2c_data *drv_data = dev_get_drvdata(&plat_dev->dev);
+
+	dev_set_drvdata(&plat_dev->dev, NULL);
+
+	i2c_bit_del_bus(&drv_data->adapter);
+
+	kfree(drv_data);
+
+	return 0;
+}
+
+static int ixp2000_i2c_probe(struct device *dev)
+{
+	int err;
+	struct platform_device *plat_dev = to_platform_device(dev);
+	struct ixp2000_i2c_pins *gpio = plat_dev->dev.platform_data;
+	struct ixp2000_i2c_data *drv_data =
+		kmalloc(sizeof(struct ixp2000_i2c_data), GFP_KERNEL);
+
+	if (!drv_data)
+		return -ENOMEM;
+	memzero(drv_data, sizeof(*drv_data));
+	drv_data->gpio_pins = gpio;
+
+	drv_data->algo_data.data = gpio;
+	drv_data->algo_data.setsda = ixp2000_bit_setsda;
+	drv_data->algo_data.setscl = ixp2000_bit_setscl;
+	drv_data->algo_data.getsda = ixp2000_bit_getsda;
+	drv_data->algo_data.getscl = ixp2000_bit_getscl;
+	drv_data->algo_data.udelay = 6;
+	drv_data->algo_data.mdelay = 6;
+	drv_data->algo_data.timeout = 100;
+
+	drv_data->adapter.id = I2C_HW_B_IXP2000,
+	drv_data->adapter.algo_data = &drv_data->algo_data,
+
+	drv_data->adapter.dev.parent = &plat_dev->dev;
+
+	gpio_line_config(gpio->sda_pin, GPIO_IN);
+	gpio_line_config(gpio->scl_pin, GPIO_IN);
+	gpio_line_set(gpio->scl_pin, 0);
+	gpio_line_set(gpio->sda_pin, 0);
+
+	if ((err = i2c_bit_add_bus(&drv_data->adapter)) != 0) {
+		dev_err(dev, "Could not install, error %d\n", err);
+		kfree(drv_data);
+		return err;
+	}
+
+	dev_set_drvdata(&plat_dev->dev, drv_data);
+
+	return 0;
+}
+
+static struct device_driver ixp2000_i2c_driver = {
+	.name		= "IXP2000-I2C",
+	.bus		= &platform_bus_type,
+	.probe		= ixp2000_i2c_probe,
+	.remove		= ixp2000_i2c_remove,
+};
+
+static int __init ixp2000_i2c_init(void)
+{
+	return driver_register(&ixp2000_i2c_driver);
+}
+
+static void __exit ixp2000_i2c_exit(void)
+{
+	driver_unregister(&ixp2000_i2c_driver);
+}
+
+module_init(ixp2000_i2c_init);
+module_exit(ixp2000_i2c_exit);
+
+MODULE_AUTHOR ("Deepak Saxena <dsaxena@plexity.net>");
+MODULE_DESCRIPTION("IXP2000 GPIO-based I2C bus driver");
+MODULE_LICENSE("GPL");
+
Index: xx-sources/drivers/i2c/busses/i2c-keywest.c
===================================================================
--- xx-sources.orig/drivers/i2c/busses/i2c-keywest.c	2004-08-14 01:37:26.000000000 -0400
+++ xx-sources/drivers/i2c/busses/i2c-keywest.c	2004-08-14 13:17:24.707780280 -0400
@@ -91,9 +91,9 @@
 MODULE_AUTHOR("Benjamin Herrenschmidt <benh@kernel.crashing.org>");
 MODULE_DESCRIPTION("I2C driver for Apple's Keywest");
 MODULE_LICENSE("GPL");
-MODULE_PARM(probe, "i");
+module_param(probe, bool, 0);
 
-static int probe = 0;
+static int probe;
 
 #ifdef POLLED_MODE
 /* Don't schedule, the g5 fan controller is too
@@ -662,8 +662,7 @@
 	spin_lock_irq(&iface->lock);
 	while (iface->state != state_idle) {
 		spin_unlock_irq(&iface->lock);
-		set_task_state(current,TASK_UNINTERRUPTIBLE);
-		schedule_timeout(HZ/10);
+		msleep(100);
 		spin_lock_irq(&iface->lock);
 	}
 #endif /* POLLED_MODE */
Index: xx-sources/drivers/i2c/busses/i2c-mpc.c
===================================================================
--- xx-sources.orig/drivers/i2c/busses/i2c-mpc.c	2004-05-31 17:36:38.000000000 -0400
+++ xx-sources/drivers/i2c/busses/i2c-mpc.c	2004-08-14 13:17:24.708780128 -0400
@@ -0,0 +1,392 @@
+/*
+ * (C) Copyright 2003-2004
+ * Humboldt Solutions Ltd, adrian@humboldt.co.uk.
+
+ * This is a combined i2c adapter and algorithm driver for the
+ * MPC107/Tsi107 PowerPC northbridge and processors that include
+ * the same I2C unit (8240, 8245, 85xx).
+ *
+ * Release 0.6
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2. This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <asm/io.h>
+#include <asm/ocp.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+
+#define MPC_I2C_ADDR  0x00
+#define MPC_I2C_FDR 	0x04
+#define MPC_I2C_CR	0x08
+#define MPC_I2C_SR	0x0c
+#define MPC_I2C_DR	0x10
+#define MPC_I2C_DFSRR 0x14
+#define MPC_I2C_REGION 0x20
+
+#define CCR_MEN  0x80
+#define CCR_MIEN 0x40
+#define CCR_MSTA 0x20
+#define CCR_MTX  0x10
+#define CCR_TXAK 0x08
+#define CCR_RSTA 0x04
+
+#define CSR_MCF  0x80
+#define CSR_MAAS 0x40
+#define CSR_MBB  0x20
+#define CSR_MAL  0x10
+#define CSR_SRW  0x04
+#define CSR_MIF  0x02
+#define CSR_RXAK 0x01
+
+struct mpc_i2c {
+	char *base;
+	struct ocp_def *ocpdef;
+	u32 interrupt;
+	wait_queue_head_t queue;
+	struct i2c_adapter adap;
+};
+
+static __inline__ void writeccr(struct mpc_i2c *i2c, u32 x)
+{
+	writeb(x, i2c->base + MPC_I2C_CR);
+}
+
+static irqreturn_t mpc_i2c_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct mpc_i2c *i2c = dev_id;
+	if (readb(i2c->base + MPC_I2C_SR) & CSR_MIF) {
+		/* Read again to allow register to stabilise */
+		i2c->interrupt = readb(i2c->base + MPC_I2C_SR);
+		writeb(0, i2c->base + MPC_I2C_SR);
+		wake_up_interruptible(&i2c->queue);
+	}
+	return IRQ_HANDLED;
+}
+
+static int i2c_wait(struct mpc_i2c *i2c, unsigned timeout, int writing)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	unsigned long orig_jiffies = jiffies;
+	u32 x;
+	int result = 0;
+
+	if (i2c->ocpdef->irq == OCP_IRQ_NA) {
+		while (!(readb(i2c->base + MPC_I2C_SR) & CSR_MIF)) {
+			schedule();
+			if (time_after(jiffies, orig_jiffies + timeout)) {
+				pr_debug("I2C: timeout\n");
+				result = -EIO;
+				break;
+			}
+		}
+		x = readb(i2c->base + MPC_I2C_SR);
+		writeb(0, i2c->base + MPC_I2C_SR);
+	} else {
+		add_wait_queue(&i2c->queue, &wait);
+		while (!(i2c->interrupt & CSR_MIF)) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			if (signal_pending(current)) {
+				pr_debug("I2C: Interrupted\n");
+				result = -EINTR;
+				break;
+			}
+			if (time_after(jiffies, orig_jiffies + timeout)) {
+				pr_debug("I2C: timeout\n");
+				result = -EIO;
+				break;
+			}
+			schedule_timeout(timeout);
+		}
+		current->state = TASK_RUNNING;
+		remove_wait_queue(&i2c->queue, &wait);
+		x = i2c->interrupt;
+		i2c->interrupt = 0;
+	}
+
+	if (result < -0)
+		return result;
+
+	if (!(x & CSR_MCF)) {
+		pr_debug("I2C: unfinished\n");
+		return -EIO;
+	}
+
+	if (x & CSR_MAL) {
+		pr_debug("I2C: MAL\n");
+		return -EIO;
+	}
+
+	if (writing && (x & CSR_RXAK)) {
+		pr_debug("I2C: No RXAK\n");
+		/* generate stop */
+		writeccr(i2c, CCR_MEN);
+		return -EIO;
+	}
+	return 0;
+}
+
+static void mpc_i2c_setclock(struct mpc_i2c *i2c)
+{
+	struct ocp_fs_i2c_data *i2c_data = i2c->ocpdef->additions;
+	/* Set clock and filters */
+	if (i2c_data && (i2c_data->flags & FS_I2C_SEPARATE_DFSRR)) {
+		writeb(0x31, i2c->base + MPC_I2C_FDR);
+		writeb(0x10, i2c->base + MPC_I2C_DFSRR);
+	} else if (i2c_data && (i2c_data->flags & FS_I2C_CLOCK_5200))
+		writeb(0x3f, i2c->base + MPC_I2C_FDR);
+	else
+		writel(0x1031, i2c->base + MPC_I2C_FDR);
+}
+
+static void mpc_i2c_start(struct mpc_i2c *i2c)
+{
+	/* Clear arbitration */
+	writeb(0, i2c->base + MPC_I2C_SR);
+	/* Start with MEN */
+	writeccr(i2c, CCR_MEN);
+}
+
+static void mpc_i2c_stop(struct mpc_i2c *i2c)
+{
+	writeccr(i2c, CCR_MEN);
+}
+
+static int mpc_write(struct mpc_i2c *i2c, int target,
+		     const u8 * data, int length, int restart)
+{
+	int i;
+	unsigned timeout = HZ;
+	u32 flags = restart ? CCR_RSTA : 0;
+
+	/* Start with MEN */
+	if (!restart)
+		writeccr(i2c, CCR_MEN);
+	/* Start as master */
+	writeccr(i2c, CCR_MIEN | CCR_MEN | CCR_MSTA | CCR_MTX | flags);
+	/* Write target byte */
+	writeb((target << 1), i2c->base + MPC_I2C_DR);
+
+	if (i2c_wait(i2c, timeout, 1) < 0)
+		return -1;
+
+	for (i = 0; i < length; i++) {
+		/* Write data byte */
+		writeb(data[i], i2c->base + MPC_I2C_DR);
+
+		if (i2c_wait(i2c, timeout, 1) < 0)
+			return -1;
+	}
+
+	return 0;
+}
+
+static int mpc_read(struct mpc_i2c *i2c, int target,
+		    u8 * data, int length, int restart)
+{
+	unsigned timeout = HZ;
+	int i;
+	u32 flags = restart ? CCR_RSTA : 0;
+
+	/* Start with MEN */
+	if (!restart)
+		writeccr(i2c, CCR_MEN);
+	/* Switch to read - restart */
+	writeccr(i2c, CCR_MIEN | CCR_MEN | CCR_MSTA | CCR_MTX | flags);
+	/* Write target address byte - this time with the read flag set */
+	writeb((target << 1) | 1, i2c->base + MPC_I2C_DR);
+
+	if (i2c_wait(i2c, timeout, 1) < 0)
+		return -1;
+
+	if (length) {
+		if (length == 1)
+			writeccr(i2c, CCR_MIEN | CCR_MEN | CCR_MSTA | CCR_TXAK);
+		else
+			writeccr(i2c, CCR_MIEN | CCR_MEN | CCR_MSTA);
+		/* Dummy read */
+		readb(i2c->base + MPC_I2C_DR);
+	}
+
+	for (i = 0; i < length; i++) {
+		if (i2c_wait(i2c, timeout, 0) < 0)
+			return -1;
+
+		/* Generate txack on next to last byte */
+		if (i == length - 2)
+			writeccr(i2c, CCR_MIEN | CCR_MEN | CCR_MSTA | CCR_TXAK);
+		/* Generate stop on last byte */
+		if (i == length - 1)
+			writeccr(i2c, CCR_MIEN | CCR_MEN | CCR_TXAK);
+		data[i] = readb(i2c->base + MPC_I2C_DR);
+	}
+
+	return length;
+}
+
+static int mpc_xfer(struct i2c_adapter *adap, struct i2c_msg msgs[], int num)
+{
+	struct i2c_msg *pmsg;
+	int i;
+	int ret = 0;
+	unsigned long orig_jiffies = jiffies;
+	struct mpc_i2c *i2c = i2c_get_adapdata(adap);
+
+	mpc_i2c_start(i2c);
+
+	/* Allow bus up to 1s to become not busy */
+	while (readb(i2c->base + MPC_I2C_SR) & CSR_MBB) {
+		if (signal_pending(current)) {
+			pr_debug("I2C: Interrupted\n");
+			return -EINTR;
+		}
+		if (time_after(jiffies, orig_jiffies + HZ)) {
+			pr_debug("I2C: timeout\n");
+			return -EIO;
+		}
+		schedule();
+	}
+
+	for (i = 0; ret >= 0 && i < num; i++) {
+		pmsg = &msgs[i];
+		pr_debug("Doing %s %d bytes to 0x%02x - %d of %d messages\n",
+			 pmsg->flags & I2C_M_RD ? "read" : "write",
+			 pmsg->len, pmsg->addr, i + 1, num);
+		if (pmsg->flags & I2C_M_RD)
+			ret =
+			    mpc_read(i2c, pmsg->addr, pmsg->buf, pmsg->len, i);
+		else
+			ret =
+			    mpc_write(i2c, pmsg->addr, pmsg->buf, pmsg->len, i);
+	}
+	mpc_i2c_stop(i2c);
+	return (ret < 0) ? ret : num;
+}
+
+static u32 mpc_functionality(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+}
+
+static struct i2c_algorithm mpc_algo = {
+	.name = "MPC algorithm",
+	.id = I2C_ALGO_MPC107,
+	.master_xfer = mpc_xfer,
+	.functionality = mpc_functionality,
+};
+
+static struct i2c_adapter mpc_ops = {
+	.owner = THIS_MODULE,
+	.name = "MPC adapter",
+	.id = I2C_ALGO_MPC107 | I2C_HW_MPC107,
+	.algo = &mpc_algo,
+	.class = I2C_CLASS_HWMON,
+	.timeout = 1,
+	.retries = 1
+};
+
+static int __devinit mpc_i2c_probe(struct ocp_device *ocp)
+{
+	int result = 0;
+	struct mpc_i2c *i2c;
+
+	if (!(i2c = kmalloc(sizeof(*i2c), GFP_KERNEL))) {
+		return -ENOMEM;
+	}
+	i2c->ocpdef = ocp->def;
+	init_waitqueue_head(&i2c->queue);
+
+	if (!request_mem_region(ocp->def->paddr, MPC_I2C_REGION, "i2c-mpc")) {
+		printk(KERN_ERR "i2c-mpc - resource unavailable\n");
+		return -ENODEV;
+	}
+
+	i2c->base = ioremap(ocp->def->paddr, MPC_I2C_REGION);
+
+	if (!i2c->base) {
+		printk(KERN_ERR "i2c-mpc - failed to map controller\n");
+		result = -ENOMEM;
+		goto fail_map;
+	}
+
+	if (ocp->def->irq != OCP_IRQ_NA)
+		if ((result = request_irq(ocp->def->irq, mpc_i2c_isr,
+					  0, "i2c-mpc", i2c)) < 0) {
+			printk(KERN_ERR
+			       "i2c-mpc - failed to attach interrupt\n");
+			goto fail_irq;
+		}
+
+	i2c->adap = mpc_ops;
+	i2c_set_adapdata(&i2c->adap, i2c);
+	if ((result = i2c_add_adapter(&i2c->adap)) < 0) {
+		printk(KERN_ERR "i2c-mpc - failed to add adapter\n");
+		goto fail_add;
+	}
+
+	mpc_i2c_setclock(i2c);
+	ocp_set_drvdata(ocp, i2c);
+	return result;
+
+      fail_add:
+	if (ocp->def->irq != OCP_IRQ_NA)
+		free_irq(ocp->def->irq, 0);
+      fail_irq:
+	iounmap(i2c->base);
+      fail_map:
+	release_mem_region(ocp->def->paddr, MPC_I2C_REGION);
+	kfree(i2c);
+	return result;
+}
+static void __devexit mpc_i2c_remove(struct ocp_device *ocp)
+{
+	struct mpc_i2c *i2c = ocp_get_drvdata(ocp);
+	ocp_set_drvdata(ocp, NULL);
+	i2c_del_adapter(&i2c->adap);
+
+	if (ocp->def->irq != OCP_IRQ_NA)
+		free_irq(i2c->ocpdef->irq, i2c);
+	iounmap(i2c->base);
+	release_mem_region(i2c->ocpdef->paddr, MPC_I2C_REGION);
+	kfree(i2c);
+}
+
+static struct ocp_device_id mpc_iic_ids[] __devinitdata = {
+	{.vendor = OCP_VENDOR_FREESCALE,.function = OCP_FUNC_IIC},
+	{.vendor = OCP_VENDOR_INVALID}
+};
+
+MODULE_DEVICE_TABLE(ocp, mpc_iic_ids);
+
+static struct ocp_driver mpc_iic_driver = {
+	.name = "iic",
+	.id_table = mpc_iic_ids,
+	.probe = mpc_i2c_probe,
+	.remove = __devexit_p(mpc_i2c_remove)
+};
+
+static int __init iic_init(void)
+{
+	return ocp_register_driver(&mpc_iic_driver);
+}
+
+static void __exit iic_exit(void)
+{
+	ocp_unregister_driver(&mpc_iic_driver);
+}
+
+module_init(iic_init);
+module_exit(iic_exit);
+
+MODULE_AUTHOR("Adrian Cox <adrian@humboldt.co.uk>");
+MODULE_DESCRIPTION
+    ("I2C-Bus adapter for MPC107 bridge and MPC824x/85xx/52xx processors");
+MODULE_LICENSE("GPL");
Index: xx-sources/drivers/i2c/busses/i2c-nforce2.c
===================================================================
--- xx-sources.orig/drivers/i2c/busses/i2c-nforce2.c	2004-08-14 01:36:17.000000000 -0400
+++ xx-sources/drivers/i2c/busses/i2c-nforce2.c	2004-08-14 13:17:24.709779976 -0400
@@ -244,8 +244,7 @@
 		temp = inb_p(NVIDIA_SMB_STS);
 	}
 	if (~temp & NVIDIA_SMB_STS_DONE) {
-		current->state = TASK_INTERRUPTIBLE;
-		schedule_timeout(HZ/100);
+		msleep(10);
 		temp = inb_p(NVIDIA_SMB_STS);
 	}
 
Index: xx-sources/drivers/i2c/busses/i2c-parport-light.c
===================================================================
--- xx-sources.orig/drivers/i2c/busses/i2c-parport-light.c	2004-08-14 01:37:38.000000000 -0400
+++ xx-sources/drivers/i2c/busses/i2c-parport-light.c	2004-08-14 13:17:24.710779824 -0400
@@ -36,8 +36,8 @@
 
 #define DEFAULT_BASE 0x378
 
-static int base;
-MODULE_PARM(base, "i");
+static u16 base;
+module_param(base, ushort, 0);
 MODULE_PARM_DESC(base, "Base I/O address");
 
 /* ----- Low-level parallel port access ----------------------------------- */
Index: xx-sources/drivers/i2c/busses/i2c-parport.h
===================================================================
--- xx-sources.orig/drivers/i2c/busses/i2c-parport.h	2004-08-14 01:38:09.000000000 -0400
+++ xx-sources/drivers/i2c/busses/i2c-parport.h	2004-08-14 13:17:24.711779672 -0400
@@ -83,7 +83,7 @@
 };
 
 static int type;
-MODULE_PARM(type, "i");
+module_param(type, int, 0);
 MODULE_PARM_DESC(type,
 	"Type of adapter:\n"
 	" 0 = Philips adapter\n"
Index: xx-sources/drivers/i2c/busses/i2c-pca-isa.c
===================================================================
--- xx-sources.orig/drivers/i2c/busses/i2c-pca-isa.c	2004-05-31 17:36:38.000000000 -0400
+++ xx-sources/drivers/i2c/busses/i2c-pca-isa.c	2004-08-14 13:17:24.713779368 -0400
@@ -0,0 +1,184 @@
+/*
+ *  i2c-pca-isa.c driver for PCA9564 on ISA boards
+ *    Copyright (C) 2004 Arcom Control Systems
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/wait.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-pca.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include "../algos/i2c-algo-pca.h"
+
+#define IO_SIZE 4
+
+#undef DEBUG_IO
+//#define DEBUG_IO
+
+static unsigned long base   = 0x330;
+static int irq 	  = 10;
+
+/* Data sheet recommends 59kHz for 100kHz operation due to variation
+ * in the actual clock rate */
+static int clock  = I2C_PCA_CON_59kHz;
+
+static int own    = 0x55;
+
+static wait_queue_head_t pca_wait;
+
+static int pca_isa_getown(struct i2c_algo_pca_data *adap)
+{
+	return (own);
+}
+
+static int pca_isa_getclock(struct i2c_algo_pca_data *adap)
+{
+	return (clock);
+}
+
+static void
+pca_isa_writebyte(struct i2c_algo_pca_data *adap, int reg, int val)
+{
+#ifdef DEBUG_IO
+	static char *names[] = { "T/O", "DAT", "ADR", "CON" };
+	printk("*** write %s at %#lx <= %#04x\n", names[reg], base+reg, val);
+#endif
+	outb(val, base+reg);
+}
+
+static int
+pca_isa_readbyte(struct i2c_algo_pca_data *adap, int reg)
+{
+	int res = inb(base+reg);
+#ifdef DEBUG_IO
+	{
+		static char *names[] = { "STA", "DAT", "ADR", "CON" };
+		printk("*** read  %s => %#04x\n", names[reg], res);
+	}
+#endif
+	return res;
+}
+
+static int pca_isa_waitforinterrupt(struct i2c_algo_pca_data *adap)
+{
+	int ret = 0;
+
+	if (irq > -1) {
+		ret = wait_event_interruptible(pca_wait,
+					       pca_isa_readbyte(adap, I2C_PCA_CON) & I2C_PCA_CON_SI);
+	} else {
+		while ((pca_isa_readbyte(adap, I2C_PCA_CON) & I2C_PCA_CON_SI) == 0)
+			udelay(100);
+	}
+	return ret;
+}
+
+static irqreturn_t pca_handler(int this_irq, void *dev_id, struct pt_regs *regs) {
+	wake_up_interruptible(&pca_wait);
+	return IRQ_HANDLED;
+}
+
+static struct i2c_algo_pca_data pca_isa_data = {
+	.get_own		= pca_isa_getown,
+	.get_clock		= pca_isa_getclock,
+	.write_byte		= pca_isa_writebyte,
+	.read_byte		= pca_isa_readbyte,
+	.wait_for_interrupt	= pca_isa_waitforinterrupt,
+};
+
+static struct i2c_adapter pca_isa_ops = {
+	.owner          = THIS_MODULE,
+	.id		= I2C_HW_A_ISA,
+	.algo_data	= &pca_isa_data,
+	.name		= "PCA9564 ISA Adapter",
+};
+
+static int __init pca_isa_init(void)
+{
+
+	init_waitqueue_head(&pca_wait);
+
+	printk(KERN_INFO "i2c-pca-isa: i/o base %#08lx. irq %d\n", base, irq);
+
+	if (!request_region(base, IO_SIZE, "i2c-pca-isa")) {
+		printk(KERN_ERR "i2c-pca-isa: I/O address %#08lx is in use.\n", base);
+		goto out;
+	}
+
+	if (irq > -1) {
+		if (request_irq(irq, pca_handler, 0, "i2c-pca-isa", &pca_isa_ops) < 0) {
+			printk(KERN_ERR "i2c-pca-isa: Request irq%d failed\n", irq);
+			goto out_region;
+		}
+	}
+
+	if (i2c_pca_add_bus(&pca_isa_ops) < 0) {
+		printk(KERN_ERR "i2c-pca-isa: Failed to add i2c bus\n");
+		goto out_irq;
+	}
+
+	return 0;
+
+ out_irq:
+	if (irq > -1)
+		free_irq(irq, &pca_isa_ops);
+ out_region:
+	release_region(base, IO_SIZE);
+ out:
+	return -ENODEV;
+}
+
+static void pca_isa_exit(void)
+{
+	i2c_pca_del_bus(&pca_isa_ops);
+
+	if (irq > 0) {
+		disable_irq(irq);
+		free_irq(irq, &pca_isa_ops);
+	}
+	release_region(base, IO_SIZE);
+}
+
+MODULE_AUTHOR("Ian Campbell <icampbell@arcom.com>");
+MODULE_DESCRIPTION("ISA base PCA9564 driver");
+MODULE_LICENSE("GPL");
+
+module_param(base, ulong, 0);
+MODULE_PARM_DESC(base, "I/O base address");
+
+module_param(irq, int, 0);
+MODULE_PARM_DESC(irq, "IRQ");
+module_param(clock, int, 0);
+MODULE_PARM_DESC(clock, "Clock rate as described in table 1 of PCA9564 datasheet");
+
+module_param(own, int, 0); /* the driver can't do slave mode, so there's no real point in this */
+
+module_init(pca_isa_init);
+module_exit(pca_isa_exit);
Index: xx-sources/drivers/i2c/busses/i2c-sis5595.c
===================================================================
--- xx-sources.orig/drivers/i2c/busses/i2c-sis5595.c	2004-08-14 01:36:56.000000000 -0400
+++ xx-sources/drivers/i2c/busses/i2c-sis5595.c	2004-08-14 13:17:24.715779064 -0400
@@ -124,8 +124,8 @@
 
 /* If force_addr is set to anything different from 0, we forcibly enable
    the device at the given address. */
-static int force_addr = 0;
-MODULE_PARM(force_addr, "i");
+static u16 force_addr = 0;
+module_param(force_addr, ushort, 0);
 MODULE_PARM_DESC(force_addr, "Initialize the base address of the i2c controller");
 
 static unsigned short sis5595_base = 0;
Index: xx-sources/drivers/i2c/busses/i2c-sis630.c
===================================================================
--- xx-sources.orig/drivers/i2c/busses/i2c-sis630.c	2004-08-14 01:36:44.000000000 -0400
+++ xx-sources/drivers/i2c/busses/i2c-sis630.c	2004-08-14 13:17:24.717778760 -0400
@@ -94,11 +94,11 @@
 #define SIS630_BLOCK_DATA	0x05
 
 /* insmod parameters */
-static int high_clock = 0;
-static int force = 0;
-MODULE_PARM(high_clock, "i");
+static int high_clock;
+static int force;
+module_param(high_clock, bool, 0);
 MODULE_PARM_DESC(high_clock, "Set Host Master Clock to 56KHz (default 14KHz).");
-MODULE_PARM(force, "i");
+module_param(force, bool, 0);
 MODULE_PARM_DESC(force, "Forcibly enable the SIS630. DANGEROUS!");
 
 /* acpi base address */
@@ -145,7 +145,7 @@
 	dev_dbg(&adap->dev, "saved clock 0x%02x\n", *oldclock);
 
 	/* disable timeout interrupt , set Host Master Clock to 56KHz if requested */
-	if (high_clock > 0)
+	if (high_clock)
 		sis630_write(SMB_CNT, 0x20);
 	else
 		sis630_write(SMB_CNT, (*oldclock & ~0x40));
@@ -210,7 +210,7 @@
 	 * restore old Host Master Clock if high_clock is set
 	 * and oldclock was not 56KHz
 	 */
-	if (high_clock > 0 && !(oldclock & 0x20))
+	if (high_clock && !(oldclock & 0x20))
 		sis630_write(SMB_CNT,(sis630_read(SMB_CNT) & ~0x20));
 
 	dev_dbg(&adap->dev, "SMB_CNT after clock restore 0x%02x\n", sis630_read(SMB_CNT));
@@ -401,7 +401,7 @@
 	if (dummy) {
 		pci_dev_put(dummy);
 	}
-        else if (force > 0) {
+        else if (force) {
 		dev_err(&sis630_dev->dev, "WARNING: Can't detect SIS630 compatible device, but "
 			"loading because of force option enabled\n");
  	}
@@ -464,6 +464,7 @@
 
 static struct pci_device_id sis630_ids[] __devinitdata = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_SI, PCI_DEVICE_ID_SI_503) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_SI, PCI_DEVICE_ID_SI_LPC) },
 	{ 0, }
 };
 
Index: xx-sources/drivers/i2c/busses/i2c-viapro.c
===================================================================
--- xx-sources.orig/drivers/i2c/busses/i2c-viapro.c	2004-08-14 01:37:37.000000000 -0400
+++ xx-sources/drivers/i2c/busses/i2c-viapro.c	2004-08-14 13:17:24.720778304 -0400
@@ -92,13 +92,13 @@
 /* If force is set to anything different from 0, we forcibly enable the
    VT596. DANGEROUS! */
 static int force;
-MODULE_PARM(force, "i");
+module_param(force, bool, 0);
 MODULE_PARM_DESC(force, "Forcibly enable the SMBus. DANGEROUS!");
 
 /* If force_addr is set to anything different from 0, we forcibly enable
    the VT596 at the given address. VERY DANGEROUS! */
-static int force_addr;
-MODULE_PARM(force_addr, "i");
+static u16 force_addr;
+module_param(force_addr, ushort, 0);
 MODULE_PARM_DESC(force_addr,
 		 "Forcibly enable the SMBus at the given address. "
 		 "EXTREMELY DANGEROUS!");
Index: xx-sources/drivers/i2c/busses/scx200_acb.c
===================================================================
--- xx-sources.orig/drivers/i2c/busses/scx200_acb.c	2004-08-14 01:36:57.000000000 -0400
+++ xx-sources/drivers/i2c/busses/scx200_acb.c	2004-08-14 13:17:24.723777848 -0400
@@ -32,6 +32,7 @@
 #include <linux/i2c.h>
 #include <linux/smp_lock.h>
 #include <linux/pci.h>
+#include <linux/delay.h>
 #include <asm/io.h>
 
 #include <linux/scx200.h>
@@ -44,7 +45,8 @@
 
 #define MAX_DEVICES 4
 static int base[MAX_DEVICES] = { 0x820, 0x840 };
-MODULE_PARM(base, "1-4i");
+static int num_base;
+module_param_array(base, int, num_base, 0);
 MODULE_PARM_DESC(base, "Base addresses for the ACCESS.bus controllers");
 
 #ifdef DEBUG
@@ -254,7 +256,7 @@
 			scx200_acb_machine(iface, status);
 			return;
 		}
-		schedule_timeout(HZ/100+1);
+		msleep(10);
 	}
 
 	scx200_acb_timeout(iface);
Index: xx-sources/drivers/i2c/busses/scx200_i2c.c
===================================================================
--- xx-sources.orig/drivers/i2c/busses/scx200_i2c.c	2004-08-14 01:36:57.000000000 -0400
+++ xx-sources/drivers/i2c/busses/scx200_i2c.c	2004-08-14 13:17:24.724777696 -0400
@@ -38,14 +38,14 @@
 MODULE_DESCRIPTION("NatSemi SCx200 I2C Driver");
 MODULE_LICENSE("GPL");
 
-MODULE_PARM(scl, "i");
-MODULE_PARM_DESC(scl, "GPIO line for SCL");
-MODULE_PARM(sda, "i");
-MODULE_PARM_DESC(sda, "GPIO line for SDA");
-
 static int scl = CONFIG_SCx200_I2C_SCL;
 static int sda = CONFIG_SCx200_I2C_SDA;
 
+module_param(scl, int, 0);
+MODULE_PARM_DESC(scl, "GPIO line for SCL");
+module_param(sda, int, 0);
+MODULE_PARM_DESC(sda, "GPIO line for SDA");
+
 static void scx200_i2c_setscl(void *data, int state)
 {
 	scx200_gpio_set(scl, state);
Index: xx-sources/drivers/i2c/chips/Kconfig
===================================================================
--- xx-sources.orig/drivers/i2c/chips/Kconfig	2004-08-14 01:37:14.000000000 -0400
+++ xx-sources/drivers/i2c/chips/Kconfig	2004-08-14 13:17:24.725777544 -0400
@@ -149,7 +149,7 @@
 
 config SENSORS_LM83
 	tristate "National Semiconductor LM83"
-	depends on I2C && EXPERIMENTAL
+	depends on I2C
 	select I2C_SENSOR
 	help
 	  If you say yes here you get support for National Semiconductor
@@ -191,6 +191,19 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called max1619.
 
+config SENSORS_SMSC47M1
+	tristate "SMSC LPC47M10x and compatibles"
+	depends on I2C && EXPERIMENTAL
+	select I2C_SENSOR
+	select I2C_ISA
+	help
+	  If you say yes here you get support for the integrated fan
+	  monitoring and control capabilities of the SMSC LPC47B27x,
+	  LPC47M10x, LPC47M13x and LPC47M14x chips.
+
+	  This driver can also be built as a module.  If so, the module
+	  will be called smsc47m1.
+
 config SENSORS_VIA686A
 	tristate "VIA686A"
 	depends on I2C && PCI && EXPERIMENTAL
Index: xx-sources/drivers/i2c/chips/Makefile
===================================================================
--- xx-sources.orig/drivers/i2c/chips/Makefile	2004-08-14 01:38:11.000000000 -0400
+++ xx-sources/drivers/i2c/chips/Makefile	2004-08-14 13:17:24.725777544 -0400
@@ -26,6 +26,7 @@
 obj-$(CONFIG_SENSORS_PCF8574)	+= pcf8574.o
 obj-$(CONFIG_SENSORS_PCF8591)	+= pcf8591.o
 obj-$(CONFIG_SENSORS_RTC8564)	+= rtc8564.o
+obj-$(CONFIG_SENSORS_SMSC47M1)	+= smsc47m1.o
 obj-$(CONFIG_SENSORS_VIA686A)	+= via686a.o
 obj-$(CONFIG_SENSORS_W83L785TS)	+= w83l785ts.o
 
Index: xx-sources/drivers/i2c/chips/adm1021.c
===================================================================
--- xx-sources.orig/drivers/i2c/chips/adm1021.c	2004-08-14 01:36:12.000000000 -0400
+++ xx-sources/drivers/i2c/chips/adm1021.c	2004-08-14 13:17:24.726777392 -0400
@@ -418,7 +418,7 @@
 MODULE_DESCRIPTION("adm1021 driver");
 MODULE_LICENSE("GPL");
 
-MODULE_PARM(read_only, "i");
+module_param(read_only, bool, 0);
 MODULE_PARM_DESC(read_only, "Don't set any values, read only mode");
 
 module_init(sensors_adm1021_init)
Index: xx-sources/drivers/i2c/chips/adm1025.c
===================================================================
--- xx-sources.orig/drivers/i2c/chips/adm1025.c	2004-08-14 01:36:10.000000000 -0400
+++ xx-sources/drivers/i2c/chips/adm1025.c	2004-08-14 13:17:24.727777240 -0400
@@ -455,7 +455,7 @@
 	struct adm1025_data *data = i2c_get_clientdata(client);
 	int i;
 
-	data->vrm = 82;
+	data->vrm = i2c_which_vrm();
 
 	/*
 	 * Set high limits
Index: xx-sources/drivers/i2c/chips/asb100.c
===================================================================
--- xx-sources.orig/drivers/i2c/chips/asb100.c	2004-08-14 01:36:59.000000000 -0400
+++ xx-sources/drivers/i2c/chips/asb100.c	2004-08-14 13:17:24.729776936 -0400
@@ -63,9 +63,6 @@
 static unsigned int normal_isa[] = { I2C_CLIENT_ISA_END };
 static unsigned int normal_isa_range[] = { I2C_CLIENT_ISA_END };
 
-/* default VRM to 9.0 instead of 8.2 */
-#define ASB100_DEFAULT_VRM 90
-
 /* Insmod parameters */
 SENSORS_INSMOD_1(asb100);
 I2C_CLIENT_MODULE_PARM(force_subclients, "List of subclient addresses: "
@@ -959,7 +956,7 @@
 
 	vid = asb100_read_value(client, ASB100_REG_VID_FANDIV) & 0x0f;
 	vid |= (asb100_read_value(client, ASB100_REG_CHIPID) & 0x01) << 4;
-	data->vrm = ASB100_DEFAULT_VRM;
+	data->vrm = i2c_which_vrm();
 	vid = vid_from_reg(vid, data->vrm);
 
 	/* Start monitoring */
Index: xx-sources/drivers/i2c/chips/ds1621.c
===================================================================
--- xx-sources.orig/drivers/i2c/chips/ds1621.c	2004-08-14 01:38:09.000000000 -0400
+++ xx-sources/drivers/i2c/chips/ds1621.c	2004-08-14 13:17:24.730776784 -0400
@@ -37,7 +37,7 @@
 /* Insmod parameters */
 SENSORS_INSMOD_1(ds1621);
 static int polarity = -1;
-MODULE_PARM(polarity, "i");
+module_param(polarity, int, 0);
 MODULE_PARM_DESC(polarity, "Output's polarity: 0 = active high, 1 = active low");
 
 /* Many DS1621 constants specified below */
Index: xx-sources/drivers/i2c/chips/eeprom.c
===================================================================
--- xx-sources.orig/drivers/i2c/chips/eeprom.c	2004-08-14 01:36:47.000000000 -0400
+++ xx-sources/drivers/i2c/chips/eeprom.c	2004-08-14 13:17:24.731776632 -0400
@@ -45,7 +45,7 @@
 SENSORS_INSMOD_1(eeprom);
 
 static int checksum = 0;
-MODULE_PARM(checksum, "i");
+module_param(checksum, bool, 0);
 MODULE_PARM_DESC(checksum, "Only accept eeproms whose checksum is correct");
 
 
Index: xx-sources/drivers/i2c/chips/it87.c
===================================================================
--- xx-sources.orig/drivers/i2c/chips/it87.c	2004-08-14 01:37:38.000000000 -0400
+++ xx-sources/drivers/i2c/chips/it87.c	2004-08-14 13:17:24.733776328 -0400
@@ -37,6 +37,7 @@
 #include <linux/slab.h>
 #include <linux/i2c.h>
 #include <linux/i2c-sensor.h>
+#include <linux/i2c-vid.h>
 #include <asm/io.h>
 
 
@@ -47,7 +48,7 @@
 static unsigned int normal_isa_range[] = { I2C_CLIENT_ISA_END };
 
 /* Insmod parameters */
-SENSORS_INSMOD_1(it87);
+SENSORS_INSMOD_2(it87, it8712);
 
 #define	REG	0x2e	/* The register to read/write */
 #define	DEV	0x07	/* Register: Logical device select */
@@ -163,8 +164,6 @@
 					((val)+500)/1000),-128,127))
 #define TEMP_FROM_REG(val) (((val)>0x80?(val)-0x100:(val))*1000)
 
-#define VID_FROM_REG(val) ((val)==0x1f?0:(val)>=0x10?510-(val)*10:\
-				205-(val)*5)
 #define ALARMS_FROM_REG(val) (val)
 
 static int DIV_TO_REG(int val)
@@ -201,6 +200,7 @@
 	u8 sensor;		/* Register value */
 	u8 fan_div[3];		/* Register encoding, shifted right */
 	u8 vid;			/* Register encoding, combined */
+	int vrm;
 	u32 alarms;		/* Register encoding, combined */
 };
 
@@ -543,6 +543,38 @@
 }
 static DEVICE_ATTR(alarms, S_IRUGO | S_IWUSR, show_alarms, NULL);
 
+static ssize_t
+show_vrm_reg(struct device *dev, char *buf)
+{
+	struct it87_data *data = it87_update_device(dev);
+	return sprintf(buf, "%ld\n", (long) data->vrm);
+}
+static ssize_t
+store_vrm_reg(struct device *dev, const char *buf, size_t count)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct it87_data *data = i2c_get_clientdata(client);
+	u32 val;
+
+	val = simple_strtoul(buf, NULL, 10);
+	data->vrm = val;
+
+	return count;
+}
+static DEVICE_ATTR(vrm, S_IRUGO | S_IWUSR, show_vrm_reg, store_vrm_reg);
+#define device_create_file_vrm(client) \
+device_create_file(&client->dev, &dev_attr_vrm)
+
+static ssize_t
+show_vid_reg(struct device *dev, char *buf)
+{
+	struct it87_data *data = it87_update_device(dev);
+	return sprintf(buf, "%ld\n", (long) vid_from_reg(data->vid, data->vrm));
+}
+static DEVICE_ATTR(in0_ref, S_IRUGO, show_vid_reg, NULL);
+#define device_create_file_vid(client) \
+device_create_file(&client->dev, &dev_attr_in0_ref)
+
 /* This function is called when:
      * it87_driver is inserted (when this module is loaded), for each
        available adapter
@@ -659,7 +691,11 @@
 	if (kind <= 0) {
 		i = it87_read_value(new_client, IT87_REG_CHIPID);
 		if (i == 0x90) {
+			u16 val;
 			kind = it87;
+			val = (superio_inb(DEVID) << 8) |
+			superio_inb(DEVID + 1);
+			if (val == IT8712F_DEVID) kind = it8712;
 		}
 		else {
 			if (kind == 0)
@@ -674,6 +710,8 @@
 
 	if (kind == it87) {
 		name = "it87";
+	} else if (kind == it8712) {
+		name = "it8712";
 	}
 
 	/* Fill in the remaining client fields and put it into the global list */
@@ -741,6 +779,12 @@
 	device_create_file(&new_client->dev, &dev_attr_fan3_div);
 	device_create_file(&new_client->dev, &dev_attr_alarms);
 
+	if (data->type == it8712) {
+		device_create_file_vrm(new_client);
+		device_create_file_vid(new_client);
+		data->vrm = i2c_which_vrm();
+	}
+
 	return 0;
 
 ERROR2:
@@ -910,7 +954,11 @@
 			(it87_read_value(client, IT87_REG_ALARM3) << 16);
 
 		data->sensor = it87_read_value(client, IT87_REG_TEMP_ENABLE);
-
+		/* The 8705 does not have VID capability */
+		if (data->type == it8712) {
+			data->vid = it87_read_value(client, IT87_REG_VID);
+			data->vid &= 0x1f;
+		}
 		data->last_updated = jiffies;
 		data->valid = 1;
 	}
@@ -938,9 +986,9 @@
 
 MODULE_AUTHOR("Chris Gauthron <chrisg@0-in.com>");
 MODULE_DESCRIPTION("IT8705F, IT8712F, Sis950 driver");
-MODULE_PARM(update_vbat, "i");
+module_param(update_vbat, bool, 0);
 MODULE_PARM_DESC(update_vbat, "Update vbat if set else return powerup value");
-MODULE_PARM(reset, "i");
+module_param(reset, bool, 0);
 MODULE_PARM_DESC(reset, "Reset the chip's registers, default no");
 MODULE_LICENSE("GPL");
 
Index: xx-sources/drivers/i2c/chips/lm83.c
===================================================================
--- xx-sources.orig/drivers/i2c/chips/lm83.c	2004-08-14 01:36:56.000000000 -0400
+++ xx-sources/drivers/i2c/chips/lm83.c	2004-08-14 13:17:24.736775872 -0400
@@ -83,8 +83,10 @@
  * The LM83 uses signed 8-bit values.
  */
 
-#define TEMP_FROM_REG(val)	((val > 127 ? val-256 : val) * 1000)
-#define TEMP_TO_REG(val)	((val < 0 ? val+256 : val) / 1000)
+#define TEMP_FROM_REG(val)	(((val) > 127 ? (val) - 0x100 : (val)) * 1000)
+#define TEMP_TO_REG(val)	((val) <= -50000 ? -50 + 0x100 : (val) >= 127000 ? 127 : \
+				 (val) > -500 ? ((val)+500) / 1000 : \
+				 ((val)-500) / 1000 + 0x100)
 
 static const u8 LM83_REG_R_TEMP[] = {
 	LM83_REG_R_LOCAL_TEMP,
@@ -178,7 +180,7 @@
 { \
 	struct i2c_client *client = to_i2c_client(dev); \
 	struct lm83_data *data = i2c_get_clientdata(client); \
-	data->value = TEMP_TO_REG(simple_strtoul(buf, NULL, 10)); \
+	data->value = TEMP_TO_REG(simple_strtol(buf, NULL, 10)); \
 	i2c_smbus_write_byte_data(client, reg, data->value); \
 	return count; \
 }
@@ -206,8 +208,11 @@
     set_temp_high3);
 static DEVICE_ATTR(temp4_max, S_IWUSR | S_IRUGO, show_temp_high4,
     set_temp_high4);
-static DEVICE_ATTR(temp_crit, S_IWUSR | S_IRUGO, show_temp_crit,
+static DEVICE_ATTR(temp1_crit, S_IRUGO, show_temp_crit, NULL);
+static DEVICE_ATTR(temp2_crit, S_IRUGO, show_temp_crit, NULL);
+static DEVICE_ATTR(temp3_crit, S_IWUSR | S_IRUGO, show_temp_crit,
     set_temp_crit);
+static DEVICE_ATTR(temp4_crit, S_IRUGO, show_temp_crit, NULL);
 static DEVICE_ATTR(alarms, S_IRUGO, show_alarms, NULL);
 
 /*
@@ -259,6 +264,11 @@
 	 * means that the driver was loaded with the force parameter and a
 	 * given kind of chip is requested, so both the detection and the
 	 * identification steps are skipped. */
+
+	/* Default to an LM83 if forced */
+	if (kind == 0)
+		kind = lm83;
+
 	if (kind < 0) { /* detection */
 		if (((i2c_smbus_read_byte_data(new_client, LM83_REG_R_STATUS1)
 		    & 0xA8) != 0x00) ||
@@ -322,7 +332,10 @@
 	device_create_file(&new_client->dev, &dev_attr_temp2_max);
 	device_create_file(&new_client->dev, &dev_attr_temp3_max);
 	device_create_file(&new_client->dev, &dev_attr_temp4_max);
-	device_create_file(&new_client->dev, &dev_attr_temp_crit);
+	device_create_file(&new_client->dev, &dev_attr_temp1_crit);
+	device_create_file(&new_client->dev, &dev_attr_temp2_crit);
+	device_create_file(&new_client->dev, &dev_attr_temp3_crit);
+	device_create_file(&new_client->dev, &dev_attr_temp4_crit);
 	device_create_file(&new_client->dev, &dev_attr_alarms);
 
 	return 0;
Index: xx-sources/drivers/i2c/chips/lm85.c
===================================================================
--- xx-sources.orig/drivers/i2c/chips/lm85.c	2004-08-14 01:36:45.000000000 -0400
+++ xx-sources/drivers/i2c/chips/lm85.c	2004-08-14 13:17:24.737775720 -0400
@@ -308,9 +308,6 @@
  * version of the driver.
  */
 
-/* Typically used with Pentium 4 systems v9.1 VRM spec */
-#define LM85_INIT_VRM  91
-
 /* Chip sampling rates
  *
  * Some sensors are not updated more frequently than once per second
@@ -832,7 +829,7 @@
 		goto ERROR1;
 
 	/* Set the VRM version */
-	data->vrm = LM85_INIT_VRM ;
+	data->vrm = i2c_which_vrm();
 
 	/* Initialize the LM85 chip */
 	lm85_init_client(new_client);
Index: xx-sources/drivers/i2c/chips/pcf8591.c
===================================================================
--- xx-sources.orig/drivers/i2c/chips/pcf8591.c	2004-08-14 01:38:11.000000000 -0400
+++ xx-sources/drivers/i2c/chips/pcf8591.c	2004-08-14 13:17:24.738775568 -0400
@@ -36,7 +36,7 @@
 SENSORS_INSMOD_1(pcf8591);
 
 static int input_mode;
-MODULE_PARM(input_mode, "i");
+module_param(input_mode, int, 0);
 MODULE_PARM_DESC(input_mode,
 	"Analog input mode:\n"
 	" 0 = four single ended inputs\n"
Index: xx-sources/drivers/i2c/chips/rtc8564.c
===================================================================
--- xx-sources.orig/drivers/i2c/chips/rtc8564.c	2004-08-14 01:36:11.000000000 -0400
+++ xx-sources/drivers/i2c/chips/rtc8564.c	2004-08-14 13:17:24.739775416 -0400
@@ -56,8 +56,8 @@
 #define BCD_TO_BIN(val) (((val)&15) + ((val)>>4)*10)
 #define BIN_TO_BCD(val) ((((val)/10)<<4) + (val)%10)
 
-static int debug = 0;
-MODULE_PARM(debug, "i");
+static int debug;;
+module_param(debug, int, S_IRUGO | S_IWUSR);
 
 static struct i2c_driver rtc8564_driver;
 
Index: xx-sources/drivers/i2c/chips/smsc47m1.c
===================================================================
--- xx-sources.orig/drivers/i2c/chips/smsc47m1.c	2004-05-31 17:36:38.000000000 -0400
+++ xx-sources/drivers/i2c/chips/smsc47m1.c	2004-08-14 13:17:24.740775264 -0400
@@ -0,0 +1,579 @@
+/*
+    smsc47m1.c - Part of lm_sensors, Linux kernel modules
+                 for hardware monitoring
+
+    Supports the SMSC LPC47B27x, LPC47M10x, LPC47M13x and LPC47M14x
+    Super-I/O chips.
+
+    Copyright (C) 2002 Mark D. Studebaker <mdsxyz123@yahoo.com>
+    Copyright (C) 2004 Jean Delvare <khali@linux-fr.org>
+    Ported to Linux 2.6 by Gabriele Gorla <gorlik@yahoo.com>
+                        and Jean Delvare
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/i2c.h>
+#include <linux/i2c-sensor.h>
+#include <linux/init.h>
+#include <asm/io.h>
+
+static unsigned short normal_i2c[] = { I2C_CLIENT_END };
+static unsigned short normal_i2c_range[] = { I2C_CLIENT_END };
+/* Address is autodetected, there is no default value */
+static unsigned int normal_isa[] = { 0x0000, I2C_CLIENT_ISA_END };
+static unsigned int normal_isa_range[] = { I2C_CLIENT_ISA_END };
+static struct i2c_force_data forces[] = {{NULL}};
+
+enum chips { any_chip, smsc47m1 };
+static struct i2c_address_data addr_data = {
+	.normal_i2c		= normal_i2c,
+	.normal_i2c_range	= normal_i2c_range,
+	.normal_isa		= normal_isa,
+	.normal_isa_range	= normal_isa_range,
+	.probe			= normal_i2c,		/* cheat */
+	.probe_range		= normal_i2c_range,	/* cheat */
+	.ignore			= normal_i2c,		/* cheat */
+	.ignore_range		= normal_i2c_range,	/* cheat */
+	.forces			= forces,
+};
+
+/* Super-I/0 registers and commands */
+
+#define	REG	0x2e	/* The register to read/write */
+#define	VAL	0x2f	/* The value to read/write */
+
+static inline void
+superio_outb(int reg, int val)
+{
+	outb(reg, REG);
+	outb(val, VAL);
+}
+
+static inline int
+superio_inb(int reg)
+{
+	outb(reg, REG);
+	return inb(VAL);
+}
+
+/* logical device for fans is 0x0A */
+#define superio_select() superio_outb(0x07, 0x0A)
+
+static inline void
+superio_enter(void)
+{
+	outb(0x55, REG);
+}
+
+static inline void
+superio_exit(void)
+{
+	outb(0xAA, REG);
+}
+
+#define SUPERIO_REG_ACT		0x30
+#define SUPERIO_REG_BASE	0x60
+#define SUPERIO_REG_DEVID	0x20
+
+/* Logical device registers */
+
+#define SMSC_EXTENT		0x80
+
+/* nr is 0 or 1 in the macros below */
+#define SMSC47M1_REG_ALARM		0x04
+#define SMSC47M1_REG_TPIN(nr)		(0x34 - (nr))
+#define SMSC47M1_REG_PPIN(nr)		(0x36 - (nr))
+#define SMSC47M1_REG_PWM(nr)		(0x56 + (nr))
+#define SMSC47M1_REG_FANDIV		0x58
+#define SMSC47M1_REG_FAN(nr)		(0x59 + (nr))
+#define SMSC47M1_REG_FAN_PRELOAD(nr)	(0x5B + (nr))
+
+#define MIN_FROM_REG(reg,div)		((reg)>=192 ? 0 : \
+					 983040/((192-(reg))*(div)))
+#define FAN_FROM_REG(reg,div,preload)	((reg)<=(preload) || (reg)==255 ? 0 : \
+					 983040/(((reg)-(preload))*(div)))
+#define DIV_FROM_REG(reg)		(1 << (reg))
+#define PWM_FROM_REG(reg)		(((reg) & 0x7E) << 1)
+#define PWM_EN_FROM_REG(reg)		((~(reg)) & 0x01)
+#define PWM_TO_REG(reg)			(((reg) >> 1) & 0x7E)
+
+struct smsc47m1_data {
+	struct i2c_client client;
+	struct semaphore lock;
+	int sysctl_id;
+
+	struct semaphore update_lock;
+	unsigned long last_updated;	/* In jiffies */
+
+	u8 fan[2];		/* Register value */
+	u8 fan_preload[2];	/* Register value */
+	u8 fan_div[2];		/* Register encoding, shifted right */
+	u8 alarms;		/* Register encoding */
+	u8 pwm[2];		/* Register value (bit 7 is enable) */
+};
+
+
+static int smsc47m1_attach_adapter(struct i2c_adapter *adapter);
+static int smsc47m1_find(int *address);
+static int smsc47m1_detect(struct i2c_adapter *adapter, int address, int kind);
+static int smsc47m1_detach_client(struct i2c_client *client);
+
+static int smsc47m1_read_value(struct i2c_client *client, u8 reg);
+static void smsc47m1_write_value(struct i2c_client *client, u8 reg, u8 value);
+
+static struct smsc47m1_data *smsc47m1_update_device(struct device *dev,
+		int init);
+
+
+static int smsc47m1_id;
+
+static struct i2c_driver smsc47m1_driver = {
+	.owner		= THIS_MODULE,
+	.name		= "smsc47m1",
+	.id		= I2C_DRIVERID_SMSC47M1,
+	.flags		= I2C_DF_NOTIFY,
+	.attach_adapter	= smsc47m1_attach_adapter,
+	.detach_client	= smsc47m1_detach_client,
+};
+
+/* nr is 0 or 1 in the callback functions below */
+
+static ssize_t get_fan(struct device *dev, char *buf, int nr)
+{
+	struct smsc47m1_data *data = smsc47m1_update_device(dev, 0);
+	/* This chip (stupidly) stops monitoring fan speed if PWM is
+	   enabled and duty cycle is 0%. This is fine if the monitoring
+	   and control concern the same fan, but troublesome if they are
+	   not (which could as well happen). */
+	int rpm = (data->pwm[nr] & 0x7F) == 0x00 ? 0 :
+		  FAN_FROM_REG(data->fan[nr],
+			       DIV_FROM_REG(data->fan_div[nr]),
+			       data->fan_preload[nr]);
+	return sprintf(buf, "%d\n", rpm);
+}
+
+static ssize_t get_fan_min(struct device *dev, char *buf, int nr)
+{
+	struct smsc47m1_data *data = smsc47m1_update_device(dev, 0);
+	int rpm = MIN_FROM_REG(data->fan_preload[nr],
+			       DIV_FROM_REG(data->fan_div[nr]));
+	return sprintf(buf, "%d\n", rpm);
+}
+
+static ssize_t get_fan_div(struct device *dev, char *buf, int nr)
+{
+	struct smsc47m1_data *data = smsc47m1_update_device(dev, 0);
+	return sprintf(buf, "%d\n", DIV_FROM_REG(data->fan_div[nr]));
+}
+
+static ssize_t get_fan_pwm(struct device *dev, char *buf, int nr)
+{
+	struct smsc47m1_data *data = smsc47m1_update_device(dev, 0);
+	return sprintf(buf, "%d\n", PWM_FROM_REG(data->pwm[nr]));
+}
+
+static ssize_t get_fan_pwm_en(struct device *dev, char *buf, int nr)
+{
+	struct smsc47m1_data *data = smsc47m1_update_device(dev, 0);
+	return sprintf(buf, "%d\n", PWM_EN_FROM_REG(data->pwm[nr]));
+}
+
+static ssize_t get_alarms(struct device *dev, char *buf)
+{
+	struct smsc47m1_data *data = smsc47m1_update_device(dev, 0);
+	return sprintf(buf, "%d\n", data->alarms);
+}
+
+static ssize_t set_fan_min(struct device *dev, const char *buf,
+		size_t count, int nr)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct smsc47m1_data *data = i2c_get_clientdata(client);
+
+	long rpmdiv = simple_strtol(buf, NULL, 10)
+		    * DIV_FROM_REG(data->fan_div[nr]);
+
+	if (983040 > 192 * rpmdiv || 2 * rpmdiv > 983040)
+		return -EINVAL;
+
+	data->fan_preload[nr] = 192 - ((983040 + rpmdiv / 2) / rpmdiv);
+	smsc47m1_write_value(client, SMSC47M1_REG_FAN_PRELOAD(nr),
+			     data->fan_preload[nr]);
+
+	return count;
+}
+
+/* Note: we save and restore the fan minimum here, because its value is
+   determined in part by the fan clock divider.  This follows the principle
+   of least suprise; the user doesn't expect the fan minimum to change just
+   because the divider changed. */
+static ssize_t set_fan_div(struct device *dev, const char *buf,
+		size_t count, int nr)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct smsc47m1_data *data = i2c_get_clientdata(client);
+
+	long new_div = simple_strtol(buf, NULL, 10), tmp;
+	u8 old_div = DIV_FROM_REG(data->fan_div[nr]);
+
+	if (new_div == old_div) /* No change */
+		return count;
+	switch (new_div) {
+	case 1: data->fan_div[nr] = 0; break;
+	case 2: data->fan_div[nr] = 1; break;
+	case 4: data->fan_div[nr] = 2; break;
+	case 8: data->fan_div[nr] = 3; break;
+	default: return -EINVAL;
+	}
+
+	tmp = smsc47m1_read_value(client, SMSC47M1_REG_FANDIV) & 0x0F;
+	tmp |= (data->fan_div[0] << 4) | (data->fan_div[1] << 6);
+	smsc47m1_write_value(client, SMSC47M1_REG_FANDIV, tmp);
+
+	/* Preserve fan min */
+	tmp = 192 - (old_div * (192 - data->fan_preload[nr])
+		     + new_div / 2) / new_div;
+	data->fan_preload[nr] = SENSORS_LIMIT(tmp, 0, 191);
+	smsc47m1_write_value(client, SMSC47M1_REG_FAN_PRELOAD(nr),
+			     data->fan_preload[nr]);
+
+	return count;
+}
+
+static ssize_t set_fan_pwm(struct device *dev, const char *buf,
+		size_t count, int nr)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct smsc47m1_data *data = i2c_get_clientdata(client);
+
+	long val = simple_strtol(buf, NULL, 10);
+
+	if (val < 0 || val > 255)
+		return -EINVAL;
+
+	data->pwm[nr] &= 0x81; /* Preserve additional bits */
+	data->pwm[nr] |= PWM_TO_REG(val);
+
+	smsc47m1_write_value(client, SMSC47M1_REG_PWM(nr),
+			     data->pwm[nr]);
+	return count;
+}
+
+static ssize_t set_fan_pwm_en(struct device *dev, const char *buf,
+		size_t count, int nr)
+{
+	struct i2c_client *client = to_i2c_client(dev);
+	struct smsc47m1_data *data = i2c_get_clientdata(client);
+
+	long val = simple_strtol(buf, NULL, 10);
+
+	if (val != 0 && val != 1)
+		return -EINVAL;
+
+	data->pwm[nr] &= 0xFE; /* preserve the other bits */
+	data->pwm[nr] |= !val;
+
+	smsc47m1_write_value(client, SMSC47M1_REG_PWM(nr),
+			     data->pwm[nr]);
+
+	return count;
+}
+
+#define fan_present(offset)						\
+static ssize_t get_fan##offset (struct device *dev, char *buf)		\
+{									\
+	return get_fan(dev, buf, 0x##offset - 1);			\
+}									\
+static ssize_t get_fan##offset##_min (struct device *dev, char *buf)	\
+{									\
+	return get_fan_min(dev, buf, 0x##offset - 1);			\
+}									\
+static ssize_t set_fan##offset##_min (struct device *dev,		\
+		const char *buf, size_t count)				\
+{									\
+	return set_fan_min(dev, buf, count, 0x##offset - 1);		\
+}									\
+static ssize_t get_fan##offset##_div (struct device *dev, char *buf)	\
+{									\
+	return get_fan_div(dev, buf, 0x##offset - 1);			\
+}									\
+static ssize_t set_fan##offset##_div (struct device *dev,		\
+		const char *buf, size_t count)				\
+{									\
+	return set_fan_div(dev, buf, count, 0x##offset - 1);		\
+}									\
+static ssize_t get_fan##offset##_pwm (struct device *dev, char *buf)	\
+{									\
+	return get_fan_pwm(dev, buf, 0x##offset - 1);			\
+}									\
+static ssize_t set_fan##offset##_pwm (struct device *dev,		\
+		const char *buf, size_t count)				\
+{									\
+	return set_fan_pwm(dev, buf, count, 0x##offset - 1);		\
+}									\
+static ssize_t get_fan##offset##_pwm_en (struct device *dev, char *buf)	\
+{									\
+	return get_fan_pwm_en(dev, buf, 0x##offset - 1);		\
+}									\
+static ssize_t set_fan##offset##_pwm_en (struct device *dev,		\
+		const char *buf, size_t count)				\
+{									\
+	return set_fan_pwm_en(dev, buf, count, 0x##offset - 1);		\
+}									\
+static DEVICE_ATTR(fan##offset##_input, S_IRUGO, get_fan##offset,	\
+		NULL);							\
+static DEVICE_ATTR(fan##offset##_min, S_IRUGO | S_IWUSR,		\
+		get_fan##offset##_min, set_fan##offset##_min);		\
+static DEVICE_ATTR(fan##offset##_div, S_IRUGO | S_IWUSR,		\
+		get_fan##offset##_div, set_fan##offset##_div);		\
+static DEVICE_ATTR(fan##offset##_pwm, S_IRUGO | S_IWUSR,		\
+		get_fan##offset##_pwm, set_fan##offset##_pwm);		\
+static DEVICE_ATTR(fan##offset##_pwm_enable, S_IRUGO | S_IWUSR,		\
+		get_fan##offset##_pwm_en, set_fan##offset##_pwm_en);
+
+fan_present(1);
+fan_present(2);
+
+static DEVICE_ATTR(alarms, S_IRUGO, get_alarms, NULL);
+
+static int smsc47m1_attach_adapter(struct i2c_adapter *adapter)
+{
+	if (!(adapter->class & I2C_CLASS_HWMON))
+		return 0;
+	return i2c_detect(adapter, &addr_data, smsc47m1_detect);
+}
+
+static int smsc47m1_find(int *address)
+{
+	u8 val;
+
+	superio_enter();
+	val = superio_inb(SUPERIO_REG_DEVID);
+
+	/*
+	 * SMSC LPC47M10x/LPC47M13x (device id 0x59), LPC47M14x (device id
+	 * 0x5F) and LPC47B27x (device id 0x51) have fan control.
+	 * The LPC47M15x and LPC47M192 chips "with hardware monitoring block"
+	 * can do much more besides (device id 0x60, unsupported).
+	 */
+	if (val == 0x51)
+		printk(KERN_INFO "smsc47m1: Found SMSC47B27x\n");
+	else if (val == 0x59)
+		printk(KERN_INFO "smsc47m1: Found SMSC47M10x/SMSC47M13x\n");
+	else if (val == 0x5F)
+		printk(KERN_INFO "smsc47m1: Found SMSC47M14x\n");
+	else {
+		superio_exit();
+		return -ENODEV;
+	}
+
+	superio_select();
+	*address = (superio_inb(SUPERIO_REG_BASE) << 8)
+		 |  superio_inb(SUPERIO_REG_BASE + 1);
+	val = superio_inb(SUPERIO_REG_ACT);
+	if (*address == 0 || (val & 0x01) == 0) {
+		printk(KERN_INFO "smsc47m1: Device is disabled, will not use\n");
+		superio_exit();
+		return -ENODEV;
+	}
+
+	superio_exit();
+	return 0;
+}
+
+static int smsc47m1_detect(struct i2c_adapter *adapter, int address, int kind)
+{
+	struct i2c_client *new_client;
+	struct smsc47m1_data *data;
+	int err = 0;
+
+	if (!i2c_is_isa_adapter(adapter)) {
+		return 0;
+	}
+
+	if (!request_region(address, SMSC_EXTENT, "smsc47m1")) {
+		dev_err(&adapter->dev, "Region 0x%x already in use!\n", address);
+		return -EBUSY;
+	}
+
+	if (!(data = kmalloc(sizeof(struct smsc47m1_data), GFP_KERNEL))) {
+		err = -ENOMEM;
+		goto error_release;
+	}
+	memset(data, 0x00, sizeof(struct smsc47m1_data));
+
+	new_client = &data->client;
+	i2c_set_clientdata(new_client, data);
+	new_client->addr = address;
+	init_MUTEX(&data->lock);
+	new_client->adapter = adapter;
+	new_client->driver = &smsc47m1_driver;
+	new_client->flags = 0;
+
+	strlcpy(new_client->name, "smsc47m1", I2C_NAME_SIZE);
+
+	new_client->id = smsc47m1_id++;
+	init_MUTEX(&data->update_lock);
+
+	if ((err = i2c_attach_client(new_client)))
+		goto error_free;
+
+	/* Some values (fan min, clock dividers, pwm registers) may be
+	   needed before any update is triggered, so we better read them
+	   at least once here. We don't usually do it that way, but in
+	   this particular case, manually reading 5 registers out of 8
+	   doesn't make much sense and we're better using the existing
+	   function. */
+	smsc47m1_update_device(&new_client->dev, 1);
+
+	if ((smsc47m1_read_value(new_client, SMSC47M1_REG_TPIN(0)) & 0x05)
+	    == 0x05) {
+		device_create_file(&new_client->dev, &dev_attr_fan1_input);
+		device_create_file(&new_client->dev, &dev_attr_fan1_min);
+		device_create_file(&new_client->dev, &dev_attr_fan1_div);
+	} else
+		dev_dbg(&new_client->dev, "Fan 1 not enabled by hardware, "
+			"skipping\n");
+
+	if ((smsc47m1_read_value(new_client, SMSC47M1_REG_TPIN(1)) & 0x05)
+	    == 0x05) {
+		device_create_file(&new_client->dev, &dev_attr_fan2_input);
+		device_create_file(&new_client->dev, &dev_attr_fan2_min);
+		device_create_file(&new_client->dev, &dev_attr_fan2_div);
+	} else
+		dev_dbg(&new_client->dev, "Fan 2 not enabled by hardware, "
+			"skipping\n");
+
+	if ((smsc47m1_read_value(new_client, SMSC47M1_REG_PPIN(0)) & 0x05)
+	    == 0x04) {
+		device_create_file(&new_client->dev, &dev_attr_fan1_pwm);
+		device_create_file(&new_client->dev, &dev_attr_fan1_pwm_enable);
+	} else
+		dev_dbg(&new_client->dev, "PWM 1 not enabled by hardware, "
+			"skipping\n");
+	if ((smsc47m1_read_value(new_client, SMSC47M1_REG_PPIN(1)) & 0x05)
+	    == 0x04) {
+		device_create_file(&new_client->dev, &dev_attr_fan2_pwm);
+		device_create_file(&new_client->dev, &dev_attr_fan2_pwm_enable);
+	} else
+		dev_dbg(&new_client->dev, "PWM 2 not enabled by hardware, "
+			"skipping\n");
+
+	device_create_file(&new_client->dev, &dev_attr_alarms);
+
+	return 0;
+
+error_free:
+	kfree(new_client);
+error_release:
+	release_region(address, SMSC_EXTENT);
+	return err;
+}
+
+static int smsc47m1_detach_client(struct i2c_client *client)
+{
+	int err;
+
+	if ((err = i2c_detach_client(client))) {
+		dev_err(&client->dev, "Client deregistration failed, "
+			"client not detached.\n");
+		return err;
+	}
+
+	release_region(client->addr, SMSC_EXTENT);
+	kfree(i2c_get_clientdata(client));
+
+	return 0;
+}
+
+static int smsc47m1_read_value(struct i2c_client *client, u8 reg)
+{
+	int res;
+
+	down(&((struct smsc47m1_data *) i2c_get_clientdata(client))->lock);
+	res = inb_p(client->addr + reg);
+	up(&((struct smsc47m1_data *) i2c_get_clientdata(client))->lock);
+	return res;
+}
+
+static void smsc47m1_write_value(struct i2c_client *client, u8 reg, u8 value)
+{
+	down(&((struct smsc47m1_data *) i2c_get_clientdata(client))->lock);
+	outb_p(value, client->addr + reg);
+	up(&((struct smsc47m1_data *) i2c_get_clientdata(client))->lock);
+}
+
+static struct smsc47m1_data *smsc47m1_update_device(struct device *dev,
+		int init)
+{
+ 	struct i2c_client *client = to_i2c_client(dev);
+	struct smsc47m1_data *data = i2c_get_clientdata(client);
+
+	down(&data->update_lock);
+
+	if ((jiffies - data->last_updated > HZ + HZ / 2) ||
+	    (jiffies < data->last_updated) || init) {
+		int i;
+
+		for (i = 0; i < 2; i++) {
+			data->fan[i] = smsc47m1_read_value(client,
+				       SMSC47M1_REG_FAN(i));
+			data->fan_preload[i] = smsc47m1_read_value(client,
+					       SMSC47M1_REG_FAN_PRELOAD(i));
+			data->pwm[i] = smsc47m1_read_value(client,
+				       SMSC47M1_REG_PWM(i));
+		}
+
+		i = smsc47m1_read_value(client, SMSC47M1_REG_FANDIV);
+		data->fan_div[0] = (i >> 4) & 0x03;
+		data->fan_div[1] = i >> 6;
+
+		data->alarms = smsc47m1_read_value(client,
+			       SMSC47M1_REG_ALARM) >> 6;
+		/* Clear alarms if needed */
+		if (data->alarms)
+			smsc47m1_write_value(client, SMSC47M1_REG_ALARM, 0xC0);
+
+		data->last_updated = jiffies;
+	}
+
+	up(&data->update_lock);
+	return data;
+}
+
+static int __init sm_smsc47m1_init(void)
+{
+	if (smsc47m1_find(normal_isa)) {
+		return -ENODEV;
+	}
+
+	return i2c_add_driver(&smsc47m1_driver);
+}
+
+static void __exit sm_smsc47m1_exit(void)
+{
+	i2c_del_driver(&smsc47m1_driver);
+}
+
+MODULE_AUTHOR("Mark D. Studebaker <mdsxyz123@yahoo.com>");
+MODULE_DESCRIPTION("SMSC LPC47M1xx fan sensors driver");
+MODULE_LICENSE("GPL");
+
+module_init(sm_smsc47m1_init);
+module_exit(sm_smsc47m1_exit);
Index: xx-sources/drivers/i2c/chips/via686a.c
===================================================================
--- xx-sources.orig/drivers/i2c/chips/via686a.c	2004-08-14 01:36:16.000000000 -0400
+++ xx-sources/drivers/i2c/chips/via686a.c	2004-08-14 13:17:24.741775112 -0400
@@ -43,8 +43,8 @@
 
 /* If force_addr is set to anything different from 0, we forcibly enable
    the device at the given address. */
-static int force_addr = 0;
-MODULE_PARM(force_addr, "i");
+static unsigned short force_addr = 0;
+module_param(force_addr, ushort, 0);
 MODULE_PARM_DESC(force_addr,
 		 "Initialize the base address of the sensors");
 
Index: xx-sources/drivers/i2c/chips/w83627hf.c
===================================================================
--- xx-sources.orig/drivers/i2c/chips/w83627hf.c	2004-08-14 01:37:37.000000000 -0400
+++ xx-sources/drivers/i2c/chips/w83627hf.c	2004-08-14 13:17:24.743774808 -0400
@@ -46,12 +46,12 @@
 #include <asm/io.h>
 #include "lm75.h"
 
-static int force_addr;
-MODULE_PARM(force_addr, "i");
+static u16 force_addr;
+module_param(force_addr, ushort, 0);
 MODULE_PARM_DESC(force_addr,
 		 "Initialize the base address of the sensors");
-static int force_i2c = 0x1f;
-MODULE_PARM(force_i2c, "i");
+static u8 force_i2c = 0x1f;
+module_param(force_i2c, byte, 0);
 MODULE_PARM_DESC(force_i2c,
 		 "Initialize the i2c address of the sensors");
 
@@ -65,7 +65,7 @@
 SENSORS_INSMOD_4(w83627hf, w83627thf, w83697hf, w83637hf);
 
 static int init = 1;
-MODULE_PARM(init, "i");
+module_param(init, bool, 0);
 MODULE_PARM_DESC(init, "Set to zero to bypass chip initialization");
 
 /* modified from kernel/include/traps.c */
@@ -1281,7 +1281,7 @@
 		data->vrm = (data->vrm_ovt & 0x01) ? 90 : 82;
 	} else {
 		/* Convert VID to voltage based on default VRM */
-		data->vrm = DEFAULT_VRM;
+		data->vrm = i2c_which_vrm();
 	}
 
 	tmp = w83627hf_read_value(client, W83781D_REG_SCFG1);
Index: xx-sources/drivers/i2c/chips/w83781d.c
===================================================================
--- xx-sources.orig/drivers/i2c/chips/w83781d.c	2004-08-14 01:36:09.000000000 -0400
+++ xx-sources/drivers/i2c/chips/w83781d.c	2004-08-14 13:17:24.745774504 -0400
@@ -60,7 +60,7 @@
 		    "{bus, clientaddr, subclientaddr1, subclientaddr2}");
 
 static int init = 1;
-MODULE_PARM(init, "i");
+module_param(init, bool, 0);
 MODULE_PARM_DESC(init, "Set to zero to bypass chip initialization");
 
 /* Constants specified below */
@@ -815,8 +815,7 @@
 		data->sens[nr - 1] = val;
 		break;
 	default:
-		dev_err(&client->dev,
-		       "Invalid sensor type %ld; must be 1, 2, or %d\n",
+		dev_err(dev, "Invalid sensor type %ld; must be 1, 2, or %d\n",
 		       (long) val, W83781D_DEFAULT_BETA);
 		break;
 	}
@@ -1513,7 +1512,7 @@
 		w83781d_write_value(client, W83781D_REG_BEEP_INTS2, 0);
 	}
 
-	data->vrm = 82;
+	data->vrm = i2c_which_vrm();
 
 	if ((type != w83781d) && (type != as99127f)) {
 		tmp = w83781d_read_value(client, W83781D_REG_SCFG1);
@@ -1593,7 +1592,7 @@
 	if (time_after
 	    (jiffies - data->last_updated, (unsigned long) (HZ + HZ / 2))
 	    || time_before(jiffies, data->last_updated) || !data->valid) {
-		pr_debug("Starting device update\n");
+		dev_dbg(dev, "Starting device update\n");
 
 		for (i = 0; i <= 8; i++) {
 			if ((data->type == w83783s || data->type == w83697hf)
Index: xx-sources/drivers/i2c/i2c-sensor-detect.c
===================================================================
--- xx-sources.orig/drivers/i2c/i2c-sensor-detect.c	2004-05-31 17:36:38.000000000 -0400
+++ xx-sources/drivers/i2c/i2c-sensor-detect.c	2004-08-14 13:17:24.746774352 -0400
@@ -0,0 +1,169 @@
+/*
+    i2c-sensor-detect.c - Part of lm_sensors, Linux kernel modules for hardware
+            		  monitoring
+    Copyright (c) 1998 - 2001 Frodo Looijaard <frodol@dds.nl> and
+    Mark D. Studebaker <mdsxyz123@yahoo.com>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/ctype.h>
+#include <linux/sysctl.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/i2c.h>
+#include <linux/i2c-sensor.h>
+#include <asm/uaccess.h>
+
+
+/* Very inefficient for ISA detects, and won't work for 10-bit addresses! */
+int i2c_detect(struct i2c_adapter *adapter,
+	       struct i2c_address_data *address_data,
+	       int (*found_proc) (struct i2c_adapter *, int, int))
+{
+	int addr, i, found, j, err;
+	struct i2c_force_data *this_force;
+	int is_isa = i2c_is_isa_adapter(adapter);
+	int adapter_id =
+	    is_isa ? ANY_I2C_ISA_BUS : i2c_adapter_id(adapter);
+
+	/* Forget it if we can't probe using SMBUS_QUICK */
+	if ((!is_isa) &&
+	    !i2c_check_functionality(adapter, I2C_FUNC_SMBUS_QUICK))
+		return -1;
+
+	for (addr = 0x00; addr <= (is_isa ? 0xffff : 0x7f); addr++) {
+		if (!is_isa && i2c_check_addr(adapter, addr))
+			continue;
+
+		/* If it is in one of the force entries, we don't do any
+		   detection at all */
+		found = 0;
+		for (i = 0; !found && (this_force = address_data->forces + i, this_force->force); i++) {
+			for (j = 0; !found && (this_force->force[j] != I2C_CLIENT_END); j += 2) {
+				if ( ((adapter_id == this_force->force[j]) ||
+				      ((this_force->force[j] == ANY_I2C_BUS) && !is_isa)) &&
+				      (addr == this_force->force[j + 1]) ) {
+					dev_dbg(&adapter->dev, "found force parameter for adapter %d, addr %04x\n", adapter_id, addr);
+					if ((err = found_proc(adapter, addr, this_force->kind)))
+						return err;
+					found = 1;
+				}
+			}
+		}
+		if (found)
+			continue;
+
+		/* If this address is in one of the ignores, we can forget about it
+		   right now */
+		for (i = 0; !found && (address_data->ignore[i] != I2C_CLIENT_END); i += 2) {
+			if ( ((adapter_id == address_data->ignore[i]) ||
+			      ((address_data->ignore[i] == ANY_I2C_BUS) &&
+			       !is_isa)) &&
+			      (addr == address_data->ignore[i + 1])) {
+				dev_dbg(&adapter->dev, "found ignore parameter for adapter %d, addr %04x\n", adapter_id, addr);
+				found = 1;
+			}
+		}
+		for (i = 0; !found && (address_data->ignore_range[i] != I2C_CLIENT_END); i += 3) {
+			if ( ((adapter_id == address_data->ignore_range[i]) ||
+			      ((address_data-> ignore_range[i] == ANY_I2C_BUS) &
+			       !is_isa)) &&
+			     (addr >= address_data->ignore_range[i + 1]) &&
+			     (addr <= address_data->ignore_range[i + 2])) {
+				dev_dbg(&adapter->dev,  "found ignore_range parameter for adapter %d, addr %04x\n", adapter_id, addr);
+				found = 1;
+			}
+		}
+		if (found)
+			continue;
+
+		/* Now, we will do a detection, but only if it is in the normal or
+		   probe entries */
+		if (is_isa) {
+			for (i = 0; !found && (address_data->normal_isa[i] != I2C_CLIENT_ISA_END); i += 1) {
+				if (addr == address_data->normal_isa[i]) {
+					dev_dbg(&adapter->dev, "found normal isa entry for adapter %d, addr %04x\n", adapter_id, addr);
+					found = 1;
+				}
+			}
+			for (i = 0; !found && (address_data->normal_isa_range[i] != I2C_CLIENT_ISA_END); i += 3) {
+				if ((addr >= address_data->normal_isa_range[i]) &&
+				    (addr <= address_data->normal_isa_range[i + 1]) &&
+				    ((addr - address_data->normal_isa_range[i]) % address_data->normal_isa_range[i + 2] == 0)) {
+					dev_dbg(&adapter->dev, "found normal isa_range entry for adapter %d, addr %04x", adapter_id, addr);
+					found = 1;
+				}
+			}
+		} else {
+			for (i = 0; !found && (address_data->normal_i2c[i] != I2C_CLIENT_END); i += 1) {
+				if (addr == address_data->normal_i2c[i]) {
+					found = 1;
+					dev_dbg(&adapter->dev, "found normal i2c entry for adapter %d, addr %02x", adapter_id, addr);
+				}
+			}
+			for (i = 0; !found && (address_data->normal_i2c_range[i] != I2C_CLIENT_END); i += 2) {
+				if ((addr >= address_data->normal_i2c_range[i]) &&
+				    (addr <= address_data->normal_i2c_range[i + 1])) {
+					dev_dbg(&adapter->dev, "found normal i2c_range entry for adapter %d, addr %04x\n", adapter_id, addr);
+					found = 1;
+				}
+			}
+		}
+
+		for (i = 0;
+		     !found && (address_data->probe[i] != I2C_CLIENT_END);
+		     i += 2) {
+			if (((adapter_id == address_data->probe[i]) ||
+			     ((address_data->
+			       probe[i] == ANY_I2C_BUS) && !is_isa))
+			    && (addr == address_data->probe[i + 1])) {
+				dev_dbg(&adapter->dev, "found probe parameter for adapter %d, addr %04x\n", adapter_id, addr);
+				found = 1;
+			}
+		}
+		for (i = 0; !found && (address_data->probe_range[i] != I2C_CLIENT_END); i += 3) {
+			if ( ((adapter_id == address_data->probe_range[i]) ||
+			      ((address_data->probe_range[i] == ANY_I2C_BUS) && !is_isa)) &&
+			     (addr >= address_data->probe_range[i + 1]) &&
+			     (addr <= address_data->probe_range[i + 2])) {
+				found = 1;
+				dev_dbg(&adapter->dev, "found probe_range parameter for adapter %d, addr %04x\n", adapter_id, addr);
+			}
+		}
+		if (!found)
+			continue;
+
+		/* OK, so we really should examine this address. First check
+		   whether there is some client here at all! */
+		if (is_isa ||
+		    (i2c_smbus_xfer (adapter, addr, 0, 0, 0, I2C_SMBUS_QUICK, NULL) >= 0))
+			if ((err = found_proc(adapter, addr, -1)))
+				return err;
+	}
+	return 0;
+}
+
+EXPORT_SYMBOL(i2c_detect);
+
+MODULE_AUTHOR("Frodo Looijaard <frodol@dds.nl>, "
+	      "Rudolf Marek <r.marek@sh.cvut.cz>");
+
+MODULE_DESCRIPTION("i2c-sensor driver");
+MODULE_LICENSE("GPL");
Index: xx-sources/drivers/i2c/i2c-sensor-vid.c
===================================================================
--- xx-sources.orig/drivers/i2c/i2c-sensor-vid.c	2004-05-31 17:36:38.000000000 -0400
+++ xx-sources/drivers/i2c/i2c-sensor-vid.c	2004-08-14 13:17:24.747774200 -0400
@@ -0,0 +1,99 @@
+/*
+    i2c-sensor-vid.c -  Part of lm_sensors, Linux kernel modules for hardware
+        		monitoring
+
+    Copyright (c) 2004 Rudolf Marek <r.marek@sh.cvut.cz>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+
+struct vrm_model {
+	u8 vendor;
+	u8 eff_family;
+	u8 eff_model;
+	int vrm_type;
+};
+
+#define ANY 0xFF
+
+#ifdef CONFIG_X86
+
+static struct vrm_model vrm_models[] = {
+	{X86_VENDOR_AMD, 0x6, ANY, 90},		/* Athlon Duron etc */
+	{X86_VENDOR_AMD, 0xF, 0x4, 90},		/* Athlon 64 */
+	{X86_VENDOR_AMD, 0xF, 0x5, 24},		/* Opteron */
+	{X86_VENDOR_INTEL, 0x6, 0x9, 85},	/* 0.13um too */
+	{X86_VENDOR_INTEL, 0x6, 0xB, 85},	/* 0xB Tualatin */
+	{X86_VENDOR_INTEL, 0x6, ANY, 82},	/* any P6 */
+	{X86_VENDOR_INTEL, 0x7, ANY, 0},	/* Itanium */
+	{X86_VENDOR_INTEL, 0xF, 0x3, 100},	/* P4 Prescott */
+	{X86_VENDOR_INTEL, 0xF, ANY, 90},	/* P4 before Prescott */
+	{X86_VENDOR_INTEL, 0x10,ANY, 0},	/* Itanium 2 */
+	{X86_VENDOR_UNKNOWN, ANY, ANY, 0}	/* stop here */
+	};
+
+static int find_vrm(u8 eff_family, u8 eff_model, u8 vendor)
+{
+	int i = 0;
+
+	while (vrm_models[i].vendor!=X86_VENDOR_UNKNOWN) {
+		if (vrm_models[i].vendor==vendor)
+			if ((vrm_models[i].eff_family==eff_family)&& \
+			((vrm_models[i].eff_model==eff_model)|| \
+			(vrm_models[i].eff_model==ANY)))
+				return vrm_models[i].vrm_type;
+		i++;
+	}
+
+	return 0;
+}
+
+int i2c_which_vrm(void)
+{
+	struct cpuinfo_x86 *c = cpu_data;
+	u32 eax;
+	u8 eff_family, eff_model;
+	int vrm_ret;
+
+	if (c->x86 < 6) return 0;	/* any CPU with familly lower than 6
+				 	dont have VID and/or CPUID */
+	eax = cpuid_eax(1);
+	eff_family = ((eax & 0x00000F00)>>8);
+	eff_model  = ((eax & 0x000000F0)>>4);
+	if (eff_family == 0xF) {	/* use extended model & family */
+		eff_family += ((eax & 0x00F00000)>>20);
+		eff_model += ((eax & 0x000F0000)>>16)<<4;
+	}
+	vrm_ret = find_vrm(eff_family,eff_model,c->x86_vendor);
+	if (vrm_ret == 0)
+		printk(KERN_INFO "i2c-sensor.o: Unknown VRM version of your"
+		" x86 CPU\n");
+	return vrm_ret;
+}
+
+/* and now something completely different for Non-x86 world*/
+#else
+int i2c_which_vrm(void)
+{
+	printk(KERN_INFO "i2c-sensor.o: Unknown VRM version of your CPU\n");
+	return 0;
+}
+#endif
+
+EXPORT_SYMBOL(i2c_which_vrm);
Index: xx-sources/drivers/i2c/i2c-sensor.c
===================================================================
--- xx-sources.orig/drivers/i2c/i2c-sensor.c	2004-08-14 01:36:58.000000000 -0400
+++ xx-sources/drivers/i2c/i2c-sensor.c	2004-05-31 17:36:38.000000000 -0400
@@ -1,167 +0,0 @@
-/*
-    i2c-sensor.c - Part of lm_sensors, Linux kernel modules for hardware
-                monitoring
-    Copyright (c) 1998 - 2001 Frodo Looijaard <frodol@dds.nl> and
-    Mark D. Studebaker <mdsxyz123@yahoo.com>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-*/
-
-#include <linux/config.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/ctype.h>
-#include <linux/sysctl.h>
-#include <linux/init.h>
-#include <linux/ioport.h>
-#include <linux/i2c.h>
-#include <linux/i2c-sensor.h>
-#include <asm/uaccess.h>
-
-
-/* Very inefficient for ISA detects, and won't work for 10-bit addresses! */
-int i2c_detect(struct i2c_adapter *adapter,
-	       struct i2c_address_data *address_data,
-	       int (*found_proc) (struct i2c_adapter *, int, int))
-{
-	int addr, i, found, j, err;
-	struct i2c_force_data *this_force;
-	int is_isa = i2c_is_isa_adapter(adapter);
-	int adapter_id =
-	    is_isa ? ANY_I2C_ISA_BUS : i2c_adapter_id(adapter);
-
-	/* Forget it if we can't probe using SMBUS_QUICK */
-	if ((!is_isa) &&
-	    !i2c_check_functionality(adapter, I2C_FUNC_SMBUS_QUICK))
-		return -1;
-
-	for (addr = 0x00; addr <= (is_isa ? 0xffff : 0x7f); addr++) {
-		if (!is_isa && i2c_check_addr(adapter, addr))
-			continue;
-
-		/* If it is in one of the force entries, we don't do any
-		   detection at all */
-		found = 0;
-		for (i = 0; !found && (this_force = address_data->forces + i, this_force->force); i++) {
-			for (j = 0; !found && (this_force->force[j] != I2C_CLIENT_END); j += 2) {
-				if ( ((adapter_id == this_force->force[j]) ||
-				      ((this_force->force[j] == ANY_I2C_BUS) && !is_isa)) &&
-				      (addr == this_force->force[j + 1]) ) {
-					dev_dbg(&adapter->dev, "found force parameter for adapter %d, addr %04x\n", adapter_id, addr);
-					if ((err = found_proc(adapter, addr, this_force->kind)))
-						return err;
-					found = 1;
-				}
-			}
-		}
-		if (found)
-			continue;
-
-		/* If this address is in one of the ignores, we can forget about it
-		   right now */
-		for (i = 0; !found && (address_data->ignore[i] != I2C_CLIENT_END); i += 2) {
-			if ( ((adapter_id == address_data->ignore[i]) ||
-			      ((address_data->ignore[i] == ANY_I2C_BUS) &&
-			       !is_isa)) &&
-			      (addr == address_data->ignore[i + 1])) {
-				dev_dbg(&adapter->dev, "found ignore parameter for adapter %d, addr %04x\n", adapter_id, addr);
-				found = 1;
-			}
-		}
-		for (i = 0; !found && (address_data->ignore_range[i] != I2C_CLIENT_END); i += 3) {
-			if ( ((adapter_id == address_data->ignore_range[i]) ||
-			      ((address_data-> ignore_range[i] == ANY_I2C_BUS) & 
-			       !is_isa)) &&
-			     (addr >= address_data->ignore_range[i + 1]) &&
-			     (addr <= address_data->ignore_range[i + 2])) {
-				dev_dbg(&adapter->dev,  "found ignore_range parameter for adapter %d, addr %04x\n", adapter_id, addr);
-				found = 1;
-			}
-		}
-		if (found)
-			continue;
-
-		/* Now, we will do a detection, but only if it is in the normal or 
-		   probe entries */
-		if (is_isa) {
-			for (i = 0; !found && (address_data->normal_isa[i] != I2C_CLIENT_ISA_END); i += 1) {
-				if (addr == address_data->normal_isa[i]) {
-					dev_dbg(&adapter->dev, "found normal isa entry for adapter %d, addr %04x\n", adapter_id, addr);
-					found = 1;
-				}
-			}
-			for (i = 0; !found && (address_data->normal_isa_range[i] != I2C_CLIENT_ISA_END); i += 3) {
-				if ((addr >= address_data->normal_isa_range[i]) &&
-				    (addr <= address_data->normal_isa_range[i + 1]) &&
-				    ((addr - address_data->normal_isa_range[i]) % address_data->normal_isa_range[i + 2] == 0)) {
-					dev_dbg(&adapter->dev, "found normal isa_range entry for adapter %d, addr %04x", adapter_id, addr);
-					found = 1;
-				}
-			}
-		} else {
-			for (i = 0; !found && (address_data->normal_i2c[i] != I2C_CLIENT_END); i += 1) {
-				if (addr == address_data->normal_i2c[i]) {
-					found = 1;
-					dev_dbg(&adapter->dev, "found normal i2c entry for adapter %d, addr %02x", adapter_id, addr);
-				}
-			}
-			for (i = 0; !found && (address_data->normal_i2c_range[i] != I2C_CLIENT_END); i += 2) {
-				if ((addr >= address_data->normal_i2c_range[i]) &&
-				    (addr <= address_data->normal_i2c_range[i + 1])) {
-					dev_dbg(&adapter->dev, "found normal i2c_range entry for adapter %d, addr %04x\n", adapter_id, addr);
-					found = 1;
-				}
-			}
-		}
-
-		for (i = 0;
-		     !found && (address_data->probe[i] != I2C_CLIENT_END);
-		     i += 2) {
-			if (((adapter_id == address_data->probe[i]) ||
-			     ((address_data->
-			       probe[i] == ANY_I2C_BUS) && !is_isa))
-			    && (addr == address_data->probe[i + 1])) {
-				dev_dbg(&adapter->dev, "found probe parameter for adapter %d, addr %04x\n", adapter_id, addr);
-				found = 1;
-			}
-		}
-		for (i = 0; !found && (address_data->probe_range[i] != I2C_CLIENT_END); i += 3) {
-			if ( ((adapter_id == address_data->probe_range[i]) ||
-			      ((address_data->probe_range[i] == ANY_I2C_BUS) && !is_isa)) &&
-			     (addr >= address_data->probe_range[i + 1]) &&
-			     (addr <= address_data->probe_range[i + 2])) {
-				found = 1;
-				dev_dbg(&adapter->dev, "found probe_range parameter for adapter %d, addr %04x\n", adapter_id, addr);
-			}
-		}
-		if (!found)
-			continue;
-
-		/* OK, so we really should examine this address. First check
-		   whether there is some client here at all! */
-		if (is_isa ||
-		    (i2c_smbus_xfer (adapter, addr, 0, 0, 0, I2C_SMBUS_QUICK, NULL) >= 0))
-			if ((err = found_proc(adapter, addr, -1)))
-				return err;
-	}
-	return 0;
-}
-
-EXPORT_SYMBOL(i2c_detect);
-
-MODULE_AUTHOR("Frodo Looijaard <frodol@dds.nl>");
-MODULE_DESCRIPTION("i2c-sensor driver");
-MODULE_LICENSE("GPL");
Index: xx-sources/drivers/parisc/superio.c
===================================================================
--- xx-sources.orig/drivers/parisc/superio.c	2004-08-14 01:37:25.000000000 -0400
+++ xx-sources/drivers/parisc/superio.c	2004-08-14 13:17:24.749773896 -0400
@@ -484,6 +484,7 @@
 	pci_read_config_byte(pdev, PCI_CLASS_PROG, &prog);
 	printk("PCI: Enabled native mode for NS87415 (pif=0x%x)\n", prog);
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_NS, PCI_DEVICE_ID_NS_87415, superio_fixup_pci);
 
 /* Because of a defect in Super I/O, all reads of the PCI DMA status 
  * registers, IDE status register and the IDE select register need to be 
Index: xx-sources/drivers/pci/hotplug/Kconfig
===================================================================
--- xx-sources.orig/drivers/pci/hotplug/Kconfig	2004-08-14 01:38:11.000000000 -0400
+++ xx-sources/drivers/pci/hotplug/Kconfig	2004-08-14 13:17:24.750773744 -0400
@@ -88,6 +88,18 @@
 
 	  When in doubt, say N.
 
+config HOTPLUG_PCI_ACPI_IBM
+	tristate "ACPI PCI Hotplug driver IBM extensions"
+	depends on HOTPLUG_PCI_ACPI
+	help
+	  Say Y here if you have an IBM system that supports PCI Hotplug using
+	  ACPI.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called acpiphp_ibm.
+
+	  When in doubt, say N.
+
 config HOTPLUG_PCI_CPCI
 	bool "CompactPCI Hotplug driver"
 	depends on HOTPLUG_PCI
Index: xx-sources/drivers/pci/hotplug/Makefile
===================================================================
--- xx-sources.orig/drivers/pci/hotplug/Makefile	2004-08-14 01:37:26.000000000 -0400
+++ xx-sources/drivers/pci/hotplug/Makefile	2004-08-14 13:17:24.751773592 -0400
@@ -7,6 +7,7 @@
 obj-$(CONFIG_HOTPLUG_PCI_COMPAQ)	+= cpqphp.o
 obj-$(CONFIG_HOTPLUG_PCI_IBM)		+= ibmphp.o
 obj-$(CONFIG_HOTPLUG_PCI_ACPI)		+= acpiphp.o
+obj-$(CONFIG_HOTPLUG_PCI_ACPI_IBM)	+= acpiphp_ibm.o
 obj-$(CONFIG_HOTPLUG_PCI_CPCI_ZT5550)	+= cpcihp_zt5550.o
 obj-$(CONFIG_HOTPLUG_PCI_CPCI_GENERIC)	+= cpcihp_generic.o
 obj-$(CONFIG_HOTPLUG_PCI_PCIE)		+= pciehp.o
Index: xx-sources/drivers/pci/hotplug/acpiphp.h
===================================================================
--- xx-sources.orig/drivers/pci/hotplug/acpiphp.h	2004-08-14 01:38:09.000000000 -0400
+++ xx-sources/drivers/pci/hotplug/acpiphp.h	2004-08-14 13:17:24.751773592 -0400
@@ -171,6 +171,18 @@
 	struct pci_resource *bus_head;
 };
 
+/**
+ * struct acpiphp_attention_info - device specific attention registration
+ *
+ * ACPI has no generic method of setting/getting attention status
+ * this allows for device specific driver registration
+ */
+struct acpiphp_attention_info
+{
+	int (*set_attn)(struct hotplug_slot *slot, u8 status);
+	int (*get_attn)(struct hotplug_slot *slot, u8 *status);
+	struct module *owner;
+};
 
 /* PCI bus bridge HID */
 #define ACPI_PCI_HOST_HID		"PNP0A03"
@@ -212,6 +224,10 @@
 
 /* function prototypes */
 
+/* acpiphp_core.c */
+extern int acpiphp_register_attention(struct acpiphp_attention_info*info);
+extern int acpiphp_unregister_attention(struct acpiphp_attention_info *info);
+
 /* acpiphp_glue.c */
 extern int acpiphp_glue_init (void);
 extern void acpiphp_glue_exit (void);
Index: xx-sources/drivers/pci/hotplug/acpiphp_core.c
===================================================================
--- xx-sources.orig/drivers/pci/hotplug/acpiphp_core.c	2004-08-14 01:37:15.000000000 -0400
+++ xx-sources/drivers/pci/hotplug/acpiphp_core.c	2004-08-14 13:17:24.754773136 -0400
@@ -51,6 +51,7 @@
 
 /* local variables */
 static int num_slots;
+static struct acpiphp_attention_info *attention_info;
 
 #define DRIVER_VERSION	"0.4"
 #define DRIVER_AUTHOR	"Greg Kroah-Hartman <gregkh@us.ibm.com>, Takayoshi Kochi <t-kochi@bq.jp.nec.com>"
@@ -62,10 +63,15 @@
 MODULE_PARM_DESC(debug, "Debugging mode enabled or not");
 module_param(debug, bool, 644);
 
+/* export the attention callback registration methods */
+EXPORT_SYMBOL_GPL(acpiphp_register_attention);
+EXPORT_SYMBOL_GPL(acpiphp_unregister_attention);
+
 static int enable_slot		(struct hotplug_slot *slot);
 static int disable_slot		(struct hotplug_slot *slot);
 static int set_attention_status (struct hotplug_slot *slot, u8 value);
 static int get_power_status	(struct hotplug_slot *slot, u8 *value);
+static int get_attention_status (struct hotplug_slot *slot, u8 *value);
 static int get_address		(struct hotplug_slot *slot, u32 *value);
 static int get_latch_status	(struct hotplug_slot *slot, u8 *value);
 static int get_adapter_status	(struct hotplug_slot *slot, u8 *value);
@@ -76,11 +82,54 @@
 	.disable_slot		= disable_slot,
 	.set_attention_status	= set_attention_status,
 	.get_power_status	= get_power_status,
+	.get_attention_status	= get_attention_status,
 	.get_latch_status	= get_latch_status,
 	.get_adapter_status	= get_adapter_status,
 	.get_address		= get_address,
 };
 
+
+/**
+ * acpiphp_register_attention - set attention LED callback
+ * @info: must be completely filled with LED callbacks
+ *
+ * Description: this is used to register a hardware specific ACPI
+ * driver that manipulates the attention LED.  All the fields in
+ * info must be set.
+ **/
+int acpiphp_register_attention(struct acpiphp_attention_info *info)
+{
+	int retval = -EINVAL;
+
+	if (info && info->owner && info->set_attn &&
+			info->get_attn && !attention_info) {
+		retval = 0;
+		attention_info = info;
+	}
+	return retval;
+}
+
+
+/**
+ * acpiphp_unregister_attention - unset attention LED callback
+ * @info: must match the pointer used to register
+ *
+ * Description: this is used to un-register a hardware specific acpi
+ * driver that manipulates the attention LED.  The pointer to the
+ * info struct must be the same as the one used to set it.
+ **/
+int acpiphp_unregister_attention(struct acpiphp_attention_info *info)
+{
+	int retval = -EINVAL;
+
+	if (info && attention_info == info) {
+		attention_info = NULL;
+		retval = 0;
+	}
+	return retval;
+}
+
+
 /**
  * enable_slot - power on and enable a slot
  * @hotplug_slot: slot to enable
@@ -117,33 +166,29 @@
 }
 
 
-/**
- * set_attention_status - set attention LED
- *
- * TBD:
- * ACPI doesn't have known method to manipulate
- * attention status LED.
- *
- */
-static int set_attention_status(struct hotplug_slot *hotplug_slot, u8 status)
-{
-	dbg("%s - physical_slot = %s\n", __FUNCTION__, hotplug_slot->name);
-
-	switch (status) {
-		case 0:
-			/* FIXME turn light off */
-			hotplug_slot->info->attention_status = 0;
-			break;
-
-		case 1:
-		default:
-			/* FIXME turn light on */
-			hotplug_slot->info->attention_status = 1;
-			break;
-	}
+ /**
+  * set_attention_status - set attention LED
+ * @hotplug_slot: slot to set attention LED on
+ * @status: value to set attention LED to (0 or 1)
+ *
+ * attention status LED, so we use a callback that
+ * was registered with us.  This allows hardware specific
+ * ACPI implementations to blink the light for us.
+ **/
+ static int set_attention_status(struct hotplug_slot *hotplug_slot, u8 status)
+ {
+	int retval = -ENODEV;
+
+ 	dbg("%s - physical_slot = %s\n", __FUNCTION__, hotplug_slot->name);
+
+	if (attention_info && try_module_get(attention_info->owner)) {
+		retval = attention_info->set_attn(hotplug_slot, status);
+		module_put(attention_info->owner);
+	} else
+		attention_info = NULL;
+	return retval;
+ }
 
-	return 0;
-}
 
 /**
  * get_power_status - get power status of a slot
@@ -165,6 +210,32 @@
 	return 0;
 }
 
+
+ /**
+ * get_attention_status - get attention LED status
+ * @hotplug_slot: slot to get status from
+ * @value: returns with value of attention LED
+ *
+ * ACPI doesn't have known method to determine the state
+ * of the attention status LED, so we use a callback that
+ * was registered with us.  This allows hardware specific
+ * ACPI implementations to determine its state
+ **/
+static int get_attention_status(struct hotplug_slot *hotplug_slot, u8 *value)
+{
+	int retval = -EINVAL;
+
+	dbg("%s - physical_slot = %s\n", __FUNCTION__, hotplug_slot->name);
+
+	if (attention_info && try_module_get(attention_info->owner)) {
+		retval = attention_info->get_attn(hotplug_slot, value);
+		module_put(attention_info->owner);
+	} else
+		attention_info = NULL;
+	return retval;
+}
+
+
 /**
  * get_latch_status - get latch status of a slot
  * @hotplug_slot: slot to get status
@@ -307,7 +378,7 @@
 
 		slot->acpi_slot = get_slot_from_id(i);
 		slot->hotplug_slot->info->power_status = acpiphp_get_power_status(slot->acpi_slot);
-		slot->hotplug_slot->info->attention_status = acpiphp_get_attention_status(slot->acpi_slot);
+		slot->hotplug_slot->info->attention_status = 0;
 		slot->hotplug_slot->info->latch_status = acpiphp_get_latch_status(slot->acpi_slot);
 		slot->hotplug_slot->info->adapter_status = acpiphp_get_adapter_status(slot->acpi_slot);
 		slot->hotplug_slot->info->max_bus_speed = PCI_SPEED_UNKNOWN;
Index: xx-sources/drivers/pci/hotplug/acpiphp_glue.c
===================================================================
--- xx-sources.orig/drivers/pci/hotplug/acpiphp_glue.c	2004-08-14 01:36:44.000000000 -0400
+++ xx-sources/drivers/pci/hotplug/acpiphp_glue.c	2004-08-14 13:17:24.756772832 -0400
@@ -1302,20 +1302,6 @@
 
 
 /*
- * attention LED ON: 1
- *		OFF: 0
- *
- * TBD
- * no direct attention led status information via ACPI
- *
- */
-u8 acpiphp_get_attention_status(struct acpiphp_slot *slot)
-{
-	return 0;
-}
-
-
-/*
  * latch closed:  1
  * latch   open:  0
  */
Index: xx-sources/drivers/pci/hotplug/acpiphp_ibm.c
===================================================================
--- xx-sources.orig/drivers/pci/hotplug/acpiphp_ibm.c	2004-05-31 17:36:38.000000000 -0400
+++ xx-sources/drivers/pci/hotplug/acpiphp_ibm.c	2004-08-14 13:17:24.760772224 -0400
@@ -0,0 +1,474 @@
+/*
+ * ACPI PCI Hot Plug IBM Extension
+ *
+ * Copyright (C) 2004 Vernon Mauery <vernux@us.ibm.com>
+ * Copyright (C) 2004 IBM Corp.
+ *
+ * All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+ * NON INFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Send feedback to <vernux@us.ibm.com>
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <acpi/acpi_bus.h>
+#include <linux/sysfs.h>
+#include <linux/kobject.h>
+#include <asm/uaccess.h>
+#include <linux/moduleparam.h>
+
+#include "acpiphp.h"
+#include "pci_hotplug.h"
+
+#define DRIVER_VERSION	"1.0.1"
+#define DRIVER_AUTHOR	"Irene Zubarev <zubarev@us.ibm.com>, Vernon Mauery <vernux@us.ibm.com>"
+#define DRIVER_DESC	"ACPI Hot Plug PCI Controller Driver IBM extension"
+
+static int debug;
+
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRIVER_VERSION);
+module_param(debug, bool, 644);
+MODULE_PARM_DESC(debug, " Debugging mode enabled or not");
+#define MY_NAME "acpiphp_ibm"
+
+#undef dbg
+#define dbg(format, arg...)				\
+do {							\
+	if (debug)					\
+		printk(KERN_DEBUG "%s: " format,	\
+				MY_NAME , ## arg);	\
+} while (0)
+
+#define FOUND_APCI 0x61504349
+/* these are the names for the IBM ACPI pseudo-device */
+#define IBM_HARDWARE_ID1 "IBM37D0"
+#define IBM_HARDWARE_ID2 "IBM37D4"
+
+/* union apci_descriptor - allows access to the
+ * various device descriptors that are embedded in the
+ * aPCI table
+ */
+union apci_descriptor {
+	struct {
+		char sig[4];
+		u8   len;
+	} header;
+	struct {
+		u8  type;
+		u8  len;
+		u16 slot_id;
+		u8  bus_id;
+		u8  dev_num;
+		u8  slot_num;
+		u8  slot_attr[2];
+		u8  attn;
+		u8  status[2];
+		u8  sun;
+	} slot;
+	struct {
+		u8 type;
+		u8 len;
+	} generic;
+};
+
+/* struct notification - keeps info about the device
+ * that cause the ACPI notification event
+ */
+struct notification {
+	struct acpi_device *device;
+	u8                  event;
+};
+
+static int ibm_set_attention_status(struct hotplug_slot *slot, u8 status);
+static int ibm_get_attention_status(struct hotplug_slot *slot, u8 *status);
+static void ibm_handle_events(acpi_handle handle, u32 event, void *context);
+static int ibm_get_table_from_acpi(char **bufp);
+static ssize_t ibm_read_apci_table(struct kobject *kobj,
+		char *buffer, loff_t pos, size_t size);
+static acpi_status __init ibm_find_acpi_device(acpi_handle handle,
+		u32 lvl, void *context, void **rv);
+static int __init ibm_acpiphp_init(void);
+static void __exit ibm_acpiphp_exit(void);
+
+static acpi_handle ibm_acpi_handle;
+static struct notification ibm_note;
+static struct bin_attribute ibm_apci_table_attr = {
+	    .attr = {
+		    .name = "apci_table",
+		    .owner = THIS_MODULE,
+		    .mode = S_IRUGO,
+	    },
+	    .read = ibm_read_apci_table,
+	    .write = NULL,
+};
+static struct acpiphp_attention_info ibm_attention_info =
+{
+	.set_attn = ibm_set_attention_status,
+	.get_attn = ibm_get_attention_status,
+	.owner = THIS_MODULE,
+};
+
+
+/**
+ * ibm_set_attention_status - callback method to set the attention LED
+ * @slot: the hotplug_slot to work with
+ * @status: what to set the LED to (0 or 1)
+ *
+ * Description: this method is registered with the acpiphp module as a
+ * callback to do the device specific task of setting the LED status
+ **/
+static int ibm_set_attention_status(struct hotplug_slot *slot, u8 status)
+{
+	int retval = 0;
+	union acpi_object args[2];
+	struct acpi_object_list params = { .pointer = args, .count = 2 };
+	acpi_status stat;
+	unsigned long rc = 0;
+	struct acpiphp_slot *acpi_slot;
+
+	acpi_slot = ((struct slot *)(slot->private))->acpi_slot;
+
+	dbg("%s: set slot %d attention status to %d\n", __FUNCTION__,
+			acpi_slot->sun, (status ? 1 : 0));
+
+	args[0].type = ACPI_TYPE_INTEGER;
+	args[0].integer.value = acpi_slot->sun;
+	args[1].type = ACPI_TYPE_INTEGER;
+	args[1].integer.value = (status) ? 1 : 0;
+
+	stat = acpi_evaluate_integer(ibm_acpi_handle, "APLS", &params, &rc);
+	if (ACPI_FAILURE(stat)) {
+		retval = -ENODEV;
+		err("APLS evaluation failed:  0x%08x\n", stat);
+	} else if (!rc) {
+		retval = -ERANGE;
+		err("APLS method failed:  0x%08lx\n", rc);
+	}
+	return retval;
+}
+
+/**
+ * ibm_get_attention_status - callback method to get attention LED status
+ * @slot: the hotplug_slot to work with
+ * @status: returns what the LED is set to (0 or 1)
+ *
+ * Description: this method is registered with the acpiphp module as a
+ * callback to do the device specific task of getting the LED status
+ *
+ * Because there is no direct method of getting the LED status directly
+ * from an ACPI call, we read the aPCI table and parse out our
+ * slot descriptor to read the status from that.
+ **/
+static int ibm_get_attention_status(struct hotplug_slot *slot, u8 *status)
+{
+	int retval = -EINVAL, ind = 0, size;
+	char *table = NULL;
+	struct acpiphp_slot *acpi_slot;
+	union apci_descriptor *des;
+
+	acpi_slot = ((struct slot *)(slot->private))->acpi_slot;
+
+	size = ibm_get_table_from_acpi(&table);
+	if (size <= 0 || !table)
+		goto get_attn_done;
+	// read the header
+	des = (union apci_descriptor *)&table[ind];
+	if (memcmp(des->header.sig, "aPCI", 4) != 0)
+		goto get_attn_done;
+	des = (union apci_descriptor *)&table[ind += des->header.len];
+	while (ind < size && (des->generic.type != 0x82 ||
+			des->slot.slot_id != acpi_slot->sun))
+		des = (union apci_descriptor *)&table[ind += des->generic.len];
+	if (ind < size && des->slot.slot_id == acpi_slot->sun) {
+		retval = 0;
+		if (des->slot.attn & 0xa0 || des->slot.status[1] & 0x08)
+			*status = 1;
+		else
+			*status = 0;
+	}
+
+	dbg("%s: get slot %d attention status is %d retval=%x\n",
+			__FUNCTION__, acpi_slot->sun, *status, retval);
+
+get_attn_done:
+	kfree(table);
+	return retval;
+}
+
+/**
+ * ibm_handle_events - listens for ACPI events for the IBM37D0 device
+ * @handle: an ACPI handle to the device that caused the event
+ * @event: the event info (device specific)
+ * @context: passed context (our notification struct)
+ *
+ * Description: this method is registered as a callback with the ACPI
+ * subsystem it is called when this device has an event to notify the OS of
+ *
+ * The events actually come from the device as two events that get
+ * synthesized into one event with data by this function.  The event
+ * ID comes first and then the slot number that caused it.  We report
+ * this as one event to the OS.
+ *
+ * From section 5.6.2.2 of the ACPI 2.0 spec, I understand that the OSPM will
+ * only re-enable the interrupt that causes this event AFTER this method
+ * has returned, thereby enforcing serial access for the notification struct.
+ **/
+static void ibm_handle_events(acpi_handle handle, u32 event, void *context)
+{
+	u8 detail = event & 0x0f;
+	u8 subevent = event & 0xf0;
+	struct notification *note = context;
+
+	dbg("%s: Received notification %02x\n", __FUNCTION__, event);
+
+	if (subevent == 0x80) {
+		dbg("%s: generationg bus event\n", __FUNCTION__);
+		acpi_bus_generate_event(note->device, note->event, detail);
+	} else
+		note->event = event;
+}
+
+/**
+ * ibm_get_table_from_acpi - reads the APLS buffer from ACPI
+ * @bufp: address to pointer to allocate for the table
+ *
+ * Description: this method reads the APLS buffer in from ACPI and
+ * stores the "stripped" table into a single buffer
+ * it allocates and passes the address back in bufp
+ *
+ * If NULL is passed in as buffer, this method only calculates
+ * the size of the table and returns that without filling
+ * in the buffer
+ *
+ * returns < 0 on error or the size of the table on success
+ **/
+static int ibm_get_table_from_acpi(char **bufp)
+{
+	union acpi_object *package;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	acpi_status status;
+	char *lbuf = NULL;
+	int i, size = -EIO;
+
+	status = acpi_evaluate_object(ibm_acpi_handle, "APCI", NULL, &buffer);
+	if (ACPI_FAILURE(status)) {
+		err("%s:  APCI evaluation failed\n", __FUNCTION__);
+		return -ENODEV;
+	}
+
+	package = (union acpi_object *) buffer.pointer;
+	if(!(package) ||
+			(package->type != ACPI_TYPE_PACKAGE) ||
+			!(package->package.elements)) {
+		err("%s:  Invalid APCI object\n", __FUNCTION__);
+		goto read_table_done;
+	}
+
+	for(size = 0, i = 0; i < package->package.count; i++) {
+		if (package->package.elements[i].type != ACPI_TYPE_BUFFER) {
+			err("%s:  Invalid APCI element %d\n", __FUNCTION__, i);
+			goto read_table_done;
+		}
+		size += package->package.elements[i].buffer.length;
+	}
+
+	if (bufp == NULL)
+		goto read_table_done;
+
+	lbuf = kmalloc(size, GFP_KERNEL);
+	dbg("%s: element count: %i, ASL table size: %i, &table = 0x%p\n",
+			__FUNCTION__, package->package.count, size, lbuf);
+
+	if (lbuf) {
+		*bufp = lbuf;
+		memset(lbuf, 0, size);
+	} else {
+		size = -ENOMEM;
+		goto read_table_done;
+	}
+
+	size = 0;
+	for (i=0; i<package->package.count; i++) {
+		memcpy(&lbuf[size],
+				package->package.elements[i].buffer.pointer,
+				package->package.elements[i].buffer.length);
+		size += package->package.elements[i].buffer.length;
+	}
+
+read_table_done:
+	kfree(buffer.pointer);
+	return size;
+}
+
+/**
+ * ibm_read_apci_table - callback for the sysfs apci_table file
+ * @kobj: the kobject this binary attribute is a part of
+ * @buffer: the kernel space buffer to fill
+ * @pos: the offset into the file
+ * @size: the number of bytes requested
+ *
+ * Description: gets registered with sysfs as the reader callback
+ * to be executed when /sys/bus/pci/slots/apci_table gets read
+ *
+ * Since we don't get notified on open and close for this file,
+ * things get really tricky here...
+ * our solution is to only allow reading the table in all at once
+ **/
+static ssize_t ibm_read_apci_table(struct kobject *kobj,
+		char *buffer, loff_t pos, size_t size)
+{
+	int bytes_read = -EINVAL;
+	char *table = NULL;
+
+	dbg("%s: pos = %d, size = %d\n", __FUNCTION__, (int)pos, size);
+
+	if (pos == 0) {
+		bytes_read = ibm_get_table_from_acpi(&table);
+		if (bytes_read > 0 && bytes_read <= size)
+			memcpy(buffer, table, bytes_read);
+		kfree(table);
+	}
+	return bytes_read;
+}
+
+/**
+ * ibm_find_acpi_device - callback to find our ACPI device
+ * @handle: the ACPI handle of the device we are inspecting
+ * @lvl: depth into the namespace tree
+ * @context: a pointer to our handle to fill when we find the device
+ * @rv: a return value to fill if desired
+ *
+ * Description: used as a callback when calling acpi_walk_namespace
+ * to find our device.  When this method returns non-zero
+ * acpi_walk_namespace quits its search and returns our value
+ **/
+static acpi_status __init ibm_find_acpi_device(acpi_handle handle,
+		u32 lvl, void *context, void **rv)
+{
+	acpi_handle *phandle = (acpi_handle *)context;
+	acpi_status status;
+	struct acpi_device_info info;
+	struct acpi_buffer info_buffer = {
+		.length = sizeof(struct acpi_device_info),
+		.pointer = &info,
+	};
+
+	status = acpi_get_object_info(handle, &info_buffer);
+	if (ACPI_FAILURE(status)) {
+		err("%s:  Failed to get device information", __FUNCTION__);
+		return 0;
+	}
+	info.hardware_id.value[sizeof(info.hardware_id.value) - 1] = '\0';
+
+	if(info.current_status && (info.valid & ACPI_VALID_HID) &&
+			(!strcmp(info.hardware_id.value, IBM_HARDWARE_ID1) ||
+			!strcmp(info.hardware_id.value, IBM_HARDWARE_ID2))) {
+		dbg("found hardware: %s, handle: %x\n", info.hardware_id.value,
+				(unsigned int)handle);
+		*phandle = handle;
+		/* returning non-zero causes the search to stop
+		 * and returns this value to the caller of
+		 * acpi_walk_namespace, but it also causes some warnings
+		 * in the acpi debug code to print...
+		 */
+		return FOUND_APCI;
+	}
+	return 0;
+}
+
+static int __init ibm_acpiphp_init(void)
+{
+	int retval = 0;
+	acpi_status status;
+	struct acpi_device *device;
+	struct kobject *sysdir = &pci_hotplug_slots_subsys.kset.kobj;
+
+	dbg("%s\n", __FUNCTION__);
+
+	if (acpi_walk_namespace(ACPI_TYPE_DEVICE, ACPI_ROOT_OBJECT,
+			ACPI_UINT32_MAX, ibm_find_acpi_device,
+			&ibm_acpi_handle, NULL) != FOUND_APCI) {
+		err("%s: acpi_walk_namespace failed\n", __FUNCTION__);
+		retval = -ENODEV;
+		goto init_return;
+	}
+	dbg("%s: found IBM aPCI device\n", __FUNCTION__);
+	if (acpi_bus_get_device(ibm_acpi_handle, &device)) {
+		err("%s: acpi_bus_get_device failed\n", __FUNCTION__);
+		retval = -ENODEV;
+		goto init_return;
+	}
+	if (acpiphp_register_attention(&ibm_attention_info)) {
+		retval = -ENODEV;
+		goto init_return;
+	}
+
+	ibm_note.device = device;
+	status = acpi_install_notify_handler(
+			ibm_acpi_handle,
+			ACPI_DEVICE_NOTIFY,
+			ibm_handle_events,
+			&ibm_note);
+	if (ACPI_FAILURE(status)) {
+		err("%s:  Failed to register notification handler\n",
+				__FUNCTION__);
+		retval = -EBUSY;
+		goto init_cleanup;
+	}
+
+	ibm_apci_table_attr.size = ibm_get_table_from_acpi(NULL);
+	retval = sysfs_create_bin_file(sysdir, &ibm_apci_table_attr);
+
+	return retval;
+
+init_cleanup:
+	acpiphp_unregister_attention(&ibm_attention_info);
+init_return:
+	return retval;
+}
+
+static void __exit ibm_acpiphp_exit(void)
+{
+	acpi_status status;
+	struct kobject *sysdir = &pci_hotplug_slots_subsys.kset.kobj;
+
+	dbg("%s\n", __FUNCTION__);
+
+	if (acpiphp_unregister_attention(&ibm_attention_info))
+		err("%s: attention info deregistration failed", __FUNCTION__);
+
+	   status = acpi_remove_notify_handler(
+			   ibm_acpi_handle,
+			   ACPI_DEVICE_NOTIFY,
+			   ibm_handle_events);
+	   if (ACPI_FAILURE(status))
+		   err("%s:  Notification handler removal failed\n",
+				   __FUNCTION__);
+	// remove the /sys entries
+	if (sysfs_remove_bin_file(sysdir, &ibm_apci_table_attr))
+		err("%s: removal of sysfs file apci_table failed\n",
+				__FUNCTION__);
+}
+
+module_init(ibm_acpiphp_init);
+module_exit(ibm_acpiphp_exit);
Index: xx-sources/drivers/pci/hotplug/cpci_hotplug_core.c
===================================================================
--- xx-sources.orig/drivers/pci/hotplug/cpci_hotplug_core.c	2004-08-14 01:36:56.000000000 -0400
+++ xx-sources/drivers/pci/hotplug/cpci_hotplug_core.c	2004-08-14 13:17:24.763771768 -0400
@@ -33,6 +33,7 @@
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/smp_lock.h>
+#include <linux/delay.h>
 #include "pci_hotplug.h"
 #include "cpci_hotplug.h"
 
@@ -513,11 +514,10 @@
 			break;
 		while(controller->ops->query_enum()) {
 			rc = check_slots();
-			if(rc > 0) {
+			if (rc > 0)
 				/* Give userspace a chance to handle extraction */
-				set_current_state(TASK_INTERRUPTIBLE);
-				schedule_timeout(HZ / 2);
-			} else if(rc < 0) {
+				msleep(500);
+			else if (rc < 0) {
 				dbg("%s - error checking slots", __FUNCTION__);
 				thread_finished = 1;
 				break;
@@ -568,11 +568,10 @@
 
 		while(controller->ops->query_enum()) {
 			rc = check_slots();
-			if(rc > 0) {
+			if(rc > 0)
 				/* Give userspace a chance to handle extraction */
-				set_current_state(TASK_INTERRUPTIBLE);
-				schedule_timeout(HZ / 2);
-			} else if(rc < 0) {
+				msleep(500);
+			else if (rc < 0) {
 				dbg("%s - error checking slots", __FUNCTION__);
 				thread_finished = 1;
 				break;
@@ -595,8 +594,7 @@
 			}
 		}
 
-		set_current_state(TASK_INTERRUPTIBLE);
-		schedule_timeout(HZ / 10);
+		msleep(100);
 	}
 	dbg("poll thread signals exit");
 	up(&thread_exit);
Index: xx-sources/drivers/pci/hotplug/ibmphp.h
===================================================================
--- xx-sources.orig/drivers/pci/hotplug/ibmphp.h	2004-08-14 01:36:16.000000000 -0400
+++ xx-sources/drivers/pci/hotplug/ibmphp.h	2004-08-14 13:17:24.764771616 -0400
@@ -759,11 +759,5 @@
 extern int ibmphp_unconfigure_card (struct slot **, int);
 extern struct hotplug_slot_ops ibmphp_hotplug_slot_ops;
 
-static inline void long_delay (int delay)
-{
-	set_current_state (TASK_INTERRUPTIBLE);
-	schedule_timeout (delay);
-}
-
 #endif				//__IBMPHP_H
 
Index: xx-sources/drivers/pci/hotplug/ibmphp_core.c
===================================================================
--- xx-sources.orig/drivers/pci/hotplug/ibmphp_core.c	2004-08-14 01:38:10.000000000 -0400
+++ xx-sources/drivers/pci/hotplug/ibmphp_core.c	2004-08-14 13:17:24.766771312 -0400
@@ -190,7 +190,7 @@
 		err ("command not completed successfully in power_on\n");
 		return -EIO;
 	}
-	long_delay (3 * HZ); /* For ServeRAID cards, and some 66 PCI */
+	msleep(3000);	/* For ServeRAID cards, and some 66 PCI */
 	return 0;
 }
 
@@ -913,7 +913,7 @@
 	}
 	/* This is for x440, once Brandon fixes the firmware, 
 	will not need this delay */
-	long_delay (1 * HZ);
+	msleep(1000);
 	debug ("%s -Exit\n", __FUNCTION__);
 	return 0;
 }
Index: xx-sources/drivers/pci/hotplug/ibmphp_hpc.c
===================================================================
--- xx-sources.orig/drivers/pci/hotplug/ibmphp_hpc.c	2004-08-14 01:36:32.000000000 -0400
+++ xx-sources/drivers/pci/hotplug/ibmphp_hpc.c	2004-08-14 13:17:24.767771160 -0400
@@ -29,6 +29,7 @@
 
 #include <linux/wait.h>
 #include <linux/time.h>
+#include <linux/delay.h>
 #include <linux/module.h>
 #include <linux/pci.h>
 #include <linux/smp_lock.h>
@@ -205,7 +206,7 @@
 	// READ - step 4 : wait until start operation bit clears
 	i = CMD_COMPLETE_TOUT_SEC;
 	while (i) {
-		long_delay (1 * HZ / 100);
+		msleep(10);
 		wpg_addr = WPGBbar + WPG_I2CMCNTL_OFFSET;
 		wpg_data = readl (wpg_addr);
 		data = swab32 (wpg_data);
@@ -221,7 +222,7 @@
 	// READ - step 5 : read I2C status register
 	i = CMD_COMPLETE_TOUT_SEC;
 	while (i) {
-		long_delay (1 * HZ / 100);
+		msleep(10);
 		wpg_addr = WPGBbar + WPG_I2CSTAT_OFFSET;
 		wpg_data = readl (wpg_addr);
 		data = swab32 (wpg_data);
@@ -316,7 +317,7 @@
 	// WRITE - step 4 : wait until start operation bit clears
 	i = CMD_COMPLETE_TOUT_SEC;
 	while (i) {
-		long_delay (1 * HZ / 100);
+		msleep(10);
 		wpg_addr = WPGBbar + WPG_I2CMCNTL_OFFSET;
 		wpg_data = readl (wpg_addr);
 		data = swab32 (wpg_data);
@@ -333,7 +334,7 @@
 	// WRITE - step 5 : read I2C status register
 	i = CMD_COMPLETE_TOUT_SEC;
 	while (i) {
-		long_delay (1 * HZ / 100);
+		msleep(10);
 		wpg_addr = WPGBbar + WPG_I2CSTAT_OFFSET;
 		wpg_data = readl (wpg_addr);
 		data = swab32 (wpg_data);
@@ -748,7 +749,7 @@
 					done = TRUE;
 			}
 			if (!done) {
-				long_delay (1 * HZ);
+				msleep(1000);
 				if (timeout < 1) {
 					done = TRUE;
 					err ("%s - Error command complete timeout\n", __FUNCTION__);
@@ -891,7 +892,7 @@
 		case POLL_SLEEP:
 			/* don't sleep with a lock on the hardware */
 			up (&semOperations);
-			long_delay (POLL_INTERVAL_SEC * HZ);
+			msleep(POLL_INTERVAL_SEC * 1000);
 
 			if (ibmphp_shutdown) 
 				break;
@@ -908,8 +909,7 @@
 		/* give up the harware semaphore */
 		up (&semOperations);
 		/* sleep for a short time just for good measure */
-		set_current_state (TASK_INTERRUPTIBLE);
-		schedule_timeout (HZ/10);
+		msleep(100);
 	}
 	up (&sem_exit);
 	debug ("%s - Exit\n", __FUNCTION__);
@@ -974,7 +974,7 @@
 			if (SLOT_PWRGD (pslot->status)) {
 				// power goes on and off after closing latch
 				// check again to make sure power is still ON
-				long_delay (1 * HZ);
+				msleep(1000);
 				rc = ibmphp_hpc_readslot (pslot, READ_SLOTSTATUS, &status);
 				if (SLOT_PWRGD (status))
 					update = TRUE;
@@ -1147,7 +1147,7 @@
 		if (CTLR_WORKING (*pstatus) == HPC_CTLR_WORKING_NO)
 			done = TRUE;
 		if (!done) {
-			long_delay (1 * HZ);
+			msleep(1000);
 			if (timeout < 1) {
 				done = TRUE;
 				err ("HPCreadslot - Error ctlr timeout\n");
Index: xx-sources/drivers/pci/hotplug/pciehp_hpc.c
===================================================================
--- xx-sources.orig/drivers/pci/hotplug/pciehp_hpc.c	2004-08-14 01:37:15.000000000 -0400
+++ xx-sources/drivers/pci/hotplug/pciehp_hpc.c	2004-08-14 13:17:24.769770856 -0400
@@ -1017,7 +1017,7 @@
 	return IRQ_HANDLED;
 }
 
-static int hpc_get_max_lnk_speed (struct slot *slot, enum pcie_link_speed *value)
+static int hpc_get_max_lnk_speed (struct slot *slot, enum pci_bus_speed *value)
 {
 	struct php_ctlr_state_s *php_ctlr = slot->ctrl->hpc_ctlr_handle;
 	enum pcie_link_speed lnk_speed;
@@ -1120,7 +1120,7 @@
 	return retval;
 }
 
-static int hpc_get_cur_lnk_speed (struct slot *slot, enum pcie_link_speed *value)
+static int hpc_get_cur_lnk_speed (struct slot *slot, enum pci_bus_speed *value)
 {
 	struct php_ctlr_state_s *php_ctlr = slot->ctrl->hpc_ctlr_handle;
 	enum pcie_link_speed lnk_speed = PCI_SPEED_UNKNOWN;
Index: xx-sources/drivers/pci/hotplug/rpaphp_core.c
===================================================================
--- xx-sources.orig/drivers/pci/hotplug/rpaphp_core.c	2004-08-14 01:38:08.000000000 -0400
+++ xx-sources/drivers/pci/hotplug/rpaphp_core.c	2004-08-14 13:17:24.770770704 -0400
@@ -54,8 +54,6 @@
 MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_LICENSE("GPL");
 
-void eeh_register_disable_func(int (*)(struct pci_dev *));
-
 module_param(debug, bool, 0644);
 
 static int enable_slot(struct hotplug_slot *slot);
@@ -407,18 +405,12 @@
 {
 	info(DRIVER_DESC " version: " DRIVER_VERSION "\n");
 
-	/* let EEH know they can use hotplug */
-	eeh_register_disable_func(&rpaphp_disable_slot);
-
 	/* read all the PRA info from the system */
 	return init_rpa();
 }
 
 static void __exit rpaphp_exit(void)
 {
-	/* let EEH know we are going away */
-	eeh_register_disable_func(NULL);
-
 	cleanup_slots();
 }
 
Index: xx-sources/drivers/pci/hotplug/rpaphp_pci.c
===================================================================
--- xx-sources.orig/drivers/pci/hotplug/rpaphp_pci.c	2004-08-14 01:36:10.000000000 -0400
+++ xx-sources/drivers/pci/hotplug/rpaphp_pci.c	2004-08-14 13:17:24.771770552 -0400
@@ -341,7 +341,6 @@
 	return rc;
 }
 
-
 static void rpaphp_eeh_remove_bus_device(struct pci_dev *dev)
 {
 	eeh_remove_device(dev);
@@ -430,10 +429,26 @@
 				__FUNCTION__, slot->name);
 			goto exit_rc;
 		}
-		if (init_slot_pci_funcs(slot)) {
-			err("%s: init_slot_pci_funcs failed\n", __FUNCTION__);
+
+		if (slot->hotplug_slot->info->adapter_status == NOT_CONFIGURED) {
+			dbg("%s CONFIGURING pci adapter in slot[%s]\n",
+				__FUNCTION__, slot->name);
+			if (rpaphp_config_pci_adapter(slot)) {
+				err("%s: CONFIG pci adapter failed\n", __FUNCTION__);
+				goto exit_rc;
+			}
+		} else if (slot->hotplug_slot->info->adapter_status == CONFIGURED) {
+			if (init_slot_pci_funcs(slot)) {
+				err("%s: init_slot_pci_funcs failed\n", __FUNCTION__);
+				goto exit_rc;
+			}
+
+		} else {
+			err("%s: slot[%s]'s adapter_status is NOT_VALID.\n",
+				__FUNCTION__, slot->name);
 			goto exit_rc;
 		}
+
 		print_slot_pci_funcs(slot);
 		if (!list_empty(&slot->dev.pci_funcs)) {
 			slot->state = CONFIGURED;
Index: xx-sources/drivers/pci/hotplug/shpchp_hpc.c
===================================================================
--- xx-sources.orig/drivers/pci/hotplug/shpchp_hpc.c	2004-08-14 01:36:44.000000000 -0400
+++ xx-sources/drivers/pci/hotplug/shpchp_hpc.c	2004-08-14 13:17:24.772770400 -0400
@@ -35,6 +35,7 @@
 #include <linux/vmalloc.h>
 #include <linux/interrupt.h>
 #include <linux/spinlock.h>
+#include <linux/delay.h>
 #include <linux/pci.h>
 #include <asm/system.h>
 #include "shpchp.h"
@@ -300,8 +301,7 @@
 		if (!(cmd_status & 0x1))
 			break;
 		/*  Check every 0.1 sec for a total of 1 sec*/
-		set_current_state(TASK_INTERRUPTIBLE);
-		schedule_timeout(HZ/10);
+		msleep(100);
 	}
 
 	cmd_status = readw(php_ctlr->creg + CMD_STATUS);
Index: xx-sources/drivers/pci/pci.c
===================================================================
--- xx-sources.orig/drivers/pci/pci.c	2004-08-14 01:36:33.000000000 -0400
+++ xx-sources/drivers/pci/pci.c	2004-08-14 13:17:24.774770096 -0400
@@ -291,10 +291,7 @@
 	/* Mandatory power management transition delays */
 	/* see PCI PM 1.1 5.6.1 table 18 */
 	if(state == 3 || dev->current_state == 3)
-	{
-		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(HZ/100);
-	}
+		msleep(10);
 	else if(state == 2 || dev->current_state == 2)
 		udelay(200);
 	dev->current_state = state;
@@ -748,7 +745,7 @@
 	struct pci_dev *dev = NULL;
 
 	while ((dev = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, dev)) != NULL) {
-		pci_fixup_device(PCI_FIXUP_FINAL, dev);
+		pci_fixup_device(pci_fixup_final, dev);
 	}
 	return 0;
 }
Index: xx-sources/drivers/pci/pci.ids
===================================================================
--- xx-sources.orig/drivers/pci/pci.ids	2004-08-14 01:36:58.000000000 -0400
+++ xx-sources/drivers/pci/pci.ids	2004-08-14 13:17:24.783768728 -0400
@@ -7,7 +7,7 @@
 #	so if you have anything to contribute, please visit the home page or
 #	send a diff -u against the most recent pci.ids to pci-ids@ucw.cz.
 #
-#	Daily snapshot on Thu 2004-04-15 10:00:04
+#	Daily snapshot on Mon 2004-07-12 10:00:27
 #
 
 # Vendors, devices and subsystems. Please keep sorted.
@@ -150,37 +150,58 @@
 		0e11 4082  Smart Array 532
 		0e11 4083  Smart Array 5312
 	b1a4  NC7131 Gigabit Server Adapter
+	b203  Integrated Lights Out Controller
+	b204  Integrated Lights Out  Processor
 	f130  NetFlex-3/P ThunderLAN 1.0
 	f150  NetFlex-3/P ThunderLAN 2.3
 0e55  HaSoTec GmbH
 # Formerly NCR
 1000  LSI Logic / Symbios Logic
 	0001  53c810
-		1000 1000  8100S
+		1000 1000  LSI53C810AE PCI to SCSI I/O Processor
 	0002  53c820
 	0003  53c825
+		1000 1000  LSI53C825AE PCI to SCSI I/O Processor (Ultra Wide)
 	0004  53c815
 	0005  53c810AP
 	0006  53c860
+		1000 1000  LSI53C860E PCI to Ultra SCSI I/O Processor
 	000a  53c1510
-	000b  53c896
+		1000 1000  LSI53C1510 PCI to Dual Channel Wide Ultra2 SCSI Controller (Nonintelligent mode)
+	000b  53C896/897
+		1000 1000  LSI53C896/7 PCI to Dual Channel Ultra2 SCSI Multifunction Controller
+		1000 1010  LSI22910 PCI to Dual Channel Ultra2 SCSI host adapter
+		1000 1020  LSI21002 PCI to Dual Channel Ultra2 SCSI host adapter
+# multifunction PCI card: Dual U2W SCSI, dual 10/100TX, graphics
+		13e9 1000  6221L-4U
 	000c  53c895
+		1000 1010  LSI8951U PCI to Ultra2 SCSI host adapter
+		1000 1020  LSI8952U PCI to Ultra2 SCSI host adapter
+		1de1 3906  DC-390U2B SCSI adapter
 		1de1 3907  DC-390U2W
 	000d  53c885
 	000f  53c875
 		0e11 7004  Embedded Ultra Wide SCSI Controller
+		1000 1000  LSI53C876/E PCI to Dual Channel SCSI Controller
+		1000 1010  LSI22801 PCI to Dual Channel Ultra SCSI host adapter
+		1000 1020  LSI22802 PCI to Dual Channel Ultra SCSI host adapter
 		1092 8760  FirePort 40 Dual SCSI Controller
-		1de1 3904  DC390F Ultra Wide SCSI Controller
+		1de1 3904  DC390F/U Ultra Wide SCSI Adapter
 		4c53 1000  CC7/CR7/CP7/VC7/VP7/VR7 mainboard
 		4c53 1050  CT7 mainboard
-	0010  53c895
+	0010  53C1510
 		0e11 4040  Integrated Array Controller
 		0e11 4048  Integrated Array Controller
+		1000 1000  53C1510 PCI to Dual Channel Wide Ultra2 SCSI Controller (Intelligent mode)
 	0012  53c895a
+		1000 1000  LSI53C895A PCI to Ultra2 SCSI Controller
 	0013  53c875a
+		1000 1000  LSI53C875A PCI to Ultra SCSI Controller
 	0020  53c1010 Ultra3 SCSI Adapter
+		1000 1000  LSI53C1010-33 PCI to Dual Channel Ultra160 SCSI Controller
 		1de1 1020  DC-390U3W
 	0021  53c1010 66MHz  Ultra3 SCSI Adapter
+		1000 1000  LSI53C1000/1000R/1010R/1010-66 PCI to Ultra160 SCSI Controller
 		124b 1070  PMC-USCSI3
 		4c53 1080  CT8 mainboard
 		4c53 1300  P017 mezzanine (32-bit PMC)
@@ -191,6 +212,7 @@
 		1028 1010  LSI U320 SCSI Controller
 	0031  53c1030ZC PCI-X Fusion-MPT Dual Ultra320 SCSI
 	0032  53c1035 PCI-X Fusion-MPT Dual Ultra320 SCSI
+		1000 1000  LSI53C1020/1030 PCI-X to Ultra320 SCSI Controller
 	0033  1030ZC_53c1035 PCI-X Fusion-MPT Dual Ultra320 SCSI
 	0040  53c1035 PCI-X Fusion-MPT Dual Ultra320 SCSI
 		1000 0033  MegaRAID SCSI 320-2XR
@@ -203,8 +225,10 @@
 		1000 0530  MegaRAID 530 SCSI 320-0X RAID Controller
 		1000 0531  MegaRAID 531 SCSI 320-4X RAID Controller
 		1000 0532  MegaRAID 532 SCSI 320-2X RAID Controller
-		1028 0533  PowerEgde Expandable RAID Controller 4/QC
+		1028 0533  PowerEdge Expandable RAID Controller 4/QC
 		8086 0532  Storage RAID Controller SRCU42X
+	0408  MegaRAID
+		1028 0002  PowerEdge Expandable RAID Controller 4e/DC
 	0621  FC909 Fibre Channel Adapter
 	0622  FC929 Fibre Channel Adapter
 		1000 1020  44929 O Dual Fibre Channel card
@@ -235,6 +259,7 @@
 		1028 0518  MegaRAID 518 DELL PERC 4/DC RAID Controller
 		1028 0520  MegaRAID 520 DELL PERC 4/SC RAID Controller
 		1028 0531  PowerEdge Expandable RAID Controller 4/QC
+		1028 0533  PowerEdge Expandable RAID Controller 4/QC
 1001  Kolter Electronic
 	0010  PCI 1616 Measurement card with 32 digital I/O lines
 	0011  OPTO-PCI Opto-Isolated digital I/O board
@@ -350,6 +375,8 @@
 		1002 8008  Rage XL
 		1028 00ce  PowerEdge 1400
 		1028 00d1  PowerEdge 2550
+		8086 3411  SDS2 Mainboard
+		8086 3427  S875WP1-E mainboard
 	4753  Rage XC
 		1002 4753  Rage XC
 	4754  3D Rage I/II 215GT [Mach64 GT]
@@ -435,10 +462,12 @@
 	4e44  Radeon R300 ND [Radeon 9700 Pro]
 	4e45  Radeon R300 NE [Radeon 9500 Pro]
 		1002 0002  Radeon R300 NE [Radeon 9500 Pro]
+		1681 0002  Hercules 3D Prophet 9500 PRO [Radeon 9500 Pro]
 # New PCI ID provided by ATI developer relations (correction to above)
 	4e46  RV350 NF [Radeon 9600]
 	4e47  Radeon R300 NG [FireGL X1]
-	4e48  Radeon R350 [Radeon 9800]
+# (added pro)
+	4e48  Radeon R350 [Radeon 9800 Pro]
 # New PCI ID provided by ATI developer relations
 	4e49  Radeon R350 [Radeon 9800]
 	4e4a  RV350 NJ [Radeon 9800 XT]
@@ -451,10 +480,12 @@
 	4e64  Radeon R300 [Radeon 9700 Pro] (Secondary)
 	4e65  Radeon R300 [Radeon 9500 Pro] (Secondary)
 		1002 0003  Radeon R300 NE [Radeon 9500 Pro]
+		1681 0003  Hercules 3D Prophet 9500 PRO [Radeon 9500 Pro] (Secondary)
 # New PCI ID provided by ATI developer relations (correction to above)
 	4e66  RV350 NF [Radeon 9600] (Secondary)
 	4e67  Radeon R300 [FireGL X1] (Secondary)
-	4e68  Radeon R350 [Radeon 9800] (Secondary)
+# (added pro)
+	4e68  Radeon R350 [Radeon 9800 Pro] (Secondary)
 # New PCI ID provided by ATI developer relations
 	4e69  Radeon R350 [Radeon 9800] (Secondary)
 	4e6a  RV350 NJ [Radeon 9800 XT] (Secondary)
@@ -535,6 +566,7 @@
 		148c 2024  RV200 QW [Radeon 7500LE Dual Display]
 		148c 2025  RV200 QW [Radeon 7500 Evil Master Multi Display Edition]
 		148c 2036  RV200 QW [Radeon 7500 PCI Dual Display]
+		174b 7146  RV200 QW [Radeon 7500 LE]
 		174b 7147  RV200 QW [Sapphire Radeon 7500LE]
 		174b 7161  Radeon RV200 QW [Radeon 7500 LE]
 		17af 0202  RV200 QW [Excalibur Radeon 7500LE]
@@ -624,6 +656,7 @@
 	5d44  RV280 [Radeon 9200 SE] (Secondary)
 	700f  PCI Bridge [IGP 320M]
 	7010  PCI Bridge [IGP 340M]
+	7c37  RV350 AQ [Radeon 9600 SE]
 	cab0  AGP Bridge [IGP 320M]
 	cab2  RS200/RS200M AGP Bridge [IGP 340M]
 1003  ULSI Systems
@@ -865,6 +898,8 @@
 		1014 002e  ServeRAID-3x
 		1014 022e  ServeRAID-4H
 	0031  2 Port Serial Adapter
+# AS400 iSeries PCI sync serial card
+		1014 0031  2721 WAN IOA - 2 Port Sync Serial Adapter
 	0036  Miami
 	003a  CPU to PCI Bridge
 	003c  GXT250P/GXT255P Graphics Adapter
@@ -946,7 +981,7 @@
 	0266  PCI-X Dual Channel SCSI
 	0268  Gigabit Ethernet-SX Adapter (PCI-X)
 	0269  10/100/1000 Base-TX Ethernet Adapter (PCI-X)
-	0302  XA-32 chipset [Summit]
+	0302  X-Architecture Bridge [Summit]
 	ffff  MPIC-2 interrupt controller
 1015  LSI Logic Corp of Canada
 1016  ICL Personal Systems
@@ -1059,20 +1094,27 @@
 	7454  AMD-8151 System Controller
 	7455  AMD-8151 AGP Bridge
 	7460  AMD-8111 PCI
+		161f 3017  HDAMB
 	7461  AMD-8111 USB
 	7462  AMD-8111 Ethernet
 	7464  AMD-8111 USB
+		161f 3017  HDAMB
 	7468  AMD-8111 LPC
+		161f 3017  HDAMB
 	7469  AMD-8111 IDE
+		161f 3017  HDAMB
 	746a  AMD-8111 SMBus 2.0
 	746b  AMD-8111 ACPI
+		161f 3017  HDAMB
 	746d  AMD-8111 AC97 Audio
+		161f 3017  HDAMB
 	746e  AMD-8111 MC97 Modem
 	756b  AMD-8111 ACPI
 1023  Trident Microsystems
 	0194  82C194
 	2000  4DWave DX
 	2001  4DWave NX
+		122d 1400  Trident PCI288-Q3DII (NX)
 	2100  CyberBlade XP4m32
 	8400  CyberBlade/i7
 		1023 8400  CyberBlade i7 AGP
@@ -1083,7 +1125,7 @@
 		0e11 b16e  CyberBlade i1 AGP
 		1023 8520  CyberBlade i1 AGP
 	8620  CyberBlade/i1
-		1014 0502  ThinkPad T30
+		1014 0502  ThinkPad R30/T30
 	8820  CyberBlade XPAi1
 	9320  TGUI 9320
 	9350  GUI Accelerator
@@ -1179,34 +1221,30 @@
 	5453  M5453 PCI AC-Link Controller Modem Device
 	7101  M7101 PCI PMU Power Management Controller
 		10b9 7101  M7101 PCI PMU Power Management Controller
-1028  Dell Computer Corporation
+1028  Dell
 	0001  PowerEdge Expandable RAID Controller 2/Si
-		1028 0001  PowerEdge Expandable RAID Controller 2/Si
-	0002  PowerEdge Expandable RAID Controller 3
-		1028 0002  PowerEdge Expandable RAID Controller 3/Di
-		1028 00d1  PowerEdge Expandable RAID Controller 3/Di
-		1028 00d9  PowerEdge Expandable RAID Controller 3/Di
+		1028 0001  PowerEdge 2400
+	0002  PowerEdge Expandable RAID Controller 3/Di
+		1028 0002  PowerEdge 4400
 	0003  PowerEdge Expandable RAID Controller 3/Si
-		1028 0003  PowerEdge Expandable RAID Controller 3/Si
-	0004  PowerEdge Expandable RAID Controller 3/Si
-		1028 00d0  PowerEdge Expandable RAID Controller 3/Si
+		1028 0003  PowerEdge 2450
 	0006  PowerEdge Expandable RAID Controller 3/Di
-	0007  Remote Access Controller:DRAC III
-	0008  Remote Access Controller
-	0009  BMC/SMIC device not present
-	000a  PowerEdge Expandable RAID Controller 3
-		1028 0106  PowerEdge Expandable RAID Controller 3/Di
-		1028 011b  PowerEdge Expandable RAID Controller 3/Di
-		1028 0121  PowerEdge Expandable RAID Controller 3/Di
-	000c  Remote Access Controller:ERA or ERA/O
-	000d  BMC/SMIC device
-	000e  PowerEdge Expandable RAID controller 4
-		1028 0123  PowerEdge Expandable RAID Controller 4/Di
-	000f  PowerEdge Expandable RAID controller 4
-		1028 013b  MegaRAID DELL PERC 4/Di RAID On Motherboard
-		1028 014a  PowerEdge Expandable RAID Controller 4/Di
-		1028 014c  MegaRAID DELL PERC 4/Di RAID On Motherboard
-		1028 014d  MegaRAID DELL PERC 4/Di RAID On Motherboard
+	0007  Remote Access Card III
+	0008  Remote Access Card III
+	0009  Remote Access Card III: BMC/SMIC device not present
+	000a  PowerEdge Expandable RAID Controller 3/Di
+	000c  Embedded Remote Access or ERA/O
+	000d  Embedded Remote Access: BMC/SMIC device
+	000e  PowerEdge Expandable RAID controller 4/Di
+	000f  PowerEdge Expandable RAID controller 4/Di
+	0010  Remote Access Card 4
+	0011  Remote Access Card 4 Daughter Card
+	0012  Remote Access Card 4 Daughter Card Virtual UART
+	0013  PowerEdge Expandable RAID controller 4
+		1028 016c  PowerEdge Expandable RAID Controller 4e/Si
+		1028 016d  PowerEdge Expandable RAID Controller 4e/Di
+		1028 016e  PowerEdge Expandable RAID Controller 4e/Di
+	0014  Remote Access Card 4 Daughter Card SMIC interface
 1029  Siemens Nixdorf IS
 102a  LSI Logic
 	0000  HYDRA
@@ -1542,6 +1580,7 @@
 		1092 4920  SpeedStar A70
 		1569 6326  SiS6326 GUI Accelerator
 	6330  661FX/M661FX/M661MX/741/M741/760/M760 PCI/AGP
+		1039 6330  [M]661FX/M661MX/[M]741/[M]760 PCI/AGP VGA Display Adapter
 	7001  USB 1.0 Controller
 		1039 7000  Onboard USB Controller
 	7002  USB 2.0 Controller
@@ -1604,7 +1643,7 @@
 		103c 1049  Tosca Console
 		103c 104a  Tosca Secondary
 		103c 104b  Maestro SP2
-		103c 1223  Halfdome Console
+		103c 1223  Superdome Console
 		103c 1226  Keystone SP2
 		103c 1227  Powerbar SP2
 		103c 1282  Everest SP2
@@ -1642,7 +1681,7 @@
 	4057  v8200 GeForce 3
 	8043  v8240 PAL 128M [P4T] Motherboard
 	807b  v9280/TD [Geforce4 TI4200 8X With TV-Out and DVI]
-1044  Distributed Processing Technology
+1044  Adaptec (formerly DPT)
 	1012  Domino RAID Engine
 	a400  SmartCache/Raid I-IV Controller
 	a500  PCI Bridge
@@ -1683,6 +1722,7 @@
 		1044 c065  3010S Ultra3 Four Channel
 		1044 c066  3010S Fibre Channel
 	a511  SmartRAID V Controller
+		1044 c032  ASR-2005S I2O Zero Channel
 1045  OPTi Inc.
 	a0f8  82C750 [Vendetta] USB Controller
 	c101  92C264
@@ -1786,6 +1826,7 @@
 		1028 00e6  PCI4451 IEEE-1394 Controller (Dell Inspiron 8100)
 	8029  PCI4510 IEEE-1394 Controller
 		1071 8160  MIM2900
+	802e  PCI7x20 1394a-2000 OHCI Two-Port PHY/Link-Layer Controller
 	8400  ACX 100 22Mbps Wireless Interface
 		00fc 16ec  U.S. Robotics 22 Mbps Wireless PC Card (model 2210)
 		00fd 16ec  U.S. Robotics 22Mbps Wireless PCI Adapter (model 2216)
@@ -1894,6 +1935,8 @@
 	0003  MPC8240 [Kahlua]
 	0004  MPC107
 	0006  MPC8245 [Unity]
+	0008  MPC8540
+	0009  MPC8560
 	0100  MC145575 [HFC-PCI]
 	0431  KTI829c 100VG
 	1801  DSP56301 Digital Signal Processor
@@ -1939,44 +1982,49 @@
 1058  Electronics & Telecommunications RSH
 1059  Teknor Industrial Computers Inc
 105a  Promise Technology, Inc.
-	0d30  20265
+# more correct description from promise linux sources
+	0d30  PDC20265 (FastTrak100 Lite/Ultra100)
 		105a 4d33  Ultra100
 	0d38  20263
 		105a 4d39  Fasttrak66
 	1275  20275
 	3318  PDC20318 (SATA150 TX4)
-	3319  PDC20319 (SATA150 TX4)
-	3373  PDC20378 (SATA150 TX)
+	3319  PDC20319 (FastTrak S150 TX4)
+		8086 3427  S875WP1-E mainboard
+	3371  PDC20371 (FastTrak S150 TX2plus)
+	3373  PDC20378 (FastTrak 378/SATA 378)
+		1043 80f5  PC-DL Deluxe motherboard
 		1462 702e  K8T NEO FIS2R motherboard
 	3375  PDC20375 (SATA150 TX2plus)
-	3376  PDC20376
+	3376  PDC20376 (FastTrak 376)
 		1043 809e  A7V8X motherboard
-	4d30  20267
+	4d30  PDC20267 (FastTrak100/Ultra100)
 		105a 4d33  Ultra100
-		105a 4d39  Fasttrak100
+		105a 4d39  FastTrak100
 	4d33  20246
 		105a 4d33  20246 IDE Controller
-	4d38  20262
+	4d38  PDC20262 (FastTrak66/Ultra66)
 		105a 4d30  Ultra Device on SuperTrak
 		105a 4d33  Ultra66
-		105a 4d39  Fasttrak66
-	4d68  20268
+		105a 4d39  FastTrak66
+	4d68  PDC20268 (Ultra100 TX2)
 		105a 4d68  Ultra100TX2
 	4d69  20269
 		105a 4d68  Ultra133TX2
-	5275  PDC20276 IDE
+	5275  PDC20276 (MBFastTrak133 Lite)
 		105a 0275  SuperTrak SX6000 IDE
 		105a 1275  MBFastTrak133 Lite (tm) Controller (RAID mode)
 		1458 b001  MBUltra 133
 	5300  DC5300
-	6268  20268R
-	6269  PDC20271
+	6268  PDC20270 (FastTrak100 LP/TX2/TX4)
+		105a 4d68  FastTrak100 TX2
+	6269  PDC20271 (FastTrak TX2000)
 		105a 6269  FastTrak TX2/TX2000
-	6621  PDC20621 [SX4000] 4 Channel IDE RAID Controller
+	6621  PDC20621 (FastTrak S150 SX4/FastTrak SX4000 lite)
 	6622  PDC20621 [SATA150 SX4] 4 Channel IDE RAID Controller
-	6626  PDC20618 Ultra 618
-	6629  PDC20619 FastTrak TX4000 RAID
-	7275  PDC20277
+	6626  PDC20618 (Ultra 618)
+	6629  PDC20619 (FastTrak TX4000)
+	7275  PDC20277 (SBFastTrak133 Lite)
 105b  Foxconn International, Inc.
 105c  Wipro Infotech Limited
 105d  Number 9 Computer Company
@@ -2199,6 +2247,7 @@
 107c  LG Electronics [Lucky Goldstar Co. Ltd]
 107d  LeadTek Research Inc.
 	0000  P86C850
+	2134  WinFast 3D S320 II
 107e  Interphase Corporation
 	0001  5515 ATM Adapter [Flipper]
 	0002  100 VG AnyLan Controller
@@ -2348,10 +2397,10 @@
 	0673  USB0673
 	0680  PCI0680 Ultra ATA-133 Host Controller
 		1095 3680  Winic W-680 (Silicon Image 680 based)
-	3112  Silicon Image Serial ATARaid Controller [ CMD/Sil 3112/3112A ]
+	3112  SiI 3112 [SATALink/SATARaid] Serial ATA Controller
 		1095 6112  Asus A7N8X
-	3114  Silicon Image SiI 3114 SATARaid
-	3512  Silicon Image Serial ATARaid Controller [ CMD/Sil 3512 ]
+	3114  SiI 3114 [SATALink/SATARaid] Serial ATA Controller
+	3512  SiI 3512 [SATALink/SATARaid] Serial ATA Controller
 1096  Alacron
 1097  Appian Technology
 1098  Quantum Designs (H.K.) Ltd
@@ -2742,6 +2791,7 @@
 		10b7 7000  10/100 Mini PCI Ethernet Adapter
 		10f1 2466  Tiger MPX S2466 (3C920 Integrated Fast Ethernet Controller)
 	9201  3C920B-EMB Integrated Fast Ethernet Controller [Tornado]
+		1043 80ab  A7N8X Deluxe onboard 3C920B-EMB Integrated Fast Ethernet Controller
 	9202  3Com 3C920B-EMB-WNM Integrated Fast Ethernet Controller
 	9210  3C920B-EMB-WNM Integrated Fast Ethernet Controller
 	9300  3CSOHO100B-TX 910-A01 [tulip]
@@ -2837,6 +2887,7 @@
 	5219  M5219
 	5225  M5225
 	5229  M5229 IDE
+		1014 050f  ThinkPad R30
 		1043 8053  A7A266 Motherboard IDE
 	5235  M5225
 	5237  USB 1.1 Controller
@@ -2859,8 +2910,8 @@
 	545a  SmartLink SmartPCI563 56K Modem
 	5471  M5471 Memory Stick Controller
 	5473  M5473 SD-MMC Controller
-	7101  M7101 PMU
-		10b9 7101  ALI M7101 Power Management Controller
+	7101  M7101 Power Management Controller [PMU]
+		1014 0510  ThinkPad R30
 10ba  Mitsubishi Electric Corp.
 	0301  AccelGraphics AccelECLIPSE
 	0304  AccelGALAXY A2100 [OEM Evans & Sutherland]
@@ -3001,6 +3052,7 @@
 		1043 0205  PCI-V3800
 		1043 4000  AGP-V3800PRO
 		1048 0c21  Synergy II
+		107d 2134  WinFast 3D S320 II + TV-Out
 		1092 4804  Viper V770
 		1092 4a00  Viper V770
 		1092 4a02  Viper V770 Ultra
@@ -3041,11 +3093,13 @@
 		1554 1041  Pixelview RIVA TNT2 M64
 	002e  NV6 [Vanta]
 	002f  NV6 [Vanta]
+	0041  NV40 OS1RT00B30
 	0060  nForce2 ISA Bridge
 		1043 80ad  A7N8X Mainboard
 	0064  nForce2 SMBus (MCP)
 	0065  nForce2 IDE
 	0066  nForce2 Ethernet Controller
+		1043 80a7  A7N8X Mainboard onboard nForce2 Ethernet
 	0067  nForce2 USB Controller
 		1043 0c11  A7N8X Mainboard
 	0068  nForce2 USB Controller
@@ -3292,6 +3346,7 @@
 		1071 8160  MIM2000
 		10bd 0320  EP-320X-R
 		10ec 8139  RT8139
+		1113 ec01  FNC-0107TX
 		1186 1300  DFE-538TX
 		1186 1320  SN5200
 		1186 8139  DRN-32TX
@@ -3342,7 +3397,7 @@
 10f9  PC Direct
 10fa  Truevision
 	000c  TARGA 1000
-10fb  Thesys Gesellschaft fÃ¼r Mikroelektronik mbH
+10fb  Thesys Gesellschaft für Mikroelektronik mbH
 	186f  TH 6255
 10fc  I-O Data Device, Inc.
 # What's in the cardbus end of a Sony ACR-A01 card, comes with newer Vaio CD-RW drives
@@ -3358,6 +3413,7 @@
 	9400  INI-940
 	9401  INI-950
 	9500  360P
+	9502  Initio INI-9100UW Ultra Wide SCSI Controller INIC-950P chip
 1102  Creative Labs
 	0002  SB Live! EMU10k1
 		1102 0020  CT4850 SBLive! Value
@@ -3507,13 +3563,16 @@
 		0e11 0097  SoundMax Digital Integrated Audio
 		0e11 b194  Soundmax integrated digital audio
 		1019 0985  P6VXA Motherboard
+		1043 1106  A7V133/A7V133-C Mainboard
 		1106 4511  Onboard Audio on EP7KXA
 		1458 7600  Onboard Audio
 		1462 3091  MS-6309 Onboard Audio
+		1462 3300  MS-6330 Onboard Audio
 		15dd 7609  Onboard Audio
 	3059  VT8233/A/8235/8237 AC97 Audio Controller
 		1019 0a81  L7VTA v1.0 Motherboard (KT400-8235)
 		1043 8095  A7V8X Motherboard (Realtek ALC650 codec)
+		1043 80a1  A7V8X-X Motherboard
 		1043 80b0  A7V600 motherboard (ADI AD1980 codec [SoundMAX])
 		1106 3059  L7VMM2 Motherboard
 		1297 c160  FX41 motherboard (Realtek ALC650 codec)
@@ -3526,6 +3585,7 @@
 		1186 1401  DFE-530TX rev B
 		13b9 1421  LD-10/100AL PCI Fast Ethernet Adapter (rev.B)
 	3068  Intel 537 [AC97 Modem]
+		1462 309e  MS-6309 Saturn Motherboard
 	3074  VT8233 PCI to ISA Bridge
 		1043 8052  VT8233A
 	3091  VT8633 [Apollo Pro266]
@@ -3906,7 +3966,15 @@
 		1133 1c0b  Diva Server V-PRI/T1-24 Cornet NQ 3
 		1133 1c0c  Diva Server V-PRI/E1-30 Cornet NQ 3
 	e01e  Diva Server 2PRI
+		1133 1e00  Diva Server V-2PRI/E1-60
+		1133 1e01  Diva Server V-2PRI/T1-48
+		1133 1e02  Diva Server 2PRI/E1-60
+		1133 1e03  Diva Server 2PRI/T1-48
 	e020  Diva Server 4PRI
+		1133 2000  Diva Server V-4PRI/E1-120
+		1133 2001  Diva Server V-4PRI/T1-96
+		1133 2002  Diva Server 4PRI/E1-120
+		1133 2003  Diva Server 4PRI/T1-96
 	e024  Diva Server Analog-4P
 	e028  Diva Server Analog-8P
 1134  Mercury Computer Systems
@@ -4145,6 +4213,7 @@
 1165  Imagraph Corporation
 	0001  Motion TPEG Recorder/Player with audio
 1166  ServerWorks
+	0000  CMIC-LE
 	0005  CNB20-LE Host Bridge
 	0006  CNB20HE Host Bridge
 	0007  CNB20-LE Host Bridge
@@ -4152,13 +4221,13 @@
 	0009  CNB20LE Host Bridge
 	0010  CIOB30
 	0011  CMIC-HE
-	0012  CMIC-LE
+	0012  CMIC-WS Host Bridge (GC-LE chipset)
 	0013  CNB20-HE Host Bridge
-	0014  CNB20-HE Host Bridge
+	0014  CMIC-LE Host Bridge (GC-LE chipset)
 	0015  CMIC-GC Host Bridge
 	0016  CMIC-GC Host Bridge
 	0017  GCNB-LE Host Bridge
-	0101  CIOB-X2
+	0101  CIOB-X2 PCI-X I/O Bridge
 	0110  CIOB-E I/O Bridge with Gigabit Ethernet
 	0200  OSB4 South Bridge
 	0201  CSB5 South Bridge
@@ -4255,6 +4324,7 @@
 		1186 1300  DFE-538TX 10/100 Ethernet Adapter
 		1186 1301  DFE-530TX+ 10/100 Ethernet Adapter
 	1340  DFE-690TXD CardBus PC Card
+	1541  DFE-680TXD CardBus PC Card
 	1561  DRP-32TXD Cardbus PC Card
 	3300  DWL-510 2.4GHz Wireless PCI Adapter
 	3b05  DWL-G650+ CardBus PC Card
@@ -4337,9 +4407,10 @@
 11a9  InnoSys Inc.
 	4240  AMCC S933Q Intelligent Serial Card
 11aa  Actel
-# (formerly Galileo technologies)
-11ab  Marvell
+# Formerly Galileo Technology, Inc.
+11ab  Marvell Technology Group Ltd.
 	0146  GT-64010/64010A System Controller
+	1fa6  Marvell W8300 802.11 Adapter
 	4320  Yukon Gigabit Ethernet 10/100/1000Base-T Adapter
 	4611  GT-64115 System Controller
 	4620  GT-64120/64120A/64121A System Controller
@@ -4677,6 +4748,7 @@
 	6933  OZ6933 Cardbus Controller
 		1025 1016  Travelmate 612 TX
 	6972  OZ6912 Cardbus Controller
+		1014 020c  ThinkPad R30
 		1179 0001  Magnia Z310
 	7110  OZ711Mx MultiMediaBay Accelerator
 	7112  OZ711EC1/M1 SmartCardBus MultiMediaBay Controller
@@ -4762,6 +4834,7 @@
 122c  Sican GmbH
 122d  Aztech System Ltd
 	1206  368DSP
+	1400  Trident PCI288-Q3DII (NX)
 	50dc  3328 Audio
 		122d 0001  3328 Audio
 	80da  3328 Audio
@@ -4905,11 +4978,15 @@
 	3873  Prism 2.5 Wavelan chipset
 		1186 3501  DWL-520 Wireless PCI Adapter
 		1186 3700  DWL-520 Wireless PCI Adapter, Rev E1
+		1385 4105  MA311 802.11b wireless adapter
 		1668 0414  HWP01170-01 802.11b PCI Wireless Adapter
 		16a5 1601  AIR.mate PC-400 PCI Wireless LAN Adapter
 		1737 3874  WMP11 Wireless 802.11b PCI Adapter
 		8086 2513  Wireless 802.11b MiniPCI Adapter
+	3886  ISL3886 [Prism Javelin/Prism Xbow]
 	3890  Intersil ISL3890 [Prism GT/Prism Duette]
+		10b8 a835  SMC2835W V2 Wireless Cardbus Adapter
+		16a5 1605  ALLNET ALL0271 Wireless PCI Adapter
 		17cf 0014  Ovislink WL-5400PCM, Prism GT
 	8130  HMP8130 NTSC/PAL Video Decoder
 	8131  HMP8131 NTSC/PAL Video Decoder
@@ -5155,7 +5232,7 @@
 	9132  Ethernet 100/10 MBit
 1283  Integrated Technology Express, Inc.
 	673a  IT8330G
-	8212  IT/ITE8212 Dual channel ATA RAID
+	8212  IT/ITE8212 Dual channel ATA RAID controller
 	8330  IT8330G
 	8872  IT8874F PCI Dual Serial Port Controller
 	8888  IT8888F PCI to ISA Bridge with SMB
@@ -5466,7 +5543,8 @@
 	0985  NC100 Network Everywhere Fast Ethernet 10/100
 	1985  21x4x DEC-Tulip compatible 10/100 Ethernet
 	2850  HSP MicroModem 56
-	8201  [ADMtek] SP906B_V2 Wireless LAN adapter
+	8201  ADMtek ADM8211 802.11b Wireless Interface
+		10b8 2635  SMC2635W 802.11b (11Mbps) wireless lan pcmcia (cardbus) card
 		1317 8201  SMC2635W 802.11b (11mbps) wireless lan pcmcia (cardbus) card
 	9511  21x4x DEC-Tulip compatible 10/100 Ethernet
 1318  Packet Engines Inc.
@@ -5535,7 +5613,6 @@
 132d  Integrated Silicon Solution, Inc.
 1330  MMC Networks
 1331  Radisys Corp.
-	0030  ENP-2611
 	8200  82600 Host Bridge
 	8201  82600 IDE
 	8202  82600 USB
@@ -5659,9 +5736,11 @@
 1385  Netgear
 	4100  802.11b Wireless Adapter (MA301)
 	4105  MA311 802.11b wireless adapter
+	4a00  WAG311 802.11abg Wireless Adapter
 	620a  GA620 Gigabit Ethernet
 	622a  GA622
 	630a  GA630 Gigabit Ethernet
+	f004  FA310TX
 1386  Video Domain Technologies
 1387  Systran Corp
 1388  Hitachi Information Technology Co Ltd
@@ -5720,6 +5799,7 @@
 13a6  Videonics Inc
 13a7  Teles AG
 13a8  Exar Corp.
+	0154  XR17C154 Quad UART
 	0158  XR17C158 Octal UART
 13a9  Siemens Medical Systems, Ultrasound Group
 13aa  Broadband Networks Inc
@@ -5752,6 +5832,7 @@
 13c1  3ware Inc
 	1000  3ware ATA-RAID
 	1001  3ware 7000-series ATA-RAID
+		13c1 1001  3ware Inc 3ware 7xxx/8xxx-series PATA/SATA-RAID
 	1002  3ware ATA-RAID
 13c2  Technotrend Systemtechnik GmbH
 13c3  Janz Computer AG
@@ -5884,10 +5965,11 @@
 140f  Salient Systems Corp
 1410  Midas lab Inc
 1411  Ikos Systems Inc
-1412  IC Ensemble Inc
-	1712  ICE1712 [Envy24]
+# formerly IC Ensemble Inc.
+1412  VIA Technologies Inc.
+	1712  ICE1712 [Envy24] PCI Multi-Channel I/O Controller
 		1412 d638  M-Audio Delta 410
-	1724  ICE1724 [Envy24HT]
+	1724  VT1720/24 [Envy24PT/HT] PCI Multi-Channel Audio Controller
 1413  Addonics
 1414  Microsoft Corporation
 1415  Oxford Semiconductor Ltd
@@ -5990,6 +6072,7 @@
 1460  DYNARC INC
 1461  Avermedia Technologies Inc
 1462  Micro-Star International Co., Ltd.
+	6825  PCI Card wireless 11g [PC54G]
 	8725  NVIDIA NV25 [GeForce4 Ti 4600] VGA Adapter
 # MSI G4Ti4800, 128MB DDR SDRAM, TV-Out, DVI-I
 	9000  NVIDIA NV28 [GeForce4 Ti 4800] VGA Adapter
@@ -6150,8 +6233,9 @@
 14d6  Accusys Inc
 14d7  Hirakawa Hewtech Corp
 14d8  HOPF Elektronik GmBH
-14d9  Alpha Processor Inc
-	0010  AP1011 HyperTransport-PCI Bridge [Sturgeon]
+# Formerly SiPackets, Inc., formerly API NetWorks, Inc., formerly Alpha Processor, Inc.
+14d9  Alliance Semiconductor Corporation
+	0010  AP1011/SP1011 HyperTransport-PCI Bridge [Sturgeon]
 14da  National Aerospace Laboratories
 14db  AFAVLAB Technology Inc
 	2120  TK9902
@@ -6175,6 +6259,14 @@
 14e2  INFOLIBRIA
 14e3  AMTELCO
 14e4  Broadcom Corporation
+	0800  Sentry5 Chipcommon I/O Controller
+	0804  Sentry5 PCI Bridge
+	0805  Sentry5 MIPS32 CPU
+	0806  Sentry5 Ethernet Controller
+	080b  Sentry5 Crypto Accelerator
+	080f  Sentry5 DDR/SDR RAM Controller
+	0811  Sentry5 External Interface Core
+	0816  BCM3302 Sentry5 MIPS32 CPU
 	1644  NetXtreme BCM5700 Gigabit Ethernet
 		1014 0277  Broadcom Vigil B5700 1000Base-T
 		1028 00d1  Broadcom BCM5700
@@ -6241,21 +6333,14 @@
 	164d  NetXtreme BCM5702FE Gigabit Ethernet
 	1653  NetXtreme BCM5705 Gigabit Ethernet
 	1654  NetXtreme BCM5705_2 Gigabit Ethernet
-	1658  NetXtreme BCM5720 Gigabit Ethernet
-	1659  NetXtreme BCM5721 Gigabit Ethernet
+	1659  NetXtreme BCM5721 Gigabit Ethernet PCI Express
 	165d  NetXtreme BCM5705M Gigabit Ethernet
 	165e  NetXtreme BCM5705M_2 Gigabit Ethernet
-	166e  NetXtreme BCM5705F Gigabit Ethernet
-	1676  NetXtreme BCM5750 Gigabit Ethernet
-	1677  NetXtreme BCM5751 Gigabit Ethernet
-	167c  NetXtreme BCM5750M Gigabit Ethernet
-	167d  NetXtreme BCM5751M Gigabit Ethernet
-	167e  NetXtreme BCM5751F Gigabit Ethernet
+	1677  NetXtreme BCM5751 Gigabit Ethernet PCI Express
 	1696  NetXtreme BCM5782 Gigabit Ethernet
 		103c 12bc  HP d530 CMT (DG746A)
 		14e4 000d  NetXtreme BCM5782 1000Base-T
 	169c  NetXtreme BCM5788 Gigabit Ethernet
-	169d  NetXtreme BCM5789 Gigabit Ethernet
 	16a6  NetXtreme BCM5702X Gigabit Ethernet
 		0e11 00bb  NC7760 Gigabit Server Adapter (PCI-X, 10/100/1000-T)
 		1028 0126  BCM5702 1000Base-T
@@ -6279,13 +6364,17 @@
 		103c 12ca  HP Combo FC/GigE-T [A9784A]
 		14e4 0009  NetXtreme BCM5703 1000Base-T
 		14e4 000a  NetXtreme BCM5703 1000Base-SX
-	170d  NetXtreme BCM5901 Gigabit Ethernet
-	170e  NetXtreme BCM5901_2 Gigabit Ethernet
+	170c  BCM4401-B0 100Base-TX
+	170d  NetXtreme BCM5901 100Base-TX
+	170e  NetXtreme BCM5901 100Base-TX
+	3352  BCM3352
+	3360  BCM3360
 	4210  BCM4210 iLine10 HomePNA 2.0
 	4211  BCM4211 iLine10 HomePNA 2.0 + V.90 56k modem
 	4212  BCM4212 v.90 56k modem
 	4301  BCM4301 802.11b
-	4320  BCM94306 802.11g
+	4307  BCM4307 802.11b Wireless LAN Controller
+	4320  BCM4306 802.11b/g Wireless LAN Controller
 		1028 0001  TrueMobile 1300 WLAN Mini-PCI Card
 		1737 4320  WPC54G
 	4324  BCM4309 802.11a/b/g
@@ -6293,12 +6382,47 @@
 	4401  BCM4401 100Base-T
 		1043 80a8  A7V8X motherboard
 	4402  BCM4402 Integrated 10/100BaseT
+	4403  BCM4402 V.90 56k Modem
 	4410  BCM4413 iLine32 HomePNA 2.0
 	4411  BCM4413 V.90 56k modem
 	4412  BCM4413 10/100BaseT
+	4430  BCM44xx CardBus iLine32 HomePNA 2.0
+	4432  BCM44xx CardBus 10/100BaseT
+	4610  BCM4610 Sentry5 PCI to SB Bridge
+	4611  BCM4610 Sentry5 iLine32 HomePNA 1.0
+	4612  BCM4610 Sentry5 V.90 56k Modem
+	4613  BCM4610 Sentry5 Ethernet Controller
+	4614  BCM4610 Sentry5 External Interface
+	4615  BCM4610 Sentry5 USB Controller
+	4704  BCM4704 PCI to SB Bridge
+	4708  BCM4708 Sentry5 PCI to SB Bridge
+	4710  BCM4710 Sentry5 PCI to SB Bridge
+	4711  BCM47xx Sentry5 iLine32 HomePNA 2.0
+	4712  Sentry5 UART
+	4713  Sentry5 Ethernet Controller
+	4714  BCM47xx Sentry5 External Interface
+	4715  Sentry5 USB Controller
+	4716  BCM47xx Sentry5 USB Host Controller
+	4717  BCM47xx Sentry5 USB Device Controller
+	4718  Sentry5 Crypto Accelerator
+	5365  BCM5365P Sentry5 Host Bridge
+	5600  BCM5600 StrataSwitch 24+2 Ethernet Switch Controller
+	5605  BCM5605 StrataSwitch 24+2 Ethernet Switch Controller
+	5615  BCM5615 StrataSwitch 24+2 Ethernet Switch Controller
+	5625  BCM5625 StrataSwitch 24+2 Ethernet Switch Controller
+	5645  BCM5645 StrataSwitch 24+2 Ethernet Switch Controller
+	5670  BCM5670 8-Port 10GE Ethernet Switch Fabric
+	5680  BCM5680 G-Switch 8 Port Gigabit Ethernet Switch Controller
 	5690  BCM5690 12-port Multi-Layer Gigabit Ethernet Switch
+	5691  BCM5691 GE/10GE 8+2 Gigabit Ethernet Switch Controller
 	5820  BCM5820 Crypto Accelerator
 	5821  BCM5821 Crypto Accelerator
+	5822  BCM5822 Crypto Accelerator
+	5823  BCM5823 Crypto Accelerator
+	5824  BCM5824 Crypto Accelerator
+	5840  BCM5840 Crypto Accelerator
+	5841  BCM5841 Crypto Accelerator
+	5850  BCM5850 Crypto Accelerator
 14e5  Pixelfusion Ltd
 14e6  SHINING Technology Inc
 14e7  3CX
@@ -6823,11 +6947,16 @@
 1619  FarSite Communications Ltd
 	0400  FarSync T2P (2 port X.21/V.35/V.24)
 	0440  FarSync T4P (4 port X.21/V.35/V.24)
+# www.rioworks.com
+161f  Rioworks
 1626  TDK Semiconductor Corp.
 	8410  RTL81xx Fast Ethernet
 1629  Kongsberg Spacetec AS
 	1003  Format synchronizer v3.0
 	2002  Fast Universal Data Output
+# This seems to occur on their 802.11b Wireless card WMP-11
+1637  Linksys
+	3874  Linksys 802.11b WMP11 PCI Wireless card
 1638  Standard Microsystems Corp [SMC]
 	1100  SMC2602W EZConnect/Addtron AWA-100/Eumitcom WL11000
 163c  Smart Link Ltd.
@@ -6862,6 +6991,7 @@
 		168c 0013  WG511T Wireless CardBus Adapter
 		168c 1025  DWL-G650B2 Wireless CardBus Adapter
 	1014  AR5212 802.11abg NIC
+16a5  Tekram Technology Co.,Ltd.
 16ab  Global Sun Technology Inc
 	1100  GL24110P
 	1101  PLX9052 PCMCIA-to-PCI Wireless LAN
@@ -6874,9 +7004,13 @@
 16cd  Densitron Technologies
 # www.pikatechnologies.com
 16df  PIKA Technologies Inc.
+16e3  European Space Agency
+	1e0f  LEON2FT Processor
 16ec  U.S. Robotics
 	00ff  USR997900 10/100 Mbps PCI Network Card
 	3685  Wireless Access PCI Adapter Model 022415
+16f4  Vweb Corp
+	8000  VW2010
 16f6  VideoTele.com, Inc.
 # www.internetmachines.com
 1702  Internet Machines Corporation (IMC)
@@ -6884,8 +7018,12 @@
 170b  NetOctave
 	0100  NSP2000-SSL crypto accelerator
 170c  YottaYotta Inc.
+# Seems to be a 2nd ID for Vitesse Semiconductor
+1725  Vitesse Semiconductor
+	7174  VSC7174 PCI/PCI-X Serial ATA Host Bus Controller
 172a  Accelerated Encryption
 1737  Linksys
+	0013  WMP54G Wireless Pci Card
 	1032  Gigabit Network Adapter
 		1737 0015  EG1032 v2 Instant Gigabit Network Adapter
 	1064  Gigabit Network Adapter
@@ -6914,10 +7052,12 @@
 	0004  CAMAC Controller
 	0005  PROFIBUS
 	0006  AMCC HOTlink
+1797  JumpTec h, GMBH
 1799  Belkin
 	6001  Wireless PCI Card - F5D6001
 	6020  Wireless PCMCIA Card - F5D6020
 	6060  Wireless PDA Card - F5D6060
+	7000  Wireless PCI Card - F5D7000
 17af  Hightech Information System Ltd.
 17b3  Hawking Technologies
 	ab08  PN672TX 10/100 Ethernet
@@ -6929,6 +7069,9 @@
 	2280  USB 2.0
 # S2io ships 10Gb PCI-X Ethernet adapters www.s2io.com
 17d5  S2io Inc.
+# Supplying full name for a currently green entry
+17fe  Linksys, A Division of Cisco Systems
+	2220  [AirConn] INPROCOMM IPN 2220 WLAN Adapter (rev 01)
 1813  Ambient Technologies Inc
 	4000  HaM controllerless modem
 		16be 0001  V9x HAM Data Fax Modem
@@ -6937,6 +7080,8 @@
 1814  RaLink
 	0101  Wireless PCI Adpator RT2400 / RT2460
 	0201  Ralink RT2500 802.11 Cardbus Reference Card
+1820  InfiniCon Systems Inc.
+1822  Twinhan Technology Co. Ltd
 1830  Credence Systems Corporation
 1851  Microtune, Inc.
 1852  Anritsu Corp.
@@ -6952,6 +7097,8 @@
 # found e.g. on KNC DVB-S card
 1894  KNC One
 18a1  Astute Networks Inc.
+18bc  Info-Tek Corp.
+18c9  ARVOO Engineering BV
 18ca  XGI - Xabre Graphics Inc
 	0040  Volari V8
 18e6  MPL AG
@@ -7018,6 +7165,7 @@
 	0008  GLINT Gamma G1
 	0009  Permedia II 2D+3D
 		1040 0011  AccelStar II
+		13e9 1000  6221L-4U
 		3d3d 0100  AccelStar II 3D Accelerator
 		3d3d 0111  Permedia 3:16
 		3d3d 0114  Santa Ana
@@ -7269,10 +7417,11 @@
 5555  Genroco, Inc
 	0003  TURBOstor HFP-832 [HiPPI NIC]
 5654  VoiceTronix Pty Ltd
+	3132  OpenSwitch12
 5700  Netpower
 5851  Exacq Technologies
 6356  UltraStor
-6374  c't Magazin fÃ¼r Computertechnik
+6374  c't Magazin für Computertechnik
 	6773  GPPCI
 6409  Logitec Corp.
 6666  Decision Computer International Co.
@@ -7292,6 +7441,8 @@
 		0008 1000  WorldMark 4300 INCA ASIC
 	0039  21145 Fast Ethernet
 	0122  82437FX
+	0309  80303 I/O Processor PCI-to-PCI Bridge
+	030d  80312 I/O Companion Chip PCI-to-PCI Bridge
 	0326  PCI Bridge Hub I/OxAPIC Interrupt Controller A
 	0327  PCI Bridge Hub I/OxAPIC Interrupt Controller B
 	0329  PCI Bridge Hub A
@@ -7315,13 +7466,38 @@
 	0340  41210 [Lanai] Serial to Parallel PCI Bridge
 # B-segment bridge
 	0341  41210 [Lanai] Serial to Parallel PCI Bridge
-	0482  82375EB
-	0483  82424ZX [Saturn]
-	0484  82378IB [SIO ISA Bridge]
-	0486  82430ZX [Aries]
-	04a3  82434LX [Mercury/Neptune]
+	0482  82375EB/SB PCI to EISA Bridge
+	0483  82424TX/ZX [Saturn] CPU to PCI bridge
+	0484  82378ZB/IB, 82379AB (SIO, SIO.A) PCI to ISA Bridge
+	0486  82425EX/ZX [Aries] PCIset with ISA bridge
+	04a3  82434LX/NX [Mercury/Neptune] Processor to PCI bridge
 	04d0  82437FX [Triton FX]
+	0500  E8870 Processor bus control
+	0501  E8870 Memory controller
+# and registers common to both SPs
+	0502  E8870 Scalability Port 0
+# and global performance monitoring
+	0503  E8870 Scalability Port 1
+	0510  E8870IO Hub Interface Port 0 registers (8-bit compatibility port)
+	0511  E8870IO Hub Interface Port 1 registers
+	0512  E8870IO Hub Interface Port 2 registers
+	0513  E8870IO Hub Interface Port 3 registers
+	0514  E8870IO Hub Interface Port 4 registers
+	0515  E8870IO General SIOH registers
+	0516  E8870IO RAS registers
+	0530  E8870SP Scalability Port 0 registers
+	0531  E8870SP Scalability Port 1 registers
+	0532  E8870SP Scalability Port 2 registers
+	0533  E8870SP Scalability Port 3 registers
+	0534  E8870SP Scalability Port 4 registers
+	0535  E8870SP Scalability Port 5 registers
+# (bi-interleave 0) and global registers that are neither per-port nor per-interleave
+	0536  E8870SP Interleave registers 0 and 1
+# (bi-interleave 1)
+	0537  E8870SP Interleave registers 2 and 3
 	0600  RAID Controller
+		8086 01c1  ICP Vortex GDT8546RZ
+		8086 01f7  SCRU32
 	0960  80960RP [i960 RP Microprocessor/Bridge]
 	0962  80960RM [i960RM Bridge]
 	0964  80960RP [i960 RP Microprocessor/Bridge]
@@ -7406,6 +7582,7 @@
 	1019  82547EI Gigabit Ethernet Controller (LOM)
 		1458 1019  GA-8IPE1000 Pro2 motherboard (865PE)
 		8086 1019  PRO/1000 CT Desktop Connection
+		8086 3427  S875WP1-E mainboard
 	101d  82546EB Gigabit Ethernet Controller
 		8086 1000  PRO/1000 MT Quad Port Server Adapter
 	101e  82540EP Gigabit Ethernet Controller (Mobile)
@@ -7453,13 +7630,16 @@
 		16be 1040  V.9X DSP Data Fax Modem
 	1043  PRO/Wireless LAN 2100 3B Mini PCI Adapter
 		8086 2527  MIM2000/Centrino
-	1048  Intel(R) PRO/10GbE LR Server Adapter
+	1048  PRO/10GbE LR Server Adapter
 		8086 a01f  PRO/10GbE LR Server Adapter
 		8086 a11f  PRO/10GbE LR Server Adapter
 	1050  82562EZ 10/100 Ethernet Controller
 		1462 728c  865PE Neo2 (MS-6728)
+		1462 758c  MS-6758 (875P Neo)
+		8086 3427  S875WP1-E mainboard
 	1051  82801EB/ER (ICH5/ICH5R) integrated LAN Controller
 	1059  82551QM Ethernet Controller
+	1065  82801FB/FBM/FR/FW/FRW (ICH6 Family) LAN Controller
 # Updated controller name from 82547EI to 82547GI
 	1075  82547GI Gigabit Ethernet Controller
 		8086 0075  PRO/1000 CT Network Connection
@@ -7516,8 +7696,8 @@
 		4c53 1050  CT7 mainboard
 		4c53 1051  CE7 mainboard
 		4c53 1070  PC6 mainboard
-	1221  82092AA_0
-	1222  82092AA_1
+	1221  82092AA PCI to PCMCIA Bridge
+	1222  82092AA IDE Controller
 	1223  SAA7116
 	1225  82452KX/GX [Orion]
 	1226  82596 PRO/10 PCI
@@ -7587,6 +7767,7 @@
 		1259 2560  AT-2560 100
 		1259 2561  AT-2560 100 FX Ethernet Adapter
 		1266 0001  NE10/100 Adapter
+		13e9 1000  6221L-4U
 		144d 2501  SEM-2000 MiniPCI LAN Adapter
 		144d 2502  SEM-2100IL MiniPCI LAN Adapter
 		1668 1100  EtherExpress PRO/100B (TX) (MiniPCI Ethernet+Modem)
@@ -7675,6 +7856,7 @@
 		8086 3010  EtherExpress PRO/100 S Network Connection
 		8086 3011  EtherExpress PRO/100 S Network Connection
 		8086 3012  EtherExpress PRO/100 Network Connection
+		8086 3411  SDS2 Mainboard
 	122d  430FX - 82437FX TSC [Triton I]
 	122e  82371FB PIIX ISA [Triton I]
 	1230  82371FB PIIX IDE [Triton I]
@@ -7682,13 +7864,15 @@
 	1234  430MX - 82371MX Mobile PCI I/O IDE Xcelerator (MPIIX)
 	1235  430MX - 82437MX Mob. System Ctrlr (MTSC) & 82438MX Data Path (MTDP)
 	1237  440FX - 82441FX PMC [Natoma]
-	1239  82371FB
-	123b  82380PB
-	123c  82380AB
+	1239  82371FB PIIX IDE Interface
+	123b  82380PB PCI to PCI Docking Bridge
+	123c  82380AB (MISA) Mobile PCI-to-ISA Bridge
 	123d  683053 Programmable Interrupt Device
+# in" hidden" mode
+	123e  82466GX (IHPC) Integrated Hot-Plug Controller
 	123f  82466GX Integrated Hot-Plug Controller (IHPC)
-	1240  752 AGP
-	124b  82380FB
+	1240  82752 (752) AGP Graphics Accelerator
+	124b  82380FB (MPCI2) Mobile Docking Controller
 	1250  430HX - 82439HX TXC [Triton II]
 	1360  82806AA PCI64 Hub PCI Bridge
 	1361  82806AA PCI64 Hub Controller (HRes)
@@ -7782,7 +7966,7 @@
 	2446  Intel 537 [82801BA/BAM AC'97 Modem]
 		1025 1016  Travelmate 612 TX
 		104d 80df  Vaio PCG-FX403
-	2448  82801BAM/CAM PCI Bridge
+	2448  82801 PCI Bridge
 	2449  82801BA/BAM/CA/CAM Ethernet Controller
 		0e11 0012  EtherExpress PRO/100 VM
 		0e11 0091  EtherExpress PRO/100 VE
@@ -7824,7 +8008,7 @@
 		8086 4532  D815EEA2 mainboard
 		8086 4557  D815EGEW Mainboard
 	244c  82801BAM ISA Bridge (LPC)
-	244e  82801BA/CA/DB/EB/ER Hub interface to PCI Bridge
+	244e  82801 PCI Bridge
 		1014 0267  NetVista A30p
 	2450  82801E ISA Bridge (LPC)
 	2452  82801E USB
@@ -7879,45 +8063,45 @@
 	248b  82801CA Ultra ATA Storage Controller
 		15d9 3480  P4DP6
 	248c  82801CAM ISA Bridge (LPC)
-	24c0  82801DB (ICH4) LPC Bridge
+	24c0  82801DB/DBL (ICH4/ICH4-L) LPC Bridge
 		1014 0267  NetVista A30p
 		1462 5800  845PE Max (MS-6580)
-	24c2  82801DB (ICH4) USB UHCI #1
+	24c2  82801DB/DBL/DBM (ICH4/ICH4-L/ICH4-M) USB UHCI Controller #1
 		1014 0267  NetVista A30p
 		1071 8160  MIM2000
 		1462 5800  845PE Max (MS-6580)
-	24c3  82801DB/DBM (ICH4) SMBus Controller
+	24c3  82801DB/DBL/DBM (ICH4/ICH4-L/ICH4-M) SMBus Controller
 		1014 0267  NetVista A30p
 		1071 8160  MIM2000
 		1458 24c2  GA-8PE667 Ultra
 		1462 5800  845PE Max (MS-6580)
 		4c53 1090  Cx9 / Vx9 mainboard
-	24c4  82801DB (ICH4) USB UHCI #2
+	24c4  82801DB/DBL/DBM (ICH4/ICH4-L/ICH4-M) USB UHCI Controller #2
 		1014 0267  NetVista A30p
 		1071 8160  MIM2000
 		1462 5800  845PE Max (MS-6580)
 		4c53 1090  Cx9 / Vx9 mainboard
-	24c5  82801DB (ICH4) AC'97 Audio Controller
+	24c5  82801DB/DBL/DBM (ICH4/ICH4-L/ICH4-M) AC'97 Audio Controller
 		0e11 00b8  Analog Devices Inc. codec [SoundMAX]
 		1014 0267  NetVista A30p
 		1071 8160  MIM2000
 		1458 a002  GA-8PE667 Ultra
 		1462 5800  845PE Max (MS-6580)
-	24c6  82801DB (ICH4) AC'97 Modem Controller
+	24c6  82801DB/DBL/DBM (ICH4/ICH4-L/ICH4-M) AC'97 Modem Controller
 		1071 8160  MIM2000
-	24c7  82801DB (ICH4) USB UHCI #3
+	24c7  82801DB/DBL/DBM (ICH4/ICH4-L/ICH4-M) USB UHCI Controller #3
 		1014 0267  NetVista A30p
 		1071 8160  MIM2000
 		1462 5800  845PE Max (MS-6580)
 	24ca  82801DBM (ICH4) Ultra ATA Storage Controller
 		1071 8160  MIM2000
-	24cb  82801DB (ICH4) Ultra ATA 100 Storage Controller
+	24cb  82801DB/DBL (ICH4/ICH4-L) UltraATA-100 IDE Controller
 		1014 0267  NetVista A30p
 		1458 24c2  GA-8PE667 Ultra
 		1462 5800  845PE Max (MS-6580)
 		4c53 1090  Cx9 / Vx9 mainboard
 	24cc  82801DBM LPC Interface Controller
-	24cd  82801DB (ICH4) USB2 EHCI Controller
+	24cd  82801DB/DBM (ICH4/ICH4-M) USB 2.0 EHCI Controller
 		1014 0267  NetVista A30p
 		1071 8160  MIM2000
 		1462 3981  845PE Max (MS-6580)
@@ -7927,19 +8111,23 @@
 		103c 12bc  d530 CMT (DG746A)
 		1458 24d1  GA-8IPE1000 Pro2 motherboard (865PE)
 		1462 7280  865PE Neo2 (MS-6728)
+		8086 3427  S875WP1-E mainboard
 	24d2  82801EB/ER (ICH5/ICH5R) USB UHCI #1
 		103c 12bc  d530 CMT (DG746A)
 		1043 80a6  P4P800 Mainboard
 		1462 7280  865PE Neo2 (MS-6728)
+		8086 3427  S875WP1-E mainboard
 	24d3  82801EB/ER (ICH5/ICH5R) SMBus Controller
 		1043 80a6  P4P800 Mainboard
 		1458 24d2  GA-8IPE1000 Pro2 motherboard (865PE)
 		1462 7280  865PE Neo2 (MS-6728)
+		8086 3427  S875WP1-E mainboard
 	24d4  82801EB/ER (ICH5/ICH5R) USB UHCI #2
 		103c 12bc  d530 CMT (DG746A)
 		1043 80a6  P4P800 Mainboard
 		1458 24d2  GA-8IPE1000 Pro2 motherboard (865PE)
 		1462 7280  865PE Neo2 (MS-6728)
+		8086 3427  S875WP1-E mainboard
 	24d5  82801EB/ER (ICH5/ICH5R) AC'97 Audio Controller
 		103c 12bc  Analog Devices codec [SoundMAX Integrated Digital Audio]
 		1043 80f3  P4P800 Mainboard
@@ -7950,22 +8138,26 @@
 		1043 80a6  P4P800 Mainboard
 		1458 24d2  GA-8IPE1000 Pro2 motherboard (865PE)
 		1462 7280  865PE Neo2 (MS-6728)
+		8086 3427  S875WP1-E mainboard
 	24db  82801EB/ER (ICH5/ICH5R) Ultra ATA 100 Storage Controller
 		103c 12bc  d530 CMT (DG746A)
 		1043 80a6  P4P800 Mainboard
 		1458 24d2  GA-8IPE1000 Pro2 motherboard (865PE)
 		1462 7280  865PE Neo2 (MS-6728)
 		1462 7580  MSI 875P
+		8086 3427  S875WP1-E mainboard
 	24dc  82801EB LPC Interface Controller
 	24dd  82801EB/ER (ICH5/ICH5R) USB2 EHCI Controller
 		103c 12bc  d530 CMT (DG746A)
 		1043 80a6  P4P800 Mainboard
 		1458 5006  GA-8IPE1000 Pro2 motherboard (865PE)
 		1462 7280  865PE Neo2 (MS-6728)
+		8086 3427  S875WP1-E mainboard
 	24de  82801EB/ER (ICH5/ICH5R) USB UHCI #4
 		1043 80a6  P4P800 Mainboard
 		1458 24d2  GA-8IPE1000 Pro2 motherboard (865PE)
 		1462 7280  865PE Neo2 (MS-6728)
+		8086 3427  S875WP1-E mainboard
 	24df  82801EB (ICH5R) SATA (cc=RAID)
 	2500  82820 820 (Camino) Chipset Host Bridge (MCH)
 		1028 0095  Precision Workstation 220 Chipset
@@ -7984,23 +8176,23 @@
 	2534  82860 860 (Wombat) Chipset PCI Bridge
 	2540  E7500 Memory Controller Hub
 		15d9 3480  P4DP6
-	2541  E7000 Series Host RASUM Controller
+	2541  E7500/E7501 Host RASUM Controller
 		15d9 3480  P4DP6
 		4c53 1090  Cx9 / Vx9 mainboard
-	2543  E7000 Series Hub Interface B PCI-to-PCI Bridge
-	2544  E7000 Series Hub Interface B RASUM Controller
+	2543  E7500/E7501 Hub Interface B PCI-to-PCI Bridge
+	2544  E7500/E7501 Hub Interface B RASUM Controller
 		4c53 1090  Cx9 / Vx9 mainboard
-	2545  E7000 Series Hub Interface C PCI-to-PCI Bridge
-	2546  E7000 Series Hub Interface C RASUM Controller
-	2547  E7000 Series Hub Interface D PCI-to-PCI Bridge
-	2548  E7000 Series Hub Interface D RASUM Controller
+	2545  E7500/E7501 Hub Interface C PCI-to-PCI Bridge
+	2546  E7500/E7501 Hub Interface C RASUM Controller
+	2547  E7500/E7501 Hub Interface D PCI-to-PCI Bridge
+	2548  E7500/E7501 Hub Interface D RASUM Controller
 	254c  E7501 Memory Controller Hub
 		4c53 1090  Cx9 / Vx9 mainboard
 	2550  E7505 Memory Controller Hub
-	2551  E7000 Series RAS Controller
-	2552  E7000 Series Processor to AGP Controller
-	2553  E7000 Series Hub Interface B PCI-to-PCI Bridge
-	2554  E7000 Series Hub Interface B PCI-to-PCI Bridge RAS Controller
+	2551  E7505/E7205 Series RAS Controller
+	2552  E7505/E7205 PCI-to-AGP Bridge
+	2553  E7505 Hub Interface B PCI-to-PCI Bridge
+	2554  E7505 Hub Interface B PCI-to-PCI Bridge RAS Controller
 	255d  E7205 Memory Controller Hub
 	2560  82845G/GL[Brookdale-G]/GE/PE DRAM Controller/Host-Hub Interface
 		1458 2560  GA-8PE667 Ultra
@@ -8022,14 +8214,17 @@
 	2579  82875P Processor to AGP Controller
 	257b  82875P Processor to PCI to CSA Bridge
 	257e  82875P Processor to I/O Memory Interface
-	2580  Memory Controller Hub
-	2581  Memory Controller Hub PCI Express Port
-	2582  Graphics Controller
-	2584  Workstation Memory Controller Hub
-	2585  Workstation Memory Controller Hub PCI Express Port
+	2580  915G/P/GV Processor to I/O Controller
+	2581  915G/P/GV PCI Express Root Port
+	2582  82915G Express Chipset Family Graphics Controller
+	2584  925X Memory Controller Hub
+	2585  925X PCI Express Root Port
 	2588  Server Memory Controller Hub
 	2589  Server Memory Controller Hub PCI Express Port
 	258a  Graphics Controller
+	2590  Mobile Memory Controller Hub
+	2591  Mobile Memory Controller Hub PCI Express Port
+	2592  Mobile Graphics Controller
 	25a1  6300ESB LPC Interface Controller
 	25a2  6300ESB PATA Storage Controller
 	25a3  6300ESB SATA Storage Controller
@@ -8043,26 +8238,63 @@
 	25ad  6300ESB USB2 Enhanced Host Controller
 	25ae  6300ESB 64-bit PCI-X Bridge
 	25b0  6300ESB SATA RAID Controller
-	2640  I/O Controller Hub LPC
-	2641  I/O Controller Hub LPC
-	2642  I/O Controller Hub LPC
-	2651  I/O Controller Hub SATA cc=ide
-	2652  I/O Controller Hub SATA cc=raid
-	2658  I/O Controller Hub USB
-	2659  I/O Controller Hub USB
-	265a  I/O Controller Hub USB
-	265b  I/O Controller Hub USB
-	265c  I/O Controller Hub USB2
-	2660  I/O Controller Hub PCI Express Port 0
-	2662  I/O Controller Hub PCI Express Port 1
-	2664  I/O Controller Hub PCI Express Port 2
-	2666  I/O Controller Hub PCI Express Port 3
-	2668  I/O Controller Hub Audio
-	266a  I/O Controller Hub SMBus
-	266d  I/O Controller Hub Modem
-	266e  I/O Controller Hub Audio
-	266f  I/O Controller Hub PATA
-	2782  Graphics Controller
+	2600  Server Hub Interface
+	2601  Server Hub PCI Express x4 Port D
+	2602  Server Hub PCI Express x4 Port C0
+	2603  Server Hub PCI Express x4 Port C1
+	2604  Server Hub PCI Express x4 Port B0
+	2605  Server Hub PCI Express x4 Port B1
+	2606  Server Hub PCI Express x4 Port A0
+	2607  Server Hub PCI Express x4 Port A1
+	2608  Server Hub PCI Express x8 Port C
+	2609  Server Hub PCI Express x8 Port B
+	260a  Server Hub PCI Express x8 Port A
+	260c  Server Hub IMI Registers
+	2610  Server Hub System Bus, Boot, and Interrupt Registers
+	2611  Server Hub Address Mapping Registers
+	2612  Server Hub RAS Registers
+	2613  Server Hub Performance Monitoring Registers
+	2614  Server Hub Performance Monitoring Registers
+	2615  Server Hub Performance Monitoring Registers
+	2617  Server Hub Debug Registers
+	2618  Server Hub Debug Registers
+	2619  Server Hub Debug Registers
+	261a  Server Hub Debug Registers
+	261b  Server Hub Debug Registers
+	261c  Server Hub Debug Registers
+	261d  Server Hub Debug Registers
+	261e  Server Hub Debug Registers
+	2620  External Memory Bridge
+	2621  External Memory Bridge Control Registers
+	2622  External Memory Bridge Memory Interleaving Registers
+	2623  External Memory Bridge DDR Initialization and Calibration
+	2624  External Memory Bridge Reserved Registers
+	2625  External Memory Bridge Reserved Registers
+	2626  External Memory Bridge Reserved Registers
+	2627  External Memory Bridge Reserved Registers
+	2640  82801FB/FR (ICH6/ICH6R) LPC Interface Bridge
+	2641  82801FBM (ICH6M) LPC Interface Bridge
+	2642  82801FW/FRW (ICH6W/ICH6RW) LPC Interface Bridge
+	2651  82801FB/FW (ICH6/ICH6W) SATA Controller
+	2652  82801FR/FRW (ICH6R/ICH6RW) SATA Controller
+	2653  82801FBM (ICH6M) SATA Controller
+	2658  82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #1
+	2659  82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #2
+	265a  82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #3
+	265b  82801FB/FBM/FR/FW/FRW (ICH6 Family) USB UHCI #4
+	265c  82801FB/FBM/FR/FW/FRW (ICH6 Family) USB2 EHCI Controller
+	2660  82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 1
+	2662  82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 2
+	2664  82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 3
+	2666  82801FB/FBM/FR/FW/FRW (ICH6 Family) PCI Express Port 4
+	2668  82801FB/FBM/FR/FW/FRW (ICH6 Family) High Definition Audio Controller
+	266a  82801FB/FBM/FR/FW/FRW (ICH6 Family) SMBus Controller
+	266c  82801FB/FBM/FR/FW/FRW (ICH6 Family) LAN Controller
+	266d  82801FB/FBM/FR/FW/FRW (ICH6 Family) AC'97 Modem Controller
+	266e  82801FB/FBM/FR/FW/FRW (ICH6 Family) AC'97 Audio Controller
+	266f  82801FB/FBM/FR/FW/FRW (ICH6 Family) IDE Controller
+	2782  82915G Express Chipset Family Graphics Controller
+	2792  Mobile Graphics Controller
 	3092  Integrated RAID
 	3200  GD31244 PCI-X SATA HBA
 	3340  82855PM Processor to I/O Controller
@@ -8092,7 +8324,7 @@
 	359a  Memory Controller Hub PCI Express Port C1
 	359b  Memory Controller Hub Extended Configuration Registers
 	359e  Workstation Memory Controller Hub
-	4220  Intel(R) PRO/Wireless 2200BG
+	4220  PRO/Wireless 2200BG
 	5200  EtherExpress PRO/100 Intelligent Server
 	5201  EtherExpress PRO/100 Intelligent Server
 		8086 0001  EtherExpress PRO/100 Server Ethernet Adapter
@@ -8155,7 +8387,7 @@
 	7601  82372FB PIIX5 IDE
 	7602  82372FB PIIX5 USB
 	7603  82372FB PIIX5 SMBus
-	7800  i740
+	7800  82740 (i740) AGP Graphics Accelerator
 		003d 0008  Starfighter AGP
 		003d 000b  Starfighter AGP
 		1092 0100  Stealth II G460
@@ -8175,7 +8407,9 @@
 	84e6  460GX - 82466GX Wide and fast PCI eXpander Bridge (WXB)
 	84ea  460GX - 84460GX AGP Bridge (GXB function 1)
 	8500  IXP4xx Family  Network Processor (IXP420, 421, 422, 425 and IXC1100)
-	9000  Intel IXP2000 Familly Network Processor
+	9000  Intel IXP2000 Family Network Processor
+	9001  Intel IXP2400 Network Processor
+	9004  Intel IXP2800 Network Processor
 	9621  Integrated RAID
 	9622  Integrated RAID
 	9641  Integrated RAID
@@ -8184,10 +8418,12 @@
 # observed, and documented in Intel revision note; new mask of 1011:0026
 	b154  21154 PCI-to-PCI Bridge
 	b555  21555 Non transparent PCI-to-PCI Bridge
+		1331 0030  Radisys ENP-2611
 		4c53 1050  CT7 mainboard
 		4c53 1051  CE7 mainboard
 		e4bf 1000  CC8-1-BLUES
 	ffff  450NX/GX [Orion] - 82453KX/GX Memory controller [BUG]
+8401  TRENDware International Inc.
 8800  Trigem Computer Inc.
 	2008  Video assistent component
 8866  T-Square Design Inc.
@@ -8352,15 +8588,18 @@
 	00c1  AIC-7899B U160/m
 	00c3  AIC-7899D U160/m
 	00c5  RAID subsystem HBA
-		1028 00c5  PowerEdge 2550
+		1028 00c5  PowerEdge 2400,2500,2550,4400
 	00cf  AIC-7899P U160/m
 		1028 00ce  PowerEdge 1400
 		1028 00d1  PowerEdge 2550
 		10f1 2462  Thunder K7 S2462
 		15d9 9005  Onboard SCSI Host Adapter
+		8086 3411  SDS2 Mainboard
 	0250  ServeRAID Controller
 		1014 0279  ServeRAID-xx
 		1014 028c  ServeRAID-xx
+# from kernel sources
+	0279  ServeRAID 6M
 	0283  AAC-RAID
 		9005 0283  Catapult
 	0284  AAC-RAID
@@ -8429,7 +8668,7 @@
 		1000 0012  1P2S
 	9845  PCI 9845 Multi-I/O Controller
 		1000 0006  0P6S (6 port 16550a serial card)
-	9855  PCI 9855 Multi-I/O Controller 4 Serial 1 Parallel
+	9855  PCI 9855 Multi-I/O Controller
 		1000 0014  1P4S
 9902  Stargen Inc.
 	0001  SG2010 PCI over Starfabric Bridge
@@ -8444,6 +8683,7 @@
 a727  3Com Corporation
 aa42  Scitex Digital Video
 ac1e  Digital Receiver Technology Inc
+aecb  Adrienne Electronics Corporation
 b1b3  Shiva Europe Limited
 # Pinnacle should be 11bd, but they got it wrong several times --mj
 bd11  Pinnacle Systems, Inc. (Wrong ID)
@@ -8464,9 +8704,9 @@
 dead  Indigita Corporation
 e000  Winbond
 	e000  W89C940
-# see : http://www.schoenfeld.de/inside/Inside_CWMK3.txt
-e159  Individual Computers - Jens Schoenfeld
-	0001  Intel 537
+# see also : http://www.schoenfeld.de/inside/Inside_CWMK3.txt maybe a misuse of TJN id or it use the TJN 3XX chip for other applic
+e159  Tiger Jet Network Inc.
+	0001  Tiger3XX Modem/ISDN interface
 		0059 0001  128k ISDN-S/T Adapter
 		0059 0003  128k ISDN-U Adapter
 	0002  Tiger100APC ISDN chipset
Index: xx-sources/drivers/pci/probe.c
===================================================================
--- xx-sources.orig/drivers/pci/probe.c	2004-08-14 01:37:26.000000000 -0400
+++ xx-sources/drivers/pci/probe.c	2004-08-14 13:17:24.784768576 -0400
@@ -640,7 +640,7 @@
 		return NULL;
 	
 	/* Fix up broken headers */
-	pci_fixup_device(PCI_FIXUP_HEADER, dev);
+	pci_fixup_device(pci_fixup_header, dev);
 
 	/*
 	 * Add the device to our list of discovered devices
Index: xx-sources/drivers/pci/quirks.c
===================================================================
--- xx-sources.orig/drivers/pci/quirks.c	2004-08-14 01:36:12.000000000 -0400
+++ xx-sources/drivers/pci/quirks.c	2004-08-14 13:17:52.049623688 -0400
@@ -1,10 +1,10 @@
 /*
- * $Id: quirks.c,v 1.5 1998/05/02 19:24:14 mj Exp $
- *
  *  This file contains work-arounds for many known PCI hardware
  *  bugs.  Devices present only on certain architectures (host
  *  bridges et cetera) should be handled in arch-specific code.
  *
+ *  Note: any quirks for hotpluggable devices must _NOT_ be declared __init.
+ *
  *  Copyright (c) 1999 Martin Mares <mj@ucw.cz>
  *
  *  The bridge optimization stuff has been removed. If you really
@@ -39,6 +39,7 @@
 		}
 	}
 }
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82441,	quirk_passive_release );
 
 /*  The VIA VP2/VP3/MVP3 seem to have some 'features'. There may be a workaround
     but VIA don't answer queries. If you happen to have good contacts at VIA
@@ -46,8 +47,6 @@
     
     This appears to be BIOS not version dependent. So presumably there is a 
     chipset level fix */
-    
-
 int isa_dma_bridge_buggy;		/* Exported */
     
 static void __devinit quirk_isa_dma_hangs(struct pci_dev *dev)
@@ -57,34 +56,47 @@
 		printk(KERN_INFO "Activating ISA DMA hang workarounds.\n");
 	}
 }
+	/*
+	 * Its not totally clear which chipsets are the problematic ones
+	 * We know 82C586 and 82C596 variants are affected.
+	 */
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C586_0,	quirk_isa_dma_hangs );
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C596,	quirk_isa_dma_hangs );
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82371SB_0,  quirk_isa_dma_hangs );
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AL,	PCI_DEVICE_ID_AL_M1533, 	quirk_isa_dma_hangs );
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_NEC,	PCI_DEVICE_ID_NEC_CBUS_1,	quirk_isa_dma_hangs );
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_NEC,	PCI_DEVICE_ID_NEC_CBUS_2,	quirk_isa_dma_hangs );
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_NEC,	PCI_DEVICE_ID_NEC_CBUS_3,	quirk_isa_dma_hangs );
 
 int pci_pci_problems;
 
 /*
  *	Chipsets where PCI->PCI transfers vanish or hang
  */
-
 static void __devinit quirk_nopcipci(struct pci_dev *dev)
 {
-	if((pci_pci_problems&PCIPCI_FAIL)==0)
-	{
+	if ((pci_pci_problems & PCIPCI_FAIL)==0) {
 		printk(KERN_INFO "Disabling direct PCI/PCI transfers.\n");
-		pci_pci_problems|=PCIPCI_FAIL;
+		pci_pci_problems |= PCIPCI_FAIL;
 	}
 }
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_SI,	PCI_DEVICE_ID_SI_5597,		quirk_nopcipci );
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_SI,	PCI_DEVICE_ID_SI_496,		quirk_nopcipci );
 
 /*
  *	Triton requires workarounds to be used by the drivers
  */
- 
 static void __devinit quirk_triton(struct pci_dev *dev)
 {
-	if((pci_pci_problems&PCIPCI_TRITON)==0)
-	{
+	if ((pci_pci_problems&PCIPCI_TRITON)==0) {
 		printk(KERN_INFO "Limiting direct PCI/PCI transfers.\n");
-		pci_pci_problems|=PCIPCI_TRITON;
+		pci_pci_problems |= PCIPCI_TRITON;
 	}
 }
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 	PCI_DEVICE_ID_INTEL_82437, 	quirk_triton );
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 	PCI_DEVICE_ID_INTEL_82437VX, 	quirk_triton );
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 	PCI_DEVICE_ID_INTEL_82439, 	quirk_triton );
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 	PCI_DEVICE_ID_INTEL_82439TX, 	quirk_triton );
 
 /*
  *	VIA Apollo KT133 needs PCI latency patch
@@ -104,19 +116,16 @@
 	/* Ok we have a potential problem chipset here. Now see if we have
 	   a buggy southbridge */
 	   
-	p=pci_find_device(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_82C686, NULL);
-	if(p!=NULL)
-	{
+	p = pci_find_device(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_82C686, NULL);
+	if (p!=NULL) {
 		pci_read_config_byte(p, PCI_CLASS_REVISION, &rev);
 		/* 0x40 - 0x4f == 686B, 0x10 - 0x2f == 686A; thanks Dan Hollis */
 		/* Check for buggy part revisions */
 		if (rev < 0x40 || rev > 0x42) 
 			return;
-	}
-	else
-	{
+	} else {
 		p = pci_find_device(PCI_VENDOR_ID_VIA, PCI_DEVICE_ID_VIA_8231, NULL);
-		if(p==NULL)	/* No problem parts */
+		if (p==NULL)	/* No problem parts */
 			return;
 		pci_read_config_byte(p, PCI_CLASS_REVISION, &rev);
 		/* Check for buggy part revisions */
@@ -145,27 +154,30 @@
 	pci_write_config_byte(dev, 0x76, busarb);
 	printk(KERN_INFO "Applying VIA southbridge workaround.\n");
 }
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_8363_0,	quirk_vialatency );
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_8371_1,	quirk_vialatency );
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_8361,		quirk_vialatency );
 
 /*
  *	VIA Apollo VP3 needs ETBF on BT848/878
  */
- 
 static void __devinit quirk_viaetbf(struct pci_dev *dev)
 {
-	if((pci_pci_problems&PCIPCI_VIAETBF)==0)
-	{
+	if ((pci_pci_problems&PCIPCI_VIAETBF)==0) {
 		printk(KERN_INFO "Limiting direct PCI/PCI transfers.\n");
-		pci_pci_problems|=PCIPCI_VIAETBF;
+		pci_pci_problems |= PCIPCI_VIAETBF;
 	}
 }
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C597_0,	quirk_viaetbf );
+
 static void __devinit quirk_vsfx(struct pci_dev *dev)
 {
-	if((pci_pci_problems&PCIPCI_VSFX)==0)
-	{
+	if ((pci_pci_problems&PCIPCI_VSFX)==0) {
 		printk(KERN_INFO "Limiting direct PCI/PCI transfers.\n");
-		pci_pci_problems|=PCIPCI_VSFX;
+		pci_pci_problems |= PCIPCI_VSFX;
 	}
 }
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C576,	quirk_vsfx );
 
 /*
  *	Ali Magik requires workarounds to be used by the drivers
@@ -173,36 +185,38 @@
  *	workaround applied too
  *	[Info kindly provided by ALi]
  */	
- 
 static void __init quirk_alimagik(struct pci_dev *dev)
 {
-	if((pci_pci_problems&PCIPCI_ALIMAGIK)==0)
-	{
+	if ((pci_pci_problems&PCIPCI_ALIMAGIK)==0) {
 		printk(KERN_INFO "Limiting direct PCI/PCI transfers.\n");
-		pci_pci_problems|=PCIPCI_ALIMAGIK|PCIPCI_TRITON;
+		pci_pci_problems |= PCIPCI_ALIMAGIK|PCIPCI_TRITON;
 	}
 }
-
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AL, 	PCI_DEVICE_ID_AL_M1647, 	quirk_alimagik );
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AL, 	PCI_DEVICE_ID_AL_M1651, 	quirk_alimagik );
 
 /*
  *	Natoma has some interesting boundary conditions with Zoran stuff
  *	at least
  */
- 
 static void __devinit quirk_natoma(struct pci_dev *dev)
 {
-	if((pci_pci_problems&PCIPCI_NATOMA)==0)
-	{
+	if ((pci_pci_problems&PCIPCI_NATOMA)==0) {
 		printk(KERN_INFO "Limiting direct PCI/PCI transfers.\n");
-		pci_pci_problems|=PCIPCI_NATOMA;
+		pci_pci_problems |= PCIPCI_NATOMA;
 	}
 }
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 	PCI_DEVICE_ID_INTEL_82441, 	quirk_natoma );
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 	PCI_DEVICE_ID_INTEL_82443LX_0, 	quirk_natoma );
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 	PCI_DEVICE_ID_INTEL_82443LX_1, 	quirk_natoma );
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 	PCI_DEVICE_ID_INTEL_82443BX_0, 	quirk_natoma );
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 	PCI_DEVICE_ID_INTEL_82443BX_1, 	quirk_natoma );
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL, 	PCI_DEVICE_ID_INTEL_82443BX_2, 	quirk_natoma );
 
 /*
  *  S3 868 and 968 chips report region size equal to 32M, but they decode 64M.
  *  If it's needed, re-allocate the region.
  */
-
 static void __devinit quirk_s3_64M(struct pci_dev *dev)
 {
 	struct resource *r = &dev->resource[0];
@@ -212,6 +226,8 @@
 		r->end = 0x3ffffff;
 	}
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_S3,	PCI_DEVICE_ID_S3_868,		quirk_s3_64M );
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_S3,	PCI_DEVICE_ID_S3_968,		quirk_s3_64M );
 
 static void __devinit quirk_io_region(struct pci_dev *dev, unsigned region, unsigned size, int nr)
 {
@@ -231,7 +247,6 @@
  *	ATI Northbridge setups MCE the processor if you even
  *	read somewhere between 0x3b0->0x3bb or read 0x3d3
  */
- 
 static void __devinit quirk_ati_exploding_mce(struct pci_dev *dev)
 {
 	printk(KERN_INFO "ATI Northbridge, reserving I/O ports 0x3b0 to 0x3bb.\n");
@@ -239,6 +254,7 @@
 	request_region(0x3b0, 0x0C, "RadeonIGP");
 	request_region(0x3d3, 0x01, "RadeonIGP");
 }
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_ATI,	PCI_DEVICE_ID_ATI_RS100,   quirk_ati_exploding_mce );
 
 /*
  * Let's make the southbridge information explicit instead
@@ -260,6 +276,7 @@
 	pci_read_config_word(dev, 0xE2, &region);
 	quirk_io_region(dev, region, 32, PCI_BRIDGE_RESOURCES+1);
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_AL,	PCI_DEVICE_ID_AL_M7101,		quirk_ali7101_acpi );
 
 /*
  * PIIX4 ACPI: Two IO regions pointed to by longwords at
@@ -275,6 +292,7 @@
 	pci_read_config_dword(dev, 0x90, &region);
 	quirk_io_region(dev, region, 32, PCI_BRIDGE_RESOURCES+1);
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82371AB_3,	quirk_piix4_acpi );
 
 /*
  * ICH4, ICH4-M, ICH5, ICH5-M ACPI: Three IO regions pointed to by longwords at
@@ -291,6 +309,15 @@
 	pci_read_config_dword(dev, 0x58, &region);
 	quirk_io_region(dev, region, 64, PCI_BRIDGE_RESOURCES+1);
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82801AA_0,		quirk_ich4_lpc_acpi );
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82801AB_0,		quirk_ich4_lpc_acpi );
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82801BA_0,		quirk_ich4_lpc_acpi );
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82801BA_10,	quirk_ich4_lpc_acpi );
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82801CA_0,		quirk_ich4_lpc_acpi );
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82801CA_12,	quirk_ich4_lpc_acpi );
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82801DB_0,		quirk_ich4_lpc_acpi );
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82801DB_12,	quirk_ich4_lpc_acpi );
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82801EB_0,		quirk_ich4_lpc_acpi );
 
 /*
  * VIA ACPI: One IO region pointed to by longword at
@@ -308,6 +335,7 @@
 		quirk_io_region(dev, region, 256, PCI_BRIDGE_RESOURCES);
 	}
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C586_3,	quirk_vt82c586_acpi );
 
 /*
  * VIA VT82C686 ACPI: Three IO region pointed to by (long)words at
@@ -330,6 +358,7 @@
 	smb &= PCI_BASE_ADDRESS_IO_MASK;
 	quirk_io_region(dev, smb, 16, PCI_BRIDGE_RESOURCES + 2);
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C686_4,	quirk_vt82c686_acpi );
 
 
 #ifdef CONFIG_X86_IO_APIC 
@@ -358,6 +387,7 @@
 	/* Offset 0x58: External APIC IRQ output control */
 	pci_write_config_byte (dev, 0x58, tmp);
 }
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C686,	quirk_via_ioapic );
 
 /*
  * The AMD io apic can hang the box when an apic irq is masked.
@@ -368,30 +398,29 @@
  * noapic specified. For the moment we assume its the errata. We may be wrong
  * of course. However the advice is demonstrably good even if so..
  */
- 
 static void __devinit quirk_amd_ioapic(struct pci_dev *dev)
 {
 	u8 rev;
 
 	pci_read_config_byte(dev, PCI_REVISION_ID, &rev);
-	if(rev >= 0x02)
-	{
+	if (rev >= 0x02) {
 		printk(KERN_WARNING "I/O APIC: AMD Errata #22 may be present. In the event of instability try\n");
 		printk(KERN_WARNING "        : booting with the \"noapic\" option.\n");
 	}
 }
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AMD,	PCI_DEVICE_ID_AMD_VIPER_7410,	quirk_amd_ioapic );
 
 static void __init quirk_ioapic_rmw(struct pci_dev *dev)
 {
 	if (dev->devfn == 0 && dev->bus->number == 0)
 		sis_apic_bug = 1;
 }
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_SI,	PCI_ANY_ID,			quirk_ioapic_rmw );
 
 #define AMD8131_revA0        0x01
 #define AMD8131_revB0        0x11
 #define AMD8131_MISC         0x40
 #define AMD8131_NIOAMODE_BIT 0
-
 static void __init quirk_amd_8131_ioapic(struct pci_dev *dev) 
 { 
         unsigned char revid, tmp;
@@ -407,6 +436,7 @@
                 pci_write_config_byte( dev, AMD8131_MISC, tmp);
         }
 } 
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_8131_APIC,         quirk_amd_8131_ioapic );
 
 #endif /* CONFIG_X86_IO_APIC */
 
@@ -444,6 +474,8 @@
 	if (irq && (irq != 2))
 		d->irq = irq;
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C586_3,	quirk_via_acpi );
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C686_4,	quirk_via_acpi );
 
 static void __devinit quirk_via_irqpic(struct pci_dev *dev)
 {
@@ -459,6 +491,9 @@
 		pci_write_config_byte(dev, PCI_INTERRUPT_LINE, new_irq);
 	}
 }
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C586_2,	quirk_via_irqpic );
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C686_5,	quirk_via_irqpic );
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C686_6,	quirk_via_irqpic );
 
 
 /*
@@ -480,6 +515,8 @@
 	legsup &= 0x50ef;
 	pci_write_config_word(dev, 0xc0, legsup);
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82371SB_2,	quirk_piix3_usb );
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82371AB_2,	quirk_piix3_usb );
 
 /*
  * VIA VT82C598 has its device ID settable and many BIOSes
@@ -492,6 +529,7 @@
 	pci_write_config_byte(dev, 0xfc, 0);
 	pci_read_config_word(dev, PCI_DEVICE_ID, &dev->device);
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C597_0,	quirk_vt82c598_id );
 
 /*
  * CardBus controllers have a legacy base address that enables them
@@ -505,6 +543,7 @@
 		return;
 	pci_write_config_dword(dev, PCI_CB_LEGACY_MODE_BASE, 0);
 }
+DECLARE_PCI_FIXUP_FINAL(PCI_ANY_ID,		PCI_ANY_ID,			quirk_cardbus_legacy );
 
 /*
  * Following the PCI ordering rules is optional on the AMD762. I'm not
@@ -513,13 +552,11 @@
  * To be fair to AMD, it follows the spec by default, its BIOS people
  * who turn it off!
  */
- 
 static void __devinit quirk_amd_ordering(struct pci_dev *dev)
 {
 	u32 pcic;
 	pci_read_config_dword(dev, 0x4C, &pcic);
-	if((pcic&6)!=6)
-	{
+	if ((pcic&6)!=6) {
 		pcic |= 6;
 		printk(KERN_WARNING "BIOS failed to enable PCI standards compliance, fixing this error.\n");
 		pci_write_config_dword(dev, 0x4C, pcic);
@@ -528,6 +565,7 @@
 		pci_write_config_dword(dev, 0x84, pcic);
 	}
 }
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_AMD,	PCI_DEVICE_ID_AMD_FE_GATE_700C, quirk_amd_ordering );
 
 /*
  *	DreamWorks provided workaround for Dunord I-3000 problem
@@ -536,18 +574,26 @@
  *	assigned to it. We force a larger allocation to ensure that
  *	nothing gets put too close to it.
  */
-
 static void __devinit quirk_dunord ( struct pci_dev * dev )
 {
-	struct resource * r = & dev -> resource [ 1 ];
-	r -> start = 0;
-	r -> end = 0xffffff;
+	struct resource *r = &dev->resource [1];
+	r->start = 0;
+	r->end = 0xffffff;
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_DUNORD,	PCI_DEVICE_ID_DUNORD_I3000,	quirk_dunord );
 
+/*
+ * i82380FB mobile docking controller: its PCI-to-PCI bridge
+ * is subtractive decoding (transparent), and does indicate this
+ * in the ProgIf. Unfortunately, the ProgIf value is wrong - 0x80
+ * instead of 0x01.
+ */
 static void __devinit quirk_transparent_bridge(struct pci_dev *dev)
 {
 	dev->transparent = 1;
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82380FB,	quirk_transparent_bridge );
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_TOSHIBA,	0x605,	quirk_transparent_bridge );
 
 /*
  * Common misconfiguration of the MediaGX/Geode PCI master that will
@@ -555,7 +601,6 @@
  * datasheets found at http://www.national.com/ds/GX for info on what
  * these bits do.  <christer@weinigel.se>
  */
- 
 static void __init quirk_mediagx_master(struct pci_dev *dev)
 {
 	u8 reg;
@@ -566,6 +611,7 @@
                 pci_write_config_byte(dev, 0x41, reg);
 	}
 }
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_CYRIX,	PCI_DEVICE_ID_CYRIX_PCI_MASTER, quirk_mediagx_master );
 
 /*
  * As per PCI spec, ignore base address registers 0-3 of the IDE controllers
@@ -584,7 +630,6 @@
  * we do now ? We don't want is pci_enable_device to come along
  * and assign new resources. Both approaches work for that.
  */ 
-
 static void __devinit quirk_ide_bases(struct pci_dev *dev)
 {
        struct resource *res;
@@ -616,34 +661,33 @@
        printk(KERN_INFO "PCI: Ignoring BAR%d-%d of IDE controller %s\n",
               first_bar, last_bar, pci_name(dev));
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_ANY_ID,             PCI_ANY_ID,                     quirk_ide_bases );
 
 /*
  *	Ensure C0 rev restreaming is off. This is normally done by
  *	the BIOS but in the odd case it is not the results are corruption
  *	hence the presence of a Linux check
  */
- 
 static void __init quirk_disable_pxb(struct pci_dev *pdev)
 {
 	u16 config;
 	u8 rev;
 	
 	pci_read_config_byte(pdev, PCI_REVISION_ID, &rev);
-	if(rev != 0x04)		/* Only C0 requires this */
+	if (rev != 0x04)		/* Only C0 requires this */
 		return;
 	pci_read_config_word(pdev, 0x40, &config);
-	if(config & (1<<6))
-	{
+	if (config & (1<<6)) {
 		config &= ~(1<<6);
 		pci_write_config_word(pdev, 0x40, config);
 		printk(KERN_INFO "PCI: C0 revision 450NX. Disabling PCI restreaming.\n");
 	}
 }
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82454NX,	quirk_disable_pxb );
 
 /*
  *	VIA northbridges care about PCI_INTERRUPT_LINE
  */
- 
 int interrupt_line_quirk;
 
 static void __devinit quirk_via_bridge(struct pci_dev *pdev)
@@ -651,6 +695,7 @@
 	if(pdev->devfn == 0)
 		interrupt_line_quirk = 1;
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_VIA,	PCI_ANY_ID,                     quirk_via_bridge );
 
 /*
  *	Serverworks CSB5 IDE does not fully support native mode
@@ -667,15 +712,16 @@
 		quirk_ide_bases(pdev);
 	}
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_SERVERWORKS, PCI_DEVICE_ID_SERVERWORKS_CSB5IDE, quirk_svwks_csb5ide );
 
 /* This was originally an Alpha specific thing, but it really fits here.
  * The i82375 PCI/EISA bridge appears as non-classified. Fix that.
  */
-
 static void __init quirk_eisa_bridge(struct pci_dev *dev)
 {
 	dev->class = PCI_CLASS_BRIDGE_EISA << 8;
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82375,	quirk_eisa_bridge );
 
 /*
  * On ASUS P4B boards, the SMBus PCI Device within the ICH2/4 southbridge
@@ -689,7 +735,6 @@
  * becomes necessary to do this tweak in two steps -- I've chosen the Host
  * bridge as trigger.
  */
-
 static int __initdata asus_hides_smbus = 0;
 
 static void __init asus_hides_smbus_hostbridge(struct pci_dev *dev)
@@ -699,6 +744,7 @@
 			switch(dev->subsystem_device) {
 			case 0x8070: /* P4B */
 			case 0x8088: /* P4B533 */
+			case 0x1626: /* L3C notebook */
 				asus_hides_smbus = 1;
 			}
 		if (dev->device == PCI_DEVICE_ID_INTEL_82845G_HB)
@@ -730,8 +776,20 @@
 			case 0x0890: /* HP Compaq nc6000 */
 				asus_hides_smbus = 1;
 			}
+		if (dev->device == PCI_DEVICE_ID_INTEL_82865_HB)
+			switch (dev->subsystem_device) {
+			case 0x12bc: /* HP D330L */
+				asus_hides_smbus = 1;
+			}
 	}
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82845_HB,	asus_hides_smbus_hostbridge );
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82845G_HB,	asus_hides_smbus_hostbridge );
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82850_HB,	asus_hides_smbus_hostbridge );
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82865_HB,	asus_hides_smbus_hostbridge );
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_7205_0,	asus_hides_smbus_hostbridge );
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82855PM_HB,	asus_hides_smbus_hostbridge );
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82855GM_HB,	asus_hides_smbus_hostbridge );
 
 static void __init asus_hides_smbus_lpc(struct pci_dev *dev)
 {
@@ -744,12 +802,17 @@
 	if (val & 0x8) {
 		pci_write_config_word(dev, 0xF2, val & (~0x8));
 		pci_read_config_word(dev, 0xF2, &val);
-		if(val & 0x8)
+		if (val & 0x8)
 			printk(KERN_INFO "PCI: i801 SMBus device continues to play 'hide and seek'! 0x%x\n", val);
 		else
 			printk(KERN_INFO "PCI: Enabled i801 SMBus device\n");
 	}
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82801DB_0,	asus_hides_smbus_lpc );
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82801BA_0,	asus_hides_smbus_lpc );
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82801CA_12,	asus_hides_smbus_lpc );
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82801DB_12,	asus_hides_smbus_lpc );
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82801EB_0,	asus_hides_smbus_lpc );
 
 /*
  * SiS 96x south bridge: BIOS typically hides SMBus device...
@@ -803,6 +866,19 @@
 {
 	sis_96x_compatible = 1;
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_SI,	PCI_DEVICE_ID_SI_645,		quirk_sis_96x_compatible );
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_SI,	PCI_DEVICE_ID_SI_646,		quirk_sis_96x_compatible );
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_SI,	PCI_DEVICE_ID_SI_648,		quirk_sis_96x_compatible );
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_SI,	PCI_DEVICE_ID_SI_650,		quirk_sis_96x_compatible );
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_SI,	PCI_DEVICE_ID_SI_651,		quirk_sis_96x_compatible );
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_SI,	PCI_DEVICE_ID_SI_735,		quirk_sis_96x_compatible );
+
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_SI,	PCI_DEVICE_ID_SI_503,		quirk_sis_503 );
+
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_SI,	PCI_DEVICE_ID_SI_961,		quirk_sis_96x_smbus );
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_SI,	PCI_DEVICE_ID_SI_962,		quirk_sis_96x_smbus );
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_SI,	PCI_DEVICE_ID_SI_963,		quirk_sis_96x_smbus );
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_SI,	PCI_DEVICE_ID_SI_LPC,		quirk_sis_96x_smbus );
 
 #ifdef CONFIG_X86_IO_APIC
 static void __init quirk_alder_ioapic(struct pci_dev *pdev)
@@ -815,16 +891,17 @@
 	/* the first BAR is the location of the IO APIC...we must
 	 * not touch this (and it's already covered by the fixmap), so
 	 * forcibly insert it into the resource tree */
-	if(pci_resource_start(pdev, 0) && pci_resource_len(pdev, 0))
+	if (pci_resource_start(pdev, 0) && pci_resource_len(pdev, 0))
 		insert_resource(&iomem_resource, &pdev->resource[0]);
 
 	/* The next five BARs all seem to be rubbish, so just clean
 	 * them out */
-	for(i=1; i < 6; i++) {
+	for (i=1; i < 6; i++) {
 		memset(&pdev->resource[i], 0, sizeof(pdev->resource[i]));
 	}
 
 }
+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_EESSC,	quirk_alder_ioapic );
 #endif
 
 #ifdef CONFIG_SCSI_SATA
@@ -898,6 +975,7 @@
 	else
 		request_region(0x170, 8, "libata");	/* port 1 */
 }
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,    PCI_ANY_ID,	  quirk_intel_ide_combined );
 #endif /* CONFIG_SCSI_SATA */
 
 int pciehp_msi_quirk;
@@ -906,163 +984,45 @@
 {
 	pciehp_msi_quirk = 1;
 }
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_SMCH,	quirk_pciehp_msi );
 
-/*
- *  The main table of quirks.
- *
- *  Note: any hooks for hotpluggable devices in this table must _NOT_
- *        be declared __init.
- */
-
-static struct pci_fixup pci_fixups[] __devinitdata = {
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_DUNORD,	PCI_DEVICE_ID_DUNORD_I3000,	quirk_dunord },
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82441,	quirk_passive_release },
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82441,	quirk_passive_release },
-	/*
-	 * Its not totally clear which chipsets are the problematic ones
-	 * We know 82C586 and 82C596 variants are affected.
-	 */
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C586_0,	quirk_isa_dma_hangs },
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C596,	quirk_isa_dma_hangs },
-	{ PCI_FIXUP_FINAL,      PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82371SB_0,  quirk_isa_dma_hangs },
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_AL,	PCI_DEVICE_ID_AL_M1533, 	quirk_isa_dma_hangs },
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82454NX,	quirk_disable_pxb },
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_NEC,	PCI_DEVICE_ID_NEC_CBUS_1,	quirk_isa_dma_hangs },
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_NEC,	PCI_DEVICE_ID_NEC_CBUS_2,	quirk_isa_dma_hangs },
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_NEC,	PCI_DEVICE_ID_NEC_CBUS_3,	quirk_isa_dma_hangs },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_S3,	PCI_DEVICE_ID_S3_868,		quirk_s3_64M },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_S3,	PCI_DEVICE_ID_S3_968,		quirk_s3_64M },
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_INTEL, 	PCI_DEVICE_ID_INTEL_82437, 	quirk_triton }, 
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_INTEL, 	PCI_DEVICE_ID_INTEL_82437VX, 	quirk_triton }, 
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_INTEL, 	PCI_DEVICE_ID_INTEL_82439, 	quirk_triton }, 
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_INTEL, 	PCI_DEVICE_ID_INTEL_82439TX, 	quirk_triton }, 
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_INTEL, 	PCI_DEVICE_ID_INTEL_82441, 	quirk_natoma }, 
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_INTEL, 	PCI_DEVICE_ID_INTEL_82443LX_0, 	quirk_natoma }, 
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_INTEL, 	PCI_DEVICE_ID_INTEL_82443LX_1, 	quirk_natoma }, 
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_INTEL, 	PCI_DEVICE_ID_INTEL_82443BX_0, 	quirk_natoma }, 
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_INTEL, 	PCI_DEVICE_ID_INTEL_82443BX_1, 	quirk_natoma }, 
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_INTEL, 	PCI_DEVICE_ID_INTEL_82443BX_2, 	quirk_natoma },
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_SI,	PCI_DEVICE_ID_SI_5597,		quirk_nopcipci },
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_SI,	PCI_DEVICE_ID_SI_496,		quirk_nopcipci },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_SI,	PCI_DEVICE_ID_SI_503,		quirk_sis_503 },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_SI,	PCI_DEVICE_ID_SI_LPC,		quirk_sis_96x_smbus },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_SI,	PCI_DEVICE_ID_SI_645,		quirk_sis_96x_compatible },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_SI,	PCI_DEVICE_ID_SI_646,		quirk_sis_96x_compatible },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_SI,	PCI_DEVICE_ID_SI_648,		quirk_sis_96x_compatible },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_SI,	PCI_DEVICE_ID_SI_650,		quirk_sis_96x_compatible },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_SI,	PCI_DEVICE_ID_SI_651,		quirk_sis_96x_compatible },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_SI,	PCI_DEVICE_ID_SI_735,		quirk_sis_96x_compatible },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_SI,	PCI_DEVICE_ID_SI_961,		quirk_sis_96x_smbus },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_SI,	PCI_DEVICE_ID_SI_962,		quirk_sis_96x_smbus },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_SI,	PCI_DEVICE_ID_SI_963,		quirk_sis_96x_smbus },
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_AL, 	PCI_DEVICE_ID_AL_M1647, 	quirk_alimagik },
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_AL, 	PCI_DEVICE_ID_AL_M1651, 	quirk_alimagik },
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_8363_0,	quirk_vialatency },
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_8371_1,	quirk_vialatency },
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_8361,	quirk_vialatency },
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C576,	quirk_vsfx },
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C597_0,	quirk_viaetbf },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C597_0,	quirk_vt82c598_id },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C586_3,	quirk_vt82c586_acpi },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C686_4,	quirk_vt82c686_acpi },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82371AB_3,	quirk_piix4_acpi },
-
-	/* Intel LPC interface bridges all have 128 bytes of magic ACPI/TCO regs and 64 bytes of GPIO */
-	{ PCI_FIXUP_HEADER,     PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82801AA_0,	quirk_ich4_lpc_acpi },
-	{ PCI_FIXUP_HEADER,     PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82801AB_0,	quirk_ich4_lpc_acpi },
-	{ PCI_FIXUP_HEADER,     PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82801BA_0,	quirk_ich4_lpc_acpi },
-	{ PCI_FIXUP_HEADER,     PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82801BA_10,	quirk_ich4_lpc_acpi },
-	{ PCI_FIXUP_HEADER,     PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82801CA_0,	quirk_ich4_lpc_acpi },
-	{ PCI_FIXUP_HEADER,     PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82801CA_12,	quirk_ich4_lpc_acpi },
-	{ PCI_FIXUP_HEADER,     PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82801DB_0,	quirk_ich4_lpc_acpi },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82801DB_12,	quirk_ich4_lpc_acpi },
-	{ PCI_FIXUP_HEADER,     PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_82801EB_0,	quirk_ich4_lpc_acpi },
-
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_AL,	PCI_DEVICE_ID_AL_M7101,		quirk_ali7101_acpi },
- 	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82371SB_2,	quirk_piix3_usb },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82371AB_2,	quirk_piix3_usb },
-	{ PCI_FIXUP_HEADER,     PCI_ANY_ID,             PCI_ANY_ID,                     quirk_ide_bases },
-	{ PCI_FIXUP_HEADER,     PCI_VENDOR_ID_VIA,	PCI_ANY_ID,                     quirk_via_bridge },
-	{ PCI_FIXUP_FINAL,	PCI_ANY_ID,		PCI_ANY_ID,			quirk_cardbus_legacy },
-
-#ifdef CONFIG_X86_IO_APIC 
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C686,	quirk_via_ioapic },
-	{ PCI_FIXUP_FINAL, 	PCI_VENDOR_ID_AMD,	PCI_DEVICE_ID_AMD_VIPER_7410,	quirk_amd_ioapic },
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_SI,	PCI_ANY_ID,			quirk_ioapic_rmw },
-        { PCI_FIXUP_FINAL,      PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_8131_APIC,
-          quirk_amd_8131_ioapic }, 
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_EESSC,	quirk_alder_ioapic },
-#endif
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C586_3,	quirk_via_acpi },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C686_4,	quirk_via_acpi },
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C586_2,	quirk_via_irqpic },
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C686_5,	quirk_via_irqpic },
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_VIA,	PCI_DEVICE_ID_VIA_82C686_6,	quirk_via_irqpic },
-
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_AMD,	PCI_DEVICE_ID_AMD_FE_GATE_700C, quirk_amd_ordering },
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_ATI,	PCI_DEVICE_ID_ATI_RS100,   quirk_ati_exploding_mce },
-	/*
-	 * i82380FB mobile docking controller: its PCI-to-PCI bridge
-	 * is subtractive decoding (transparent), and does indicate this
-	 * in the ProgIf. Unfortunately, the ProgIf value is wrong - 0x80
-	 * instead of 0x01.
-	 */
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82380FB,	quirk_transparent_bridge },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_TOSHIBA,	0x605,	quirk_transparent_bridge },
-
-	{ PCI_FIXUP_FINAL,	PCI_VENDOR_ID_CYRIX,	PCI_DEVICE_ID_CYRIX_PCI_MASTER, quirk_mediagx_master },
-
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_SERVERWORKS, PCI_DEVICE_ID_SERVERWORKS_CSB5IDE, quirk_svwks_csb5ide },
-
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82375,	quirk_eisa_bridge },
-
-	/*
-	 * on Asus P4B boards, the i801SMBus device is disabled at startup.
-	 * this also goes for boards in HP Compaq nc6000 and nc8000 notebooks.
-	 */
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82845_HB,	asus_hides_smbus_hostbridge },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82845G_HB,	asus_hides_smbus_hostbridge },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82850_HB,	asus_hides_smbus_hostbridge },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_7205_0,	asus_hides_smbus_hostbridge },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82855PM_HB,	asus_hides_smbus_hostbridge },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82855GM_HB,	asus_hides_smbus_hostbridge },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82801DB_0,	asus_hides_smbus_lpc },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82801BA_0,	asus_hides_smbus_lpc },
-	{ PCI_FIXUP_HEADER,	PCI_VENDOR_ID_INTEL,	PCI_DEVICE_ID_INTEL_82801DB_12,	asus_hides_smbus_lpc },
-
-#ifdef CONFIG_SCSI_SATA
-	/* Fixup BIOSes that configure Parallel ATA (PATA / IDE) and
-	 * Serial ATA (SATA) into the same PCI ID.
-	 */
-	{ PCI_FIXUP_FINAL,      PCI_VENDOR_ID_INTEL,    PCI_ANY_ID,
-	  quirk_intel_ide_combined },
-#endif /* CONFIG_SCSI_SATA */
-
-	{ PCI_FIXUP_FINAL,      PCI_VENDOR_ID_INTEL,    PCI_DEVICE_ID_INTEL_SMCH,	quirk_pciehp_msi },
-
-	{ 0 }
-};
 
-
-static void pci_do_fixups(struct pci_dev *dev, int pass, struct pci_fixup *f)
+static void pci_do_fixups(struct pci_dev *dev, struct pci_fixup *f, struct pci_fixup *end)
 {
-	while (f->pass) {
-		if (f->pass == pass &&
- 		    (f->vendor == dev->vendor || f->vendor == (u16) PCI_ANY_ID) &&
+	while (f < end) {
+		if ((f->vendor == dev->vendor || f->vendor == (u16) PCI_ANY_ID) &&
  		    (f->device == dev->device || f->device == (u16) PCI_ANY_ID)) {
-#ifdef DEBUG
-			printk(KERN_INFO "PCI: Calling quirk %p for %s\n", f->hook, pci_name(dev));
-#endif
+			pr_debug(KERN_INFO "PCI: Calling quirk %p for %s\n", f->hook, pci_name(dev));
 			f->hook(dev);
 		}
 		f++;
 	}
 }
 
-void pci_fixup_device(int pass, struct pci_dev *dev)
-{
-	pci_do_fixups(dev, pass, pcibios_fixups);
-	pci_do_fixups(dev, pass, pci_fixups);
+extern struct pci_fixup __start_pci_fixups_header[];
+extern struct pci_fixup __end_pci_fixups_header[];
+extern struct pci_fixup __start_pci_fixups_final[];
+extern struct pci_fixup __end_pci_fixups_final[];
+
+void pci_fixup_device(enum pci_fixup_pass pass, struct pci_dev *dev)
+{
+	struct pci_fixup *start, *end;
+
+	switch(pass) {
+	case pci_fixup_header:
+		start = __start_pci_fixups_header;
+		end = __end_pci_fixups_header;
+		break;
+
+	case pci_fixup_final:
+		start = __start_pci_fixups_final;
+		end = __end_pci_fixups_final;
+		break;
+	default:
+		/* stupid compiler warning, you would think with an enum... */
+		return;
+	}
+	pci_do_fixups(dev, start, end);
 }
 
 EXPORT_SYMBOL(pciehp_msi_quirk);
Index: xx-sources/drivers/pci/setup-bus.c
===================================================================
--- xx-sources.orig/drivers/pci/setup-bus.c	2004-08-14 01:38:08.000000000 -0400
+++ xx-sources/drivers/pci/setup-bus.c	2004-08-14 13:17:24.788767968 -0400
@@ -537,10 +537,11 @@
 
 	/* Depth first, calculate sizes and alignments of all
 	   subordinate buses. */
-	for(ln=pci_root_buses.next; ln != &pci_root_buses; ln=ln->next)
+	list_for_each(ln, &pci_root_buses) {
 		pci_bus_size_bridges(pci_bus_b(ln));
+	}
 	/* Depth last, allocate resources and update the hardware. */
-	for(ln=pci_root_buses.next; ln != &pci_root_buses; ln=ln->next) {
+	list_for_each(ln, &pci_root_buses) {
 		pci_bus_assign_resources(pci_bus_b(ln));
 		pci_enable_bridges(pci_bus_b(ln));
 	}
Index: xx-sources/drivers/w1/Kconfig
===================================================================
--- xx-sources.orig/drivers/w1/Kconfig	2004-08-14 01:37:38.000000000 -0400
+++ xx-sources/drivers/w1/Kconfig	2004-08-14 13:17:24.789767816 -0400
@@ -21,6 +21,25 @@
 	  This support is also available as a module.  If so, the module 
 	  will be called matrox_w1.ko.
 
+config W1_DS9490
+	tristate "DS9490R transport layer driver"
+	depends on W1 && USB
+	help
+	  Say Y here if you want to have a driver for DS9490R UWB <-> W1 bridge.
+
+	  This support is also available as a module.  If so, the module
+	  will be called ds9490r.ko.
+
+config W1_DS9490R_BRIDGE
+	tristate "DS9490R USB <-> W1 transport layer for 1-wire"
+	depends on W1_DS9490
+	help
+	  Say Y here if you want to communicate with your 1-wire devices
+	  using DS9490R USB bridge.
+
+	  This support is also available as a module.  If so, the module
+	  will be called ds_w1_bridge.ko.
+
 config W1_THERM
 	tristate "Thermal family implementation"
 	depends on W1
@@ -28,4 +47,11 @@
 	  Say Y here if you want to connect 1-wire thermal sensors to you
 	  wire.
 
+config W1_SMEM
+	tristate "Simple 64bit memory family implementation"
+	depends on W1
+	help
+	  Say Y here if you want to connect 1-wire
+	  simple 64bit memory rom(ds2401/ds2411/ds1990*) to you wire.
+
 endmenu
Index: xx-sources/drivers/w1/Makefile
===================================================================
--- xx-sources.orig/drivers/w1/Makefile	2004-08-14 01:36:57.000000000 -0400
+++ xx-sources/drivers/w1/Makefile	2004-08-14 13:17:24.790767664 -0400
@@ -7,3 +7,10 @@
 
 obj-$(CONFIG_W1_MATROX)		+= matrox_w1.o
 obj-$(CONFIG_W1_THERM)		+= w1_therm.o
+obj-$(CONFIG_W1_SMEM)		+= w1_smem.o
+
+obj-$(CONFIG_W1_DS9490)		+= ds9490r.o
+ds9490r-objs    := dscore.o
+
+obj-$(CONFIG_W1_DS9490_BRIDGE)	+= ds_w1_bridge.o
+
Index: xx-sources/drivers/w1/ds_w1_bridge.c
===================================================================
--- xx-sources.orig/drivers/w1/ds_w1_bridge.c	2004-05-31 17:36:38.000000000 -0400
+++ xx-sources/drivers/w1/ds_w1_bridge.c	2004-08-14 13:17:24.790767664 -0400
@@ -0,0 +1,174 @@
+/*
+ * 	ds_w1_bridge.c
+ *
+ * Copyright (c) 2004 Evgeniy Polyakov <johnpol@2ka.mipt.ru>
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+
+#include "../w1/w1.h"
+#include "../w1/w1_int.h"
+#include "dscore.h"
+
+static struct ds_device *ds_dev;
+static struct w1_bus_master *ds_bus_master;
+
+static u8 ds9490r_touch_bit(unsigned long data, u8 bit)
+{
+	u8 ret;
+	struct ds_device *dev = (struct ds_device *)data;
+
+	if (ds_touch_bit(dev, bit, &ret))
+		return 0;
+
+	return ret;
+}
+
+static void ds9490r_write_bit(unsigned long data, u8 bit)
+{
+	struct ds_device *dev = (struct ds_device *)data;
+
+	ds_write_bit(dev, bit);
+}
+
+static void ds9490r_write_byte(unsigned long data, u8 byte)
+{
+	struct ds_device *dev = (struct ds_device *)data;
+
+	ds_write_byte(dev, byte);
+}
+
+static u8 ds9490r_read_bit(unsigned long data)
+{
+	struct ds_device *dev = (struct ds_device *)data;
+	int err;
+	u8 bit = 0;
+
+	err = ds_touch_bit(dev, 1, &bit);
+	if (err)
+		return 0;
+	//err = ds_read_bit(dev, &bit);
+	//if (err)
+	//	return 0;
+
+	return bit & 1;
+}
+
+static u8 ds9490r_read_byte(unsigned long data)
+{
+	struct ds_device *dev = (struct ds_device *)data;
+	int err;
+	u8 byte = 0;
+
+	err = ds_read_byte(dev, &byte);
+	if (err)
+		return 0;
+
+	return byte;
+}
+
+static void ds9490r_write_block(unsigned long data, u8 *buf, int len)
+{
+	struct ds_device *dev = (struct ds_device *)data;
+
+	ds_write_block(dev, buf, len);
+}
+
+static u8 ds9490r_read_block(unsigned long data, u8 *buf, int len)
+{
+	struct ds_device *dev = (struct ds_device *)data;
+	int err;
+
+	err = ds_read_block(dev, buf, len);
+	if (err < 0)
+		return 0;
+
+	return len;
+}
+
+static u8 ds9490r_reset(unsigned long data)
+{
+	struct ds_device *dev = (struct ds_device *)data;
+	struct ds_status st;
+	int err;
+
+	memset(&st, 0, sizeof(st));
+
+	err = ds_reset(dev, &st);
+	if (err)
+		return 1;
+
+	return 0;
+}
+
+static int __devinit ds_w1_init(void)
+{
+	int err;
+
+	ds_bus_master = kmalloc(sizeof(*ds_bus_master), GFP_KERNEL);
+	if (!ds_bus_master) {
+		printk(KERN_ERR "Failed to allocate DS9490R USB<->W1 bus_master structure.\n");
+		return -ENOMEM;
+	}
+
+	ds_dev = ds_get_device();
+	if (!ds_dev) {
+		printk(KERN_ERR "DS9490R is not registered.\n");
+		err =  -ENODEV;
+		goto err_out_free_bus_master;
+	}
+
+	memset(ds_bus_master, 0, sizeof(*ds_bus_master));
+
+	ds_bus_master->data 		= (unsigned long)ds_dev;
+	ds_bus_master->touch_bit 	= &ds9490r_touch_bit;
+	ds_bus_master->read_bit 	= &ds9490r_read_bit;
+	ds_bus_master->write_bit 	= &ds9490r_write_bit;
+	ds_bus_master->read_byte 	= &ds9490r_read_byte;
+	ds_bus_master->write_byte 	= &ds9490r_write_byte;
+	ds_bus_master->read_block 	= &ds9490r_read_block;
+	ds_bus_master->write_block 	= &ds9490r_write_block;
+	ds_bus_master->reset_bus	= &ds9490r_reset;
+
+	err = w1_add_master_device(ds_bus_master);
+	if (err)
+		goto err_out_put_device;
+
+	return 0;
+
+err_out_put_device:
+	ds_put_device(ds_dev);
+err_out_free_bus_master:
+	kfree(ds_bus_master);
+
+	return err;
+}
+
+static void __devexit ds_w1_fini(void)
+{
+	w1_remove_master_device(ds_bus_master);
+	ds_put_device(ds_dev);
+	kfree(ds_bus_master);
+}
+
+module_init(ds_w1_init);
+module_exit(ds_w1_fini);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Evgeniy Polyakov <johnpol@2ka.mipt.ru>");
Index: xx-sources/drivers/w1/dscore.c
===================================================================
--- xx-sources.orig/drivers/w1/dscore.c	2004-05-31 17:36:38.000000000 -0400
+++ xx-sources/drivers/w1/dscore.c	2004-08-14 13:17:24.792767360 -0400
@@ -0,0 +1,783 @@
+/*
+ * 	dscore.c
+ *
+ * Copyright (c) 2004 Evgeniy Polyakov <johnpol@2ka.mipt.ru>
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/mod_devicetable.h>
+#include <linux/usb.h>
+
+#include "dscore.h"
+
+static struct usb_device_id ds_id_table [] = {
+	{ USB_DEVICE(0x04fa, 0x2490) },
+	{ },
+};
+MODULE_DEVICE_TABLE(usb, ds_id_table);
+
+int ds_probe(struct usb_interface *, const struct usb_device_id *);
+void ds_disconnect(struct usb_interface *);
+
+inline int ds_touch_bit(struct ds_device *, u8, u8 *);
+inline int ds_read_byte(struct ds_device *, u8 *);
+inline int ds_read_bit(struct ds_device *, u8 *);
+inline int ds_write_byte(struct ds_device *, u8);
+inline int ds_write_bit(struct ds_device *, u8);
+inline int ds_start_pulse(struct ds_device *, int);
+inline int ds_set_speed(struct ds_device *, int);
+inline int ds_reset(struct ds_device *, struct ds_status *);
+inline int ds_detect(struct ds_device *, struct ds_status *);
+inline int ds_stop_pulse(struct ds_device *, int);
+inline int ds_send_data(struct ds_device *, unsigned char *, int);
+inline int ds_recv_data(struct ds_device *, unsigned char *, int);
+inline int ds_recv_status(struct ds_device *, struct ds_status *);
+inline struct ds_device * ds_get_device(void);
+inline void ds_put_device(struct ds_device *);
+
+static inline void ds_dump_status(unsigned char *, unsigned char *, int);
+static inline int ds_send_control(struct ds_device *, u16, u16);
+static inline int ds_send_control_mode(struct ds_device *, u16, u16);
+static inline int ds_send_control_cmd(struct ds_device *, u16, u16);
+
+
+static struct usb_driver ds_driver = {
+	.owner =	THIS_MODULE,
+	.name =		"DS9490R",
+	.probe =	ds_probe,
+	.disconnect =	ds_disconnect,
+	.id_table =	ds_id_table,
+};
+
+static struct ds_device *ds_dev;
+
+struct ds_device * ds_get_device(void)
+{
+	if (ds_dev)
+		atomic_inc(&ds_dev->refcnt);
+	return ds_dev;
+}
+
+void ds_put_device(struct ds_device *dev)
+{
+	atomic_dec(&dev->refcnt);
+}
+
+static int ds_send_control_cmd(struct ds_device *dev, u16 value, u16 index)
+{
+	int err;
+
+	err = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, dev->ep[EP_CONTROL]),
+			CONTROL_CMD, 0x40, value, index, NULL, 0, HZ);
+	if (err < 0) {
+		printk(KERN_ERR "Failed to send command control message %x.%x: err=%d.\n",
+				value, index, err);
+		return err;
+	}
+
+	return err;
+}
+
+static int ds_send_control_mode(struct ds_device *dev, u16 value, u16 index)
+{
+	int err;
+
+	err = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, dev->ep[EP_CONTROL]),
+			MODE_CMD, 0x40, value, index, NULL, 0, HZ);
+	if (err < 0) {
+		printk(KERN_ERR "Failed to send mode control message %x.%x: err=%d.\n",
+				value, index, err);
+		return err;
+	}
+
+	return err;
+}
+
+static int ds_send_control(struct ds_device *dev, u16 value, u16 index)
+{
+	int err;
+
+	err = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, dev->ep[EP_CONTROL]),
+			COMM_CMD, 0x40, value, index, NULL, 0, HZ);
+	if (err < 0) {
+		printk(KERN_ERR "Failed to send control message %x.%x: err=%d.\n",
+				value, index, err);
+		return err;
+	}
+
+	return err;
+}
+
+static inline void ds_dump_status(unsigned char *buf, unsigned char *str, int off)
+{
+	printk("%45s: %8x\n", str, buf[off]);
+}
+
+int ds_recv_status_nodump(struct ds_device *dev, struct ds_status *st, unsigned char *buf, int size)
+{
+	int count, err;
+
+	memset(st, 0, sizeof(st));
+
+	count = 0;
+	err = usb_bulk_msg(dev->udev, usb_rcvbulkpipe(dev->udev, dev->ep[EP_STATUS]), buf, size, &count, 100);
+	if (err < 0) {
+		printk(KERN_ERR "Failed to read 1-wire data from 0x%x: err=%d.\n", dev->ep[EP_STATUS], err);
+		return err;
+	}
+
+	if (count >= sizeof(*st))
+		memcpy(st, buf, sizeof(*st));
+
+	return count;
+}
+
+int ds_recv_status(struct ds_device *dev, struct ds_status *st)
+{
+	unsigned char buf[64];
+	int count, err = 0, i;
+
+	memcpy(st, buf, sizeof(*st));
+
+	count = ds_recv_status_nodump(dev, st, buf, sizeof(buf));
+	if (count < 0)
+		return err;
+
+	printk("0x%x: count=%d, status: ", dev->ep[EP_STATUS], count);
+	for (i=0; i<count; ++i)
+		printk("%02x ", buf[i]);
+	printk("\n");
+
+	if (count >= 16) {
+		ds_dump_status(buf, "enable flag", 0);
+		ds_dump_status(buf, "1-wire speed", 1);
+		ds_dump_status(buf, "strong pullup duration", 2);
+		ds_dump_status(buf, "programming pulse duration", 3);
+		ds_dump_status(buf, "pulldown slew rate control", 4);
+		ds_dump_status(buf, "write-1 low time", 5);
+		ds_dump_status(buf, "data sample offset/write-0 recovery time", 6);
+		ds_dump_status(buf, "reserved (test register)", 7);
+		ds_dump_status(buf, "device status flags", 8);
+		ds_dump_status(buf, "communication command byte 1", 9);
+		ds_dump_status(buf, "communication command byte 2", 10);
+		ds_dump_status(buf, "communication command buffer status", 11);
+		ds_dump_status(buf, "1-wire data output buffer status", 12);
+		ds_dump_status(buf, "1-wire data input buffer status", 13);
+		ds_dump_status(buf, "reserved", 14);
+		ds_dump_status(buf, "reserved", 15);
+	}
+
+	memcpy(st, buf, sizeof(*st));
+
+	if (st->status & ST_EPOF) {
+		printk(KERN_INFO "Resetting device after ST_EPOF.\n");
+		err = ds_send_control_cmd(dev, CTL_RESET_DEVICE, 0);
+		if (err)
+			return err;
+		count = ds_recv_status_nodump(dev, st, buf, sizeof(buf));
+		if (count < 0)
+			return err;
+	}
+#if 0
+	if (st->status & ST_IDLE) {
+		printk(KERN_INFO "Resetting pulse after ST_IDLE.\n");
+		err = ds_start_pulse(dev, PULLUP_PULSE_DURATION);
+		if (err)
+			return err;
+	}
+#endif
+
+	return err;
+}
+
+int ds_recv_data(struct ds_device *dev, unsigned char *buf, int size)
+{
+	int count, err;
+	struct ds_status st;
+
+	count = 0;
+	err = usb_bulk_msg(dev->udev, usb_rcvbulkpipe(dev->udev, dev->ep[EP_DATA_IN]),
+				buf, size, &count, HZ);
+	if (err < 0) {
+		printk(KERN_INFO "Clearing ep0x%x.\n", dev->ep[EP_DATA_IN]);
+		usb_clear_halt(dev->udev, usb_rcvbulkpipe(dev->udev, dev->ep[EP_DATA_IN]));
+		ds_recv_status(dev, &st);
+		return err;
+	}
+
+#if 0
+	{
+		int i;
+
+		printk("%s: count=%d: ", __func__, count);
+		for (i=0; i<count; ++i)
+			printk("%02x ", buf[i]);
+		printk("\n");
+	}
+#endif
+	return count;
+}
+
+int ds_send_data(struct ds_device *dev, unsigned char *buf, int len)
+{
+	int count, err;
+
+	count = 0;
+	err = usb_bulk_msg(dev->udev, usb_sndbulkpipe(dev->udev, dev->ep[EP_DATA_OUT]), buf, len, &count, HZ);
+	if (err < 0) {
+		printk(KERN_ERR "Failed to read 1-wire data from 0x02: err=%d.\n", err);
+		return err;
+	}
+
+	return err;
+}
+
+int ds_stop_pulse(struct ds_device *dev, int limit)
+{
+	struct ds_status st;
+	int count = 0, err = 0;
+	u8 buf[0x20];
+
+	do {
+		err = ds_send_control(dev, CTL_HALT_EXE_IDLE, 0);
+		if (err)
+			break;
+		err = ds_send_control(dev, CTL_RESUME_EXE, 0);
+		if (err)
+			break;
+		err = ds_recv_status_nodump(dev, &st, buf, sizeof(buf));
+		if (err)
+			break;
+
+		if ((st.status & ST_SPUA) == 0) {
+			err = ds_send_control_mode(dev, MOD_PULSE_EN, 0);
+			if (err)
+				break;
+		}
+	} while(++count < limit);
+
+	return err;
+}
+
+int ds_detect(struct ds_device *dev, struct ds_status *st)
+{
+	int err;
+
+	err = ds_send_control_cmd(dev, CTL_RESET_DEVICE, 0);
+	if (err)
+		return err;
+
+	err = ds_send_control(dev, COMM_SET_DURATION | COMM_IM, 0);
+	if (err)
+		return err;
+
+	err = ds_send_control(dev, COMM_SET_DURATION | COMM_IM | COMM_TYPE, 0x40);
+	if (err)
+		return err;
+
+	err = ds_send_control_mode(dev, MOD_PULSE_EN, PULSE_PROG);
+	if (err)
+		return err;
+
+	err = ds_recv_status(dev, st);
+
+	return err;
+}
+
+int ds_wait_status(struct ds_device *dev, struct ds_status *st)
+{
+	u8 buf[0x20];
+	int err, count = 0;
+
+	do {
+		err = ds_recv_status_nodump(dev, st, buf, sizeof(buf));
+#if 0
+		if (err >= 0) {
+			int i;
+			printk("0x%x: count=%d, status: ", dev->ep[EP_STATUS], err);
+			for (i=0; i<err; ++i)
+				printk("%02x ", buf[i]);
+			printk("\n");
+		}
+#endif
+	} while(!(buf[0x08] & 0x20) && !(err < 0) && ++count < 100);
+
+
+	if (((err > 16) && (buf[0x10] & 0x01)) || count >= 100 || err < 0) {
+		ds_recv_status(dev, st);
+		return -1;
+	}
+	else {
+		return 0;
+	}
+}
+
+int ds_reset(struct ds_device *dev, struct ds_status *st)
+{
+	int err;
+
+	//err = ds_send_control(dev, COMM_1_WIRE_RESET | COMM_F | COMM_IM | COMM_SE, SPEED_FLEXIBLE);
+	err = ds_send_control(dev, 0x43, SPEED_NORMAL);
+	if (err)
+		return err;
+
+	ds_wait_status(dev, st);
+#if 0
+	if (st->command_buffer_status) {
+		printk(KERN_INFO "Short circuit.\n");
+		return -EIO;
+	}
+#endif
+
+	return 0;
+}
+
+int ds_set_speed(struct ds_device *dev, int speed)
+{
+	int err;
+
+	if (speed != SPEED_NORMAL && speed != SPEED_FLEXIBLE && speed != SPEED_OVERDRIVE)
+		return -EINVAL;
+
+	if (speed != SPEED_OVERDRIVE)
+		speed = SPEED_FLEXIBLE;
+
+	speed &= 0xff;
+
+	err = ds_send_control_mode(dev, MOD_1WIRE_SPEED, speed);
+	if (err)
+		return err;
+
+	return err;
+}
+
+int ds_start_pulse(struct ds_device *dev, int delay)
+{
+	int err;
+	u8 del = 1 + (u8)(delay >> 4);
+	struct ds_status st;
+
+#if 0
+	err = ds_stop_pulse(dev, 10);
+	if (err)
+		return err;
+
+	err = ds_send_control_mode(dev, MOD_PULSE_EN, PULSE_SPUE);
+	if (err)
+		return err;
+#endif
+	err = ds_send_control(dev, COMM_SET_DURATION | COMM_IM, del);
+	if (err)
+		return err;
+
+	err = ds_send_control(dev, COMM_PULSE | COMM_IM | COMM_F, 0);
+	if (err)
+		return err;
+
+	mdelay(delay);
+
+	ds_wait_status(dev, &st);
+
+	return err;
+}
+
+int ds_touch_bit(struct ds_device *dev, u8 bit, u8 *tbit)
+{
+	int err, count;
+	struct ds_status st;
+	u16 value = (COMM_BIT_IO | COMM_IM) | ((bit) ? COMM_D : 0);
+	u16 cmd;
+
+	err = ds_send_control(dev, value, 0);
+	if (err)
+		return err;
+
+	count = 0;
+	do {
+		err = ds_wait_status(dev, &st);
+		if (err)
+			return err;
+
+		cmd = st.command0 | (st.command1 << 8);
+	} while (cmd != value && ++count < 10);
+
+	if (err < 0 || count >= 10) {
+		printk(KERN_ERR "Failed to obtain status.\n");
+		return -EINVAL;
+	}
+
+	err = ds_recv_data(dev, tbit, sizeof(*tbit));
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+int ds_write_bit(struct ds_device *dev, u8 bit)
+{
+	int err;
+	struct ds_status st;
+
+	err = ds_send_control(dev, COMM_BIT_IO | COMM_IM | (bit) ? COMM_D : 0, 0);
+	if (err)
+		return err;
+
+	ds_wait_status(dev, &st);
+
+	return 0;
+}
+
+int ds_write_byte(struct ds_device *dev, u8 byte)
+{
+	int err;
+	struct ds_status st;
+	u8 rbyte;
+
+	err = ds_send_control(dev, COMM_BYTE_IO | COMM_IM | COMM_SPU, byte);
+	if (err)
+		return err;
+
+	err = ds_wait_status(dev, &st);
+	if (err)
+		return err;
+
+	err = ds_recv_data(dev, &rbyte, sizeof(rbyte));
+	if (err < 0)
+		return err;
+
+	ds_start_pulse(dev, PULLUP_PULSE_DURATION);
+
+	return !(byte == rbyte);
+}
+
+int ds_read_bit(struct ds_device *dev, u8 *bit)
+{
+	int err;
+
+	err = ds_send_control_mode(dev, MOD_PULSE_EN, PULSE_SPUE);
+	if (err)
+		return err;
+
+	err = ds_send_control(dev, COMM_BIT_IO | COMM_IM | COMM_SPU | COMM_D, 0);
+	if (err)
+		return err;
+
+	err = ds_recv_data(dev, bit, sizeof(*bit));
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+int ds_read_byte(struct ds_device *dev, u8 *byte)
+{
+	int err;
+	struct ds_status st;
+
+	err = ds_send_control(dev, COMM_BYTE_IO | COMM_IM , 0xff);
+	if (err)
+		return err;
+
+	ds_wait_status(dev, &st);
+
+	err = ds_recv_data(dev, byte, sizeof(*byte));
+	if (err < 0)
+		return err;
+
+	return 0;
+}
+
+inline int ds_read_block(struct ds_device *dev, u8 *buf, int len)
+{
+	struct ds_status st;
+	int err;
+
+	if (len > 64*1024)
+		return -E2BIG;
+
+	memset(buf, 0xFF, len);
+
+	err = ds_send_data(dev, buf, len);
+	if (err < 0)
+		return err;
+
+	err = ds_send_control(dev, COMM_BLOCK_IO | COMM_IM | COMM_SPU, len);
+	if (err)
+		return err;
+
+	ds_wait_status(dev, &st);
+
+	memset(buf, 0x00, len);
+	err = ds_recv_data(dev, buf, len);
+
+	return err;
+}
+
+inline int ds_write_block(struct ds_device *dev, u8 *buf, int len)
+{
+	int err;
+	struct ds_status st;
+
+	err = ds_send_data(dev, buf, len);
+	if (err < 0)
+		return err;
+
+	ds_wait_status(dev, &st);
+
+	err = ds_send_control(dev, COMM_BLOCK_IO | COMM_IM | COMM_SPU, len);
+	if (err)
+		return err;
+
+	ds_wait_status(dev, &st);
+
+	err = ds_recv_data(dev, buf, len);
+	if (err < 0)
+		return err;
+
+	ds_start_pulse(dev, PULLUP_PULSE_DURATION);
+
+	return !(err == len);
+}
+
+int ds_search(struct ds_device *dev, u64 init, u64 *buf, u8 id_number, int conditional_search)
+{
+	int err;
+	u16 value, index;
+	struct ds_status st;
+
+	memset(buf, 0, sizeof(buf));
+
+	err = ds_send_data(ds_dev, (unsigned char *)&init, 8);
+	if (err)
+		return err;
+
+	ds_wait_status(ds_dev, &st);
+
+	value = COMM_SEARCH_ACCESS | COMM_IM | COMM_SM | COMM_F | COMM_RTS;
+	index = (conditional_search ? 0xEC : 0xF0) | (id_number << 8);
+	err = ds_send_control(ds_dev, value, index);
+	if (err)
+		return err;
+
+	ds_wait_status(ds_dev, &st);
+
+	err = ds_recv_data(ds_dev, (unsigned char *)buf, 8*id_number);
+	if (err < 0)
+		return err;
+
+	return err/8;
+}
+
+int ds_match_access(struct ds_device *dev, u64 init)
+{
+	int err;
+	struct ds_status st;
+
+	err = ds_send_data(dev, (unsigned char *)&init, sizeof(init));
+	if (err)
+		return err;
+
+	ds_wait_status(dev, &st);
+
+	err = ds_send_control(dev, COMM_MATCH_ACCESS | COMM_IM | COMM_RST, 0x0055);
+	if (err)
+		return err;
+
+	ds_wait_status(dev, &st);
+
+	return 0;
+}
+
+int ds_set_path(struct ds_device *dev, u64 init)
+{
+	int err;
+	struct ds_status st;
+	u8 buf[9];
+
+	memcpy(buf, &init, 8);
+	buf[8] = BRANCH_MAIN;
+
+	err = ds_send_data(dev, buf, sizeof(buf));
+	if (err)
+		return err;
+
+	ds_wait_status(dev, &st);
+
+	err = ds_send_control(dev, COMM_SET_PATH | COMM_IM | COMM_RST, 0);
+	if (err)
+		return err;
+
+	ds_wait_status(dev, &st);
+
+	return 0;
+}
+
+int ds_probe(struct usb_interface *intf, const struct usb_device_id *udev_id)
+{
+	struct usb_device *udev = interface_to_usbdev(intf);
+	struct usb_endpoint_descriptor *endpoint;
+	struct usb_host_interface *iface_desc;
+	int i, err;
+
+	ds_dev = kmalloc(sizeof(struct ds_device), GFP_KERNEL);
+	if (!ds_dev) {
+		printk(KERN_INFO "Failed to allocate new DS9490R structure.\n");
+		return -ENOMEM;
+	}
+
+	ds_dev->udev = usb_get_dev(udev);
+	usb_set_intfdata(intf, ds_dev);
+
+	err = usb_set_interface(ds_dev->udev, intf->altsetting[0].desc.bInterfaceNumber, 3);
+	if (err) {
+		printk(KERN_ERR "Failed to set alternative setting 3 for %d interface: err=%d.\n",
+				intf->altsetting[0].desc.bInterfaceNumber, err);
+		return err;
+	}
+
+	err = usb_reset_configuration(ds_dev->udev);
+	if (err) {
+		printk(KERN_ERR "Failed to reset configuration: err=%d.\n", err);
+		return err;
+	}
+
+	iface_desc = &intf->altsetting[0];
+	if (iface_desc->desc.bNumEndpoints != NUM_EP-1) {
+		printk(KERN_INFO "Num endpoints=%d. It is not DS9490R.\n", iface_desc->desc.bNumEndpoints);
+		return -ENODEV;
+	}
+
+	atomic_set(&ds_dev->refcnt, 0);
+	memset(ds_dev->ep, 0, sizeof(ds_dev->ep));
+
+	/*
+	 * This loop doesn'd show control 0 endpoint,
+	 * so we will fill only 1-3 endpoints entry.
+	 */
+	for (i = 0; i < iface_desc->desc.bNumEndpoints; ++i) {
+		endpoint = &iface_desc->endpoint[i].desc;
+
+		ds_dev->ep[i+1] = endpoint->bEndpointAddress;
+
+		printk("%d: addr=%x, size=%d, dir=%s, type=%x\n",
+			i, endpoint->bEndpointAddress, endpoint->wMaxPacketSize,
+			(endpoint->bEndpointAddress & USB_DIR_IN)?"IN":"OUT",
+			endpoint->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK);
+	}
+
+#if 0
+	{
+		int err, i;
+		u64 buf[3];
+		u64 init=0xb30000002078ee81ull;
+		struct ds_status st;
+
+		ds_reset(ds_dev, &st);
+		err = ds_search(ds_dev, init, buf, 3, 0);
+		if (err < 0)
+			return err;
+		for (i=0; i<err; ++i)
+			printk("%d: %llx\n", i, buf[i]);
+
+		printk("Resetting...\n");
+		ds_reset(ds_dev, &st);
+		printk("Setting path for %llx.\n", init);
+		err = ds_set_path(ds_dev, init);
+		if (err)
+			return err;
+		printk("Calling MATCH_ACCESS.\n");
+		err = ds_match_access(ds_dev, init);
+		if (err)
+			return err;
+
+		printk("Searching the bus...\n");
+		err = ds_search(ds_dev, init, buf, 3, 0);
+
+		printk("ds_search() returned %d\n", err);
+
+		if (err < 0)
+			return err;
+		for (i=0; i<err; ++i)
+			printk("%d: %llx\n", i, buf[i]);
+
+		return 0;
+	}
+#endif
+
+	return 0;
+}
+
+void ds_disconnect(struct usb_interface *intf)
+{
+	struct ds_device *dev;
+
+	dev = usb_get_intfdata (intf);
+	usb_set_intfdata (intf, NULL);
+
+	while(atomic_read(&dev->refcnt))
+		schedule_timeout(HZ);
+
+	usb_put_dev(dev->udev);
+	kfree(dev);
+	ds_dev = NULL;
+}
+
+int ds_init(void)
+{
+	int err;
+
+	err = usb_register(&ds_driver);
+	if (err) {
+		printk(KERN_INFO "Failed to register DS9490R USB device: err=%d.\n", err);
+		return err;
+	}
+
+	return 0;
+}
+
+void ds_fini(void)
+{
+	usb_deregister(&ds_driver);
+}
+
+module_init(ds_init);
+module_exit(ds_fini);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Evgeniy Polyakov <johnpol@2ka.mipt.ru>");
+
+EXPORT_SYMBOL(ds_touch_bit);
+EXPORT_SYMBOL(ds_read_byte);
+EXPORT_SYMBOL(ds_read_bit);
+EXPORT_SYMBOL(ds_read_block);
+EXPORT_SYMBOL(ds_write_byte);
+EXPORT_SYMBOL(ds_write_bit);
+EXPORT_SYMBOL(ds_write_block);
+EXPORT_SYMBOL(ds_start_pulse);
+EXPORT_SYMBOL(ds_set_speed);
+EXPORT_SYMBOL(ds_reset);
+EXPORT_SYMBOL(ds_detect);
+EXPORT_SYMBOL(ds_stop_pulse);
+EXPORT_SYMBOL(ds_send_data);
+EXPORT_SYMBOL(ds_recv_data);
+EXPORT_SYMBOL(ds_recv_status);
+EXPORT_SYMBOL(ds_search);
+EXPORT_SYMBOL(ds_get_device);
+EXPORT_SYMBOL(ds_put_device);
+
Index: xx-sources/drivers/w1/dscore.h
===================================================================
--- xx-sources.orig/drivers/w1/dscore.h	2004-05-31 17:36:38.000000000 -0400
+++ xx-sources/drivers/w1/dscore.h	2004-08-14 13:17:24.793767208 -0400
@@ -0,0 +1,173 @@
+/*
+ * 	dscore.h
+ *
+ * Copyright (c) 2004 Evgeniy Polyakov <johnpol@2ka.mipt.ru>
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#ifndef __DSCORE_H
+#define __DSCORE_H
+
+#include <linux/usb.h>
+#include <asm/atomic.h>
+
+/* COMMAND TYPE CODES */
+#define CONTROL_CMD			0x00
+#define COMM_CMD			0x01
+#define MODE_CMD			0x02
+
+/* CONTROL COMMAND CODES */
+#define CTL_RESET_DEVICE		0x0000
+#define CTL_START_EXE			0x0001
+#define CTL_RESUME_EXE			0x0002
+#define CTL_HALT_EXE_IDLE		0x0003
+#define CTL_HALT_EXE_DONE		0x0004
+#define CTL_FLUSH_COMM_CMDS		0x0007
+#define CTL_FLUSH_RCV_BUFFER		0x0008
+#define CTL_FLUSH_XMT_BUFFER		0x0009
+#define CTL_GET_COMM_CMDS		0x000A
+
+/* MODE COMMAND CODES */
+#define MOD_PULSE_EN			0x0000
+#define MOD_SPEED_CHANGE_EN		0x0001
+#define MOD_1WIRE_SPEED			0x0002
+#define MOD_STRONG_PU_DURATION		0x0003
+#define MOD_PULLDOWN_SLEWRATE		0x0004
+#define MOD_PROG_PULSE_DURATION		0x0005
+#define MOD_WRITE1_LOWTIME		0x0006
+#define MOD_DSOW0_TREC			0x0007
+
+/* COMMUNICATION COMMAND CODES */
+#define COMM_ERROR_ESCAPE		0x0601
+#define COMM_SET_DURATION		0x0012
+#define COMM_BIT_IO			0x0020
+#define COMM_PULSE			0x0030
+#define COMM_1_WIRE_RESET		0x0042
+#define COMM_BYTE_IO			0x0052
+#define COMM_MATCH_ACCESS		0x0064
+#define COMM_BLOCK_IO			0x0074
+#define COMM_READ_STRAIGHT		0x0080
+#define COMM_DO_RELEASE			0x6092
+#define COMM_SET_PATH			0x00A2
+#define COMM_WRITE_SRAM_PAGE		0x00B2
+#define COMM_WRITE_EPROM		0x00C4
+#define COMM_READ_CRC_PROT_PAGE		0x00D4
+#define COMM_READ_REDIRECT_PAGE_CRC	0x21E4
+#define COMM_SEARCH_ACCESS		0x00F4
+
+/* Communication command bits */
+#define COMM_TYPE			0x0008
+#define COMM_SE				0x0008
+#define COMM_D				0x0008
+#define COMM_Z				0x0008
+#define COMM_CH				0x0008
+#define COMM_SM				0x0008
+#define COMM_R				0x0008
+#define COMM_IM				0x0001
+
+#define COMM_PS				0x4000
+#define COMM_PST			0x4000
+#define COMM_CIB			0x4000
+#define COMM_RTS			0x4000
+#define COMM_DT				0x2000
+#define COMM_SPU			0x1000
+#define COMM_F				0x0800
+#define COMM_NTP			0x0400
+#define COMM_ICP			0x0200
+#define COMM_RST			0x0100
+
+#define PULSE_PROG			0x01
+#define PULSE_SPUE			0x02
+
+#define BRANCH_MAIN			0xCC
+#define BRANCH_AUX			0x33
+
+/*
+ * Duration of the strong pull-up pulse in milliseconds.
+ */
+#define PULLUP_PULSE_DURATION		750
+
+/* Status flags */
+#define ST_SPUA				0x01  /* Strong Pull-up is active */
+#define ST_PRGA				0x02  /* 12V programming pulse is being generated */
+#define ST_12VP				0x04  /* external 12V programming voltage is present */
+#define ST_PMOD				0x08  /* DS2490 powered from USB and external sources */
+#define ST_HALT				0x10  /* DS2490 is currently halted */
+#define ST_IDLE				0x20  /* DS2490 is currently idle */
+#define ST_EPOF				0x80
+
+#define SPEED_NORMAL			0x00
+#define SPEED_FLEXIBLE			0x01
+#define SPEED_OVERDRIVE			0x02
+
+#define NUM_EP				4
+#define EP_CONTROL			0
+#define EP_STATUS			1
+#define EP_DATA_OUT			2
+#define EP_DATA_IN			3
+
+struct ds_device
+{
+	struct usb_device 	*udev;
+	struct usb_interface	*intf;
+
+	int			ep[NUM_EP];
+
+	atomic_t		refcnt;
+};
+
+struct ds_status
+{
+	u8			enable;
+	u8			speed;
+	u8			pullup_dur;
+	u8			ppuls_dur;
+	u8			pulldown_slew;
+	u8			write1_time;
+	u8			write0_time;
+	u8			reserved0;
+	u8			status;
+	u8			command0;
+	u8			command1;
+	u8			command_buffer_status;
+	u8			data_out_buffer_status;
+	u8			data_in_buffer_status;
+	u8			reserved1;
+	u8			reserved2;
+
+};
+
+inline int ds_touch_bit(struct ds_device *, u8, u8 *);
+inline int ds_read_byte(struct ds_device *, u8 *);
+inline int ds_read_bit(struct ds_device *, u8 *);
+inline int ds_write_byte(struct ds_device *, u8);
+inline int ds_write_bit(struct ds_device *, u8);
+inline int ds_start_pulse(struct ds_device *, int);
+inline int ds_set_speed(struct ds_device *, int);
+inline int ds_reset(struct ds_device *, struct ds_status *);
+inline int ds_detect(struct ds_device *, struct ds_status *);
+inline int ds_stop_pulse(struct ds_device *, int);
+inline int ds_send_data(struct ds_device *, unsigned char *, int);
+inline int ds_recv_data(struct ds_device *, unsigned char *, int);
+inline int ds_recv_status(struct ds_device *, struct ds_status *);
+inline struct ds_device * ds_get_device(void);
+inline void ds_put_device(struct ds_device *);
+inline int ds_write_block(struct ds_device *, u8 *, int);
+inline int ds_read_block(struct ds_device *, u8 *, int);
+
+#endif /* __DSCORE_H */
+
Index: xx-sources/drivers/w1/matrox_w1.c
===================================================================
--- xx-sources.orig/drivers/w1/matrox_w1.c	2004-08-14 01:37:25.000000000 -0400
+++ xx-sources/drivers/w1/matrox_w1.c	2004-08-14 13:17:24.795766904 -0400
@@ -94,7 +94,7 @@
 /*
  * These functions read and write DDC Data bit.
  *
- * Using tristate pins, since i can't  fin any open-drain pin in whole motherboard.
+ * Using tristate pins, since i can't find any open-drain pin in whole motherboard.
  * Unfortunately we can't connect to Intel's 82801xx IO controller
  * since we don't know motherboard schema, wich has pretty unused(may be not) GPIO.
  *
Index: xx-sources/drivers/w1/w1.c
===================================================================
--- xx-sources.orig/drivers/w1/w1.c	2004-08-14 01:36:44.000000000 -0400
+++ xx-sources/drivers/w1/w1.c	2004-08-14 13:17:24.798766448 -0400
@@ -45,7 +45,7 @@
 MODULE_AUTHOR("Evgeniy Polyakov <johnpol@2ka.mipt.ru>");
 MODULE_DESCRIPTION("Driver for 1-wire Dallas network protocol.");
 
-static int w1_timeout = 5 * HZ;
+static int w1_timeout = 10;
 int w1_max_slave_count = 10;
 
 module_param_named(timeout, w1_timeout, int, 0);
@@ -137,25 +137,95 @@
 	.show = &w1_default_read_name,
 };
 
-static ssize_t w1_master_attribute_show(struct device *dev, char *buf)
+ssize_t w1_master_attribute_show_name(struct device *dev, char *buf)
+{
+	struct w1_master *md = container_of (dev, struct w1_master, dev);
+	ssize_t count;
+
+	if (down_interruptible (&md->mutex))
+		return -EBUSY;
+
+	count = sprintf(buf, "%s\n", md->name);
+
+	up(&md->mutex);
+
+	return count;
+}
+
+ssize_t w1_master_attribute_show_pointer(struct device *dev, char *buf)
+{
+	struct w1_master *md = container_of(dev, struct w1_master, dev);
+	ssize_t count;
+
+	if (down_interruptible(&md->mutex))
+		return -EBUSY;
+
+	count = sprintf(buf, "0x%p\n", md->bus_master);
+
+	up(&md->mutex);
+	return count;
+}
+
+ssize_t w1_master_attribute_show_timeout(struct device *dev, char *buf)
+{
+	ssize_t count;
+	count = sprintf(buf, "%d\n", w1_timeout);
+	return count;
+}
+
+ssize_t w1_master_attribute_show_max_slave_count(struct device *dev, char *buf)
+{
+	struct w1_master *md = container_of(dev, struct w1_master, dev);
+	ssize_t count;
+
+	if (down_interruptible(&md->mutex))
+		return -EBUSY;
+
+	count = sprintf(buf, "%d\n", md->max_slave_count);
+
+	up(&md->mutex);
+	return count;
+}
+
+ssize_t w1_master_attribute_show_attempts(struct device *dev, char *buf)
+{
+	struct w1_master *md = container_of(dev, struct w1_master, dev);
+	ssize_t count;
+
+	if (down_interruptible(&md->mutex))
+		return -EBUSY;
+
+	count = sprintf(buf, "%lu\n", md->attempts);
+
+	up(&md->mutex);
+	return count;
+}
+
+ssize_t w1_master_attribute_show_slave_count(struct device *dev, char *buf)
+{
+	struct w1_master *md = container_of(dev, struct w1_master, dev);
+	ssize_t count;
+
+	if (down_interruptible(&md->mutex))
+		return -EBUSY;
+
+	count = sprintf(buf, "%d\n", md->slave_count);
+
+	up(&md->mutex);
+	return count;
+}
+
+ssize_t w1_master_attribute_show_slaves(struct device *dev, char *buf)
+
 {
-	return sprintf(buf, "please fix me\n");
-#if 0
 	struct w1_master *md = container_of(dev, struct w1_master, dev);
 	int c = PAGE_SIZE;
 
 	if (down_interruptible(&md->mutex))
 		return -EBUSY;
 
-	c -= snprintf(buf + PAGE_SIZE - c, c, "%s\n", md->name);
-	c -= snprintf(buf + PAGE_SIZE - c, c,
-		       "bus_master=0x%p, timeout=%d, max_slave_count=%d, attempts=%lu\n",
-		       md->bus_master, w1_timeout, md->max_slave_count,
-		       md->attempts);
-	c -= snprintf(buf + PAGE_SIZE - c, c, "%d slaves: ",
-		       md->slave_count);
 	if (md->slave_count == 0)
-		c -= snprintf(buf + PAGE_SIZE - c, c, "no.\n");
+		c -= snprintf(buf + PAGE_SIZE - c, c, "not found.\n");
 	else {
 		struct list_head *ent, *n;
 		struct w1_slave *sl;
@@ -163,25 +233,70 @@
 		list_for_each_safe(ent, n, &md->slist) {
 			sl = list_entry(ent, struct w1_slave, w1_slave_entry);
 
-			c -= snprintf(buf + PAGE_SIZE - c, c, "%s[%p] ",
-				       sl->name, sl);
+ 			c -= snprintf(buf + PAGE_SIZE - c, c, "%s\n", sl->name);
 		}
-		c -= snprintf(buf + PAGE_SIZE - c, c, "\n");
 	}
 
 	up(&md->mutex);
 
 	return PAGE_SIZE - c;
-#endif
 }
 
-struct device_attribute w1_master_attribute = {
+static struct device_attribute w1_master_attribute_slaves = {
 	.attr = {
-			.name = "w1_master_stats",
+ 			.name = "w1_master_slaves",
 			.mode = S_IRUGO,
 			.owner = THIS_MODULE,
 	},
-	.show = &w1_master_attribute_show,
+ 	.show = &w1_master_attribute_show_slaves,
+};
+static struct device_attribute w1_master_attribute_slave_count = {
+	.attr = {
+			.name = "w1_master_slave_count",
+			.mode = S_IRUGO,
+			.owner = THIS_MODULE
+	},
+	.show = &w1_master_attribute_show_slave_count,
+};
+static struct device_attribute w1_master_attribute_attempts = {
+	.attr = {
+			.name = "w1_master_attempts",
+			.mode = S_IRUGO,
+			.owner = THIS_MODULE
+	},
+	.show = &w1_master_attribute_show_attempts,
+};
+static struct device_attribute w1_master_attribute_max_slave_count = {
+	.attr = {
+			.name = "w1_master_max_slave_count",
+			.mode = S_IRUGO,
+			.owner = THIS_MODULE
+	},
+	.show = &w1_master_attribute_show_max_slave_count,
+};
+static struct device_attribute w1_master_attribute_timeout = {
+	.attr = {
+			.name = "w1_master_timeout",
+			.mode = S_IRUGO,
+			.owner = THIS_MODULE
+	},
+	.show = &w1_master_attribute_show_timeout,
+};
+static struct device_attribute w1_master_attribute_pointer = {
+	.attr = {
+			.name = "w1_master_pointer",
+			.mode = S_IRUGO,
+			.owner = THIS_MODULE
+	},
+	.show = &w1_master_attribute_show_pointer,
+};
+static struct device_attribute w1_master_attribute_name = {
+	.attr = {
+			.name = "w1_master_name",
+			.mode = S_IRUGO,
+			.owner = THIS_MODULE
+	},
+	.show = &w1_master_attribute_show_name,
 };
 
 static struct bin_attribute w1_slave_bin_attribute = {
@@ -204,11 +319,11 @@
 	sl->dev.release = &w1_slave_release;
 
 	snprintf(&sl->dev.bus_id[0], sizeof(sl->dev.bus_id),
-		  "%x-%llx",
+		  "%02x-%012llx",
 		  (unsigned int) sl->reg_num.family,
 		  (unsigned long long) sl->reg_num.id);
 	snprintf (&sl->name[0], sizeof(sl->name),
-		  "%x-%llx",
+		  "%02x-%012llx",
 		  (unsigned int) sl->reg_num.family,
 		  (unsigned long long) sl->reg_num.id);
 
@@ -223,12 +338,16 @@
 		return err;
 	}
 
-	w1_slave_bin_attribute.read = sl->family->fops->rbin;
-	w1_slave_attribute.show = sl->family->fops->rname;
-	w1_slave_attribute_val.show = sl->family->fops->rval;
-	w1_slave_attribute_val.attr.name = sl->family->fops->rvalname;
+	memcpy(&sl->attr_bin, &w1_slave_bin_attribute, sizeof(sl->attr_bin));
+	memcpy(&sl->attr_name, &w1_slave_attribute, sizeof(sl->attr_name));
+	memcpy(&sl->attr_val, &w1_slave_attribute_val, sizeof(sl->attr_val));
+
+	sl->attr_bin.read = sl->family->fops->rbin;
+	sl->attr_name.show = sl->family->fops->rname;
+	sl->attr_val.show = sl->family->fops->rval;
+	sl->attr_val.attr.name = sl->family->fops->rvalname;
 
-	err = device_create_file(&sl->dev, &w1_slave_attribute);
+	err = device_create_file(&sl->dev, &sl->attr_name);
 	if (err < 0) {
 		dev_err(&sl->dev,
 			 "sysfs file creation for [%s] failed. err=%d\n",
@@ -237,23 +356,23 @@
 		return err;
 	}
 
-	err = device_create_file(&sl->dev, &w1_slave_attribute_val);
+	err = device_create_file(&sl->dev, &sl->attr_val);
 	if (err < 0) {
 		dev_err(&sl->dev,
 			 "sysfs file creation for [%s] failed. err=%d\n",
 			 sl->dev.bus_id, err);
-		device_remove_file(&sl->dev, &w1_slave_attribute);
+		device_remove_file(&sl->dev, &sl->attr_name);
 		device_unregister(&sl->dev);
 		return err;
 	}
 
-	err = sysfs_create_bin_file(&sl->dev.kobj, &w1_slave_bin_attribute);
+	err = sysfs_create_bin_file(&sl->dev.kobj, &sl->attr_bin);
 	if (err < 0) {
 		dev_err(&sl->dev,
 			 "sysfs file creation for [%s] failed. err=%d\n",
 			 sl->dev.bus_id, err);
-		device_remove_file(&sl->dev, &w1_slave_attribute);
-		device_remove_file(&sl->dev, &w1_slave_attribute_val);
+		device_remove_file(&sl->dev, &sl->attr_name);
+		device_remove_file(&sl->dev, &sl->attr_val);
 		device_unregister(&sl->dev);
 		return err;
 	}
@@ -268,6 +387,7 @@
 	struct w1_slave *sl;
 	struct w1_family *f;
 	int err;
+	struct w1_netlink_msg msg;
 
 	sl = kmalloc(sizeof(struct w1_slave), GFP_KERNEL);
 	if (!sl) {
@@ -281,6 +401,7 @@
 
 	sl->owner = THIS_MODULE;
 	sl->master = dev;
+	set_bit(W1_SLAVE_ACTIVE, (long *)&sl->flags);
 
 	memcpy(&sl->reg_num, rn, sizeof(sl->reg_num));
 	atomic_set(&sl->refcnt, 0);
@@ -290,8 +411,8 @@
 	f = w1_family_registered(rn->family);
 	if (!f) {
 		spin_unlock(&w1_flock);
-		dev_info(&dev->dev, "Family %x is not registered.\n",
-			  rn->family);
+		dev_info(&dev->dev, "Family %x for %02x.%012llx.%02x is not registered.\n",
+			  rn->family, rn->family, rn->id, rn->crc);
 		kfree(sl);
 		return -ENODEV;
 	}
@@ -312,20 +433,31 @@
 
 	dev->slave_count++;
 
+	memcpy(&msg.id.id, rn, sizeof(msg.id.id));
+	msg.type = W1_SLAVE_ADD;
+	w1_netlink_send(dev, &msg);
+
 	return 0;
 }
 
 static void w1_slave_detach(struct w1_slave *sl)
 {
+	struct w1_netlink_msg msg;
+
 	dev_info(&sl->dev, "%s: detaching %s.\n", __func__, sl->name);
 
 	while (atomic_read(&sl->refcnt))
 		schedule_timeout(10);
 
-	sysfs_remove_bin_file(&sl->dev.kobj, &w1_slave_bin_attribute);
-	device_remove_file(&sl->dev, &w1_slave_attribute);
+	sysfs_remove_bin_file (&sl->dev.kobj, &sl->attr_bin);
+	device_remove_file(&sl->dev, &sl->attr_name);
+	device_remove_file(&sl->dev, &sl->attr_val);
 	device_unregister(&sl->dev);
 	w1_family_put(sl->family);
+
+	memcpy(&msg.id.id, &sl->reg_num, sizeof(msg.id.id));
+	msg.type = W1_SLAVE_REMOVE;
+	w1_netlink_send(sl->master, &msg);
 }
 
 static void w1_search(struct w1_master *dev)
@@ -337,12 +469,9 @@
 	struct list_head *ent;
 	struct w1_slave *sl;
 	int family_found = 0;
-	struct w1_netlink_msg msg;
 
 	dev->attempts++;
 
-	memset(&msg, 0, sizeof(msg));
-
 	search_bit = id_bit = comp_bit = 0;
 	rn = tmp = last = 0;
 	last_device = last_zero = last_family_desc = 0;
@@ -368,8 +497,6 @@
 		}
 
 #if 1
-		memset(&msg, 0, sizeof(msg));
-
 		w1_write_8(dev, W1_SEARCH);
 		for (i = 0; i < 64; ++i) {
 			/*
@@ -413,9 +540,6 @@
 
 		}
 #endif
-		msg.id.w1_id = rn;
-		msg.val = w1_calc_crc8((u8 *) & rn, 7);
-		w1_netlink_send(dev, &msg);
 
 		if (desc_bit == last_zero)
 			last_device = 1;
@@ -432,8 +556,10 @@
 
 			if (sl->reg_num.family == tmp->family &&
 			    sl->reg_num.id == tmp->id &&
-			    sl->reg_num.crc == tmp->crc)
+			    sl->reg_num.crc == tmp->crc) {
+				set_bit(W1_SLAVE_ACTIVE, (long *)&sl->flags);
 				break;
+			}
 			else if (sl->reg_num.family == tmp->family) {
 				family_found = 1;
 				break;
@@ -443,12 +569,38 @@
 		}
 
 		if (slave_count == dev->slave_count &&
-		    msg.val && (*((__u8 *) & msg.val) == msg.id.id.crc)) {
+		    ((rn >> 56) & 0xff) == w1_calc_crc8((u8 *)&rn, 7)) {
 			w1_attach_slave_device(dev, (struct w1_reg_num *) &rn);
 		}
 	}
 }
 
+int w1_create_master_attributes(struct w1_master *dev)
+{
+	if (	device_create_file(&dev->dev, &w1_master_attribute_slaves) < 0 ||
+		device_create_file(&dev->dev, &w1_master_attribute_slave_count) < 0 ||
+		device_create_file(&dev->dev, &w1_master_attribute_attempts) < 0 ||
+		device_create_file(&dev->dev, &w1_master_attribute_max_slave_count) < 0 ||
+		device_create_file(&dev->dev, &w1_master_attribute_timeout) < 0||
+		device_create_file(&dev->dev, &w1_master_attribute_pointer) < 0||
+		device_create_file(&dev->dev, &w1_master_attribute_name) < 0)
+		return -EINVAL;
+
+	return 0;
+}
+
+void w1_destroy_master_attributes(struct w1_master *dev)
+{
+	device_remove_file(&dev->dev, &w1_master_attribute_slaves);
+	device_remove_file(&dev->dev, &w1_master_attribute_slave_count);
+	device_remove_file(&dev->dev, &w1_master_attribute_attempts);
+	device_remove_file(&dev->dev, &w1_master_attribute_max_slave_count);
+	device_remove_file(&dev->dev, &w1_master_attribute_timeout);
+	device_remove_file(&dev->dev, &w1_master_attribute_pointer);
+	device_remove_file(&dev->dev, &w1_master_attribute_name);
+}
+
+
 int w1_control(void *data)
 {
 	struct w1_slave *sl;
@@ -462,7 +614,7 @@
 	while (!control_needs_exit || have_to_wait) {
 		have_to_wait = 0;
 
-		timeout = w1_timeout;
+		timeout = w1_timeout*HZ;
 		do {
 			timeout = interruptible_sleep_on_timeout(&w1_control_wait, timeout);
 			if (current->flags & PF_FREEZE)
@@ -516,7 +668,7 @@
 					kfree(sl);
 				}
 			}
-			device_remove_file(&dev->dev, &w1_master_attribute);
+			w1_destroy_master_attributes(dev);
 			atomic_dec(&dev->refcnt);
 		}
 	}
@@ -528,12 +680,14 @@
 {
 	struct w1_master *dev = (struct w1_master *) data;
 	unsigned long timeout;
+	struct list_head *ent, *n;
+	struct w1_slave *sl;
 
 	daemonize("%s", dev->name);
 	allow_signal(SIGTERM);
 
 	while (!dev->need_exit) {
-		timeout = w1_timeout;
+		timeout = w1_timeout*HZ;
 		do {
 			timeout = interruptible_sleep_on_timeout(&dev->kwait, timeout);
 			if (current->flags & PF_FREEZE)
@@ -551,7 +705,28 @@
 
 		if (down_interruptible(&dev->mutex))
 			continue;
-		w1_search(dev);
+
+		list_for_each_safe(ent, n, &dev->slist) {
+			sl = list_entry(ent, struct w1_slave, w1_slave_entry);
+
+			if (sl)
+				clear_bit(W1_SLAVE_ACTIVE, (long *)&sl->flags);
+		}
+
+      		w1_search(dev);
+
+		list_for_each_safe(ent, n, &dev->slist) {
+			sl = list_entry(ent, struct w1_slave, w1_slave_entry);
+
+			if (sl && !test_bit(W1_SLAVE_ACTIVE, (unsigned long *)&sl->flags)) {
+				list_del (&sl->w1_slave_entry);
+
+				w1_slave_detach (sl);
+				kfree (sl);
+
+				dev->slave_count--;
+			}
+		}
 		up(&dev->mutex);
 	}
 
@@ -621,3 +796,6 @@
 
 module_init(w1_init);
 module_exit(w1_fini);
+
+EXPORT_SYMBOL(w1_create_master_attributes);
+EXPORT_SYMBOL(w1_destroy_master_attributes);
Index: xx-sources/drivers/w1/w1.h
===================================================================
--- xx-sources.orig/drivers/w1/w1.h	2004-08-14 01:38:11.000000000 -0400
+++ xx-sources/drivers/w1/w1.h	2004-08-14 13:17:24.799766296 -0400
@@ -52,6 +52,8 @@
 #define W1_READ_PSUPPLY		0xB4
 #define W1_MATCH_ROM		0x55
 
+#define W1_SLAVE_ACTIVE		(1<<0)
+
 struct w1_slave
 {
 	struct module		*owner;
@@ -60,11 +62,15 @@
 	struct w1_reg_num	reg_num;
 	atomic_t		refcnt;
 	u8			rom[9];
+	u32			flags;
 
 	struct w1_master	*master;
 	struct w1_family 	*family;
 	struct device 		dev;
 	struct completion 	dev_released;
+
+	struct bin_attribute 	attr_bin;
+	struct device_attribute	attr_name, attr_val;
 };
 
 struct w1_bus_master
@@ -73,6 +79,16 @@
 
 	u8			(*read_bit)(unsigned long);
 	void			(*write_bit)(unsigned long, u8);
+
+	u8			(*read_byte)(unsigned long);
+  	void			(*write_byte)(unsigned long, u8);
+
+	u8			(*read_block)(unsigned long, u8 *, int);
+	void			(*write_block)(unsigned long, u8 *, int);
+
+  	u8			(*touch_bit)(unsigned long, u8);
+
+  	u8			(*reset_bus)(unsigned long);
 };
 
 struct w1_master
@@ -107,6 +123,9 @@
 	struct sock 		*nls;
 };
 
+int w1_create_master_attributes(struct w1_master *);
+void w1_destroy_master_attributes(struct w1_master *);
+
 #endif /* __KERNEL__ */
 
 #endif /* __W1_H */
Index: xx-sources/drivers/w1/w1_family.c
===================================================================
--- xx-sources.orig/drivers/w1/w1_family.c	2004-08-14 01:37:25.000000000 -0400
+++ xx-sources/drivers/w1/w1_family.c	2004-08-14 13:17:24.801765992 -0400
@@ -27,12 +27,23 @@
 spinlock_t w1_flock = SPIN_LOCK_UNLOCKED;
 static LIST_HEAD(w1_families);
 
+static int w1_check_family(struct w1_family *f)
+{
+	if (!f->fops->rname || !f->fops->rbin || !f->fops->rval || !f->fops->rvalname)
+		return -EINVAL;
+
+	return 0;
+}
+
 int w1_register_family(struct w1_family *newf)
 {
 	struct list_head *ent, *n;
 	struct w1_family *f;
 	int ret = 0;
 
+	if (w1_check_family(newf))
+		return -EINVAL;
+
 	spin_lock(&w1_flock);
 	list_for_each_safe(ent, n, &w1_families) {
 		f = list_entry(ent, struct w1_family, family_entry);
Index: xx-sources/drivers/w1/w1_family.h
===================================================================
--- xx-sources.orig/drivers/w1/w1_family.h	2004-08-14 01:38:08.000000000 -0400
+++ xx-sources/drivers/w1/w1_family.h	2004-08-14 13:17:24.804765536 -0400
@@ -28,7 +28,7 @@
 
 #define W1_FAMILY_DEFAULT	0
 #define W1_FAMILY_THERM		0x10
-#define W1_FAMILY_IBUT		0xff /* ? */
+#define W1_FAMILY_SMEM		0x01
 
 #define MAXNAMELEN		32
 
Index: xx-sources/drivers/w1/w1_int.c
===================================================================
--- xx-sources.orig/drivers/w1/w1_int.c	2004-08-14 01:37:40.000000000 -0400
+++ xx-sources/drivers/w1/w1_int.c	2004-08-14 13:17:24.805765384 -0400
@@ -24,13 +24,13 @@
 
 #include "w1.h"
 #include "w1_log.h"
+#include "w1_netlink.h"
 
 static u32 w1_ids = 1;
 
 extern struct device_driver w1_driver;
 extern struct bus_type w1_bus_type;
 extern struct device w1_device;
-extern struct device_attribute w1_master_attribute;
 extern int w1_max_slave_count;
 extern struct list_head w1_masters;
 extern spinlock_t w1_mlock;
@@ -119,6 +119,7 @@
 {
 	struct w1_master *dev;
 	int retval = 0;
+	struct w1_netlink_msg msg;
 
 	dev = w1_alloc_dev(w1_ids++, w1_max_slave_count, &w1_driver, &w1_device);
 	if (!dev)
@@ -133,7 +134,7 @@
 		goto err_out_free_dev;
 	}
 
-	retval = device_create_file(&dev->dev, &w1_master_attribute);
+	retval =  w1_create_master_attributes(dev);
 	if (retval)
 		goto err_out_kill_thread;
 
@@ -145,6 +146,11 @@
 	list_add(&dev->w1_master_entry, &w1_masters);
 	spin_unlock(&w1_mlock);
 
+	msg.id.mst.id = dev->id;
+	msg.id.mst.pid = dev->kpid;
+	msg.type = W1_MASTER_ADD;
+	w1_netlink_send(dev, &msg);
+
 	return 0;
 
 err_out_kill_thread:
@@ -164,6 +170,7 @@
 void __w1_remove_master_device(struct w1_master *dev)
 {
 	int err;
+	struct w1_netlink_msg msg;
 
 	dev->need_exit = 1;
 	err = kill_proc(dev->kpid, SIGTERM, 1);
@@ -175,6 +182,11 @@
 	while (atomic_read(&dev->refcnt))
 		schedule_timeout(10);
 
+	msg.id.mst.id = dev->id;
+	msg.id.mst.pid = dev->kpid;
+	msg.type = W1_MASTER_REMOVE;
+	w1_netlink_send(dev, &msg);
+
 	w1_free_dev(dev);
 }
 
Index: xx-sources/drivers/w1/w1_io.c
===================================================================
--- xx-sources.orig/drivers/w1/w1_io.c	2004-08-14 01:37:25.000000000 -0400
+++ xx-sources/drivers/w1/w1_io.c	2004-08-14 13:17:24.806765232 -0400
@@ -55,6 +55,14 @@
 	udelay(tm * w1_delay_parm);
 }
 
+u8 w1_touch_bit(struct w1_master *dev, int bit)
+{
+	if (dev->bus_master->touch_bit)
+		return dev->bus_master->touch_bit(dev->bus_master->data, bit);
+	else
+		return w1_read_bit(dev);
+}
+
 void w1_write_bit(struct w1_master *dev, int bit)
 {
 	if (bit) {
@@ -74,8 +82,11 @@
 {
 	int i;
 
-	for (i = 0; i < 8; ++i)
-		w1_write_bit(dev, (byte >> i) & 0x1);
+	if (dev->bus_master->write_byte)
+		dev->bus_master->write_byte(dev->bus_master->data, byte);
+	else
+		for (i = 0; i < 8; ++i)
+			w1_write_bit(dev, (byte >> i) & 0x1);
 }
 
 u8 w1_read_bit(struct w1_master *dev)
@@ -98,23 +109,57 @@
 	int i;
 	u8 res = 0;
 
-	for (i = 0; i < 8; ++i)
-		res |= (w1_read_bit(dev) << i);
+	if (dev->bus_master->read_byte)
+		res = dev->bus_master->read_byte(dev->bus_master->data);
+	else
+		for (i = 0; i < 8; ++i)
+			res |= (w1_read_bit(dev) << i);
 
 	return res;
 }
 
+void w1_write_block(struct w1_master *dev, u8 *buf, int len)
+{
+	int i;
+
+	if (dev->bus_master->write_block)
+		dev->bus_master->write_block(dev->bus_master->data, buf, len);
+	else
+		for (i = 0; i < len; ++i)
+			w1_write_8(dev, buf[i]);
+}
+
+u8 w1_read_block(struct w1_master *dev, u8 *buf, int len)
+{
+	int i;
+	u8 ret;
+
+	if (dev->bus_master->read_block)
+		ret = dev->bus_master->read_block(dev->bus_master->data, buf, len);
+	else {
+		for (i = 0; i < len; ++i)
+			buf[i] = w1_read_8(dev);
+		ret = len;
+	}
+
+	return ret;
+}
+
 int w1_reset_bus(struct w1_master *dev)
 {
-	int result;
+	int result = 0;
 
-	dev->bus_master->write_bit(dev->bus_master->data, 0);
-	w1_delay(480);
-	dev->bus_master->write_bit(dev->bus_master->data, 1);
-	w1_delay(70);
+	if (dev->bus_master->reset_bus)
+		result = dev->bus_master->reset_bus(dev->bus_master->data) & 0x1;
+	else {
+		dev->bus_master->write_bit(dev->bus_master->data, 0);
+		w1_delay(480);
+		dev->bus_master->write_bit(dev->bus_master->data, 1);
+		w1_delay(70);
 
-	result = dev->bus_master->read_bit(dev->bus_master->data) & 0x1;
-	w1_delay(410);
+		result = dev->bus_master->read_bit(dev->bus_master->data) & 0x1;
+		w1_delay(410);
+	}
 
 	return result;
 }
@@ -136,3 +181,5 @@
 EXPORT_SYMBOL(w1_reset_bus);
 EXPORT_SYMBOL(w1_calc_crc8);
 EXPORT_SYMBOL(w1_delay);
+EXPORT_SYMBOL(w1_read_block);
+EXPORT_SYMBOL(w1_write_block);
Index: xx-sources/drivers/w1/w1_io.h
===================================================================
--- xx-sources.orig/drivers/w1/w1_io.h	2004-08-14 01:37:40.000000000 -0400
+++ xx-sources/drivers/w1/w1_io.h	2004-08-14 13:17:24.807765080 -0400
@@ -25,11 +25,14 @@
 #include "w1.h"
 
 void w1_delay(unsigned long);
+u8 w1_touch_bit(struct w1_master *, int);
 void w1_write_bit(struct w1_master *, int);
 void w1_write_8(struct w1_master *, u8);
 u8 w1_read_bit(struct w1_master *);
 u8 w1_read_8(struct w1_master *);
 int w1_reset_bus(struct w1_master *);
 u8 w1_calc_crc8(u8 *, int);
+void w1_write_block(struct w1_master *, u8 *, int);
+u8 w1_read_block(struct w1_master *, u8 *, int);
 
 #endif /* __W1_IO_H */
Index: xx-sources/drivers/w1/w1_netlink.h
===================================================================
--- xx-sources.orig/drivers/w1/w1_netlink.h	2004-08-14 01:37:15.000000000 -0400
+++ xx-sources/drivers/w1/w1_netlink.h	2004-08-14 13:17:24.808764928 -0400
@@ -26,14 +26,27 @@
 
 #include "w1.h"
 
+enum w1_netlink_message_types {
+	W1_SLAVE_ADD = 0,
+	W1_SLAVE_REMOVE,
+	W1_MASTER_ADD,
+	W1_MASTER_REMOVE,
+};
+
 struct w1_netlink_msg 
 {
+	__u8				type;
+	__u8				reserved[3];
 	union
 	{
 		struct w1_reg_num 	id;
 		__u64			w1_id;
+		struct
+		{
+			__u32		id;
+			__u32		pid;
+		} mst;
 	} id;
-	__u64				val;
 };
 
 #ifdef __KERNEL__
Index: xx-sources/drivers/w1/w1_smem.c
===================================================================
--- xx-sources.orig/drivers/w1/w1_smem.c	2004-05-31 17:36:38.000000000 -0400
+++ xx-sources/drivers/w1/w1_smem.c	2004-08-14 13:17:24.808764928 -0400
@@ -0,0 +1,118 @@
+/*
+ * 	w1_smem.c
+ *
+ * Copyright (c) 2004 Evgeniy Polyakov <johnpol@2ka.mipt.ru>
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the smems of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+
+#include <asm/types.h>
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/device.h>
+#include <linux/types.h>
+
+#include "w1.h"
+#include "w1_io.h"
+#include "w1_int.h"
+#include "w1_family.h"
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Evgeniy Polyakov <johnpol@2ka.mipt.ru>");
+MODULE_DESCRIPTION("Driver for 1-wire Dallas network protocol, 64bit memory family.");
+
+static ssize_t w1_smem_read_name(struct device *, char *);
+static ssize_t w1_smem_read_val(struct device *, char *);
+static ssize_t w1_smem_read_bin(struct kobject *, char *, loff_t, size_t);
+
+static struct w1_family_ops w1_smem_fops = {
+	.rname = &w1_smem_read_name,
+	.rbin = &w1_smem_read_bin,
+	.rval = &w1_smem_read_val,
+	.rvalname = "id",
+};
+
+static ssize_t w1_smem_read_name(struct device *dev, char *buf)
+{
+	struct w1_slave *sl = container_of(dev, struct w1_slave, dev);
+
+	return sprintf(buf, "%s\n", sl->name);
+}
+
+static ssize_t w1_smem_read_val(struct device *dev, char *buf)
+{
+	struct w1_slave *sl = container_of(dev, struct w1_slave, dev);
+	int i;
+	ssize_t count = 0;
+
+	for (i = 0; i < 9; ++i)
+		count += sprintf(buf + count, "%02x ", ((u8 *)&sl->reg_num)[i]);
+	count += sprintf(buf + count, "\n");
+
+	return count;
+}
+
+static ssize_t w1_smem_read_bin(struct kobject *kobj, char *buf, loff_t off, size_t count)
+{
+	struct w1_slave *sl = container_of(container_of(kobj, struct device, kobj),
+			      			struct w1_slave, dev);
+	int i;
+
+	atomic_inc(&sl->refcnt);
+	if (down_interruptible(&sl->master->mutex)) {
+		count = 0;
+		goto out_dec;
+	}
+
+	if (off > W1_SLAVE_DATA_SIZE) {
+		count = 0;
+		goto out;
+	}
+	if (off + count > W1_SLAVE_DATA_SIZE) {
+		count = 0;
+		goto out;
+	}
+	for (i = 0; i < 9; ++i)
+		count += sprintf(buf + count, "%02x ", ((u8 *)&sl->reg_num)[i]);
+	count += sprintf(buf + count, "\n");
+
+out:
+	up(&sl->master->mutex);
+out_dec:
+	atomic_dec(&sl->refcnt);
+
+	return count;
+}
+
+static struct w1_family w1_smem_family = {
+	.fid = W1_FAMILY_SMEM,
+	.fops = &w1_smem_fops,
+};
+
+static int __init w1_smem_init(void)
+{
+	return w1_register_family(&w1_smem_family);
+}
+
+static void __exit w1_smem_fini(void)
+{
+	w1_unregister_family(&w1_smem_family);
+}
+
+module_init(w1_smem_init);
+module_exit(w1_smem_fini);
Index: xx-sources/drivers/w1/w1_therm.c
===================================================================
--- xx-sources.orig/drivers/w1/w1_therm.c	2004-08-14 01:36:16.000000000 -0400
+++ xx-sources/drivers/w1/w1_therm.c	2004-08-14 13:17:24.809764776 -0400
@@ -36,6 +36,11 @@
 MODULE_AUTHOR("Evgeniy Polyakov <johnpol@2ka.mipt.ru>");
 MODULE_DESCRIPTION("Driver for 1-wire Dallas network protocol, temperature family.");
 
+static u8 bad_roms[][9] = {
+				{0xaa, 0x00, 0x4b, 0x46, 0xff, 0xff, 0x0c, 0x10, 0x87},
+				{}
+			};
+
 static ssize_t w1_therm_read_name(struct device *, char *);
 static ssize_t w1_therm_read_temp(struct device *, char *);
 static ssize_t w1_therm_read_bin(struct kobject *, char *, loff_t, size_t);
@@ -69,14 +74,24 @@
 	return sprintf(buf, "%d\n", temp * 1000);
 }
 
+static int w1_therm_check_rom(u8 rom[9])
+{
+	int i;
+
+	for (i=0; i<sizeof(bad_roms)/9; ++i)
+		if (!memcmp(bad_roms[i], rom, 9))
+			return 1;
+
+	return 0;
+}
+
 static ssize_t w1_therm_read_bin(struct kobject *kobj, char *buf, loff_t off, size_t count)
 {
 	struct w1_slave *sl = container_of(container_of(kobj, struct device, kobj),
 			      			struct w1_slave, dev);
 	struct w1_master *dev = sl->master;
 	u8 rom[9], crc, verdict;
-	size_t icount;
-	int i;
+	int i, max_trying = 10;
 	u16 temp;
 
 	atomic_inc(&sl->refcnt);
@@ -89,10 +104,10 @@
 		count = 0;
 		goto out;
 	}
-	if (off + count > W1_SLAVE_DATA_SIZE)
-		count = W1_SLAVE_DATA_SIZE - off;
-
-	icount = count;
+	if (off + count > W1_SLAVE_DATA_SIZE) {
+		count = 0;
+		goto out;
+	}
 
 	memset(buf, 0, count);
 	memset(rom, 0, sizeof(rom));
@@ -100,56 +115,54 @@
 	count = 0;
 	verdict = 0;
 	crc = 0;
-	if (!w1_reset_bus(dev)) {
-		u64 id = *(u64 *) & sl->reg_num;
-		int count = 0;
-
-		w1_write_8(dev, W1_MATCH_ROM);
-		for (i = 0; i < 8; ++i)
-			w1_write_8(dev, (id >> i * 8) & 0xff);
-
-		w1_write_8(dev, W1_CONVERT_TEMP);
-
-		while (dev->bus_master->read_bit(dev->bus_master->data) == 0
-		       && count < 10) {
-			w1_delay(1);
-			count++;
-		}
 
-		if (count < 10) {
-			if (!w1_reset_bus(dev)) {
-				w1_write_8(dev, W1_MATCH_ROM);
-				for (i = 0; i < 8; ++i)
-					w1_write_8(dev,
-						   (id >> i * 8) & 0xff);
-
-				w1_write_8(dev, W1_READ_SCRATCHPAD);
-				for (i = 0; i < 9; ++i)
-					rom[i] = w1_read_8(dev);
+	while (max_trying--) {
+		if (!w1_reset_bus (dev)) {
+			int count = 0;
+			u8 match[9] = {W1_MATCH_ROM, };
+
+			memcpy(&match[1], (u64 *) & sl->reg_num, 8);
+
+			w1_write_block(dev, match, 9);
 
-				crc = w1_calc_crc8(rom, 8);
+			w1_write_8(dev, W1_CONVERT_TEMP);
 
-				if (rom[8] == crc && rom[0])
-					verdict = 1;
+			if (count < 10) {
+				if (!w1_reset_bus(dev)) {
+					w1_write_block(dev, match, 9);
+
+					w1_write_8(dev, W1_READ_SCRATCHPAD);
+					if ((count = w1_read_block(dev, rom, 9)) != 9) {
+						dev_warn(&dev->dev, "w1_read_block() returned %d instead of 9.\n", count);
+					}
+
+					crc = w1_calc_crc8(rom, 8);
+
+					if (rom[8] == crc && rom[0])
+						verdict = 1;
+				}
 			}
+			else
+				dev_warn(&dev->dev,
+					  "18S20 doesn't respond to CONVERT_TEMP.\n");
 		}
-		else
-			dev_warn(&dev->dev,
-				  "18S20 doesn't respond to CONVERT_TEMP.\n");
+
+		if (!w1_therm_check_rom(rom))
+			break;
 	}
 
 	for (i = 0; i < 9; ++i)
-		count += snprintf(buf + count, icount - count, "%02x ", rom[i]);
-	count += snprintf(buf + count, icount - count, ": crc=%02x %s\n",
+		count += sprintf(buf + count, "%02x ", rom[i]);
+	count += sprintf(buf + count, ": crc=%02x %s\n",
 			   crc, (verdict) ? "YES" : "NO");
 	if (verdict)
 		memcpy(sl->rom, rom, sizeof(sl->rom));
 	for (i = 0; i < 9; ++i)
-		count += snprintf(buf + count, icount - count, "%02x ", sl->rom[i]);
+		count += sprintf(buf + count, "%02x ", sl->rom[i]);
 	temp = 0;
 	temp <<= sl->rom[1] / 2;
 	temp |= sl->rom[0] / 2;
-	count += snprintf(buf + count, icount - count, "t=%u\n", temp);
+	count += sprintf(buf + count, "t=%u\n", temp);
 out:
 	up(&dev->mutex);
 out_dec:
Index: xx-sources/include/asm-generic/vmlinux.lds.h
===================================================================
--- xx-sources.orig/include/asm-generic/vmlinux.lds.h	2004-08-14 01:36:13.000000000 -0400
+++ xx-sources/include/asm-generic/vmlinux.lds.h	2004-08-14 13:17:24.810764624 -0400
@@ -16,6 +16,16 @@
 		*(.rodata1)						\
 	}								\
 									\
+	/* PCI quirks */						\
+	.pci_fixup        : AT(ADDR(.pci_fixup) - LOAD_OFFSET) {	\
+		VMLINUX_SYMBOL(__start_pci_fixups_header) = .;		\
+		*(.pci_fixup_header)					\
+		VMLINUX_SYMBOL(__end_pci_fixups_header) = .;		\
+		VMLINUX_SYMBOL(__start_pci_fixups_final) = .;		\
+		*(.pci_fixup_final)					\
+		VMLINUX_SYMBOL(__end_pci_fixups_final) = .;		\
+	}								\
+									\
 	/* Kernel symbol table: Normal symbols */			\
 	__ksymtab         : AT(ADDR(__ksymtab) - LOAD_OFFSET) {		\
 		VMLINUX_SYMBOL(__start___ksymtab) = .;			\
Index: xx-sources/include/asm-ppc/fsl_ocp.h
===================================================================
--- xx-sources.orig/include/asm-ppc/fsl_ocp.h	2004-08-14 01:37:40.000000000 -0400
+++ xx-sources/include/asm-ppc/fsl_ocp.h	2004-08-14 13:17:24.811764472 -0400
@@ -48,7 +48,7 @@
 
 /* Flags for I2C */
 #define FS_I2C_SEPARATE_DFSRR	0x02
-#define FS_I2C_32BIT		0x01
+#define FS_I2C_CLOCK_5200	0x01
 
 #endif	/* __ASM_FS_OCP_H__ */
 #endif	/* __KERNEL__ */
Index: xx-sources/include/linux/i2c-algo-pca.h
===================================================================
--- xx-sources.orig/include/linux/i2c-algo-pca.h	2004-05-31 17:36:38.000000000 -0400
+++ xx-sources/include/linux/i2c-algo-pca.h	2004-08-14 13:17:24.811764472 -0400
@@ -0,0 +1,17 @@
+#ifndef _LINUX_I2C_ALGO_PCA_H
+#define _LINUX_I2C_ALGO_PCA_H
+
+struct i2c_algo_pca_data {
+	int  (*get_own)			(struct i2c_algo_pca_data *adap); /* Obtain own address */
+	int  (*get_clock)		(struct i2c_algo_pca_data *adap);
+	void (*write_byte)		(struct i2c_algo_pca_data *adap, int reg, int val);
+	int  (*read_byte)		(struct i2c_algo_pca_data *adap, int reg);
+	int  (*wait_for_interrupt)	(struct i2c_algo_pca_data *adap);
+};
+
+#define I2C_PCA_ADAP_MAX	16
+
+int i2c_pca_add_bus(struct i2c_adapter *);
+int i2c_pca_del_bus(struct i2c_adapter *);
+
+#endif /* _LINUX_I2C_ALGO_PCA_H */
Index: xx-sources/include/linux/i2c-id.h
===================================================================
--- xx-sources.orig/include/linux/i2c-id.h	2004-08-14 01:36:13.000000000 -0400
+++ xx-sources/include/linux/i2c-id.h	2004-08-14 13:17:24.812764320 -0400
@@ -194,6 +194,7 @@
 #define I2C_ALGO_OCP    0x120000	/* IBM or otherwise On-chip I2C algorithm */
 #define I2C_ALGO_BITHS	0x130000	/* enhanced bit style adapters	*/
 #define I2C_ALGO_OCP_IOP3XX  0x140000	/* XSCALE IOP3XX On-chip I2C alg */
+#define I2C_ALGO_PCA	0x150000	/* PCA 9564 style adapters	*/
 
 #define I2C_ALGO_EXP	0x800000	/* experimental			*/
 
@@ -239,6 +240,9 @@
 #define I2C_HW_P_ISA	0x01	/* generic ISA Bus inteface card	*/
 #define I2C_HW_P_ELEK	0x02	/* Elektor ISA Bus inteface card	*/
 
+/* --- PCA 9564 based algorithms */
+#define I2C_HW_A_ISA	0x00	/* generic ISA Bus interface card	*/
+
 /* --- ACPI Embedded controller algorithms                              */
 #define I2C_HW_ACPI_EC          0x00
 
Index: xx-sources/include/linux/i2c-vid.h
===================================================================
--- xx-sources.orig/include/linux/i2c-vid.h	2004-08-14 01:36:12.000000000 -0400
+++ xx-sources/include/linux/i2c-vid.h	2004-08-14 13:17:24.813764168 -0400
@@ -35,12 +35,15 @@
     to avoid floating point in the kernel.
 */
 
+int i2c_which_vrm(void);
+
 #define DEFAULT_VRM	82
 
 static inline int vid_from_reg(int val, int vrm)
 {
 	switch(vrm) {
-
+	case  0:
+		return 0;
 	case 91:		/* VRM 9.1 */
 	case 90:		/* VRM 9.0 */
 		return(val == 0x1f ? 0 :
Index: xx-sources/include/linux/i2c.h
===================================================================
--- xx-sources.orig/include/linux/i2c.h	2004-08-14 01:36:17.000000000 -0400
+++ xx-sources/include/linux/i2c.h	2004-08-14 13:17:24.814764016 -0400
@@ -566,7 +566,9 @@
 
 #define I2C_CLIENT_MODULE_PARM(var,desc) \
   static unsigned short var[I2C_CLIENT_MAX_OPTS] = I2C_CLIENT_DEFAULTS; \
-  MODULE_PARM(var,I2C_CLIENT_MODPARM); \
+  static unsigned int var##_num; \
+  /*MODULE_PARM(var,I2C_CLIENT_MODPARM);*/ \
+  module_param_array(var, short, var##_num, 0); \
   MODULE_PARM_DESC(var,desc)
 
 /* This is the one you want to use in your own modules */
Index: xx-sources/include/linux/moduleparam.h
===================================================================
--- xx-sources.orig/include/linux/moduleparam.h	2004-08-14 12:56:53.494953080 -0400
+++ xx-sources/include/linux/moduleparam.h	2004-08-14 13:17:24.815763864 -0400
@@ -89,6 +89,10 @@
 #define __param_check(name, p, type) \
 	static inline type *__check_##name(void) { return(p); }
 
+extern int param_set_byte(const char *val, struct kernel_param *kp);
+extern int param_get_byte(char *buffer, struct kernel_param *kp);
+#define param_check_byte(name, p) __param_check(name, p, unsigned char)
+
 extern int param_set_short(const char *val, struct kernel_param *kp);
 extern int param_get_short(char *buffer, struct kernel_param *kp);
 #define param_check_short(name, p) __param_check(name, p, short)
Index: xx-sources/include/linux/pci.h
===================================================================
--- xx-sources.orig/include/linux/pci.h	2004-08-14 01:36:57.000000000 -0400
+++ xx-sources/include/linux/pci.h	2004-08-14 13:17:24.817763560 -0400
@@ -536,7 +536,7 @@
 	unsigned int	is_enabled:1;	/* pci_enable_device has been called */
 	unsigned int	is_busmaster:1; /* device is busmaster */
 	
-	unsigned int 	saved_config_space[16]; /* config space saved at suspend time */
+	u32		saved_config_space[16]; /* config space saved at suspend time */
 #ifdef CONFIG_PCI_NAMES
 #define PCI_NAME_SIZE	96
 #define PCI_NAME_HALF	__stringify(43)	/* less than half to handle slop */
@@ -1001,17 +1001,27 @@
  */
 
 struct pci_fixup {
-	int pass;
 	u16 vendor, device;			/* You can use PCI_ANY_ID here of course */
 	void (*hook)(struct pci_dev *dev);
 };
 
-extern struct pci_fixup pcibios_fixups[];
+enum pci_fixup_pass {
+	pci_fixup_header,	/* Called immediately after reading configuration header */
+	pci_fixup_final,	/* Final phase of device fixups */
+};
 
-#define PCI_FIXUP_HEADER	1		/* Called immediately after reading configuration header */
-#define PCI_FIXUP_FINAL		2		/* Final phase of device fixups */
+/* Anonymous variables would be nice... */
+#define DECLARE_PCI_FIXUP_HEADER(vendor, device, hook)					\
+	static struct pci_fixup __pci_fixup_##vendor##device##hook __attribute_used__	\
+	__attribute__((__section__(".pci_fixup_header"))) = {				\
+		vendor, device, hook };
+
+#define DECLARE_PCI_FIXUP_FINAL(vendor, device, hook)				\
+	static struct pci_fixup __pci_fixup_##vendor##device##hook __attribute_used__	\
+	__attribute__((__section__(".pci_fixup_final"))) = {				\
+		vendor, device, hook };
 
-void pci_fixup_device(int pass, struct pci_dev *dev);
+void pci_fixup_device(enum pci_fixup_pass pass, struct pci_dev *dev);
 
 extern int pci_pci_problems;
 #define PCIPCI_FAIL		1
Index: xx-sources/include/linux/pci_ids.h
===================================================================
--- xx-sources.orig/include/linux/pci_ids.h	2004-08-14 13:01:47.067323296 -0400
+++ xx-sources/include/linux/pci_ids.h	2004-08-14 13:17:24.819763256 -0400
@@ -2230,7 +2230,9 @@
 #define PCI_DEVICE_ID_INTEL_82451NX	0x84ca
 #define PCI_DEVICE_ID_INTEL_82454NX     0x84cb
 #define PCI_DEVICE_ID_INTEL_84460GX	0x84ea
-#define	PCI_DEVICE_ID_INTEL_IXP4XX	0x8500
+#define PCI_DEVICE_ID_INTEL_IXP4XX	0x8500
+#define PCI_DEVICE_ID_INTEL_IXP2400	0x9001
+#define PCI_DEVICE_ID_INTEL_IXP2800	0x9004
 
 #define PCI_VENDOR_ID_COMPUTONE		0x8e0e
 #define PCI_DEVICE_ID_COMPUTONE_IP2EX	0x0291
Index: xx-sources/kernel/module.c
===================================================================
--- xx-sources.orig/kernel/module.c	2004-08-14 01:37:30.000000000 -0400
+++ xx-sources/kernel/module.c	2004-08-14 13:17:24.821762952 -0400
@@ -725,19 +725,6 @@
 #endif /* CONFIG_MODULE_UNLOAD */
 
 #ifdef CONFIG_OBSOLETE_MODPARM
-static int param_set_byte(const char *val, struct kernel_param *kp)  
-{
-	char *endp;
-	long l;
-
-	if (!val) return -EINVAL;
-	l = simple_strtol(val, &endp, 0);
-	if (endp == val || *endp || ((char)l != l))
-		return -EINVAL;
-	*((char *)kp->arg) = l;
-	return 0;
-}
-
 /* Bounds checking done below */
 static int obsparm_copy_string(const char *val, struct kernel_param *kp)
 {
Index: xx-sources/kernel/params.c
===================================================================
--- xx-sources.orig/kernel/params.c	2004-08-14 12:56:53.559943200 -0400
+++ xx-sources/kernel/params.c	2004-08-14 13:17:24.822762800 -0400
@@ -171,6 +171,7 @@
 		return sprintf(buffer, format, *((type *)kp->arg));	\
 	}
 
+STANDARD_PARAM_DEF(byte, unsigned char, "%c", unsigned long, simple_strtoul);
 STANDARD_PARAM_DEF(short, short, "%hi", long, simple_strtol);
 STANDARD_PARAM_DEF(ushort, unsigned short, "%hu", unsigned long, simple_strtoul);
 STANDARD_PARAM_DEF(int, int, "%i", long, simple_strtol);
@@ -345,6 +346,8 @@
 	return strlcpy(buffer, kps->string, kps->maxlen);
 }
 
+EXPORT_SYMBOL(param_set_byte);
+EXPORT_SYMBOL(param_get_byte);
 EXPORT_SYMBOL(param_set_short);
 EXPORT_SYMBOL(param_get_short);
 EXPORT_SYMBOL(param_set_ushort);
