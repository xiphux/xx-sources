
From: Dmitry Torokhov <dtor_core@ameritech.net>

  sysfs: add platform_device_register_simple to register platform devices
         requiring minimal resource and memory management. The device will
         have standard release function that just frees memory occupied by
         the platform device. By having release function in the driver core
         modules using such devices can be unloaded without waiting for the
         last reference to the device to be dropped.
  
         Suggested by Russell King
  
Signed-off-by: Dmitry Torokhov <dtor@mail.ru>
Signed-off-by: Andrew Morton <akpm@osdl.org>
---

 25-akpm/drivers/base/platform.c |   68 ++++++++++++++++++++++++++++++++++++++++
 25-akpm/include/linux/device.h  |    2 +
 2 files changed, 70 insertions(+)

diff -puN drivers/base/platform.c~input-add-platform_device_register_simple drivers/base/platform.c
--- 25/drivers/base/platform.c~input-add-platform_device_register_simple	2004-06-27 22:51:04.291542648 -0700
+++ 25-akpm/drivers/base/platform.c	2004-06-27 22:51:04.298541584 -0700
@@ -13,6 +13,7 @@
 #include <linux/device.h>
 #include <linux/module.h>
 #include <linux/init.h>
+#include <linux/err.h>
 
 struct device platform_bus = {
 	.bus_id		= "platform",
@@ -131,6 +132,13 @@ int platform_device_register(struct plat
 	return ret;
 }
 
+/**
+ *	platform_device_unregister - remove a platform-level device
+ *	@dev:	platform device we're removing
+ *
+ *	Note that this function will also release all memory- and port-based
+ *	resources owned by the device (@dev->resource).
+ */
 void platform_device_unregister(struct platform_device * pdev)
 {
 	int i;
@@ -146,6 +154,65 @@ void platform_device_unregister(struct p
 	}
 }
 
+struct platform_object {
+        struct platform_device pdev;
+        struct resource resources[0];
+};
+
+static void platform_device_release_simple(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+
+	kfree(container_of(pdev, struct platform_object, pdev));
+}
+
+/**
+ *	platform_device_register_simple
+ *	@name:  base name of the device we're adding
+ *	@id:    instance id
+ *	@res:   set of resources that needs to be allocated for the device
+ *	@num:	number of resources
+ *
+ *	This function creates a simple platform device that requires minimal
+ *	resource and memory management. Canned release function freeing
+ *	memory allocated for the device allows drivers using such devices
+ *	to be unloaded iwithout waiting for the last reference to the device
+ *	to be dropped.
+ */
+struct platform_device *platform_device_register_simple(char *name, unsigned int id,
+							struct resource *res, unsigned int num)
+{
+	struct platform_object *pobj;
+	int retval;
+
+	pobj = kmalloc(sizeof(struct platform_object) + sizeof(struct resource) * num, GFP_KERNEL);
+	if (!pobj) {
+		retval = -ENOMEM;
+		goto error;
+	}
+
+	memset(pobj, 0, sizeof(*pobj));
+	pobj->pdev.name = name;
+	pobj->pdev.id = id;
+	pobj->pdev.dev.release = platform_device_release_simple;
+
+	if (num) {
+		memcpy(pobj->resources, res, sizeof(struct resource) * num);
+		pobj->pdev.resource = pobj->resources;
+		pobj->pdev.num_resources = num;
+	}
+
+	retval = platform_device_register(&pobj->pdev);
+	if (retval)
+		goto error;
+
+	return &pobj->pdev;
+
+error:
+	kfree(pobj);
+	return ERR_PTR(retval);
+}
+
 
 /**
  *	platform_match - bind platform device to platform driver.
@@ -213,6 +280,7 @@ int __init platform_bus_init(void)
 EXPORT_SYMBOL(platform_bus);
 EXPORT_SYMBOL(platform_bus_type);
 EXPORT_SYMBOL(platform_device_register);
+EXPORT_SYMBOL(platform_device_register_simple);
 EXPORT_SYMBOL(platform_device_unregister);
 EXPORT_SYMBOL(platform_get_irq);
 EXPORT_SYMBOL(platform_get_resource);
diff -puN include/linux/device.h~input-add-platform_device_register_simple include/linux/device.h
--- 25/include/linux/device.h~input-add-platform_device_register_simple	2004-06-27 22:51:04.293542344 -0700
+++ 25-akpm/include/linux/device.h	2004-06-27 22:51:04.300541280 -0700
@@ -381,6 +381,8 @@ extern struct resource *platform_get_res
 extern int platform_get_irq(struct platform_device *, unsigned int);
 extern int platform_add_devices(struct platform_device **, int);
 
+extern struct platform_device *platform_device_register_simple(char *, unsigned int, struct resource *, unsigned int);
+
 /* drivers/base/power.c */
 extern void device_shutdown(void);
 
_
