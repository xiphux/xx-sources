---

 linux-2.6.7-xx4-xiphux/arch/i386/kernel/apic.c               |   84 ++++++++-
 linux-2.6.7-xx4-xiphux/arch/i386/kernel/apm.c                |   23 ++
 linux-2.6.7-xx4-xiphux/arch/i386/kernel/bootflag.c           |    6 
 linux-2.6.7-xx4-xiphux/arch/i386/kernel/cpu/amd.c            |   26 ++
 linux-2.6.7-xx4-xiphux/arch/i386/kernel/cpu/centaur.c        |   20 ++
 linux-2.6.7-xx4-xiphux/arch/i386/kernel/cpu/common.c         |   17 +
 linux-2.6.7-xx4-xiphux/arch/i386/kernel/cpu/cyrix.c          |   30 ++-
 linux-2.6.7-xx4-xiphux/arch/i386/kernel/cpu/intel.c          |   38 ++++
 linux-2.6.7-xx4-xiphux/arch/i386/kernel/cpu/mcheck/k7.c      |    9 
 linux-2.6.7-xx4-xiphux/arch/i386/kernel/cpu/mcheck/p4.c      |   17 +
 linux-2.6.7-xx4-xiphux/arch/i386/kernel/cpu/mcheck/p5.c      |    8 
 linux-2.6.7-xx4-xiphux/arch/i386/kernel/cpu/mcheck/p6.c      |    9 
 linux-2.6.7-xx4-xiphux/arch/i386/kernel/cpu/mcheck/winchip.c |    4 
 linux-2.6.7-xx4-xiphux/arch/i386/kernel/cpu/mtrr/cyrix.c     |   12 +
 linux-2.6.7-xx4-xiphux/arch/i386/kernel/cpu/mtrr/generic.c   |    5 
 linux-2.6.7-xx4-xiphux/arch/i386/kernel/cpu/mtrr/main.c      |   20 ++
 linux-2.6.7-xx4-xiphux/arch/i386/kernel/cpu/transmeta.c      |   14 +
 linux-2.6.7-xx4-xiphux/arch/i386/kernel/dmi_scan.c           |   25 ++
 linux-2.6.7-xx4-xiphux/arch/i386/kernel/efi.c                |   37 +++-
 linux-2.6.7-xx4-xiphux/arch/i386/kernel/io_apic.c            |   80 +++++++-
 linux-2.6.7-xx4-xiphux/arch/i386/kernel/irq.c                |   32 +++
 linux-2.6.7-xx4-xiphux/arch/i386/kernel/mca.c                |    8 
 linux-2.6.7-xx4-xiphux/arch/i386/kernel/microcode.c          |   14 +
 linux-2.6.7-xx4-xiphux/arch/i386/kernel/mpparse.c            |   59 ++++++
 linux-2.6.7-xx4-xiphux/arch/i386/kernel/nmi.c                |    6 
 linux-2.6.7-xx4-xiphux/arch/i386/kernel/scx200.c             |    9 
 linux-2.6.7-xx4-xiphux/arch/i386/kernel/setup.c              |   12 +
 linux-2.6.7-xx4-xiphux/arch/i386/kernel/smpboot.c            |  100 ++++++++++-
 linux-2.6.7-xx4-xiphux/arch/i386/kernel/summit.c             |    4 
 linux-2.6.7-xx4-xiphux/arch/i386/kernel/time.c               |    8 
 linux-2.6.7-xx4-xiphux/arch/i386/mm/fault.c                  |    4 
 linux-2.6.7-xx4-xiphux/arch/i386/mm/init.c                   |   13 +
 linux-2.6.7-xx4-xiphux/arch/i386/pci/acpi.c                  |    5 
 linux-2.6.7-xx4-xiphux/arch/i386/pci/direct.c                |    8 
 linux-2.6.7-xx4-xiphux/arch/i386/pci/fixup.c                 |    4 
 linux-2.6.7-xx4-xiphux/arch/i386/pci/irq.c                   |   54 +++++
 linux-2.6.7-xx4-xiphux/arch/i386/pci/legacy.c                |   11 +
 linux-2.6.7-xx4-xiphux/arch/i386/pci/mmconfig.c              |    5 
 linux-2.6.7-xx4-xiphux/arch/i386/pci/pcbios.c                |    4 
 linux-2.6.7-xx4-xiphux/arch/i386/pci/visws.c                 |    5 
 linux-2.6.7-xx4-xiphux/include/asm-i386/bugs.h               |   21 ++
 linux-2.6.7-xx4-xiphux/kernel/Kconfig-extra.xx               |   11 +
 42 files changed, 819 insertions(+), 62 deletions(-)

diff -puN arch/i386/kernel/apic.c~silence-i386-boot arch/i386/kernel/apic.c
--- linux-2.6.7-xx4/arch/i386/kernel/apic.c~silence-i386-boot	2004-06-29 19:15:28.819162584 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/kernel/apic.c	2004-06-29 19:15:28.914148144 -0400
@@ -173,7 +173,11 @@ void __init connect_bsp_APIC(void)
 		 * PIC mode, enable APIC mode in the IMCR, i.e.
 		 * connect BSP's local APIC to INT and NMI lines.
 		 */
-		printk("leaving PIC mode, enabling APIC mode.\n");
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "leaving PIC mode, enabling APIC mode.\n");
+#else
+		printk(KERN_DEBUG "leaving PIC mode, enabling APIC mode.\n");
+#endif
 		outb(0x70, 0x22);
 		outb(0x01, 0x23);
 	}
@@ -189,7 +193,11 @@ void disconnect_bsp_APIC(void)
 		 * interrupts, including IPIs, won't work beyond
 		 * this point!  The only exception are INIT IPIs.
 		 */
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "disabling APIC mode, entering PIC mode.\n");
+#else
 		printk("disabling APIC mode, entering PIC mode.\n");
+#endif
 		outb(0x70, 0x22);
 		outb(0x00, 0x23);
 	}
@@ -427,10 +435,20 @@ void __init setup_local_APIC (void)
 	value = apic_read(APIC_LVT0) & APIC_LVT_MASKED;
 	if (!smp_processor_id() && (pic_mode || !value)) {
 		value = APIC_DM_EXTINT;
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "enabled ExtINT on CPU#%d\n",
+			smp_processor_id());
+#else
 		printk("enabled ExtINT on CPU#%d\n", smp_processor_id());
+#endif
 	} else {
 		value = APIC_DM_EXTINT | APIC_LVT_MASKED;
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "masked ExtINT on CPU#%d\n",
+			smp_processor_id());
+#else
 		printk("masked ExtINT on CPU#%d\n", smp_processor_id());
+#endif
 	}
 	apic_write_around(APIC_LVT0, value);
 
@@ -450,7 +468,12 @@ void __init setup_local_APIC (void)
 		if (maxlvt > 3)		/* Due to the Pentium erratum 3AP. */
 			apic_write(APIC_ESR, 0);
 		value = apic_read(APIC_ESR);
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "ESR value before enabling vector: %08lx\n",
+			value);
+#else
 		printk("ESR value before enabling vector: %08lx\n", value);
+#endif
 
 		value = ERROR_APIC_VECTOR;      // enables sending errors
 		apic_write_around(APIC_LVTERR, value);
@@ -460,7 +483,12 @@ void __init setup_local_APIC (void)
 		if (maxlvt > 3)
 			apic_write(APIC_ESR, 0);
 		value = apic_read(APIC_ESR);
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "ESR value after enabling vector: %08lx\n",
+			value);
+#else
 		printk("ESR value after enabling vector: %08lx\n", value);
+#endif
 	} else {
 		if (esr_disable)	
 			/* 
@@ -469,9 +497,17 @@ void __init setup_local_APIC (void)
 			 * ESR disabled - we can't do anything useful with the
 			 * errors anyway - mbligh
 			 */
+#ifdef CONFIG_SILENT_BOOT
+			printk(KERN_DEBUG "Leaving ESR disabled.\n");
+#else
 			printk("Leaving ESR disabled.\n");
+#endif
 		else 
+#ifdef CONFIG_SILENT_BOOT
+			printk(KERN_DEBUG "No ESR for 82489DX.\n");
+#else
 			printk("No ESR for 82489DX.\n");
+#endif
 	}
 
 	if (nmi_watchdog == NMI_LOCAL_APIC)
@@ -671,7 +707,11 @@ static int __init detect_init_APIC (void
 		 */
 		rdmsr(MSR_IA32_APICBASE, l, h);
 		if (!(l & MSR_IA32_APICBASE_ENABLE)) {
+#ifdef CONFIG_SILENT_BOOT
+			printk(KERN_DEBUG "Local APIC disabled by BIOS -- reenabling.\n");
+#else
 			printk("Local APIC disabled by BIOS -- reenabling.\n");
+#endif
 			l &= ~MSR_IA32_APICBASE_BASE;
 			l |= MSR_IA32_APICBASE_ENABLE | APIC_DEFAULT_PHYS_BASE;
 			wrmsr(MSR_IA32_APICBASE, l, h);
@@ -684,7 +724,11 @@ static int __init detect_init_APIC (void
 	 */
 	features = cpuid_edx(1);
 	if (!(features & (1 << X86_FEATURE_APIC))) {
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "Could not enable APIC!\n");
+#else
 		printk("Could not enable APIC!\n");
+#endif
 		return -1;
 	}
 	set_bit(X86_FEATURE_APIC, boot_cpu_data.x86_capability);
@@ -698,14 +742,22 @@ static int __init detect_init_APIC (void
 	if (nmi_watchdog != NMI_NONE)
 		nmi_watchdog = NMI_LOCAL_APIC;
 
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "Found and enabled local APIC!\n");
+#else
 	printk("Found and enabled local APIC!\n");
+#endif
 
 	apic_pm_activate();
 
 	return 0;
 
 no_apic:
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "No local APIC present or hardware disabled\n");
+#else
 	printk("No local APIC present or hardware disabled\n");
+#endif
 	return -1;
 }
 
@@ -893,9 +945,11 @@ int __init calibrate_APIC_clock(void)
 	long result;
 	int i;
 	const int LOOPS = HZ/10;
-
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "calibrating APIC timer ...\n");
+#else
 	printk("calibrating APIC timer ...\n");
-
+#endif
 	/*
 	 * Put whatever arbitrary (but long enough) timeout
 	 * value into the APIC clock, we just want to get the
@@ -939,11 +993,19 @@ int __init calibrate_APIC_clock(void)
 	result = (tt1-tt2)*APIC_DIVISOR/LOOPS;
 
 	if (cpu_has_tsc)
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "..... CPU clock speed is %ld.%04ld MHz.\n",
+#else
 		printk("..... CPU clock speed is %ld.%04ld MHz.\n",
+#endif
 			((long)(t2-t1)/LOOPS)/(1000000/HZ),
 			((long)(t2-t1)/LOOPS)%(1000000/HZ));
 
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "..... host bus clock speed is %ld.%04ld MHz.\n",
+#else
 	printk("..... host bus clock speed is %ld.%04ld MHz.\n",
+#endif
 		result/(1000000/HZ),
 		result%(1000000/HZ));
 
@@ -954,7 +1016,11 @@ static unsigned int calibration_result;
 
 void __init setup_boot_APIC_clock(void)
 {
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "Using local APIC timer interrupts.\n");
+#else
 	printk("Using local APIC timer interrupts.\n");
+#endif
 	using_apic_timer = 1;
 
 	local_irq_disable();
@@ -1128,7 +1194,11 @@ asmlinkage void smp_spurious_interrupt(v
 		ack_APIC_irq();
 
 	/* see sw-dev-man vol 3, chapter 7.4.13.5 */
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_ERR "spurious APIC interrupt on CPU#%d, should never happen.\n",
+#else
 	printk(KERN_INFO "spurious APIC interrupt on CPU#%d, should never happen.\n",
+#endif
 			smp_processor_id());
 	irq_exit();
 }
@@ -1159,7 +1229,11 @@ asmlinkage void smp_error_interrupt(void
 	   6: Received illegal vector
 	   7: Illegal register address
 	*/
+#ifdef CONFIG_SILENT_BOOT
+	printk (KERN_ERR "APIC error on CPU%d: %02lx(%02lx)\n",
+#else
 	printk (KERN_INFO "APIC error on CPU%d: %02lx(%02lx)\n",
+#endif
 	        smp_processor_id(), v , v1);
 	irq_exit();
 }
@@ -1180,7 +1254,11 @@ int __init APIC_init_uniprocessor (void)
 	 * Complain if the BIOS pretends there is one.
 	 */
 	if (!cpu_has_apic && APIC_INTEGRATED(apic_version[boot_cpu_physical_apicid])) {
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "BIOS bug, local APIC #%d not detected!...\n",
+#else
 		printk(KERN_ERR "BIOS bug, local APIC #%d not detected!...\n",
+#endif
 			boot_cpu_physical_apicid);
 		return -1;
 	}
diff -puN arch/i386/kernel/apm.c~silence-i386-boot arch/i386/kernel/apm.c
--- linux-2.6.7-xx4/arch/i386/kernel/apm.c~silence-i386-boot	2004-06-29 19:15:28.822162128 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/kernel/apm.c	2004-06-29 19:15:28.917147688 -0400
@@ -1739,7 +1739,11 @@ static int apm(void *unused)
 	}
 
 	if (debug)
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "apm: Connection version %d.%d\n",
+#else
 		printk(KERN_INFO "apm: Connection version %d.%d\n",
+#endif
 			(apm_info.connection_version >> 8) & 0xff,
 			apm_info.connection_version & 0xff);
 
@@ -2223,17 +2227,32 @@ static int __init apm_init(void)
 	dmi_check_system(apm_dmi_table);
 
 	if (apm_info.bios.version == 0) {
+#ifndef CONFIG_SILENT_BOOT
 		printk(KERN_INFO "apm: BIOS not found.\n");
+#endif
 		return -ENODEV;
 	}
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG
+		"apm: BIOS version %d.%d Flags 0x%02x (Driver version %s)\n",
+		((apm_info.bios.version >> 8) & 0xff),
+		(apm_info.bios.version & 0xff),
+		apm_info.bios.flags,
+		driver_version);
+#else
 	printk(KERN_INFO
 		"apm: BIOS version %d.%d Flags 0x%02x (Driver version %s)\n",
 		((apm_info.bios.version >> 8) & 0xff),
 		(apm_info.bios.version & 0xff),
 		apm_info.bios.flags,
 		driver_version);
+#endif
 	if ((apm_info.bios.flags & APM_32_BIT_SUPPORT) == 0) {
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "apm: no 32 bit BIOS support\n");
+#else
 		printk(KERN_INFO "apm: no 32 bit BIOS support\n");
+#endif
 		return -ENODEV;
 	}
 
@@ -2259,7 +2278,11 @@ static int __init apm_init(void)
 		apm_info.bios.cseg_16_len = 0; /* 64k */
 
 	if (debug) {
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "apm: entry %x:%lx cseg16 %x dseg %x",
+#else
 		printk(KERN_INFO "apm: entry %x:%lx cseg16 %x dseg %x",
+#endif
 			apm_info.bios.cseg, apm_info.bios.offset,
 			apm_info.bios.cseg_16, apm_info.bios.dseg);
 		if (apm_info.bios.version > 0x100)
diff -puN arch/i386/kernel/bootflag.c~silence-i386-boot arch/i386/kernel/bootflag.c
--- linux-2.6.7-xx4/arch/i386/kernel/bootflag.c~silence-i386-boot	2004-06-29 19:15:28.825161672 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/kernel/bootflag.c	2004-06-29 19:15:28.918147536 -0400
@@ -47,9 +47,11 @@ static void __init sbf_write(u8 v)
 		v &= ~SBF_PARITY;
 		if(!parity(v))
 			v|=SBF_PARITY;
-
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "Simple Boot Flag at 0x%x set to 0x%x\n", sbf_port, v);
+#else
 		printk(KERN_INFO "Simple Boot Flag at 0x%x set to 0x%x\n", sbf_port, v);
-
+#endif
 		spin_lock_irqsave(&rtc_lock, flags);
 		CMOS_WRITE(v, sbf_port);
 		spin_unlock_irqrestore(&rtc_lock, flags);
diff -puN arch/i386/kernel/cpu/amd.c~silence-i386-boot arch/i386/kernel/cpu/amd.c
--- linux-2.6.7-xx4/arch/i386/kernel/cpu/amd.c~silence-i386-boot	2004-06-29 19:15:28.828161216 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/kernel/cpu/amd.c	2004-06-29 19:15:28.919147384 -0400
@@ -73,9 +73,11 @@ static void __init init_amd(struct cpuin
 				int n;
 				void (*f_vide)(void);
 				unsigned long d, d2;
-				
+#ifdef CONFIG_SILENT_BOOT
+				printk(KERN_DEBUG "AMD K6 stepping B detected - ");
+#else
 				printk(KERN_INFO "AMD K6 stepping B detected - ");
-				
+#endif
 				/*
 				 * It looks like AMD fixed the 2.6.2 bug and improved indirect 
 				 * calls at the same time.
@@ -90,13 +92,21 @@ static void __init init_amd(struct cpuin
 				d = d2-d;
 				
 				/* Knock these two lines out if it debugs out ok */
+#ifdef CONFIG_SILENT_BOOT
+				printk(KERN_DEBUG "AMD K6 stepping B detected - ");
+#else
 				printk(KERN_INFO "AMD K6 stepping B detected - ");
+#endif
 				/* -- cut here -- */
 				if (d > 20*K6_BUG_LOOP) 
 					printk("system stability may be impaired when more than 32 MB are used.\n");
 				else 
 					printk("probably OK (after B9730xxxx).\n");
+#ifdef CONFIG_SILENT_BOOT
+				printk(KERN_DEBUG "Please see http://membres.lycos.fr/poulot/k6bug.html\n");
+#else
 				printk(KERN_INFO "Please see http://membres.lycos.fr/poulot/k6bug.html\n");
+#endif
 			}
 
 			/* K6 with old style WHCR */
@@ -114,7 +124,11 @@ static void __init init_amd(struct cpuin
 					wbinvd();
 					wrmsr(MSR_K6_WHCR, l, h);
 					local_irq_restore(flags);
+#ifdef CONFIG_SILENT_BOOT
+					printk(KERN_DEBUG "Enabling old style K6 write allocation for %d Mb\n",
+#else
 					printk(KERN_INFO "Enabling old style K6 write allocation for %d Mb\n",
+#endif
 						mbytes);
 				}
 				break;
@@ -135,7 +149,11 @@ static void __init init_amd(struct cpuin
 					wbinvd();
 					wrmsr(MSR_K6_WHCR, l, h);
 					local_irq_restore(flags);
+#ifdef CONFIG_SILENT_BOOT
+					printk(KERN_DEBUG "Enabling new style K6 write allocation for %d Mb\n",
+#else
 					printk(KERN_INFO "Enabling new style K6 write allocation for %d Mb\n",
+#endif
 						mbytes);
 				}
 
@@ -155,7 +173,11 @@ static void __init init_amd(struct cpuin
 			 */
 			if (c->x86_model >= 6 && c->x86_model <= 10) {
 				if (!cpu_has(c, X86_FEATURE_XMM)) {
+#ifdef CONFIG_SILENT_BOOT
+					printk(KERN_DEBUG "Enabling disabled K7/SSE Support.\n");
+#else
 					printk(KERN_INFO "Enabling disabled K7/SSE Support.\n");
+#endif
 					rdmsr(MSR_K7_HWCR, l, h);
 					l &= ~0x00008000;
 					wrmsr(MSR_K7_HWCR, l, h);
diff -puN arch/i386/kernel/cpu/centaur.c~silence-i386-boot arch/i386/kernel/cpu/centaur.c
--- linux-2.6.7-xx4/arch/i386/kernel/cpu/centaur.c~silence-i386-boot	2004-06-29 19:15:28.830160912 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/kernel/cpu/centaur.c	2004-06-29 19:15:28.921147080 -0400
@@ -269,7 +269,11 @@ static void __init init_c3(struct cpuinf
 			rdmsr (MSR_VIA_FCR, lo, hi);
 			lo |= ACE_FCR;		/* enable ACE unit */
 			wrmsr (MSR_VIA_FCR, lo, hi);
+#ifdef CONFIG_SILENT_BOOT
+			printk(KERN_DEBUG "CPU: Enabled ACE h/w crypto\n");
+#else
 			printk(KERN_INFO "CPU: Enabled ACE h/w crypto\n");
+#endif
 		}
 
 		/* enable RNG unit, if present and disabled */
@@ -277,7 +281,11 @@ static void __init init_c3(struct cpuinf
 			rdmsr (MSR_VIA_RNG, lo, hi);
 			lo |= RNG_ENABLE;	/* enable RNG unit */
 			wrmsr (MSR_VIA_RNG, lo, hi);
+#ifdef CONFIG_SILENT_BOOT
+			printk(KERN_DEBUG "CPU: Enabled h/w RNG\n");
+#else
 			printk(KERN_INFO "CPU: Enabled h/w RNG\n");
+#endif
 		}
 
 		/* store Centaur Extended Feature Flags as
@@ -346,7 +354,11 @@ static void __init init_centaur(struct c
 				name="C6";
 				fcr_set=ECX8|DSMC|EDCTLB|EMMX|ERETSTK;
 				fcr_clr=DPDC;
+#ifdef CONFIG_SILENT_BOOT
+				printk(KERN_DEBUG "Disabling bugged TSC.\n");
+#else
 				printk(KERN_NOTICE "Disabling bugged TSC.\n");
+#endif
 				clear_bit(X86_FEATURE_TSC, c->x86_capability);
 #ifdef CONFIG_X86_OOSTORE
 				centaur_create_optimal_mcr();
@@ -420,10 +432,18 @@ static void __init init_centaur(struct c
 			newlo=(lo|fcr_set) & (~fcr_clr);
 
 			if (newlo!=lo) {
+#ifdef CONFIG_SILENT_BOOT
+				printk(KERN_DEBUG "Centaur FCR was 0x%X now 0x%X\n", lo, newlo );
+#else
 				printk(KERN_INFO "Centaur FCR was 0x%X now 0x%X\n", lo, newlo );
+#endif
 				wrmsr(MSR_IDT_FCR1, newlo, hi );
 			} else {
+#ifdef CONFIG_SILENT_BOOT
+				printk(KERN_DEBUG "Centaur FCR is 0x%X\n",lo);
+#else
 				printk(KERN_INFO "Centaur FCR is 0x%X\n",lo);
+#endif
 			}
 			/* Emulate MTRRs using Centaur's MCR. */
 			set_bit(X86_FEATURE_CENTAUR_MCR, c->x86_capability);
diff -puN arch/i386/kernel/cpu/common.c~silence-i386-boot arch/i386/kernel/cpu/common.c
--- linux-2.6.7-xx4/arch/i386/kernel/cpu/common.c~silence-i386-boot	2004-06-29 19:15:28.832160608 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/kernel/cpu/common.c	2004-06-29 19:15:28.922146928 -0400
@@ -84,7 +84,11 @@ void __init display_cacheinfo(struct cpu
 
 	if (n >= 0x80000005) {
 		cpuid(0x80000005, &dummy, &dummy, &ecx, &edx);
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "CPU: L1 I Cache: %dK (%d bytes/line), D cache %dK (%d bytes/line)\n",
+#else
 		printk(KERN_INFO "CPU: L1 I Cache: %dK (%d bytes/line), D cache %dK (%d bytes/line)\n",
+#endif
 			edx>>24, edx&0xFF, ecx>>24, ecx&0xFF);
 		c->x86_cache_size=(ecx>>24)+(edx>>24);	
 	}
@@ -107,8 +111,11 @@ void __init display_cacheinfo(struct cpu
 		return;		/* Again, no L2 cache is possible */
 
 	c->x86_cache_size = l2size;
-
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "CPU: L2 Cache: %dK (%d bytes/line)\n",
+#else
 	printk(KERN_INFO "CPU: L2 Cache: %dK (%d bytes/line)\n",
+#endif
 	       l2size, ecx & 0xFF);
 }
 
@@ -508,12 +515,20 @@ void __init cpu_init (void)
 		printk(KERN_WARNING "CPU#%d already initialized!\n", cpu);
 		for (;;) local_irq_enable();
 	}
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "Initializing CPU#%d\n", cpu);
+#else
 	printk(KERN_INFO "Initializing CPU#%d\n", cpu);
+#endif
 
 	if (cpu_has_vme || cpu_has_tsc || cpu_has_de)
 		clear_in_cr4(X86_CR4_VME|X86_CR4_PVI|X86_CR4_TSD|X86_CR4_DE);
 	if (tsc_disable && cpu_has_tsc) {
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "Disabling TSC...\n");
+#else
 		printk(KERN_NOTICE "Disabling TSC...\n");
+#endif
 		/**** FIX-HPA: DOES THIS REALLY BELONG HERE? ****/
 		clear_bit(X86_FEATURE_TSC, boot_cpu_data.x86_capability);
 		set_in_cr4(X86_CR4_TSD);
diff -puN arch/i386/kernel/cpu/cyrix.c~silence-i386-boot arch/i386/kernel/cpu/cyrix.c
--- linux-2.6.7-xx4/arch/i386/kernel/cpu/cyrix.c~silence-i386-boot	2004-06-29 19:15:28.835160152 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/kernel/cpu/cyrix.c	2004-06-29 19:15:28.923146776 -0400
@@ -99,7 +99,11 @@ static void __init check_cx686_slop(stru
 		local_irq_restore(flags);
 
 		if (ccr5 & 2) { /* possible wrong calibration done */
+#ifdef CONFIG_SILENT_BOOT
+			printk(KERN_DEBUG "Recalibrating delay loop with SLOP bit reset\n");
+#else
 			printk(KERN_INFO "Recalibrating delay loop with SLOP bit reset\n");
+#endif
 			calibrate_delay();
 			c->loops_per_jiffy = loops_per_jiffy;
 		}
@@ -110,8 +114,11 @@ static void __init check_cx686_slop(stru
 static void __init set_cx86_reorder(void)
 {
 	u8 ccr3;
-
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "Enable Memory access reorder on Cyrix/NSC processor.\n");
+#else
 	printk(KERN_INFO "Enable Memory access reorder on Cyrix/NSC processor.\n");
+#endif
 	ccr3 = getCx86(CX86_CCR3);
 	setCx86(CX86_CCR3, (ccr3 & 0x0f) | 0x10); /* enable MAPEN  */
 
@@ -125,9 +132,11 @@ static void __init set_cx86_reorder(void
 static void __init set_cx86_memwb(void)
 {
 	u32 cr0;
-
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "Enable Memory-Write-back mode on Cyrix/NSC processor.\n");
+#else
 	printk(KERN_INFO "Enable Memory-Write-back mode on Cyrix/NSC processor.\n");
-
+#endif
 	/* CCR2 bit 2: unlock NW bit */
 	setCx86(CX86_CCR2, getCx86(CX86_CCR2) & ~0x04);
 	/* set 'Not Write-through' */
@@ -144,9 +153,11 @@ static void __init set_cx86_memwb(void)
 static void __init set_cx86_inc(void)
 {
 	unsigned char ccr3;
-
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "Enable Incrementor on Cyrix/NSC processor.\n");
+#else
 	printk(KERN_INFO "Enable Incrementor on Cyrix/NSC processor.\n");
-
+#endif
 	ccr3 = getCx86(CX86_CCR3);
 	setCx86(CX86_CCR3, (ccr3 & 0x0f) | 0x10); /* enable MAPEN  */
 	/* PCR1 -- Performance Control */
@@ -265,8 +276,11 @@ static void __init init_cyrix(struct cpu
 		   and X doesn't seem to support it either so who cares 8).
 		   VSA1 we work around however.
 		*/
-
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "Working around Cyrix MediaGX virtual DMA bugs.\n");
+#else
 		printk(KERN_INFO "Working around Cyrix MediaGX virtual DMA bugs.\n");
+#endif
 		isa_dma_bridge_buggy = 2;
 #endif		
 		c->x86_cache_size=16;	/* Yep 16K integrated cache thats it */
@@ -388,7 +402,11 @@ static void cyrix_identify(struct cpuinf
    	        {
 			unsigned char ccr3, ccr4;
 			unsigned long flags;
+#ifdef CONFIG_SILENT_BOOT
+			printk(KERN_DEBUG "Enabling CPUID on Cyrix processor.\n");
+#else
 			printk(KERN_INFO "Enabling CPUID on Cyrix processor.\n");
+#endif
 			local_irq_save(flags);
 			ccr3 = getCx86(CX86_CCR3);
 			setCx86(CX86_CCR3, (ccr3 & 0x0f) | 0x10); /* enable MAPEN  */
diff -puN arch/i386/kernel/cpu/intel.c~silence-i386-boot arch/i386/kernel/cpu/intel.c
--- linux-2.6.7-xx4/arch/i386/kernel/cpu/intel.c~silence-i386-boot	2004-06-29 19:15:28.838159696 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/kernel/cpu/intel.c	2004-06-29 19:15:28.925146472 -0400
@@ -50,7 +50,11 @@ int __init ppro_with_ram_bug(void)
 	    boot_cpu_data.x86 == 6 &&
 	    boot_cpu_data.x86_model == 1 &&
 	    boot_cpu_data.x86_mask < 8) {
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "Pentium Pro with Errata#50 detected. Taking evasive action.\n");
+#else
 		printk(KERN_INFO "Pentium Pro with Errata#50 detected. Taking evasive action.\n");
+#endif
 		return 1;
 	}
 	return 0;
@@ -121,8 +125,13 @@ static void __init Intel_errata_workarou
 	if ((c->x86 == 15) && (c->x86_model == 1) && (c->x86_mask == 1)) {
 		rdmsr (MSR_IA32_MISC_ENABLE, lo, hi);
 		if ((lo & (1<<9)) == 0) {
+#ifdef CONFIG_SILENT_BOOT
+			printk (KERN_DEBUG "CPU: C0 stepping P4 Xeon detected.\n");
+			printk (KERN_DEBUG "CPU: Disabling hardware prefetching (Errata 037)\n");
+#else
 			printk (KERN_INFO "CPU: C0 stepping P4 Xeon detected.\n");
 			printk (KERN_INFO "CPU: Disabling hardware prefetching (Errata 037)\n");
+#endif
 			lo |= (1<<9);	/* Disable hw prefetching */
 			wrmsr (MSR_IA32_MISC_ENABLE, lo, hi);
 		}
@@ -148,7 +157,11 @@ static void __init init_intel(struct cpu
 		c->f00f_bug = 1;
 		if ( !f00f_workaround_enabled ) {
 			trap_init_f00f_bug();
+#ifdef CONFIG_SILENT_BOOT
+			printk(KERN_DEBUG "Intel Pentium with F0 0F bug - workaround enabled.\n");
+#else
 			printk(KERN_NOTICE "Intel Pentium with F0 0F bug - workaround enabled.\n");
+#endif
 			f00f_workaround_enabled = 1;
 		}
 	}
@@ -208,17 +221,33 @@ static void __init init_intel(struct cpu
 		}
 
 		if ( trace )
+#ifdef CONFIG_SILENT_BOOT
+			printk (KERN_DEBUG "CPU: Trace cache: %dK uops", trace);
+#else
 			printk (KERN_INFO "CPU: Trace cache: %dK uops", trace);
+#endif
 		else if ( l1i )
+#ifdef CONFIG_SILENT_BOOT
+			printk (KERN_DEBUG "CPU: L1 I cache: %dK", l1i);
+#else
 			printk (KERN_INFO "CPU: L1 I cache: %dK", l1i);
+#endif
 		if ( l1d )
 			printk(", L1 D cache: %dK\n", l1d);
 		else
 			printk("\n");
 		if ( l2 )
+#ifdef CONFIG_SILENT_BOOT
+			printk(KERN_DEBUG "CPU: L2 cache: %dK\n", l2);
+#else
 			printk(KERN_INFO "CPU: L2 cache: %dK\n", l2);
+#endif
 		if ( l3 )
+#ifdef CONFIG_SILENT_BOOT
+			printk(KERN_DEBUG "CPU: L3 cache: %dK\n", l3);
+#else
 			printk(KERN_INFO "CPU: L3 cache: %dK\n", l3);
+#endif
 
 		/*
 		 * This assumes the L3 cache is shared; it typically lives in
@@ -276,7 +305,11 @@ static void __init init_intel(struct cpu
 		smp_num_siblings = (ebx & 0xff0000) >> 16;
 
 		if (smp_num_siblings == 1) {
+#ifdef CONFIG_SILENT_BOOT
+			printk(KERN_DEBUG  "CPU: Hyper-Threading is disabled\n");
+#else
 			printk(KERN_INFO  "CPU: Hyper-Threading is disabled\n");
+#endif
 		} else if (smp_num_siblings > 1 ) {
 			index_lsb = 0;
 			index_msb = 31;
@@ -299,8 +332,11 @@ static void __init init_intel(struct cpu
 			if (index_lsb != index_msb )
 				index_msb++;
 			phys_proc_id[cpu] = phys_pkg_id((ebx >> 24) & 0xFF, index_msb);
-
+#ifdef CONFIG_SILENT_BOOT
+			printk(KERN_DEBUG  "CPU: Physical Processor ID: %d\n",
+#else
 			printk(KERN_INFO  "CPU: Physical Processor ID: %d\n",
+#endif
                                phys_proc_id[cpu]);
 		}
 
diff -puN arch/i386/kernel/cpu/mcheck/k7.c~silence-i386-boot arch/i386/kernel/cpu/mcheck/k7.c
--- linux-2.6.7-xx4/arch/i386/kernel/cpu/mcheck/k7.c~silence-i386-boot	2004-06-29 19:15:28.843158936 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/kernel/cpu/mcheck/k7.c	2004-06-29 19:15:28.926146320 -0400
@@ -75,8 +75,11 @@ void __init amd_mcheck_init(struct cpuin
 
 	machine_check_vector = k7_machine_check;
 	wmb();
-
+#ifdef CONFIG_SILENT_BOOT
+	printk (KERN_DEBUG "Intel machine check architecture supported.\n");
+#else
 	printk (KERN_INFO "Intel machine check architecture supported.\n");
+#endif
 	rdmsr (MSR_IA32_MCG_CAP, l, h);
 	if (l & (1<<8))	/* Control register present ? */
 		wrmsr (MSR_IA32_MCG_CTL, 0xffffffff, 0xffffffff);
@@ -91,6 +94,10 @@ void __init amd_mcheck_init(struct cpuin
 	}
 
 	set_in_cr4 (X86_CR4_MCE);
+#ifdef CONFIG_SILENT_BOOT
+	printk (KERN_DEBUG "Intel machine check reporting enabled on CPU#%d.\n",
+#else
 	printk (KERN_INFO "Intel machine check reporting enabled on CPU#%d.\n",
+#endif
 		smp_processor_id());
 }
diff -puN arch/i386/kernel/cpu/mcheck/p4.c~silence-i386-boot arch/i386/kernel/cpu/mcheck/p4.c
--- linux-2.6.7-xx4/arch/i386/kernel/cpu/mcheck/p4.c~silence-i386-boot	2004-06-29 19:15:28.845158632 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/kernel/cpu/mcheck/p4.c	2004-06-29 19:15:28.927146168 -0400
@@ -125,7 +125,11 @@ static void __init intel_init_thermal(st
 	
 	l = apic_read (APIC_LVTTHMR);
 	apic_write_around (APIC_LVTTHMR, l & ~APIC_LVT_MASKED);
+#ifdef CONFIG_SILENT_BOOT
+	printk (KERN_DEBUG "CPU%d: Thermal monitoring enabled\n", cpu);
+#else
 	printk (KERN_INFO "CPU%d: Thermal monitoring enabled\n", cpu);
+#endif
 	return;
 }
 #endif /* CONFIG_X86_MCE_P4THERMAL */
@@ -236,8 +240,11 @@ void __init intel_p4_mcheck_init(struct 
 	
 	machine_check_vector = intel_machine_check;
 	wmb();
-
+#ifdef CONFIG_SILENT_BOOT
+	printk (KERN_DEBUG "Intel machine check architecture supported.\n");
+#else
 	printk (KERN_INFO "Intel machine check architecture supported.\n");
+#endif
 	rdmsr (MSR_IA32_MCG_CAP, l, h);
 	if (l & (1<<8))	/* Control register present ? */
 		wrmsr (MSR_IA32_MCG_CTL, 0xffffffff, 0xffffffff);
@@ -249,14 +256,22 @@ void __init intel_p4_mcheck_init(struct 
 	}
 
 	set_in_cr4 (X86_CR4_MCE);
+#ifdef CONFIG_SILENT_BOOT
+	printk (KERN_DEBUG "Intel machine check reporting enabled on CPU#%d.\n",
+#else
 	printk (KERN_INFO "Intel machine check reporting enabled on CPU#%d.\n",
+#endif
 		smp_processor_id());
 
 	/* Check for P4/Xeon extended MCE MSRs */
 	rdmsr (MSR_IA32_MCG_CAP, l, h);
 	if (l & (1<<9))	{/* MCG_EXT_P */
 		mce_num_extended_msrs = (l >> 16) & 0xff;
+#ifdef CONFIG_SILENT_BOOT
+		printk (KERN_DEBUG "CPU%d: Intel P4/Xeon Extended MCE MSRs (%d)"
+#else
 		printk (KERN_INFO "CPU%d: Intel P4/Xeon Extended MCE MSRs (%d)"
+#endif
 				" available\n",
 			smp_processor_id(), mce_num_extended_msrs);
 
diff -puN arch/i386/kernel/cpu/mcheck/p5.c~silence-i386-boot arch/i386/kernel/cpu/mcheck/p5.c
--- linux-2.6.7-xx4/arch/i386/kernel/cpu/mcheck/p5.c~silence-i386-boot	2004-06-29 19:15:28.847158328 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/kernel/cpu/mcheck/p5.c	2004-06-29 19:15:28.927146168 -0400
@@ -45,9 +45,17 @@ void __init intel_p5_mcheck_init(struct 
 	/* Read registers before enabling */
 	rdmsr(MSR_IA32_P5_MC_ADDR, l, h);
 	rdmsr(MSR_IA32_P5_MC_TYPE, l, h);
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "Intel old style machine check architecture supported.\n");
+#else
 	printk(KERN_INFO "Intel old style machine check architecture supported.\n");
+#endif
 
  	/* Enable MCE */
 	set_in_cr4(X86_CR4_MCE);
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "Intel old style machine check reporting enabled on CPU#%d.\n", smp_processor_id());
+#else
 	printk(KERN_INFO "Intel old style machine check reporting enabled on CPU#%d.\n", smp_processor_id());
+#endif
 }
diff -puN arch/i386/kernel/cpu/mcheck/p6.c~silence-i386-boot arch/i386/kernel/cpu/mcheck/p6.c
--- linux-2.6.7-xx4/arch/i386/kernel/cpu/mcheck/p6.c~silence-i386-boot	2004-06-29 19:15:28.849158024 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/kernel/cpu/mcheck/p6.c	2004-06-29 19:15:28.928146016 -0400
@@ -95,8 +95,11 @@ void __init intel_p6_mcheck_init(struct 
 	/* Ok machine check is available */
 	machine_check_vector = intel_machine_check;
 	wmb();
-
+#ifdef CONFIG_SILENT_BOOT
+	printk (KERN_DEBUG "Intel machine check architecture supported.\n");
+#else
 	printk (KERN_INFO "Intel machine check architecture supported.\n");
+#endif
 	rdmsr (MSR_IA32_MCG_CAP, l, h);
 	if (l & (1<<8))	/* Control register present ? */
 		wrmsr(MSR_IA32_MCG_CTL, 0xffffffff, 0xffffffff);
@@ -109,6 +112,10 @@ void __init intel_p6_mcheck_init(struct 
 	}
 
 	set_in_cr4 (X86_CR4_MCE);
+#ifdef CONFIG_SILENT_BOOT
+	printk (KERN_DEBUG "Intel machine check reporting enabled on CPU#%d.\n",
+#else
 	printk (KERN_INFO "Intel machine check reporting enabled on CPU#%d.\n",
+#endif
 		smp_processor_id());
 }
diff -puN arch/i386/kernel/cpu/mcheck/winchip.c~silence-i386-boot arch/i386/kernel/cpu/mcheck/winchip.c
--- linux-2.6.7-xx4/arch/i386/kernel/cpu/mcheck/winchip.c~silence-i386-boot	2004-06-29 19:15:28.851157720 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/kernel/cpu/mcheck/winchip.c	2004-06-29 19:15:28.929145864 -0400
@@ -32,5 +32,9 @@ void __init winchip_mcheck_init(struct c
 	lo&= ~(1<<4);	/* Enable MCE */
 	wrmsr(MSR_IDT_FCR1, lo, hi);
 	set_in_cr4(X86_CR4_MCE);
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "Winchip machine check reporting enabled on CPU#0.\n");
+#else
 	printk(KERN_INFO "Winchip machine check reporting enabled on CPU#0.\n");
+#endif
 }
diff -puN arch/i386/kernel/cpu/mtrr/cyrix.c~silence-i386-boot arch/i386/kernel/cpu/mtrr/cyrix.c
--- linux-2.6.7-xx4/arch/i386/kernel/cpu/mtrr/cyrix.c~silence-i386-boot	2004-06-29 19:15:28.853157416 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/kernel/cpu/mtrr/cyrix.c	2004-06-29 19:15:28.930145712 -0400
@@ -330,16 +330,28 @@ cyrix_arr_init(void)
 	set_mtrr_done(&ctxt);	/* flush cache and disable MAPEN */
 
 	if (ccrc[5])
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "mtrr: ARR usage was not enabled, enabled manually\n");
+#else
 		printk(KERN_INFO "mtrr: ARR usage was not enabled, enabled manually\n");
+#endif
 	if (ccrc[3])
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "mtrr: ARR3 cannot be changed\n");
+#else
 		printk(KERN_INFO "mtrr: ARR3 cannot be changed\n");
+#endif
 /*
     if ( ccrc[1] & 0x80) printk ("mtrr: SMM memory access through ARR3 disabled\n");
     if ( ccrc[1] & 0x04) printk ("mtrr: SMM memory access disabled\n");
     if ( ccrc[1] & 0x02) printk ("mtrr: SMM mode disabled\n");
 */
 	if (ccrc[6])
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "mtrr: ARR3 was write protected, unprotected\n");
+#else
 		printk(KERN_INFO "mtrr: ARR3 was write protected, unprotected\n");
+#endif
 }
 
 static struct mtrr_ops cyrix_mtrr_ops = {
diff -puN arch/i386/kernel/cpu/mtrr/generic.c~silence-i386-boot arch/i386/kernel/cpu/mtrr/generic.c
--- linux-2.6.7-xx4/arch/i386/kernel/cpu/mtrr/generic.c~silence-i386-boot	2004-06-29 19:15:28.855157112 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/kernel/cpu/mtrr/generic.c	2004-06-29 19:15:28.931145560 -0400
@@ -89,8 +89,13 @@ void __init mtrr_state_warn(void)
 		printk(KERN_WARNING "mtrr: your CPUs had inconsistent variable MTRR settings\n");
 	if (mask & MTRR_CHANGE_MASK_DEFTYPE)
 		printk(KERN_WARNING "mtrr: your CPUs had inconsistent MTRRdefType settings\n");
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "mtrr: probably your BIOS does not setup all CPUs.\n");
+	printk(KERN_DEBUG "mtrr: corrected configuration.\n");
+#else
 	printk(KERN_INFO "mtrr: probably your BIOS does not setup all CPUs.\n");
 	printk(KERN_INFO "mtrr: corrected configuration.\n");
+#endif
 }
 
 
diff -puN arch/i386/kernel/cpu/mtrr/main.c~silence-i386-boot arch/i386/kernel/cpu/mtrr/main.c
--- linux-2.6.7-xx4/arch/i386/kernel/cpu/mtrr/main.c~silence-i386-boot	2004-06-29 19:15:28.857156808 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/kernel/cpu/mtrr/main.c	2004-06-29 19:15:28.933145256 -0400
@@ -82,7 +82,11 @@ static int have_wrcomb(void)
 		   Don't allow it and leave room for other chipsets to be tagged */
 		if (dev->vendor == PCI_VENDOR_ID_SERVERWORKS &&
 		    dev->device == PCI_DEVICE_ID_SERVERWORKS_LE) {
+#ifdef CONFIG_SILENT_BOOT
+			printk(KERN_DEBUG "mtrr: Serverworks LE detected. Write-combining disabled.\n");
+#else
 			printk(KERN_INFO "mtrr: Serverworks LE detected. Write-combining disabled.\n");
+#endif
 			return 0;
 		}
 		/* Intel 450NX errata # 23. Non ascending cachline evictions to
@@ -90,7 +94,11 @@ static int have_wrcomb(void)
 		if (dev->vendor == PCI_VENDOR_ID_INTEL &&
 		    dev->device == PCI_DEVICE_ID_INTEL_82451NX)
 		{
+#ifdef CONFIG_SILENT_BOOT
+			printk(KERN_DEBUG "mtrr: Intel 450NX MMC detected. Write-combining disabled.\n");
+#else
 			printk(KERN_INFO "mtrr: Intel 450NX MMC detected. Write-combining disabled.\n");
+#endif
 			return 0;
 		}
 	}		
@@ -372,7 +380,11 @@ int mtrr_add_page(unsigned long base, un
 		set_mtrr(i, base, size, type);
 		usage_table[i] = 1;
 	} else
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "mtrr: no more MTRRs available\n");
+#else
 		printk(KERN_INFO "mtrr: no more MTRRs available\n");
+#endif
 	error = i;
  out:
 	up(&main_lock);
@@ -516,7 +528,11 @@ int
 mtrr_del(int reg, unsigned long base, unsigned long size)
 {
 	if ((base & (PAGE_SIZE - 1)) || (size & (PAGE_SIZE - 1))) {
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "mtrr: size and base must be multiples of 4 kiB\n");
+#else
 		printk(KERN_INFO "mtrr: size and base must be multiples of 4 kiB\n");
+#endif
 		printk(KERN_DEBUG "mtrr: size: 0x%lx  base: 0x%lx\n", size, base);
 		return -EINVAL;
 	}
@@ -685,7 +701,11 @@ static int __init mtrr_init(void)
 			break;
 		}
 	}
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "mtrr: v%s\n",MTRR_VERSION);
+#else
 	printk(KERN_INFO "mtrr: v%s\n",MTRR_VERSION);
+#endif
 
 	if (mtrr_if) {
 		set_num_var_ranges();
diff -puN arch/i386/kernel/cpu/transmeta.c~silence-i386-boot arch/i386/kernel/cpu/transmeta.c
--- linux-2.6.7-xx4/arch/i386/kernel/cpu/transmeta.c~silence-i386-boot	2004-06-29 19:15:28.859156504 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/kernel/cpu/transmeta.c	2004-06-29 19:15:28.934145104 -0400
@@ -17,8 +17,12 @@ static void __init init_transmeta(struct
 	/* Print CMS and CPU revision */
 	max = cpuid_eax(0x80860000);
 	if ( max >= 0x80860001 ) {
-		cpuid(0x80860001, &dummy, &cpu_rev, &cpu_freq, &cpu_flags); 
+		cpuid(0x80860001, &dummy, &cpu_rev, &cpu_freq, &cpu_flags);
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "CPU: Processor revision %u.%u.%u.%u, %u MHz\n",
+#else
 		printk(KERN_INFO "CPU: Processor revision %u.%u.%u.%u, %u MHz\n",
+#endif
 		       (cpu_rev >> 24) & 0xff,
 		       (cpu_rev >> 16) & 0xff,
 		       (cpu_rev >> 8) & 0xff,
@@ -27,7 +31,11 @@ static void __init init_transmeta(struct
 	}
 	if ( max >= 0x80860002 ) {
 		cpuid(0x80860002, &dummy, &cms_rev1, &cms_rev2, &dummy);
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "CPU: Code Morphing Software revision %u.%u.%u-%u-%u\n",
+#else
 		printk(KERN_INFO "CPU: Code Morphing Software revision %u.%u.%u-%u-%u\n",
+#endif
 		       (cms_rev1 >> 24) & 0xff,
 		       (cms_rev1 >> 16) & 0xff,
 		       (cms_rev1 >> 8) & 0xff,
@@ -56,7 +64,11 @@ static void __init init_transmeta(struct
 		      (void *)&cpu_info[56],
 		      (void *)&cpu_info[60]);
 		cpu_info[64] = '\0';
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "CPU: %s\n", cpu_info);
+#else
 		printk(KERN_INFO "CPU: %s\n", cpu_info);
+#endif
 	}
 
 	/* Unhide possibly hidden capability flags */
diff -puN arch/i386/kernel/dmi_scan.c~silence-i386-boot arch/i386/kernel/dmi_scan.c
--- linux-2.6.7-xx4/arch/i386/kernel/dmi_scan.c~silence-i386-boot	2004-06-29 19:15:28.860156352 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/kernel/dmi_scan.c	2004-06-29 19:15:28.937144648 -0400
@@ -125,13 +125,26 @@ static int __init dmi_iterate(void (*dec
 			 * the SMBIOS version, which we don't know at this point.
 			 */
 			if(buf[14]!=0)
+#ifdef CONFIG_SILENT_BOOT
+				printk(KERN_DEBUG "DMI %d.%d present.\n",
+#else
 				printk(KERN_INFO "DMI %d.%d present.\n",
+#endif
 					buf[14]>>4, buf[14]&0x0F);
 			else
+#ifdef CONFIG_SILENT_BOOT
+				printk(KERN_DEBUG "DMI present.\n");
+			dmi_printk((KERN_DEBUG "%d structures occupying %d bytes.\n",
+#else
 				printk(KERN_INFO "DMI present.\n");
 			dmi_printk((KERN_INFO "%d structures occupying %d bytes.\n",
+#endif
 				num, len));
+#ifdef CONFIG_SILENT_BOOT
+			dmi_printk((KERN_DEBUG "DMI table at 0x%08X.\n",
+#else
 			dmi_printk((KERN_INFO "DMI table at 0x%08X.\n",
+#endif
 				base));
 			if(dmi_table(base,len, num, decode)==0)
 				return 0;
@@ -183,7 +196,11 @@ static __init int set_bios_reboot(struct
 	if (reboot_thru_bios == 0)
 	{
 		reboot_thru_bios = 1;
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "%s series board detected. Selecting BIOS-method for reboots.\n", d->ident);
+#else
 		printk(KERN_INFO "%s series board detected. Selecting BIOS-method for reboots.\n", d->ident);
+#endif
 	}
 	return 0;
 }
@@ -198,7 +215,11 @@ static __init int set_smp_reboot(struct 
 	if (reboot_smp == 0)
 	{
 		reboot_smp = 1;
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "%s series board detected. Selecting SMP-method for reboots.\n", d->ident);
+#else
 		printk(KERN_INFO "%s series board detected. Selecting SMP-method for reboots.\n", d->ident);
+#endif
 	}
 #endif
 	return 0;
@@ -714,7 +735,11 @@ void __init dmi_scan_machine(void)
 	if(err == 0)
 		dmi_check_blacklist();
 	else
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "DMI not present.\n");
+#else
 		printk(KERN_INFO "DMI not present.\n");
+#endif
 }
 
 
diff -puN arch/i386/kernel/efi.c~silence-i386-boot arch/i386/kernel/efi.c
--- linux-2.6.7-xx4/arch/i386/kernel/efi.c~silence-i386-boot	2004-06-29 19:15:28.864155744 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/kernel/efi.c	2004-06-29 19:15:28.940144192 -0400
@@ -247,7 +247,11 @@ void __init print_efi_memmap(void)
 
 	for (i = 0; i < memmap.nr_map; i++) {
 		md = &memmap.map[i];
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "mem%02u: type=%u, attr=0x%llx, "
+#else
 		printk(KERN_INFO "mem%02u: type=%u, attr=0x%llx, "
+#endif
 			"range=[0x%016llx-0x%016llx) (%lluMB)\n",
 			i, md->type, md->attribute, md->phys_addr,
 			md->phys_addr + (md->num_pages << EFI_PAGE_SHIFT),
@@ -284,7 +288,11 @@ void efi_memmap_walk(efi_freemem_callbac
 			prev_valid = 1;
 		} else {
 			if (curr.start < prev.start)
+#ifdef CONFIG_SILENT_BOOT
+				printk(KERN_DEBUG PFX "Unordered memory map\n");
+#else
 				printk(KERN_INFO PFX "Unordered memory map\n");
+#endif
 			if (prev.end == curr.start)
 				prev.end = curr.end;
 			else {
@@ -358,8 +366,11 @@ void __init efi_init(void)
 		vendor[i] = '\0';
 	} else
 		printk(KERN_ERR PFX "Could not map the firmware vendor!\n");
-
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG PFX "EFI v%u.%.02u by %s \n",
+#else
 	printk(KERN_INFO PFX "EFI v%u.%.02u by %s \n",
+#endif
 	       efi.systab->hdr.revision >> 16,
 	       efi.systab->hdr.revision & 0xffff, vendor);
 
@@ -376,27 +387,51 @@ void __init efi_init(void)
 	for (i = 0; i < num_config_tables; i++) {
 		if (efi_guidcmp(config_tables[i].guid, MPS_TABLE_GUID) == 0) {
 			efi.mps = (void *)config_tables[i].table;
+#ifdef CONFIG_SILENT_BOOT
+			printk(KERN_DEBUG " MPS=0x%lx ", config_tables[i].table);
+#else
 			printk(KERN_INFO " MPS=0x%lx ", config_tables[i].table);
+#endif
 		} else
 		    if (efi_guidcmp(config_tables[i].guid, ACPI_20_TABLE_GUID) == 0) {
 			efi.acpi20 = __va(config_tables[i].table);
+#ifdef CONFIG_SILENT_BOOT
+			printk(KERN_DEBUG " ACPI 2.0=0x%lx ", config_tables[i].table);
+#else
 			printk(KERN_INFO " ACPI 2.0=0x%lx ", config_tables[i].table);
+#endif
 		} else
 		    if (efi_guidcmp(config_tables[i].guid, ACPI_TABLE_GUID) == 0) {
 			efi.acpi = __va(config_tables[i].table);
+#ifdef CONFIG_SILENT_BOOT
+			printk(KERN_DEBUG " ACPI=0x%lx ", config_tables[i].table);
+#else
 			printk(KERN_INFO " ACPI=0x%lx ", config_tables[i].table);
+#endif
 		} else
 		    if (efi_guidcmp(config_tables[i].guid, SMBIOS_TABLE_GUID) == 0) {
 			efi.smbios = (void *) config_tables[i].table;
+#ifdef CONFIG_SILENT_BOOT
+			printk(KERN_DEBUG " SMBIOS=0x%lx ", config_tables[i].table);
+#else
 			printk(KERN_INFO " SMBIOS=0x%lx ", config_tables[i].table);
+#endif
 		} else
 		    if (efi_guidcmp(config_tables[i].guid, HCDP_TABLE_GUID) == 0) {
 			efi.hcdp = (void *)config_tables[i].table;
+#ifdef CONFIG_SILENT_BOOT
+			printk(KERN_DEBUG " HCDP=0x%lx ", config_tables[i].table);
+#else
 			printk(KERN_INFO " HCDP=0x%lx ", config_tables[i].table);
+#endif
 		} else
 		    if (efi_guidcmp(config_tables[i].guid, UGA_IO_PROTOCOL_GUID) == 0) {
 			efi.uga = (void *)config_tables[i].table;
+#ifdef CONFIG_SILENT_BOOT
+			printk(KERN_DEBUG " UGA=0x%lx ", config_tables[i].table);
+#else
 			printk(KERN_INFO " UGA=0x%lx ", config_tables[i].table);
+#endif
 		}
 	}
 	printk("\n");
diff -puN arch/i386/kernel/io_apic.c~silence-i386-boot arch/i386/kernel/io_apic.c
--- linux-2.6.7-xx4/arch/i386/kernel/io_apic.c~silence-i386-boot	2004-06-29 19:15:28.866155440 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/kernel/io_apic.c	2004-06-29 19:15:28.944143584 -0400
@@ -626,8 +626,9 @@ static int __init balanced_irq_init(void
 		memset(irq_cpu_data[i].irq_delta,0,sizeof(unsigned long) * NR_IRQS);
 		memset(irq_cpu_data[i].last_irq,0,sizeof(unsigned long) * NR_IRQS);
 	}
-	
+#ifndef CONFIG_SILENT_BOOT
 	printk(KERN_INFO "Starting balanced_irq\n");
+#endif
 	if (kernel_thread(balanced_irq, NULL, CLONE_KERNEL) >= 0) 
 		return 0;
 	else 
@@ -712,7 +713,11 @@ static int __init ioapic_pirq_setup(char
 		pirq_entries[i] = -1;
 
 	pirqs_enabled = 1;
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "PIRQ redirection, working around broken MP-BIOS.\n");
+#else
 	printk(KERN_INFO "PIRQ redirection, working around broken MP-BIOS.\n");
+#endif
 	max = MAX_PIRQS;
 	if (ints[0] < MAX_PIRQS)
 		max = ints[0];
@@ -782,7 +787,11 @@ int IO_APIC_get_PCI_irq_vector(int bus, 
 	Dprintk("querying PCI -> IRQ mapping bus:%d, slot:%d, pin:%d.\n",
 		bus, slot, pin);
 	if (mp_bus_id_to_pci_bus[bus] == -1) {
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "PCI BIOS passed nonexistent PCI bus %d!\n", bus);
+#else
 		printk(KERN_WARNING "PCI BIOS passed nonexistent PCI bus %d!\n", bus);
+#endif
 		return -1;
 	}
 	for (i = 0; i < mp_irq_entries; i++) {
@@ -848,7 +857,11 @@ static int __init EISA_ELCR(unsigned int
 		unsigned int port = 0x4d0 + (irq >> 3);
 		return (inb(port) >> (irq & 7)) & 1;
 	}
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "Broken MPtable reports ISA irq %d\n", irq);
+#else
 	printk(KERN_INFO "Broken MPtable reports ISA irq %d\n", irq);
+#endif
 	return 0;
 }
 
@@ -1315,7 +1328,11 @@ void __init print_IO_APIC(void)
 	 * We are a bit conservative about what we expect.  We have to
 	 * know about every hardware change ASAP.
 	 */
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "testing the IO APIC.......................\n");
+#else
 	printk(KERN_INFO "testing the IO APIC.......................\n");
+#endif
 
 	for (apic = 0; apic < nr_ioapics; apic++) {
 
@@ -1437,9 +1454,11 @@ void __init print_IO_APIC(void)
 		}
 		printk("\n");
 	}
-
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG ".................................... done.\n");
+#else
 	printk(KERN_INFO ".................................... done.\n");
-
+#endif
 	return;
 }
 
@@ -1468,9 +1487,17 @@ void /*__init*/ print_local_APIC(void * 
 	printk("\n" KERN_DEBUG "printing local APIC contents on CPU#%d/%d:\n",
 		smp_processor_id(), hard_smp_processor_id());
 	v = apic_read(APIC_ID);
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "... APIC ID:      %08x (%01x)\n", v, GET_APIC_ID(v));
+#else
 	printk(KERN_INFO "... APIC ID:      %08x (%01x)\n", v, GET_APIC_ID(v));
+#endif
 	v = apic_read(APIC_LVR);
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "... APIC VERSION: %08x\n", v);
+#else
 	printk(KERN_INFO "... APIC VERSION: %08x\n", v);
+#endif
 	ver = GET_APIC_VERSION(v);
 	maxlvt = get_maxlvt();
 
@@ -1687,7 +1714,12 @@ static void __init setup_ioapic_ids_from
 		} else {
 			physid_mask_t tmp;
 			tmp = apicid_to_cpu_present(mp_ioapics[apic].mpc_apicid);
+#ifdef CONFIG_SILENT_BOOT
+			printk(KERN_DEBUG "Setting %d in the phys_id_present_map\n",
+				mp_ioapics[apic].mpc_apicid);
+#else
 			printk("Setting %d in the phys_id_present_map\n", mp_ioapics[apic].mpc_apicid);
+#endif
 			physids_or(phys_id_present_map, phys_id_present_map, tmp);
 		}
 
@@ -1706,7 +1738,11 @@ static void __init setup_ioapic_ids_from
 		 * Read the right value from the MPC table and
 		 * write it into the ID register.
 	 	 */
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "...changing IO-APIC physical APIC ID to %d ...",
+#else
 		printk(KERN_INFO "...changing IO-APIC physical APIC ID to %d ...",
+#endif
 					mp_ioapics[apic].mpc_apicid);
 
 		reg_00.bits.ID = mp_ioapics[apic].mpc_apicid;
@@ -2038,7 +2074,11 @@ static void setup_nmi (void)
 	 * is from Maciej W. Rozycki - so we do not have to EOI from
 	 * the NMI handler or the timer interrupt.
 	 */ 
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "activating NMI Watchdog ...");
+#else
 	printk(KERN_INFO "activating NMI Watchdog ...");
+#endif
 
 	on_each_cpu(enable_NMI_through_LVT0, NULL, 1, 1);
 
@@ -2139,8 +2179,11 @@ static inline void check_timer(void)
 
 	pin1 = find_isa_irq_pin(0, mp_INT);
 	pin2 = find_isa_irq_pin(0, mp_ExtINT);
-
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "..TIMER: vector=0x%02X pin1=%d pin2=%d\n", vector, pin1, pin2);
+#else
 	printk(KERN_INFO "..TIMER: vector=0x%02X pin1=%d pin2=%d\n", vector, pin1, pin2);
+#endif
 
 	if (pin1 != -1) {
 		/*
@@ -2159,8 +2202,11 @@ static inline void check_timer(void)
 		clear_IO_APIC_pin(0, pin1);
 		printk(KERN_ERR "..MP-BIOS bug: 8254 timer not connected to IO-APIC\n");
 	}
-
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "...trying to set up timer (IRQ0) through the 8259A ... ");
+#else
 	printk(KERN_INFO "...trying to set up timer (IRQ0) through the 8259A ... ");
+#endif
 	if (pin2 != -1) {
 		printk("\n..... (found pin %d) ...", pin2);
 		/*
@@ -2190,9 +2236,11 @@ static inline void check_timer(void)
 		printk(KERN_WARNING "timer doesn't work through the IO-APIC - disabling NMI Watchdog!\n");
 		nmi_watchdog = 0;
 	}
-
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "...trying to set up timer as Virtual Wire IRQ...");
+#else
 	printk(KERN_INFO "...trying to set up timer as Virtual Wire IRQ...");
-
+#endif
 	disable_8259A_irq(0);
 	irq_desc[0].handler = &lapic_irq_type;
 	apic_write_around(APIC_LVT0, APIC_DM_FIXED | vector);	/* Fixed mode */
@@ -2204,9 +2252,11 @@ static inline void check_timer(void)
 	}
 	apic_write_around(APIC_LVT0, APIC_LVT_MASKED | APIC_DM_FIXED | vector);
 	printk(" failed.\n");
-
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "...trying to set up timer as ExtINT IRQ...");
+#else
 	printk(KERN_INFO "...trying to set up timer as ExtINT IRQ...");
-
+#endif
 	timer_ack = 0;
 	init_8259A(0);
 	make_8259A_irq(0);
@@ -2239,9 +2289,11 @@ void __init setup_IO_APIC(void)
 		io_apic_irqs = ~0;	/* all IRQs go through IOAPIC */
 	else
 		io_apic_irqs = ~PIC_IRQS;
-
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "ENABLING IO-APIC IRQs\n");
+#else
 	printk("ENABLING IO-APIC IRQs\n");
-
+#endif
 	/*
 	 * Set up IO-APIC IRQ routing.
 	 */
@@ -2340,9 +2392,11 @@ int __init io_apic_get_unique_id (int io
 		if (reg_00.bits.ID != apic_id)
 			panic("IOAPIC[%d]: Unable change apic_id!\n", ioapic);
 	}
-
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "IOAPIC[%d]: Assigned apic_id %d\n", ioapic, apic_id);
+#else
 	printk(KERN_INFO "IOAPIC[%d]: Assigned apic_id %d\n", ioapic, apic_id);
-
+#endif
 	return apic_id;
 }
 
diff -puN arch/i386/kernel/irq.c~silence-i386-boot arch/i386/kernel/irq.c
--- linux-2.6.7-xx4/arch/i386/kernel/irq.c~silence-i386-boot	2004-06-29 19:15:28.869154984 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/kernel/irq.c	2004-06-29 19:15:28.946143280 -0400
@@ -102,8 +102,11 @@ static void ack_none(unsigned int irq)
  * each architecture has to answer this themselves, it doesn't deserve
  * a generic callback i think.
  */
-#ifdef CONFIG_X86
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_ERR "unexpected IRQ trap at vector %02x\n", irq);
+#elif defined(CONFIG_X86)
 	printk("unexpected IRQ trap at vector %02x\n", irq);
+#endif
 #ifdef CONFIG_X86_LOCAL_APIC
 	/*
 	 * Currently unexpected vectors happen only on SMP and APIC.
@@ -115,7 +118,6 @@ static void ack_none(unsigned int irq)
 	 */
 	ack_APIC_irq();
 #endif
-#endif
 }
 
 /* startup is the same as "enable", shutdown is same as "disable" */
@@ -273,7 +275,11 @@ static int noirqdebug;
 static int __init noirqdebug_setup(char *str)
 {
 	noirqdebug = 1;
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "IRQ lockup detection disabled\n");
+#else
 	printk("IRQ lockup detection disabled\n");
+#endif
 	return 1;
 }
 
@@ -402,7 +408,11 @@ void enable_irq(unsigned int irq)
 		desc->depth--;
 		break;
 	case 0:
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "enable_irq(%u) unbalanced from %p\n", irq,
+#else
 		printk("enable_irq(%u) unbalanced from %p\n", irq,
+#endif
 		       __builtin_return_address(0));
 	}
 	spin_unlock_irqrestore(&desc->lock, flags);
@@ -440,7 +450,11 @@ asmlinkage unsigned int do_IRQ(struct pt
 		__asm__ __volatile__("andl %%esp,%0" :
 					"=r" (esp) : "0" (THREAD_SIZE - 1));
 		if (unlikely(esp < (sizeof(struct thread_info) + STACK_WARN))) {
+#ifdef CONFIG_SILENT_BOOT
+			printk(KERN_WARNING "do_IRQ: stack overflow: %ld\n",
+#else
 			printk("do_IRQ: stack overflow: %ld\n",
+#endif
 				esp - sizeof(struct thread_info));
 			dump_stack();
 		}
@@ -638,7 +652,12 @@ int request_irq(unsigned int irq, 
 	 */
 	if (irqflags & SA_SHIRQ) {
 		if (!dev_id)
+#ifdef CONFIG_SILENT_BOOT
+			printk(KERN_DEBUG "Bad boy: %s (at 0x%x) called us without a dev_id!\n",
+				devname, (&irq)[-1]);
+#else
 			printk("Bad boy: %s (at 0x%x) called us without a dev_id!\n", devname, (&irq)[-1]);
+#endif
 	}
 #endif
 
@@ -715,7 +734,11 @@ void free_irq(unsigned int irq, void *de
 			kfree(action);
 			return;
 		}
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "Trying to free free IRQ%d\n",irq);
+#else
 		printk("Trying to free free IRQ%d\n",irq);
+#endif
 		spin_unlock_irqrestore(&desc->lock,flags);
 		return;
 	}
@@ -1148,8 +1171,11 @@ void irq_ctx_init(int cpu)
 	irqctx->tinfo.addr_limit        = MAKE_MM_SEG(0);
 
 	softirq_ctx[cpu] = irqctx;
-
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "CPU %u irqstacks, hard=%p soft=%p\n",
+#else
 	printk("CPU %u irqstacks, hard=%p soft=%p\n",
+#endif
 		cpu,hardirq_ctx[cpu],softirq_ctx[cpu]);
 }
 
diff -puN arch/i386/kernel/mca.c~silence-i386-boot arch/i386/kernel/mca.c
--- linux-2.6.7-xx4/arch/i386/kernel/mca.c~silence-i386-boot	2004-06-29 19:15:28.870154832 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/kernel/mca.c	2004-06-29 19:15:28.948142976 -0400
@@ -259,15 +259,19 @@ static int __init mca_init(void)
 	/* Make sure the MCA bus is present */
 
 	if (mca_system_init()) {
+#ifndef CONFIG_SILENT_BOOT
 		printk(KERN_ERR "MCA bus system initialisation failed\n");
+#endif
 		return -ENODEV;
 	}
 
 	if (!MCA_bus)
 		return -ENODEV;
-
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "Micro Channel bus detected.\n");
+#else
 	printk(KERN_INFO "Micro Channel bus detected.\n");
-
+#endif
 	/* All MCA systems have at least a primary bus */
 	bus = mca_attach_bus(MCA_PRIMARY_BUS);
 	if (!bus)
diff -puN arch/i386/kernel/microcode.c~silence-i386-boot arch/i386/kernel/microcode.c
--- linux-2.6.7-xx4/arch/i386/kernel/microcode.c~silence-i386-boot	2004-06-29 19:15:28.872154528 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/kernel/microcode.c	2004-06-29 19:17:09.363877464 -0400
@@ -369,7 +369,11 @@ static void do_update_one (void * unused
 	struct ucode_cpu_info *uci = ucode_cpu_info + cpu_num;
 
 	if (uci->mc == NULL) {
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "microcode: No suitable data for CPU%d\n", cpu_num);
+#else
 		printk(KERN_INFO "microcode: No suitable data for CPU%d\n", cpu_num);
+#endif
 		return;
 	}
 
@@ -389,7 +393,11 @@ static void do_update_one (void * unused
 	/* notify the caller of success on this cpu */
 	uci->err = MC_SUCCESS;
 	spin_unlock_irqrestore(&microcode_update_lock, flags);
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "microcode: CPU%d updated from revision "
+#else
 	printk(KERN_INFO "microcode: CPU%d updated from revision "
+#endif
 	       "0x%x to 0x%x, date = %08x \n", 
 	       cpu_num, uci->rev, val[1], uci->mc->hdr.date);
 	return;
@@ -500,7 +508,11 @@ static int __init microcode_init (void)
 		return error;
 	}
 
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG
+#else
 	printk(KERN_INFO 
+#endif
 		"IA-32 Microcode Update Driver: v" MICROCODE_VERSION " <tigran@veritas.com>\n");
 	return 0;
 }
@@ -508,7 +520,9 @@ static int __init microcode_init (void)
 static void __exit microcode_exit (void)
 {
 	misc_deregister(&microcode_dev);
+#ifndef CONFIG_SILENT_BOOT
 	printk(KERN_INFO "IA-32 Microcode Update Driver v" MICROCODE_VERSION " unregistered\n");
+#endif
 }
 
 module_init(microcode_init)
diff -puN arch/i386/kernel/mpparse.c~silence-i386-boot arch/i386/kernel/mpparse.c
--- linux-2.6.7-xx4/arch/i386/kernel/mpparse.c~silence-i386-boot	2004-06-29 19:15:28.874154224 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/kernel/mpparse.c	2004-06-29 19:15:28.953142216 -0400
@@ -249,8 +249,11 @@ static void __init MP_ioapic_info (struc
 {
 	if (!(m->mpc_flags & MPC_APIC_USABLE))
 		return;
-
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "I/O APIC #%d Version %d at 0x%lX.\n",
+#else
 	printk(KERN_INFO "I/O APIC #%d Version %d at 0x%lX.\n",
+#endif
 		m->mpc_apicid, m->mpc_apicver, m->mpc_apicaddr);
 	if (nr_ioapics >= MAX_IO_APICS) {
 		printk(KERN_CRIT "Max # of I/O APICs (%d) exceeded (found %d).\n",
@@ -303,7 +306,11 @@ static void __init MP_lintsrc_info (stru
 #ifdef CONFIG_X86_NUMAQ
 static void __init MP_translation_info (struct mpc_config_translation *m)
 {
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "Translation: record %d, type %d, quad %d, global %d, local %d\n", mpc_record, m->trans_type, m->trans_quad, m->trans_global, m->trans_local);
+#else
 	printk(KERN_INFO "Translation: record %d, type %d, quad %d, global %d, local %d\n", mpc_record, m->trans_type, m->trans_quad, m->trans_global, m->trans_local);
+#endif
 
 	if (mpc_record >= MAX_MPC_ENTRY) 
 		printk(KERN_ERR "MAX_MPC_ENTRY exceeded!\n");
@@ -324,7 +331,11 @@ static void __init smp_read_mpc_oem(stru
 	unsigned char *oemptr = ((unsigned char *)oemtable)+count;
 	
 	mpc_record = 0;
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "Found an OEM MPC table at %8p - parsing it ... \n", oemtable);
+#else
 	printk(KERN_INFO "Found an OEM MPC table at %8p - parsing it ... \n", oemtable);
+#endif
 	if (memcmp(oemtable->oem_signature,MPC_OEM_SIGNATURE,4))
 	{
 		printk(KERN_WARNING "SMP mpc oemtable: bad signature [%c%c%c%c]!\n",
@@ -364,7 +375,11 @@ static inline void mps_oem_check(struct 
 		char *productid)
 {
 	if (strncmp(oem, "IBM NUMA", 8))
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_WARNING "Warning!  May not be a NUMA-Q system!\n");
+#else
 		printk("Warning!  May not be a NUMA-Q system!\n");
+#endif
 	if (mpc->mpc_oemptr)
 		smp_read_mpc_oem((struct mp_config_oemtable *) mpc->mpc_oemptr,
 				mpc->mpc_oemsize);
@@ -402,7 +417,11 @@ static int __init smp_read_mpc(struct mp
 	}
 	memcpy(oem,mpc->mpc_oem,8);
 	oem[8]=0;
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "OEM ID: %s ",oem);
+#else
 	printk(KERN_INFO "OEM ID: %s ",oem);
+#endif
 
 	memcpy(str,mpc->mpc_productid,12);
 	str[12]=0;
@@ -517,12 +536,20 @@ static void __init construct_default_ioi
 	 *  If it does, we assume it's valid.
 	 */
 	if (mpc_default_type == 5) {
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "ISA/PCI bus type with no IRQ information... falling back to ELCR\n");
+#else
 		printk(KERN_INFO "ISA/PCI bus type with no IRQ information... falling back to ELCR\n");
+#endif
 
 		if (ELCR_trigger(0) || ELCR_trigger(1) || ELCR_trigger(2) || ELCR_trigger(13))
 			printk(KERN_WARNING "ELCR contains invalid data... not using ELCR\n");
 		else {
+#ifdef CONFIG_SILENT_BOOT
+			printk(KERN_DEBUG "Using ELCR to identify PCI interrupts\n");
+#else
 			printk(KERN_INFO "Using ELCR to identify PCI interrupts\n");
+#endif
 			ELCR_fallback = 1;
 		}
 	}
@@ -661,18 +688,34 @@ void __init get_smp_config (void)
 	 * processors, where MPS only supports physical.
 	 */
 	if (acpi_lapic && acpi_ioapic) {
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "Using ACPI (MADT) for SMP configuration information\n");
+#else
 		printk(KERN_INFO "Using ACPI (MADT) for SMP configuration information\n");
+#endif
 		return;
 	}
 	else if (acpi_lapic)
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "Using ACPI for processor (LAPIC) configuration information\n");
+#else
 		printk(KERN_INFO "Using ACPI for processor (LAPIC) configuration information\n");
+#endif
 
 	printk(KERN_INFO "Intel MultiProcessor Specification v1.%d\n", mpf->mpf_specification);
 	if (mpf->mpf_feature2 & (1<<7)) {
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "    IMCR and PIC compatibility mode.\n");
+#else
 		printk(KERN_INFO "    IMCR and PIC compatibility mode.\n");
+#endif
 		pic_mode = 1;
 	} else {
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "    Virtual Wire compatibility mode.\n");
+#else
 		printk(KERN_INFO "    Virtual Wire compatibility mode.\n");
+#endif
 		pic_mode = 0;
 	}
 
@@ -680,8 +723,11 @@ void __init get_smp_config (void)
 	 * Now see if we need to read further.
 	 */
 	if (mpf->mpf_feature1 != 0) {
-
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "Default MP configuration #%d\n", mpf->mpf_feature1);
+#else
 		printk(KERN_INFO "Default MP configuration #%d\n", mpf->mpf_feature1);
+#endif
 		construct_default_ISA_mptable(mpf->mpf_feature1);
 
 	} else if (mpf->mpf_physptr) {
@@ -741,7 +787,11 @@ static int __init smp_scan_config (unsig
 				|| (mpf->mpf_specification == 4)) ) {
 
 			smp_found_config = 1;
+#ifdef CONFIG_SILENT_BOOT
+			printk(KERN_DEBUG "found SMP MP-table at %08lx\n",
+#else
 			printk(KERN_INFO "found SMP MP-table at %08lx\n",
+#endif
 						virt_to_phys(mpf));
 			reserve_bootmem(virt_to_phys(mpf), PAGE_SIZE);
 			if (mpf->mpf_physptr) {
@@ -926,8 +976,11 @@ void __init mp_register_ioapic (
 	mp_ioapic_routing[idx].gsi_base = gsi_base;
 	mp_ioapic_routing[idx].gsi_end = gsi_base + 
 		io_apic_get_redir_entries(idx);
-
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "IOAPIC[%d]: apic_id %d, version %d, address 0x%lx, "
+#else
 	printk("IOAPIC[%d]: apic_id %d, version %d, address 0x%lx, "
+#endif
 		"GSI %d-%d\n", idx, mp_ioapics[idx].mpc_apicid, 
 		mp_ioapics[idx].mpc_apicver, mp_ioapics[idx].mpc_apicaddr,
 		mp_ioapic_routing[idx].gsi_base,
diff -puN arch/i386/kernel/nmi.c~silence-i386-boot arch/i386/kernel/nmi.c
--- linux-2.6.7-xx4/arch/i386/kernel/nmi.c~silence-i386-boot	2004-06-29 19:15:28.876153920 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/kernel/nmi.c	2004-06-29 19:15:28.954142064 -0400
@@ -112,9 +112,11 @@ int __init check_nmi_watchdog (void)
 {
 	unsigned int prev_nmi_count[NR_CPUS];
 	int cpu;
-
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "testing NMI watchdog ... ");
+#else
 	printk(KERN_INFO "testing NMI watchdog ... ");
-
+#endif
 	for (cpu = 0; cpu < NR_CPUS; cpu++)
 		prev_nmi_count[cpu] = irq_stat[cpu].__nmi_count;
 	local_irq_enable();
diff -puN arch/i386/kernel/scx200.c~silence-i386-boot arch/i386/kernel/scx200.c
--- linux-2.6.7-xx4/arch/i386/kernel/scx200.c~silence-i386-boot	2004-06-29 19:15:28.878153616 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/kernel/scx200.c	2004-06-29 19:15:28.957141608 -0400
@@ -81,9 +81,9 @@ int __init scx200_init(void)
 	struct pci_dev *bridge;
 	int bank;
 	unsigned base;
-
+#ifndef CONFIG_SILENT_BOOT
 	printk(KERN_INFO NAME ": NatSemi SCx200 Driver\n");
-
+#endif
 	if ((bridge = pci_find_device(PCI_VENDOR_ID_NS, 
 				      PCI_DEVICE_ID_NS_SCx200_BRIDGE,
 				      NULL)) == NULL
@@ -93,8 +93,11 @@ int __init scx200_init(void)
 		return -ENODEV;
 
 	base = pci_resource_start(bridge, 0);
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG NAME ": GPIO base 0x%x\n", base);
+#else
 	printk(KERN_INFO NAME ": GPIO base 0x%x\n", base);
-
+#endif
 	if (request_region(base, SCx200_GPIO_SIZE, "NatSemi SCx200 GPIO") == 0) {
 		printk(KERN_ERR NAME ": can't allocate I/O for GPIOs\n");
 		return -EBUSY;
diff -puN arch/i386/kernel/setup.c~silence-i386-boot arch/i386/kernel/setup.c
--- linux-2.6.7-xx4/arch/i386/kernel/setup.c~silence-i386-boot	2004-06-29 19:15:28.880153312 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/kernel/setup.c	2004-06-29 19:15:28.964140544 -0400
@@ -386,7 +386,11 @@ static void __init print_memory_map(char
 	int i;
 
 	for (i = 0; i < e820.nr_map; i++) {
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG " %s: %016Lx - %016Lx ", who,
+#else
 		printk(" %s: %016Lx - %016Lx ", who,
+#endif
 			e820.map[i].addr,
 			e820.map[i].addr + e820.map[i].size);
 		switch (e820.map[i].type) {
@@ -819,7 +823,11 @@ static void __init parse_cmdline_early (
 	*to = '\0';
 	*cmdline_p = command_line;
 	if (userdef) {
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "user-defined physical RAM map:\n");
+#else
 		printk(KERN_INFO "user-defined physical RAM map:\n");
+#endif
 		print_memory_map("user");
 	}
 }
@@ -1311,7 +1319,11 @@ void __init setup_arch(char **cmdline_p)
 	if (efi_enabled)
 		efi_init();
 	else {
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "BIOS-provided physical RAM map:\n");
+#else
 		printk(KERN_INFO "BIOS-provided physical RAM map:\n");
+#endif
 		print_memory_map(machine_specific_memory_setup());
 	}
 
diff -puN arch/i386/kernel/smpboot.c~silence-i386-boot arch/i386/kernel/smpboot.c
--- linux-2.6.7-xx4/arch/i386/kernel/smpboot.c~silence-i386-boot	2004-06-29 19:15:28.882153008 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/kernel/smpboot.c	2004-06-29 19:15:28.967140088 -0400
@@ -218,8 +218,12 @@ static void __init synchronize_tsc_bp (v
 	long long delta;
 	unsigned long one_usec;
 	int buggy = 0;
-
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "checking TSC synchronization across %u CPUs: ",
+		num_booting_cpus());
+#else
 	printk("checking TSC synchronization across %u CPUs: ", num_booting_cpus());
+#endif
 
 	/* convert from kcyc/sec to cyc/usec */
 	one_usec = cpu_khz / 1000;
@@ -295,8 +299,11 @@ static void __init synchronize_tsc_bp (v
 			realdelta = div64(delta, one_usec);
 			if (tsc_values[i] < avg)
 				realdelta = -realdelta;
-
+#ifdef CONFIG_SILENT_BOOT
+			printk(KERN_DEBUG "BIOS BUG: CPU#%d improperly initialized, has %ld usecs TSC skew! FIXED.\n", i, realdelta);
+#else
 			printk("BIOS BUG: CPU#%d improperly initialized, has %ld usecs TSC skew! FIXED.\n", i, realdelta);
+#endif
 		}
 
 		sum += delta;
@@ -355,7 +362,11 @@ void __init smp_callin(void)
 	phys_id = GET_APIC_ID(apic_read(APIC_ID));
 	cpuid = smp_processor_id();
 	if (cpu_isset(cpuid, cpu_callin_map)) {
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "huh, phys CPU#%d, CPU#%d already present??\n",
+#else
 		printk("huh, phys CPU#%d, CPU#%d already present??\n",
+#endif
 					phys_id, cpuid);
 		BUG();
 	}
@@ -383,7 +394,11 @@ void __init smp_callin(void)
 	}
 
 	if (!time_before(jiffies, timeout)) {
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "BUG: CPU%d started up but did not get a callout!\n",
+#else
 		printk("BUG: CPU%d started up but did not get a callout!\n",
+#endif
 			cpuid);
 		BUG();
 	}
@@ -509,7 +524,11 @@ EXPORT_SYMBOL(cpu_2_node);
 /* set up a mapping between cpu and node. */
 static inline void map_cpu_to_node(int cpu, int node)
 {
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "Mapping cpu %d to node %d\n", cpu, node);
+#else
 	printk("Mapping cpu %d to node %d\n", cpu, node);
+#endif
 	cpu_set(cpu, node_2_cpu_mask[node]);
 	cpu_2_node[cpu] = node;
 }
@@ -518,8 +537,11 @@ static inline void map_cpu_to_node(int c
 static inline void unmap_cpu_to_node(int cpu)
 {
 	int node;
-
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "Unmapping cpu %d from all nodes\n", cpu);
+#else
 	printk("Unmapping cpu %d from all nodes\n", cpu);
+#endif
 	for (node = 0; node < MAX_NUMNODES; node ++)
 		cpu_clear(cpu, node_2_cpu_mask[node]);
 	cpu_2_node[cpu] = 0;
@@ -629,10 +651,17 @@ wakeup_secondary_cpu(int logical_apicid,
 	Dprintk("NMI sent.\n");
 
 	if (send_status)
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "APIC never delivered???\n");
+#else
 		printk("APIC never delivered???\n");
+#endif
 	if (accept_status)
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "APIC delivery error (%lx).\n", accept_status);
+#else
 		printk("APIC delivery error (%lx).\n", accept_status);
-
+#endif
 	return (send_status | accept_status);
 }
 #endif	/* WAKE_SECONDARY_VIA_NMI */
@@ -764,10 +793,18 @@ wakeup_secondary_cpu(int phys_apicid, un
 	Dprintk("After Startup.\n");
 
 	if (send_status)
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "APIC never delivered???\n");
+#else
 		printk("APIC never delivered???\n");
+#endif
 	if (accept_status)
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "APIC delivery error (%lx).\n",
+			accept_status);
+#else
 		printk("APIC delivery error (%lx).\n", accept_status);
-
+#endif
 	return (send_status | accept_status);
 }
 #endif	/* WAKE_SECONDARY_VIA_INIT */
@@ -808,7 +845,12 @@ static int __init do_boot_cpu(int apicid
 	start_eip = setup_trampoline();
 
 	/* So we see what's up   */
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "Booting processor %d/%d eip %lx\n",
+		cpu, apicid, start_eip);
+#else
 	printk("Booting processor %d/%d eip %lx\n", cpu, apicid, start_eip);
+#endif
 	/* Stack for startup_32 can be just as for start_secondary onwards */
 	stack_start.esp = (void *) idle->thread.esp;
 
@@ -852,7 +894,11 @@ static int __init do_boot_cpu(int apicid
 		if (cpu_isset(cpu, cpu_callin_map)) {
 			/* number CPUs logically, starting from 1 (BSP is 0) */
 			Dprintk("OK.\n");
+#ifdef CONFIG_SILENT_BOOT
+			printk(KERN_DEBUG "CPU%d: ", cpu);
+#else
 			printk("CPU%d: ", cpu);
+#endif
 			print_cpu_info(&cpu_data[cpu]);
 			Dprintk("CPU has booted.\n");
 		} else {
@@ -860,10 +906,18 @@ static int __init do_boot_cpu(int apicid
 			if (*((volatile unsigned char *)trampoline_base)
 					== 0xA5)
 				/* trampoline started but...? */
+#ifdef CONFIG_SILENT_BOOT
+				printk(KERN_DEBUG "Stuck ??\n");
+#else
 				printk("Stuck ??\n");
+#endif
 			else
 				/* trampoline code not run */
+#ifdef CONFIG_SILENT_BOOT
+				printk(KERN_DEBUG "Not responding.\n");
+#else
 				printk("Not responding.\n");
+#endif
 			inquire_remote_apic(apicid);
 		}
 	}
@@ -918,10 +972,18 @@ static void smp_tune_scheduling (void)
 
 	cache_decay_ticks = (long)cacheflush_time/cpu_khz + 1;
 
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "per-CPU timeslice cutoff: %ld.%02ld usecs.\n",
+#else
 	printk("per-CPU timeslice cutoff: %ld.%02ld usecs.\n",
+#endif
 		(long)cacheflush_time/(cpu_khz/1000),
 		((long)cacheflush_time*100/(cpu_khz/1000)) % 100);
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "task migration cache decay timeout: %ld msecs.\n",
+#else
 	printk("task migration cache decay timeout: %ld msecs.\n",
+#endif
 		cache_decay_ticks);
 }
 
@@ -944,7 +1006,11 @@ static void __init smp_boot_cpus(unsigne
 	 * Setup boot CPU information
 	 */
 	smp_store_cpu_info(0); /* Final full version of the data */
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_INFO "CPU%d: ", 0);
+#else
 	printk("CPU%d: ", 0);
+#endif
 	print_cpu_info(&cpu_data[0]);
 
 	boot_cpu_physical_apicid = GET_APIC_ID(apic_read(APIC_ID));
@@ -960,11 +1026,19 @@ static void __init smp_boot_cpus(unsigne
 	 * get out of here now!
 	 */
 	if (!smp_found_config && !acpi_lapic) {
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "SMP motherboard not detected.\n");
+#else
 		printk(KERN_NOTICE "SMP motherboard not detected.\n");
+#endif
 		smpboot_clear_io_apic_irqs();
 		phys_cpu_present_map = physid_mask_of_physid(0);
 		if (APIC_init_uniprocessor())
+#ifdef CONFIG_SILENT_BOOT
+			printk(KERN_DEBUG "Local APIC not detected."
+#else
 			printk(KERN_NOTICE "Local APIC not detected."
+#endif
 					   " Using dummy APIC emulation.\n");
 		map_cpu_to_logical_apicid();
 		return;
@@ -976,7 +1050,11 @@ static void __init smp_boot_cpus(unsigne
 	 * Makes no sense to do this check in clustered apic mode, so skip it
 	 */
 	if (!check_phys_apicid_present(boot_cpu_physical_apicid)) {
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "weird, boot CPU (#%d) not listed by the BIOS.\n",
+#else
 		printk("weird, boot CPU (#%d) not listed by the BIOS.\n",
+#endif
 				boot_cpu_physical_apicid);
 		physid_set(hard_smp_processor_id(), phys_cpu_present_map);
 	}
@@ -1000,7 +1078,11 @@ static void __init smp_boot_cpus(unsigne
 	 */
 	if (!max_cpus) {
 		smp_found_config = 0;
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "SMP mode deactivated, forcing use of dummy APIC emulation.\n");
+#else
 		printk(KERN_INFO "SMP mode deactivated, forcing use of dummy APIC emulation.\n");
+#endif
 		smpboot_clear_io_apic_irqs();
 		phys_cpu_present_map = physid_mask_of_physid(0);
 		return;
@@ -1037,7 +1119,11 @@ static void __init smp_boot_cpus(unsigne
 			continue;
 
 		if (do_boot_cpu(apicid))
+#ifdef CONFIG_SILENT_BOOT
+			printk(KERN_WARNING "CPU #%d not responding - cannot use it.\n",
+#else
 			printk("CPU #%d not responding - cannot use it.\n",
+#endif
 								apicid);
 		else
 			++kicked;
@@ -1072,7 +1158,11 @@ static void __init smp_boot_cpus(unsigne
 	 */
 	if (tainted & TAINT_UNSAFE_SMP) {
 		if (cpucount)
+#ifdef CONFIG_SILENT_BOOT
+			printk (KERN_WARNING "WARNING: This combination of AMD processors is not suitable for SMP.\n");
+#else
 			printk (KERN_INFO "WARNING: This combination of AMD processors is not suitable for SMP.\n");
+#endif
 		else
 			tainted &= ~TAINT_UNSAFE_SMP;
 	}
diff -puN arch/i386/kernel/summit.c~silence-i386-boot arch/i386/kernel/summit.c
--- linux-2.6.7-xx4/arch/i386/kernel/summit.c~silence-i386-boot	2004-06-29 19:15:28.884152704 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/kernel/summit.c	2004-06-29 19:15:28.968139936 -0400
@@ -85,7 +85,11 @@ static int __init setup_pci_node_map_for
 		num_buses = 9;
 		break;
 	default:
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "%s: Unsupported Winnipeg type!\n", __FUNCTION__);
+#else
 		printk(KERN_INFO "%s: Unsupported Winnipeg type!\n", __FUNCTION__);
+#endif
 		return last_bus;
 	}
 
diff -puN arch/i386/kernel/time.c~silence-i386-boot arch/i386/kernel/time.c
--- linux-2.6.7-xx4/arch/i386/kernel/time.c~silence-i386-boot	2004-06-29 19:15:28.886152400 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/kernel/time.c	2004-06-29 19:15:28.970139632 -0400
@@ -362,10 +362,12 @@ void __init hpet_time_init(void)
 	xtime.tv_nsec = (INITIAL_JIFFIES % HZ) * (NSEC_PER_SEC / HZ);
 	wall_to_monotonic.tv_nsec = -xtime.tv_nsec;
 
-	if (hpet_enable() >= 0) {
+	if (hpet_enable() >= 0)
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "Using HPET for base-timer\n");
+#else
 		printk("Using HPET for base-timer\n");
-	}
-
+#endif
 	cur_timer = select_timer();
 	printk(KERN_INFO "Using %s for high-res timesource\n",cur_timer->name);
 
diff -puN arch/i386/mm/fault.c~silence-i386-boot arch/i386/mm/fault.c
--- linux-2.6.7-xx4/arch/i386/mm/fault.c~silence-i386-boot	2004-06-29 19:15:28.888152096 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/mm/fault.c	2004-06-29 19:15:28.971139480 -0400
@@ -490,7 +490,11 @@ out_of_memory:
 		down_read(&mm->mmap_sem);
 		goto survive;
 	}
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_WARNING "VM: killing process %s\n", tsk->comm);
+#else
 	printk("VM: killing process %s\n", tsk->comm);
+#endif
 	if (error_code & 4)
 		do_exit(SIGKILL);
 	goto no_context;
diff -puN arch/i386/mm/init.c~silence-i386-boot arch/i386/mm/init.c
--- linux-2.6.7-xx4/arch/i386/mm/init.c~silence-i386-boot	2004-06-29 19:15:28.890151792 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/mm/init.c	2004-06-29 19:15:28.972139328 -0400
@@ -522,8 +522,11 @@ void __init paging_init(void)
 
 void __init test_wp_bit(void)
 {
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "Checking if this processor honours the WP bit even in supervisor mode... ");
+#else
 	printk("Checking if this processor honours the WP bit even in supervisor mode... ");
-
+#endif
 	/* Any page-aligned address will do, the test is non-destructive */
 	__set_fixmap(FIX_WP_TEST, __pa(&swapper_pg_dir), PAGE_READONLY);
 	boot_cpu_data.wp_works_ok = do_test_wp_bit();
@@ -740,14 +743,22 @@ void free_initmem(void)
 		free_page(addr);
 		totalram_pages++;
 	}
+#ifdef CONFIG_SILENT_BOOT
+	printk (KERN_DEBUG "Freeing unused kernel memory: %dk freed\n", (__init_end - __init_begin) >> 10);
+#else
 	printk (KERN_INFO "Freeing unused kernel memory: %dk freed\n", (__init_end - __init_begin) >> 10);
+#endif
 }
 
 #ifdef CONFIG_BLK_DEV_INITRD
 void free_initrd_mem(unsigned long start, unsigned long end)
 {
 	if (start < end)
+#ifdef CONFIG_SILENT_BOOT
+		printk (KERN_DEBUG "Freeing initrd memory: %ldk freed\n", (end - start) >> 10);
+#else
 		printk (KERN_INFO "Freeing initrd memory: %ldk freed\n", (end - start) >> 10);
+#endif
 	for (; start < end; start += PAGE_SIZE) {
 		ClearPageReserved(virt_to_page(start));
 #ifdef CONFIG_SOFTWARE_SUSPEND2
diff -puN arch/i386/pci/acpi.c~silence-i386-boot arch/i386/pci/acpi.c
--- linux-2.6.7-xx4/arch/i386/pci/acpi.c~silence-i386-boot	2004-06-29 19:15:28.892151488 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/pci/acpi.c	2004-06-29 19:15:28.973139176 -0400
@@ -24,8 +24,11 @@ static int __init pci_acpi_init(void)
 
 	if (acpi_noirq)
 		return 0;
-
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "PCI: Using ACPI for IRQ routing\n");
+#else
 	printk(KERN_INFO "PCI: Using ACPI for IRQ routing\n");
+#endif
 	acpi_irq_penalty_init();
 	pcibios_scanned++;
 	pcibios_enable_irq = acpi_pci_irq_enable;
diff -puN arch/i386/pci/direct.c~silence-i386-boot arch/i386/pci/direct.c
--- linux-2.6.7-xx4/arch/i386/pci/direct.c~silence-i386-boot	2004-06-29 19:15:28.894151184 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/pci/direct.c	2004-06-29 19:15:28.974139024 -0400
@@ -252,7 +252,11 @@ static int __init pci_direct_init(void)
 		goto type2;
 
 	if (pci_check_type1()) {
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "PCI: Using configuration type 1\n");
+#else
 		printk(KERN_INFO "PCI: Using configuration type 1\n");
+#endif
 		raw_pci_ops = &pci_direct_conf1;
 		return 0;
 	}
@@ -269,7 +273,11 @@ static int __init pci_direct_init(void)
 		goto fail2;
 
 	if (pci_check_type2()) {
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "PCI: Using configuration type 2\n");
+#else
 		printk(KERN_INFO "PCI: Using configuration type 2\n");
+#endif
 		raw_pci_ops = &pci_direct_conf2;
 		return 0;
 	}
diff -puN arch/i386/pci/fixup.c~silence-i386-boot arch/i386/pci/fixup.c
--- linux-2.6.7-xx4/arch/i386/pci/fixup.c~silence-i386-boot	2004-06-29 19:15:28.896150880 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/pci/fixup.c	2004-06-29 19:15:28.977138568 -0400
@@ -38,7 +38,11 @@ static void __devinit pci_fixup_i450gx(s
 	 */
 	u8 busno;
 	pci_read_config_byte(d, 0x4a, &busno);
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "PCI: i440KX/GX host bridge %s: secondary bus %02x\n", pci_name(d), busno);
+#else
 	printk(KERN_INFO "PCI: i440KX/GX host bridge %s: secondary bus %02x\n", pci_name(d), busno);
+#endif
 	pci_scan_bus(busno, &pci_root_ops, NULL);
 	pcibios_last_bus = -1;
 }
diff -puN arch/i386/pci/irq.c~silence-i386-boot arch/i386/pci/irq.c
--- linux-2.6.7-xx4/arch/i386/pci/irq.c~silence-i386-boot	2004-06-29 19:15:28.898150576 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/pci/irq.c	2004-06-29 19:15:28.980138112 -0400
@@ -114,7 +114,11 @@ static void __init pirq_peer_trick(void)
 		if (!busmap[i] || pci_find_bus(0, i))
 			continue;
 		if (pci_scan_bus(i, &pci_root_ops, NULL))
+#ifdef CONFIG_SILENT_BOOT
+			printk(KERN_DEBUG "PCI: Discovered primary peer bus %02x [IRQ]\n", i);
+#else
 			printk(KERN_INFO "PCI: Discovered primary peer bus %02x [IRQ]\n", i);
+#endif
 	}
 	pcibios_last_bus = -1;
 }
@@ -369,7 +373,11 @@ static int pirq_sis_set(struct pci_dev *
 static int pirq_vlsi_get(struct pci_dev *router, struct pci_dev *dev, int pirq)
 {
 	if (pirq > 8) {
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "VLSI router pirq escape (%d)\n", pirq);
+#else
 		printk(KERN_INFO "VLSI router pirq escape (%d)\n", pirq);
+#endif
 		return 0;
 	}
 	return read_config_nybble(router, 0x74, pirq-1);
@@ -378,7 +386,11 @@ static int pirq_vlsi_get(struct pci_dev 
 static int pirq_vlsi_set(struct pci_dev *router, struct pci_dev *dev, int pirq, int irq)
 {
 	if (pirq > 8) {
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "VLSI router pirq escape (%d)\n", pirq);
+#else
 		printk(KERN_INFO "VLSI router pirq escape (%d)\n", pirq);
+#endif
 		return 0;
 	}
 	write_config_nybble(router, 0x74, pirq-1, irq);
@@ -425,14 +437,22 @@ static int pirq_amd756_get(struct pci_de
 	{
 		irq = read_config_nybble(router, 0x56, pirq - 1);
 	}
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "AMD756: dev %04x:%04x, router pirq : %d get irq : %2d\n",
+#else
 	printk(KERN_INFO "AMD756: dev %04x:%04x, router pirq : %d get irq : %2d\n",
+#endif
 		dev->vendor, dev->device, pirq, irq);
 	return irq;
 }
 
 static int pirq_amd756_set(struct pci_dev *router, struct pci_dev *dev, int pirq, int irq)
 {
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "AMD756: dev %04x:%04x, router pirq : %d SET irq : %2d\n",
+#else
 	printk(KERN_INFO "AMD756: dev %04x:%04x, router pirq : %d SET irq : %2d\n", 
+#endif
 		dev->vendor, dev->device, pirq, irq);
 	if (pirq <= 4)
 	{
@@ -591,7 +611,11 @@ static __init int ali_router_probe(struc
 	{
 	case PCI_DEVICE_ID_AL_M1533:
 	case PCI_DEVICE_ID_AL_M1563:
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "PCI: Using ALI IRQ Router\n");
+#else
 		printk("PCI: Using ALI IRQ Router\n");
+#endif
 			r->name = "ALI";
 			r->get = pirq_ali_get;
 			r->set = pirq_ali_set;
@@ -651,7 +675,11 @@ static void __init pirq_find_router(stru
 
 #ifdef CONFIG_PCI_BIOS
 	if (!rt->signature) {
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "PCI: Using BIOS for IRQ routing\n");
+#else
 		printk(KERN_INFO "PCI: Using BIOS for IRQ routing\n");
+#endif
 		r->set = pirq_bios_set;
 		r->name = "BIOS";
 		return;
@@ -680,7 +708,11 @@ static void __init pirq_find_router(stru
 		if (pirq_router_dev->vendor == h->vendor && h->probe(r, pirq_router_dev, pirq_router_dev->device))
 			break;
 	}
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "PCI: Using IRQ router %s [%04x/%04x] at %s\n",
+#else
 	printk(KERN_INFO "PCI: Using IRQ router %s [%04x/%04x] at %s\n",
+#endif
 		pirq_router.name,
 		pirq_router_dev->vendor,
 		pirq_router_dev->device,
@@ -801,8 +833,11 @@ static int pcibios_lookup_irq(struct pci
 		} else
 			return 0;
 	}
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "PCI: %s IRQ %d for device %s\n", msg, irq, pci_name(dev));
+#else
 	printk(KERN_INFO "PCI: %s IRQ %d for device %s\n", msg, irq, pci_name(dev));
-
+#endif
 	/* Update IRQ for all devices with the same pirq value */
 	while ((dev2 = pci_find_device(PCI_ANY_ID, PCI_ANY_ID, dev2)) != NULL) {
 		pci_read_config_byte(dev2, PCI_INTERRUPT_PIN, &pin);
@@ -818,7 +853,11 @@ static int pcibios_lookup_irq(struct pci
 			(!(pci_probe & PCI_USE_PIRQ_MASK) || \
 			((1 << dev2->irq) & mask)) ) {
 #ifndef CONFIG_PCI_USE_VECTOR
+#ifdef CONFIG_SILENT_BOOT
+		    		printk(KERN_DEBUG "IRQ routing conflict for %s, have irq %d, want irq %d\n",
+#else
 		    		printk(KERN_INFO "IRQ routing conflict for %s, have irq %d, want irq %d\n",
+#endif
 				       pci_name(dev2), dev2->irq, irq);
 #endif
 		    		continue;
@@ -826,7 +865,11 @@ static int pcibios_lookup_irq(struct pci
 			dev2->irq = irq;
 			pirq_penalty[irq]++;
 			if (dev != dev2)
+#ifdef CONFIG_SILENT_BOOT
+				printk(KERN_DEBUG "PCI: Sharing IRQ %d with %s\n", irq, pci_name(dev2));
+#else
 				printk(KERN_INFO "PCI: Sharing IRQ %d with %s\n", irq, pci_name(dev2));
+#endif
 		}
 	}
 	return 1;
@@ -887,8 +930,11 @@ static void __init pcibios_fixup_irqs(vo
 					if (use_pci_vector() &&
 						!platform_legacy_irq(irq))
 						irq = IO_APIC_VECTOR(irq);
-
+#ifdef CONFIG_SILENT_BOOT
+					printk(KERN_DEBUG "PCI->APIC IRQ transform: (B%d,I%d,P%d) -> %d\n",
+#else
 					printk(KERN_INFO "PCI->APIC IRQ transform: (B%d,I%d,P%d) -> %d\n",
+#endif
 						dev->bus->number, PCI_SLOT(dev->devfn), pin, irq);
 					dev->irq = irq;
 				}
@@ -1038,7 +1084,11 @@ int pirq_enable_irq(struct pci_dev *dev)
 					if (!platform_legacy_irq(irq))
 						irq = IO_APIC_VECTOR(irq);
 #endif
+#ifdef CONFIG_SILENT_BOOT
+					printk(KERN_DEBUG "PCI->APIC IRQ transform: (B%d,I%d,P%d) -> %d\n",
+#else
 					printk(KERN_INFO "PCI->APIC IRQ transform: (B%d,I%d,P%d) -> %d\n",
+#endif
 						dev->bus->number, PCI_SLOT(dev->devfn), pin, irq);
 					dev->irq = irq;
 					return 0;
diff -puN arch/i386/pci/legacy.c~silence-i386-boot arch/i386/pci/legacy.c
--- linux-2.6.7-xx4/arch/i386/pci/legacy.c~silence-i386-boot	2004-06-29 19:15:28.899150424 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/pci/legacy.c	2004-06-29 19:15:28.982137808 -0400
@@ -25,7 +25,11 @@ static void __devinit pcibios_fixup_peer
 			if (!raw_pci_ops->read(0, n, devfn, PCI_VENDOR_ID, 2, &l) &&
 			    l != 0x0000 && l != 0xffff) {
 				DBG("Found device at %02x:%02x [%04x]\n", n, devfn, l);
+#ifdef CONFIG_SILENT_BOOT
+				printk(KERN_DEBUG "PCI: Discovered peer bus %02x\n", n);
+#else
 				printk(KERN_INFO "PCI: Discovered peer bus %02x\n", n);
+#endif
 				pci_scan_bus(n, &pci_root_ops, NULL);
 				break;
 			}
@@ -36,14 +40,19 @@ static void __devinit pcibios_fixup_peer
 static int __init pci_legacy_init(void)
 {
 	if (!raw_pci_ops) {
+#ifndef CONFIG_SILENT_BOOT
 		printk("PCI: System does not support PCI\n");
+#endif
 		return 0;
 	}
 
 	if (pcibios_scanned++)
 		return 0;
-
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "PCI: Probing PCI hardware\n");
+#else
 	printk("PCI: Probing PCI hardware\n");
+#endif
 	pci_root_bus = pcibios_scan_root(0);
 
 	pcibios_fixup_peer_bridges();
diff -puN arch/i386/pci/mmconfig.c~silence-i386-boot arch/i386/pci/mmconfig.c
--- linux-2.6.7-xx4/arch/i386/pci/mmconfig.c~silence-i386-boot	2004-06-29 19:15:28.901150120 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/pci/mmconfig.c	2004-06-29 19:15:28.982137808 -0400
@@ -97,8 +97,11 @@ static int __init pci_mmcfg_init(void)
 		goto out;
 	if (!pci_mmcfg_base_addr)
 		goto out;
-
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "PCI: Using MMCONFIG\n");
+#else
 	printk(KERN_INFO "PCI: Using MMCONFIG\n");
+#endif
 	raw_pci_ops = &pci_mmcfg;
 	pci_probe = (pci_probe & ~PCI_PROBE_MASK) | PCI_PROBE_MMCONF;
 
diff -puN arch/i386/pci/pcbios.c~silence-i386-boot arch/i386/pci/pcbios.c
--- linux-2.6.7-xx4/arch/i386/pci/pcbios.c~silence-i386-boot	2004-06-29 19:15:28.903149816 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/pci/pcbios.c	2004-06-29 19:15:28.984137504 -0400
@@ -448,7 +448,11 @@ struct irq_routing_table * __devinit pci
 			rt->size = opt.size + sizeof(struct irq_routing_table);
 			rt->exclusive_irqs = map;
 			memcpy(rt->slots, (void *) page, opt.size);
+#ifdef CONFIG_SILENT_BOOT
+			printk(KERN_DEBUG "PCI: Using BIOS Interrupt Routing Table\n");
+#else
 			printk(KERN_INFO "PCI: Using BIOS Interrupt Routing Table\n");
+#endif
 		}
 	}
 	free_page(page);
diff -puN arch/i386/pci/visws.c~silence-i386-boot arch/i386/pci/visws.c
--- linux-2.6.7-xx4/arch/i386/pci/visws.c~silence-i386-boot	2004-06-29 19:15:28.905149512 -0400
+++ linux-2.6.7-xx4-xiphux/arch/i386/pci/visws.c	2004-06-29 19:15:28.985137352 -0400
@@ -95,8 +95,11 @@ static int __init pcibios_init(void)
 
 	pci_bus0 = li_pcib_read16(LI_PCI_BUSNUM) & 0xff;
 	pci_bus1 = li_pcia_read16(LI_PCI_BUSNUM) & 0xff;
-
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "PCI: Lithium bridge A bus: %u, "
+#else
 	printk(KERN_INFO "PCI: Lithium bridge A bus: %u, "
+#endif
 		"bridge B (PIIX4) bus: %u\n", pci_bus1, pci_bus0);
 
 	raw_pci_ops = &pci_direct_conf1;
diff -puN include/asm-i386/bugs.h~silence-i386-boot include/asm-i386/bugs.h
--- linux-2.6.7-xx4/include/asm-i386/bugs.h~silence-i386-boot	2004-06-29 19:15:28.907149208 -0400
+++ linux-2.6.7-xx4-xiphux/include/asm-i386/bugs.h	2004-06-29 19:15:28.987137048 -0400
@@ -98,12 +98,20 @@ static void __init check_fpu(void)
 		__buggy_fxsr_alignment();
 	}
 	if (cpu_has_fxsr) {
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "Enabling fast FPU save and restore... ");
+#else
 		printk(KERN_INFO "Enabling fast FPU save and restore... ");
+#endif
 		set_in_cr4(X86_CR4_OSFXSR);
 		printk("done.\n");
 	}
 	if (cpu_has_xmm) {
+#ifdef CONFIG_SILENT_BOOT
+		printk(KERN_DEBUG "Enabling unmasked SIMD FPU exception support... ");
+#else
 		printk(KERN_INFO "Enabling unmasked SIMD FPU exception support... ");
+#endif
 		set_in_cr4(X86_CR4_OSXMMEXCPT);
 		printk("done.\n");
 	}
@@ -126,7 +134,11 @@ static void __init check_fpu(void)
 
 static void __init check_hlt(void)
 {
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "Checking 'hlt' instruction... ");
+#else
 	printk(KERN_INFO "Checking 'hlt' instruction... ");
+#endif
 	if (!boot_cpu_data.hlt_works_ok) {
 		printk("disabled\n");
 		return;
@@ -144,8 +156,11 @@ static void __init check_popad(void)
 {
 #ifndef CONFIG_X86_POPAD_OK
 	int res, inp = (int) &res;
-
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_DEBUG "Checking for popad bug... ");
+#else
 	printk(KERN_INFO "Checking for popad bug... ");
+#endif
 	__asm__ __volatile__( 
 	  "movl $12345678,%%eax; movl $0,%%edi; pusha; popa; movl (%%edx,%%edi),%%ecx "
 	  : "=&a" (res)
@@ -214,7 +229,11 @@ static void __init check_bugs(void)
 {
 	identify_cpu(&boot_cpu_data);
 #ifndef CONFIG_SMP
+#ifdef CONFIG_SILENT_BOOT
+	printk(KERN_INFO "CPU: ");
+#else
 	printk("CPU: ");
+#endif
 	print_cpu_info(&boot_cpu_data);
 #endif
 	check_config();
diff -puN kernel/Kconfig-extra.xx~silence-i386-boot kernel/Kconfig-extra.xx
--- linux-2.6.7-xx4/kernel/Kconfig-extra.xx~silence-i386-boot	2004-06-29 19:15:28.909148904 -0400
+++ linux-2.6.7-xx4-xiphux/kernel/Kconfig-extra.xx	2004-06-29 19:15:28.988136896 -0400
@@ -260,4 +260,15 @@ config LOW_LATENCY
 
 endchoice
 
+config SILENT_BOOT
+	bool "Silent boot"
+	default n
+	help
+	  This will hide many of the boot messages to make the system
+	  startup look cleaner with less junk.  Note that even if you
+	  choose to hide these messages, you can still view them by
+	  booting the kernel in debug mode.
+
+	  If unsure, say N.
+
 endmenu

_
