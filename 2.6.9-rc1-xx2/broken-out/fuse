Index: xx-sources/fs/Kconfig
===================================================================
--- xx-sources.orig/fs/Kconfig	2004-08-24 20:33:52.798221776 -0400
+++ xx-sources/fs/Kconfig	2004-08-24 20:35:30.338393416 -0400
@@ -1493,6 +1493,16 @@
 
 	  Say Y here if you want to get access to a bunch of useful file
 	  systens: sshfs, ftpfs, gnutellafs, gvfs, cardfs, cefs, etc.
+
+config FUSE_FS
+	tristate "FUSE file system support (EXPERIMENTAL)"
+	depends on EXPERIMENTAL
+	help
+	  FUSE (Filesystem in USErspace) is a simple interface for userspace
+	  programs to export a virtual filesystem to the linux kernel.  FUSE
+	  also aims to provide a secure method for non privileged users to
+	  create and mount their own filesystem implementations.
+
 endmenu
 
 menu "Network File Systems"
Index: xx-sources/fs/Makefile
===================================================================
--- xx-sources.orig/fs/Makefile	2004-08-24 20:33:52.796222080 -0400
+++ xx-sources/fs/Makefile	2004-08-24 20:35:30.339393264 -0400
@@ -105,3 +105,4 @@
 obj-$(CONFIG_SUBFS)		+= subfs.o
 obj-$(CONFIG_LOCK_HARNESS)	+= gfs_locking/
 obj-$(CONFIG_GFS_FS)		+= gfs/
+obj-$(CONFIG_FUSE_FS)		+= fuse/
Index: xx-sources/fs/fuse/Makefile
===================================================================
--- xx-sources.orig/fs/fuse/Makefile	2004-05-31 17:36:38.000000000 -0400
+++ xx-sources/fs/fuse/Makefile	2004-08-24 20:35:30.340393112 -0400
@@ -0,0 +1,3 @@
+obj-$(CONFIG_FUSE_FS) += fuse.o
+
+fuse-objs := dev.o dir.o file.o inode.o util.o
Index: xx-sources/fs/fuse/dev.c
===================================================================
--- xx-sources.orig/fs/fuse/dev.c	2004-05-31 17:36:38.000000000 -0400
+++ xx-sources/fs/fuse/dev.c	2004-08-24 20:35:30.342392808 -0400
@@ -0,0 +1,666 @@
+/*
+    FUSE: Filesystem in Userspace
+    Copyright (C) 2001-2004  Miklos Szeredi <miklos@szeredi.hu>
+
+    This program can be distributed under the terms of the GNU GPL.
+    See the file COPYING.
+*/
+
+#include "fuse_i.h"
+
+#include <linux/poll.h>
+#include <linux/proc_fs.h>
+#include <linux/file.h>
+
+/* If more requests are outstanding, then the operation will block */
+#define MAX_OUTSTANDING 10
+
+static struct proc_dir_entry *proc_fs_fuse;
+struct proc_dir_entry *proc_fuse_dev;
+static kmem_cache_t *fuse_req_cachep;
+
+static struct fuse_req *request_new(void)
+{
+	struct fuse_req *req;
+
+	req = (struct fuse_req *) kmem_cache_alloc(fuse_req_cachep, SLAB_NOFS);
+	if(req) {
+		INIT_LIST_HEAD(&req->list);
+		req->issync = 0;
+		req->locked = 0;
+		req->interrupted = 0;
+		req->sent = 0;
+		req->finished = 0;
+		req->in = NULL;
+		req->out = NULL;
+		init_waitqueue_head(&req->waitq);
+	}
+
+	return req;
+}
+
+static void request_free(struct fuse_req *req)
+{
+	kmem_cache_free(fuse_req_cachep, req);
+}
+
+static int request_restartable(enum fuse_opcode opcode)
+{
+	switch(opcode) {
+	case FUSE_LOOKUP:
+	case FUSE_GETATTR:
+	case FUSE_READLINK:
+	case FUSE_GETDIR:
+	case FUSE_OPEN:
+	case FUSE_READ:
+	case FUSE_WRITE:
+		return 1;
+
+	default:
+		return 0;
+	}
+}
+
+/* Called with fuse_lock held.  Releases, and then reaquires it. */
+static void request_wait_answer(struct fuse_req *req)
+{
+	int intr;
+	
+	spin_unlock(&fuse_lock);
+	intr = wait_event_interruptible(req->waitq, req->finished);
+	spin_lock(&fuse_lock);
+	if(!intr)
+		return;
+
+	/* Request interrupted... Wait for it to be unlocked */
+	if(req->locked) {
+		req->interrupted = 1;
+		spin_unlock(&fuse_lock);
+		wait_event(req->waitq, !req->locked);
+		spin_lock(&fuse_lock);
+	}
+	
+	/* Operations which modify the filesystem cannot safely be
+	   restarted, because it is uncertain whether the operation has
+	   completed or not... */
+	if(req->sent && !request_restartable(req->in->h.opcode))
+		req->out->h.error = -EINTR;
+	else
+		req->out->h.error = -ERESTARTSYS;
+}
+
+static int get_unique(struct fuse_conn *fc)
+{
+	do fc->reqctr++;
+	while(!fc->reqctr);
+	return fc->reqctr;
+}
+
+/* Must be called with fuse_lock held, and unlocks it */
+static void request_end(struct fuse_conn *fc, struct fuse_req *req)
+{
+	fuse_reqend_t endfunc = req->end;
+
+	if(!endfunc) {
+		wake_up(&req->waitq);
+		spin_unlock(&fuse_lock);
+	} else {
+		spin_unlock(&fuse_lock);
+		endfunc(fc, req->in, req->out, req->data);
+		request_free(req);
+		up(&fc->outstanding);
+	}
+}
+
+void request_send(struct fuse_conn *fc, struct fuse_in *in,
+		  struct fuse_out *out)
+{
+	struct fuse_req *req;
+
+	out->h.error = -ERESTARTSYS;
+	if(down_interruptible(&fc->outstanding))
+		return;
+
+	out->h.error = -ENOMEM;
+	req = request_new();
+	if(req) {
+		req->in = in;
+		req->out = out;
+		req->issync = 1;
+		req->end = NULL;
+		
+		spin_lock(&fuse_lock);
+		out->h.error = -ENOTCONN;
+		if(fc->file) {
+			in->h.unique = get_unique(fc);		
+			list_add_tail(&req->list, &fc->pending);
+			wake_up(&fc->waitq);
+			request_wait_answer(req);
+			list_del(&req->list);
+		}
+		spin_unlock(&fuse_lock);
+		request_free(req);
+	}
+
+	up(&fc->outstanding);
+}
+
+
+static inline void destroy_request(struct fuse_req *req)
+{
+	if(req) {
+		kfree(req->in);
+		request_free(req);
+	}
+}
+
+/* This one is currently only used for sending FORGET and RELEASE,
+   which are kernel initiated request.  So the outstanding semaphore
+   is not used.  */
+int request_send_noreply(struct fuse_conn *fc, struct fuse_in *in)
+{
+	struct fuse_req *req;
+
+	req = request_new();
+	if(!req)
+		return -ENOMEM;
+
+	req->in = in;
+	req->issync = 0;
+
+	spin_lock(&fuse_lock);
+	if(!fc->file) {
+		spin_unlock(&fuse_lock);
+		request_free(req);
+		return -ENOTCONN;
+	}
+
+	list_add_tail(&req->list, &fc->pending);
+	wake_up(&fc->waitq);
+	spin_unlock(&fuse_lock);
+	return 0;
+}
+
+int request_send_nonblock(struct fuse_conn *fc, struct fuse_in *in,
+			  struct fuse_out *out, fuse_reqend_t end, void *data)
+{
+	int err;
+	struct fuse_req *req;
+
+	BUG_ON(!end);
+
+	if(down_trylock(&fc->outstanding))
+		return -EWOULDBLOCK;
+
+	err = -ENOMEM;
+	req = request_new();
+	if(req) {
+		req->in = in;
+		req->out = out;
+		req->issync = 1;
+		req->end = end;
+		req->data = data;
+
+		spin_lock(&fuse_lock);
+		err = -ENOTCONN;
+		if(fc->file) {
+			in->h.unique = get_unique(fc);		
+			list_add_tail(&req->list, &fc->pending);
+			wake_up(&fc->waitq);
+			spin_unlock(&fuse_lock);
+			return 0;
+		}
+		spin_unlock(&fuse_lock);
+		request_free(req);
+	}
+	up(&fc->outstanding);
+	return err;
+}
+
+static void request_wait(struct fuse_conn *fc)
+{
+	DECLARE_WAITQUEUE(wait, current);
+
+	add_wait_queue_exclusive(&fc->waitq, &wait);
+	while(fc->sb != NULL && list_empty(&fc->pending)) {
+		set_current_state(TASK_INTERRUPTIBLE);
+		if(signal_pending(current))
+			break;
+
+		spin_unlock(&fuse_lock);
+		schedule();
+		spin_lock(&fuse_lock);
+	}
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&fc->waitq, &wait);
+}
+
+static inline int copy_in_one(const void *src, size_t srclen, char **dstp,
+			      size_t *dstlenp)
+{
+	if(*dstlenp < srclen) {
+		printk("fuse_dev_read: buffer too small\n");
+		return -EINVAL;
+	}
+			
+	if(copy_to_user(*dstp, src, srclen))
+		return -EFAULT;
+
+	*dstp += srclen;
+	*dstlenp -= srclen;
+
+	return 0;
+}
+
+static inline int copy_in_args(struct fuse_in *in, char *buf, size_t nbytes)
+{
+	int err;
+	int i;
+	size_t orignbytes = nbytes;
+		
+	err = copy_in_one(&in->h, sizeof(in->h), &buf, &nbytes);
+	if(err)
+		return err;
+
+	for(i = 0; i < in->numargs; i++) {
+		struct fuse_in_arg *arg = &in->args[i];
+		err = copy_in_one(arg->value, arg->size, &buf, &nbytes);
+		if(err)
+			return err;
+	}
+
+	return orignbytes - nbytes;
+}
+
+static ssize_t fuse_dev_read(struct file *file, char *buf, size_t nbytes,
+			     loff_t *off)
+{
+	ssize_t ret;
+	struct fuse_conn *fc = DEV_FC(file);
+	struct fuse_req *req = NULL;
+
+	spin_lock(&fuse_lock);
+	request_wait(fc);
+	if(fc->sb != NULL && !list_empty(&fc->pending)) {
+		req = list_entry(fc->pending.next, struct fuse_req, list);
+		list_del_init(&req->list);
+		req->locked = 1;
+	}
+	spin_unlock(&fuse_lock);
+	if(fc->sb == NULL)
+		return -ENODEV;
+	if(req == NULL)
+		return -EINTR;
+
+	ret = copy_in_args(req->in, buf, nbytes);
+	spin_lock(&fuse_lock);
+	if(req->issync) {
+		if(ret < 0) {
+			req->out->h.error = -EPROTO;
+			req->finished = 1;
+		} else {
+			list_add_tail(&req->list, &fc->processing);
+			req->sent = 1;
+		}
+		req->locked = 0;
+		if(ret < 0 || req->interrupted)
+			/* Unlocks fuse_lock: */
+			request_end(fc, req);
+		else
+			spin_unlock(&fuse_lock);
+	} else {
+		spin_unlock(&fuse_lock);
+		destroy_request(req);
+	}
+	return ret;
+}
+
+static struct fuse_req *request_find(struct fuse_conn *fc, unsigned int unique)
+{
+	struct list_head *entry;
+	struct fuse_req *req = NULL;
+
+	list_for_each(entry, &fc->processing) {
+		struct fuse_req *tmp;
+		tmp = list_entry(entry, struct fuse_req, list);
+		if(tmp->in->h.unique == unique) {
+			req = tmp;
+			break;
+		}
+	}
+
+	return req;
+}
+
+static void process_getdir(struct fuse_req *req)
+{
+	struct fuse_getdir_out *arg;
+	arg = (struct fuse_getdir_out *) req->out->args[0].value;
+	arg->file = fget(arg->fd);
+}
+
+static inline int copy_out_one(struct fuse_out_arg *arg, const char **srcp,
+			       size_t *srclenp, int allowvar)
+{
+	size_t dstlen = arg->size;
+	if(*srclenp < dstlen) {
+		if(!allowvar) {
+			printk("fuse_dev_write: write is short\n");
+			return -EINVAL;
+		}
+		dstlen = *srclenp;
+	}
+
+	if(dstlen) {
+		if(copy_from_user(arg->value, *srcp, dstlen))
+			return -EFAULT;
+	}
+
+	*srcp += dstlen;
+	*srclenp -= dstlen;
+	arg->size = dstlen;
+
+	return 0;
+}
+
+static inline int copy_out_args(struct fuse_out *out, const char *buf,
+				size_t nbytes)
+{
+	int err;
+	int i;
+
+	buf += sizeof(struct fuse_out_header);
+	nbytes -= sizeof(struct fuse_out_header);
+		
+	if(!out->h.error) {
+		for(i = 0; i < out->numargs; i++) {
+			struct fuse_out_arg *arg = &out->args[i];
+			int allowvar;
+
+			if(out->argvar && i == out->numargs - 1)
+				allowvar = 1;
+			else
+				allowvar = 0;
+
+			err = copy_out_one(arg, &buf, &nbytes, allowvar);
+			if(err)
+				return err;
+		}
+	}
+
+	if(nbytes != 0) {
+		printk("fuse_dev_write: write is long\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static inline int copy_out_header(struct fuse_out_header *oh, const char *buf,
+				  size_t nbytes)
+{
+	if(nbytes < sizeof(struct fuse_out_header)) {
+		printk("fuse_dev_write: write is short\n");
+		return -EINVAL;
+	}
+	
+	if(copy_from_user(oh, buf, sizeof(struct fuse_out_header)))
+		return -EFAULT;
+
+	return 0;
+}
+
+#ifdef KERNEL_2_6
+static int fuse_invalidate(struct fuse_conn *fc, struct fuse_user_header *uh)
+{
+	struct inode *inode = ilookup(fc->sb, uh->ino);
+	if (!inode)
+		return -ENOENT;
+	invalidate_inode_pages(inode->i_mapping);
+	iput(inode);
+	return 0;
+}
+#else 
+static int fuse_invalidate(struct fuse_conn *fc, struct fuse_user_header *uh)
+{
+	struct inode *inode = iget(fc->sb, uh->ino);
+	int err = -ENOENT;
+	if(inode) {
+		if(inode->u.generic_ip) {
+			invalidate_inode_pages(inode);
+			err = 0;
+		}
+		iput(inode);
+	}
+	return err;
+}
+#endif
+
+static int fuse_user_request(struct fuse_conn *fc, const char *buf,
+			     size_t nbytes)
+{
+	struct fuse_user_header uh;
+	int err;
+
+	if (nbytes < sizeof(struct fuse_user_header)) {
+		printk("fuse_dev_write: write is short\n");
+		return -EINVAL;
+	}
+
+	if(copy_from_user(&uh, buf, sizeof(struct fuse_out_header)))
+		return -EFAULT;
+	
+	switch(uh.opcode) {
+	case FUSE_INVALIDATE:
+		err = fuse_invalidate(fc, &uh);
+		break;
+
+	default:
+		err = -ENOSYS;
+	}
+	return err;
+}
+    
+
+static ssize_t fuse_dev_write(struct file *file, const char *buf,
+			      size_t nbytes, loff_t *off)
+{
+	int err;
+	struct fuse_conn *fc = DEV_FC(file);
+	struct fuse_req *req;
+	struct fuse_out_header oh;
+
+	if(!fc->sb)
+		return -EPERM;
+
+	err = copy_out_header(&oh, buf, nbytes);
+	if(err)
+		return err;
+
+	if (!oh.unique)	{
+		err = fuse_user_request(fc, buf, nbytes);
+		goto out;
+	}     
+
+        if (oh.error <= -512 || oh.error > 0) {
+                printk("fuse_dev_write: bad error value\n");
+                return -EINVAL;
+        }
+
+	spin_lock(&fuse_lock);
+	req = request_find(fc, oh.unique);
+	if(req != NULL) {
+		list_del_init(&req->list);
+		req->locked = 1;
+	}
+	spin_unlock(&fuse_lock);
+	if(!req)
+		return -ENOENT;
+
+	req->out->h = oh;
+	err = copy_out_args(req->out, buf, nbytes);
+
+	spin_lock(&fuse_lock);
+	if(err)
+		req->out->h.error = -EPROTO;
+	else {
+		/* fget() needs to be done in this context */
+		if(req->in->h.opcode == FUSE_GETDIR && !oh.error)
+			process_getdir(req);
+	}	
+	req->finished = 1;
+	req->locked = 0;
+	/* Unlocks fuse_lock: */
+	request_end(fc, req);
+
+  out:
+	if(!err)
+		return nbytes;
+	else
+		return err;
+}
+
+
+static unsigned int fuse_dev_poll(struct file *file, poll_table *wait)
+{
+	struct fuse_conn *fc = DEV_FC(file);
+	unsigned int mask = POLLOUT | POLLWRNORM;
+
+	if(!fc->sb)
+		return -EPERM;
+
+	poll_wait(file, &fc->waitq, wait);
+
+	spin_lock(&fuse_lock);
+	if (!list_empty(&fc->pending))
+                mask |= POLLIN | POLLRDNORM;
+	spin_unlock(&fuse_lock);
+
+	return mask;
+}
+
+static struct fuse_conn *new_conn(void)
+{
+	struct fuse_conn *fc;
+
+	fc = kmalloc(sizeof(*fc), GFP_KERNEL);
+	if(fc != NULL) {
+		fc->sb = NULL;
+		fc->file = NULL;
+		fc->flags = 0;
+		fc->uid = 0;
+		fc->oldrelease = 0;
+		init_waitqueue_head(&fc->waitq);
+		INIT_LIST_HEAD(&fc->pending);
+		INIT_LIST_HEAD(&fc->processing);
+		sema_init(&fc->outstanding, MAX_OUTSTANDING);
+		fc->reqctr = 1;
+	}
+	return fc;
+}
+
+static int fuse_dev_open(struct inode *inode, struct file *file)
+{
+	struct fuse_conn *fc;
+
+	fc = new_conn();
+	if(!fc)
+		return -ENOMEM;
+
+	fc->file = file;
+	file->private_data = fc;
+
+	return 0;
+}
+
+static void end_requests(struct fuse_conn *fc, struct list_head *head)
+{
+	while(!list_empty(head)) {
+		struct fuse_req *req;
+		req = list_entry(head->next, struct fuse_req, list);
+		list_del_init(&req->list);
+		if(req->issync) {
+			req->out->h.error = -ECONNABORTED;
+			req->finished = 1;
+			/* Unlocks fuse_lock: */
+			request_end(fc, req);
+			spin_lock(&fuse_lock);
+		} else
+			destroy_request(req);
+	}
+}
+
+static int fuse_dev_release(struct inode *inode, struct file *file)
+{
+	struct fuse_conn *fc = DEV_FC(file);
+
+	spin_lock(&fuse_lock);
+	fc->file = NULL;
+	end_requests(fc, &fc->pending);
+	end_requests(fc, &fc->processing);
+	fuse_release_conn(fc);
+	spin_unlock(&fuse_lock);
+	return 0;
+}
+
+static struct file_operations fuse_dev_operations = {
+	.owner		= THIS_MODULE,
+	.read		= fuse_dev_read,
+	.write		= fuse_dev_write,
+	.poll		= fuse_dev_poll,
+	.open		= fuse_dev_open,
+	.release	= fuse_dev_release,
+};
+
+int fuse_dev_init()
+{
+	int ret;
+
+	proc_fs_fuse = NULL;
+	proc_fuse_dev = NULL;
+
+	fuse_req_cachep = kmem_cache_create("fuser_request",
+					     sizeof(struct fuse_req),
+					     0, 0, NULL, NULL);
+	if(!fuse_req_cachep)
+		return -ENOMEM;
+
+	ret = -ENOMEM;
+	proc_fs_fuse = proc_mkdir("fuse", proc_root_fs);
+	if(!proc_fs_fuse) {
+		printk("fuse: failed to create directory in /proc/fs\n");
+		goto err;
+	}
+
+	proc_fs_fuse->owner = THIS_MODULE;
+	proc_fuse_dev = create_proc_entry("dev", S_IFSOCK | 0600, proc_fs_fuse);
+	if(!proc_fuse_dev) {
+		printk("fuse: failed to create entry in /proc/fs/fuse\n");
+		goto err;
+	}
+
+	proc_fuse_dev->proc_fops = &fuse_dev_operations;
+
+	return 0;
+
+  err:
+	fuse_dev_cleanup();
+	return ret;
+}
+
+void fuse_dev_cleanup()
+{
+	if(proc_fs_fuse) {
+		remove_proc_entry("dev", proc_fs_fuse);
+		remove_proc_entry("fuse", proc_root_fs);
+	}
+	
+	kmem_cache_destroy(fuse_req_cachep);
+}
+
+/* 
+ * Local Variables:
+ * indent-tabs-mode: t
+ * c-basic-offset: 8
+ * End:
+ */
Index: xx-sources/fs/fuse/dir.c
===================================================================
--- xx-sources.orig/fs/fuse/dir.c	2004-05-31 17:36:38.000000000 -0400
+++ xx-sources/fs/fuse/dir.c	2004-08-24 20:35:30.344392504 -0400
@@ -0,0 +1,827 @@
+/*
+    FUSE: Filesystem in Userspace
+    Copyright (C) 2001-2004  Miklos Szeredi <miklos@szeredi.hu>
+
+    This program can be distributed under the terms of the GNU GPL.
+    See the file COPYING.
+*/
+
+#include "fuse_i.h"
+
+#include <linux/pagemap.h>
+#include <linux/slab.h>
+#include <linux/file.h>
+
+static struct inode_operations fuse_dir_inode_operations;
+static struct inode_operations fuse_file_inode_operations;
+static struct inode_operations fuse_symlink_inode_operations;
+
+static struct file_operations fuse_dir_operations;
+
+static struct dentry_operations fuse_dentry_operations;
+
+/* FIXME: This should be user configurable */
+#define FUSE_REVALIDATE_TIME (1 * HZ)
+
+#ifndef KERNEL_2_6
+#define new_decode_dev(x) (x)
+#define new_encode_dev(x) (x)
+#endif
+
+static void change_attributes(struct inode *inode, struct fuse_attr *attr)
+{
+	if(S_ISREG(inode->i_mode) && i_size_read(inode) != attr->size) {
+#ifdef KERNEL_2_6
+		invalidate_inode_pages(inode->i_mapping);
+#else
+		invalidate_inode_pages(inode);
+#endif
+	}
+
+	inode->i_mode    = (inode->i_mode & S_IFMT) + (attr->mode & 07777);
+	inode->i_nlink   = attr->nlink;
+	inode->i_uid     = attr->uid;
+	inode->i_gid     = attr->gid;
+	i_size_write(inode, attr->size);
+	inode->i_blksize = PAGE_CACHE_SIZE;
+	inode->i_blocks  = attr->blocks;
+#ifdef KERNEL_2_6
+	inode->i_atime.tv_sec   = attr->atime;
+	inode->i_atime.tv_nsec  = 0;
+	inode->i_mtime.tv_sec   = attr->mtime;
+	inode->i_mtime.tv_nsec  = 0;
+	inode->i_ctime.tv_sec   = attr->ctime;
+	inode->i_ctime.tv_nsec  = 0;
+#else
+	inode->i_atime   = attr->atime;
+	inode->i_mtime   = attr->mtime;
+	inode->i_ctime   = attr->ctime;
+#endif
+}
+
+static void fuse_init_inode(struct inode *inode, struct fuse_attr *attr)
+{
+	inode->i_mode = attr->mode & S_IFMT;
+	i_size_write(inode, attr->size);
+	if(S_ISREG(inode->i_mode)) {
+		inode->i_op = &fuse_file_inode_operations;
+		fuse_init_file_inode(inode);
+	}
+	else if(S_ISDIR(inode->i_mode)) {
+		inode->i_op = &fuse_dir_inode_operations;
+		inode->i_fop = &fuse_dir_operations;
+	}
+	else if(S_ISLNK(inode->i_mode)) {
+		inode->i_op = &fuse_symlink_inode_operations;
+	}
+	else {
+		inode->i_op = &fuse_file_inode_operations;
+		init_special_inode(inode, inode->i_mode,
+				   new_decode_dev(attr->rdev));
+	}
+	inode->u.generic_ip = inode;
+}
+
+struct inode *fuse_iget(struct super_block *sb, ino_t ino,
+			struct fuse_attr *attr, int version)
+{
+	struct inode *inode;
+
+	inode = iget(sb, ino);
+	if(inode) {
+		if(!inode->u.generic_ip)
+			fuse_init_inode(inode, attr);
+
+		change_attributes(inode, attr);
+		inode->i_version = version;
+	}
+
+	return inode;
+}
+
+static int fuse_do_lookup(struct inode *dir, struct dentry *entry,
+			  struct fuse_lookup_out *outarg, int *version)
+{
+	struct fuse_conn *fc = INO_FC(dir);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+
+	if (entry->d_name.len > FUSE_NAME_MAX)
+		return -ENAMETOOLONG;
+
+	in.h.opcode = FUSE_LOOKUP;
+	in.h.ino = dir->i_ino;
+	in.numargs = 1;
+	in.args[0].size = entry->d_name.len + 1;
+	in.args[0].value = entry->d_name.name;
+	out.numargs = 1;
+	out.args[0].size = sizeof(struct fuse_lookup_out);
+	out.args[0].value = outarg;
+	request_send(fc, &in, &out);
+
+	*version = out.h.unique;
+	return out.h.error;
+}
+
+static int fuse_lookup_iget(struct inode *dir, struct dentry *entry,
+			    struct inode **inodep)
+{
+	int err;
+	struct fuse_lookup_out outarg;
+	int version;
+	struct inode *inode = NULL;
+
+	err = fuse_do_lookup(dir, entry, &outarg, &version);
+	if(!err) {
+		inode = fuse_iget(dir->i_sb, outarg.ino, &outarg.attr, version);
+		if(!inode)
+			return -ENOMEM;
+	} else if(err != -ENOENT)
+		return err;
+
+	entry->d_time = jiffies;
+	entry->d_op = &fuse_dentry_operations;
+	*inodep = inode;
+	return 0;
+}
+
+static void uncache_dir(struct inode *dir)
+{
+	struct dentry *entry = d_find_alias(dir);
+	if (!entry)
+		dir->i_nlink = 0;
+	else {
+		entry->d_time = jiffies - FUSE_REVALIDATE_TIME - 1;
+		dput(entry);
+	}
+}
+
+/* create needs to return a positive entry, so this is actually an
+   mknod+lookup */
+static int _fuse_mknod(struct inode *dir, struct dentry *entry, int mode,
+		      dev_t rdev)
+{
+	struct fuse_conn *fc = INO_FC(dir);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+	struct fuse_mknod_in inarg;
+	struct fuse_mknod_out outarg;
+	struct inode *inode;
+
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.mode = mode;
+	inarg.rdev = new_encode_dev(rdev);
+
+	in.h.opcode = FUSE_MKNOD;
+	in.h.ino = dir->i_ino;
+	in.numargs = 2;
+	in.args[0].size = sizeof(inarg);
+	in.args[0].value = &inarg;
+	in.args[1].size = entry->d_name.len + 1;
+	in.args[1].value = entry->d_name.name;
+	out.numargs = 1;
+	out.args[0].size = sizeof(outarg);
+	out.args[0].value = &outarg;
+	request_send(fc, &in, &out);
+
+	if(out.h.error) 
+		return out.h.error;
+
+	inode = fuse_iget(dir->i_sb, outarg.ino, &outarg.attr, out.h.unique);
+	if(!inode) 
+		return -ENOMEM;
+
+	/* Don't allow userspace to do really stupid things... */
+	if((inode->i_mode ^ mode) & S_IFMT) {
+		iput(inode);
+		printk("fuse_mknod: inode has wrong type\n");
+		return -EPROTO;
+	}
+
+	d_instantiate(entry, inode);
+	uncache_dir(dir);
+	return 0;
+}
+
+static int _fuse_create(struct inode *dir, struct dentry *entry, int mode)
+{
+	return _fuse_mknod(dir, entry, mode, 0);
+}
+
+/* knfsd needs the new entry instantiated in mkdir/symlink/link. this
+   should rather be done like mknod: attributes returned in out arg to
+   save a call to userspace */
+static int lookup_new_entry(struct inode *dir, struct dentry *entry)
+{
+	struct inode *inode;
+	int err = fuse_lookup_iget(dir, entry, &inode);
+	if(err || !inode) {
+		printk("fuse_mkdir: failed to look up new entry\n");
+		return err ? err : -ENOENT;
+	}
+	d_instantiate(entry, inode);
+	uncache_dir(dir);
+	return 0;
+}
+
+static int fuse_mkdir(struct inode *dir, struct dentry *entry, int mode)
+{
+	struct fuse_conn *fc = INO_FC(dir);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+	struct fuse_mkdir_in inarg;
+
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.mode = mode;
+
+	in.h.opcode = FUSE_MKDIR;
+	in.h.ino = dir->i_ino;
+	in.numargs = 2;
+	in.args[0].size = sizeof(inarg);
+	in.args[0].value = &inarg;
+	in.args[1].size = entry->d_name.len + 1;
+	in.args[1].value = entry->d_name.name;
+	request_send(fc, &in, &out);
+	if(out.h.error)
+		return out.h.error;
+
+	return lookup_new_entry(dir, entry);
+}
+
+static int fuse_symlink(struct inode *dir, struct dentry *entry,
+			const char *link)
+{
+	struct fuse_conn *fc = INO_FC(dir);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+	unsigned int len = strlen(link) + 1;
+	
+	if (len > FUSE_SYMLINK_MAX)
+		return -ENAMETOOLONG;
+
+	in.h.opcode = FUSE_SYMLINK;
+	in.h.ino = dir->i_ino;
+	in.numargs = 2;
+	in.args[0].size = entry->d_name.len + 1;
+	in.args[0].value = entry->d_name.name;
+	in.args[1].size = len;
+	in.args[1].value = link;
+	request_send(fc, &in, &out);
+	if(out.h.error)
+		return out.h.error;
+
+	return lookup_new_entry(dir, entry);
+}
+
+static int fuse_remove(struct inode *dir, struct dentry *entry, 
+		       enum fuse_opcode op)
+{
+	struct fuse_conn *fc = INO_FC(dir);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+
+	in.h.opcode = op;
+	in.h.ino = dir->i_ino;
+	in.numargs = 1;
+	in.args[0].size = entry->d_name.len + 1;
+	in.args[0].value = entry->d_name.name;
+	request_send(fc, &in, &out);
+
+	return out.h.error;
+}
+
+static int fuse_unlink(struct inode *dir, struct dentry *entry)
+{
+	int err = fuse_remove(dir, entry, FUSE_UNLINK);
+	if(!err) {
+		/* FIXME: the new i_nlink could be returned by the
+                   unlink operation */
+		err = fuse_do_getattr(entry->d_inode);
+		if(err == -ENOENT)
+			entry->d_inode->i_nlink = 0;
+
+		uncache_dir(dir);
+		return 0;
+	}
+	return err;
+}
+
+static int fuse_rmdir(struct inode *dir, struct dentry *entry)
+{
+	int err = fuse_remove(dir, entry, FUSE_RMDIR);
+	if(!err) {
+		entry->d_inode->i_nlink = 0;
+		uncache_dir(dir);
+	}
+	return err;
+}
+
+static int fuse_rename(struct inode *olddir, struct dentry *oldent,
+		       struct inode *newdir, struct dentry *newent)
+{
+	struct fuse_conn *fc = INO_FC(olddir);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+	struct fuse_rename_in inarg;
+	
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.newdir = newdir->i_ino;
+
+	in.h.opcode = FUSE_RENAME;
+	in.h.ino = olddir->i_ino;
+	in.numargs = 3;
+	in.args[0].size = sizeof(inarg);
+	in.args[0].value = &inarg;
+	in.args[1].size = oldent->d_name.len + 1;
+	in.args[1].value = oldent->d_name.name;
+	in.args[2].size = newent->d_name.len + 1;
+	in.args[2].value = newent->d_name.name;
+	request_send(fc, &in, &out);
+
+	if (!out.h.error) {
+		uncache_dir(olddir);
+		if (olddir != newdir)
+			uncache_dir(newdir);
+	}
+
+	return out.h.error;
+}
+
+static int fuse_link(struct dentry *entry, struct inode *newdir,
+		     struct dentry *newent)
+{
+	struct inode *inode = entry->d_inode;
+	struct fuse_conn *fc = INO_FC(inode);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+	struct fuse_link_in inarg;
+	
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.newdir = newdir->i_ino;
+
+	in.h.opcode = FUSE_LINK;
+	in.h.ino = inode->i_ino;
+	in.numargs = 2;
+	in.args[0].size = sizeof(inarg);
+	in.args[0].value = &inarg;
+	in.args[1].size = newent->d_name.len + 1;
+	in.args[1].value = newent->d_name.name;
+	request_send(fc, &in, &out);
+	if(out.h.error)
+		return out.h.error;
+
+	/* Invalidate old entry, so attributes are refreshed */
+	d_invalidate(entry);
+	return lookup_new_entry(newdir, newent);
+}
+
+int fuse_do_getattr(struct inode *inode)
+{
+	struct fuse_conn *fc = INO_FC(inode);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+	struct fuse_getattr_out arg;
+	
+	in.h.opcode = FUSE_GETATTR;
+	in.h.ino = inode->i_ino;
+	out.numargs = 1;
+	out.args[0].size = sizeof(arg);
+	out.args[0].value = &arg;
+	request_send(fc, &in, &out);
+	
+	if(!out.h.error)
+		change_attributes(inode, &arg.attr);
+	
+	return out.h.error;
+}
+
+static int fuse_revalidate(struct dentry *entry)
+{
+	struct inode *inode = entry->d_inode;
+	struct fuse_conn *fc = INO_FC(inode);
+
+	if(inode->i_ino == FUSE_ROOT_INO) {
+		if(!(fc->flags & FUSE_ALLOW_OTHER) &&
+		   current->fsuid != fc->uid)
+			return -EACCES;
+	} else if(time_before_eq(jiffies, entry->d_time + FUSE_REVALIDATE_TIME))
+		return 0;
+
+	return fuse_do_getattr(inode);
+}
+
+static int _fuse_permission(struct inode *inode, int mask)
+{
+	struct fuse_conn *fc = INO_FC(inode);
+
+	if(!(fc->flags & FUSE_ALLOW_OTHER) && current->fsuid != fc->uid)
+		return -EACCES;
+	else if(fc->flags & FUSE_DEFAULT_PERMISSIONS) {
+		int err = vfs_permission(inode, mask);
+
+		/* If permission is denied, try to refresh file
+		   attributes.  This is also needed, because the root
+		   node will at first have no permissions */
+
+		if(err == -EACCES) {
+		 	err = fuse_do_getattr(inode);
+			if(!err)
+			 	err = vfs_permission(inode, mask);
+		}
+
+		/* FIXME: Need some mechanism to revoke permissions:
+		   currently if the filesystem suddenly changes the
+		   file mode, we will not be informed abot that, and
+		   continue to allow access to the file/directory.
+		   
+		   This is actually not so grave, since the user can
+		   simply keep access to the file/directory anyway by
+		   keeping it open... */
+
+		return err;
+	}
+	else
+		return 0;
+}
+
+static int parse_dirfile(char *buf, size_t nbytes, struct file *file,
+			 void *dstbuf, filldir_t filldir)
+{
+	while(nbytes >= FUSE_NAME_OFFSET) {
+		struct fuse_dirent *dirent = (struct fuse_dirent *) buf;
+		size_t reclen = FUSE_DIRENT_SIZE(dirent);
+		int over;
+		if(dirent->namelen > NAME_MAX) {
+			printk("fuse_readdir: name too long\n");
+			return -EPROTO;
+		}
+		if(reclen > nbytes)
+			break;
+
+		over = filldir(dstbuf, dirent->name, dirent->namelen,
+			      file->f_pos, dirent->ino, dirent->type);
+		if(over)
+			break;
+
+		buf += reclen;
+		file->f_pos += reclen;
+		nbytes -= reclen;
+	}
+
+	return 0;
+}
+
+#define DIR_BUFSIZE 2048
+static int fuse_readdir(struct file *file, void *dstbuf, filldir_t filldir)
+{
+	struct file *cfile = file->private_data;
+	char *buf;
+	int ret;
+
+	if(!cfile)
+		return -EISDIR;
+
+	buf = kmalloc(DIR_BUFSIZE, GFP_KERNEL);
+	if(!buf)
+		return -ENOMEM;
+	
+	ret = kernel_read(cfile, file->f_pos, buf, DIR_BUFSIZE);
+	if(ret < 0)
+		printk("fuse_readdir: failed to read container file\n");
+	else 
+		ret = parse_dirfile(buf, ret, file, dstbuf, filldir);
+
+	kfree(buf);	
+	return ret;
+}
+
+static char *read_link(struct dentry *dentry)
+{
+	struct inode *inode = dentry->d_inode;
+	struct fuse_conn *fc = INO_FC(inode);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+	char *link;
+
+	link = (char *) __get_free_page(GFP_KERNEL);
+	if(!link)
+		return ERR_PTR(-ENOMEM);
+
+	in.h.opcode = FUSE_READLINK;
+	in.h.ino = inode->i_ino;
+	out.argvar = 1;
+	out.numargs = 1;
+	out.args[0].size = PAGE_SIZE - 1;
+	out.args[0].value = link;
+	request_send(fc, &in, &out);
+	if(out.h.error) {
+		free_page((unsigned long) link);
+		return ERR_PTR(out.h.error);
+	}
+
+	link[out.args[0].size] = '\0';
+	return link;
+}
+
+static void free_link(char *link)
+{
+	if(!IS_ERR(link))
+		free_page((unsigned long) link);
+}
+
+static int fuse_readlink(struct dentry *dentry, char *buffer, int buflen)
+{
+	int ret;
+	char *link;
+
+	link = read_link(dentry);
+	ret = vfs_readlink(dentry, buffer, buflen, link);
+	free_link(link);
+	return ret;
+}
+
+static int fuse_follow_link(struct dentry *dentry, struct nameidata *nd)
+{
+	int ret;
+	char *link;
+
+	link = read_link(dentry);
+	ret = vfs_follow_link(nd, link);
+	free_link(link);
+	return ret;
+}
+
+static int fuse_dir_open(struct inode *inode, struct file *file)
+{
+	struct fuse_conn *fc = INO_FC(inode);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+	struct fuse_getdir_out outarg;
+
+	in.h.opcode = FUSE_GETDIR;
+	in.h.ino = inode->i_ino;
+	out.numargs = 1;
+	out.args[0].size = sizeof(outarg);
+	out.args[0].value = &outarg;
+	request_send(fc, &in, &out);
+	if(!out.h.error) {
+		struct file *cfile = outarg.file;
+		struct inode *inode;
+		if(!cfile) {
+			printk("fuse_getdir: invalid file\n");
+			return -EPROTO;
+		}
+		inode = cfile->f_dentry->d_inode;
+		if(!S_ISREG(inode->i_mode)) {
+			printk("fuse_getdir: not a regular file\n");
+			fput(cfile);
+			return -EPROTO;
+		}
+
+		file->private_data = cfile;
+	}
+
+	return out.h.error;
+}
+
+static int fuse_dir_release(struct inode *inode, struct file *file)
+{
+	struct file *cfile = file->private_data;
+
+	if(cfile)
+		fput(cfile);
+
+	return 0;
+}
+
+static unsigned int iattr_to_fattr(struct iattr *iattr,
+				   struct fuse_attr *fattr)
+{
+	unsigned int ivalid = iattr->ia_valid;
+	unsigned int fvalid = 0;
+	
+	memset(fattr, 0, sizeof(*fattr));
+	
+	if(ivalid & ATTR_MODE)
+		fvalid |= FATTR_MODE,   fattr->mode = iattr->ia_mode;
+	if(ivalid & ATTR_UID)
+		fvalid |= FATTR_UID,    fattr->uid = iattr->ia_uid;
+	if(ivalid & ATTR_GID)
+		fvalid |= FATTR_GID,    fattr->gid = iattr->ia_gid;
+	if(ivalid & ATTR_SIZE)
+		fvalid |= FATTR_SIZE,   fattr->size = iattr->ia_size;
+	/* You can only _set_ these together (they may change by themselves) */
+	if((ivalid & (ATTR_ATIME | ATTR_MTIME)) == (ATTR_ATIME | ATTR_MTIME)) {
+		fvalid |= FATTR_UTIME;
+#ifdef KERNEL_2_6
+		fattr->atime = iattr->ia_atime.tv_sec;
+		fattr->mtime = iattr->ia_mtime.tv_sec;
+#else
+		fattr->atime = iattr->ia_atime;
+		fattr->mtime = iattr->ia_mtime;
+#endif
+	}
+
+	return fvalid;
+}
+
+static int fuse_setattr(struct dentry *entry, struct iattr *attr)
+{
+	struct inode *inode = entry->d_inode;
+	struct fuse_conn *fc = INO_FC(inode);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+	struct fuse_setattr_in inarg;
+	struct fuse_setattr_out outarg;
+
+	/* FIXME: need to fix race between truncate and writepage */
+	if (attr->ia_valid & ATTR_SIZE)	
+		fuse_sync_inode(inode);
+
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.valid = iattr_to_fattr(attr, &inarg.attr);
+	
+	in.h.opcode = FUSE_SETATTR;
+	in.h.ino = inode->i_ino;
+	in.numargs = 1;
+	in.args[0].size = sizeof(inarg);
+	in.args[0].value = &inarg;
+	out.numargs = 1;
+	out.args[0].size = sizeof(outarg);
+	out.args[0].value = &outarg;
+	request_send(fc, &in, &out);
+
+	if(!out.h.error) {
+		if(attr->ia_valid & ATTR_SIZE &&
+		   outarg.attr.size < i_size_read(inode))
+			vmtruncate(inode, outarg.attr.size);
+
+		change_attributes(inode, &outarg.attr);
+	} 
+	return out.h.error;
+}
+
+static int _fuse_dentry_revalidate(struct dentry *entry)
+{
+	if(!entry->d_inode)
+		return 0;
+	else if(time_after(jiffies, entry->d_time + FUSE_REVALIDATE_TIME)) {
+		struct inode *inode = entry->d_inode;
+		struct fuse_lookup_out outarg;
+		int version;
+		int ret;
+		
+		ret = fuse_do_lookup(entry->d_parent->d_inode, entry, &outarg,
+				     &version);
+		if(ret)
+			return 0;
+		
+		if(outarg.ino != inode->i_ino)
+			return 0;
+		
+		change_attributes(inode, &outarg.attr);
+		inode->i_version = version;
+		entry->d_time = jiffies;
+	}
+	return 1;
+}
+
+#ifdef KERNEL_2_6
+
+#define fuse_mknod _fuse_mknod
+
+static int fuse_getattr(struct vfsmount *mnt, struct dentry *entry,
+			struct kstat *stat)
+{
+	struct inode *inode = entry->d_inode;
+	int err = fuse_revalidate(entry);
+	if(!err)
+		generic_fillattr(inode, stat);
+	
+	return err;
+}
+
+static struct dentry *fuse_lookup(struct inode *dir, struct dentry *entry,
+				   struct nameidata *nd)
+{
+	struct inode *inode;
+	int err = fuse_lookup_iget(dir, entry, &inode);
+	if (err)
+		return ERR_PTR(err);
+	return d_splice_alias(inode, entry);
+}
+
+static int fuse_create(struct inode *dir, struct dentry *entry, int mode,
+		       struct nameidata *nd)
+{
+	return _fuse_create(dir, entry, mode);
+}
+
+static int fuse_permission(struct inode *inode, int mask,
+			    struct nameidata *nd)
+{
+	return _fuse_permission(inode, mask);
+}
+
+static int fuse_dentry_revalidate(struct dentry *entry, struct nameidata *nd)
+{
+	return _fuse_dentry_revalidate(entry);
+}
+#else /* KERNEL_2_6 */
+
+#define fuse_create _fuse_create
+#define fuse_permission _fuse_permission
+
+static struct dentry *fuse_lookup(struct inode *dir, struct dentry *entry)
+{
+	struct inode *inode;
+	struct dentry *alias;
+
+	int err = fuse_lookup_iget(dir, entry, &inode);
+	if(err)
+		return ERR_PTR(err);
+
+	if(inode && S_ISDIR(inode->i_mode) &&
+	   (alias = d_find_alias(inode)) != NULL) {
+		dput(alias);
+		iput(inode);
+		printk("fuse: cannot assign an existing directory\n");
+		return ERR_PTR(-EPROTO);
+	}
+
+	d_add(entry, inode);
+	return NULL;
+}
+
+static int fuse_mknod(struct inode *dir, struct dentry *entry, int mode,
+		      int rdev)
+{
+	return _fuse_mknod(dir, entry, mode, rdev);
+}
+
+static int fuse_dentry_revalidate(struct dentry *entry, int flags)
+{
+	return _fuse_dentry_revalidate(entry);
+}
+#endif /* KERNEL_2_6 */
+
+
+static struct inode_operations fuse_dir_inode_operations =
+{
+	.lookup		= fuse_lookup,
+	.create		= fuse_create,
+	.mknod		= fuse_mknod,
+	.mkdir		= fuse_mkdir,
+	.symlink	= fuse_symlink,
+	.unlink		= fuse_unlink,
+	.rmdir		= fuse_rmdir,
+	.rename		= fuse_rename,
+	.link		= fuse_link,
+	.setattr	= fuse_setattr,
+	.permission	= fuse_permission,
+#ifdef KERNEL_2_6
+	.getattr	= fuse_getattr,
+#else
+	.revalidate	= fuse_revalidate,
+#endif
+};
+
+static struct file_operations fuse_dir_operations = {
+	.read		= generic_read_dir,
+	.readdir	= fuse_readdir,
+	.open		= fuse_dir_open,
+	.release	= fuse_dir_release,
+};
+
+static struct inode_operations fuse_file_inode_operations = {
+	.setattr	= fuse_setattr,
+	.permission	= fuse_permission,
+#ifdef KERNEL_2_6
+	.getattr	= fuse_getattr,
+#else
+	.revalidate	= fuse_revalidate,
+#endif
+};
+
+static struct inode_operations fuse_symlink_inode_operations =
+{
+	.setattr	= fuse_setattr,
+	.readlink	= fuse_readlink,
+	.follow_link	= fuse_follow_link,
+#ifdef KERNEL_2_6
+	.getattr	= fuse_getattr,
+#else
+	.revalidate	= fuse_revalidate,
+#endif
+};
+
+static struct dentry_operations fuse_dentry_operations = {
+	.d_revalidate	= fuse_dentry_revalidate,
+};
+
+/* 
+ * Local Variables:
+ * indent-tabs-mode: t
+ * c-basic-offset: 8
+ * End:
+ */
Index: xx-sources/fs/fuse/file.c
===================================================================
--- xx-sources.orig/fs/fuse/file.c	2004-05-31 17:36:38.000000000 -0400
+++ xx-sources/fs/fuse/file.c	2004-08-24 20:35:30.346392200 -0400
@@ -0,0 +1,542 @@
+/*
+    FUSE: Filesystem in Userspace
+    Copyright (C) 2001-2004  Miklos Szeredi <miklos@szeredi.hu>
+
+    This program can be distributed under the terms of the GNU GPL.
+    See the file COPYING.
+*/
+#include "fuse_i.h"
+
+#include <linux/pagemap.h>
+#include <linux/slab.h>
+#ifdef KERNEL_2_6
+#include <linux/backing-dev.h>
+#include <linux/writeback.h>
+#endif
+
+#ifndef KERNEL_2_6
+#define PageUptodate(page) Page_Uptodate(page)
+#endif
+
+static int fuse_open(struct inode *inode, struct file *file)
+{
+	struct fuse_conn *fc = INO_FC(inode);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+	struct fuse_open_in inarg;
+	int err;
+
+	err = generic_file_open(inode, file);
+	if(err)
+		return err;
+
+	/* If opening the root node, no lookup has been performed on
+	   it, so the attributes must be refreshed */
+	if(inode->i_ino == FUSE_ROOT_INO) {
+		int err = fuse_do_getattr(inode);
+		if(err)
+		 	return err;
+	}
+
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.flags = file->f_flags & ~O_EXCL;
+
+	in.h.opcode = FUSE_OPEN;
+	in.h.ino = inode->i_ino;
+	in.numargs = 1;
+	in.args[0].size = sizeof(inarg);
+	in.args[0].value = &inarg;
+	request_send(fc, &in, &out);
+	if(!out.h.error && !(fc->flags & FUSE_KERNEL_CACHE)) {
+#ifdef KERNEL_2_6
+		invalidate_inode_pages(inode->i_mapping);
+#else
+		invalidate_inode_pages(inode);
+#endif
+	}
+
+	return out.h.error;
+}
+
+void fuse_sync_inode(struct inode *inode)
+{
+#ifdef KERNEL_2_6
+	filemap_fdatawrite(inode->i_mapping);
+	filemap_fdatawait(inode->i_mapping);
+#else
+#ifndef NO_MM
+	filemap_fdatasync(inode->i_mapping);
+	filemap_fdatawait(inode->i_mapping);
+#endif
+#endif
+}
+
+static int fuse_release_old(struct inode *inode, struct file *file)
+{
+	struct fuse_conn *fc = INO_FC(inode);
+	struct fuse_in *in = NULL;
+	struct fuse_open_in *inarg = NULL;
+	unsigned int s = sizeof(struct fuse_in) + sizeof(struct fuse_open_in);
+
+	in = kmalloc(s, GFP_NOFS);
+	if(!in)
+		return -ENOMEM;
+	memset(in, 0, s);
+	inarg = (struct fuse_open_in *) (in + 1);
+	inarg->flags = file->f_flags & ~O_EXCL;
+
+	in->h.opcode = FUSE_RELEASE;
+	in->h.ino = inode->i_ino;
+	in->numargs = 1;
+	in->args[0].size = sizeof(struct fuse_open_in);
+	in->args[0].value = inarg;
+	if(!request_send_noreply(fc, in))
+		return 0;
+
+	kfree(in);
+	return 0;
+}
+
+static int fuse_release(struct inode *inode, struct file *file)
+{
+	struct fuse_conn *fc = INO_FC(inode);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+	struct fuse_open_in inarg;
+
+	if(file->f_mode & FMODE_WRITE)
+		fuse_sync_inode(inode);
+
+	if (fc->oldrelease)
+		return fuse_release_old(inode, file);
+
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.flags = file->f_flags & ~O_EXCL;
+
+	in.h.opcode = FUSE_RELEASE2;
+	in.h.ino = inode->i_ino;
+	in.numargs = 1;
+	in.args[0].size = sizeof(inarg);
+	in.args[0].value = &inarg;
+	request_send(fc, &in, &out);
+	if (out.h.error == -ENOSYS) {
+		fc->oldrelease = 1;
+		return fuse_release_old(inode, file);
+	}
+	return 0;
+}
+
+static int fuse_fsync(struct file *file, struct dentry *de, int datasync)
+{
+	struct inode *inode = de->d_inode;
+	struct fuse_conn *fc = INO_FC(inode);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+	struct fuse_fsync_in inarg;
+	
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.datasync = datasync;
+
+	in.h.opcode = FUSE_FSYNC;
+	in.h.ino = inode->i_ino;
+	in.numargs = 1;
+	in.args[0].size = sizeof(inarg);
+	in.args[0].value = &inarg;
+	request_send(fc, &in, &out);
+	return out.h.error;
+
+	/* FIXME: need to ensure, that all write requests issued
+           before this request are completed.  Should userspace take
+           care of this? */
+}
+
+static int fuse_readpage(struct file *file, struct page *page)
+{
+	struct inode *inode = page->mapping->host;
+	struct fuse_conn *fc = INO_FC(inode);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+	struct fuse_read_in inarg;
+	char *buffer;
+
+	buffer = kmap(page);
+	
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.offset = (unsigned long long) page->index << PAGE_CACHE_SHIFT;
+	inarg.size = PAGE_CACHE_SIZE;
+
+	in.h.opcode = FUSE_READ;
+	in.h.ino = inode->i_ino;
+	in.numargs = 1;
+	in.args[0].size = sizeof(inarg);
+	in.args[0].value = &inarg;
+	out.argvar = 1;
+	out.numargs = 1;
+	out.args[0].size = PAGE_CACHE_SIZE;
+	out.args[0].value = buffer;
+
+	request_send(fc, &in, &out);
+	if(!out.h.error) {
+		size_t outsize = out.args[0].size;
+		if(outsize < PAGE_CACHE_SIZE) 
+			memset(buffer + outsize, 0, PAGE_CACHE_SIZE - outsize);
+		flush_dcache_page(page);
+		SetPageUptodate(page);
+	}
+
+	kunmap(page);
+	unlock_page(page);
+
+	return out.h.error;
+}
+
+static int fuse_is_block_uptodate(struct address_space *mapping,
+		struct inode *inode, size_t bl_index)
+{
+	size_t index = bl_index << FUSE_BLOCK_PAGE_SHIFT;
+	size_t end_index = ((bl_index + 1) << FUSE_BLOCK_PAGE_SHIFT) - 1;
+	size_t file_end_index = i_size_read(inode) >> PAGE_CACHE_SHIFT;
+
+	if (end_index > file_end_index)
+		end_index = file_end_index;
+
+	for (; index <= end_index; index++) {
+		struct page *page = find_get_page(mapping, index);
+
+		if (!page)
+			return 0;
+
+		if (!PageUptodate(page)) {
+			page_cache_release(page);
+			return 0;
+		}
+
+		page_cache_release(page);
+	}
+
+	return 1;
+}
+
+
+static int fuse_cache_block(struct address_space *mapping,
+		struct inode *inode, char *bl_buf,
+		size_t bl_index)
+{
+	size_t start_index = bl_index << FUSE_BLOCK_PAGE_SHIFT;
+	size_t end_index = ((bl_index + 1) << FUSE_BLOCK_PAGE_SHIFT) - 1;
+	size_t file_end_index = i_size_read(inode) >> PAGE_CACHE_SHIFT;
+
+	int i;
+
+	if (end_index > file_end_index)
+		end_index = file_end_index;
+
+	for (i = 0; start_index + i <= end_index; i++) {
+		size_t index = start_index + i;
+		struct page *page;
+		char *buffer;
+
+		page = grab_cache_page(mapping, index);
+		if (!page)
+			return -1;
+
+		if (!PageUptodate(page)) {
+			buffer = kmap(page);
+			memcpy(buffer, bl_buf + i * PAGE_CACHE_SIZE,
+					PAGE_CACHE_SIZE);
+			flush_dcache_page(page);
+			SetPageUptodate(page);
+			kunmap(page);
+		}
+
+		unlock_page(page);
+		page_cache_release(page);
+	}
+
+	return 0;
+} 
+
+static int fuse_file_read_block(struct inode *inode, char *bl_buf,
+		size_t bl_index)
+{
+	struct fuse_conn *fc = INO_FC(inode);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+	struct fuse_read_in inarg;
+
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.offset = (unsigned long long) bl_index << FUSE_BLOCK_SHIFT;
+	inarg.size = FUSE_BLOCK_SIZE;
+
+	in.h.opcode = FUSE_READ;
+	in.h.ino = inode->i_ino;
+	in.numargs = 1;
+	in.args[0].size = sizeof(inarg);
+	in.args[0].value = &inarg;
+	out.argvar = 1;
+	out.numargs = 1;
+	out.args[0].size = FUSE_BLOCK_SIZE;
+	out.args[0].value = bl_buf;
+
+	request_send(fc, &in, &out);
+
+	if (!out.h.error) {
+		size_t outsize = out.args[0].size;
+		if (outsize < FUSE_BLOCK_SIZE)
+			memset(bl_buf + outsize, 0, FUSE_BLOCK_SIZE - outsize);
+	}
+
+	return out.h.error;
+}   
+
+static void fuse_file_bigread(struct address_space *mapping,
+			      struct inode *inode, loff_t pos, size_t count)
+{
+	size_t bl_index = pos >> FUSE_BLOCK_SHIFT;
+	size_t bl_end_index = (pos + count) >> FUSE_BLOCK_SHIFT;
+	size_t bl_file_end_index = i_size_read(inode) >> FUSE_BLOCK_SHIFT;
+	
+	if (bl_end_index > bl_file_end_index)
+		bl_end_index = bl_file_end_index;
+	
+	while (bl_index <= bl_end_index) {
+		int res;
+		char *bl_buf = kmalloc(FUSE_BLOCK_SIZE, GFP_NOFS);
+		if (!bl_buf)
+			break;
+		res = fuse_is_block_uptodate(mapping, inode, bl_index);
+		if (!res)
+			res = fuse_file_read_block(inode, bl_buf, bl_index);
+		if (!res)
+			fuse_cache_block(mapping, inode, bl_buf, bl_index);
+		kfree(bl_buf);
+		bl_index++;
+	}
+}
+
+static ssize_t fuse_file_read(struct file *filp, char *buf,
+		size_t count, loff_t * ppos)
+{
+	struct address_space *mapping = filp->f_dentry->d_inode->i_mapping;
+	struct inode *inode = mapping->host;
+	struct fuse_conn *fc = INO_FC(inode);
+
+	if(fc->flags & FUSE_LARGE_READ) {
+		/* Don't allow this to get mixed up with writes */
+		down(&inode->i_sem);
+		fuse_file_bigread(mapping, inode, *ppos, count);
+		up(&inode->i_sem);
+	}
+
+	return generic_file_read(filp, buf, count, ppos);
+}  
+
+static int write_buffer(struct inode *inode, struct page *page,
+			unsigned offset, size_t count)
+{
+	struct fuse_conn *fc = INO_FC(inode);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+	struct fuse_write_in inarg;
+	char *buffer;
+
+	buffer = kmap(page);
+
+	memset(&inarg, 0, sizeof(inarg));
+	inarg.offset = ((unsigned long long) page->index << PAGE_CACHE_SHIFT) +
+		offset;
+	inarg.size = count;
+	
+	in.h.opcode = FUSE_WRITE;
+	in.h.ino = inode->i_ino;
+	in.numargs = 2;
+	in.args[0].size = sizeof(inarg);
+	in.args[0].value = &inarg;
+	in.args[1].size = count;
+	in.args[1].value = buffer + offset;
+	request_send(fc, &in, &out);
+	kunmap(page);
+	if(out.h.error)
+		SetPageError(page);
+
+	return out.h.error;
+}
+
+static int get_write_count(struct inode *inode, struct page *page)
+{
+	unsigned long end_index;
+	loff_t size = i_size_read(inode);
+	int count;
+	
+	end_index = size >> PAGE_CACHE_SHIFT;
+	if(page->index < end_index)
+		count = PAGE_CACHE_SIZE;
+	else {
+		count = size & (PAGE_CACHE_SIZE - 1);
+		if(page->index > end_index || count == 0)
+			return 0;
+	}
+	return count;
+}
+
+#ifdef KERNEL_2_6
+
+static void write_buffer_end(struct fuse_conn *fc, struct fuse_in *in,
+			     struct fuse_out *out, void *_page)
+{
+	struct page *page = (struct page *) _page;
+	
+	if(out->h.error) {
+		SetPageError(page);
+		if(out->h.error == -ENOSPC)
+			set_bit(AS_ENOSPC, &page->mapping->flags);
+		else
+			set_bit(AS_EIO, &page->mapping->flags);
+	}
+	end_page_writeback(page);
+	kunmap(page);
+	kfree(in);	
+}
+
+static int write_buffer_nonblock(struct inode *inode, struct page *page,
+				 unsigned offset, size_t count)
+{
+	int err;
+	struct fuse_conn *fc = INO_FC(inode);
+	struct fuse_in *in = NULL;
+	struct fuse_out *out = NULL;
+	struct fuse_write_in *inarg = NULL;
+	char *buffer;
+	unsigned int s = sizeof(struct fuse_in) + sizeof(struct fuse_out) +
+		sizeof(struct fuse_write_in);
+
+	in = kmalloc(s, GFP_NOFS);
+	if(!in)
+		return -ENOMEM;
+	memset(in, 0, s);
+	out = (struct fuse_out *)(in + 1);
+	inarg = (struct fuse_write_in *)(out + 1);
+	
+	buffer = kmap(page);
+
+	inarg->offset = ((unsigned long long) page->index << PAGE_CACHE_SHIFT) + offset;
+	inarg->size = count;
+	
+	in->h.opcode = FUSE_WRITE;
+	in->h.ino = inode->i_ino;
+	in->numargs = 2;
+	in->args[0].size = sizeof(struct fuse_write_in);
+	in->args[0].value = inarg;
+	in->args[1].size = count;
+	in->args[1].value = buffer + offset;
+	err = request_send_nonblock(fc, in, out, write_buffer_end, page);
+	if(err) {
+		if(err != -EWOULDBLOCK)
+			SetPageError(page);
+		kunmap(page);
+		kfree(in);
+	}
+	return err;
+}
+
+static int fuse_writepage(struct page *page, struct writeback_control *wbc)
+{
+	int err;
+	struct inode *inode = page->mapping->host;
+	unsigned count = get_write_count(inode, page);
+
+	err = -EINVAL;
+	if(count) {
+		/* FIXME: check sync_mode, and wait for previous writes (or
+		   signal userspace to do this) */
+		if(wbc->nonblocking) {
+			SetPageWriteback(page);
+			err = write_buffer_nonblock(inode, page, 0, count);
+			if (err)
+				ClearPageWriteback(page);
+			if(err == -EWOULDBLOCK) {
+				__set_page_dirty_nobuffers(page);
+				err = 0;
+			}
+		} else
+			err = write_buffer(inode, page, 0, count);
+	}
+
+	unlock_page(page);
+	return err;
+}
+#else
+static int fuse_writepage(struct page *page)
+{
+	int err;
+	struct inode *inode = page->mapping->host;
+	int count = get_write_count(inode, page);
+	err = -EINVAL;
+	if(count)
+		err = write_buffer(inode, page, 0, count);
+
+	unlock_page(page);
+	return err;
+}
+#endif
+
+static int fuse_prepare_write(struct file *file, struct page *page,
+			      unsigned offset, unsigned to)
+{
+	/* No op */
+	return 0;
+}
+
+static int fuse_commit_write(struct file *file, struct page *page,
+			     unsigned offset, unsigned to)
+{
+	int err;
+	struct inode *inode = page->mapping->host;
+
+	err = write_buffer(inode, page, offset, to - offset);
+	if(!err) {
+		loff_t pos = (page->index << PAGE_CACHE_SHIFT) + to;
+		if(pos > i_size_read(inode))
+			i_size_write(inode, pos);
+	}
+	return err;
+}
+
+static struct file_operations fuse_file_operations = {
+	.read		= fuse_file_read,
+	.write		= generic_file_write,
+	.mmap		= generic_file_mmap,
+	.open		= fuse_open,
+	.release	= fuse_release,
+	.fsync		= fuse_fsync,
+#ifdef KERNEL_2_6
+	.sendfile	= generic_file_sendfile,
+#endif
+};
+
+static struct address_space_operations fuse_file_aops  = {
+	.readpage =		fuse_readpage,
+	.writepage =		fuse_writepage,
+	.prepare_write =	fuse_prepare_write,
+	.commit_write =		fuse_commit_write,
+};
+
+void fuse_init_file_inode(struct inode *inode)
+{
+#ifdef KERNEL_2_6
+	struct fuse_conn *fc = INO_FC(inode);
+	/* Readahead somehow defeats big reads on 2.6 (says Michael
+           Grigoriev) */
+	if(fc->flags & FUSE_LARGE_READ)
+		inode->i_mapping->backing_dev_info->ra_pages = 0;
+#endif
+	inode->i_fop = &fuse_file_operations;
+	inode->i_data.a_ops = &fuse_file_aops;
+}
+
+/* 
+ * Local Variables:
+ * indent-tabs-mode: t
+ * c-basic-offset: 8
+ * End:
+ */
Index: xx-sources/fs/fuse/fuse_i.h
===================================================================
--- xx-sources.orig/fs/fuse/fuse_i.h	2004-05-31 17:36:38.000000000 -0400
+++ xx-sources/fs/fuse/fuse_i.h	2004-08-24 20:35:30.348391896 -0400
@@ -0,0 +1,250 @@
+/*
+    FUSE: Filesystem in Userspace
+    Copyright (C) 2001-2004  Miklos Szeredi <miklos@szeredi.hu>
+
+    This program can be distributed under the terms of the GNU GPL.
+    See the file COPYING.
+*/
+
+
+#include <linux/fuse.h>
+#include <linux/version.h>
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,0) && LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#error Kernel version 2.5.* not supported
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)
+#define KERNEL_2_6
+#endif
+
+#ifndef KERNEL_2_6
+#include <linux/config.h>
+#ifdef CONFIG_MODVERSIONS
+#define MODVERSIONS
+#include <linux/modversions.h>
+#endif
+#include <config.h>
+#ifndef HAVE_I_SIZE_FUNC
+#define i_size_read(inode) ((inode)->i_size)
+#define i_size_write(inode, size) do { (inode)->i_size = size; } while(0)
+#endif
+#endif 
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+
+/** Read combining parameters */
+#define FUSE_BLOCK_SHIFT 16
+#define FUSE_BLOCK_SIZE 65536
+#define FUSE_BLOCK_MASK 0xffff0000
+
+#define FUSE_BLOCK_PAGE_SHIFT (FUSE_BLOCK_SHIFT - PAGE_CACHE_SHIFT)
+
+/**
+ * A Fuse connection.
+ *
+ * This structure is created, when the client device is opened, and is
+ * destroyed, when the client device is closed _and_ the filesystem is
+ * unmounted.
+ */
+struct fuse_conn {
+	/** The superblock of the mounted filesystem */
+	struct super_block *sb;
+	
+	/** The opened client device */
+	struct file *file;
+
+	/** The user id for this mount */
+	uid_t uid;
+
+	/** The fuse mount flags for this mount */
+	unsigned int flags;
+
+	/** Is the new (synchronous) release not supported by
+	    userspace? */
+	unsigned int oldrelease;
+
+	/** Readers of the connection are waiting on this */
+	wait_queue_head_t waitq;
+
+	/** The list of pending requests */
+	struct list_head pending;
+
+	/** The list of requests being processed */
+	struct list_head processing;
+
+	/** Controls the maximum number of outstanding requests */
+	struct semaphore outstanding;
+	
+	/** The next unique request id */
+	int reqctr;
+};
+
+/** One input argument of a request */
+struct fuse_in_arg {
+	unsigned int size;
+	const void *value;
+};
+
+/** The request input */
+struct fuse_in {
+	struct fuse_in_header h;
+	unsigned int numargs;
+	struct fuse_in_arg args[3];
+};
+
+/** One output argument of a request */
+struct fuse_out_arg {
+	unsigned int size;
+	void *value;
+};
+
+/** The request output */
+struct fuse_out {
+	struct fuse_out_header h;
+	unsigned int argvar;
+	unsigned int numargs;
+	struct fuse_out_arg args[3];
+};
+
+#define FUSE_IN_INIT { {0, 0, 0, current->fsuid, current->fsgid}, 0}
+#define FUSE_OUT_INIT { {0, 0}, 0, 0}
+
+struct fuse_req;
+typedef void (*fuse_reqend_t)(struct fuse_conn *, struct fuse_in *,
+			      struct fuse_out *, void *data);
+
+/**
+ * A request to the client
+ */
+struct fuse_req {
+	/** The request list */
+	struct list_head list;
+
+	/** True if the request is synchronous */
+	unsigned int issync:1;
+
+	/** The request is locked */
+	unsigned int locked:1;
+
+	/** The request has been interrupted while it was locked */
+	unsigned int interrupted:1;
+
+	/* The request has been sent to the client */
+	unsigned int sent:1;
+
+	/* The request is finished */
+	unsigned int finished:1;
+
+	/** The request input */
+	struct fuse_in *in;
+
+	/** The request output */
+	struct fuse_out *out;
+
+	/** Used to wake up the task waiting for completion of request*/
+	wait_queue_head_t waitq;
+
+	/** Request completion callback */
+	fuse_reqend_t end;
+
+	/** User data */
+	void *data;
+};
+
+#ifdef KERNEL_2_6
+#define SB_FC(sb) ((sb)->s_fs_info)
+#else
+#define SB_FC(sb) ((sb)->u.generic_sbp)
+#endif
+#define INO_FC(inode) SB_FC((inode)->i_sb)
+#define DEV_FC(file) ((struct fuse_conn *) (file)->private_data)
+
+
+/**
+ * The proc entry for the client device ("/proc/fs/fuse/dev")
+ */
+extern struct proc_dir_entry *proc_fuse_dev;
+
+/**
+ * The lock to protect fuses structures
+ */
+extern spinlock_t fuse_lock;
+
+
+/**
+ * Get a filled in inode
+ */
+struct inode *fuse_iget(struct super_block *sb, ino_t ino,
+			struct fuse_attr *attr, int version);
+
+
+/**
+ * Initialise operations on regular file
+ */
+void fuse_init_file_inode(struct inode *inode);
+
+/**
+ * Check if the connection can be released, and if yes, then free the
+ * connection structure
+ */
+void fuse_release_conn(struct fuse_conn *fc);
+
+/**
+ * Initialize the client device
+ */
+int fuse_dev_init(void);
+
+/**
+ * Cleanup the client device
+ */
+void fuse_dev_cleanup(void);
+
+/**
+ * Initialize the fuse filesystem 
+ */
+int fuse_fs_init(void);
+
+/**
+ * Cleanup the fuse filesystem
+ */
+void fuse_fs_cleanup(void);
+
+/**
+ * Send a request
+ *
+ */
+void request_send(struct fuse_conn *fc, struct fuse_in *in,
+		  struct fuse_out *out);
+
+/**
+ * Send a request for which a reply is not expected
+ */
+int request_send_noreply(struct fuse_conn *fc, struct fuse_in *in);
+
+
+/**
+ * Send a synchronous request without blocking
+ */
+int request_send_nonblock(struct fuse_conn *fc, struct fuse_in *in,
+			  struct fuse_out *out, fuse_reqend_t end, void *data);
+
+/**
+ * Get the attributes of a file
+ */
+int fuse_do_getattr(struct inode *inode);
+
+/**
+ * Write dirty pages
+ */
+void fuse_sync_inode(struct inode *inode);
+
+/*
+ * Local Variables:
+ * indent-tabs-mode: t
+ * c-basic-offset: 8
+ * End:
+ */
Index: xx-sources/fs/fuse/inode.c
===================================================================
--- xx-sources.orig/fs/fuse/inode.c	2004-05-31 17:36:38.000000000 -0400
+++ xx-sources/fs/fuse/inode.c	2004-08-24 20:35:30.349391744 -0400
@@ -0,0 +1,290 @@
+/*
+    FUSE: Filesystem in Userspace
+    Copyright (C) 2001	Miklos Szeredi (miklos@szeredi.hu)
+
+    This program can be distributed under the terms of the GNU GPL.
+    See the file COPYING.
+*/
+
+#include "fuse_i.h"
+
+#include <linux/pagemap.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/file.h>
+#include <linux/proc_fs.h>
+#ifdef KERNEL_2_6
+#include <linux/statfs.h>
+#endif
+
+#define FUSE_SUPER_MAGIC 0x65735546
+
+#ifndef KERNEL_2_6
+#define kstatfs statfs
+#endif
+
+#ifndef FS_BINARY_MOUNTDATA
+#define FS_BINARY_MOUNTDATA 0
+#endif
+
+static void fuse_read_inode(struct inode *inode)
+{
+	/* No op */
+}
+
+static void fuse_clear_inode(struct inode *inode)
+{
+	struct fuse_conn *fc = INO_FC(inode);
+	struct fuse_in *in = NULL;
+	struct fuse_forget_in *inarg = NULL;
+	unsigned int s = sizeof(struct fuse_in) + sizeof(struct fuse_forget_in);
+	
+	if(fc == NULL)
+		return;
+
+	in = kmalloc(s, GFP_NOFS);
+	if(!in)
+		return;
+	memset(in, 0, s);
+	inarg = (struct fuse_forget_in *) (in + 1);
+	inarg->version = inode->i_version;
+		
+	in->h.opcode = FUSE_FORGET;
+	in->h.ino = inode->i_ino;
+	in->numargs = 1;
+	in->args[0].size = sizeof(struct fuse_forget_in);
+	in->args[0].value = inarg;
+		
+	if(!request_send_noreply(fc, in))
+		return;
+
+	kfree(in);
+}
+
+static void fuse_put_super(struct super_block *sb)
+{
+	struct fuse_conn *fc = SB_FC(sb);
+
+	spin_lock(&fuse_lock);
+	fc->sb = NULL;
+	fc->uid = 0;
+	fc->flags = 0;
+	/* Flush all readers on this fs */
+	wake_up_all(&fc->waitq);
+	fuse_release_conn(fc);
+	SB_FC(sb) = NULL;
+	spin_unlock(&fuse_lock);
+}
+
+static void convert_fuse_statfs(struct kstatfs *stbuf, struct fuse_kstatfs *attr)
+{
+	stbuf->f_type	 = FUSE_SUPER_MAGIC;
+	stbuf->f_bsize	 = attr->block_size;
+	stbuf->f_blocks	 = attr->blocks;
+	stbuf->f_bfree	 = stbuf->f_bavail = attr->blocks_free;
+	stbuf->f_files	 = attr->files;
+	stbuf->f_ffree	 = attr->files_free;
+	/* Is this field necessary?  Most filesystems ignore it...
+	stbuf->f_fsid.val[0] = (FUSE_SUPER_MAGIC>>16)&0xffff;
+	stbuf->f_fsid.val[1] =	FUSE_SUPER_MAGIC     &0xffff; */
+	stbuf->f_namelen = attr->namelen;
+}
+
+static int fuse_statfs(struct super_block *sb, struct kstatfs *buf)
+{
+	struct fuse_conn *fc = SB_FC(sb);
+	struct fuse_in in = FUSE_IN_INIT;
+	struct fuse_out out = FUSE_OUT_INIT;
+	struct fuse_statfs_out outarg;
+	
+	in.numargs = 0;
+	in.h.opcode = FUSE_STATFS;
+	out.numargs = 1;
+	out.args[0].size = sizeof(outarg);
+	out.args[0].value = &outarg;
+	request_send(fc, &in, &out);
+	if(!out.h.error)
+		convert_fuse_statfs(buf, &outarg.st);
+	
+	return out.h.error;
+}
+
+static struct fuse_conn *get_conn(struct fuse_mount_data *d)
+{
+	struct fuse_conn *fc = NULL;
+	struct file *file;
+	struct inode *ino;
+
+	if(d == NULL) {
+		printk("fuse_read_super: Bad mount data\n");
+		return NULL;
+	}
+
+	if(d->version != FUSE_KERNEL_VERSION) {
+		printk("fuse_read_super: Bad version: %i\n", d->version);
+		return NULL;
+	}
+
+	file = fget(d->fd);
+	ino = NULL;
+	if(file)
+		ino = file->f_dentry->d_inode;
+	
+	if(!ino || !proc_fuse_dev || proc_fuse_dev->low_ino != ino->i_ino) {
+		printk("fuse_read_super: Bad file: %i\n", d->fd);
+		goto out;
+	}
+
+	fc = file->private_data;
+
+  out:
+	fput(file);
+	return fc;
+
+}
+
+static struct inode *get_root_inode(struct super_block *sb, unsigned int mode)
+{
+	struct fuse_attr attr;
+	memset(&attr, 0, sizeof(attr));
+
+	attr.mode = mode;
+	return fuse_iget(sb, 1, &attr, 0);
+}
+
+
+#ifdef KERNEL_2_6
+
+static struct dentry *fuse_get_dentry(struct super_block *sb, void *vobjp)
+{
+	__u32 *objp = vobjp;
+	unsigned long ino = objp[0];
+	/* __u32 generation = objp[1]; */
+	struct inode *inode;
+	struct dentry *entry;
+
+	if(ino == 0)
+		return ERR_PTR(-ESTALE);
+
+	inode = ilookup(sb, ino);
+	if(!inode)
+		return ERR_PTR(-ESTALE);
+
+	entry = d_alloc_anon(inode);
+	if(!entry) {
+		iput(inode);
+		return ERR_PTR(-ENOMEM);
+	}
+
+	return entry;
+}
+
+static struct export_operations fuse_export_operations = {
+	.get_dentry	= fuse_get_dentry,
+};
+#endif
+
+static struct super_operations fuse_super_operations = {
+	.read_inode	= fuse_read_inode,
+	.clear_inode	= fuse_clear_inode,
+	.put_super	= fuse_put_super,
+	.statfs		= fuse_statfs,
+};
+
+static int fuse_read_super(struct super_block *sb, void *data, int silent)
+{	
+	struct fuse_conn *fc;
+	struct inode *root;
+	struct fuse_mount_data *d = data;
+
+	sb->s_blocksize = PAGE_CACHE_SIZE;
+	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
+	sb->s_magic = FUSE_SUPER_MAGIC;
+	sb->s_op = &fuse_super_operations;
+	sb->s_maxbytes = MAX_LFS_FILESIZE;
+#ifdef KERNEL_2_6
+	sb->s_export_op = &fuse_export_operations;
+#endif
+
+	fc = get_conn(d);
+	if(fc == NULL)
+		return -EINVAL;
+	spin_lock(&fuse_lock);
+	if(fc->sb != NULL) {
+		printk("fuse_read_super: connection already mounted\n");
+		spin_unlock(&fuse_lock);
+		return -EINVAL;
+	}
+	fc->sb = sb;
+	fc->flags = d->flags;
+	fc->uid = d->uid;
+	spin_unlock(&fuse_lock);
+	
+	/* fc is needed in fuse_init_file_inode which could be called
+	   from get_root_inode */
+	SB_FC(sb) = fc;
+
+	root = get_root_inode(sb, d->rootmode);
+	if(root == NULL) {
+		printk("fuse_read_super: failed to get root inode\n");
+		return -EINVAL;
+	}
+
+	sb->s_root = d_alloc_root(root);
+	if(!sb->s_root)
+		return -EINVAL;
+
+	return 0;
+}
+
+#ifdef KERNEL_2_6
+static struct super_block *fuse_get_sb(struct file_system_type *fs_type,
+				       int flags, const char *dev_name,
+				       void *raw_data)
+{
+	return get_sb_nodev(fs_type, flags, raw_data, fuse_read_super);
+}
+
+static struct file_system_type fuse_fs_type = {
+	.owner		= THIS_MODULE,
+	.name		= "fuse",
+	.get_sb		= fuse_get_sb,
+	.kill_sb	= kill_anon_super,
+	.fs_flags	= FS_BINARY_MOUNTDATA,
+};
+#else
+static struct super_block *fuse_read_super_compat(struct super_block *sb,
+						  void *data, int silent)
+{
+	int err = fuse_read_super(sb, data, silent);
+	if(err)
+		return NULL;
+	else
+		return sb;
+}
+
+static DECLARE_FSTYPE(fuse_fs_type, "fuse", fuse_read_super_compat, 0);
+#endif
+
+int fuse_fs_init()
+{
+	int res;
+
+	res = register_filesystem(&fuse_fs_type);
+	if(res)
+		printk("fuse: failed to register filesystem\n");
+
+	return res;
+}
+
+void fuse_fs_cleanup()
+{
+	unregister_filesystem(&fuse_fs_type);
+}
+
+/* 
+ * Local Variables:
+ * indent-tabs-mode: t
+ * c-basic-offset: 8
+ * End:
+ */
Index: xx-sources/fs/fuse/util.c
===================================================================
--- xx-sources.orig/fs/fuse/util.c	2004-05-31 17:36:38.000000000 -0400
+++ xx-sources/fs/fuse/util.c	2004-08-24 20:35:30.350391592 -0400
@@ -0,0 +1,70 @@
+/*
+    FUSE: Filesystem in Userspace
+    Copyright (C) 2001-2004  Miklos Szeredi <miklos@szeredi.hu>
+
+    This program can be distributed under the terms of the GNU GPL.
+    See the file COPYING.
+*/
+
+#include "fuse_i.h"
+
+#include <linux/init.h>
+#include <linux/slab.h>
+
+MODULE_AUTHOR("Miklos Szeredi <miklos@szeredi.hu>");
+MODULE_DESCRIPTION("Filesystem in Userspace");
+#ifdef MODULE_LICENSE
+MODULE_LICENSE("GPL");
+#endif
+
+spinlock_t fuse_lock = SPIN_LOCK_UNLOCKED;
+
+/* Must be called with the fuse lock held */
+void fuse_release_conn(struct fuse_conn *fc)
+{
+	if(fc->sb == NULL && fc->file == NULL) {
+		kfree(fc);
+	}
+}
+
+int __init fuse_init(void)
+{
+	int res;
+
+	printk(KERN_DEBUG "fuse init %s (API version %i.%i)\n",
+	       FUSE_VERSION,
+	       FUSE_KERNEL_VERSION, FUSE_KERNEL_MINOR_VERSION);
+
+	res = fuse_fs_init();
+	if(res)
+		goto err;
+	
+	res = fuse_dev_init();
+	if(res)
+		goto err_fs_cleanup;
+	
+	return 0;
+
+  err_fs_cleanup:
+	fuse_fs_cleanup();
+  err:
+	return res;
+}
+
+void __exit fuse_exit(void)
+{
+	printk(KERN_DEBUG "fuse exit\n");
+	
+	fuse_fs_cleanup();
+	fuse_dev_cleanup();
+}
+
+module_init(fuse_init);
+module_exit(fuse_exit);
+
+/*
+ * Local Variables:
+ * indent-tabs-mode: t
+ * c-basic-offset: 8
+ * End:
+ */
Index: xx-sources/include/linux/fuse.h
===================================================================
--- xx-sources.orig/include/linux/fuse.h	2004-05-31 17:36:38.000000000 -0400
+++ xx-sources/include/linux/fuse.h	2004-08-24 22:29:39.526158608 -0400
@@ -0,0 +1,230 @@
+/*
+    FUSE: Filesystem in Userspace
+    Copyright (C) 2001-2004  Miklos Szeredi <miklos@szeredi.hu>
+
+    This program can be distributed under the terms of the GNU GPL.
+    See the file COPYING.
+*/
+
+/* This file defines the kernel interface of FUSE */
+#define FUSE_VERSION "1.3"
+
+/** Version number of this interface */
+#define FUSE_KERNEL_VERSION 2
+
+/** Minor version number of this interface */
+#define FUSE_KERNEL_MINOR_VERSION 2
+
+/** The inode number of the root indode */
+#define FUSE_ROOT_INO 1
+
+/** Opening this will yield a new control file */
+#define FUSE_DEV "/proc/fs/fuse/dev"
+
+/** Data passed to mount */
+struct fuse_mount_data {
+	/** Must be set to FUSE_KERNEL_VERSION */
+	int version;
+	
+	/** The control file descriptor */
+	int fd;
+	
+	/** The file type of the root inode */
+	unsigned int rootmode;
+
+	/** The user ID of the user initiating this mount */
+	unsigned int uid;
+	
+	/** FUSE specific mount flags */
+	unsigned int flags;
+};
+
+/* FUSE mount flags: */
+
+/** If the FUSE_DEFAULT_PERMISSIONS flag is given, the filesystem
+module will check permissions based on the file mode.  Otherwise no
+permission checking is done in the kernel */
+#define FUSE_DEFAULT_PERMISSIONS (1 << 0)
+
+/** If the FUSE_ALLOW_OTHER flag is given, then not only the user
+    doing the mount will be allowed to access the filesystem */
+#define FUSE_ALLOW_OTHER         (1 << 1)
+
+/** If the FUSE_KERNEL_CACHE flag is given, then files will be cached
+    until the INVALIDATE operation is invoked */
+#define FUSE_KERNEL_CACHE        (1 << 2)
+
+/** Allow FUSE to combine reads into 64k chunks.  This is useful if
+    the filesystem is better at handling large chunks.  NOTE: in
+    current implementation the raw throughput is worse for large reads
+    than for small. */
+#define FUSE_LARGE_READ          (1 << 3)
+
+struct fuse_attr {
+	unsigned int        mode;
+	unsigned int        nlink;
+	unsigned int        uid;
+	unsigned int        gid;
+	unsigned int        rdev;
+	unsigned long long  size;
+	unsigned long       _dummy;
+	unsigned long       blocks;
+	unsigned long       atime;
+	unsigned long       mtime;
+	unsigned long       ctime;
+};
+
+struct fuse_kstatfs {
+    long block_size;
+    long blocks;
+    long blocks_free;
+    long files;
+    long files_free;
+    long namelen;
+};
+
+#define FATTR_MODE	(1 << 0)
+#define FATTR_UID	(1 << 1)
+#define FATTR_GID	(1 << 2)
+#define FATTR_SIZE	(1 << 3)
+#define FATTR_UTIME	(1 << 4)
+
+enum fuse_opcode {
+	FUSE_LOOKUP	= 1,
+	FUSE_FORGET	= 2,  /* no reply */
+	FUSE_GETATTR	= 3,
+	FUSE_SETATTR	= 4,
+	FUSE_READLINK	= 5,
+	FUSE_SYMLINK	= 6,
+	FUSE_GETDIR	= 7,
+	FUSE_MKNOD	= 8,
+	FUSE_MKDIR	= 9,
+	FUSE_UNLINK	= 10,
+	FUSE_RMDIR	= 11,
+	FUSE_RENAME	= 12,
+	FUSE_LINK	= 13,
+	FUSE_OPEN	= 14,
+	FUSE_READ	= 15,
+	FUSE_WRITE	= 16,
+	FUSE_STATFS	= 17,
+	FUSE_RELEASE    = 18, /* no reply */
+	FUSE_INVALIDATE = 19, /* user initiated */
+	FUSE_FSYNC      = 20,
+	FUSE_RELEASE2   = 21  /* reply needed after all */
+};
+
+/* Conservative buffer size for the client */
+#define FUSE_MAX_IN 8192
+
+#define FUSE_NAME_MAX 1024
+#define FUSE_SYMLINK_MAX 4096
+
+struct fuse_lookup_out {
+	unsigned long ino;
+	struct fuse_attr attr;
+};
+
+struct fuse_forget_in {
+	int version;
+};
+
+struct fuse_getattr_out {
+	struct fuse_attr attr;
+};
+
+struct fuse_getdir_out {
+	int fd;
+	void *file; /* Used by kernel only */
+};
+
+/* FIXME: 2.6 needs 32 bit rdev */
+struct fuse_mknod_in {
+	unsigned short mode;
+	unsigned short rdev;
+};
+
+struct fuse_mknod_out {
+	unsigned long ino;
+	struct fuse_attr attr;
+};
+
+struct fuse_mkdir_in {
+	unsigned short mode;
+};
+
+struct fuse_rename_in {
+	unsigned long newdir;
+};
+
+struct fuse_link_in {
+	unsigned long newdir;
+};
+
+struct fuse_setattr_in {
+	struct fuse_attr attr;
+	unsigned int valid;
+};
+
+struct fuse_setattr_out {
+	struct fuse_attr attr;
+};
+
+struct fuse_open_in {
+	unsigned int flags;
+};
+
+struct fuse_read_in {
+	unsigned long long offset;
+	unsigned int size;
+};
+
+struct fuse_write_in {
+	unsigned long long offset;
+	unsigned int size;
+};
+
+struct fuse_statfs_out {
+	struct fuse_kstatfs st;
+};
+
+struct fuse_fsync_in {
+	int datasync;
+};
+
+struct fuse_in_header {
+	int unique;
+	enum fuse_opcode opcode;
+	unsigned long ino;
+	unsigned int uid;
+	unsigned int gid;
+};
+
+struct fuse_out_header {
+	int unique;
+	int error;
+};
+
+struct fuse_user_header {
+	int unique; /* zero */
+	enum fuse_opcode opcode;
+	unsigned long ino;
+};
+
+struct fuse_dirent {
+	unsigned long ino;
+	unsigned short namelen;
+	unsigned char type;
+	char name[256];
+};
+
+#define FUSE_NAME_OFFSET ((unsigned int) ((struct fuse_dirent *) 0)->name)
+#define FUSE_DIRENT_ALIGN(x) (((x) + sizeof(long) - 1) & ~(sizeof(long) - 1))
+#define FUSE_DIRENT_SIZE(d) \
+	FUSE_DIRENT_ALIGN(FUSE_NAME_OFFSET + (d)->namelen)
+
+/* 
+ * Local Variables:
+ * indent-tabs-mode: t
+ * c-basic-offset: 8
+ * End:
+ */
