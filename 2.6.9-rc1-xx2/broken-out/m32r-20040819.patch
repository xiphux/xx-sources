diff -ruN linux-2.6.7.org/arch/m32r/Kconfig linux-2.6.7/arch/m32r/Kconfig
--- linux-2.6.7.org/arch/m32r/Kconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/Kconfig	2004-07-27 15:54:20.000000000 +0900
@@ -0,0 +1,621 @@
+#
+# For a description of the syntax of this configuration file,
+# see Documentation/kbuild/kconfig-language.txt.
+#
+
+mainmenu "Linux Kernel Configuration"
+
+config M32R
+	bool
+	default y
+
+config SBUS
+	bool
+
+config UID16
+	bool
+	default y
+
+config GENERIC_ISA_DMA
+	bool
+	default y
+
+source "init/Kconfig"
+
+
+menu "Processor type and features"
+
+choice
+	prompt "Platform Type"
+	default PLAT_MAPPI
+
+config PLAT_MAPPI
+	bool "Mappi-I"
+	help
+	  The Mappi-I is an FPGA board for SOC (System-On-a-Chip) prototyping.
+	  You can operate a Linux system on this board by using an M32R
+	  softmacro core, which is a fully-synthesizable functional model 
+	  described in Verilog-HDL.
+
+	  The Mappi-I board was the first platform, which had been used 
+	  to port and develop a Linux system for the M32R processor.  
+	  Currently, the Mappi-II, an heir to the Mappi-I, is available.
+
+config PLAT_USRV
+	bool "uServer"
+
+config PLAT_M32700UT
+	bool "M32700UT"
+	help
+	  The M3T-M32700UT is an evaluation board based on uT-Engine
+	  specification.  This board has an M32700 (Chaos) evaluation chip.
+	  You can say Y for SMP, because the M32700 is a single chip 
+	  multiprocessor.
+
+config PLAT_OPSPUT
+	bool "OPSPUT"
+	help
+	  The OPSPUT is an evaluation board based on uT-Engine
+	  specification.  This board has a OPSP-REP chip.
+
+config PLAT_OAKS32R
+	bool "OAKS32R"
+	help
+	  The OAKS32R is a tiny, inexpensive evaluation board.
+	  Please note that if you say Y here and choose chip "M32102", 
+	  say N for MMU and select a no-MMU version kernel, otherwise 
+	  a kernel with MMU support will not work, because the M32102 
+	  is a microcontroller for embedded systems and it has no MMU.
+
+config PLAT_MAPPI2
+       bool "Mappi-II(M3A-ZA36/M3A-ZA52)"
+
+endchoice
+
+choice
+	prompt "Processor family"
+	default CHIP_M32700
+
+config CHIP_M32700
+	bool "M32700 (Chaos)"
+
+config CHIP_M32102
+	bool "M32102"
+
+config CHIP_VDEC2
+       bool "VDEC2"
+
+config CHIP_OPSP
+       bool "OPSP"
+
+endchoice
+
+config MMU
+	bool "Support for memory management hardware"
+	depends on CHIP_M32700 || CHIP_VDEC2 || CHIP_OPSP
+	default y
+
+config TLB_ENTRIES
+       int "TLB Entries"
+       depends on CHIP_M32700 || CHIP_VDEC2 || CHIP_OPSP
+       default 32 if CHIP_M32700 || CHIP_OPSP
+       default 16 if CHIP_VDEC2 
+       
+
+config ISA_M32R
+        bool
+	depends on CHIP_M32102
+	default y
+
+config ISA_M32R2
+	bool
+	depends on CHIP_M32700 || CHIP_VDEC2 || CHIP_OPSP
+	default y
+
+config ISA_DSP_LEVEL2
+	bool
+	depends on CHIP_M32700 || CHIP_OPSP
+	default y
+
+config ISA_DUAL_ISSUE
+	bool
+	depends on CHIP_M32700 || CHIP_OPSP
+	default y
+
+config BUS_CLOCK
+	int "Bus Clock [Hz] (integer)"
+	default "70000000" if PLAT_MAPPI
+	default "25000000" if PLAT_USRV
+	default "50000000" if PLAT_M32700UT
+	default "50000000" if PLAT_OPSPUT
+	default "33333333" if PLAT_OAKS32R
+	default "20000000" if PLAT_MAPPI2
+
+config TIMER_DIVIDE
+	int "Timer divider (integer)"
+	default "128"
+
+config CPU_LITTLE_ENDIAN
+        bool "Generate little endian code"
+	default n
+
+config MEMORY_START
+	hex "Physical memory start address (hex)"
+	default "08000000" if PLAT_MAPPI || PLAT_MAPPI2
+	default "08000000" if PLAT_USRV
+	default "08000000" if PLAT_M32700UT
+	default "08000000" if PLAT_OPSPUT
+	default "01000000" if PLAT_OAKS32R
+
+config MEMORY_SIZE
+	hex "Physical memory size (hex)"
+	default "04000000" if PLAT_MAPPI || PLAT_MAPPI2
+	default "02000000" if PLAT_USRV
+	default "01000000" if PLAT_M32700UT
+	default "01000000" if PLAT_OPSPUT
+	default "00800000" if PLAT_OAKS32R
+
+config NOHIGHMEM
+	bool
+	default y
+
+config DISCONTIGMEM
+	bool "Internal RAM Support"
+	depends on CHIP_M32700 || CHIP_M32102 || CHIP_VDEC2 || CHIP_OPSP
+	default y
+
+config IRAM_START
+	hex "Internal memory start address (hex)"
+	default "00f00000"
+	depends on (CHIP_M32700 || CHIP_M32102 || CHIP_VDEC2 || CHIP_OPSP) && DISCONTIGMEM
+
+config IRAM_SIZE
+	hex "Internal memory size (hex)"
+	depends on (CHIP_M32700 || CHIP_M32102 || CHIP_VDEC2 || CHIP_OPSP) && DISCONTIGMEM
+	default "00080000" if CHIP_M32700 
+	default "00010000" if CHIP_M32102 || CHIP_OPSP
+	default "00008000" if CHIP_VDEC2
+
+#
+# Define implied options from the CPU selection here
+#
+
+config RWSEM_GENERIC_SPINLOCK
+	bool
+	depends on M32R
+	default y
+
+config RWSEM_XCHGADD_ALGORITHM
+	bool
+	default n
+
+config PREEMPT
+	bool "Preemptible Kernel"
+	help
+	  This option reduces the latency of the kernel when reacting to
+	  real-time or interactive events by allowing a low priority process to
+	  be preempted even if it is in kernel mode executing a system call.
+	  This allows applications to run more reliably even when the system is
+	  under load.
+
+	  Say Y here if you are building a kernel for a desktop, embedded
+	  or real-time system.  Say N if you are unsure.
+
+config HAVE_DEC_LOCK
+	bool
+	depends on (SMP || PREEMPT)
+	default n
+
+config SMP
+	bool "Symmetric multi-processing support"
+	---help---
+	  This enables support for systems with more than one CPU. If you have
+	  a system with only one CPU, like most personal computers, say N. If
+	  you have a system with more than one CPU, say Y.
+
+	  If you say N here, the kernel will run on single and multiprocessor
+	  machines, but will use only one CPU of a multiprocessor machine. If
+	  you say Y here, the kernel will run on many, but not all,
+	  singleprocessor machines. On a singleprocessor machine, the kernel
+	  will run faster if you say N here.
+
+	  Note that if you say Y here and choose architecture "586" or
+	  "Pentium" under "Processor family", the kernel will not work on 486
+	  architectures. Similarly, multiprocessor kernels for the "PPro"
+	  architecture may not work on all Pentium based boards.
+
+	  People using multiprocessor machines who say Y here should also say
+	  Y to "Enhanced Real Time Clock Support", below. The "Advanced Power
+	  Management" code will be disabled if you say Y here.
+
+	  See also the <file:Documentation/smp.tex>,
+	  <file:Documentation/smp.txt>, <file:Documentation/i386/IO-APIC.txt>,
+	  <file:Documentation/nmi_watchdog.txt> and the SMP-HOWTO available at
+	  <http://www.linuxdoc.org/docs.html#howto>.
+
+	  If you don't know what to do here, say N.
+
+config CHIP_M32700_TS1
+	bool "Workaround code for the M32700 TS1 chip's bug"
+	depends on (CHIP_M32700 && SMP)
+	default n
+
+config NR_CPUS
+	int "Maximum number of CPUs (2-32)"
+	range 2 32
+	depends on SMP
+	default "2"
+	help
+	  This allows you to specify the maximum number of CPUs which this
+	  kernel will support.  The maximum supported value is 32 and the
+	  minimum value which makes sense is 2.
+
+	  This is purely to save memory - each supported CPU adds
+	  approximately eight kilobytes to the kernel image.
+
+# Common NUMA Features
+config NUMA
+	bool "Numa Memory Allocation Support"
+	depends on SMP
+	default n
+
+source "arch/m32r/drivers/Kconfig"
+
+# turning this on wastes a bunch of space.
+# Summit needs it only when NUMA is on
+config BOOT_IOREMAP
+	bool
+	depends on NUMA
+	default n
+
+endmenu
+
+
+menu "Power management options (ACPI, APM)"
+
+source kernel/power/Kconfig
+
+config APM
+	tristate "Advanced Power Management BIOS support"
+	depends on PM
+	---help---
+	  APM is a BIOS specification for saving power using several different
+	  techniques. This is mostly useful for battery powered laptops with
+	  APM compliant BIOSes. If you say Y here, the system time will be
+	  reset after a RESUME operation, the /proc/apm device will provide
+	  battery status information, and user-space programs will receive
+	  notification of APM "events" (e.g. battery status change).
+
+	  If you select "Y" here, you can disable actual use of the APM
+	  BIOS by passing the "apm=off" option to the kernel at boot time.
+
+	  Note that the APM support is almost completely disabled for
+	  machines with more than one CPU.
+
+	  In order to use APM, you will need supporting software. For location
+	  and more information, read <file:Documentation/pm.txt> and the
+	  Battery Powered Linux mini-HOWTO, available from
+	  <http://www.linuxdoc.org/docs.html#howto>.
+
+	  This driver does not spin down disk drives (see the hdparm(8)
+	  manpage ("man 8 hdparm") for that), and it doesn't turn off
+	  VESA-compliant "green" monitors.
+
+	  This driver does not support the TI 4000M TravelMate and the ACER
+	  486/DX4/75 because they don't have compliant BIOSes. Many "green"
+	  desktop machines also don't have compliant BIOSes, and this driver
+	  may cause those machines to panic during the boot phase.
+
+	  Generally, if you don't have a battery in your machine, there isn't
+	  much point in using this driver and you should say N. If you get
+	  random kernel OOPSes or reboots that don't seem to be related to
+	  anything, try disabling/enabling this option (or disabling/enabling
+	  APM in your BIOS).
+
+	  Some other things you should try when experiencing seemingly random,
+	  "weird" problems:
+
+	  1) make sure that you have enough swap space and that it is
+	  enabled.
+	  2) pass the "no-hlt" option to the kernel
+	  3) switch on floating point emulation in the kernel and pass
+	  the "no387" option to the kernel
+	  4) pass the "floppy=nodma" option to the kernel
+	  5) pass the "mem=4M" option to the kernel (thereby disabling
+	  all but the first 4 MB of RAM)
+	  6) make sure that the CPU is not over clocked.
+	  7) read the sig11 FAQ at <http://www.bitwizard.nl/sig11/>
+	  8) disable the cache from your BIOS settings
+	  9) install a fan for the video card or exchange video RAM
+	  10) install a better fan for the CPU
+	  11) exchange RAM chips
+	  12) exchange the motherboard.
+
+	  To compile this driver as a module ( = code which can be inserted in
+	  and removed from the running kernel whenever you want), say M here
+	  and read <file:Documentation/modules.txt>. The module will be called
+	  apm.
+
+config APM_IGNORE_USER_SUSPEND
+	bool "Ignore USER SUSPEND"
+	depends on APM
+	help
+	  This option will ignore USER SUSPEND requests. On machines with a
+	  compliant APM BIOS, you want to say N. However, on the NEC Versa M
+	  series notebooks, it is necessary to say Y because of a BIOS bug.
+
+config APM_DO_ENABLE
+	bool "Enable PM at boot time"
+	depends on APM
+	---help---
+	  Enable APM features at boot time. From page 36 of the APM BIOS
+	  specification: "When disabled, the APM BIOS does not automatically
+	  power manage devices, enter the Standby State, enter the Suspend
+	  State, or take power saving steps in response to CPU Idle calls."
+	  This driver will make CPU Idle calls when Linux is idle (unless this
+	  feature is turned off -- see "Do CPU IDLE calls", below). This
+	  should always save battery power, but more complicated APM features
+	  will be dependent on your BIOS implementation. You may need to turn
+	  this option off if your computer hangs at boot time when using APM
+	  support, or if it beeps continuously instead of suspending. Turn
+	  this off if you have a NEC UltraLite Versa 33/C or a Toshiba
+	  T400CDT. This is off by default since most machines do fine without
+	  this feature.
+
+config APM_CPU_IDLE
+	bool "Make CPU Idle calls when idle"
+	depends on APM
+	help
+	  Enable calls to APM CPU Idle/CPU Busy inside the kernel's idle loop.
+	  On some machines, this can activate improved power savings, such as
+	  a slowed CPU clock rate, when the machine is idle. These idle calls
+	  are made after the idle loop has run for some length of time (e.g.,
+	  333 mS). On some machines, this will cause a hang at boot time or
+	  whenever the CPU becomes idle. (On machines with more than one CPU,
+	  this option does nothing.)
+
+config APM_DISPLAY_BLANK
+	bool "Enable console blanking using APM"
+	depends on APM
+	help
+	  Enable console blanking using the APM. Some laptops can use this to
+	  turn off the LCD backlight when the screen blanker of the Linux
+	  virtual console blanks the screen. Note that this is only used by
+	  the virtual console screen blanker, and won't turn off the backlight
+	  when using the X Window system. This also doesn't have anything to
+	  do with your VESA-compliant power-saving monitor. Further, this
+	  option doesn't work for all laptops -- it might not turn off your
+	  backlight at all, or it might print a lot of errors to the console,
+	  especially if you are using gpm.
+
+config APM_RTC_IS_GMT
+	bool "RTC stores time in GMT"
+	depends on APM
+	help
+	  Say Y here if your RTC (Real Time Clock a.k.a. hardware clock)
+	  stores the time in GMT (Greenwich Mean Time). Say N if your RTC
+	  stores localtime.
+
+	  It is in fact recommended to store GMT in your RTC, because then you
+	  don't have to worry about daylight savings time changes. The only
+	  reason not to use GMT in your RTC is if you also run a broken OS
+	  that doesn't understand GMT.
+
+config APM_ALLOW_INTS
+	bool "Allow interrupts during APM BIOS calls"
+	depends on APM
+	help
+	  Normally we disable external interrupts while we are making calls to
+	  the APM BIOS as a measure to lessen the effects of a badly behaving
+	  BIOS implementation.  The BIOS should reenable interrupts if it
+	  needs to.  Unfortunately, some BIOSes do not -- especially those in
+	  many of the newer IBM Thinkpads.  If you experience hangs when you
+	  suspend, try setting this to Y.  Otherwise, say N.
+
+config APM_REAL_MODE_POWER_OFF
+	bool "Use real mode APM BIOS call to power off"
+	depends on APM
+	help
+	  Use real mode APM BIOS calls to switch off the computer. This is
+	  a work-around for a number of buggy BIOSes. Switch this option on if
+	  your computer crashes instead of powering off properly.
+
+endmenu
+
+
+menu "Bus options (PCI, PCMCIA, EISA, MCA, ISA)"
+
+config PCI
+	bool "PCI support"
+	default n
+	help
+	  Find out whether you have a PCI motherboard. PCI is the name of a
+	  bus system, i.e. the way the CPU talks to the other stuff inside
+	  your box. Other bus systems are ISA, EISA, MicroChannel (MCA) or
+	  VESA. If you have PCI, say Y, otherwise N.
+
+	  The PCI-HOWTO, available from
+	  <http://www.linuxdoc.org/docs.html#howto>, contains valuable
+	  information about which PCI hardware does work under Linux and which
+	  doesn't.
+
+choice
+	prompt "PCI access mode"
+	depends on PCI
+	default PCI_GOANY
+
+config PCI_GOBIOS
+	bool "BIOS"
+	---help---
+	  On PCI systems, the BIOS can be used to detect the PCI devices and
+	  determine their configuration. However, some old PCI motherboards
+	  have BIOS bugs and may crash if this is done. Also, some embedded
+	  PCI-based systems don't have any BIOS at all. Linux can also try to
+	  detect the PCI hardware directly without using the BIOS.
+
+	  With this option, you can specify how Linux should detect the PCI
+	  devices. If you choose "BIOS", the BIOS will be used, if you choose
+	  "Direct", the BIOS won't be used, and if you choose "Any", the
+	  kernel will try the direct access method and falls back to the BIOS
+	  if that doesn't work. If unsure, go with the default, which is
+	  "Any".
+
+config PCI_GODIRECT
+	bool "Direct"
+
+config PCI_GOANY
+	bool "Any"
+
+endchoice
+
+config PCI_BIOS
+	bool
+	depends on PCI && (PCI_GOBIOS || PCI_GOANY)
+	default y
+
+config PCI_DIRECT
+	bool
+ 	depends on PCI && (PCI_GODIRECT || PCI_GOANY)
+	default y
+
+source "drivers/pci/Kconfig"
+
+config ISA
+	bool "ISA support"
+	help
+	  Find out whether you have ISA slots on your motherboard.  ISA is the
+	  name of a bus system, i.e. the way the CPU talks to the other stuff
+	  inside your box.  Other bus systems are PCI, EISA, MicroChannel
+	  (MCA) or VESA.  ISA is an older system, now being displaced by PCI;
+	  newer boards don't support it.  If you have ISA, say Y, otherwise N.
+
+config EISA
+	bool "EISA support"
+	depends on ISA
+	---help---
+	  The Extended Industry Standard Architecture (EISA) bus was
+	  developed as an open alternative to the IBM MicroChannel bus.
+
+	  The EISA bus provided some of the features of the IBM MicroChannel
+	  bus while maintaining backward compatibility with cards made for
+	  the older ISA bus.  The EISA bus saw limited use between 1988 and
+	  1995 when it was made obsolete by the PCI bus.
+
+	  Say Y here if you are building a kernel for an EISA-based machine.
+
+	  Otherwise, say N.
+
+source "drivers/eisa/Kconfig"
+
+source "drivers/pcmcia/Kconfig"
+
+source "drivers/pci/hotplug/Kconfig"
+
+endmenu
+
+
+menu "Executable file formats"
+
+source "fs/Kconfig.binfmt"
+
+endmenu
+
+source "drivers/Kconfig"
+
+source "fs/Kconfig"
+
+source "arch/m32r/oprofile/Kconfig"
+
+menu "Kernel hacking"
+
+config DEBUG_KERNEL
+	bool "Kernel debugging"
+	help
+	  Say Y here if you are developing drivers or trying to debug and
+	  identify kernel problems.
+
+config DEBUG_STACKOVERFLOW
+	bool "Check for stack overflows"
+	depends on DEBUG_KERNEL
+
+config DEBUG_SLAB
+	bool "Debug memory allocations"
+	depends on DEBUG_KERNEL
+	help
+	  Say Y here to have the kernel do limited verification on memory
+	  allocation as well as poisoning memory on free to catch use of freed
+	  memory.
+
+config DEBUG_IOVIRT
+	bool "Memory mapped I/O debugging"
+	depends on DEBUG_KERNEL
+	help
+	  Say Y here to get warned whenever an attempt is made to do I/O on
+	  obviously invalid addresses such as those generated when ioremap()
+	  calls are forgotten.  Memory mapped I/O will go through an extra
+	  check to catch access to unmapped ISA addresses, an access method
+	  that can still be used by old drivers that are being ported from
+	  2.0/2.2.
+
+config MAGIC_SYSRQ
+	bool "Magic SysRq key"
+	depends on DEBUG_KERNEL
+	help
+	  If you say Y here, you will have some control over the system even
+	  if the system crashes for example during kernel debugging (e.g., you
+	  will be able to flush the buffer cache to disk, reboot the system
+	  immediately or dump some status information). This is accomplished
+	  by pressing various keys while holding SysRq (Alt+PrintScreen). It
+	  also works on a serial console (on PC hardware at least), if you
+	  send a BREAK and then within 5 seconds a command keypress. The
+	  keys are documented in <file:Documentation/sysrq.txt>. Don't say Y
+	  unless you really know what this hack does.
+
+config DEBUG_SPINLOCK
+	bool "Spinlock debugging"
+	depends on DEBUG_KERNEL
+	help
+	  Say Y here and build SMP to catch missing spinlock initialization
+	  and certain other kinds of spinlock errors commonly made.  This is
+	  best used in conjunction with the NMI watchdog so that spinlock
+	  deadlocks are also debuggable.
+
+config DEBUG_PAGEALLOC
+	bool "Page alloc debugging"
+	depends on DEBUG_KERNEL
+	help
+	  Unmap pages from the kernel linear mapping after free_pages().
+	  This results in a large slowdown, but helps to find certain types
+	  of memory corruptions.
+
+config DEBUG_INFO
+	bool "Compile the kernel with debug info"
+	depends on DEBUG_KERNEL
+	help
+          If you say Y here the resulting kernel image will include
+	  debugging info resulting in a larger kernel image.
+	  Say Y here only if you plan to use gdb to debug the kernel.
+	  If you don't debug the kernel, you can say N.
+
+config DEBUG_SPINLOCK_SLEEP
+	bool "Sleep-inside-spinlock checking"
+	help
+	  If you say Y here, various routines which may sleep will become very
+	  noisy if they are called with a spinlock held.	
+
+config FRAME_POINTER
+	bool "Compile the kernel with frame pointers"
+	help
+	  If you say Y here the resulting kernel image will be slightly larger
+	  and slower, but it will give very useful debugging information.
+	  If you don't debug the kernel, you can say N, but we may not be able
+	  to solve problems without frame pointers.
+
+endmenu
+
+source "security/Kconfig"
+
+source "crypto/Kconfig"
+
+source "lib/Kconfig"
+
diff -ruN linux-2.6.7.org/arch/m32r/Makefile linux-2.6.7/arch/m32r/Makefile
--- linux-2.6.7.org/arch/m32r/Makefile	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/Makefile	2004-04-23 16:09:37.000000000 +0900
@@ -0,0 +1,38 @@
+#
+# m32r/Makefile
+# 
+
+LDFLAGS		:=
+OBJCOPYFLAGS	:= -O binary -R .note -R .comment -S
+LDFLAGS_vmlinux	:= -e startup_32
+LDFLAGS_BLOB	:= --format binary --oformat elf32-m32r
+
+CFLAGS += -pipe -fno-schedule-insns
+CFLAGS_KERNEL += -mmodel=medium
+CFLAGS_MODULE += -mmodel=large
+
+ifdef CONFIG_CHIP_VDEC2
+cflags-$(CONFIG_ISA_M32R2)	+= -DNO_FPU -Wa,-bitinst
+aflags-$(CONFIG_ISA_M32R2)	+= -DNO_FPU -Wa,-bitinst
+else
+cflags-$(CONFIG_ISA_M32R2)	+= -DNO_FPU -m32r2
+aflags-$(CONFIG_ISA_M32R2)	+= -DNO_FPU -m32r2
+endif
+
+cflags-$(CONFIG_ISA_M32R)	+= -DNO_FPU 
+aflags-$(CONFIG_ISA_M32R)	+= -DNO_FPU -Wa,-no-bitinst
+
+CFLAGS += $(cflags-y)
+AFLAGS += $(aflags-y)
+
+head-y	:= arch/m32r/kernel/head.o arch/m32r/kernel/init_task.o
+
+LIBGCC	:= $(shell $(CC) $(CFLAGS) -print-libgcc-file-name)
+
+libs-y	+= arch/m32r/lib/ $(LIBGCC)
+core-y	+= arch/m32r/kernel/	\
+	   arch/m32r/mm/	\
+	   arch/m32r/boot/	\
+	   arch/m32r/drivers/
+drivers-$(CONFIG_OPROFILE)	+= arch/m32r/oprofile/
+
diff -ruN linux-2.6.7.org/arch/m32r/boot/Makefile linux-2.6.7/arch/m32r/boot/Makefile
--- linux-2.6.7.org/arch/m32r/boot/Makefile	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/boot/Makefile	2004-07-29 22:07:12.000000000 +0900
@@ -0,0 +1,19 @@
+#
+# arch/m32r/boot/Makefile
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License.  See the file "COPYING" in the main directory of this archive
+# for more details.
+
+targets := zImage
+subdir- := compressed
+
+obj-y	:= setup.o
+
+$(obj)/zImage: $(obj)/compressed/vmlinux FORCE
+	$(call if_changed,objcopy)
+	@echo 'Kernel: $@ is ready'
+
+$(obj)/compressed/vmlinux: FORCE
+	$(Q)$(MAKE) $(build)=$(obj)/compressed $@
+
diff -ruN linux-2.6.7.org/arch/m32r/boot/compressed/Makefile linux-2.6.7/arch/m32r/boot/compressed/Makefile
--- linux-2.6.7.org/arch/m32r/boot/compressed/Makefile	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/boot/compressed/Makefile	2004-07-29 22:07:12.000000000 +0900
@@ -0,0 +1,37 @@
+#
+# linux/arch/sh/boot/compressed/Makefile
+#
+# create a compressed vmlinux image from the original vmlinux
+#
+
+targets		:= vmlinux vmlinux.bin vmlinux.bin.gz head.o misc.o \
+		   m32r-sio.o piggy.o vmlinux.lds.s
+EXTRA_AFLAGS	:= -traditional
+
+OBJECTS = $(obj)/head.o $(obj)/misc.o $(obj)/m32r_sio.o
+
+#
+# IMAGE_OFFSET is the load offset of the compression loader
+#
+IMAGE_OFFSET := $(shell printf "0x%08x" $$[$(CONFIG_MEMORY_START)+0x1000])
+
+LDFLAGS_vmlinux := -Ttext $(IMAGE_OFFSET) -e startup -T 
+
+$(obj)/vmlinux: $(obj)/vmlinux.lds.s $(OBJECTS) $(obj)/piggy.o FORCE
+	$(call if_changed,ld)
+	@:
+
+$(obj)/vmlinux.bin: vmlinux FORCE
+	$(call if_changed,objcopy)
+
+$(obj)/vmlinux.bin.gz: $(obj)/vmlinux.bin FORCE
+	$(call if_changed,gzip)
+
+$(obj)/vmlinux.lds.s: $(obj)/vmlinux.lds.S FORCE
+	$(CPP) -E -P $< >$@
+
+LDFLAGS_piggy.o := -r --format binary --oformat elf32-m32r-linux -T
+#OBJCOPYFLAGS += -R .empty_zero_page
+
+$(obj)/piggy.o: $(obj)/vmlinux.scr $(obj)/vmlinux.bin.gz FORCE
+	$(call if_changed,ld)
diff -ruN linux-2.6.7.org/arch/m32r/boot/compressed/boot.h linux-2.6.7/arch/m32r/boot/compressed/boot.h
--- linux-2.6.7.org/arch/m32r/boot/compressed/boot.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/boot/compressed/boot.h	2003-09-09 10:15:02.000000000 +0900
@@ -0,0 +1,59 @@
+/*
+ * 1. load vmlinuz
+ *
+ * CONFIG_MEMORY_START  	+-----------------------+
+ *				|        vmlinuz	|
+ *				+-----------------------+
+ * 2. decompressed
+ *
+ * CONFIG_MEMORY_START  	+-----------------------+
+ *				|        vmlinuz	|
+ *				+-----------------------+
+ *				|			|
+ * BOOT_RELOC_ADDR		+-----------------------+
+ *				|		 	|
+ * KERNEL_DECOMPRESS_ADDR 	+-----------------------+
+ *				|  	vmlinux		|
+ *				+-----------------------+
+ *
+ * 3. relocate copy & jump code
+ *		
+ * CONFIG_MEMORY_START  	+-----------------------+
+ *				|        vmlinuz	|
+ *				+-----------------------+
+ *				|			|
+ * BOOT_RELOC_ADDR		+-----------------------+
+ *				|    boot(copy&jump)	|
+ * KERNEL_DECOMPRESS_ADDR 	+-----------------------+
+ *				|  	vmlinux		|
+ *				+-----------------------+
+ *
+ * 4. relocate decompressed kernel
+ *
+ * CONFIG_MEMORY_START  	+-----------------------+
+ *				|        vmlinux	|
+ *				+-----------------------+
+ *				|			|
+ * BOOT_RELOC_ADDR		+-----------------------+
+ *				|     boot(copy&jump) 	|
+ * KERNEL_DECOMPRESS_ADDR 	+-----------------------+
+ *				|  			|
+ *				+-----------------------+
+ *
+ */
+#ifdef __ASSEMBLY__
+#define __val(x)	x
+#else
+#define __val(x)	(x)
+#endif
+
+#define DECOMPRESS_OFFSET_BASE	__val(0x00900000)
+#define BOOT_RELOC_SIZE		__val(0x00001000)
+
+#define KERNEL_EXEC_ADDR	__val(CONFIG_MEMORY_START)
+#define KERNEL_DECOMPRESS_ADDR	__val(CONFIG_MEMORY_START + \
+				      DECOMPRESS_OFFSET_BASE + BOOT_RELOC_SIZE)
+#define KERNEL_ENTRY		__val(CONFIG_MEMORY_START + 0x1000)
+
+#define BOOT_EXEC_ADDR		__val(CONFIG_MEMORY_START)
+#define BOOT_RELOC_ADDR		__val(CONFIG_MEMORY_START + DECOMPRESS_OFFSET_BASE)
diff -ruN linux-2.6.7.org/arch/m32r/boot/compressed/head.S linux-2.6.7/arch/m32r/boot/compressed/head.S
--- linux-2.6.7.org/arch/m32r/boot/compressed/head.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/boot/compressed/head.S	2004-07-29 22:07:12.000000000 +0900
@@ -0,0 +1,202 @@
+/*
+ *  linux/arch/m32r/boot/compressed/head.S
+ *
+ *  Copyright (c) 2001-2003	Hiroyuki Kondo, Hirokazu Takata,
+ *				Hitoshi Yamamoto, Takeo Takahashi
+ */
+
+	.text
+#include <linux/config.h>
+#include <linux/linkage.h>
+#include <asm/addrspace.h>
+#include <asm/page.h>
+#include <asm/assembler.h>
+#include "boot.h"
+
+	.global	startup
+	__ALIGN
+startup:
+	ldi	r0, #0x0000			/* SPI, disable EI */
+	mvtc	r0, psw
+
+/*
+ * Clear BSS first so that there are no surprises...
+ */
+#ifdef CONFIG_ISA_DUAL_ISSUE
+
+	LDIMM	(r2, __bss_start)
+	LDIMM	(r3, _end)
+	sub	r3, r2		; BSS size in bytes
+	; R4 = BSS size in longwords (rounded down)
+	mv	r4, r3		    ||	ldi	r1, #0
+	srli	r4, #4		    ||	addi	r2, #-4	
+	beqz	r4, .Lendloop1
+.Lloop1:	
+#ifndef CONFIG_CHIP_M32310
+	; Touch memory for the no-write-allocating cache.
+	ld	r0, @(4,r2)
+#endif
+	st	r1, @+r2	    ||	addi	r4, #-1
+	st	r1, @+r2
+	st	r1, @+r2
+	st	r1, @+r2	    ||	cmpeq	r1, r4	; R4 = 0?
+	bnc	.Lloop1
+.Lendloop1:
+	and3	r4, r3, #15
+	addi	r2, #4
+	beqz	r4, .Lendloop2
+.Lloop2:
+	stb	r1, @r2		    ||	addi	r4, #-1
+	addi	r2, #1
+	bnez	r4, .Lloop2
+.Lendloop2:
+
+#else /* not CONFIG_ISA_DUAL_ISSUE */
+
+	LDIMM	(r2, __bss_start)
+	LDIMM	(r3, _end)
+	sub	r3, r2		; BSS size in bytes
+	mv	r4, r3
+	srli	r4, #2		; R4 = BSS size in longwords (rounded down)
+	ldi	r1, #0		; clear R1 for longwords store
+	addi	r2, #-4		; account for pre-inc store
+	beqz	r4, .Lendloop1	; any more to go?
+.Lloop1:	
+	st	r1, @+r2	; yep, zero out another longword
+	addi	r4, #-1		; decrement count
+	bnez	r4, .Lloop1	; go do some more
+.Lendloop1:
+	and3	r4, r3, #3	; get no. of remaining BSS bytes to clear
+	addi	r2, #4		; account for pre-inc store
+	beqz	r4, .Lendloop2	; any more to go?
+.Lloop2:
+	stb	r1, @r2		; yep, zero out another byte
+	addi	r2, #1		; bump address
+	addi	r4, #-1		; decrement count
+	bnez	r4, .Lloop2	; go do some more
+.Lendloop2:		
+
+#endif /* not CONFIG_ISA_DUAL_ISSUE */
+
+	seth	r0, #shigh(stack_start)
+	ld	sp, @(r0, low(stack_start))	/* set stack point */
+
+/*
+ * decompress the kernel
+ */
+	bl	decompress_kernel
+	mv	r12, r0 		/* size of decompressed kernel */
+
+/*
+ * relocate copy routine & jump routine
+ */
+	LDIMM	(r1, BOOT_RELOC_ADDR)
+	mv	r5, r1		; save reloc addr to jump
+
+	LDIMM	(r2, startup_reloc)
+	LDIMM	(r3, exit_reloc)
+	sub	r3, r2		; relocated code size in bytes
+	mv	r4, r3
+	srli	r4, #2		; R4 = code size in longwords (rounded down)
+	addi	r1, #-4		; account for pre-inc store
+	beqz	r4, 2f		; any more to go?
+	.fillinsn
+1:	
+	ld	r6, @r2+	; code to be relocated
+	st	r6, @+r1	; relocate code
+	addi	r4, #-1		; decrement count
+	bnez	r4, 1b		; go do some more
+	.fillinsn
+2:
+	and3	r4, r3, #3	; get no. of remaining bytes
+	addi	r1, #4		; account for pre-inc store
+	beqz	r4, 4f		; any more to go?
+	.fillinsn
+3:
+	ldb	r6, @r2		; code to be relocated
+	stb	r6, @r1		; relocate code
+	addi	r1, #1		; bump address
+	addi	r2, #1		; bump address
+	addi	r4, #-1		; decrement count
+	bnez	r4, 3b		; go do some more
+	.fillinsn
+4:		
+	jmp	r5		; jump to relocated code
+
+/*
+ * startup_reloc runs on BOOT_RELOC_ADDR.
+ * copy decompressed kernel to original location
+ */
+	.text
+	__ALIGN
+startup_reloc:
+	LDIMM	(r1, CONFIG_MEMORY_START)
+	LDIMM	(r2, KERNEL_DECOMPRESS_ADDR)
+	mv	r4, r12		; r12 holds size of decompressed kernel
+	srli	r4, #2		; R4 = code size in longwords (rounded down)
+	addi	r1, #-4		; account for pre-inc store
+	beqz	r4, 2f		; any more to go?
+	.fillinsn
+1:	
+	ld	r6, @r2+	; code to be relocated
+	st	r6, @+r1	; relocate code
+	addi	r4, #-1		; decrement count
+	bnez	r4, 1b		; go do some more
+	.fillinsn
+2:
+	and3	r4, r12, #3	; get no. of remaining bytes
+	addi	r1, #4		; account for pre-inc store
+	beqz	r4, 4f		; any more to go?
+	.fillinsn
+3:
+	ldb	r6, @r2		; code to be relocated
+	stb	r6, @r1		; relocate code
+	addi	r1, #1		; bump address
+	addi	r2, #1		; bump address
+	addi	r4, #-1		; decrement count
+	bnez	r4, 3b		; go do some more
+	.fillinsn
+4:		
+	/*
+	 * invalidate i-cache before jump to kernel
+	 */
+#if defined(CONFIG_CHIP_VDEC2)
+	ldi	r0, #-1
+	ldi	r1, #0xc0	; invalidate i-cache
+	stb	r1, @r0
+#elif defined(CONFIG_CHIP_XNUX2)
+	ldi	r0, #-2
+	ldi	r1, #0x0100	; invalidate
+	sth	r1, @r0
+#elif defined(CONFIG_CHIP_M32700)
+	ldi	r0, #-1		; MCCR(cache control register)
+	ldi	r1, #0xc0	; invalidate i-cache
+	stb	r1, @r0
+#else
+#error unknown chip configuration
+#endif
+	LDIMM	(r0, KERNEL_ENTRY)
+	jmp	r0				/* jump to kernel */
+
+	__ALIGN
+exit_reloc:
+
+	.balign 4096
+.fake_empty_zero_page:
+	/* FIXME: correct table value */
+	.word	0
+	.ascii	"HdrS"
+	.word	0x0202
+	.word	0
+	.word	0
+	.word	0x1000
+	.word	0
+	.byte	0
+	.byte	1
+	.word	0x8000
+	.long	0
+	.long	0
+
+	.section	.fake_eit_vector, "aw"
+	.long	0
+
diff -ruN linux-2.6.7.org/arch/m32r/boot/compressed/install.sh linux-2.6.7/arch/m32r/boot/compressed/install.sh
--- linux-2.6.7.org/arch/m32r/boot/compressed/install.sh	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/boot/compressed/install.sh	2003-09-09 10:15:02.000000000 +0900
@@ -0,0 +1,57 @@
+#!/bin/sh
+#
+# arch/sh/boot/install.sh
+#
+# This file is subject to the terms and conditions of the GNU General Public
+# License.  See the file "COPYING" in the main directory of this archive
+# for more details.
+#
+# Copyright (C) 1995 by Linus Torvalds
+#
+# Adapted from code in arch/i386/boot/Makefile by H. Peter Anvin
+# Adapted from code in arch/i386/boot/install.sh by Russell King
+# Adapted from code in arch/arm/boot/install.sh by Stuart Menefy
+# Adapted from code in arch/sh/boot/install.sh by Takeo Takahashi
+#
+# "make install" script for sh architecture
+#
+# Arguments:
+#   $1 - kernel version
+#   $2 - kernel image file
+#   $3 - kernel map file
+#   $4 - default install path (blank if root directory)
+#
+
+# User may have a custom install script
+
+if [ -x /sbin/installkernel ]; then
+  exec /sbin/installkernel "$@"
+fi
+
+if [ "$2" = "zImage" ]; then
+# Compressed install
+  echo "Installing compressed kernel"
+  if [ -f $4/vmlinuz-$1 ]; then
+    mv $4/vmlinuz-$1 $4/vmlinuz.old
+  fi
+
+  if [ -f $4/System.map-$1 ]; then
+    mv $4/System.map-$1 $4/System.old
+  fi
+
+  cat $2 > $4/vmlinuz-$1
+  cp $3 $4/System.map-$1
+else
+# Normal install
+  echo "Installing normal kernel"
+  if [ -f $4/vmlinux-$1 ]; then
+    mv $4/vmlinux-$1 $4/vmlinux.old
+  fi
+
+  if [ -f $4/System.map ]; then
+    mv $4/System.map $4/System.old
+  fi
+
+  cat $2 > $4/vmlinux-$1
+  cp $3 $4/System.map
+fi
diff -ruN linux-2.6.7.org/arch/m32r/boot/compressed/m32r_sio.c linux-2.6.7/arch/m32r/boot/compressed/m32r_sio.c
--- linux-2.6.7.org/arch/m32r/boot/compressed/m32r_sio.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/boot/compressed/m32r_sio.c	2003-09-09 10:15:02.000000000 +0900
@@ -0,0 +1,50 @@
+/*
+ * arch/m32r/boot/compressed/m32r_sio.c
+ * 
+ * 2003-02-12:	Takeo Takahashi
+ *
+ */
+
+#include <linux/config.h>
+#include <asm/m32r.h>
+#include <asm/io.h>
+
+void putc(char c);
+
+void puts(char *s)
+{
+	char c;
+	while ((c = *s++)) putc(c);
+}
+
+#if defined(CONFIG_PLAT_M32700UT_Alpha) || defined(CONFIG_PLAT_M32700UT)
+#define USE_FPGA_MAP	0
+
+#if USE_FPGA_MAP
+/*
+ * fpga configuration program uses MMU, and define map as same as
+ * M32104 uT-Engine board.
+ */
+#define BOOT_SIO0STS	(volatile unsigned short *)(0x02c00000 + 0x20006)
+#define BOOT_SIO0TXB	(volatile unsigned short *)(0x02c00000 + 0x2000c)
+#else
+#define BOOT_SIO0STS	PLD_ESIO0STS
+#define BOOT_SIO0TXB	PLD_ESIO0TXB
+#endif
+
+void putc(char c)
+{
+
+	while ((*BOOT_SIO0STS & 0x3) != 0x3) ;
+	if (c == '\n') {
+		*BOOT_SIO0TXB = '\r';
+		while ((*BOOT_SIO0STS & 0x3) != 0x3) ;
+	}
+	*BOOT_SIO0TXB = c;
+}
+#else
+void putc(char c)
+{
+	/* do nothing */
+}
+#endif
diff -ruN linux-2.6.7.org/arch/m32r/boot/compressed/misc.c linux-2.6.7/arch/m32r/boot/compressed/misc.c
--- linux-2.6.7.org/arch/m32r/boot/compressed/misc.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/boot/compressed/misc.c	2003-09-09 10:15:02.000000000 +0900
@@ -0,0 +1,224 @@
+/*
+ * arch/m32r/boot/compressed/misc.c
+ * 
+ * This is a collection of several routines from gzip-1.0.3 
+ * adapted for Linux.
+ *
+ * malloc by Hannu Savolainen 1993 and Matthias Urlichs 1994
+ *
+ * Adapted for SH by Stuart Menefy, Aug 1999
+ *
+ * Modified to use standard LinuxSH BIOS by Greg Banks 7Jul2000
+ *
+ * 2003-02-12:	Support M32R by Takeo Takahashi
+ * 		This is based on arch/sh/boot/compressed/misc.c.
+ */
+
+#include <linux/config.h>
+#include <asm/uaccess.h>
+#include "boot.h"
+
+/*
+ * gzip declarations
+ */
+
+#define OF(args)  args
+#define STATIC static
+
+#undef memset
+#undef memcpy
+#define memzero(s, n)     memset ((s), 0, (n))
+
+typedef unsigned char  uch;
+typedef unsigned short ush;
+typedef unsigned long  ulg;
+
+#define WSIZE 0x8000		/* Window size must be at least 32k, */
+				/* and a power of two */
+
+static uch *inbuf;	     /* input buffer */
+static uch window[WSIZE];    /* Sliding window buffer */
+
+static unsigned insize;  /* valid bytes in inbuf */
+static unsigned inptr;   /* index of next byte to be processed in inbuf */
+static unsigned outcnt;  /* bytes in output buffer */
+
+/* gzip flag byte */
+#define ASCII_FLAG   0x01 /* bit 0 set: file probably ASCII text */
+#define CONTINUATION 0x02 /* bit 1 set: continuation of multi-part gzip file */
+#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */
+#define ORIG_NAME    0x08 /* bit 3 set: original file name present */
+#define COMMENT      0x10 /* bit 4 set: file comment present */
+#define ENCRYPTED    0x20 /* bit 5 set: file is encrypted */
+#define RESERVED     0xC0 /* bit 6,7:   reserved */
+
+#define get_byte()  (inptr < insize ? inbuf[inptr++] : fill_inbuf())
+		
+/* Diagnostic functions */
+#ifdef DEBUG
+#  define Assert(cond,msg) {if(!(cond)) error(msg);}
+#  define Trace(x) fprintf x
+#  define Tracev(x) {if (verbose) fprintf x ;}
+#  define Tracevv(x) {if (verbose>1) fprintf x ;}
+#  define Tracec(c,x) {if (verbose && (c)) fprintf x ;}
+#  define Tracecv(c,x) {if (verbose>1 && (c)) fprintf x ;}
+#else
+#  define Assert(cond,msg)
+#  define Trace(x)
+#  define Tracev(x)
+#  define Tracevv(x)
+#  define Tracec(c,x)
+#  define Tracecv(c,x)
+#endif
+
+static int  fill_inbuf(void);
+static void flush_window(void);
+static void error(char *m);
+static void gzip_mark(void **);
+static void gzip_release(void **);
+  
+extern char input_data[];
+extern int input_len;
+
+static long bytes_out;
+static uch *output_data;
+static unsigned long output_ptr;
+
+ 
+static void *malloc(int size);
+static void free(void *where);
+static void error(char *m);
+static void gzip_mark(void **);
+static void gzip_release(void **);
+ 
+extern void puts(const char *);
+  
+extern int _text;		/* Defined in vmlinux.lds.S */
+extern int _end;
+static unsigned long free_mem_ptr;
+static unsigned long free_mem_end_ptr;
+ 
+#define HEAP_SIZE             0x10000
+
+#include "../../../../lib/inflate.c"
+
+static void *malloc(int size)
+{
+	void *p;
+
+	if (size <0) error("Malloc error\n");
+	if (free_mem_ptr == 0) error("Memory error\n");
+
+	free_mem_ptr = (free_mem_ptr + 3) & ~3;	/* Align */
+
+	p = (void *)free_mem_ptr;
+	free_mem_ptr += size;
+
+	if (free_mem_ptr >= free_mem_end_ptr)
+		error("\nOut of memory\n");
+
+	return p;
+}
+
+static void free(void *where)
+{	/* Don't care */
+}
+
+static void gzip_mark(void **ptr)
+{
+	*ptr = (void *) free_mem_ptr;
+}
+
+static void gzip_release(void **ptr)
+{
+	free_mem_ptr = (long) *ptr;
+}
+
+void* memset(void* s, int c, size_t n)
+{
+	int i;
+	char *ss = (char*)s;
+
+	for (i=0;i<n;i++) ss[i] = c;
+	return s;
+}
+
+void* memcpy(void* __dest, __const void* __src,
+			    size_t __n)
+{
+	int i;
+	char *d = (char *)__dest, *s = (char *)__src;
+
+	for (i=0;i<__n;i++) d[i] = s[i];
+	return __dest;
+}
+
+/* ===========================================================================
+ * Fill the input buffer. This is called only when the buffer is empty
+ * and at least one byte is really needed.
+ */
+static int fill_inbuf(void)
+{
+	if (insize != 0) {
+		error("ran out of input data\n");
+	}
+
+	inbuf = input_data;
+	insize = input_len;
+	inptr = 1;
+	return inbuf[0];
+}
+
+/* ===========================================================================
+ * Write the output window window[0..outcnt-1] and update crc and bytes_out.
+ * (Used for the decompressed data only.)
+ */
+static void flush_window(void)
+{
+    ulg c = crc;         /* temporary variable */
+    unsigned n;
+    uch *in, *out, ch;
+    
+    in = window;
+    out = &output_data[output_ptr]; 
+    for (n = 0; n < outcnt; n++) {
+	    ch = *out++ = *in++;
+	    c = crc_32_tab[((int)c ^ ch) & 0xff] ^ (c >> 8);
+    }
+    crc = c;
+    bytes_out += (ulg)outcnt;
+    output_ptr += (ulg)outcnt;
+    outcnt = 0;
+}
+
+static void error(char *x)
+{
+	puts("\n\n");
+	puts(x);
+	puts("\n\n -- System halted");
+
+	while(1);	/* Halt */
+}
+
+#define STACK_SIZE (4096)
+long user_stack [STACK_SIZE];
+long* stack_start = &user_stack[STACK_SIZE];
+
+/* return decompressed size */
+long decompress_kernel(void)
+{
+	insize = 0;
+	inptr = 0;
+	bytes_out = 0;
+	outcnt = 0;
+	output_data = 0;
+	output_ptr = (unsigned long)KERNEL_DECOMPRESS_ADDR;
+	free_mem_ptr = (unsigned long)&_end;
+	free_mem_end_ptr = free_mem_ptr + HEAP_SIZE;
+
+	makecrc();
+	puts("Uncompressing Linux... ");
+	gunzip();
+	puts("Ok, booting the kernel.\n");
+	return bytes_out;
+}
diff -ruN linux-2.6.7.org/arch/m32r/boot/compressed/vmlinux.lds.S linux-2.6.7/arch/m32r/boot/compressed/vmlinux.lds.S
--- linux-2.6.7.org/arch/m32r/boot/compressed/vmlinux.lds.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/boot/compressed/vmlinux.lds.S	2004-07-29 22:07:12.000000000 +0900
@@ -0,0 +1,25 @@
+#include <linux/config.h>
+
+OUTPUT_ARCH(m32r)
+ENTRY(startup)
+SECTIONS
+{
+  . = CONFIG_MEMORY_START;
+  .fake_eit_vector : { *(.fake_eit_vector) }
+  
+  . = ALIGN(4096);
+  _text = .;
+  .text : { *(.text) } = 0
+  .rodata : { *(.rodata) }
+  _etext = .;
+
+  . = ALIGN(32) + (. & (32 - 1));
+  .data : { *(.data) }
+  _edata  =  .;
+
+  . = ALIGN(32 / 8);
+  __bss_start = .;
+  .bss : { *(.bss) }
+  . = ALIGN(32 / 8);
+  _end = . ;
+}
diff -ruN linux-2.6.7.org/arch/m32r/boot/compressed/vmlinux.scr linux-2.6.7/arch/m32r/boot/compressed/vmlinux.scr
--- linux-2.6.7.org/arch/m32r/boot/compressed/vmlinux.scr	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/boot/compressed/vmlinux.scr	2004-07-29 22:07:12.000000000 +0900
@@ -0,0 +1,9 @@
+SECTIONS
+{
+  .data : { 
+	input_len = .;
+	LONG(input_data_end - input_data) input_data = .; 
+	*(.data) 
+	input_data_end = .; 
+	}
+}
diff -ruN linux-2.6.7.org/arch/m32r/boot/setup.S linux-2.6.7/arch/m32r/boot/setup.S
--- linux-2.6.7.org/arch/m32r/boot/setup.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/boot/setup.S	2004-07-27 15:54:20.000000000 +0900
@@ -0,0 +1,217 @@
+/*
+ *  linux/arch/m32r/boot/setup.S -- A setup code.
+ *
+ *  Copyright (C) 2001, 2002  Hiroyuki Kondo, Hirokazu Takata,
+ *  and Hitoshi Yamamoto
+ *
+ */
+/* $Id$ */
+
+#include <linux/linkage.h>
+#include <asm/segment.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+	
+#include <linux/config.h>
+#include <asm/assembler.h>
+#include <asm/mmu_context.h>
+#include <asm/m32r.h>
+
+/*
+ * References to members of the boot_cpu_data structure.
+ */
+
+#define CPU_PARAMS	boot_cpu_data
+#define M32R_MCICAR	 0xfffffff0	
+#define M32R_MCDCAR	 0xfffffff4	
+#define	M32R_MCCR 	 0xfffffffc
+#define M32R_BSCR0	 0xffffffd2
+
+;BSEL
+#define BSEL0CR0	 0x00ef5000
+#define	BSEL0CR1	 0x00ef5004
+#define BSEL1CR0	 0x00ef5100
+#define BSEL1CR1	 0x00ef5104
+#define BSEL0CR0_VAL	 0x00000000
+#define BSEL0CR1_VAL	 0x01200100
+#define BSEL1CR0_VAL	 0x01018000
+#define BSEL1CR1_VAL	 0x00200001
+
+;SDRAMC
+#define SDRAMC_SDRF0	 0x00ef6000
+#define SDRAMC_SDRF1	 0x00ef6004
+#define SDRAMC_SDIR0	 0x00ef6008
+#define SDRAMC_SDIR1	 0x00ef600c
+#define SDRAMC_SD0ADR	 0x00ef6020
+#define SDRAMC_SD0ER	 0x00ef6024
+#define SDRAMC_SD0TR	 0x00ef6028
+#define SDRAMC_SD0MOD	 0x00ef602c
+#define SDRAMC_SD1ADR	 0x00ef6040
+#define SDRAMC_SD1ER	 0x00ef6044
+#define SDRAMC_SD1TR	 0x00ef6048
+#define SDRAMC_SD1MOD	 0x00ef604c
+#define SDRAM0		 0x18000000
+#define SDRAM1		 0x1c000000
+
+/*------------------------------------------------------------------------
+ * start up
+ */
+
+/*------------------------------------------------------------------------
+ * Kernel entry
+ */
+	.section .boot,"ax"
+ENTRY(boot)
+
+/* Set cache mode */
+#if defined(CONFIG_CHIP_XNUX2)
+	ldi	r0, #-2              ;LDIMM	(r0, M32R_MCCR)
+	ldi	r1, #0x0101		; cache on (with invalidation)
+;	ldi	r1, #0x00		; cache off
+	sth	r1, @r0
+#elif defined(CONFIG_CHIP_VDEC2)
+	; cache condition is controlled by loader
+	; r13 = pointer to kernel parameter passed from loader
+	beqz	r13, param_skip
+	ldi	r2, #4096				; size
+	seth	r1, #high(empty_zero_page)
+	or3	r1, r1, #low(empty_zero_page)
+	seth	r3, #high(__PAGE_OFFSET)
+	or3	r3, r3, #low(__PAGE_OFFSET)
+	not	r3, r3
+	and	r1, r3
+	addi	r1, #-4
+param_loop:
+	ld	r3, @r13+
+	st	r3, @+r1
+	addi	r2, #-4
+	bnez	r2, param_loop
+	bra	param_end
+param_skip:
+	ldi	r0, #-1              ;LDIMM	(r0, M32R_MCCR)
+	ldi	r1, #0x63      		; cache on
+;	ldi	r1, #0x00		; cache off
+	stb	r1, @r0
+param_end:
+
+#elif defined(CONFIG_CHIP_M32700) && (defined(CONFIG_PLAT_M32700UT) \
+	|| defined(CONFIG_PLAT_USRV)) || \
+	defined(CONFIG_CHIP_OPSP) && defined(CONFIG_PLAT_OPSPUT)	
+	; cache condition is controlled by loader
+	; r13 = pointer to kernel parameter passed from loader
+	ldi     r0, #-4
+	ldi     r1, #0x63		;  cache Ion/Don
+	st      r1, @r0
+#if defined(CONFIG_SMP) && !defined(CONFIG_PLAT_USRV)
+	seth    r5, #high(M32R_CPUID_PORTL)
+	or3     r5, r5, #low(M32R_CPUID_PORTL)
+	ld      r5, @r5
+	bnez    r5, param_end
+		;;  boot AP
+	ld24    r5, #0xeff2f8		;  IPICR7
+	ldi     r6, #0x2		;  IPI to CPU1
+	st      r6, @r5
+#endif
+	beqz	r13, param_end
+	ldi	r2, #4096				; size
+	seth	r1, #high(empty_zero_page)
+	or3	r1, r1, #low(empty_zero_page)
+	seth	r3, #high(__PAGE_OFFSET)
+	or3	r3, r3, #low(__PAGE_OFFSET)
+	not	r3, r3
+	and	r1, r3
+	addi	r1, #-4
+param_loop:
+	ld	r3, @r13+
+	st	r3, @+r1
+	addi	r2, #-4
+	bnez	r2, param_loop
+param_end:
+#elif defined(CONFIG_CHIP_M32700) || defined(CONFIG_CHIP_OPSP)
+	ldi	r0, #-4			;LDIMM	(r0, M32R_MCCR)
+	ldi	r1, #0x63		; cache Ion/Don (with invalidation)
+;	ldi	r1, #0x00		; cache off
+	st	r1, @r0
+#elif defined(CONFIG_CHIP_M32102)
+        ldi     r0, #-4                 ;LDIMM  (r0, M32R_MCCR)
+        ldi     r1, #0x101              ; cache Ion (with invalidation)
+;       ldi     r1, #0x00               ; cache off
+        st      r1, @r0
+#else
+#error unknown chip configuration
+#endif
+
+#ifdef CONFIG_SMP
+	;; if not BSP (CPU#0) goto AP_loop
+	seth	r5, #shigh(M32R_CPUID_PORTL)
+	ld      r5, @(low(M32R_CPUID_PORTL), r5)
+	bnez	r5, AP_loop
+#endif
+
+/*
+ *  Now, Jump to stext 
+ *        if with MMU,    TLB on.
+ *        if with no MMU, only jump.
+ */
+mmu_on:
+	LDIMM	(r13, stext)
+#ifdef CONFIG_MMU
+	bl	init_tlb
+	LDIMM	(r2, _RE)			; set EVB(cr5)
+	mvtc    r2, cr5	
+	seth	r0, #high(MMU_REG_BASE)		; Set MMU_REG_BASE higher
+	or3     r0, r0, #low(MMU_REG_BASE)	; Set MMU_REG_BASE lower
+	ldi     r1, #0x01    
+	st      r1, @(MATM_offset,r0)		; Set MATM (T bit ON)
+	ld      r0, @(MATM_offset,r0)		; Check
+#else
+	seth	r0,#high(M32R_MCDCAR)
+	or3	r0,r0,#low(M32R_MCDCAR)
+	ld24	r1,#0x8080
+	st	r1,@r0
+#endif	/* CONFIG_MMU */
+	jmp	r13
+	nop
+	nop
+
+#ifdef CONFIG_SMP
+/* 
+ * AP wait loop
+ */
+ENTRY(AP_loop)
+	;; disable interrupt
+	clrpsw	#0x40
+	;; reset EVB
+	LDIMM	(r4, _AP_RE)
+	seth	r5, #high(__PAGE_OFFSET)
+	or3	r5, r5, #low(__PAGE_OFFSET)
+	not	r5, r5
+	and	r4, r5
+	mvtc	r4, cr5
+	;; disable maskable interrupt
+	seth	r4, #high(M32R_ICU_IMASK_PORTL)
+	or3	r4, r4, #low(M32R_ICU_IMASK_PORTL)
+	ldi	r5, #0
+	st	r5, @r4
+	ld	r5, @r4
+	;; enable only IPI
+	setpsw	#0x40
+    	;; LOOOOOOOOOOOOOOP!!!
+	.fillinsn
+2:
+	nop
+	nop
+	bra	2b
+	nop
+	nop
+
+#ifdef CONFIG_CHIP_M32700_TS1
+	.global	dcache_dummy
+	.balign	16, 0
+dcache_dummy:
+	.byte	16
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+#endif	/* CONFIG_SMP */
+
+	.end
+
diff -ruN linux-2.6.7.org/arch/m32r/defconfig linux-2.6.7/arch/m32r/defconfig
--- linux-2.6.7.org/arch/m32r/defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/defconfig	2004-07-15 13:43:14.000000000 +0900
@@ -0,0 +1,622 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_M32R=y
+CONFIG_UID16=y
+CONFIG_GENERIC_ISA_DMA=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_STANDALONE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_HOTPLUG=y
+CONFIG_IKCONFIG=y
+# CONFIG_IKCONFIG_PROC is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+# CONFIG_FUTEX is not set
+# CONFIG_EPOLL is not set
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+CONFIG_KMOD=y
+
+#
+# Processor type and features
+#
+# CONFIG_PLAT_MAPPI is not set
+# CONFIG_PLAT_USRV is not set
+CONFIG_PLAT_M32700UT=y
+# CONFIG_PLAT_OAKS32R is not set
+# CONFIG_PLAT_MAPPI2 is not set
+CONFIG_CHIP_M32700=y
+# CONFIG_CHIP_M32102 is not set
+# CONFIG_CHIP_VDEC2 is not set
+# CONFIG_CHIP_OPSP is not set
+CONFIG_MMU=y
+CONFIG_TLB_ENTRIES=32
+CONFIG_ISA_M32R2=y
+CONFIG_ISA_DSP_LEVEL2=y
+CONFIG_ISA_DUAL_ISSUE=y
+CONFIG_BUS_CLOCK=50000000
+CONFIG_TIMER_DIVIDE=128
+# CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_MEMORY_START=0x08000000
+CONFIG_MEMORY_SIZE=0x01000000
+CONFIG_NOHIGHMEM=y
+# CONFIG_DISCONTIGMEM is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+CONFIG_PREEMPT=y
+# CONFIG_HAVE_DEC_LOCK is not set
+# CONFIG_SMP is not set
+
+#
+# M32R drivers
+#
+# CONFIG_M32RPCC is not set
+CONFIG_M32R_CFC=y
+CONFIG_M32700UT_CFC=y
+CONFIG_CFC_NUM=1
+CONFIG_M32R_SMC91111=y
+CONFIG_M32700UT_DS1302=y
+
+#
+# Power management options (ACPI, APM)
+#
+# CONFIG_PM is not set
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+# CONFIG_PCI is not set
+# CONFIG_ISA is not set
+
+#
+# PCMCIA/CardBus support
+#
+CONFIG_PCMCIA=y
+# CONFIG_PCMCIA_DEBUG is not set
+# CONFIG_TCIC is not set
+
+#
+# PCI Hotplug Support
+#
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_FW_LOADER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_NBD=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_BLK_DEV_INITRD is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECS=y
+CONFIG_BLK_DEV_IDECD=m
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+# CONFIG_IDE_TASKFILE_IO is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+# CONFIG_IDE_ARM is not set
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI=m
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=m
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=m
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_EATA_PIO is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# PCMCIA SCSI adapter support
+#
+# CONFIG_PCMCIA_AHA152X is not set
+# CONFIG_PCMCIA_FDOMAIN is not set
+# CONFIG_PCMCIA_NINJA_SCSI is not set
+# CONFIG_PCMCIA_QLOGIC is not set
+# CONFIG_PCMCIA_SYM53C500 is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_NETDEVICES is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_CT82C710 is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_M32R_SIO is not set
+CONFIG_SERIAL_M32R_PLDSIO=y
+CONFIG_SERIAL_M32R_PLDSIO_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_QIC02_TAPE is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+
+#
+# PCMCIA character devices
+#
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+CONFIG_VIDEO_DEV=y
+
+#
+# Video For Linux
+#
+
+#
+# Video Adapters
+#
+# CONFIG_VIDEO_CPIA is not set
+
+#
+# Radio Adapters
+#
+# CONFIG_RADIO_MAXIRADIO is not set
+# CONFIG_RADIO_MAESTRO is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+CONFIG_EXT3_FS=m
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=m
+CONFIG_JBD_DEBUG=y
+CONFIG_FS_MBCACHE=y
+CONFIG_REISERFS_FS=m
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_REISERFS_FS_XATTR is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+CONFIG_UDF_FS=m
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=m
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=m
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
+# CONFIG_DEVFS_DEBUG is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_FRAME_POINTER is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
diff -ruN linux-2.6.7.org/arch/m32r/drivers/8390.c linux-2.6.7/arch/m32r/drivers/8390.c
--- linux-2.6.7.org/arch/m32r/drivers/8390.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/drivers/8390.c	2003-09-09 10:15:02.000000000 +0900
@@ -0,0 +1 @@
+#include "../../../drivers/net/8390.c"
diff -ruN linux-2.6.7.org/arch/m32r/drivers/8390.h linux-2.6.7/arch/m32r/drivers/8390.h
--- linux-2.6.7.org/arch/m32r/drivers/8390.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/drivers/8390.h	2003-09-09 10:15:02.000000000 +0900
@@ -0,0 +1 @@
+#include "../../../drivers/net/8390.h"
diff -ruN linux-2.6.7.org/arch/m32r/drivers/Kconfig linux-2.6.7/arch/m32r/drivers/Kconfig
--- linux-2.6.7.org/arch/m32r/drivers/Kconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/drivers/Kconfig	2004-08-03 17:21:10.000000000 +0900
@@ -0,0 +1,42 @@
+#
+# For a description of the syntax of this configuration file,
+# see Documentation/kbuild/kconfig-language.txt.
+#
+
+menu "M32R drivers"
+
+config M32RPCC
+	bool "M32R PCMCIA I/F"
+	depends on CHIP_M32700
+
+config M32R_NE2000
+	bool "On board NE2000 Network Interface Chip"
+	depends on PLAT_MAPPI || PLAT_OAKS32R
+
+config M32R_CFC
+	bool "CF I/F Controller"
+	depends on PLAT_USRV || PLAT_M32700UT || PLAT_MAPPI2 || PLAT_OPSPUT
+
+config M32700UT_CFC
+	bool
+	depends on M32R_CFC
+	default y
+
+config CFC_NUM
+	int "CF I/F number"
+	depends on PLAT_USRV || PLAT_M32700UT
+	default "1" if PLAT_USRV || PLAT_M32700UT || PLAT_MAPPI2 || PLAT_OPSPUT
+
+config MTD_M32R
+	bool "Flash device mapped on M32R"
+	depends on PLAT_USRV || PLAT_M32700UT || PLAT_MAPPI2
+
+config M32R_SMC91111
+	bool "On board SMC91111 Network Interface Chip"
+	depends on PLAT_M32700UT || PLAT_MAPPI2 || PLAT_OPSPUT
+
+config M32700UT_DS1302
+	bool "DS1302 Real Time Clock support"
+	depends on PLAT_M32700UT || PLAT_OPSPUT
+
+endmenu
diff -ruN linux-2.6.7.org/arch/m32r/drivers/Makefile linux-2.6.7/arch/m32r/drivers/Makefile
--- linux-2.6.7.org/arch/m32r/drivers/Makefile	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/drivers/Makefile	2004-02-17 17:31:39.000000000 +0900
@@ -0,0 +1,9 @@
+#
+# Makefile for the Linux/M32R driver
+#
+
+obj-$(CONFIG_M32R_SMC91111)	+= smc91111.o
+obj-$(CONFIG_M32R_NE2000)	+= mappi_ne.o 8390.o
+obj-$(CONFIG_M32RPCC)		+= m32r_pcc.o
+obj-$(CONFIG_M32R_CFC)		+= m32r_cfc.o
+obj-$(CONFIG_M32700UT_DS1302)	+= ds1302.o
diff -ruN linux-2.6.7.org/arch/m32r/drivers/cs_internal.h linux-2.6.7/arch/m32r/drivers/cs_internal.h
--- linux-2.6.7.org/arch/m32r/drivers/cs_internal.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/drivers/cs_internal.h	2003-09-09 10:15:02.000000000 +0900
@@ -0,0 +1,2 @@
+#include "../../../drivers/pcmcia/cs_internal.h"
+
diff -ruN linux-2.6.7.org/arch/m32r/drivers/ds1302.c linux-2.6.7/arch/m32r/drivers/ds1302.c
--- linux-2.6.7.org/arch/m32r/drivers/ds1302.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/drivers/ds1302.c	2004-08-03 17:21:10.000000000 +0900
@@ -0,0 +1,432 @@
+/*!***************************************************************************
+*!
+*! FILE NAME  : ds1302.c
+*!
+*! DESCRIPTION: Implements an interface for the DS1302 RTC through Etrax I/O
+*!
+*! Functions exported: ds1302_readreg, ds1302_writereg, ds1302_init, get_rtc_status
+*!
+*! $Log: ds1302.c,v $
+*! Revision 1.2  2003/10/29 08:42:58  fujiwara
+*! Set PLD_RTCBAUR from bus clock
+*!
+*! Revision 1.12  2002/04/10 15:35:25  johana
+*! Moved probe function closer to init function and marked it __init.
+*!
+*! Revision 1.11  2001/06/14 12:35:52  jonashg
+*! The ATA hack is back. It is unfortunately the only way to set g27 to output.
+*!
+*! Revision 1.9  2001/06/14 10:00:14  jonashg
+*! No need for tempudelay to be inline anymore (had to adjust the usec to
+*! loops conversion because of this to make it slow enough to be a udelay).
+*!
+*! Revision 1.8  2001/06/14 08:06:32  jonashg
+*! Made tempudelay delay usecs (well, just a tad more).
+*!
+*! Revision 1.7  2001/06/13 14:18:11  jonashg
+*! Only allow processes with SYS_TIME capability to set time and charge.
+*!
+*! Revision 1.6  2001/06/12 15:22:07  jonashg
+*! * Made init function __init.
+*! * Parameter to out_byte() is unsigned char.
+*! * The magic number 42 has got a name.
+*! * Removed comment about /proc (nothing is exported there).
+*!
+*! Revision 1.5  2001/06/12 14:35:13  jonashg
+*! Gave the module a name and added it to printk's.
+*!
+*! Revision 1.4  2001/05/31 14:53:40  jonashg
+*! Made tempudelay() inline so that the watchdog doesn't reset (see
+*! function comment).
+*!
+*! Revision 1.3  2001/03/26 16:03:06  bjornw
+*! Needs linux/config.h
+*!
+*! Revision 1.2  2001/03/20 19:42:00  bjornw
+*! Use the ETRAX prefix on the DS1302 options
+*!
+*! Revision 1.1  2001/03/20 09:13:50  magnusmn
+*! Linux 2.4 port
+*!
+*! Revision 1.10  2000/07/05 15:38:23  bjornw
+*! Dont update kernel time when a RTC_SET_TIME is done
+*!
+*! Revision 1.9  2000/03/02 15:42:59  macce
+*! * Hack to make RTC work on all 2100/2400
+*!
+*! Revision 1.8  2000/02/23 16:59:18  torbjore
+*! added setup of R_GEN_CONFIG when RTC is connected to the generic port.
+*!
+*! Revision 1.7  2000/01/17 15:51:43  johana
+*! Added RTC_SET_CHARGE ioctl to enable trickle charger.
+*!
+*! Revision 1.6  1999/10/27 13:19:47  bjornw
+*! Added update_xtime_from_cmos which reads back the updated RTC into the kernel.
+*! /dev/rtc calls it now.
+*!
+*! Revision 1.5  1999/10/27 12:39:37  bjornw
+*! Disabled superuser check. Anyone can now set the time.
+*!
+*! Revision 1.4  1999/09/02 13:27:46  pkj
+*! Added shadow for R_PORT_PB_CONFIG.
+*! Renamed port_g_shadow to port_g_data_shadow.
+*!
+*! Revision 1.3  1999/09/02 08:28:06  pkj
+*! Made it possible to select either port PB or the generic port for the RST
+*! signal line to the DS1302 RTC.
+*! Also make sure the RST bit is configured as output on Port PB (if used).
+*!
+*! Revision 1.2  1999/09/01 14:47:20  bjornw
+*! Added support for /dev/rtc operations with ioctl RD_TIME and SET_TIME to read
+*! and set the date. Register as major 121.
+*!
+*! Revision 1.1  1999/09/01 09:45:29  bjornw
+*! Implemented a DS1302 RTC driver.
+*!
+*!
+*! ---------------------------------------------------------------------------
+*!
+*! (C) Copyright 1999, 2000, 2001  Axis Communications AB, LUND, SWEDEN
+*!
+*! $Id: ds1302.c,v 1.2 2003/10/29 08:42:58 fujiwara Exp $
+*!
+*!***************************************************************************/
+
+#include <linux/config.h>
+
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/miscdevice.h>
+#include <linux/delay.h>
+#include <linux/bcd.h>
+
+#include <asm/uaccess.h>
+#include <asm/system.h>
+#include <asm/io.h>
+#include <asm/rtc.h>
+#include <asm/m32r.h>
+
+#define RTC_MAJOR_NR 121 /* local major, change later */
+
+static const char ds1302_name[] = "ds1302";
+
+/* Send 8 bits. */
+static void
+out_byte_rtc(unsigned int reg_addr, unsigned char x) 
+{
+	//RST H
+	outw(0x0001,(unsigned long)PLD_RTCRSTODT);
+	//write data
+	outw(((x<<8)|(reg_addr&0xff)),(unsigned long)PLD_RTCWRDATA);
+	//WE
+	outw(0x0002,(unsigned long)PLD_RTCCR);
+	//wait
+	while(inw((unsigned long)PLD_RTCCR));
+	
+	//RST L
+	outw(0x0000,(unsigned long)PLD_RTCRSTODT);
+
+}
+
+static unsigned char
+in_byte_rtc(unsigned int reg_addr) 
+{
+	unsigned char retval;
+	
+	//RST H
+	outw(0x0001,(unsigned long)PLD_RTCRSTODT);
+	//write data
+	outw((reg_addr&0xff),(unsigned long)PLD_RTCRDDATA);
+	//RE
+	outw(0x0001,(unsigned long)PLD_RTCCR);
+	//wait
+	while(inw((unsigned long)PLD_RTCCR));
+
+	//read data
+	retval=(inw((unsigned long)PLD_RTCRDDATA) & 0xff00)>>8;
+
+	//RST L
+	outw(0x0000,(unsigned long)PLD_RTCRSTODT);
+
+	return retval;
+}
+
+/* Enable writing. */
+
+static void
+ds1302_wenable(void) 
+{
+	out_byte_rtc(0x8e,0x00);
+}
+
+/* Disable writing. */
+
+static void
+ds1302_wdisable(void) 
+{
+	out_byte_rtc(0x8e,0x80);
+}
+
+
+
+/* Read a byte from the selected register in the DS1302. */
+
+unsigned char
+ds1302_readreg(int reg) 
+{
+	unsigned char x;
+
+	x=in_byte_rtc((0x81 | (reg << 1))); /* read register */
+
+	return x;
+}
+
+/* Write a byte to the selected register. */
+
+void
+ds1302_writereg(int reg, unsigned char val) 
+{
+	ds1302_wenable();
+	out_byte_rtc((0x80 | (reg << 1)),val);
+	ds1302_wdisable();
+}
+
+void
+get_rtc_time(struct rtc_time *rtc_tm) 
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	local_irq_disable();
+
+	rtc_tm->tm_sec = CMOS_READ(RTC_SECONDS);
+	rtc_tm->tm_min = CMOS_READ(RTC_MINUTES);
+	rtc_tm->tm_hour = CMOS_READ(RTC_HOURS);
+	rtc_tm->tm_mday = CMOS_READ(RTC_DAY_OF_MONTH);
+	rtc_tm->tm_mon = CMOS_READ(RTC_MONTH);
+	rtc_tm->tm_year = CMOS_READ(RTC_YEAR);
+
+	local_irq_restore(flags);
+	
+	BCD_TO_BIN(rtc_tm->tm_sec);
+	BCD_TO_BIN(rtc_tm->tm_min);
+	BCD_TO_BIN(rtc_tm->tm_hour);
+	BCD_TO_BIN(rtc_tm->tm_mday);
+	BCD_TO_BIN(rtc_tm->tm_mon);
+	BCD_TO_BIN(rtc_tm->tm_year);
+
+	/*
+	 * Account for differences between how the RTC uses the values
+	 * and how they are defined in a struct rtc_time;
+	 */
+
+	if (rtc_tm->tm_year <= 69)
+		rtc_tm->tm_year += 100;
+
+	rtc_tm->tm_mon--;
+}
+
+static unsigned char days_in_mo[] = 
+    {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
+
+/* ioctl that supports RTC_RD_TIME and RTC_SET_TIME (read and set time/date). */
+
+static int
+rtc_ioctl(struct inode *inode, struct file *file, unsigned int cmd,
+	  unsigned long arg) 
+{
+        unsigned long flags;
+
+	switch(cmd) {
+		case RTC_RD_TIME:	/* read the time/date from RTC	*/
+		{
+			struct rtc_time rtc_tm;
+						
+			memset(&rtc_tm, 0, sizeof (struct rtc_time));
+			get_rtc_time(&rtc_tm);						
+			if (copy_to_user((struct rtc_time*)arg, &rtc_tm, sizeof(struct rtc_time)))
+				return -EFAULT;	
+			return 0;
+		}
+
+		case RTC_SET_TIME:	/* set the RTC */
+		{
+			struct rtc_time rtc_tm;
+			unsigned char mon, day, hrs, min, sec, leap_yr;
+			unsigned int yrs;
+
+			if (!capable(CAP_SYS_TIME))
+				return -EPERM;
+
+			if (copy_from_user(&rtc_tm, (struct rtc_time*)arg, sizeof(struct rtc_time)))
+				return -EFAULT;    	
+
+			yrs = rtc_tm.tm_year + 1900;
+			mon = rtc_tm.tm_mon + 1;   /* tm_mon starts at zero */
+			day = rtc_tm.tm_mday;
+			hrs = rtc_tm.tm_hour;
+			min = rtc_tm.tm_min;
+			sec = rtc_tm.tm_sec;
+			
+			
+			if ((yrs < 1970) || (yrs > 2069))
+				return -EINVAL;
+
+			leap_yr = ((!(yrs % 4) && (yrs % 100)) || !(yrs % 400));
+
+			if ((mon > 12) || (day == 0))
+				return -EINVAL;
+
+			if (day > (days_in_mo[mon] + ((mon == 2) && leap_yr)))
+				return -EINVAL;
+			
+			if ((hrs >= 24) || (min >= 60) || (sec >= 60))
+				return -EINVAL;
+
+			if (yrs >= 2000)
+				yrs -= 2000;	/* RTC (0, 1, ... 69) */
+			else
+				yrs -= 1900;	/* RTC (70, 71, ... 99) */
+
+			BIN_TO_BCD(sec);
+			BIN_TO_BCD(min);
+			BIN_TO_BCD(hrs);
+			BIN_TO_BCD(day);
+			BIN_TO_BCD(mon);
+			BIN_TO_BCD(yrs);
+
+			local_irq_save(flags);
+			local_irq_disable();
+			CMOS_WRITE(yrs, RTC_YEAR);
+			CMOS_WRITE(mon, RTC_MONTH);
+			CMOS_WRITE(day, RTC_DAY_OF_MONTH);
+			CMOS_WRITE(hrs, RTC_HOURS);
+			CMOS_WRITE(min, RTC_MINUTES);
+			CMOS_WRITE(sec, RTC_SECONDS);
+			local_irq_restore(flags);
+
+			/* Notice that at this point, the RTC is updated but
+			 * the kernel is still running with the old time.
+			 * You need to set that separately with settimeofday
+			 * or adjtimex.
+			 */
+			return 0;
+		}
+
+		case RTC_SET_CHARGE: /* set the RTC TRICKLE CHARGE register */
+		{
+			int tcs_val;                        
+
+			if (!capable(CAP_SYS_TIME))
+				return -EPERM;
+			
+			if(copy_from_user(&tcs_val, (int*)arg, sizeof(int)))
+				return -EFAULT;
+
+			tcs_val = RTC_TCR_PATTERN | (tcs_val & 0x0F);
+			ds1302_writereg(RTC_TRICKLECHARGER, tcs_val);
+			return 0;
+		}
+		default:
+			return -EINVAL;
+	}
+}
+
+int
+get_rtc_status(char *buf) 
+{
+	char *p;
+	struct rtc_time tm;
+
+	p = buf;
+
+	get_rtc_time(&tm);
+
+	/*
+	 * There is no way to tell if the luser has the RTC set for local
+	 * time or for Universal Standard Time (GMT). Probably local though.
+	 */
+
+	p += sprintf(p,
+		"rtc_time\t: %02d:%02d:%02d\n"
+		"rtc_date\t: %04d-%02d-%02d\n",
+		tm.tm_hour, tm.tm_min, tm.tm_sec,
+		tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday);
+
+	return  p - buf;
+}
+
+
+/* The various file operations we support. */
+
+static struct file_operations rtc_fops = {
+	.owner          = THIS_MODULE,
+	.ioctl          = rtc_ioctl,    
+}; 
+
+/* Probe for the chip by writing something to its RAM and try reading it back. */
+
+#define MAGIC_PATTERN 0x42
+
+static int __init
+ds1302_probe(void) 
+{
+	int retval, res, baur; 
+
+	baur=(boot_cpu_data.bus_clock/(2*1000*1000));
+
+	printk("%s: Set PLD_RTCBAUR = %d\n", ds1302_name,baur);
+
+	outw(0x0000,(unsigned long)PLD_RTCCR);
+	outw(0x0000,(unsigned long)PLD_RTCRSTODT);
+	outw(baur,(unsigned long)PLD_RTCBAUR);
+
+	/* Try to talk to timekeeper. */
+
+	ds1302_wenable();  
+	/* write RAM byte 0 */	
+	/* write something magic */
+	out_byte_rtc(0xc0,MAGIC_PATTERN);
+	
+	/* read RAM byte 0 */
+	if((res = in_byte_rtc(0xc1)) == MAGIC_PATTERN) {
+		char buf[100];
+		ds1302_wdisable();
+		printk("%s: RTC found.\n", ds1302_name);
+                get_rtc_status(buf);
+                printk(buf);
+		retval = 1;
+	} else {
+		printk("%s: RTC not found.\n", ds1302_name);
+		retval = 0;
+	}
+
+	return retval;
+}
+
+
+/* Just probe for the RTC and register the device to handle the ioctl needed. */
+
+int __init
+ds1302_init(void) 
+{ 
+	if (!ds1302_probe()) {
+    		return -1;
+  	}
+	return 0;
+}
+
+static int __init ds1302_register(void)
+{
+        ds1302_init();
+	if (register_chrdev(RTC_MAJOR_NR, ds1302_name, &rtc_fops)) {
+		printk(KERN_INFO "%s: unable to get major %d for rtc\n", 
+		       ds1302_name, RTC_MAJOR_NR);
+		return -1;
+	}
+	return 0;
+}
+
+module_init(ds1302_register);
diff -ruN linux-2.6.7.org/arch/m32r/drivers/m32r-pldsio.c linux-2.6.7/arch/m32r/drivers/m32r-pldsio.c
--- linux-2.6.7.org/arch/m32r/drivers/m32r-pldsio.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/drivers/m32r-pldsio.c	2003-09-09 10:15:02.000000000 +0900
@@ -0,0 +1,3067 @@
+/* $Id$
+ *
+ * M32R onboard PLD serial module support.
+ * 
+ * Much of the design and some of the code came from serial.c:
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ *  Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997,
+ *              1998, 1999  Theodore Ts'o
+ *
+ * M32R work:
+ *  Copyright 1996, 2001, Mitsubishi Electric Corporation 
+ *  Copyright (C) 2000,2001  by Hiro Kondo, Hiro Takata, and Hitoshi Yamamoto.
+ *
+ *  2002-12-25: Support M32700UT Platform by Takeo Takahashi
+ *  		Derived from dbg_console.c.
+ */
+
+static char *serial_version = "kondo";
+static char *serial_revdate = "2002-09-11";
+static char *serial_name = "M32R Serial driver";
+
+#define LOCAL_VERSTRING ""
+
+#include <linux/config.h>
+#include <linux/version.h>
+#include <linux/module.h>
+
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/tty_driver.h>
+#include <linux/smp_lock.h>
+#include <linux/init.h>
+#include <linux/major.h>
+#include <linux/console.h>
+#include <linux/kdev_t.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/serial.h>
+#include <linux/serialP.h>  /* serial_state */
+#include <linux/slab.h>  /* kmalloc */
+
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/serial.h>
+#include <asm/m32r.h>
+
+extern struct console  console_for_debug;
+
+static int psio_write(struct tty_struct *tty, int from_user, 
+			const unsigned char *buf, int count);
+static int psio_write_room(struct tty_struct *tty);
+static int psio_chars_in_buffer(struct tty_struct *tty);
+
+static void dbg_console_write(struct console *, const char *, unsigned);
+static kdev_t dbg_console_device(struct console *c);
+//static void psio_interrupt_single(int, void *, struct pt_regs *);
+void psio_interrupt_single(int, void *, struct pt_regs *);
+static void psio_receive_chars(struct async_struct *, int *);
+
+static void psio_wait_until_sent(struct tty_struct *, int);
+static void change_speed(struct async_struct *,struct termios *);
+static void autoconfig(struct serial_state *);
+static unsigned detect_uart_irq (struct serial_state *);
+
+static struct tty_driver psio_driver;
+static int psio_refcount;
+
+#define RS_STROBE_TIME (10*HZ)
+#define RS_ISR_PASS_LIMIT 256
+
+/* number of characters left in xmit buffer before we ask for more */
+#define WAKEUP_CHARS 256
+
+static struct async_struct *IRQ_ports[NR_IRQS];
+static int IRQ_timeout[NR_IRQS];
+#ifdef CONFIG_SERIAL_CONSOLE
+static struct console cons;
+static int lsr_break_flag;
+#endif
+
+#define BAUDRATE 115200        /* Set Baudrate */
+
+/*
+ * Here we define the default xmit fifo size used for each type of
+ * UART
+ */
+static struct serial_uart_config uart_config[] = {
+	{ "unknown", 1, 0 },
+	{ "8250", 1, 0 },
+	{ "16450", 1, 0 },
+	{ "16550", 1, 0 },
+	{ "16550A", 16, UART_CLEAR_FIFO | UART_USE_FIFO },
+	{ "cirrus", 1, 0 },     /* usurped by cyclades.c */
+	{ "ST16650", 1, UART_CLEAR_FIFO | UART_STARTECH },
+	{ "ST16650V2", 32, UART_CLEAR_FIFO | UART_USE_FIFO |
+		UART_STARTECH },
+	{ "TI16750", 64, UART_CLEAR_FIFO | UART_USE_FIFO},
+	{ "Startech", 1, 0},    /* usurped by cyclades.c */
+	{ "16C950/954", 128, UART_CLEAR_FIFO | UART_USE_FIFO},
+	{ "ST16654", 64, UART_CLEAR_FIFO | UART_USE_FIFO |
+		UART_STARTECH },
+	{ "XR16850", 128, UART_CLEAR_FIFO | UART_USE_FIFO |
+		UART_STARTECH },
+	{ "RSA", 2048, UART_CLEAR_FIFO | UART_USE_FIFO },
+	{ "m32102", 1, 0 },
+	{ 0, 0}
+};
+
+static struct serial_state rs_table[RS_TABLE_SIZE] = {
+/*    UART CLK        PORT        IRQ   FLAGS        */ 
+      { 0,   BAUDRATE, ((int)PLD_ESIO0CR + NONCACHE_OFFSET), PLD_IRQ_SIO0_RCV,   STD_COM_FLAGS }, 
+};
+#define NR_PORTS    (sizeof(rs_table)/sizeof(struct serial_state))
+
+
+#define HIGH_BITS_OFFSET ((sizeof(long)-sizeof(int))*8)
+
+static DECLARE_TASK_QUEUE(tq_psio_serial);
+static struct tty_struct *psio_table[NR_PORTS];
+static struct termios *psio_termios[NR_PORTS];
+static struct termios *psio_termios_locked[NR_PORTS];
+
+#if defined(MODULE) && defined(SERIAL_DEBUG_MCOUNT)
+#define DBG_CNT(s) printk("(%s): [%x] refc=%d, serc=%d, ttyc=%d -> %s\n", \
+ kdevname(tty->device), (info->flags), serial_refcount,info->count,tty->count,s
+)
+#else
+#define DBG_CNT(s)
+#endif
+
+
+static struct timer_list serial_timer;
+
+static unsigned char *tmp_buf;
+#ifdef DECLARE_MUTEX
+static DECLARE_MUTEX(tmp_buf_sem);
+#else
+static struct semaphore tmp_buf_sem = MUTEX;
+#endif
+
+static int dbg_console_setup(struct console *console, char *options);
+
+#undef SIO0CR
+#undef SIO0MOD0
+#undef SIO0MOD1
+#undef SIO0STS
+#undef SIO0IMASK
+#undef SIO0BAUR
+#undef SIO0TXB
+#undef SIO0RXB
+#define SIO0CR     PLD_ESIO0CR
+#define SIO0MOD0   PLD_ESIO0MOD0
+#define SIO0MOD1   PLD_ESIO0MOD1
+#define SIO0STS    PLD_ESIO0STS
+#define SIO0IMASK  PLD_ESIO0INTCR
+#define SIO0BAUR   PLD_ESIO0BAUR
+#define SIO0TXB    PLD_ESIO0TXB
+#define SIO0RXB    PLD_ESIO0RXB
+
+#define SIO_IMASK_TEMPIE       (1UL<<1)  /* b14: enable */
+#define SIO_IMASK_RXCEN        (1UL<<2)  /* b13: enable */
+#define SIO_IMASK_REIE         (0UL)
+#define	SIO_SIO0STS_TEMP       (1UL<<0)  /* Transmitter Register Empty */
+#define	SIO_SIO0STS_TXCP       (1UL<<1)
+#define	SIO_SIO0STS_RXCP       (1UL<<2)
+#define	SIO_SIO0STS_OERR       (0UL)
+#define	SIO_SIO0STS_PERR       (0UL)
+#define	SIO_SIO0STS_FERR       (0UL)
+#define	SIO_SIO0MOD0_CTSS      (1UL<<6)
+#define	SIO_SIO0MOD0_RTSS      (1UL<<7)
+#define	SIO_NONE               (0UL)
+
+#define	UART_TX   	((unsigned char *)SIO0TXB - (unsigned char *)SIO0CR)
+#define	UART_RX         ((unsigned char *)SIO0RXB - (unsigned char *)SIO0CR)
+#define	UART_IER        ((unsigned char *)SIO0IMASK - (unsigned char *)SIO0CR)
+#define UART_IER_THRI   	SIO_IMASK_TEMPIE
+#define UART_IER_MSI    	SIO_NONE
+#define UART_IER_RLSI   	SIO_IMASK_RXCEN
+#define UART_IER_RDI    	SIO_IMASK_REIE
+#define	UART_LSR        ((unsigned char *)SIO0STS - (unsigned char *)SIO0CR)
+#define	UART_LSR_DR     	SIO_SIO0STS_RXCP
+#define	UART_LSR_THRE   	SIO_SIO0STS_TEMP
+#define	UART_LSR_TEMT   	SIO_SIO0STS_TXCP
+#define UART_EMPTY		(UART_LSR_TEMT | UART_LSR_THRE)
+#define	UART_LSR_BI     	SIO_NONE
+#define	UART_LSR_PE     	SIO_SIO0STS_PERR
+#define	UART_LSR_FE     	SIO_SIO0STS_FERR
+#define	UART_LSR_OE     	SIO_SIO0STS_OERR
+#define	UART_IIR	((unsigned char *)SIO0STS - (unsigned char *)SIO0CR)
+#define	UART_LCR        ((unsigned char *)SIO0CR - (unsigned char *)SIO0CR)
+#define	UART_LCR_SBC    	SIO_NONE
+#define	UART_LCR_PARITY 	SIO_NONE
+#define	UART_LCR_EPAR   	SIO_NONE
+#define	UART_LCR_SPAR   	SIO_NONE
+#define	UART_MCR        ((unsigned char *)SIO0MOD0 - (unsigned char *)SIO0CR)
+#define	UART_MCR_RTS    	SIO_SIO0MOD0_RTSS
+#define	UART_MCR_DTR    	SIO_NONE	/* SIO_SIO0MOD0_CTSS */
+#define	UART_MCR_LOOP   	SIO_NONE
+#define	UART_MCR_OUT1   	SIO_NONE
+#define	UART_MCR_OUT2   	SIO_NONE
+#define	UART_MSR        ((unsigned char *)SIO0MOD0 - (unsigned char *)SIO0CR)
+#define	UART_MSR_DCD           	SIO_NONE
+#define	UART_MSR_RI            	SIO_NONE
+#define	UART_MSR_DSR           	SIO_NONE
+#define	UART_MSR_CTS           	SIO_NONE
+
+#define	UART_BAUR       ((unsigned char *)SIO0BAUR - (unsigned char *)SIO0CR)
+#define	UART_MOD0   	((unsigned char *)SIO0MOD0 - (unsigned char *)SIO0CR)
+#define	UART_MOD1       ((unsigned char *)SIO0MOD1 - (unsigned char *)SIO0CR)
+
+static  inline unsigned int psio_in(struct async_struct *info,int offset)
+{
+	return *(volatile unsigned short *)(info->port + offset);
+}
+static inline void psio_out(struct async_struct *info,int offset,int value)
+{
+	*(volatile unsigned short *)(info->port + offset) = value;
+}
+
+#define serial_in(info, offset)            psio_in(info,(int)offset)
+#define serial_out(info, offset, value)    psio_out(info,(int)offset, value)
+#define serial_inp(info, offset)           psio_in(info,(int)offset)
+#define serial_outp(info, offset, value)   psio_out(info,(int)offset, value)
+
+
+static inline int serial_paranoia_check(struct async_struct *info,
+				        kdev_t device, const char *routine)
+{
+#ifdef SERIAL_PARANOIA_CHECK
+	static const char *badmagic =
+		"Warning: bad magic number for serial struct (%s) in %s\n";
+	static const char *badinfo =
+		"Warning: null async_struct for (%s) in %s\n";
+
+	if (!info) {
+		printk(badinfo, kdevname(device), routine);
+		return 1;
+	}
+	if (info->magic != SERIAL_MAGIC) {
+		printk(badmagic, kdevname(device), routine);
+		return 1;
+	}
+#endif
+	return 0;
+}
+
+/*
+ * ------------------------------------------------------------
+ * psio_stop() and psio_start()
+ *
+ * This routines are called before setting or resetting tty->stopped.
+ * They enable or disable transmitter interrupts, as necessary.
+ * ------------------------------------------------------------
+ */
+static void psio_stop(struct tty_struct *tty)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+
+	if (serial_paranoia_check(info, tty->device, "psio_stop"))
+		return;
+	
+	save_flags(flags); cli();
+	if (info->IER & UART_IER_THRI) {
+		info->IER &= ~UART_IER_THRI;
+		serial_out(info, UART_IER, info->IER);
+	}
+	restore_flags(flags);
+
+}
+
+static void psio_start(struct tty_struct *tty)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+	
+	if (serial_paranoia_check(info, tty->device, "psio_start"))
+		return;
+	
+	save_flags(flags); cli();
+	if (info->xmit.head != info->xmit.tail
+		&& info->xmit.buf
+		&& !(info->IER & UART_IER_THRI)) {
+		info->IER |= UART_IER_THRI;
+		serial_out(info, UART_IER, info->IER);
+		serial_out(info, UART_TX, info->xmit.buf[info->xmit.tail]);
+		info->xmit.tail = (info->xmit.tail + 1) & (SERIAL_XMIT_SIZE-1);
+		info->state->icount.tx++;
+	}
+	restore_flags(flags);
+}
+
+
+/*
+ * This routine is used by the interrupt handler to schedule
+ * processing in the software interrupt portion of the driver.
+ */
+static inline void psio_sched_event(struct async_struct *info,int event)
+{
+	info->event |= 1 << event;
+	queue_task(&info->tqueue, &tq_psio_serial);
+	mark_bh(SERIAL_BH);
+}
+
+static inline void psio_receive_chars(struct async_struct *info,int *status)
+{
+	struct tty_struct *tty = info->tty;
+	unsigned char ch;
+	struct  async_icount *icount;
+	int max_count = 256;
+
+	icount = &info->state->icount;
+	do {
+		if (tty->flip.count >= TTY_FLIPBUF_SIZE) {
+			tty->flip.tqueue.routine((void *) tty);
+			if (tty->flip.count >= TTY_FLIPBUF_SIZE)
+				return;     // if TTY_DONT_FLIP is set
+		}
+		ch = serial_inp(info, UART_RX);
+		*tty->flip.char_buf_ptr = ch;
+		icount->rx++;
+	
+#ifdef SERIAL_DEBUG_INTR
+		printk("DR%02x:%02x...", ch, *status);
+#endif
+		*tty->flip.flag_buf_ptr = 0;
+		if (*status & (UART_LSR_BI | UART_LSR_PE |
+			       UART_LSR_FE | UART_LSR_OE)) {
+			/*
+			 * For statistics only
+			 */
+			if (*status & UART_LSR_BI) {
+				*status &= ~(UART_LSR_FE | UART_LSR_PE);
+				icount->brk++;
+				/*
+				 * We do the SysRQ and SAK checking
+				 * here because otherwise the break
+				 * may get masked by ignore_status_mask
+				 * or read_status_mask.
+				 */
+#if defined(CONFIG_SERIAL_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+				if (info->line == cons.index) {
+					if (!break_pressed) {
+						break_pressed = jiffies;
+						goto ignore_char;
+					}
+					break_pressed = 0;
+				}
+#endif
+			        if (info->flags & ASYNC_SAK)
+					do_SAK(tty);
+			} else if (*status & UART_LSR_PE)
+				icount->parity++;
+			else if (*status & UART_LSR_FE)
+				icount->frame++;
+			if (*status & UART_LSR_OE)
+				icount->overrun++;
+
+			/*
+			 * Mask off conditions which should be ignored.
+			 */
+			*status &= info->read_status_mask;
+
+#ifdef CONFIG_SERIAL_CONSOLE
+			if (info->line == cons.index) {
+				/* Recover the break flag from console xmit */
+				*status |= lsr_break_flag;
+				lsr_break_flag = 0;
+			}
+#endif
+			if (*status & (UART_LSR_BI)) {
+#ifdef SERIAL_DEBUG_INTR
+				printk("handling break....");
+#endif
+				*tty->flip.flag_buf_ptr = TTY_BREAK;
+			} else if (*status & UART_LSR_PE)
+				*tty->flip.flag_buf_ptr = TTY_PARITY;
+			else if (*status & UART_LSR_FE)
+				*tty->flip.flag_buf_ptr = TTY_FRAME;
+		}
+#if defined(CONFIG_SERIAL_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+		if (break_pressed && info->line == cons.index) {
+			if (ch != 0 &&
+				time_before(jiffies, break_pressed + HZ*5)) {
+				handle_sysrq(ch, regs, NULL, NULL);
+				break_pressed = 0;
+				goto ignore_char;
+			}
+			break_pressed = 0;
+		}
+#endif
+		if ((*status & info->ignore_status_mask) == 0) {
+			tty->flip.flag_buf_ptr++;
+			tty->flip.char_buf_ptr++;
+			tty->flip.count++;
+		}
+#if defined(CONFIG_SERIAL_CONSOLE) && defined(CONFIG_MAGIC_SYSRQ)
+	ignore_char:
+#endif
+		*status = serial_inp(info, UART_LSR);
+	} while ((*status & UART_LSR_DR) && (max_count-- > 0));
+#if (LINUX_VERSION_CODE > 131394) /* 2.1.66 */
+	tty_flip_buffer_push(tty);
+#else
+	queue_task_irq_off(&tty->flip.tqueue, &tq_timer);
+#endif
+}
+
+static void transmit_chars(struct async_struct *info, int *intr_done)
+{
+	int count;
+
+	if (info->x_char) {
+		// for M32102 serial
+		// serial_outp(info, UART_TX, info->x_char);
+		info->state->icount.tx++;
+		info->x_char = 0;
+		if (intr_done)
+			*intr_done = 0;
+		while((serial_in(info,UART_LSR) & UART_LSR_TEMT) == 0);
+		return;
+	}
+	if (info->xmit.head == info->xmit.tail
+		|| info->tty->stopped
+		|| info->tty->hw_stopped) {
+		info->IER &= ~UART_IER_THRI;
+		serial_out(info, UART_IER, info->IER);
+		return;
+	}
+	count = info->xmit_fifo_size;
+	count = SERIAL_XMIT_SIZE-1;
+	do {
+		serial_out(info, UART_TX, info->xmit.buf[info->xmit.tail]);
+		info->xmit.tail = (info->xmit.tail + 1) & (SERIAL_XMIT_SIZE-1);
+		info->state->icount.tx++;
+
+		if (info->xmit.head == info->xmit.tail)
+			break;
+
+		while((serial_in(info,UART_LSR) & UART_LSR_THRE) == 0);
+	} while (--count > 0);
+	while((serial_in(info,UART_LSR) & UART_LSR_TEMT) == 0);
+
+	if (CIRC_CNT(info->xmit.head,
+			 info->xmit.tail,
+			 SERIAL_XMIT_SIZE) < WAKEUP_CHARS)
+		psio_sched_event(info, RS_EVENT_WRITE_WAKEUP);
+
+#ifdef SERIAL_DEBUG_INTR
+	printk("THRE...");
+#endif
+	if (intr_done)
+		*intr_done = 0;
+
+	if (info->xmit.head == info->xmit.tail) {
+		info->IER &= ~UART_IER_THRI;
+		serial_out(info, UART_IER, info->IER);
+	}
+}
+
+
+/*
+
+#ifdef CONFIG_SERIAL_SHARE_IRQ
+static void rs_interrupt(int irq, void *dev_id, struct pt_regs * regs)
+#endif 
+*/
+
+static void sio_reset(struct async_struct *info)
+{
+	unsigned int dummy;
+	/* reset sio */
+	/* read receive buffer */
+	dummy = serial_inp(info, UART_RX);
+	dummy = serial_inp(info, UART_RX);
+	dummy = serial_inp(info, UART_LSR);
+	serial_outp(info, UART_LCR, 0x0300);	/* RSCLR:1, TSCLR:1 */
+	serial_outp(info, UART_LCR, 0x0003);	/* RSEN:1, TXEN:1 */
+}
+
+static void sio_error(struct async_struct *info,int status)
+{
+	unsigned int dummy;
+	/* reset sio */
+	printk("sio[%d] error[%04x]\n", info->line,status);
+	/* read receive buffer */
+	dummy = serial_inp(info, UART_RX);
+	dummy = serial_inp(info, UART_RX);
+	dummy = serial_inp(info, UART_LSR);
+	serial_outp(info, UART_LCR, 0x0300);	/* RSCLR:1, TSCLR:1 */
+	serial_outp(info, UART_LCR, 0x0003);	/* RSEN:1, TXEN:1 */
+}
+
+//static void psio_interrupt_single(int irq, void *dev_id, struct pt_regs * regs)
+void psio_interrupt_single(int irq, void *dev_id, struct pt_regs * regs)
+{
+	int status;
+	// int pass_counter = 0;
+	struct async_struct * info;
+
+#ifdef CONFIG_SERIAL_MULTIPORT
+	int first_multi = 0;
+	struct rs_multiport_struct *multi;
+#endif
+
+#ifdef SERIAL_DEBUG_INTR
+	printk("psio_interrupt_single(%d)...", irq);
+#endif
+	
+	info = IRQ_ports[irq&(~1)];
+	if (!info || !info->tty)
+		return;
+
+#ifdef CONFIG_SERIAL_MULTIPORT
+	multi = &rs_multiport[irq];
+	if (multi->port_monitor)
+		first_multi = inb(multi->port_monitor);
+#endif
+
+	{
+		status = serial_inp(info, UART_LSR);
+#ifdef SERIAL_DEBUG_INTR
+		printk("status = %x...", status);
+#endif
+		if (status & UART_LSR_DR){
+			psio_receive_chars(info, &status);
+		}
+		if ((serial_in(info,UART_LSR) & UART_EMPTY) != UART_EMPTY)
+			sio_error(info, status);
+		if (status & UART_LSR_THRE)
+			transmit_chars(info, 0);
+#ifdef SERIAL_DEBUG_INTR
+		printk("IIR = %x...", serial_in(info, UART_IIR));
+#endif
+	}
+
+	info->last_active = jiffies;
+#ifdef CONFIG_SERIAL_MULTIPORT
+	if (multi->port_monitor)
+			printk("rs port monitor (single) irq %d: 0x%x, 0x%x\n",
+			info->state->irq, first_multi,
+			inb(multi->port_monitor));
+#endif
+#ifdef SERIAL_DEBUG_INTR
+	printk("end.\n");
+#endif
+}
+#ifdef CONFIG_SERIAL_MULTIPORT
+static void rs_interrupt_multi(int irq, void *dev_id, struct pt_regs * regs)
+{}
+#endif
+
+static void do_psio_serial_bh(void)
+{
+	run_task_queue(&tq_psio_serial);
+}
+
+static void do_softint(void *private_)
+{
+	struct async_struct *info = (struct async_struct *) private_;
+	struct tty_struct *tty;
+	
+	tty = info->tty;
+	if (!tty)
+		return;
+
+	if (test_and_clear_bit(RS_EVENT_WRITE_WAKEUP, &info->event)) {
+		if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
+			tty->ldisc.write_wakeup)
+			(tty->ldisc.write_wakeup)(tty);
+		wake_up_interruptible(&tty->write_wait);
+#ifdef SERIAL_HAVE_POLL_WAIT
+		wake_up_interruptible(&tty->poll_wait);
+#endif
+	}
+}
+
+static void psio_timer(void)
+{
+	static unsigned long last_strobe = 0;
+	struct async_struct *info;
+	unsigned int  i;
+	unsigned long flags;
+
+	if ((jiffies - last_strobe) >= RS_STROBE_TIME) {
+		for (i=0; i < NR_IRQS; i++) {
+			info = IRQ_ports[i];
+			if (!info)
+				continue;
+			save_flags(flags); cli();
+			psio_interrupt_single(i, NULL, NULL);
+			restore_flags(flags);
+		}
+	}
+	last_strobe = jiffies;
+
+#if 1
+	mod_timer(&serial_timer, jiffies + 10);
+#else 
+	mod_timer(&serial_timer, jiffies + RS_STROBE_TIME);
+#endif
+
+	if (IRQ_ports[0]) {
+		save_flags(flags); cli();
+#ifdef CONFIG_SERIAL_SHARE_IRQ
+		psio_interrupt(0, NULL, NULL);
+#else
+		psio_interrupt_single(0, NULL, NULL);
+#endif
+		restore_flags(flags);
+
+		mod_timer(&serial_timer, jiffies + IRQ_timeout[0]);
+	}
+}
+
+/*
+ * ---------------------------------------------------------------
+ * Low level utility subroutines for the serial driver:  routines to
+ * figure out the appropriate timeout for an interrupt chain, routines
+ * to initialize and startup a serial port, and routines to shutdown a
+ * serial port.  Useful stuff like that.
+ * ---------------------------------------------------------------
+ */
+
+/*
+ * This routine figures out the correct timeout for a particular IRQ.
+ * It uses the smallest timeout of all of the serial ports in a
+ * particular interrupt chain.  Now only used for IRQ 0....
+ */
+static void figure_IRQ_timeout(int irq)
+{
+	struct  async_struct    *info;
+	int timeout = 60*HZ;    /* 60 seconds === a long time :-) */
+
+	info = IRQ_ports[irq];
+	if (!info) {
+		IRQ_timeout[irq] = 60*HZ;
+		return;
+	}
+	while (info) {
+		if (info->timeout < timeout)
+			timeout = info->timeout;
+		info = info->next_port;
+	}
+	if (!irq)
+		timeout = timeout / 2;
+	IRQ_timeout[irq] = timeout ? timeout : 1;
+}
+
+#ifdef CONFIG_SERIAL_RSA
+/* Attempts to turn on the RSA FIFO.  Returns zero on failure */
+static int enable_rsa(struct async_struct *info) {}
+
+/* Attempts to turn off the RSA FIFO.  Returns zero on failure */
+static int disable_rsa(struct async_struct *info) { }
+#endif /* CONFIG_SERIAL_RSA */
+
+static int startup(struct async_struct * info)
+{
+	unsigned long flags;
+	int retval=0;
+	void (*handler)(int, void *, struct pt_regs *);
+	struct serial_state *state= info->state;
+	unsigned long page;
+#ifdef CONFIG_SERIAL_MANY_PORTS
+	unsigned short ICP;
+#endif
+
+	page = get_zeroed_page(GFP_KERNEL);
+	if (!page)
+		return -ENOMEM;
+
+	save_flags(flags); cli();
+
+	if (info->flags & ASYNC_INITIALIZED) {
+		free_page(page);
+		goto errout;
+	}
+	if (info->xmit.buf)
+		free_page(page);
+	else
+		info->xmit.buf = (unsigned char *) page;
+
+#ifdef SERIAL_DEBUG_OPEN
+	printk("starting up ttyD%d (irq %d)...", info->line, state->irq);
+#endif
+
+	/*
+	 * Clear the FIFO buffers and disable them
+	 * (they will be reenabled in change_speed())
+	 */
+
+	/*
+	 * Clear the interrupt registers.
+	 */
+	sio_reset(info);
+
+	/*
+	 * Allocate the IRQ if necessary
+	 */
+	if (state->irq && (!IRQ_ports[state->irq] ||
+			   !IRQ_ports[state->irq]->next_port)) {
+		if (IRQ_ports[state->irq]) {
+#ifdef CONFIG_SERIAL_SHARE_IRQ
+			free_irq(state->irq, &IRQ_ports[state->irq]);
+			free_irq(state->irq+1, &IRQ_ports[state->irq]);
+#ifdef CONFIG_SERIAL_MULTIPORT
+			if (rs_multiport[state->irq].port1)
+				handler = rs_interrupt_multi;
+			else
+#endif
+				handler = psio_interrupt;
+#else
+			retval = -EBUSY;
+			goto errout;
+#endif /* CONFIG_SERIAL_SHARE_IRQ */
+		} else
+			handler = psio_interrupt_single;
+
+		/* 020116 */
+		retval = request_irq(state->irq, handler, SA_SHIRQ,
+			"serial_rx", &IRQ_ports[state->irq]);
+		retval = request_irq(state->irq+1, handler, SA_SHIRQ,
+			"serial_tx", &IRQ_ports[state->irq]);
+		if (retval) {
+			if (capable(CAP_SYS_ADMIN)) {
+				if (info->tty)
+					set_bit(TTY_IO_ERROR,
+						&info->tty->flags);
+				retval = 0;
+			}
+			goto errout;
+		}
+	}
+
+	/*
+	 * Insert serial port into IRQ chain.
+	 */
+	info->prev_port = 0;
+	info->next_port = IRQ_ports[state->irq];
+	if (info->next_port)
+		info->next_port->prev_port = info;
+	IRQ_ports[state->irq] = info;
+	figure_IRQ_timeout(state->irq);
+
+	/*
+	 * Now, initialize the UART
+	 */
+	/* for m32r @020113 */
+	sio_reset(info);
+
+	info->MCR = 0;
+	if (info->tty->termios->c_cflag & CBAUD)
+		info->MCR = UART_MCR_DTR | UART_MCR_RTS;
+#ifdef CONFIG_SERIAL_MANY_PORTS
+	if (info->flags & ASYNC_FOURPORT) {
+		if (state->irq == 0)
+			info->MCR |= UART_MCR_OUT1;
+	} else
+#endif
+	{
+		if (state->irq != 0)
+			info->MCR |= UART_MCR_OUT2;
+	}
+	info->MCR |= ALPHA_KLUDGE_MCR;      /* Don't ask */
+	serial_outp(info, UART_MCR, info->MCR);
+
+	/*
+	 * Finally, enable interrupts
+	 */
+	info->IER = UART_IER_MSI | UART_IER_RLSI | UART_IER_RDI;
+	serial_outp(info, UART_IER, info->IER); /* enable interrupts */
+
+#ifdef CONFIG_SERIAL_MANY_PORTS
+	if (info->flags & ASYNC_FOURPORT) {
+		/* Enable interrupts on the AST Fourport board */
+		ICP = (info->port & 0xFE0) | 0x01F;
+		outb_p(0x80, ICP);
+		(void) inb_p(ICP);
+	}
+#endif
+
+	/*
+	 * And clear the interrupt registers again for luck.
+	 */
+	(void)serial_inp(info, UART_LSR);
+	(void)serial_inp(info, UART_RX);
+	(void)serial_inp(info, UART_IIR);
+	(void)serial_inp(info, UART_MSR);
+
+	if (info->tty)
+		clear_bit(TTY_IO_ERROR, &info->tty->flags);
+	info->xmit.head = info->xmit.tail = 0;
+
+	/*
+	 * Set up serial timers...
+	 */
+	mod_timer(&serial_timer, jiffies + 2*HZ/100);
+
+	/*
+	 * Set up the tty->alt_speed kludge
+	 */
+#if (LINUX_VERSION_CODE >= 131394) /* Linux 2.1.66 */
+	if (info->tty) {
+		if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)
+			info->tty->alt_speed = 57600;
+		if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)
+			info->tty->alt_speed = 115200;
+		if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)
+			info->tty->alt_speed = 230400;
+		if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)
+			info->tty->alt_speed = 460800;
+	}
+#endif
+
+	/*
+	 * and set the speed of the serial port
+	 */
+	change_speed(info, 0);
+
+	info->flags |= ASYNC_INITIALIZED;
+	restore_flags(flags);
+	return 0;
+
+errout:
+	restore_flags(flags);
+	return retval;
+}
+
+/*
+ * This routine will shutdown a serial port; interrupts are disabled, and
+ * DTR is dropped if the hangup on close termio flag is on.
+ */
+static void shutdown(struct async_struct * info)
+{
+	unsigned long   flags;
+	struct serial_state *state;
+	int     retval;
+
+	if (!(info->flags & ASYNC_INITIALIZED))
+		return;
+
+	state = info->state;
+
+#ifdef SERIAL_DEBUG_OPEN
+	printk("Shutting down serial port %d (irq %d)....", info->line,
+		   state->irq);
+#endif
+
+	save_flags(flags); cli(); /* Disable interrupts */
+
+	/*
+	 * clear delta_msr_wait queue to avoid mem leaks: we may free the irq
+	 * here so the queue might never be waken up
+	 */
+	wake_up_interruptible(&info->delta_msr_wait);
+
+	/*
+	 * First unlink the serial port from the IRQ chain...
+	 */
+	if (info->next_port)
+		info->next_port->prev_port = info->prev_port;
+	if (info->prev_port)
+		info->prev_port->next_port = info->next_port;
+	else
+		IRQ_ports[state->irq] = info->next_port;
+	figure_IRQ_timeout(state->irq);
+
+	/*
+	 * Free the IRQ, if necessary
+	 */
+	if (state->irq && (!IRQ_ports[state->irq] ||
+			  !IRQ_ports[state->irq]->next_port)) {
+		if (IRQ_ports[state->irq]) {
+			/* 020116 */
+			free_irq(state->irq+1, &IRQ_ports[state->irq]);
+			retval = request_irq(state->irq+1, psio_interrupt_single,
+				         SA_SHIRQ, "serial_xx",
+				         &IRQ_ports[state->irq]);
+			free_irq(state->irq, &IRQ_ports[state->irq]);
+			retval = request_irq(state->irq, psio_interrupt_single,
+				         SA_SHIRQ, "serial",
+				         &IRQ_ports[state->irq]);
+
+			if (retval)
+				printk("serial shutdown: request_irq: error %d"
+				       "  Couldn't reacquire IRQ.\n", retval);
+		} else{
+			free_irq(state->irq, &IRQ_ports[state->irq]);
+			/* 020116 */
+			free_irq(state->irq+1, &IRQ_ports[state->irq]);
+		}
+	}
+	if (info->xmit.buf) {
+		unsigned long pg = (unsigned long) info->xmit.buf;
+		info->xmit.buf = 0;
+		free_page(pg);
+	}
+
+	info->IER = 0;
+	serial_outp(info, UART_IER, 0x00);  /* disable all intrs */
+#ifdef CONFIG_SERIAL_MANY_PORTS
+	if (info->flags & ASYNC_FOURPORT) {
+		/* reset interrupts on the AST Fourport board */
+		(void) inb((info->port & 0xFE0) | 0x01F);
+		info->MCR |= UART_MCR_OUT1;
+	} else
+#endif
+	if (!info->tty || (info->tty->termios->c_cflag & HUPCL))
+		info->MCR &= ~(UART_MCR_DTR|UART_MCR_RTS);
+	serial_outp(info, UART_MCR, info->MCR);
+
+#ifdef CONFIG_SERIAL_RSA
+	/*
+	 * Reset the RSA board back to 115kbps compat mode.
+	 */
+	if ((state->type == PORT_RSA) &&
+		(state->baud_base == SERIAL_RSA_BAUD_BASE &&
+		 disable_rsa(info)))
+		state->baud_base = SERIAL_RSA_BAUD_BASE_LO;
+#endif
+
+
+	(void)serial_in(info, UART_RX);    /* read data port to reset things */
+
+	if (info->tty)
+		set_bit(TTY_IO_ERROR, &info->tty->flags);
+
+	sio_reset(info);
+
+	info->flags &= ~ASYNC_INITIALIZED;
+	restore_flags(flags);
+}
+
+static void change_speed(struct async_struct *info,struct termios *old_termios)
+{
+	int quot = 0, baud_base, baud;
+	unsigned cflag, cval = 0;
+	int bits;
+	unsigned long   flags;
+	unsigned mod0, mod1;
+
+	if (!info->tty || !info->tty->termios)
+		return;
+	cflag = info->tty->termios->c_cflag;
+	if (!CONFIGURED_SERIAL_PORT(info))
+		return;
+
+	/* byte size and parity */
+	switch (cflag & CSIZE) {
+		  case CS5: mod1 = 0x05; bits = 7; break;
+		  case CS6: mod1 = 0x06; bits = 8; break;
+		  case CS7: mod1 = 0x07; bits = 9; break;
+		  case CS8: mod1 = 0x08; bits = 10; break;
+		  /* Never happens, but GCC is too dumb to figure it out */
+		  default:  mod1 = 0x05; bits = 7; break;
+	}
+	mod1 <<= 8;
+	mod0 = 0;
+	if (cflag & CSTOPB) {
+		mod0 |= 0x03;
+		bits++;
+	}
+	if (cflag & PARENB) {
+		mod0 |= 0x10;
+		bits++;
+	}
+	if (!(cflag & PARODD)) {
+		mod0 |= 0x4;
+	}
+	mod0 = 0x80;	/* Use RTS# output only */
+
+	serial_outp(info, UART_MOD0, mod0);      /* */
+	//serial_outp(info, UART_MOD1, mod1); 
+	//mod1 = 0;
+	info->LCR = mod1;               /* Save LCR */
+
+	/* Determine divisor based on baud rate */
+	baud = tty_get_baud_rate(info->tty);
+	if (!baud)
+		baud = 9600;    /* B0 transition handled in rs_set_termios */
+#ifdef CONFIG_SERIAL_RSA
+	if ((info->state->type == PORT_RSA) &&
+		(info->state->baud_base != SERIAL_RSA_BAUD_BASE) &&
+		enable_rsa(info))
+		info->state->baud_base = SERIAL_RSA_BAUD_BASE;
+#endif
+	baud_base = info->state->baud_base;
+
+	if (baud == 38400 &&
+		((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST))
+		quot = info->state->custom_divisor;
+	else {
+		if (baud == 134)
+			/* Special case since 134 is really 134.5 */
+			quot = (2*baud_base / 269);
+		else if (baud)
+			quot = baud_base / baud;
+	}
+	/* If the quotient is zero refuse the change */
+	if (!quot && old_termios) {
+		info->tty->termios->c_cflag &= ~CBAUD;
+		info->tty->termios->c_cflag |= (old_termios->c_cflag & CBAUD);
+		baud = tty_get_baud_rate(info->tty);
+		if (!baud)
+			baud = 9600;
+		if (baud == 38400 &&
+			((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST))
+			quot = info->state->custom_divisor;
+		else {
+			if (baud == 134)
+				/* Special case since 134 is really 134.5 */
+				quot = (2*baud_base / 269);
+			else if (baud)
+				quot = baud_base / baud ;
+		}
+	}
+	quot = baud_base / (baud*4) ;
+	/* As a last resort, if the quotient is zero, default to 9600 bps */
+	if (!quot)
+		quot = baud_base / 9600;
+	/*
+	 * Work around a bug in the Oxford Semiconductor 952 rev B
+	 * chip which causes it to seriously miscalculate baud rates
+	 * when DLL is 0.
+	 */
+	if (((quot & 0xFF) == 0) && (info->state->type == PORT_16C950) &&
+		(info->state->revision == 0x5201))
+		quot++;
+
+	info->quot = quot;
+	info->timeout = ((info->xmit_fifo_size*HZ*bits*quot) / baud_base);
+	info->timeout += HZ/50;     /* Add .02 seconds of slop */
+
+	/* CTS flow control flag and modem status interrupts */
+	info->IER &= ~UART_IER_MSI;
+	if (info->flags & ASYNC_HARDPPS_CD)
+		info->IER |= UART_IER_MSI;
+	if (cflag & CRTSCTS) {
+		info->flags |= ASYNC_CTS_FLOW;
+		info->IER |= UART_IER_MSI;
+	} else
+		info->flags &= ~ASYNC_CTS_FLOW;
+	if (cflag & CLOCAL)
+		info->flags &= ~ASYNC_CHECK_CD;
+	else {
+		info->flags |= ASYNC_CHECK_CD;
+		info->IER |= UART_IER_MSI;
+	}
+	serial_out(info, UART_IER, info->IER);
+
+	/*
+	 * Set up parity check flag
+	 */
+#define RELEVANT_IFLAG(iflag) (iflag & (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))
+
+	info->read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;
+	if (I_INPCK(info->tty))
+		info->read_status_mask |= UART_LSR_FE | UART_LSR_PE;
+	if (I_BRKINT(info->tty) || I_PARMRK(info->tty))
+		info->read_status_mask |= UART_LSR_BI;
+
+	/*
+	 * Characters to ignore
+	 */
+	info->ignore_status_mask = 0;
+	if (I_IGNPAR(info->tty))
+		info->ignore_status_mask |= UART_LSR_PE | UART_LSR_FE;
+	if (I_IGNBRK(info->tty)) {
+		info->ignore_status_mask |= UART_LSR_BI;
+		/*
+		 * If we're ignore parity and break indicators, ignore
+		 * overruns too.  (For real raw support).
+		 */
+		if (I_IGNPAR(info->tty))
+			info->ignore_status_mask |= UART_LSR_OE;
+	}
+	/*
+	 * !!! ignore all characters if CREAD is not set
+	 */
+	if ((cflag & CREAD) == 0)
+		info->ignore_status_mask |= UART_LSR_DR;
+	cval = (baud_base / (baud * 4)) - 1;
+
+	save_flags(flags); cli();
+	serial_outp(info, UART_BAUR, cval );  /* set baurate reg */
+	serial_outp(info, UART_LCR, 0x03);
+	restore_flags(flags);
+}
+
+static void psio_put_char(struct tty_struct *tty, unsigned char ch)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+
+	if (serial_paranoia_check(info, tty->device, "psio_put_char"))
+		return;
+
+	if (!tty || !info->xmit.buf)
+		return;
+
+	save_flags(flags); cli();
+	if (CIRC_SPACE(info->xmit.head,
+			   info->xmit.tail,
+			   SERIAL_XMIT_SIZE) == 0) {
+		restore_flags(flags);
+		return;
+	}
+
+	info->xmit.buf[info->xmit.head] = ch;
+	info->xmit.head = (info->xmit.head + 1) & (SERIAL_XMIT_SIZE-1);
+	restore_flags(flags);
+}
+
+static void psio_flush_chars(struct tty_struct *tty)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+
+	if (serial_paranoia_check(info, tty->device, "psio_flush_chars"))
+		return;
+
+	if (info->xmit.head == info->xmit.tail
+		|| tty->stopped
+		|| tty->hw_stopped
+		|| !info->xmit.buf)
+		return;
+
+	save_flags(flags); cli();
+	if (!(info->IER & UART_IER_THRI)) {
+		info->IER |= UART_IER_THRI;
+		serial_out(info, UART_IER, info->IER);
+		serial_out(info, UART_TX, info->xmit.buf[info->xmit.tail]);
+		info->xmit.tail = (info->xmit.tail + 1) & (SERIAL_XMIT_SIZE-1);
+		info->state->icount.tx++;
+	}
+	restore_flags(flags);
+	while((serial_in(info,UART_LSR) & UART_EMPTY) != UART_EMPTY);
+}
+
+static int psio_write(struct tty_struct *tty, int from_user, 
+		    const unsigned char *buf, int count)
+{
+	int c, ret = 0;
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+		
+	if (serial_paranoia_check(info, tty->device, "psio_write"))
+		return 0;
+
+	if (!tty || !info->xmit.buf || !tmp_buf)
+		return 0;
+
+	save_flags(flags);
+	if (from_user) {
+		down(&tmp_buf_sem);
+		while (1) {
+			int c1;
+			c = CIRC_SPACE_TO_END(info->xmit.head,
+					info->xmit.tail,
+					SERIAL_XMIT_SIZE);
+			if (count < c)
+				c = count;
+			if (c <= 0)
+				break;
+
+			c -= copy_from_user(tmp_buf, buf, c);
+			if (!c) {
+				if (!ret)
+					ret = -EFAULT;
+				break;
+			}
+			cli();
+			c1 = CIRC_SPACE_TO_END(info->xmit.head,
+					info->xmit.tail,
+					SERIAL_XMIT_SIZE);
+			if (c1 < c)
+				c = c1;
+			memcpy(info->xmit.buf + info->xmit.head, tmp_buf, c);
+			info->xmit.head = ((info->xmit.head + c) &
+					(SERIAL_XMIT_SIZE-1));
+			restore_flags(flags);
+			buf += c;
+			count -= c;
+			ret += c;
+		}
+		up(&tmp_buf_sem);
+	} else {
+		cli();
+		while (1) {
+			c = CIRC_SPACE_TO_END(info->xmit.head,
+					info->xmit.tail,
+					SERIAL_XMIT_SIZE);
+			if (count < c)
+				c = count;
+			if (c <= 0) {
+				break;
+			}
+			memcpy(info->xmit.buf + info->xmit.head, buf, c);
+			info->xmit.head = ((info->xmit.head + c) &
+				 (SERIAL_XMIT_SIZE-1));
+			buf += c;
+			count -= c;
+			ret += c;
+		}
+		restore_flags(flags);
+	}
+	save_flags(flags); cli();
+	if (info->xmit.head != info->xmit.tail
+		&& !tty->stopped
+		&& !tty->hw_stopped
+		&& !(info->IER & UART_IER_THRI)) {
+		info->IER |= UART_IER_THRI;
+		serial_out(info, UART_IER, info->IER);
+		serial_out(info, UART_TX, info->xmit.buf[info->xmit.tail]);
+		info->xmit.tail = (info->xmit.tail + 1) & (SERIAL_XMIT_SIZE-1);
+		info->state->icount.tx++;
+	}
+	restore_flags(flags);
+	while((serial_in(info,UART_LSR) & UART_EMPTY) != UART_EMPTY);
+	return ret;
+}
+
+static int psio_write_room(struct tty_struct *tty)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+
+	if (serial_paranoia_check(info, tty->device, "psio_write_room"))
+		return 0;
+	return CIRC_SPACE(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE);
+}
+
+static int psio_chars_in_buffer(struct tty_struct *tty)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+		
+	if (serial_paranoia_check(info, tty->device, "psio_chars_in_buffer"))
+		return 0;
+	return CIRC_CNT(info->xmit.head, info->xmit.tail, SERIAL_XMIT_SIZE);
+}
+
+static void psio_flush_buffer(struct tty_struct *tty)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+
+	if (serial_paranoia_check(info, tty->device, "psio_flush_buffer"))
+		return;
+	save_flags(flags); cli();
+	info->xmit.head = info->xmit.tail = 0;
+	restore_flags(flags);
+	wake_up_interruptible(&tty->write_wait);
+#ifdef SERIAL_HAVE_POLL_WAIT
+	wake_up_interruptible(&tty->poll_wait);
+#endif
+	if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
+			 tty->ldisc.write_wakeup)
+		(tty->ldisc.write_wakeup)(tty);
+}
+
+/*
+ * This function is used to send a high-priority XON/XOFF character to
+ * the device
+ */
+static void psio_send_xchar(struct tty_struct *tty, char ch)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+
+	if (serial_paranoia_check(info, tty->device, "psio_send_char"))
+		return;
+
+	info->x_char = ch;
+	if (ch) {
+		unsigned long flags;
+		save_flags(flags); cli();
+		if (!(info->IER & UART_IER_THRI)) {
+	   		info->IER |= UART_IER_THRI;
+			serial_out(info, UART_IER, info->IER);
+			serial_out(info, UART_TX, info->x_char);
+		}
+		restore_flags(flags);
+	}
+}
+
+/*
+ * ------------------------------------------------------------
+ * rs_throttle()
+ *
+ * This routine is called by the upper-layer tty layer to signal that
+ * incoming characters should be throttled.
+ * ------------------------------------------------------------
+ */
+static void psio_throttle(struct tty_struct * tty)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+#ifdef SERIAL_DEBUG_THROTTLE
+	char    buf[64];
+
+	printk("throttle %s: %d....\n", tty_name(tty, buf),
+		tty->ldisc.chars_in_buffer(tty));
+#endif
+
+	if (serial_paranoia_check(info, tty->device, "psio_throttle"))
+		return;
+
+	if (I_IXOFF(tty))
+		psio_send_xchar(tty, STOP_CHAR(tty));
+
+	if (tty->termios->c_cflag & CRTSCTS)
+		info->MCR &= ~UART_MCR_RTS;
+
+	save_flags(flags); cli();
+	serial_out(info, UART_MCR, info->MCR);
+	restore_flags(flags);
+}
+
+static void psio_unthrottle(struct tty_struct * tty)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+#ifdef SERIAL_DEBUG_THROTTLE
+	char    buf[64];
+
+	printk("unthrottle %s: %d....\n", tty_name(tty, buf),
+		tty->ldisc.chars_in_buffer(tty));
+#endif
+
+	if (serial_paranoia_check(info, tty->device, "psio_unthrottle"))
+		return;
+
+	if (I_IXOFF(tty)) {
+		if (info->x_char) info->x_char = 0;
+	}
+	if (tty->termios->c_cflag & CRTSCTS)
+		info->MCR |= UART_MCR_RTS;
+	save_flags(flags); cli();
+	serial_out(info, UART_MCR, info->MCR);
+	restore_flags(flags);
+}
+
+/*
+ * ------------------------------------------------------------
+ * rs_ioctl() and friends
+ * ------------------------------------------------------------
+ */
+
+static int get_serial_info(struct async_struct * info,
+			   struct serial_struct * retinfo)
+{
+	struct serial_struct tmp;
+	struct serial_state *state = info->state;
+
+	if (!retinfo)
+		return -EFAULT;
+	memset(&tmp, 0, sizeof(tmp));
+	tmp.type = state->type;
+	tmp.line = state->line;
+	tmp.port = state->port;
+	if (HIGH_BITS_OFFSET)
+		tmp.port_high = state->port >> HIGH_BITS_OFFSET;
+	else
+		tmp.port_high = 0;
+	tmp.irq = state->irq;
+	tmp.flags = state->flags;
+	tmp.xmit_fifo_size = state->xmit_fifo_size;
+	tmp.baud_base = state->baud_base;
+	tmp.close_delay = state->close_delay;
+	tmp.closing_wait = state->closing_wait;
+	tmp.custom_divisor = state->custom_divisor;
+	tmp.hub6 = state->hub6;
+	tmp.io_type = state->io_type;
+	if (copy_to_user(retinfo,&tmp,sizeof(*retinfo)))
+		return -EFAULT;
+	return 0;
+}
+
+static int set_serial_info(struct async_struct * info,
+			   struct serial_struct * new_info)
+{
+	struct serial_struct new_serial;
+	struct serial_state old_state, *state;
+	unsigned int		i,change_irq,change_port;
+	int			retval = 0;
+	unsigned long		new_port;
+
+	if (copy_from_user(&new_serial,new_info,sizeof(new_serial)))
+		return -EFAULT;
+	state = info->state;
+	old_state = *state;
+
+	new_port = new_serial.port;
+	if (HIGH_BITS_OFFSET)
+		new_port += (unsigned long) new_serial.port_high << HIGH_BITS_OFFSET;
+
+	change_irq = new_serial.irq != state->irq;
+	change_port = (new_port != ((int) state->port)) ||
+		(new_serial.hub6 != state->hub6);
+
+	if (!capable(CAP_SYS_ADMIN)) {
+		if (change_irq || change_port ||
+		    (new_serial.baud_base != state->baud_base) ||
+		    (new_serial.type != state->type) ||
+		    (new_serial.close_delay != state->close_delay) ||
+		    (new_serial.xmit_fifo_size != state->xmit_fifo_size) ||
+		    ((new_serial.flags & ~ASYNC_USR_MASK) !=
+		    (state->flags & ~ASYNC_USR_MASK)))
+			return -EPERM;
+		state->flags = ((state->flags & ~ASYNC_USR_MASK) |
+					(new_serial.flags & ASYNC_USR_MASK));
+		info->flags = ((info->flags & ~ASYNC_USR_MASK) |
+				   (new_serial.flags & ASYNC_USR_MASK));
+		state->custom_divisor = new_serial.custom_divisor;
+		goto check_and_exit;
+	}
+
+	new_serial.irq = irq_cannonicalize(new_serial.irq);
+
+	if ((new_serial.irq >= NR_IRQS) || (new_serial.irq < 0) ||
+	    (new_serial.baud_base < 9600)|| (new_serial.type < PORT_UNKNOWN) ||
+	    (new_serial.type > PORT_MAX) || (new_serial.type == PORT_CIRRUS) ||
+	    (new_serial.type == PORT_STARTECH)) {
+		return -EINVAL;
+	}
+
+	if ((new_serial.type != state->type) ||
+		(new_serial.xmit_fifo_size <= 0))
+		new_serial.xmit_fifo_size =
+			uart_config[new_serial.type].dfl_xmit_fifo_size;
+
+	/* Make sure address is not already in use */
+	if (new_serial.type) {
+		for (i = 0 ; i < NR_PORTS; i++)
+			if ((state != &rs_table[i]) &&
+			    (rs_table[i].port == new_port) &&
+			    rs_table[i].type)
+				return -EADDRINUSE;
+	}
+
+	if ((change_port || change_irq) && (state->count > 1))
+		return -EBUSY;
+
+	/*
+	 * OK, past this point, all the error checking has been done.
+	 * At this point, we start making changes.....
+	 */
+
+	state->baud_base = new_serial.baud_base;
+	state->flags = ((state->flags & ~ASYNC_FLAGS) |
+			(new_serial.flags & ASYNC_FLAGS));
+	info->flags = ((state->flags & ~ASYNC_INTERNAL_FLAGS) |
+			   (info->flags & ASYNC_INTERNAL_FLAGS));
+	state->custom_divisor = new_serial.custom_divisor;
+	state->close_delay = new_serial.close_delay * HZ/100;
+	state->closing_wait = new_serial.closing_wait * HZ/100;
+#if (LINUX_VERSION_CODE > 0x20100)
+	info->tty->low_latency = (info->flags & ASYNC_LOW_LATENCY) ? 1 : 0;
+#endif
+	info->xmit_fifo_size = state->xmit_fifo_size =
+		new_serial.xmit_fifo_size;
+
+	if ((state->type != PORT_UNKNOWN) && state->port) {
+#ifdef CONFIG_SERIAL_RSA
+		if (old_state.type == PORT_RSA)
+			release_region(state->port + UART_RSA_BASE, 16);
+		else
+#endif
+		release_region(state->port,8);
+	}
+	state->type = new_serial.type;
+	if (change_port || change_irq) {
+		/*
+		 * We need to shutdown the serial port at the old
+		 * port/irq combination.
+		 */
+		shutdown(info);
+		state->irq = new_serial.irq;
+		info->port = state->port = new_port;
+		info->hub6 = state->hub6 = new_serial.hub6;
+		if (info->hub6)
+			info->io_type = state->io_type = SERIAL_IO_HUB6;
+		else if (info->io_type == SERIAL_IO_HUB6)
+			info->io_type = state->io_type = SERIAL_IO_PORT;
+	}
+	if ((state->type != PORT_UNKNOWN) && state->port) {
+#ifdef CONFIG_SERIAL_RSA
+		if (state->type == PORT_RSA)
+			request_region(state->port + UART_RSA_BASE,
+				       16, "serial_rsa(set)");
+		else
+#endif
+			request_region(state->port,8,"serial(set)");
+	}
+
+
+check_and_exit:
+	if (!state->port || !state->type)
+		return 0;
+	if (info->flags & ASYNC_INITIALIZED) {
+		if (((old_state.flags & ASYNC_SPD_MASK) !=
+			 (state->flags & ASYNC_SPD_MASK)) ||
+			(old_state.custom_divisor != state->custom_divisor)) {
+#if (LINUX_VERSION_CODE >= 131394) /* Linux 2.1.66 */
+			if ((state->flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)
+				info->tty->alt_speed = 57600;
+			if ((state->flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)
+				info->tty->alt_speed = 115200;
+			if ((state->flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)
+				info->tty->alt_speed = 230400;
+			if ((state->flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)
+				info->tty->alt_speed = 460800;
+#endif
+			change_speed(info, 0);
+		}
+	} else
+		retval = startup(info);
+	return retval;
+}
+
+/*
+ * get_lsr_info - get line status register info
+ *
+ * Purpose: Let user call ioctl() to get info when the UART physically
+ *      is emptied.  On bus types like RS485, the transmitter must
+ *      release the bus after transmitting. This must be done when
+ *      the transmit shift register is empty, not be done when the
+ *      transmit holding register is empty.  This functionality
+ *      allows an RS485 driver to be written in user space.
+ */
+static int get_lsr_info(struct async_struct * info, unsigned int *value)
+{
+	unsigned char status;
+	unsigned int result;
+	unsigned long flags;
+
+	save_flags(flags); cli();
+	status = serial_in(info, UART_LSR);
+	restore_flags(flags);
+	result = ((status & UART_LSR_TEMT) ? TIOCSER_TEMT : 0);
+
+	/*
+	 * If we're about to load something into the transmit
+	 * register, we'll pretend the transmitter isn't empty to
+	 * avoid a race condition (depending on when the transmit
+	 * interrupt happens).
+	 */
+	if (info->x_char ||
+		((CIRC_CNT(info->xmit.head, info->xmit.tail,
+			   SERIAL_XMIT_SIZE) > 0) &&
+		 !info->tty->stopped && !info->tty->hw_stopped))
+		result &= ~TIOCSER_TEMT;
+
+	if (copy_to_user(value, &result, sizeof(int)))
+		return -EFAULT;
+	return 0;
+}
+
+
+static int get_modem_info(struct async_struct * info, unsigned int *value)
+{
+	unsigned char control, status;
+	unsigned int result;
+	unsigned long flags;
+
+	control = info->MCR;
+	save_flags(flags); cli();
+	status = serial_in(info, UART_MSR);
+	restore_flags(flags);
+	result =  ((control & UART_MCR_RTS) ? TIOCM_RTS : 0)
+		| ((control & UART_MCR_DTR) ? TIOCM_DTR : 0)
+#ifdef TIOCM_OUT1
+		| ((control & UART_MCR_OUT1) ? TIOCM_OUT1 : 0)
+		| ((control & UART_MCR_OUT2) ? TIOCM_OUT2 : 0)
+#endif
+		| ((status  & UART_MSR_DCD) ? TIOCM_CAR : 0)
+		| ((status  & UART_MSR_RI) ? TIOCM_RNG : 0)
+		| ((status  & UART_MSR_DSR) ? TIOCM_DSR : 0)
+		| ((status  & UART_MSR_CTS) ? TIOCM_CTS : 0);
+
+	if (copy_to_user(value, &result, sizeof(int)))
+		return -EFAULT;
+	return 0;
+}
+static int set_modem_info(struct async_struct * info, unsigned int cmd,
+			  unsigned int *value)
+{
+	unsigned int arg;
+	unsigned long flags;
+
+	if (copy_from_user(&arg, value, sizeof(int)))
+		return -EFAULT;
+
+	switch (cmd) {
+	case TIOCMBIS:
+		if (arg & TIOCM_RTS)
+			info->MCR |= UART_MCR_RTS;
+		if (arg & TIOCM_DTR)
+			info->MCR |= UART_MCR_DTR;
+#ifdef TIOCM_OUT1
+		if (arg & TIOCM_OUT1)
+			info->MCR |= UART_MCR_OUT1;
+		if (arg & TIOCM_OUT2)
+			info->MCR |= UART_MCR_OUT2;
+#endif
+		if (arg & TIOCM_LOOP)
+			info->MCR |= UART_MCR_LOOP;
+		break;
+	case TIOCMBIC:
+		if (arg & TIOCM_RTS)
+			info->MCR &= ~UART_MCR_RTS;
+		if (arg & TIOCM_DTR)
+			info->MCR &= ~UART_MCR_DTR;
+#ifdef TIOCM_OUT1
+		if (arg & TIOCM_OUT1)
+			info->MCR &= ~UART_MCR_OUT1;
+		if (arg & TIOCM_OUT2)
+			info->MCR &= ~UART_MCR_OUT2;
+#endif
+		if (arg & TIOCM_LOOP)
+			info->MCR &= ~UART_MCR_LOOP;
+		break;
+	case TIOCMSET:
+		info->MCR = ((info->MCR & ~(UART_MCR_RTS |
+#ifdef TIOCM_OUT1
+				        UART_MCR_OUT1 |
+				        UART_MCR_OUT2 |
+#endif
+				        UART_MCR_LOOP |
+				        UART_MCR_DTR))
+				 | ((arg & TIOCM_RTS) ? UART_MCR_RTS : 0)
+#ifdef TIOCM_OUT1
+				 | ((arg & TIOCM_OUT1) ? UART_MCR_OUT1 : 0)
+				 | ((arg & TIOCM_OUT2) ? UART_MCR_OUT2 : 0)
+#endif
+				 | ((arg & TIOCM_LOOP) ? UART_MCR_LOOP : 0)
+				 | ((arg & TIOCM_DTR) ? UART_MCR_DTR : 0));
+		break;
+	default:
+		return -EINVAL;
+	}
+	save_flags(flags); cli();
+	info->MCR |= ALPHA_KLUDGE_MCR;      /* Don't ask */
+	serial_out(info, UART_MCR, info->MCR);
+	restore_flags(flags);
+	return 0;
+}
+
+static int do_autoconfig(struct async_struct * info)
+{
+	int irq, retval;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	if (info->state->count > 1)
+		return -EBUSY;
+
+	shutdown(info);
+
+	autoconfig(info->state);
+	if ((info->state->flags & ASYNC_AUTO_IRQ) &&
+		(info->state->port != 0  || info->state->iomem_base != 0) &&
+		(info->state->type != PORT_UNKNOWN)) {
+		irq = detect_uart_irq(info->state);
+		if (irq > 0)
+			info->state->irq = irq;
+	}
+
+	retval = startup(info);
+	if (retval)
+		return retval;
+	return 0;
+}
+
+/*
+ * rs_break() --- routine which turns the break handling on or off
+ */
+#if (LINUX_VERSION_CODE < 131394) /* Linux 2.1.66 */
+static void send_break( struct async_struct * info, int duration)
+{
+	if (!CONFIGURED_SERIAL_PORT(info))
+		return;
+	current->state = TASK_INTERRUPTIBLE;
+	current->timeout = jiffies + duration;
+	cli();
+	info->LCR |= UART_LCR_SBC;
+	serial_out(info, UART_LCR, 0x3);
+	schedule();
+	info->LCR &= ~UART_LCR_SBC;
+	serial_out(info, UART_LCR, 0x3);
+	sti();
+}
+#else
+static void psio_break(struct tty_struct *tty, int break_state)
+{
+	struct async_struct * info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+
+	if (serial_paranoia_check(info, tty->device, "rs_break"))
+		return;
+
+	if (!CONFIGURED_SERIAL_PORT(info))
+		return;
+	save_flags(flags); cli();
+	if (break_state == -1)
+		info->LCR |= UART_LCR_SBC;
+	else
+		info->LCR &= ~UART_LCR_SBC;
+	restore_flags(flags);
+}
+#endif
+
+#ifdef CONFIG_SERIAL_MULTIPORT
+static int get_multiport_struct(struct async_struct * info,
+				struct serial_multiport_struct *retinfo)
+{
+	struct serial_multiport_struct ret;
+	struct rs_multiport_struct *multi;
+
+	multi = &rs_multiport[info->state->irq];
+
+	ret.port_monitor = multi->port_monitor;
+
+	ret.port1 = multi->port1;
+	ret.mask1 = multi->mask1;
+	ret.match1 = multi->match1;
+
+	ret.port2 = multi->port2;
+	ret.mask2 = multi->mask2;
+	ret.match2 = multi->match2;
+
+	ret.port3 = multi->port3;
+	ret.mask3 = multi->mask3;
+	ret.match3 = multi->match3;
+
+	ret.port4 = multi->port4;
+	ret.mask4 = multi->mask4;
+	ret.match4 = multi->match4;
+
+	ret.irq = info->state->irq;
+
+	if (copy_to_user(retinfo,&ret,sizeof(*retinfo)))
+		return -EFAULT;
+	return 0;
+}
+
+static int set_multiport_struct(struct async_struct * info,
+				struct serial_multiport_struct *in_multi)
+{
+	struct serial_multiport_struct new_multi;
+	struct rs_multiport_struct *multi;
+	struct serial_state *state;
+	int was_multi, now_multi;
+	int retval;
+	void (*handler)(int, void *, struct pt_regs *);
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	state = info->state;
+
+	if (copy_from_user(&new_multi, in_multi,
+			   sizeof(struct serial_multiport_struct)))
+		return -EFAULT;
+
+	if (new_multi.irq != state->irq || state->irq == 0 ||
+		!IRQ_ports[state->irq])
+		return -EINVAL;
+
+	multi = &rs_multiport[state->irq];
+	was_multi = (multi->port1 != 0);
+
+	multi->port_monitor = new_multi.port_monitor;
+
+	if (multi->port1)
+		release_region(multi->port1,1);
+	multi->port1 = new_multi.port1;
+	multi->mask1 = new_multi.mask1;
+	multi->match1 = new_multi.match1;
+	if (multi->port1)
+		request_region(multi->port1,1,"serial(multiport1)");
+
+	if (multi->port2)
+		release_region(multi->port2,1);
+	multi->port2 = new_multi.port2;
+	multi->mask2 = new_multi.mask2;
+	multi->match2 = new_multi.match2;
+	if (multi->port2)
+		request_region(multi->port2,1,"serial(multiport2)");
+
+	if (multi->port3)
+		release_region(multi->port3,1);
+	multi->port3 = new_multi.port3;
+	multi->mask3 = new_multi.mask3;
+	multi->match3 = new_multi.match3;
+	if (multi->port3)
+		request_region(multi->port3,1,"serial(multiport3)");
+
+	if (multi->port4)
+		release_region(multi->port4,1);
+	multi->port4 = new_multi.port4;
+	multi->mask4 = new_multi.mask4;
+	multi->match4 = new_multi.match4;
+	if (multi->port4)
+		request_region(multi->port4,1,"serial(multiport4)");
+
+	now_multi = (multi->port1 != 0);
+
+	if (IRQ_ports[state->irq]->next_port &&
+		(was_multi != now_multi)) {
+		free_irq(state->irq, &IRQ_ports[state->irq]);
+		if (now_multi)
+			handler = rs_interrupt_multi;
+		else
+			handler = rs_interrupt;
+
+		retval = request_irq(state->irq, handler, SA_SHIRQ,
+				     "serial", &IRQ_ports[state->irq]);
+		if (retval) {
+			printk("Couldn't reallocate serial interrupt "
+				   "driver!!\n");
+		}
+	}
+	return 0;
+}
+#endif
+
+static int psio_ioctl(struct tty_struct *tty, struct file * file,
+		    unsigned int cmd, unsigned long arg)
+{
+	struct async_struct * info = (struct async_struct *)tty->driver_data;
+	struct async_icount cprev, cnow;    /* kernel counter temps */
+	struct serial_icounter_struct icount;
+	unsigned long flags;
+#if (LINUX_VERSION_CODE < 131394) /* Linux 2.1.66 */
+	int retval, tmp;
+#endif
+
+	if (serial_paranoia_check(info, tty->device, "rs_ioctl"))
+		return -ENODEV;
+
+	if ((cmd != TIOCGSERIAL) && (cmd != TIOCSSERIAL) &&
+		(cmd != TIOCSERCONFIG) && (cmd != TIOCSERGSTRUCT) &&
+		(cmd != TIOCMIWAIT) && (cmd != TIOCGICOUNT)) {
+		if (tty->flags & (1 << TTY_IO_ERROR))
+			return -EIO;
+	}
+
+	switch (cmd) {
+#if (LINUX_VERSION_CODE < 131394) /* Linux 2.1.66 */
+		case TCSBRK:    /* SVID version: non-zero arg --> no break */
+			retval = tty_check_change(tty);
+			if (retval)
+				return retval;
+			tty_wait_until_sent(tty, 0);
+			if (signal_pending(current))
+				return -EINTR;
+			if (!arg) {
+				send_break(info, HZ/4); /* 1/4 second */
+				if (signal_pending(current))
+				    return -EINTR;
+			}
+			return 0;
+		case TCSBRKP:   /* support for POSIX tcsendbreak() */
+			retval = tty_check_change(tty);
+			if (retval)
+				return retval;
+			tty_wait_until_sent(tty, 0);
+			if (signal_pending(current))
+				return -EINTR;
+			send_break(info, arg ? arg*(HZ/10) : HZ/4);
+			if (signal_pending(current))
+				return -EINTR;
+			return 0;
+		case TIOCGSOFTCAR:
+			tmp = C_CLOCAL(tty) ? 1 : 0;
+			if (copy_to_user((void *)arg, &tmp, sizeof(int)))
+				return -EFAULT;
+			return 0;
+		case TIOCSSOFTCAR:
+			if (copy_from_user(&tmp, (void *)arg, sizeof(int)))
+				return -EFAULT;
+
+			tty->termios->c_cflag =
+				((tty->termios->c_cflag & ~CLOCAL) |
+				 (tmp ? CLOCAL : 0));
+			return 0;
+#endif
+		case TIOCMGET:
+			return get_modem_info(info, (unsigned int *) arg);
+		case TIOCMBIS:
+		case TIOCMBIC:
+		case TIOCMSET:
+			return set_modem_info(info, cmd, (unsigned int *) arg);
+		case TIOCGSERIAL:
+			return get_serial_info(info,
+					       (struct serial_struct *) arg);
+		case TIOCSSERIAL:
+			return set_serial_info(info,
+				               (struct serial_struct *) arg);
+		case TIOCSERCONFIG:
+			return do_autoconfig(info);
+
+		case TIOCSERGETLSR: /* Get line status register */
+			return get_lsr_info(info, (unsigned int *) arg);
+
+		case TIOCSERGSTRUCT:
+			if (copy_to_user((struct async_struct *) arg,
+			    info, sizeof(struct async_struct)))
+				return -EFAULT;
+			return 0;
+
+#ifdef CONFIG_SERIAL_MULTIPORT
+		case TIOCSERGETMULTI:
+			return get_multiport_struct(info,
+				       (struct serial_multiport_struct *) arg);
+		case TIOCSERSETMULTI:
+			return set_multiport_struct(info,
+				       (struct serial_multiport_struct *) arg);
+#endif
+
+		/*
+		 * Wait for any of the 4 modem inputs (DCD,RI,DSR,CTS) to change
+		 * - mask passed in arg for lines of interest
+		 *   (use |'ed TIOCM_RNG/DSR/CD/CTS for masking)
+		 * Caller should use TIOCGICOUNT to see which one it was
+		 */
+		case TIOCMIWAIT:
+			save_flags(flags); cli();
+			/* note the counters on entry */
+			cprev = info->state->icount;
+			restore_flags(flags);
+			/* Force modem status interrupts on */
+			info->IER |= UART_IER_MSI;
+			serial_out(info, UART_IER, info->IER);
+			while (1) {
+				interruptible_sleep_on(&info->delta_msr_wait);
+				/* see if a signal did it */
+				if (signal_pending(current))
+				    return -ERESTARTSYS;
+				save_flags(flags); cli();
+				cnow = info->state->icount; /* atomic copy */
+				restore_flags(flags);
+				if (cnow.rng == cprev.rng && cnow.dsr == cprev.dsr &&
+				    cnow.dcd == cprev.dcd && cnow.cts == cprev.cts)
+				    return -EIO; /* no change => error */
+				if ( ((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) ||
+				     ((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) ||
+				     ((arg & TIOCM_CD)  && (cnow.dcd != cprev.dcd)) ||
+				     ((arg & TIOCM_CTS) && (cnow.cts != cprev.cts)) ) {
+				    return 0;
+				}
+				cprev = cnow;
+			}
+			/* NOTREACHED */
+
+		/*
+		 * Get counter of input serial line interrupts (DCD,RI,DSR,CTS)
+		 * Return: write counters to the user passed counter struct
+		 * NB: both 1->0 and 0->1 transitions are counted except for
+		 *     RI where only 0->1 is counted.
+		 */
+		case TIOCGICOUNT:
+			save_flags(flags); cli();
+			cnow = info->state->icount;
+			restore_flags(flags);
+			icount.cts = cnow.cts;
+			icount.dsr = cnow.dsr;
+			icount.rng = cnow.rng;
+			icount.dcd = cnow.dcd;
+			icount.rx = cnow.rx;
+			icount.tx = cnow.tx;
+			icount.frame = cnow.frame;
+			icount.overrun = cnow.overrun;
+			icount.parity = cnow.parity;
+			icount.brk = cnow.brk;
+			icount.buf_overrun = cnow.buf_overrun;
+
+			if (copy_to_user((void *)arg, &icount, sizeof(icount)))
+				return -EFAULT;
+			return 0;
+		case TIOCSERGWILD:
+		case TIOCSERSWILD:
+			/* "setserial -W" is called in Debian boot */
+			printk ("TIOCSER?WILD ioctl obsolete, ignored.\n");
+			return 0;
+
+		default:
+			return -ENOIOCTLCMD;
+		}
+	return 0;
+}
+
+static void psio_set_termios(struct tty_struct *tty, struct termios *old_termios)
+{
+	struct async_struct *info = (struct async_struct *)tty->driver_data;
+	unsigned long flags;
+	unsigned int cflag = tty->termios->c_cflag;
+
+	if (   (cflag == old_termios->c_cflag)
+		&& (   RELEVANT_IFLAG(tty->termios->c_iflag)
+		== RELEVANT_IFLAG(old_termios->c_iflag)))
+	  return;
+
+	change_speed(info, old_termios);
+
+	/* Handle transition to B0 status */
+	if ((old_termios->c_cflag & CBAUD) &&
+		!(cflag & CBAUD)) {
+		info->MCR &= ~(UART_MCR_DTR|UART_MCR_RTS);
+		save_flags(flags); cli();
+		serial_out(info, UART_MCR, info->MCR);
+		restore_flags(flags);
+	}
+
+	/* Handle transition away from B0 status */
+	if (!(old_termios->c_cflag & CBAUD) &&
+		(cflag & CBAUD)) {
+		info->MCR |= UART_MCR_DTR;
+		if (!(tty->termios->c_cflag & CRTSCTS) ||
+			!test_bit(TTY_THROTTLED, &tty->flags)) {
+			info->MCR |= UART_MCR_RTS;
+		}
+		save_flags(flags); cli();
+		serial_out(info, UART_MCR, info->MCR);
+		restore_flags(flags);
+	}
+
+	/* Handle turning off CRTSCTS */
+	if ((old_termios->c_cflag & CRTSCTS) &&
+		!(tty->termios->c_cflag & CRTSCTS)) {
+		tty->hw_stopped = 0;
+		psio_start(tty);
+	}
+}
+
+/*
+ * -----------------------------------------------------------
+ * psio_close()
+ *
+ * This routine is called when the debug console port gets closed.  
+ * First, we wait for the last remaining data to be sent.  Then, we unlink 
+ * its async structure from the interrupt chain if necessary, and we free
+ * that IRQ if nothing is left in the chain.
+ * -----------------------------------------------------------
+ */
+static void psio_close(struct tty_struct *tty, struct file *filp)
+{
+	struct async_struct * info = (struct async_struct *)tty->driver_data;
+	struct serial_state *state;
+	unsigned long flags;
+
+	if (!info || serial_paranoia_check(info, tty->device, "rs_close"))
+		return;
+
+	state = info->state;
+
+	save_flags(flags); cli();
+
+	if (tty_hung_up_p(filp)) {
+		DBG_CNT("before DEC-hung");
+		MOD_DEC_USE_COUNT;
+		restore_flags(flags);
+		return;
+	}
+
+#ifdef SERIAL_DEBUG_OPEN
+	printk("psio_close ttyD%d, count = %d\n", info->line, state->count);
+#endif
+	if ((tty->count == 1) && (state->count != 1)) {
+		/*
+		 * Uh, oh.  tty->count is 1, which means that the tty
+		 * structure will be freed.  state->count should always
+		 * be one in these conditions.  If it's greater than
+		 * one, we've got real problems, since it means the
+		 * serial port won't be shutdown.
+		 */
+		printk("rs_close: bad serial port count; tty->count is 1, "
+			   "state->count is %d\n", state->count);
+		state->count = 1;
+	}
+	if (--state->count < 0) {
+		printk("psio_close: bad serial port count for ttyD%d: %d\n",
+			   info->line, state->count);
+		state->count = 0;
+	}
+	if (state->count) {
+		DBG_CNT("before DEC-2");
+		MOD_DEC_USE_COUNT;
+		restore_flags(flags);
+		return;
+	}
+	info->flags |= ASYNC_CLOSING;
+	restore_flags(flags);
+	/*
+	 * Save the termios structure, since this port may have
+	 * separate termios for callout and dialin.
+	 */
+	if (info->flags & ASYNC_NORMAL_ACTIVE)
+		info->state->normal_termios = *tty->termios;
+	if (info->flags & ASYNC_CALLOUT_ACTIVE)
+		info->state->callout_termios = *tty->termios;
+	/*
+	 * Now we wait for the transmit buffer to clear; and we notify
+	 * the line discipline to only process XON/XOFF characters.
+	 */
+	tty->closing = 1;
+	if (info->closing_wait != ASYNC_CLOSING_WAIT_NONE)
+		tty_wait_until_sent(tty, info->closing_wait);
+	/*
+	 * At this point we stop accepting input.  To do this, we
+	 * disable the receive line status interrupts, and tell the
+	 * interrupt driver to stop checking the data ready bit in the
+	 * line status register.
+	 */
+	info->IER &= ~UART_IER_RLSI;
+	info->read_status_mask &= ~UART_LSR_DR;
+	if (info->flags & ASYNC_INITIALIZED) {
+		serial_out(info, UART_IER, info->IER);
+		/*
+		 * Before we drop DTR, make sure the UART transmitter
+		 * has completely drained; this is especially
+		 * important if there is a transmit FIFO!
+		 */
+		psio_wait_until_sent(tty, info->timeout);
+	}
+	shutdown(info);
+	if (tty->driver.flush_buffer)
+		tty->driver.flush_buffer(tty);
+	if (tty->ldisc.flush_buffer)
+		tty->ldisc.flush_buffer(tty);
+	tty->closing = 0;
+	info->event = 0;
+	info->tty = 0;
+	if (info->blocked_open) {
+		if (info->close_delay) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			schedule_timeout(info->close_delay);
+		}
+		wake_up_interruptible(&info->open_wait);
+	}
+	info->flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CALLOUT_ACTIVE|
+			 ASYNC_CLOSING);
+	wake_up_interruptible(&info->close_wait);
+	MOD_DEC_USE_COUNT;
+}
+
+/*
+ * rs_wait_until_sent() --- wait until the transmitter is empty
+ */
+static void psio_wait_until_sent(struct tty_struct *tty, int timeout)
+{
+	struct async_struct * info = (struct async_struct *)tty->driver_data;
+	unsigned long orig_jiffies, char_time;
+	int lsr;
+
+	if (serial_paranoia_check(info, tty->device, "psio_wait_until_sent"))
+		return;
+
+	if (info->state->type == PORT_UNKNOWN)
+		return;
+
+	if (info->xmit_fifo_size == 0)
+		return; /* Just in case.... */
+
+	orig_jiffies = jiffies;
+	/*
+	 * Set the check interval to be 1/5 of the estimated time to
+	 * send a single character, and make it at least 1.  The check
+	 * interval should also be less than the timeout.
+	 *
+	 * Note: we have to use pretty tight timings here to satisfy
+	 * the NIST-PCTS.
+	 */
+	char_time = (info->timeout - HZ/50) / info->xmit_fifo_size;
+	char_time = char_time / 5;
+	if (char_time == 0)
+		char_time = 1;
+	if (timeout && timeout < char_time)
+		char_time = timeout;
+	/*
+	 * If the transmitter hasn't cleared in twice the approximate
+	 * amount of time to send the entire FIFO, it probably won't
+	 * ever clear.  This assumes the UART isn't doing flow
+	 * control, which is currently the case.  Hence, if it ever
+	 * takes longer than info->timeout, this is probably due to a
+	 * UART bug of some kind.  So, we clamp the timeout parameter at
+	 * 2*info->timeout.
+	 */
+	if (!timeout || timeout > 2*info->timeout)
+		timeout = 2*info->timeout;
+#ifdef SERIAL_DEBUG_RS_WAIT_UNTIL_SENT
+	printk("In rs_wait_until_sent(%d) check=%lu...", timeout, char_time);
+	printk("jiff=%lu...", jiffies);
+#endif
+	while (!((lsr = serial_inp(info, UART_LSR)) & UART_LSR_TEMT)) {
+#ifdef SERIAL_DEBUG_RS_WAIT_UNTIL_SENT
+		printk("lsr = %d (jiff=%lu)...", lsr, jiffies);
+#endif
+		set_current_state(TASK_INTERRUPTIBLE);
+		schedule_timeout(char_time);
+		if (signal_pending(current))
+			break;
+		if (timeout && time_after(jiffies, orig_jiffies + timeout))
+			break;
+	}
+#ifdef SERIAL_DEBUG_RS_WAIT_UNTIL_SENT
+	printk("lsr = %d (jiff=%lu)...done\n", lsr, jiffies);
+#endif
+}
+
+/*
+ * psio_hangup() --- called by tty_hangup() when a hangup is signaled.
+ */
+static void psio_hangup(struct tty_struct *tty)
+{
+	struct async_struct * info = (struct async_struct *)tty->driver_data;
+	struct serial_state *state = info->state;
+
+	if (serial_paranoia_check(info, tty->device, "psio_hangup"))
+		return;
+
+	state = info->state;
+
+	psio_flush_buffer(tty);
+	if (info->flags & ASYNC_CLOSING)
+		return;
+	shutdown(info);
+	info->event = 0;
+	state->count = 0;
+	info->flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CALLOUT_ACTIVE);
+	info->tty = 0;
+	wake_up_interruptible(&info->open_wait);
+}
+
+
+
+/*
+static void rs_wait_until_sent(struct tty_struct *tty, int timeout)
+static void rs_hangup(struct tty_struct *tty)
+*/
+
+/*
+ * ------------------------------------------------------------
+ * psio_open() and friends
+ * ------------------------------------------------------------
+ */
+#define SERIAL_DEBUG_OPEN
+static int block_til_ready(struct tty_struct *tty, struct file * filp,
+			   struct async_struct *info)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	struct serial_state *state = info->state;
+	int     retval;
+	int     do_clocal = 0, extra_count = 0;
+	unsigned long   flags;
+
+	/*
+	 * If the device is in the middle of being closed, then block
+	 * until it's done, and then try again.
+	 */
+	if (tty_hung_up_p(filp) ||
+		(info->flags & ASYNC_CLOSING)) {
+		if (info->flags & ASYNC_CLOSING)
+			interruptible_sleep_on(&info->close_wait);
+#ifdef SERIAL_DO_RESTART
+		return ((info->flags & ASYNC_HUP_NOTIFY) ?
+			-EAGAIN : -ERESTARTSYS);
+#else
+		return -EAGAIN;
+#endif
+	}
+
+	/*
+	 * If this is a callout device, then just make sure the normal
+	 * device isn't being used.
+	 */
+	if (tty->driver.subtype == SERIAL_TYPE_CALLOUT) {
+		if (info->flags & ASYNC_NORMAL_ACTIVE)
+			return -EBUSY;
+		if ((info->flags & ASYNC_CALLOUT_ACTIVE) &&
+			(info->flags & ASYNC_SESSION_LOCKOUT) &&
+			(info->session != current->session))
+			return -EBUSY;
+		if ((info->flags & ASYNC_CALLOUT_ACTIVE) &&
+			(info->flags & ASYNC_PGRP_LOCKOUT) &&
+			(info->pgrp != current->pgrp))
+			return -EBUSY;
+		info->flags |= ASYNC_CALLOUT_ACTIVE;
+		return 0;
+	}
+
+#if 1 /* ? 020906 */
+filp->f_flags |= O_NONBLOCK;
+#endif /* ? 020906 */
+	/*
+	 * If non-blocking mode is set, or the port is not enabled,
+	 * then make the check up front and then exit.
+	 */
+	if ((filp->f_flags & O_NONBLOCK) ||
+		(tty->flags & (1 << TTY_IO_ERROR))) {
+		if (info->flags & ASYNC_CALLOUT_ACTIVE)
+			return -EBUSY;
+		info->flags |= ASYNC_NORMAL_ACTIVE;
+		return 0;
+	}
+
+	if (info->flags & ASYNC_CALLOUT_ACTIVE) {
+		if (state->normal_termios.c_cflag & CLOCAL)
+			do_clocal = 1;
+	} else {
+		if (tty->termios->c_cflag & CLOCAL)
+			do_clocal = 1;
+	}
+
+	/*
+	 * Block waiting for the carrier detect and the line to become
+	 * free (i.e., not in use by the callout).  While we are in
+	 * this loop, state->count is dropped by one, so that
+	 * rs_close() knows when to free things.  We restore it upon
+	 * exit, either normal or abnormal.
+	 */
+	retval = 0;
+	add_wait_queue(&info->open_wait, &wait);
+#ifdef SERIAL_DEBUG_OPEN
+	printk("block_til_ready before block: ttyD%d, count = %d\n",
+		   state->line, state->count);
+#endif
+	save_flags(flags); cli();
+	if (!tty_hung_up_p(filp)) {
+		extra_count = 1;
+		state->count--;
+	}
+	restore_flags(flags);
+	info->blocked_open++;
+	while (1) {
+		save_flags(flags); cli();
+		if (!(info->flags & ASYNC_CALLOUT_ACTIVE) &&
+			(tty->termios->c_cflag & CBAUD))
+			serial_out(info, UART_MCR,
+				   serial_inp(info, UART_MCR) |
+				   (UART_MCR_DTR | UART_MCR_RTS));
+		restore_flags(flags);
+		set_current_state(TASK_INTERRUPTIBLE);
+		if (tty_hung_up_p(filp) ||
+			!(info->flags & ASYNC_INITIALIZED)) {
+#ifdef SERIAL_DO_RESTART
+			if (info->flags & ASYNC_HUP_NOTIFY)
+				retval = -EAGAIN;
+			else
+				retval = -ERESTARTSYS;
+#else
+			retval = -EAGAIN;
+#endif
+			break;
+		}
+		if (!(info->flags & ASYNC_CALLOUT_ACTIVE) &&
+			!(info->flags & ASYNC_CLOSING) &&
+			(do_clocal || (serial_in(info, UART_MSR) &
+				   UART_MSR_DCD)))
+			break;
+		if (signal_pending(current)) {
+			retval = -ERESTARTSYS;
+			break;
+		}
+#ifdef SERIAL_DEBUG_OPEN
+		printk("block_til_ready blocking: ttyD%d, count = %d\n",
+			   info->line, state->count);
+#endif
+		schedule();
+	}
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&info->open_wait, &wait);
+	if (extra_count)
+		state->count++;
+	info->blocked_open--;
+#ifdef SERIAL_DEBUG_OPEN
+	printk("block_til_ready after blocking: ttyD%d, count = %d\n",
+		   info->line, state->count);
+#endif
+	if (retval)
+		return retval;
+	info->flags |= ASYNC_NORMAL_ACTIVE;
+	return 0;
+}
+#undef SERIAL_DEBUG_OPEN
+
+
+static int get_async_struct(int line, struct async_struct **ret_info)
+{
+	struct async_struct *info;
+	struct serial_state *sstate;
+
+	sstate = rs_table + line;
+	sstate->count++;
+	if (sstate->info) {
+		*ret_info = sstate->info;
+		return 0;
+	}
+	info = kmalloc(sizeof(struct async_struct), GFP_KERNEL);
+	if (!info) {
+		sstate->count--;
+		return -ENOMEM;
+	}
+	memset(info, 0, sizeof(struct async_struct));
+	init_waitqueue_head(&info->open_wait);
+	init_waitqueue_head(&info->close_wait);
+	init_waitqueue_head(&info->delta_msr_wait);
+	info->magic = SERIAL_MAGIC;
+	info->port = sstate->port;
+	info->flags = sstate->flags;
+	info->io_type = sstate->io_type;
+	info->iomem_base = sstate->iomem_base;
+	info->iomem_reg_shift = sstate->iomem_reg_shift;
+	info->xmit_fifo_size = sstate->xmit_fifo_size=0;
+	info->line = line;
+	info->tqueue.routine = do_softint;
+	info->tqueue.data = info;
+	info->state = sstate;
+
+	if (sstate->info) {
+		kfree(info);
+
+		*ret_info = sstate->info;
+		return 0;
+	}
+	*ret_info = sstate->info = info;
+	return 0;
+}
+
+/*
+ * -----------------------------------------------------------
+ * psio_open()
+ *
+ * This routine is called whenever a debug console port is opened.  It
+ * enables interrupts for a serial port, linking in its async structure into
+ * the IRQ chain.  It also performs the serial-specific
+ * initialization for the tty structure.
+ * -----------------------------------------------------------
+ */
+static int psio_open(struct tty_struct *tty, struct file *filp)
+{
+	struct async_struct *info;
+	int retval,line=0;
+	unsigned long   page;
+
+	MOD_INC_USE_COUNT;
+	line = MINOR(tty->device) - tty->driver.minor_start;
+	if ((line < 0) || (line >= NR_PORTS)) {
+		MOD_DEC_USE_COUNT;
+		return -ENODEV;
+	}
+
+	retval = get_async_struct(line, &info);
+	if (retval) {
+		printk("psio_open ttyD%d fail...",line);
+		MOD_DEC_USE_COUNT;
+		return retval;
+	}
+	tty->driver_data = info;
+	info->tty = tty;
+	if (serial_paranoia_check(info, tty->device, "psio_open"))
+		return -ENODEV;
+
+#ifdef SERIAL_DEBUG_OPEN
+	printk("psio_open %s%d, count = %d\n", tty->driver.name, info->line,
+		   info->state->count);
+#endif
+	info->tty->low_latency = (info->flags & ASYNC_LOW_LATENCY) ? 1 : 0;
+
+	/*
+	 *  This relies on lock_kernel() stuff so wants tidying for 2.5
+	 */
+	if (!tmp_buf) {
+		page = get_zeroed_page(GFP_KERNEL);
+		if (!page)
+			return -ENOMEM;
+		if (tmp_buf)
+			free_page(page);
+		else
+			tmp_buf = (unsigned char *) page;
+	}
+	/*
+	 * If the port is the middle of closing, bail out now
+	 */
+	if (tty_hung_up_p(filp) ||
+	  (info->flags & ASYNC_CLOSING)) {
+	if (info->flags & ASYNC_CLOSING)
+	  interruptible_sleep_on(&info->close_wait);
+#ifdef SERIAL_DO_RESTART
+	return ((info->flags & ASYNC_HUP_NOTIFY) ?
+	  -EAGAIN : -ERESTARTSYS);
+#else
+	return -EAGAIN;
+#endif
+	}
+
+	/*
+	 * Start up serial port
+	 */
+	retval=startup(info);
+	if (retval)
+		return retval;
+
+	retval = block_til_ready(tty, filp, info);
+	if (retval) {
+#ifdef SERIAL_DEBUG_OPEN
+		printk("psio_open returning after block_til_ready with %d\n",
+			   retval);
+#endif
+		return retval;
+	}
+
+	if ((info->state->count == 1) &&
+		(info->flags & ASYNC_SPLIT_TERMIOS)) {
+		if (tty->driver.subtype == SERIAL_TYPE_NORMAL)
+			*tty->termios = info->state->normal_termios;
+		else
+			*tty->termios = info->state->callout_termios;
+		change_speed(info, 0);
+	}
+#ifdef CONFIG_SERIAL_CONSOLE
+	if (cons.cflag && cons.index == line) {
+		tty->termios->c_cflag = cons.cflag;
+		cons.cflag = 0;
+		change_speed(info, 0);
+	}
+#endif
+	info->session = current->session;
+	info->pgrp = current->pgrp;
+
+	return 0;
+}
+
+/*
+ * /proc fs routines....
+ */
+static inline int line_info(char *buf, struct serial_state *state)
+{
+	struct async_struct *info = state->info, scr_info;
+	char  stat_buf[30], control, status;
+	int ret;
+	unsigned long flags;
+
+	ret = sprintf(buf, "%d: uart:%s port:%lX irq:%d",
+		  state->line, uart_config[state->type].name, 
+		  state->port, state->irq);
+
+	if (!state->port || (state->type == PORT_UNKNOWN)) {
+		ret += sprintf(buf+ret, "\n");
+		return ret;
+	}
+
+	/*
+	 * Figure out the current RS-232 lines
+	 */
+	if (!info) {
+		info = &scr_info; /* This is just for serial_{in,out} */
+
+		info->magic = SERIAL_MAGIC;
+		info->port = state->port;
+		info->flags = state->flags;
+		info->hub6 = state->hub6;
+		info->io_type = state->io_type;
+		info->iomem_base = state->iomem_base;
+		info->iomem_reg_shift = state->iomem_reg_shift;
+		info->quot = 0;
+		info->tty = 0;
+	}
+	save_flags(flags); cli();
+	status = serial_in(info, UART_MSR);
+	control = info != &scr_info ? info->MCR : serial_in(info, UART_MCR);
+	restore_flags(flags); 
+
+	stat_buf[0] = 0;
+	stat_buf[1] = 0;
+	if (control & UART_MCR_RTS)
+	strcat(stat_buf, "|RTS");
+	if (status & UART_MSR_CTS)
+	strcat(stat_buf, "|CTS");
+	if (control & UART_MCR_DTR)
+	strcat(stat_buf, "|DTR");
+	if (status & UART_MSR_DSR)
+	strcat(stat_buf, "|DSR");
+	if (status & UART_MSR_DCD)
+	strcat(stat_buf, "|CD");
+	if (status & UART_MSR_RI)
+	strcat(stat_buf, "|RI");
+
+	if (info->quot) {
+		ret += sprintf(buf+ret, " baud:%d",
+			 state->baud_base / (16*info->quot));
+	}
+
+	ret += sprintf(buf+ret, " tx:%d rx:%d",
+		  state->icount.tx, state->icount.rx);
+
+	if (state->icount.frame)
+		ret += sprintf(buf+ret, " fe:%d", state->icount.frame);
+	
+	if (state->icount.parity)
+		ret += sprintf(buf+ret, " pe:%d", state->icount.parity);
+	
+	if (state->icount.brk)
+		ret += sprintf(buf+ret, " brk:%d", state->icount.brk);  
+
+	if (state->icount.overrun)
+		ret += sprintf(buf+ret, " oe:%d", state->icount.overrun);
+
+	/*
+	 * Last thing is the RS-232 status lines
+	 */
+	ret += sprintf(buf+ret, " %s\n", stat_buf+1);
+	return ret;
+}
+
+
+
+int psio_read_proc(char *page, char **start, off_t off, int count,
+		 int *eof, void *data)
+{
+	int i, len = 0, l;
+	off_t begin = 0;
+
+	len += sprintf(page, "sioinfo:1.0 driver:%s%s revision:%s\n",
+		   serial_version, LOCAL_VERSTRING, serial_revdate);
+	for (i = 0; i < NR_PORTS && len < 4000; i++) {
+		l = line_info(page + len, &rs_table[i]);
+		len += l;
+		if (len+begin > off+count)
+			goto done;
+		if (len+begin < off) {
+			begin += len;
+			len = 0;
+		}
+	}
+	*eof = 1;
+done:
+	if (off >= len+begin)
+		return 0;
+	*start = page + (off-begin);
+	return ((count < begin+len-off) ? count : begin+len-off);
+}
+
+static char serial_options[] __initdata =
+	   " no serial options enabled\n";
+
+
+static inline void show_serial_version(void)
+{
+	printk(KERN_INFO "%s version %s%s (%s) with%s", serial_name,
+		serial_version, LOCAL_VERSTRING, serial_revdate,
+		serial_options);
+}
+static unsigned detect_uart_irq (struct serial_state * state)
+{
+	if(! state->irq)
+		printk(KERN_INFO "detect_uart_irq: Ohh irq = 0\n");
+		
+	return state->irq;
+}
+
+static void autoconfig(struct serial_state * state)
+{
+	struct async_struct *info, scr_info;
+	//unsigned long flags;
+
+	state->type = PORT_UNKNOWN;
+
+#ifdef SERIAL_DEBUG_AUTOCONF
+	printk("Testing ttyD%d (0x%04lx, 0x%04x)...\n", state->line,
+		   state->port, (unsigned) state->iomem_base);
+#endif
+
+	if (!CONFIGURED_SERIAL_PORT(state))
+		return;
+
+	info = &scr_info;   /* This is just for serial_{in,out} */
+
+	info->magic = SERIAL_MAGIC;
+	info->state = state;
+	info->port = state->port;
+	info->flags = state->flags;
+	sio_reset(info);
+}
+
+/*
+ * The debug console driver boot-time initialization code!
+ */
+/* 20020830 */
+int __init psio_init(void)
+{
+	int i;
+	struct serial_state * state;
+
+	init_bh(SERIAL_BH, do_psio_serial_bh);
+	init_timer(&serial_timer);
+	serial_timer.function = (void *)psio_timer;
+#if 1
+	mod_timer(&serial_timer, jiffies + 10);
+#else /* 1 */
+	mod_timer(&serial_timer, jiffies + RS_STROBE_TIME);
+#endif /* 1 */
+
+	for (i = 0; i < NR_IRQS; i++) {
+		IRQ_ports[i] = 0;
+		IRQ_timeout[i] = 0;
+	}
+
+	/*
+	 * Initialize the tty_driver structure 
+	 */
+	memset(&psio_driver, 0, sizeof(struct tty_driver));
+	psio_driver.magic = TTY_DRIVER_MAGIC;
+#if (LINUX_VERSION_CODE > 0x20100)
+	psio_driver.driver_name = "serial_m32102";
+#endif
+#if 1
+	psio_driver.name = "ttyD";
+#else
+#if (LINUX_VERSION_CODE > 0x2032D && defined(CONFIG_DEVFS_FS))
+	psio_driver.name = "ttyd/%d";
+#else
+	psio_driver.name = "ttyD";
+#endif
+#endif	/* 1 */
+
+	psio_driver.major = TTY_MAJOR;
+	psio_driver.minor_start = 80;
+	psio_driver.name_base = 0;
+	psio_driver.num = NR_PORTS;
+	psio_driver.type = TTY_DRIVER_TYPE_SERIAL;
+ 
+	psio_driver.subtype = SERIAL_TYPE_NORMAL;
+	psio_driver.init_termios = tty_std_termios;
+	psio_driver.init_termios.c_cflag =
+		B9600 | CS8 | CREAD | HUPCL | CLOCAL;
+	psio_driver.flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_NO_DEVFS;
+	psio_driver.refcount = &psio_refcount;
+	psio_driver.table = psio_table;
+	psio_driver.termios = psio_termios;
+	psio_driver.termios_locked = psio_termios_locked;
+
+	psio_driver.open = psio_open;
+	psio_driver.close = psio_close;
+	psio_driver.write = psio_write;
+	psio_driver.put_char = psio_put_char;
+	psio_driver.flush_chars = psio_flush_chars;
+	psio_driver.write_room = psio_write_room;
+	psio_driver.chars_in_buffer = psio_chars_in_buffer;
+	psio_driver.flush_buffer = psio_flush_buffer;
+	psio_driver.ioctl = psio_ioctl;
+	psio_driver.throttle = psio_throttle;
+	psio_driver.unthrottle = psio_unthrottle;
+	psio_driver.set_termios = psio_set_termios;
+	psio_driver.stop = psio_stop;
+	psio_driver.start = psio_start;
+	psio_driver.hangup = psio_hangup;
+
+#if (LINUX_VERSION_CODE >= 131394) /* Linux 2.1.66 */
+	psio_driver.break_ctl = psio_break;
+#endif
+#if (LINUX_VERSION_CODE >= 131343)
+	psio_driver.send_xchar = psio_send_xchar;
+	psio_driver.wait_until_sent = psio_wait_until_sent;
+	psio_driver.read_proc = psio_read_proc;
+#endif
+
+	if (tty_register_driver(&psio_driver))
+		panic("Couldn't register debug console driver\n");
+
+	for (i = 0, state = rs_table; i < NR_PORTS; i++,state++) {
+		state->magic = SSTATE_MAGIC;
+		state->line = i;
+		state->type = 14;
+		state->custom_divisor = 0;
+		state->close_delay = 5*HZ/10;
+		state->closing_wait = 30*HZ;
+		state->callout_termios = psio_driver.init_termios;
+		state->normal_termios = psio_driver.init_termios;
+		state->icount.cts = state->icount.dsr =
+			state->icount.rng = state->icount.dcd = 0;
+		state->icount.rx = state->icount.tx = 0;
+		state->icount.frame = state->icount.parity = 0;
+		state->icount.overrun = state->icount.brk = 0;
+		state->irq = irq_cannonicalize(state->irq);
+
+#if 0
+		if (check_region(state->port,8))
+			continue;
+		if (state->flags & ASYNC_BOOT_AUTOCONF)
+			autoconfig(psio_table);
+#endif
+		state->baud_base = boot_cpu_data.bus_clock;
+		printk(KERN_INFO "ttyD%d initialized.\n",i);
+	   		tty_register_devfs(&psio_driver, 0,
+						   psio_driver.minor_start + state->line);
+	}
+
+	return 0;
+}
+
+/* 20020830 */
+static void __exit psio_fini(void)
+{
+	unsigned long flags;
+	// int e1, e2;
+	int e1;
+	// int i;
+	// struct async_struct *info;
+
+	/* printk("Unloading %s: version %s\n", serial_name, serial_version); */
+	del_timer_sync(&serial_timer);
+	save_flags(flags); cli();
+		remove_bh(SERIAL_BH);
+	if ((e1 = tty_unregister_driver(&psio_driver)))
+		printk("psio_serial: failed to unregister serial driver (%d)\n",e1);
+	restore_flags(flags);
+
+	if (tmp_buf) {
+		unsigned long pg = (unsigned long) tmp_buf;
+		tmp_buf = NULL;
+		free_page(pg);
+	}
+}
+
+module_init(psio_init);
+module_exit(psio_fini);
+MODULE_DESCRIPTION("M32R/M32102 (dumb) serial driver");
+MODULE_AUTHOR("Hiroyuki Kondo <kondo.hiroyuki@renesas.com>, Takeo Takahashi <takahashi.takeo@renesas.com>");
+MODULE_LICENSE("GPL");
+
+
+/*
+ * -----------------------------------------------------------
+ * Debug console driver
+ * -----------------------------------------------------------
+ */
+
+#define BOTH_EMPTY (UART_LSR_TEMT | UART_LSR_THRE)
+
+static struct async_struct async_dbgcons;
+
+/*
+ *  Wait for transmitter & holding register to empty
+ */
+static inline void wait_for_xmitr(struct async_struct *info)
+{
+	unsigned int status, tmout = 1000000;
+
+	do {
+		status = serial_in(info, UART_LSR);
+
+		if (status & UART_LSR_BI)
+			lsr_break_flag = UART_LSR_BI;
+	
+		if (--tmout == 0)
+			break;
+	} while((status & BOTH_EMPTY) != BOTH_EMPTY);
+
+	/* Wait for flow control if necessary */
+	if (info->flags & ASYNC_CONS_FLOW) {
+		tmout = 1000000;
+		while (--tmout &&
+			((serial_in(info, UART_MSR) & UART_MSR_CTS) == 0));
+	} 
+}
+static void dbg_console_write(struct console *co, const char *s, 
+				unsigned count)
+{
+	static struct async_struct *info = &async_dbgcons;
+	int ier;
+	unsigned i;
+
+	/*
+	 *  First save the IER then disable the interrupts
+	 */
+	ier = serial_in(info, UART_IER);
+	serial_out(info, UART_IER, 0x00);
+
+	/*
+	 *  Now, do each character
+	 */
+	for (i = 0; i < count; i++, s++) {
+		wait_for_xmitr(info);
+
+		/*
+		 *	Send the character out.
+		 *	If a LF, also do CR...
+		 */
+		serial_out(info, UART_TX, *s);
+		if (*s == 10) {
+			wait_for_xmitr(info);
+			serial_out(info, UART_TX, 13);
+		}
+	}
+
+	/*
+	 *	Finally, Wait for transmitter & holding register to empty
+	 *	and restore the IER
+	 */
+	wait_for_xmitr(info);
+	serial_out(info, UART_IER, ier);
+}
+
+#if (LINUX_VERSION_CODE <= 132114) /* Linux 2.4.18 */
+/*
+ *  Receive character from the serial port
+ */
+static int dbg_console_wait_key(struct console *console)
+{
+	static struct async_struct *info;
+	int ier, c;
+
+	info = &async_dbgcons;
+
+	/*
+	 *  First save the IER then disable the interrupts so
+	 *  that the real driver for the port does not get the
+	 *  character.
+	 */
+	ier = serial_in(info, UART_IER);
+	serial_out(info, UART_IER, 0x00);
+ 
+	while ((serial_in(info, UART_LSR) & UART_LSR_DR) == 0);
+	c = serial_in(info, UART_RX);
+
+	/*
+	 *  Restore the interrupts
+	 */
+	serial_out(info, UART_IER, ier);
+
+	return c;
+}
+#endif
+
+static kdev_t dbg_console_device(struct console *c)
+{
+	return MKDEV(TTY_MAJOR, 80 + c->index);
+}
+
+
+static int __init dbg_console_setup(struct console *co, char *options)
+{
+	static struct async_struct *info;
+	struct serial_state *state;
+	int baud = BAUDRATE;
+	int baud_base= boot_cpu_data.bus_clock;
+	int bits = 8;
+	int parity = 'n';
+	int doflow = 0;
+	unsigned int cflag = CREAD | HUPCL | CLOCAL | CRTSCTS;
+	int cval;
+	char *s;
+
+	if (options) {
+		baud = simple_strtoul(options, NULL, 10);
+		s = options;
+		while(*s >= '0' && *s <= '9')
+			s++;
+		if (*s) parity = *s++;
+		if (*s) bits   = *s++ - '0';
+		if (*s) doflow = (*s++ == 'r');
+	}
+
+	co->flags |= CON_ENABLED;
+
+	/*
+	 * 	Now construct a cflag setting.
+	 */
+	switch(baud) {
+		case 1200:
+			cflag |= B1200;
+			break;
+		case 2400:
+			cflag |= B2400;
+			break;
+		case 4800:
+			cflag |= B4800;
+			break;
+		case 19200:
+			cflag |= B19200;
+			break;
+		case 38400:
+			cflag |= B38400;
+			break;
+		case 57600:
+			cflag |= B57600;
+			break;
+		case 115200:
+			cflag |= B115200;
+			break;
+		case 9600:
+		default:
+			cflag |= B9600;
+			baud  = 9600;
+			break;
+	}
+	switch(bits) {
+		case 7:
+			cflag |= CS7;
+			break;
+		default:
+		case 8:
+			cflag |= CS8;
+			break;
+	}
+	switch(parity) {
+		case 'o': case 'O':
+			cflag |= PARODD;
+			break;
+		case 'e': case 'E':
+			cflag |= PARENB;
+			break;
+	}
+	co->cflag = cflag;
+
+	state = rs_table + co->index;
+	if (doflow)
+		state->flags |= ASYNC_CONS_FLOW;
+	info = &async_dbgcons;
+	info->magic = SERIAL_MAGIC;
+	info->state = state;
+	info->port = state->port;
+	info->flags = state->flags;
+	info->io_type = state->io_type;
+	info->iomem_base = state->iomem_base;
+	info->iomem_reg_shift = state->iomem_reg_shift;
+
+	cval = (baud_base / (baud * 4)) - 1;
+
+	serial_outp(info, UART_LCR,  0x0300);  /* init status         */
+	//serial_outp(info, UART_MOD1, 0x0800);  /* 8bit                */
+	serial_outp(info, UART_MOD0, 0x80);    /* cts/rts 1stop nonpari */
+	//serial_outp(info, UART_MOD0, 0x180);    /* rts 1stop nonpari */
+	//serial_outp(info, UART_MOD0, 0xc0);    /* cts/rts 1stop nonpari */
+
+	serial_outp(info, UART_BAUR, cval);    /* set baurate reg     */
+	//serial_outp(info, UART_RBAUR, adj);    /* set adj baurate reg */
+	serial_outp(info, UART_IER, 0x00);     /* intr mask           */
+	serial_outp(info, UART_LCR, 0x03);
+
+	return 0;
+}
+
+static struct console cons = {
+	name:		"ttyD",
+	write:		dbg_console_write,
+	device:		dbg_console_device,
+#if (LINUX_VERSION_CODE <= 132114) /* Linux 2.4.18 */
+	wait_key:	dbg_console_wait_key,
+#endif
+	setup:		dbg_console_setup,
+	flags:		CON_PRINTBUFFER,
+	index:		-1,
+};
+
+
+/* 
+ *	Register console.
+ */
+void __init psio_console_init(void)
+{
+	register_console(&cons);
+}
+
+
diff -ruN linux-2.6.7.org/arch/m32r/drivers/m32r_cfc.c linux-2.6.7/arch/m32r/drivers/m32r_cfc.c
--- linux-2.6.7.org/arch/m32r/drivers/m32r_cfc.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/drivers/m32r_cfc.c	2004-07-27 15:54:20.000000000 +0900
@@ -0,0 +1,910 @@
+/*  
+ *  linux/arch/m32r/drivers/m32r_cfc.c
+ *  
+ *  Device driver for the CFC functionality of M32R.
+ *  
+ *  Copyright (c) 2001, 2002, 2003, 2004
+ *   Hiroyuki Kondo, Sugai Naotom, Hayato Fujiwara
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/timer.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <asm/bitops.h>
+#include <asm/system.h>
+
+#include <pcmcia/version.h>
+#include <pcmcia/cs_types.h>
+#include <pcmcia/ss.h>
+#include <pcmcia/cs.h>
+
+#undef MAX_IO_WIN	/* FIXME */
+#define MAX_IO_WIN 1
+#undef MAX_WIN	/* FIXME */
+#define MAX_WIN 1
+
+#include "m32r_cfc.h"
+
+#if !defined(COFIG_PLAT_USRV)
+#define PCMCIA_DEBUG   3
+#endif	/* COFIG_PLAT_USRV */
+
+#ifdef PCMCIA_DEBUG
+int m32r_cfc_debug = PCMCIA_DEBUG;
+module_param(m32r_cfc_debug, int, 0444);
+#define DEBUG(n, args...) if (m32r_cfc_debug>(n)) printk(args)
+#else
+#define DEBUG(n, args...) do { } while (0)
+#endif
+
+/* Poll status interval -- 0 means default to interrupt */
+static int poll_interval = 0;
+
+typedef enum pcc_space { as_none = 0, as_comm, as_attr, as_io } pcc_as_t;
+
+typedef struct pcc_socket {
+	u_short			type, flags;
+	struct pcmcia_socket	socket;
+	unsigned int		number;
+ 	ioaddr_t		ioaddr;
+	u_long			mapaddr;
+	u_long			base;	/* PCC register base */
+	u_char			cs_irq1, cs_irq2, intr;
+	pccard_io_map	io_map[MAX_IO_WIN];
+	pccard_mem_map	mem_map[MAX_WIN];
+	u_char			io_win;
+	u_char			mem_win;
+	pcc_as_t		current_space;
+	u_char			last_iodbex;
+#ifdef CHAOS_PCC_DEBUG
+	u_char			last_iosize;
+#endif
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry *proc;
+#endif
+} pcc_socket_t;
+
+static int pcc_sockets = 0;
+static pcc_socket_t socket[M32R_MAX_PCC] = {
+	{ 0, }, /* ... */
+};
+
+#define ISA_LOCK(n, f) do { } while (0)
+#define ISA_UNLOCK(n, f) do { } while (0)
+
+/*====================================================================*/
+
+static unsigned int pcc_get(u_short, unsigned int);
+static void pcc_set(u_short, unsigned int , unsigned int );
+
+static spinlock_t pcc_lock = SPIN_LOCK_UNLOCKED;
+
+#if !defined(CONFIG_PLAT_USRV)
+static __inline__ u_long pcc_port2addr(unsigned long port, int size) {
+	u_long addr = 0;
+	u_long odd;
+
+	if (size == 1) {	/* byte access */
+		odd = (port&1) << 11;
+		port -= port & 1;
+		addr = CFC_IO_MAPBASE_BYTE - CFC_IOPORT_BASE + odd + port;
+	} else if (size == 2)
+		addr = CFC_IO_MAPBASE_WORD - CFC_IOPORT_BASE + port;
+
+	return addr;
+}
+#else	/* CONFIG_PLAT_USRV */
+static __inline__ u_long pcc_port2addr(unsigned long port, int size) {
+	u_long odd;
+	u_long addr = ((port - CFC_IOPORT_BASE) & 0xf000) << 8;
+
+	if (size == 1) {	/* byte access */
+		odd = port & 1;
+		port -= odd;
+		odd <<= 11;
+		addr = (addr | CFC_IO_MAPBASE_BYTE) + odd + (port & 0xfff);
+	} else if (size == 2)	/* word access */
+		addr = (addr | CFC_IO_MAPBASE_WORD) + (port & 0xfff);
+
+	return addr;
+}
+#endif	/* CONFIG_PLAT_USRV */
+
+void pcc_ioread_byte(int sock, unsigned long port, void *buf, size_t size, 
+	size_t nmemb, int flag)
+{
+	u_long addr;
+	unsigned char *bp = (unsigned char *)buf;
+	unsigned long flags;
+
+	DEBUG(3, "m32r_cfc: pcc_ioread_byte: sock=%d, port=%#lx, buf=%p, "
+		 "size=%u, nmemb=%d, flag=%d\n",
+		  sock, port, buf, size, nmemb, flag);
+
+	addr = pcc_port2addr(port, 1);
+	if (!addr) {
+		printk("m32r_cfc:ioread_byte null port :%#lx\n",port);
+		return;
+	}
+	DEBUG(3, "m32r_cfc: pcc_ioread_byte: addr=%#lx\n", addr);
+
+	spin_lock_irqsave(&pcc_lock, flags);
+	/* read Byte */
+	while (nmemb--)
+	   	*bp++ = readb(addr);
+	spin_unlock_irqrestore(&pcc_lock, flags);
+}
+
+void pcc_ioread_word(int sock, unsigned long port, void *buf, size_t size, 
+	size_t nmemb, int flag)
+{
+	u_long addr;
+	unsigned short *bp = (unsigned short *)buf;
+	unsigned long flags;
+
+	DEBUG(3, "m32r_cfc: pcc_ioread_word: sock=%d, port=%#lx, "
+		 "buf=%p, size=%u, nmemb=%d, flag=%d\n",
+		 sock, port, buf, size, nmemb, flag);
+
+	if (size != 2)
+		printk("m32r_cfc: ioread_word :illigal size %u : %#lx\n", size,
+			port);
+	if (size == 9)
+		printk("m32r_cfc: ioread_word :insw \n");
+
+	addr = pcc_port2addr(port, 2);
+	if (!addr) {
+		printk("m32r_cfc:ioread_word null port :%#lx\n",port);
+		return;
+	}
+	DEBUG(3, "m32r_cfc: pcc_ioread_word: addr=%#lx\n", addr);
+
+	spin_lock_irqsave(&pcc_lock, flags);
+	/* read Word */
+   	while (nmemb--)
+		*bp++ = readw(addr);
+	spin_unlock_irqrestore(&pcc_lock, flags);
+}
+
+void pcc_iowrite_byte(int sock, unsigned long port, void *buf, size_t size,
+	size_t nmemb, int flag)
+{
+	u_long addr;
+	unsigned char *bp = (unsigned char *)buf;
+	unsigned long flags;
+
+	DEBUG(3, "m32r_cfc: pcc_iowrite_byte: sock=%d, port=%#lx, "
+		 "buf=%p, size=%u, nmemb=%d, flag=%d\n",
+		 sock, port, buf, size, nmemb, flag);
+
+	/* write Byte */
+	addr = pcc_port2addr(port, 1);
+	if (!addr) {
+		printk("m32r_cfc:iowrite_byte null port:%#lx\n",port);
+		return;
+	}
+	DEBUG(3, "m32r_cfc: pcc_iowrite_byte: addr=%#lx\n", addr);
+
+	spin_lock_irqsave(&pcc_lock, flags);
+	while (nmemb--)
+		writeb(*bp++, addr);
+	spin_unlock_irqrestore(&pcc_lock, flags);
+}
+
+void pcc_iowrite_word(int sock, unsigned long port, void *buf, size_t size,
+	size_t nmemb, int flag)
+{
+	u_long addr;
+	unsigned short *bp = (unsigned short *)buf;
+	unsigned long flags;
+
+	DEBUG(3, "m32r_cfc: pcc_iowrite_word: sock=%d, port=%#lx, "
+		 "buf=%p, size=%u, nmemb=%d, flag=%d\n",
+		 sock, port, buf, size, nmemb, flag);
+
+	if(size != 2)
+		printk("m32r_cfc: iowrite_word :illigal size %u : %#lx\n",
+			size, port);
+	if(size == 9)
+		printk("m32r_cfc: iowrite_word :outsw \n");
+
+	addr = pcc_port2addr(port, 2);
+	if (!addr) {
+		printk("m32r_cfc:iowrite_word null addr :%#lx\n",port);
+		return;
+	}
+#if 1
+	if (addr & 1) {
+		printk("m32r_cfc:iowrite_word port addr (%#lx):%#lx\n", port, 
+			addr);
+		return;
+	}
+#endif
+	DEBUG(3, "m32r_cfc: pcc_iowrite_word: addr=%#lx\n", addr);
+
+	spin_lock_irqsave(&pcc_lock, flags);
+	while (nmemb--)
+		writew(*bp++, addr);
+	spin_unlock_irqrestore(&pcc_lock, flags);
+}
+
+/*====================================================================*/
+
+#define IS_ALIVE		0x8000
+
+typedef struct pcc_t {
+	char				*name;
+	u_short				flags;
+} pcc_t;
+
+static pcc_t pcc[] = {
+#if !defined(CONFIG_PLAT_USRV)
+	{ "m32r_cfc", 0 }, { "", 0 },
+#else	/* CONFIG_PLAT_USRV */
+	{ "m32r_cfc", 0 }, { "m32r_cfc", 0 }, { "m32r_cfc", 0 },
+	{ "m32r_cfc", 0 }, { "m32r_cfc", 0 }, { "", 0 },
+#endif	/* CONFIG_PLAT_USRV */
+};
+
+static irqreturn_t pcc_interrupt(int, void *, struct pt_regs *regs);
+
+/*====================================================================*/
+
+static struct timer_list poll_timer;
+
+static unsigned int pcc_get(u_short sock, unsigned int reg)
+{
+	unsigned int val = inw(reg);
+	DEBUG(3, "m32r_cfc: pcc_get: reg(0x%08x)=0x%04x\n", reg, val);
+	return val;
+}
+
+
+static void pcc_set(u_short sock, unsigned int reg, unsigned int data)
+{
+	outw(data, reg);
+	DEBUG(3, "m32r_cfc: pcc_set: reg(0x%08x)=0x%04x\n", reg, data);
+}
+
+/*======================================================================
+
+	See if a card is present, powered up, in IO mode, and already
+	bound to a (non PC Card) Linux driver.  We leave these alone.
+
+	We make an exception for cards that seem to be serial devices.
+	
+======================================================================*/
+
+static int __init is_alive(u_short sock)
+{
+	unsigned int stat;
+	
+	DEBUG(3, "m32r_cfc: is_alive:\n");
+
+	printk("CF: ");
+	stat = pcc_get(sock, (unsigned int)PLD_CFSTS);
+	if (!stat)
+		printk("No ");
+	printk("Card is detected at socket %d : stat = 0x%08x\n", sock, stat);
+	DEBUG(3, "m32r_cfc: is_alive: sock stat is 0x%04x\n", stat);
+
+	return 0;
+}
+
+static void add_pcc_socket(ulong base, int irq, ulong mapaddr, ioaddr_t ioaddr)
+{
+  	pcc_socket_t *t = &socket[pcc_sockets];
+
+	DEBUG(3, "m32r_cfc: add_pcc_socket: base=%#lx, irq=%d, "
+		 "mapaddr=%#lx, ioaddr=%08x\n",
+		 base, irq, mapaddr, ioaddr);
+
+	/* add sockets */
+	t->ioaddr = ioaddr;
+	t->mapaddr = mapaddr;
+#if !defined(CONFIG_PLAT_USRV)
+	t->base = 0;
+	t->flags = 0;
+	t->cs_irq1 = irq;		// insert irq
+	t->cs_irq2 = irq + 1;		// eject irq
+#else	/* CONFIG_PLAT_USRV */
+	t->base = base;
+	t->flags = 0;
+	t->cs_irq1 = 0;			// insert irq
+	t->cs_irq2 = 0;			// eject irq
+#endif	/* CONFIG_PLAT_USRV */
+
+	if (is_alive(pcc_sockets))
+		t->flags |= IS_ALIVE;
+
+	/* add pcc */
+#if !defined(CONFIG_PLAT_USRV)
+	request_region((unsigned int)PLD_CFRSTCR, 0x20, "m32r_cfc");
+#else	/* CONFIG_PLAT_USRV */
+	{
+		unsigned int reg_base;
+
+		reg_base = (unsigned int)PLD_CFRSTCR;
+		reg_base |= pcc_sockets << 8;
+		request_region(reg_base, 0x20, "m32r_cfc");
+	}
+#endif	/* CONFIG_PLAT_USRV */
+	printk(KERN_INFO "  %s ", pcc[pcc_sockets].name);
+	printk("pcc at 0x%08lx\n", t->base);
+
+	/* Update socket interrupt information, capabilities */
+	t->socket.features |= (SS_CAP_PCCARD | SS_CAP_STATIC_MAP);
+	t->socket.map_size = M32R_PCC_MAPSIZE;
+	t->socket.io_offset = ioaddr;	/* use for io access offset */
+	t->socket.irq_mask = 0;
+#if !defined(CONFIG_PLAT_USRV)
+	t->socket.pci_irq = PLD_IRQ_CFIREQ ;	/* card interrupt */
+#else	/* CONFIG_PLAT_USRV */
+	t->socket.pci_irq = PLD_IRQ_CF0 + pcc_sockets;
+#endif	/* CONFIG_PLAT_USRV */
+
+#ifndef CONFIG_PLAT_USRV
+	/* insert interrupt */
+	request_irq(irq, pcc_interrupt, 0, "m32r_cfc", pcc_interrupt);
+	/* eject interrupt */
+	request_irq(irq+1, pcc_interrupt, 0, "m32r_cfc", pcc_interrupt);
+
+	DEBUG(3, "m32r_cfc: enable CFMSK, RDYSEL\n");
+	pcc_set(pcc_sockets, (unsigned int)PLD_CFIMASK, 0x01);
+#endif	/* CONFIG_PLAT_USRV */
+#if defined(CONFIG_PLAT_M32700UT) || defined(CONFIG_PLAT_USRV) || defined(CONFIG_PLAT_OPSPUT)
+	pcc_set(pcc_sockets, (unsigned int)PLD_CFCR1, 0x0200); 
+#endif
+	pcc_sockets++;
+
+	return;
+}
+
+
+/*====================================================================*/
+
+static irqreturn_t pcc_interrupt(int irq, void *dev, struct pt_regs *regs)
+{
+	int i;
+	u_int events = 0;
+	int handled = 0;
+	
+	DEBUG(3, "m32r_cfc: pcc_interrupt: irq=%d, dev=%p, regs=%p\n",
+		irq, dev, regs);
+	for (i = 0; i < pcc_sockets; i++) {
+		if (socket[i].cs_irq1 != irq && socket[i].cs_irq2 != irq)
+			continue;
+
+		handled = 1;
+		DEBUG(3, "m32r_cfc: pcc_interrupt: socket %d irq 0x%02x ",
+			i, irq);
+		events |= SS_DETECT;	/* insert or eject */
+		if (events)
+			pcmcia_parse_events(&socket[i].socket, events);
+	}
+	DEBUG(3, "m32r_cfc: pcc_interrupt: done\n");
+
+	return IRQ_RETVAL(handled);
+} /* pcc_interrupt */
+
+static void pcc_interrupt_wrapper(u_long data)
+{
+	DEBUG(3, "m32r_cfc: pcc_interrupt_wrapper:\n");
+	pcc_interrupt(0, NULL, NULL);
+	init_timer(&poll_timer);
+	poll_timer.expires = jiffies + poll_interval;
+	add_timer(&poll_timer);
+}
+
+/*====================================================================*/
+
+static int _pcc_get_status(u_short sock, u_int *value)
+{
+	u_int status;
+	
+	DEBUG(3, "m32r_cfc: _pcc_get_status:\n");
+	status = pcc_get(sock, (unsigned int)PLD_CFSTS);
+	*value = (status) ? SS_DETECT : 0;
+ 	DEBUG(3, "m32r_cfc: _pcc_get_status: status=0x%08x\n", status);
+
+#if defined(CONFIG_PLAT_M32700UT) || defined(CONFIG_PLAT_USRV) || defined(CONFIG_PLAT_OPSPUT)
+	if ( status ) {
+		/* enable CF power */
+		status = inw((unsigned int)PLD_CPCR);
+		if (!(status & PLD_CPCR_CF)) {
+			DEBUG(3, "m32r_cfc: _pcc_get_status: "
+				 "power on (CPCR=0x%08x)\n", status);
+			status |= PLD_CPCR_CF;
+			outw(status, (unsigned int)PLD_CPCR);
+			udelay(100);
+		}
+		*value |= SS_POWERON;
+
+		pcc_set(sock, (unsigned int)PLD_CFBUFCR,0);/* enable buffer */
+		udelay(100);
+
+		*value |= SS_READY; 		/* always ready */
+		*value |= SS_3VCARD; 
+	} else {
+		/* disable CF power */
+		status = inw((unsigned int)PLD_CPCR);
+		status &= ~PLD_CPCR_CF;
+		outw(status, (unsigned int)PLD_CPCR);
+		udelay(100);
+		DEBUG(3, "m32r_cfc: _pcc_get_status: "
+			 "power off (CPCR=0x%08x)\n", status);
+	}
+#elif defined(CONFIG_PLAT_MAPPI2)
+	if ( status ) {
+                status = pcc_get(sock, (unsigned int)PLD_CPCR);
+                if (status == 0) { /* power off */
+                        pcc_set(sock, (unsigned int)PLD_CPCR, 1);
+                        pcc_set(sock, (unsigned int)PLD_CFBUFCR,0); /* force buffer off for ZA-36 */
+                        udelay(50);
+                }
+                status = pcc_get(sock, (unsigned int)PLD_CFBUFCR);
+                if (status != 0) { /* buffer off */
+                                pcc_set(sock, (unsigned int)PLD_CFBUFCR,0);
+                                udelay(50);
+                                pcc_set(sock, (unsigned int)PLD_CFRSTCR, 0x0101);
+                                udelay(25); /* for IDE reset */
+                                pcc_set(sock, (unsigned int)PLD_CFRSTCR, 0x0100);
+                                mdelay(2);  /* for IDE reset */
+                } else {
+                        *value |= SS_POWERON;
+                        *value |= SS_READY;
+                }
+	}
+#else
+#error no platform configuration
+#endif
+	DEBUG(3, "m32r_cfc: _pcc_get_status: GetStatus(%d) = %#4.4x\n",
+		 sock, *value);
+	return 0;
+} /* _get_status */
+
+/*====================================================================*/
+
+static int _pcc_get_socket(u_short sock, socket_state_t *state)
+{
+//	pcc_socket_t *t = &socket[sock];
+	
+#if defined(CONFIG_PLAT_M32700UT) || defined(CONFIG_PLAT_USRV) || defined(CONFIG_PLAT_OPSPUT)
+	state->flags = 0;
+	state->csc_mask = SS_DETECT;	/* ??? */
+	state->csc_mask |= SS_READY;	/* ??? */
+	state->io_irq = 0;
+	state->Vcc = 33;	/* 3.3V fixed */
+	state->Vpp = 33;
+#endif
+	DEBUG(3, "m32r_cfc:  GetSocket(%d) = flags %#3.3x, Vcc %d, Vpp %d, "
+		  "io_irq %d, csc_mask %#2.2x\n", sock, state->flags,
+		  state->Vcc, state->Vpp, state->io_irq, state->csc_mask);
+	return 0;
+} /* _get_socket */
+
+/*====================================================================*/
+
+static int _pcc_set_socket(u_short sock, socket_state_t *state)
+{
+#if defined(CONFIG_PLAT_MAPPI2)
+	u_long reg = 0;
+#endif
+	DEBUG(3, "m32r_cfc: SetSocket(%d, flags %#3.3x, Vcc %d, Vpp %d, "
+		  "io_irq %d, csc_mask %#2.2x)\n", sock, state->flags,
+		  state->Vcc, state->Vpp, state->io_irq, state->csc_mask);
+
+#if defined(CONFIG_PLAT_M32700UT) || defined(CONFIG_PLAT_USRV) || defined(CONFIG_PLAT_OPSPUT)
+	if (state->Vcc) {
+		if ((state->Vcc != 50) && (state->Vcc != 33))
+			return -EINVAL;
+		/* accept 5V and 3.3V */
+	}
+#elif defined(CONFIG_PLAT_MAPPI2)
+        if (state->Vcc) {
+                /*
+                 * 5V only
+                 */
+                if (state->Vcc == 50) {
+                        reg |= PCCSIGCR_VEN;
+                } else {
+                        return -EINVAL;
+                }
+        }
+#endif
+
+	if (state->flags & SS_RESET) {
+		DEBUG(3, ":RESET\n");
+		pcc_set(sock,(unsigned int)PLD_CFRSTCR,0x101);
+	}else{
+		pcc_set(sock,(unsigned int)PLD_CFRSTCR,0x100);
+	}
+	if (state->flags & SS_OUTPUT_ENA){
+		DEBUG(3, ":OUTPUT_ENA\n");
+		/* bit clear */
+		pcc_set(sock,(unsigned int)PLD_CFBUFCR,0);
+	} else {
+		pcc_set(sock,(unsigned int)PLD_CFBUFCR,1);
+	}
+
+#ifdef PCMCIA_DEBUG
+	if(state->flags & SS_IOCARD){
+		DEBUG(3, ":IOCARD");
+	}
+	if (state->flags & SS_PWR_AUTO) {
+		DEBUG(3, ":PWR_AUTO");
+	}
+	if (state->csc_mask & SS_DETECT)
+		DEBUG(3, ":csc-SS_DETECT");
+	if (state->flags & SS_IOCARD) {
+		if (state->csc_mask & SS_STSCHG) 
+			DEBUG(3, ":STSCHG");
+	} else {
+		if (state->csc_mask & SS_BATDEAD)
+			DEBUG(3, ":BATDEAD");
+		if (state->csc_mask & SS_BATWARN)
+			DEBUG(3, ":BATWARN");
+		if (state->csc_mask & SS_READY)
+			DEBUG(3, ":READY");
+	}
+	DEBUG(3, "\n");
+#endif
+	return 0;
+} /* _set_socket */
+
+/*====================================================================*/
+
+static int _pcc_set_io_map(u_short sock, struct pccard_io_map *io)
+{
+	u_char map;
+	
+	DEBUG(3, "m32r_cfc: SetIOMap(%d, %d, %#2.2x, %d ns, "
+		  "%#4.4x-%#4.4x)\n", sock, io->map, io->flags,
+		  io->speed, io->start, io->stop);
+	map = io->map;
+
+	return 0;
+} /* _set_io_map */
+
+/*====================================================================*/
+
+static int _pcc_set_mem_map(u_short sock, struct pccard_mem_map *mem)
+{
+
+	u_char map = mem->map;
+	u_long mode;
+	u_long addr;
+	pcc_socket_t *t = &socket[sock];
+
+	DEBUG(3, "m32r_cfc: SetMemMap(%d, %d, %#2.2x, %d ns, %#5.5lx-%#5.5"
+		  "lx, %#5.5x)\n", sock, map, mem->flags, mem->speed,
+		  mem->sys_start, mem->sys_stop, mem->card_start);
+
+	/*
+	 * sanity check
+	 */
+	if ((map > MAX_WIN) || (mem->card_start > 0x3ffffff) ||	 
+		(mem->sys_start > mem->sys_stop)) {
+		return -EINVAL;
+	}
+
+	/*
+	 * de-activate
+	 */
+	if ((mem->flags & MAP_ACTIVE) == 0) {
+		t->current_space = as_none;
+		return 0;
+	}
+
+	/*
+	 * Disable first
+	 */
+//	pcc_set(sock, PCCR, 0);
+
+	/*
+	 * Set mode
+	 */
+	if (mem->flags & MAP_ATTRIB) {
+		mode = PCMOD_AS_ATTRIB | PCMOD_CBSZ;
+		t->current_space = as_attr;
+	} else {
+		mode = 0; /* common memory */
+		t->current_space = as_comm;
+	}
+//	pcc_set(sock, PCMOD, mode);
+
+	/*
+	 * Set address
+	 */
+	addr = t->mapaddr + (mem->card_start & M32R_PCC_MAPMASK);
+//	pcc_set(sock, PCADR, addr);
+
+	mem->sys_start = addr + mem->card_start;
+	mem->sys_stop = mem->sys_start + (M32R_PCC_MAPSIZE - 1);
+
+	/*
+	 * Set timing
+	 */
+//	pcc_set(sock, PCATCR, pcc_access_timing);
+
+	/*
+	 * Enable again
+	 */
+//	pcc_set(sock, PCCR, 1);
+
+	return 0;
+
+} /* _set_mem_map */
+
+#if 0 /* driver model ordering issue */
+/*======================================================================
+
+	Routines for accessing socket information and register dumps via
+	/proc/bus/pccard/...
+	
+======================================================================*/
+
+static ssize_t show_info(struct class_device *class_dev, char *buf)
+{
+	pcc_socket_t *s = container_of(class_dev, struct pcc_socket, 
+		socket.dev);
+
+	return sprintf(buf, "type:     %s\nbase addr:    0x%08lx\n",
+		pcc[s->type].name, s->base);
+}
+
+static ssize_t show_exca(struct class_device *class_dev, char *buf)
+{
+	/* FIXME */
+
+	return 0;
+}
+
+static CLASS_DEVICE_ATTR(info, S_IRUGO, show_info, NULL);
+static CLASS_DEVICE_ATTR(exca, S_IRUGO, show_exca, NULL);
+#endif
+
+/*====================================================================*/
+
+/* this is horribly ugly... proper locking needs to be done here at 
+ * some time... */
+#define LOCKED(x) do { \
+	int retval; \
+	unsigned long flags; \
+	spin_lock_irqsave(&pcc_lock, flags); \
+	retval = x; \
+	spin_unlock_irqrestore(&pcc_lock, flags); \
+	return retval; \
+} while (0)
+
+
+static int pcc_get_status(struct pcmcia_socket *s, u_int *value)
+{
+	unsigned int sock = container_of(s, struct pcc_socket, socket)->number;
+
+	if (socket[sock].flags & IS_ALIVE) {
+		DEBUG(3, "m32r_cfc: pcc_get_status: sock(%d) -EINVAL\n", sock);
+		*value = 0;
+		return -EINVAL;
+	}
+	DEBUG(3, "m32r_cfc: pcc_get_status: sock(%d)\n", sock);
+	LOCKED(_pcc_get_status(sock, value));
+}
+
+static int pcc_get_socket(struct pcmcia_socket *s, socket_state_t *state)
+{
+	unsigned int sock = container_of(s, struct pcc_socket, socket)->number;
+
+	if (socket[sock].flags & IS_ALIVE) {
+		DEBUG(3, "m32r_cfc: pcc_get_socket: sock(%d) -EINVAL\n", sock);
+		return -EINVAL;
+	}
+	DEBUG(3, "m32r_cfc: pcc_get_socket: sock(%d)\n", sock);
+	LOCKED(_pcc_get_socket(sock, state));
+}
+
+static int pcc_set_socket(struct pcmcia_socket *s, socket_state_t *state)
+{
+	unsigned int sock = container_of(s, struct pcc_socket, socket)->number;
+
+	if (socket[sock].flags & IS_ALIVE) {
+		DEBUG(3, "m32r_cfc: pcc_set_socket: sock(%d) -EINVAL\n", sock);
+		return -EINVAL;
+	}
+	DEBUG(3, "m32r_cfc: pcc_set_socket: sock(%d)\n", sock);
+	LOCKED(_pcc_set_socket(sock, state));
+}
+
+static int pcc_set_io_map(struct pcmcia_socket *s, struct pccard_io_map *io)
+{
+	unsigned int sock = container_of(s, struct pcc_socket, socket)->number;
+
+	if (socket[sock].flags & IS_ALIVE) {
+		DEBUG(3, "m32r_cfc: pcc_set_io_map: sock(%d) -EINVAL\n", sock);
+		return -EINVAL;
+	}
+	DEBUG(3, "m32r_cfc: pcc_set_io_map: sock(%d)\n", sock);
+	LOCKED(_pcc_set_io_map(sock, io));
+}
+
+static int pcc_set_mem_map(struct pcmcia_socket *s, struct pccard_mem_map *mem)
+{
+	unsigned int sock = container_of(s, struct pcc_socket, socket)->number;
+
+	if (socket[sock].flags & IS_ALIVE) {
+		DEBUG(3, "m32r_cfc: pcc_set_mem_map: sock(%d) -EINVAL\n", sock);
+		return -EINVAL;
+	}
+	DEBUG(3, "m32r_cfc: pcc_set_mem_map: sock(%d)\n", sock);
+	LOCKED(_pcc_set_mem_map(sock, mem));
+}
+
+static int pcc_init(struct pcmcia_socket *s)
+{
+	DEBUG(3, "m32r_cfc: pcc_init()\n");
+	return 0;
+}
+
+static int pcc_suspend(struct pcmcia_socket *sock)
+{
+	DEBUG(3, "m32r_cfc: pcc_suspend()\n");
+	return pcc_set_socket(sock, &dead_socket);
+}
+
+static struct pccard_operations pcc_operations = {
+	.init			= pcc_init,
+	.suspend		= pcc_suspend,
+	.get_status		= pcc_get_status,
+	.get_socket		= pcc_get_socket,
+	.set_socket		= pcc_set_socket,
+	.set_io_map		= pcc_set_io_map,
+	.set_mem_map		= pcc_set_mem_map,
+};
+
+/*====================================================================*/
+
+static int m32rpcc_suspend(struct device *dev, u32 state, u32 level)
+{
+	int ret = 0;
+	if (level == SUSPEND_SAVE_STATE)
+		ret = pcmcia_socket_dev_suspend(dev, state);
+	return ret;
+}
+
+static int m32rpcc_resume(struct device *dev, u32 level)
+{
+	int ret = 0;
+	if (level == RESUME_RESTORE_STATE)
+		ret = pcmcia_socket_dev_resume(dev);
+	return ret;
+}
+
+
+static struct device_driver pcc_driver = {
+	.name = "cfc",
+	.bus = &platform_bus_type,
+	.suspend = m32rpcc_suspend,
+	.resume = m32rpcc_resume,
+};
+
+static struct platform_device pcc_device = {
+	.name = "cfc",
+	.id = 0,
+};
+
+/*====================================================================*/
+
+#define UT_CFC
+static int __init init_m32r_pcc(void)
+{
+	int i, ret;
+
+	ret = driver_register(&pcc_driver);
+	if (ret)
+		return ret;
+
+	ret = platform_device_register(&pcc_device);
+	if (ret){
+		driver_unregister(&pcc_driver);
+		return ret;
+	}
+
+#if defined(CONFIG_PLAT_MAPPI2)
+        pcc_set(0, (unsigned int)PLD_CFCR0, 0x0f0f);
+        pcc_set(0, (unsigned int)PLD_CFCR1, 0x0200);
+#endif
+
+	pcc_sockets = 0;
+	
+#if !defined(CONFIG_PLAT_USRV)
+	add_pcc_socket(M32R_PCC0_BASE, PLD_IRQ_CFC_INSERT, CFC_ATTR_MAPBASE, 
+		       CFC_IOPORT_BASE);
+#else	/* CONFIG_PLAT_USRV */
+	{
+		ulong base, mapaddr;
+		ioaddr_t ioaddr;
+		
+		for (i = 0 ; i < M32R_MAX_PCC ; i++) {
+			base = (ulong)PLD_CFRSTCR;
+			base = base | (i << 8);
+			ioaddr = (i + 1) << 12;
+			mapaddr = CFC_ATTR_MAPBASE | (i << 20);
+			add_pcc_socket(base, 0, mapaddr, ioaddr);
+		}
+	}
+#endif	/* CONFIG_PLAT_USRV */
+	
+	if (pcc_sockets == 0) {
+		printk("socket is not found.\n");
+		platform_device_unregister(&pcc_device);
+		driver_unregister(&pcc_driver);
+		return -ENODEV;
+	}
+
+	/* Set up interrupt handler(s) */
+
+	for (i = 0 ; i < pcc_sockets ; i++) {
+		socket[i].socket.dev.dev = &pcc_device.dev;
+		socket[i].socket.ops = &pcc_operations;
+		socket[i].socket.owner = THIS_MODULE;
+		socket[i].number = i;
+		ret = pcmcia_register_socket(&socket[i].socket);
+		if (ret && i--) {
+			for (; i>= 0; i--)
+				pcmcia_unregister_socket(&socket[i].socket);
+			break;
+		}
+#if 0	/* driver model ordering issue */
+		class_device_create_file(&socket[i].socket.dev,
+					 &class_device_attr_info);
+		class_device_create_file(&socket[i].socket.dev,
+					 &class_device_attr_exca);
+#endif
+	}
+
+	/* Finally, schedule a polling interrupt */
+	if (poll_interval != 0) {
+		poll_timer.function = pcc_interrupt_wrapper;
+		poll_timer.data = 0;
+		init_timer(&poll_timer);
+		poll_timer.expires = jiffies + poll_interval;
+		add_timer(&poll_timer);
+	}
+
+	return 0;
+} /* init_m32r_pcc */
+
+static void __exit exit_m32r_pcc(void)
+{
+	int i;
+
+	for (i = 0; i < pcc_sockets; i++)
+		pcmcia_unregister_socket(&socket[i].socket);
+
+	platform_device_unregister(&pcc_device);
+	if (poll_interval != 0)
+		del_timer_sync(&poll_timer);
+
+	driver_unregister(&pcc_driver);
+} /* exit_m32r_pcc */
+
+module_init(init_m32r_pcc);
+module_exit(exit_m32r_pcc);
+MODULE_LICENSE("Dual MPL/GPL");
+/*====================================================================*/
diff -ruN linux-2.6.7.org/arch/m32r/drivers/m32r_cfc.h linux-2.6.7/arch/m32r/drivers/m32r_cfc.h
--- linux-2.6.7.org/arch/m32r/drivers/m32r_cfc.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/drivers/m32r_cfc.h	2003-12-15 15:48:06.000000000 +0900
@@ -0,0 +1,85 @@
+/*
+ *  $Id$
+ *
+ * Copyright (C) 2001 by Hiroyuki Kondo
+ */
+
+#if !defined(CONFIG_PLAT_USRV)
+#define M32R_MAX_PCC	2
+#else	/* CONFIG_PLAT_USRV */
+#define M32R_MAX_PCC	CONFIG_CFC_NUM
+#endif	/* CONFIG_PLAT_USRV */
+
+/*
+ * M32R PC Card Controler
+ */
+#define M32R_PCC0_BASE        0x00ef7000
+#define M32R_PCC1_BASE        0x00ef7020
+
+/*
+ * Register offsets
+ */
+#define PCCR            0x00
+#define PCADR           0x04
+#define PCMOD           0x08
+#define PCIRC           0x0c
+#define PCCSIGCR        0x10
+#define PCATCR          0x14
+
+/*
+ * PCCR
+ */
+#define PCCR_PCEN       (1UL<<(31-31))
+
+/*
+ * PCIRC
+ */
+#define PCIRC_BWERR     (1UL<<(31-7))
+#define PCIRC_CDIN1     (1UL<<(31-14))
+#define PCIRC_CDIN2     (1UL<<(31-15))
+#define PCIRC_BEIEN     (1UL<<(31-23))
+#define PCIRC_CIIEN     (1UL<<(31-30))
+#define PCIRC_COIEN     (1UL<<(31-31))
+
+/*
+ * PCCSIGCR
+ */
+#define PCCSIGCR_SEN    (1UL<<(31-3))
+#define PCCSIGCR_VEN    (1UL<<(31-7))
+#define PCCSIGCR_CRST   (1UL<<(31-15))
+#define PCCSIGCR_COCR   (1UL<<(31-31))
+
+/*
+ *
+ */
+#define PCMOD_AS_ATTRIB	(1UL<<(31-19))
+#define PCMOD_AS_IO	(1UL<<(31-18))
+
+#define PCMOD_CBSZ	(1UL<<(31-23)) /* set for 8bit */
+
+#define PCMOD_DBEX	(1UL<<(31-31)) /* set for excahnge */
+
+/*
+ * M32R PCC Map addr
+ */
+
+#define M32R_PCC0_MAPBASE        0x14000000
+#define M32R_PCC1_MAPBASE        0x16000000
+
+#define M32R_PCC_MAPMAX		 0x02000000
+
+#define M32R_PCC_MAPSIZE	 0x00001000 /* XXX */
+#define M32R_PCC_MAPMASK     	(~(M32R_PCC_MAPMAX-1))
+
+#define CFC_IOPORT_BASE		0x1000
+
+#if !defined(CONFIG_PLAT_USRV)
+#define CFC_ATTR_MAPBASE        0x0c014000
+#define CFC_IO_MAPBASE_BYTE     0xac012000
+#define CFC_IO_MAPBASE_WORD     0xac002000
+#else	/* CONFIG_PLAT_USRV */
+#define CFC_ATTR_MAPBASE	0x04014000
+#define CFC_IO_MAPBASE_BYTE	0xa4012000
+#define CFC_IO_MAPBASE_WORD	0xa4002000
+#endif	/* CONFIG_PLAT_USRV */
+
diff -ruN linux-2.6.7.org/arch/m32r/drivers/m32r_pcc.c linux-2.6.7/arch/m32r/drivers/m32r_pcc.c
--- linux-2.6.7.org/arch/m32r/drivers/m32r_pcc.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/drivers/m32r_pcc.c	2004-07-15 13:43:14.000000000 +0900
@@ -0,0 +1,818 @@
+/*======================================================================
+
+	Device driver for the PCMCIA functionality of M32R.
+
+======================================================================*/
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/init.h>
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/timer.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/workqueue.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <asm/bitops.h>
+#include <asm/system.h>
+#include <asm/addrspace.h>
+
+#include <pcmcia/version.h>
+#include <pcmcia/cs_types.h>
+#include <pcmcia/ss.h>
+#include <pcmcia/cs.h>
+
+/* XXX: should be moved into asm/irq.h */
+#define PCC0_IRQ 24
+#define PCC1_IRQ 25
+
+#define CHAOS_PCC_DEBUG
+#ifdef CHAOS_PCC_DEBUG
+	static volatile u_short dummy_readbuf;
+#endif
+
+#define PCC_DEBUG_DBEX
+
+#define PCMCIA_DEBUG   0
+
+#include "m32r_pcc.h"
+
+#ifdef PCMCIA_DEBUG
+int pc_debug = PCMCIA_DEBUG;
+module_param(pc_debug, int, 0444);
+#define DEBUG(n, args...) if (pc_debug>(n)) printk(args)
+#else
+#define DEBUG(n, args...) do { } while (0)
+#endif
+
+/* Poll status interval -- 0 means default to interrupt */
+static int poll_interval = 0;
+
+typedef enum pcc_space { as_none = 0, as_comm, as_attr, as_io } pcc_as_t;
+
+typedef struct pcc_socket {
+	u_short			type, flags;
+	struct pcmcia_socket	socket;
+	unsigned int		number;
+ 	ioaddr_t		ioaddr;
+	u_long			mapaddr;
+	u_long			base;	/* PCC register base */
+	u_char			cs_irq, intr;
+	pccard_io_map	io_map[MAX_IO_WIN];
+	pccard_mem_map	mem_map[MAX_WIN];
+	u_char			io_win;
+	u_char			mem_win;
+	pcc_as_t		current_space;
+	u_char			last_iodbex;
+#ifdef CHAOS_PCC_DEBUG
+	u_char			last_iosize;
+#endif
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry *proc;
+#endif
+} pcc_socket_t;
+
+static int pcc_sockets = 0;
+static pcc_socket_t socket[M32R_MAX_PCC] = {
+	{ 0, }, /* ... */
+};
+
+#define ISA_LOCK(n, f) do { } while (0)
+#define ISA_UNLOCK(n, f) do { } while (0)
+
+/*====================================================================*/
+
+static unsigned int pcc_get(u_short, unsigned int);
+static void pcc_set(u_short, unsigned int , unsigned int );
+
+static spinlock_t pcc_lock = SPIN_LOCK_UNLOCKED;
+
+void pcc_iorw(int sock, unsigned long port, void *buf, size_t size, size_t nmemb, int wr, int flag)
+{
+	u_long addr;
+	u_long flags;
+	int need_ex;
+#ifdef PCC_DEBUG_DBEX
+	int _dbex;
+#endif
+	pcc_socket_t *t = &socket[sock];
+#ifdef CHAOS_PCC_DEBUG
+	int map_changed = 0;
+#endif
+
+	/* Need lock ? */
+	spin_lock_irqsave(&pcc_lock, flags);
+
+	/*
+	 * Check if need dbex
+	 */
+	need_ex = (size > 1 && flag == 0) ? PCMOD_DBEX : 0;
+#ifdef PCC_DEBUG_DBEX
+	_dbex = need_ex;
+	need_ex = 0;
+#endif
+
+	/*
+	 * calculate access address
+	 */
+	addr = t->mapaddr + port - t->ioaddr + KSEG1; /* XXX */
+
+	/*
+	 * Check current mapping
+	 */
+	if (t->current_space != as_io || t->last_iodbex != need_ex) {
+
+		u_long cbsz;
+
+		/*
+		 * Disable first
+		 */
+		pcc_set(sock, PCCR, 0);
+
+		/*
+		 * Set mode and io address
+		 */
+		cbsz = (t->flags & MAP_16BIT) ? 0 : PCMOD_CBSZ;
+		pcc_set(sock, PCMOD, PCMOD_AS_IO | cbsz | need_ex);
+		pcc_set(sock, PCADR, addr & 0x1ff00000);
+
+		/*
+		 * Enable and read it
+		 */
+		pcc_set(sock, PCCR, 1);
+
+#ifdef CHAOS_PCC_DEBUG
+#if 0
+		map_changed = (t->current_space == as_attr && size == 2); /* XXX */
+#else
+		map_changed = 1;
+#endif
+#endif
+		t->current_space = as_io;
+	}
+
+	/*
+	 * access to IO space
+	 */
+	if (size == 1) {
+		/* Byte */
+		unsigned char *bp = (unsigned char *)buf;
+
+#ifdef CHAOS_DEBUG
+		if (map_changed) {
+			dummy_readbuf = readb(addr);
+		}
+#endif
+		if (wr) {
+			/* write Byte */
+			while (nmemb--) {
+				writeb(*bp++, addr);
+			}
+		} else {
+			/* read Byte */
+			while (nmemb--) {
+	    		*bp++ = readb(addr);
+			}
+		}
+	} else {
+		/* Word */
+		unsigned short *bp = (unsigned short *)buf;
+
+#ifdef CHAOS_PCC_DEBUG
+		if (map_changed) {
+			dummy_readbuf = readw(addr);
+		}
+#endif
+		if (wr) {
+			/* write Word */
+			while (nmemb--) {
+#ifdef PCC_DEBUG_DBEX
+				if (_dbex) {
+					unsigned char *cp = (unsigned char *)bp;
+					unsigned short tmp;
+					tmp = cp[1] << 8 | cp[0];
+					writew(tmp, addr);
+					bp++;
+				} else 
+#endif
+				writew(*bp++, addr);
+	    	}
+	    } else {
+	    	/* read Word */
+	    	while (nmemb--) {
+#ifdef  PCC_DEBUG_DBEX
+				if (_dbex) {
+					unsigned char *cp = (unsigned char *)bp;
+					unsigned short tmp;
+					tmp = readw(addr);
+					cp[0] = tmp & 0xff;
+					cp[1] = (tmp >> 8) & 0xff;
+					bp++;
+				} else 
+#endif
+				*bp++ = readw(addr);
+	    	}
+	    }
+	}
+
+#if 1
+	/* addr is no longer used */
+	if ((addr = pcc_get(sock, PCIRC)) & PCIRC_BWERR) {
+	  printk("m32r_pcc: BWERR detected : port 0x%04lx : iosize %dbit\n",
+			 port, size * 8);
+	  pcc_set(sock, PCIRC, addr);
+	}
+#endif
+	/*
+	 * save state
+	 */
+	t->last_iosize = size;
+	t->last_iodbex = need_ex;
+
+	/* Need lock ? */
+
+	spin_unlock_irqrestore(&pcc_lock,flags);
+
+	return;
+}
+
+void pcc_ioread(int sock, unsigned long port, void *buf, size_t size, size_t nmemb, int flag) {
+	pcc_iorw(sock, port, buf, size, nmemb, 0, flag);
+}
+
+void pcc_iowrite(int sock, unsigned long port, void *buf, size_t size, size_t nmemb, int flag) {
+    pcc_iorw(sock, port, buf, size, nmemb, 1, flag);
+}
+
+/*====================================================================*/
+
+#define IS_ALIVE		0x8000
+
+typedef struct pcc_t {
+	char				*name;
+	u_short				flags;
+} pcc_t;
+
+static pcc_t pcc[] = {
+	{ "xnux2", 0 }, { "xnux2", 0 },
+};
+
+static irqreturn_t pcc_interrupt(int, void *, struct pt_regs *);
+
+/*====================================================================*/
+
+static struct timer_list poll_timer;
+
+static unsigned int pcc_get(u_short sock, unsigned int reg)
+{
+	return inl(socket[sock].base + reg);
+}
+
+
+static void pcc_set(u_short sock, unsigned int reg, unsigned int data)
+{
+  	outl(data, socket[sock].base + reg);
+}
+
+/*======================================================================
+
+	See if a card is present, powered up, in IO mode, and already
+	bound to a (non PC Card) Linux driver.  We leave these alone.
+
+	We make an exception for cards that seem to be serial devices.
+	
+======================================================================*/
+
+static int __init is_alive(u_short sock)
+{
+	unsigned int stat;
+	unsigned int f;
+	
+	stat = pcc_get(sock, PCIRC);
+	f = (stat & (PCIRC_CDIN1 | PCIRC_CDIN2)) >> 16;
+	if(!f){
+		printk("m32r_pcc: No Card is detected at socket %d : stat = 0x%08x\n",stat,sock);
+		return 0;
+	}
+	if(f!=3)
+		printk("m32r_pcc: Insertion fail (%.8x) at socket %d\n",stat,sock);
+	else
+		printk("m32r_pcc: Card is Inserted at socket %d(%.8x)\n",sock,stat);
+	return 0;
+}
+
+static void add_pcc_socket(ulong base, int irq, ulong mapaddr, ioaddr_t ioaddr)
+{
+  	pcc_socket_t *t = &socket[pcc_sockets];
+
+	/* add sockets */
+	t->ioaddr = ioaddr;
+	t->mapaddr = mapaddr;
+	t->base = base;
+#ifdef CHAOS_PCC_DEBUG
+	t->flags = MAP_16BIT;
+#else
+	t->flags = 0;
+#endif
+	if (is_alive(pcc_sockets))
+		t->flags |= IS_ALIVE;
+
+	/* add pcc */
+	if (t->base > 0) {
+		request_region(t->base, 0x20, "m32r-pcc");
+	}
+
+	printk(KERN_INFO "  %s ", pcc[pcc_sockets].name);
+	printk("pcc at 0x%08lx\n", t->base);
+
+	/* Update socket interrupt information, capabilities */
+	t->socket.features |= (SS_CAP_PCCARD | SS_CAP_STATIC_MAP);
+	t->socket.map_size = M32R_PCC_MAPSIZE;
+	t->socket.io_offset = ioaddr;	/* use for io access offset */
+	t->socket.irq_mask = 0;
+	t->socket.pci_irq = 2 + pcc_sockets; /* XXX */
+
+	request_irq(irq, pcc_interrupt, 0, "m32r-pcc", pcc_interrupt);
+
+	pcc_sockets++;
+
+	return;
+}
+
+
+/*====================================================================*/
+
+static irqreturn_t pcc_interrupt(int irq, void *dev, struct pt_regs *regs)
+{
+	int i, j, irc;
+	u_int events, active;
+	int handled = 0;
+	
+	DEBUG(4, "m32r: pcc_interrupt(%d)\n", irq);
+
+	for (j = 0; j < 20; j++) {
+		active = 0;
+		for (i = 0; i < pcc_sockets; i++) {
+			if ((socket[i].cs_irq != irq) &&
+				(socket[i].socket.pci_irq != irq))
+				continue;
+			handled = 1;
+			irc = pcc_get(i, PCIRC);
+			irc >>=16;
+			DEBUG(2, "m32r-pcc:interrput: socket %d pcirc 0x%02x ", i, irc);
+			if (!irc)
+				continue;
+
+			events = (irc) ? SS_DETECT : 0;
+			events |= (pcc_get(i,PCCR) & PCCR_PCEN) ? SS_READY : 0;
+			DEBUG(2, " event 0x%02x\n", events);
+
+			if (events)
+				pcmcia_parse_events(&socket[i].socket, events);
+
+			active |= events;
+			active = 0;
+		}
+		if (!active) break;
+	}
+	if (j == 20)
+		printk(KERN_NOTICE "m32r-pcc: infinite loop in interrupt handler\n");
+
+	DEBUG(4, "m32r-pcc: interrupt done\n");
+
+	return IRQ_RETVAL(handled);
+} /* pcc_interrupt */
+
+static void pcc_interrupt_wrapper(u_long data)
+{
+	pcc_interrupt(0, NULL, NULL);
+	init_timer(&poll_timer);
+	poll_timer.expires = jiffies + poll_interval;
+	add_timer(&poll_timer);
+}
+
+/*====================================================================*/
+
+static int _pcc_get_status(u_short sock, u_int *value)
+{
+	u_int status;
+	
+	status = pcc_get(sock,PCIRC);
+	*value = ((status & PCIRC_CDIN1) && (status & PCIRC_CDIN2))
+		? SS_DETECT : 0;
+		
+	status = pcc_get(sock,PCCR);
+
+#if 0
+	*value |= (status & PCCR_PCEN) ? SS_READY : 0;
+#else
+	*value |= SS_READY; /* XXX: always */
+#endif
+
+	status = pcc_get(sock,PCCSIGCR);
+	*value |= (status & PCCSIGCR_VEN) ? SS_POWERON : 0;
+
+	DEBUG(3, "m32r-pcc: GetStatus(%d) = %#4.4x\n", sock, *value);
+	return 0;
+} /* _get_status */
+
+/*====================================================================*/
+
+static int _pcc_get_socket(u_short sock, socket_state_t *state)
+{
+	DEBUG(3, "m32r-pcc: GetSocket(%d) = flags %#3.3x, Vcc %d, Vpp %d, "
+		  "io_irq %d, csc_mask %#2.2x\n", sock, state->flags,
+		  state->Vcc, state->Vpp, state->io_irq, state->csc_mask);
+	return 0;
+} /* _get_socket */
+
+/*====================================================================*/
+
+static int _pcc_set_socket(u_short sock, socket_state_t *state)
+{
+	u_long reg = 0;
+	
+	DEBUG(3, "m32r-pcc: SetSocket(%d, flags %#3.3x, Vcc %d, Vpp %d, "
+		  "io_irq %d, csc_mask %#2.2x)", sock, state->flags,
+		  state->Vcc, state->Vpp, state->io_irq, state->csc_mask);
+
+	if (state->Vcc) {
+		/*
+		 * 5V only
+		 */
+		if (state->Vcc == 50) {
+			reg |= PCCSIGCR_VEN;
+		} else {
+			return -EINVAL;
+		}
+	}
+
+	if (state->flags & SS_RESET) {
+		DEBUG(3, ":RESET\n");
+		reg |= PCCSIGCR_CRST;
+	}
+	if (state->flags & SS_OUTPUT_ENA){
+		DEBUG(3, ":OUTPUT_ENA\n");
+		/* bit clear */
+	} else {
+		reg |= PCCSIGCR_SEN;
+	}
+
+	pcc_set(sock,PCCSIGCR,reg);
+
+#ifdef PCMCIA_DEBUG
+	if(state->flags & SS_IOCARD){
+		DEBUG(3, ":IOCARD");
+	}
+	if (state->flags & SS_PWR_AUTO) {
+		DEBUG(3, ":PWR_AUTO");
+	}
+	if (state->csc_mask & SS_DETECT)
+		DEBUG(3, ":csc-SS_DETECT");
+	if (state->flags & SS_IOCARD) {
+		if (state->csc_mask & SS_STSCHG) 
+			DEBUG(3, ":STSCHG");
+	} else {
+		if (state->csc_mask & SS_BATDEAD)
+			DEBUG(3, ":BATDEAD");
+		if (state->csc_mask & SS_BATWARN)
+			DEBUG(3, ":BATWARN");
+		if (state->csc_mask & SS_READY)
+			DEBUG(3, ":READY");
+	}
+	DEBUG(3, "\n");
+#endif
+	return 0;
+} /* _set_socket */
+
+/*====================================================================*/
+
+static int _pcc_set_io_map(u_short sock, struct pccard_io_map *io)
+{
+	u_char map;
+	
+	DEBUG(3, "m32r-pcc: SetIOMap(%d, %d, %#2.2x, %d ns, "
+		  "%#4.4x-%#4.4x)\n", sock, io->map, io->flags,
+		  io->speed, io->start, io->stop);
+	map = io->map;
+
+	return 0;
+} /* _set_io_map */
+
+/*====================================================================*/
+
+static int _pcc_set_mem_map(u_short sock, struct pccard_mem_map *mem)
+{
+
+	u_char map = mem->map;
+	u_long mode;
+	u_long addr;
+	pcc_socket_t *t = &socket[sock];
+#ifdef CHAOS_PCC_DEBUG
+#if 0
+	pcc_as_t last = t->current_space;
+#endif
+#endif
+
+	DEBUG(3, "m32r-pcc: SetMemMap(%d, %d, %#2.2x, %d ns, %#5.5lx-%#5.5"
+		  "lx, %#5.5x)\n", sock, map, mem->flags, mem->speed,
+		  mem->sys_start, mem->sys_stop, mem->card_start);
+
+	/*
+	 * sanity check
+	 */
+	if ((map > MAX_WIN) || (mem->card_start > 0x3ffffff) ||	 
+		(mem->sys_start > mem->sys_stop)) {
+		return -EINVAL;
+	}
+
+	/*
+	 * de-activate
+	 */
+	if ((mem->flags & MAP_ACTIVE) == 0) {
+		t->current_space = as_none;
+		return 0;
+	}
+
+	/*
+	 * Disable first
+	 */
+	pcc_set(sock, PCCR, 0);
+
+	/*
+	 * Set mode
+	 */
+	if (mem->flags & MAP_ATTRIB) {
+		mode = PCMOD_AS_ATTRIB | PCMOD_CBSZ;
+		t->current_space = as_attr;
+	} else {
+		mode = 0; /* common memory */
+		t->current_space = as_comm;
+	}
+	pcc_set(sock, PCMOD, mode);
+
+	/*
+	 * Set address
+	 */
+	addr = t->mapaddr + (mem->card_start & M32R_PCC_MAPMASK);
+	pcc_set(sock, PCADR, addr);
+
+	mem->sys_start = addr + mem->card_start;
+	mem->sys_stop = mem->sys_start + (M32R_PCC_MAPSIZE - 1);
+
+	/*
+	 * Enable again
+	 */
+	pcc_set(sock, PCCR, 1);
+
+#ifdef CHAOS_PCC_DEBUG
+#if 0
+	if (last != as_attr) {
+#else
+	if (1) {
+#endif
+
+		dummy_readbuf = *(u_char *)(addr + KSEG1);
+	}
+#endif
+
+	return 0;
+
+} /* _set_mem_map */
+
+#if 0 /* driver model ordering issue */
+/*======================================================================
+
+	Routines for accessing socket information and register dumps via
+	/proc/bus/pccard/...
+	
+======================================================================*/
+
+static ssize_t show_info(struct class_device *class_dev, char *buf)
+{
+	pcc_socket_t *s = container_of(class_dev, struct pcc_socket, 
+		socket.dev);
+
+	return sprintf(buf, "type:     %s\nbase addr:    0x%08lx\n",
+		pcc[s->type].name, s->base);
+}
+
+static ssize_t show_exca(struct class_device *class_dev, char *buf)
+{
+	/* FIXME */
+
+	return 0;
+}
+
+static CLASS_DEVICE_ATTR(info, S_IRUGO, show_info, NULL);
+static CLASS_DEVICE_ATTR(exca, S_IRUGO, show_exca, NULL);
+#endif
+
+/*====================================================================*/
+
+/* this is horribly ugly... proper locking needs to be done here at 
+ * some time... */
+#define LOCKED(x) do {					\
+	int retval;					\
+	unsigned long flags;				\
+	spin_lock_irqsave(&pcc_lock, flags);		\
+	retval = x;					\
+	spin_unlock_irqrestore(&pcc_lock, flags);	\
+	return retval;					\
+} while (0)
+
+
+static int pcc_get_status(struct pcmcia_socket *s, u_int *value)
+{
+	unsigned int sock = container_of(s, struct pcc_socket, socket)->number;
+
+	if (socket[sock].flags & IS_ALIVE) {
+		*value = 0;
+		return -EINVAL;
+	}
+	LOCKED(_pcc_get_status(sock, value));
+}
+
+static int pcc_get_socket(struct pcmcia_socket *s, socket_state_t *state)
+{
+	unsigned int sock = container_of(s, struct pcc_socket, socket)->number;
+
+	if (socket[sock].flags & IS_ALIVE)
+		return -EINVAL;
+	LOCKED(_pcc_get_socket(sock, state));
+}
+
+static int pcc_set_socket(struct pcmcia_socket *s, socket_state_t *state)
+{
+	unsigned int sock = container_of(s, struct pcc_socket, socket)->number;
+
+	if (socket[sock].flags & IS_ALIVE)
+		return -EINVAL;
+
+	LOCKED(_pcc_set_socket(sock, state));
+}
+
+static int pcc_set_io_map(struct pcmcia_socket *s, struct pccard_io_map *io)
+{
+	unsigned int sock = container_of(s, struct pcc_socket, socket)->number;
+
+	if (socket[sock].flags & IS_ALIVE)
+		return -EINVAL;
+	LOCKED(_pcc_set_io_map(sock, io));
+}
+
+static int pcc_set_mem_map(struct pcmcia_socket *s, struct pccard_mem_map *mem)
+{
+	unsigned int sock = container_of(s, struct pcc_socket, socket)->number;
+
+	if (socket[sock].flags & IS_ALIVE)
+		return -EINVAL;
+	LOCKED(_pcc_set_mem_map(sock, mem));
+}
+
+static int pcc_init(struct pcmcia_socket *s)
+{
+	DEBUG(4, "m32r-pcc: init call\n");
+	return 0;
+}
+
+static int pcc_suspend(struct pcmcia_socket *sock)
+{
+	return pcc_set_socket(sock, &dead_socket);
+}
+
+static struct pccard_operations pcc_operations = {
+	.init			= pcc_init,
+	.suspend		= pcc_suspend,
+	.get_status		= pcc_get_status,
+	.get_socket		= pcc_get_socket,
+	.set_socket		= pcc_set_socket,
+	.set_io_map		= pcc_set_io_map,
+	.set_mem_map		= pcc_set_mem_map,
+};
+
+/*====================================================================*/
+
+static int m32r_pcc_suspend(struct device *dev, u32 state, u32 level)
+{
+	int ret = 0;
+	if (level == SUSPEND_SAVE_STATE)
+		ret = pcmcia_socket_dev_suspend(dev, state);
+	return ret;
+}
+
+static int m32r_pcc_resume(struct device *dev, u32 level)
+{
+	int ret = 0;
+	if (level == RESUME_RESTORE_STATE)
+		ret = pcmcia_socket_dev_resume(dev);
+	return ret;
+}
+
+
+static struct device_driver pcc_driver = {
+	.name = "pcc",
+	.bus = &platform_bus_type,
+	.suspend = m32r_pcc_suspend,
+	.resume = m32r_pcc_resume,
+};
+
+static struct platform_device pcc_device = {
+	.name = "pcc",
+	.id = 0,
+};
+
+/*====================================================================*/
+
+static int __init init_m32r_pcc(void)
+{
+	int i, ret;
+
+	ret = driver_register(&pcc_driver);
+	if (ret)
+		return ret;
+
+	ret = platform_device_register(&pcc_device);
+	if (ret){
+		driver_unregister(&pcc_driver);
+		return ret;
+	}
+
+	printk(KERN_INFO "m32r PCC probe:\n");
+
+	pcc_sockets = 0;
+
+	add_pcc_socket(M32R_PCC0_BASE, PCC0_IRQ, M32R_PCC0_MAPBASE, 0x1000);
+
+#ifdef CONFIG_M32RPCC_SLOT2
+	add_pcc_socket(M32R_PCC1_BASE, PCC1_IRQ, M32R_PCC1_MAPBASE, 0x2000);
+#endif
+
+	if (pcc_sockets == 0) {
+		printk("socket is not found.\n");
+		platform_device_unregister(&pcc_device);
+		driver_unregister(&pcc_driver);
+		return -ENODEV;
+	}
+
+	/* Set up interrupt handler(s) */
+
+	for (i = 0 ; i < pcc_sockets ; i++) {
+		socket[i].socket.dev.dev = &pcc_device.dev;
+		socket[i].socket.ops = &pcc_operations;
+		socket[i].socket.owner = THIS_MODULE;
+		socket[i].number = i;
+		ret = pcmcia_register_socket(&socket[i].socket);
+		if (ret && i--) {
+			for (; i>= 0; i--)
+				pcmcia_unregister_socket(&socket[i].socket);
+			break;
+		}
+#if 0	/* driver model ordering issue */
+		class_device_create_file(&socket[i].socket.dev,
+					 &class_device_attr_info);
+		class_device_create_file(&socket[i].socket.dev,
+					 &class_device_attr_exca);
+#endif
+	}
+
+	/* Finally, schedule a polling interrupt */
+	if (poll_interval != 0) {
+		poll_timer.function = pcc_interrupt_wrapper;
+		poll_timer.data = 0;
+		init_timer(&poll_timer);
+		poll_timer.expires = jiffies + poll_interval;
+		add_timer(&poll_timer);
+	}
+
+	return 0;
+} /* init_m32r_pcc */
+
+static void __exit exit_m32r_pcc(void)
+{
+	int i;
+
+	for (i = 0; i < pcc_sockets; i++)
+		pcmcia_unregister_socket(&socket[i].socket);
+
+	platform_device_unregister(&pcc_device);
+	if (poll_interval != 0)
+		del_timer_sync(&poll_timer);
+
+	driver_unregister(&pcc_driver);
+} /* exit_m32r_pcc */
+
+module_init(init_m32r_pcc);
+module_exit(exit_m32r_pcc);
+MODULE_LICENSE("Dual MPL/GPL");
+/*====================================================================*/
diff -ruN linux-2.6.7.org/arch/m32r/drivers/m32r_pcc.h linux-2.6.7/arch/m32r/drivers/m32r_pcc.h
--- linux-2.6.7.org/arch/m32r/drivers/m32r_pcc.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/drivers/m32r_pcc.h	2003-09-09 10:15:02.000000000 +0900
@@ -0,0 +1,70 @@
+/*
+ *  $Id$
+ *
+ * Copyright (C) 2001 by Hiroyuki Kondo
+ */
+
+
+
+#define M32R_MAX_PCC	2
+
+/*
+ * M32R PC Card Controler
+ */
+#define M32R_PCC0_BASE        0x00ef7000
+#define M32R_PCC1_BASE        0x00ef7020
+
+/*
+ * Register offsets
+ */
+#define PCCR            0x00
+#define PCADR           0x04
+#define PCMOD           0x08
+#define PCIRC           0x0c
+#define PCCSIGCR        0x10
+#define PCATCR          0x14
+
+/*
+ * PCCR
+ */
+#define PCCR_PCEN       (1UL<<(31-31))
+
+/*
+ * PCIRC
+ */
+#define PCIRC_BWERR     (1UL<<(31-7))
+#define PCIRC_CDIN1     (1UL<<(31-14))
+#define PCIRC_CDIN2     (1UL<<(31-15))
+#define PCIRC_BEIEN     (1UL<<(31-23))
+#define PCIRC_CIIEN     (1UL<<(31-30))
+#define PCIRC_COIEN     (1UL<<(31-31))
+
+/*
+ * PCCSIGCR
+ */
+#define PCCSIGCR_SEN    (1UL<<(31-3))
+#define PCCSIGCR_VEN    (1UL<<(31-7))
+#define PCCSIGCR_CRST   (1UL<<(31-15))
+#define PCCSIGCR_COCR   (1UL<<(31-31))
+
+/*
+ *
+ */
+#define PCMOD_AS_ATTRIB	(1UL<<(31-19))
+#define PCMOD_AS_IO	(1UL<<(31-18))
+
+#define PCMOD_CBSZ	(1UL<<(31-23)) /* set for 8bit */
+
+#define PCMOD_DBEX	(1UL<<(31-31)) /* set for excahnge */
+
+/*
+ * M32R PCC Map addr
+ */
+#define M32R_PCC0_MAPBASE        0x14000000
+#define M32R_PCC1_MAPBASE        0x16000000
+
+#define M32R_PCC_MAPMAX		 0x02000000
+
+#define M32R_PCC_MAPSIZE	 0x00001000 /* XXX */
+#define M32R_PCC_MAPMASK     	(~(M32R_PCC_MAPMAX-1))
+
diff -ruN linux-2.6.7.org/arch/m32r/drivers/m5.c linux-2.6.7/arch/m32r/drivers/m5.c
--- linux-2.6.7.org/arch/m32r/drivers/m5.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/drivers/m5.c	2004-07-15 13:43:14.000000000 +0900
@@ -0,0 +1,913 @@
+/*
+ * Flash Memory Driver for M32700UT-CPU
+ *
+ * [support chips]
+ *  	- M5M29GT320VP
+ *
+ * Copyright (C) 2003   Takeo Takahashi
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * 2003-02-01: Takeo Takahashi, support M5M29GT320VP page program.
+ *
+ */
+
+#ifndef __KERNEL__
+#  define __KERNEL__
+#endif
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/devfs_fs_kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/ioctl.h>
+#include <linux/blkpg.h>
+#include <linux/fs.h>
+#include <linux/proc_fs.h>
+#include <linux/mm.h>
+#include <linux/delay.h>
+
+#include <asm/system.h>
+#include <asm/uaccess.h>
+#include <asm/delay.h>
+#include <asm/m32r.h>
+#include <asm/io.h>
+
+#include "m5.h"
+
+static const char version[] = "M5 Flash Driver";
+static const char date[] = __DATE__;
+static const char time[] = __TIME__;
+
+/*
+ * Special function
+ */
+#define M5_SUPPORT_PROBE	1
+#define M5_MAX_ERROR		5
+
+/*
+ * flash memory start address:
+ */
+//#define M5_BASE_ADDR         (0x00000000 + NONCACHE_OFFSET)
+#define M5_BASE_ADDR         (0x00000000 + PAGE_OFFSET)
+#define M5_IDENT_ADDR        (M5_BASE_ADDR + 0)
+
+/*
+ * This driver does not have a real partition block, but
+ * it can support simulation of partition in single chip.
+ */
+#define M5_PARTITIONS        (3)
+static int m5_len[M5_PARTITIONS] = {
+	192 * 1024,	/* 192kB:	0x00000000 - 0x0002ffff */	
+	1088 * 1024,	/* 1088kB:	0x00030000 - 0x0013ffff */
+	2816 * 1024	/* 2816kB:	0x00140000 - 0x003fffff */
+};
+
+static int major = 240;
+static int debug = 2;
+static int led=0;
+static int m5_addr[M5_PARTITIONS];
+static int m5_blk_size[M5_PARTITIONS];
+static int m5_blksize_size[M5_PARTITIONS];
+static int m5_hardsect_size[M5_PARTITIONS];
+static int m5_read_ahead = 1;
+MODULE_PARM(major, "i");
+//MODULE_PARM_DESC(major, "major number");
+MODULE_PARM(debug, "i");
+//MODULE_PARM_DESC(debug, "debug flag");
+MODULE_PARM(led, "i");
+//MODULE_PARM_DESC(led, "LED2 support");
+
+static devfs_handle_t	devfs_handle = NULL;
+#ifdef CONFIG_PROC_FS
+static struct proc_dir_entry *proc_m5;
+#endif
+
+#define MAJOR_NR		major
+#define DEVICE_NAME 		"m5"
+#define DEVICE_NR(device) 	MINOR(device)
+#define DEVICE_NO_RANDOM
+#define DEVICE_OFF(device)
+#define DEVICE_ON(device)
+#define DEVICE_REQUEST 		m5_request
+#include <linux/blk.h>
+
+#define WAIT_TIME	10			/* 10 usec */
+#define WAIT_COUNT	(50000/WAIT_TIME)	/* 50ms = 10us*5000times */
+
+#define SUCCESS 0
+#define FAILED  (-1)
+
+/*
+ * definitions for cache
+ */
+static struct cache {
+	int blk;	/* block number, -1:invalid */
+	int status;	/* cache status */
+#define B_CLEAN	0
+#define B_DIRTY	1
+	m5_t *addr;	/* block base address */
+	m5_t cache[M5_BLOCK_SIZE64];
+} m5_cache;
+#define M5_BLK_NOCACHED()		(m5_cache.blk == -1)
+#define M5_BLK_CACHED(blk)		(m5_cache.blk == (blk))
+#define M5_STATE_DIRTY()		(m5_cache.status == B_DIRTY)
+#define M5_STATE_CLEAN()		(m5_cache.status == B_CLEAN)
+#define M5_MARK_DIRTY()			(m5_cache.status = B_DIRTY)
+#define M5_MARK_CLEAN()			(m5_cache.status = B_CLEAN)
+#define M5_MARK_NOCACHED()		(m5_cache.blk = -1)
+#define M5_MARK_CACHED(blk, addr)	(m5_cache.blk = (blk), \
+					 m5_cache.addr = (addr))
+#define M5_CACHED_BLK			m5_cache.blk
+#define M5_CACHED_ADDR			m5_cache.addr
+#define M5_CACHED_BASE			m5_cache.cache
+
+/*
+ * Prototype declarations
+ */
+static int m5_erase_blk(m5_t *reg);
+static void m5_led_toggle(void);
+static void m5_led_on(void);
+static void m5_led_off(void);
+static m5_t m5_in(m5_t *addr);
+static void m5_out(m5_t val, m5_t *addr);
+static int m5_probe(m5_t *addr);
+static int m5_get_blk_num(m5_t *addr);
+static int m5_get_blk_offset(int blk, m5_t *addr);
+static int m5_get_blk_size(int blk);
+static int m5_read_blk_cache(m5_t *addr);
+static int m5_write_blk_cache(void);
+static int m5_full_status_check(m5_t status, m5_t *reg);
+static void m5_clear_status(m5_t *reg);
+#if 0
+static int m5_status_check(m5_t *reg);
+#endif
+static int m5_wait_for_ready(m5_t *reg);
+static int m5_write_page(m5_t *addr, const m5_t *buf);
+static int m5_write(const m5_t *buf, int offset, int len);
+static int m5_read_page(m5_t *buf, m5_t *addr);
+static int m5_read(m5_t *buf, int offset, int len);
+static int m5_erase_blk(m5_t *addr);
+static void m5_request(request_queue_t *req);
+static int m5_ioctl(struct inode *inode, struct file *fp, unsigned int cmd, unsigned long arg);
+static int m5_open(struct inode *inode, struct file *fp);
+static int m5_release(struct inode *inode, struct file *fp);
+static int proc_m5_read(char *buf, char **start, off_t offset, int len, int *eof, void *unused);
+static int __init m5_init(void);
+static int __init m5_init_module(void);
+static void __exit m5_cleanup_module(void);
+
+/*
+ * special function
+ */
+static inline void m5_led_toggle(void)
+{
+	unsigned short status;
+	if (!led) return;
+	status = inw((unsigned long)PLD_IOLEDCR);
+	if (status & PLD_IOLED_2_ON)
+		status &= ~PLD_IOLED_2_ON;
+	else
+		status |= PLD_IOLED_2_ON;
+	outw(status, (unsigned long)PLD_IOLEDCR);
+}
+
+static inline void m5_led_on(void)
+{
+	unsigned short status;
+	if (!led) return;
+	status = inw((unsigned long)PLD_IOLEDCR);
+	status |= PLD_IOLED_2_ON;
+	outw(status, (unsigned long)PLD_IOLEDCR);
+}
+
+static inline void m5_led_off(void)
+{
+	unsigned short status;
+	if (!led) return;
+	status = inw((unsigned long)PLD_IOLEDCR);
+	status &= ~PLD_IOLED_2_ON;
+	outw(status, (unsigned long)PLD_IOLEDCR);
+}
+
+/*
+ * I/O function
+ */
+static inline m5_t m5_in(m5_t *addr)
+{
+	return *addr;
+}
+
+static inline void m5_out(m5_t val, m5_t *addr)
+{
+	*addr = val;
+}
+
+#if M5_SUPPORT_PROBE
+/*
+ * int m5_probe()
+ *	m5_t *addr:	probed address
+ * 	int SUCCESS: 	supported device
+ *	int FAILED: 	unsupported device
+ */
+static int m5_probe(m5_t *addr)
+{
+#if 1
+	/*
+	 * FIXME: cannot read maker & device codes.
+	 */
+	m5_t val;
+	m5_out(M5_CMD_DEVICE_IDENT, addr);
+	val = m5_in((m5_t *)M5_IDENT_ADDR);
+	val &= 0xff;
+	if (val == M5_MAKER)
+		printk("m5: detected M5M29GT320VP\n");
+	else
+		printk("m5: unknown maker(0x%02x)\n", val);
+	m5_out(M5_CMD_READ_ARRAY, addr);	/* array mode */
+	/* always success */
+	return SUCCESS;
+#else
+
+	int result;
+	m5_t val;
+	unsigned char maker, device;
+
+	result = SUCCESS;
+	m5_out(M5_CMD_DEVICE_IDENT, addr);
+	val = m5_in((m5_t *)M5_IDENT_ADDR);
+	maker = (val >> 16);
+	device = (val & 0xff);
+	if (maker != M5_MAKER) {
+		printk("m5: unknown maker(0x%02x)\n", maker);
+		// result = FAILED;
+		// ignore error
+	}
+ 	if (device != M5_M5M29GT320VP) {
+		printk("m5: unknown device(0x%02x)\n", device);
+		// result = FAILED;
+		// ignore error
+	}
+	if (result != FAILED)
+		printk("m5: detected M5M29GT320VP\n");
+	m5_out(M5_CMD_READ_ARRAY, addr);
+	return result;
+#endif
+}
+#endif	/* M5_SUPPORT_PROBE */
+
+/*
+ * int m5_get_blk_num()
+ *	m5_t *addr:
+ *	blk:	OK, return block number
+ *	-1:	NG
+ */
+static int m5_get_blk_num(m5_t *addr)
+{
+	int blk;
+
+	blk = (((int)addr & 0x0fff0000) >> 16);
+	if (blk > 0x3f) {
+		printk("m5: out of block address (0x%08x)\n", (int)addr);
+		return -1; 
+	}
+	if (blk == 0x3f)
+		blk += (int)(((int)addr & 0x0000e000) >> 13);
+	if (blk > MAX_BLOCK_NUM) {
+		printk("m5: out of block address (addr=0x%08x, blk=%d)\n",
+				(int)addr, blk);
+		return -1;
+	}
+	return blk;
+}
+
+/*
+ * m5_t *m5_get_blk_base()
+ *	return block base address
+ */
+static inline m5_t *m5_get_blk_base(int blk, m5_t *addr)
+{
+	if (blk < 0x3f) return (m5_t *)((int)addr & 0xffff0000);
+	return (m5_t *)((int)addr & 0xffffe000);
+}
+
+/*
+ * int m5_get_blk_offset()
+ *	return offset of specified address in blk
+ */
+static inline int m5_get_blk_offset(int blk, m5_t *addr)
+{
+	if (blk < 0x3f) return ((int)addr & 0xffff);
+	return ((int)addr & 0x1fff);
+}
+
+/*
+ * int m5_get_blk_size()
+ *	return block size in byte
+ */
+static inline int m5_get_blk_size(int blk)
+{
+	if (blk >= 63) return M5_BLOCK_SIZE8;
+	return M5_BLOCK_SIZE64;
+}
+
+/*
+ * cache operations 
+ */
+static int m5_read_blk_cache(m5_t *addr)
+{
+	int blk;
+	int size;
+	int result;
+
+	result = SUCCESS;
+	blk = m5_get_blk_num(addr);
+	if (blk < 0) return FAILED;
+	if (M5_BLK_CACHED(blk))
+		return result;
+	if (M5_STATE_DIRTY()) {		/* cached other block */
+		result = m5_write_blk_cache();
+		if (result != SUCCESS) return result;
+	}
+	/* ok, we can use cache */
+	size = m5_get_blk_size(blk);
+	addr = m5_get_blk_base(blk, addr);
+	memcpy((void *)M5_CACHED_BASE, (void *)addr, size);
+	M5_MARK_CACHED(blk, addr);
+	M5_MARK_CLEAN();
+	return result;
+}
+
+static int m5_write_blk_cache(void)
+{
+	int size;
+	int pages;
+	int i;
+	m5_t *reg, *addr, *buf;
+	int result;
+
+	result = SUCCESS;
+
+	if (M5_BLK_NOCACHED()) 
+		return result;
+	if (! M5_STATE_DIRTY())
+		return result;
+
+	/* we have to write cache */
+	m5_led_on();
+	size = m5_get_blk_size(M5_CACHED_BLK);
+	addr = M5_CACHED_ADDR;
+	buf = M5_CACHED_BASE;
+	reg = addr;
+
+	result = m5_erase_blk(reg);
+	if (result != SUCCESS) return result;
+
+	DEBUG(1, "m5: wrting addr=0x%08x, buf=0x%08x, size=%d\n",\
+		(int)addr, (int)buf, size);
+	for (pages = 0; pages < (size/M5_PAGE_SIZE); pages++) {
+		m5_out(M5_CMD_PROGRAM_PAGE, reg);
+		for (i = 0; i < (M5_PAGE_SIZE/sizeof(m5_t)); i++)
+			*addr++ = *buf++;
+		if (m5_wait_for_ready(reg) != SUCCESS)
+			result = FAILED;
+		reg = addr;
+	}
+	m5_out(M5_CMD_READ_ARRAY, reg);	/* array mode */
+	if (result == SUCCESS)
+		M5_MARK_CLEAN();
+	m5_led_off();
+	return result;	/* SUCCESS or FAILED */
+}
+
+/*
+ * int m5_full_status_check()
+ *	m5_t status:	status
+ *	m5_t *reg:	bank address
+ *	SUCCESS:	no error
+ *	FAILED:		error happen
+ */
+static inline int m5_full_status_check(m5_t status, m5_t *reg)
+{
+	if ((status & M5_STATUS_PROGRAM) &&
+	    (status & M5_STATUS_ERASE)) {
+		printk("m5: command sequence error (addr=0x%08x, sts=0x%02x).\n",
+			(int)reg, status);
+		return FAILED;
+	}
+   	if(status & M5_STATUS_ERASE){
+      		printk("m5: erase error (addr=0x%08x, sts=0x%02x).\n",
+			(int)reg, status);
+      		return FAILED;
+   	}
+   	if(status & M5_STATUS_PROGRAM){
+      		printk("m5: program write error (addr=0x%08x, sts=0x%02x).\n",
+			(int)reg, status);
+      		return FAILED;
+   	}
+   	if(status & M5_STATUS_BLOCK){
+      		printk("m5: block write error (addr=0x%08x, sts=0x%02x).\n",
+			(int)reg, status);
+      		return FAILED;
+   	}
+	/* passed */
+   	return SUCCESS;
+}                     
+
+/*
+ * void m5_clear_status()
+ *	m5_t *reg:	address of status register
+ */
+static inline void m5_clear_status(m5_t *reg)
+{
+	m5_out(M5_CMD_CLEAR_STATUS, reg);
+}
+
+#if 0
+/*
+ * int m5_status_check()
+ *	m5_t *reg:	address of command register
+ *	SUCCESS:	ready now
+ *	FAILED:		error happen while waiting
+ */
+static int m5_status_check(m5_t *reg)
+{
+	m5_t status;
+	int result;
+	int n;
+	static int error_count = 0;
+
+	m5_out(M5_CMD_READ_STATUS, reg);
+	for (n = WAIT_COUNT; n > 0; n--) {
+		status = m5_in(reg);
+		if (status & M5_STATUS_READY)
+			break;
+		udelay(WAIT_TIME);
+	}
+	if (n <= 0) {
+		if (error_count++ < M5_MAX_ERROR)
+			printk("m5: time out (sts=0x%02x).\n", status);
+		m5_clear_status(reg);
+		return FAILED;
+	}
+	result = m5_full_status_check(status, reg);
+	if (result != SUCCESS) {
+		m5_clear_status(reg);
+		return FAILED;
+	}
+	m5_clear_status(reg);
+	return SUCCESS;
+}
+#endif
+
+/*
+ * int m5_wait_for_ready()
+ *	m5_t *reg:	address of command register
+ *	SUCCESS:	ready now
+ *	FAILED:		error happen while waiting
+ */
+static int m5_wait_for_ready(m5_t *reg)
+{
+	m5_t status;
+	int result;
+	int n;
+	static int error_count = 0;
+
+	for (n = WAIT_COUNT; n > 0; n--) {
+		status = m5_in(reg);
+		if (status & M5_STATUS_READY)
+			break;
+		udelay(WAIT_TIME);
+	}
+	if (n <= 0) {
+		if (error_count++ < M5_MAX_ERROR)
+			printk("m5: time out (sts=0x%02x).\n", status);
+		m5_clear_status(reg);
+		return FAILED;
+	}
+	result = m5_full_status_check(status, reg);
+	if (result != SUCCESS) {
+		m5_clear_status(reg);
+		return FAILED;
+	}
+	return SUCCESS;
+}
+
+/*
+ * int m5_write_page(m5_t *addr, const m5_t *buf)
+ *	m5_t *addr:	sector address
+ *	m5_t *buf:	buffer address
+ *	SUCCESS:	ok
+ *	FAILED:		error
+ */
+static int m5_write_page(m5_t *addr, const m5_t *buf)
+{
+	int blk;
+	int offset;
+
+	if (((int)addr % M5_PAGE_SIZE) != 0)
+		printk("m5: invalid sector addres (0x%08x)\n", (int)addr);
+
+	if (m5_read_blk_cache(addr) != SUCCESS)
+		return FAILED;
+	if ((blk = m5_get_blk_num(addr)) < 0)
+		return FAILED;
+	offset = m5_get_blk_offset(blk, addr);
+	memcpy((void *)M5_CACHED_BASE + offset, (void *)buf, M5_PAGE_SIZE);
+	M5_MARK_DIRTY();
+	return SUCCESS;
+}
+	
+/*
+ * int m5_write(const m5_t *buf, int offset, int len)
+ *	m5_t *buf:	write buffer address
+ *	int offset:	offset from flash base address
+ *	int len:	write length
+ *	SUCCESS:	ok
+ *	FAILE:		error
+ */
+static int m5_write(const m5_t *buf, int offset, int len)
+{
+	m5_t *addr;
+	int result;
+
+	if (len % M5_PAGE_SIZE) {
+		printk("m5: invalid write size (%d).\n", len);
+		return FAILED;
+	}
+	addr = (m5_t *)(m5_addr[MINOR(CURRENT_DEV)] + offset);
+
+	DEBUG(1, "m5: writing 0x%08x - 0x%08x\n", \
+		(int)addr, (int)addr + len);
+
+	for (; len > 0; len -= M5_PAGE_SIZE) {
+		result = m5_write_page(addr, buf);
+		if (result != SUCCESS)
+			return result;
+		addr = (m5_t *)((int)addr + M5_PAGE_SIZE);
+		buf = (m5_t *)((int)buf + M5_PAGE_SIZE);
+	}
+	return SUCCESS;
+}
+
+/*
+ * int m5_read_page()
+ *	m5_t *buf:	read buffer address
+ *	m5_t *addr:	page address
+ *	SUCCESS:	ok
+ *	FAILED:		error
+ */
+static int m5_read_page(m5_t *buf, m5_t *addr)
+{
+	int blk;
+	int offset;
+
+	if ((blk = m5_get_blk_num(addr)) < 0)
+		return FAILED;
+	if (M5_BLK_CACHED(blk)) {
+		offset = m5_get_blk_offset(blk, addr);
+		memcpy((void *)buf, (void *)M5_CACHED_BASE + offset,
+				M5_PAGE_SIZE);
+	} else {
+		/* read from flash memory directory */
+		memcpy((void *)buf, (void *)addr, M5_PAGE_SIZE);
+	}
+	return SUCCESS;
+}
+
+/*
+ * int m5_read()
+ *	m5_t *buf:		read buffer address
+ *	int offset:		offset from flash base address
+ *	int len:		read length
+ *	SUCCESS:		ok
+ *	FAILED:			error
+ */
+static int m5_read(m5_t *buf, int offset, int len)
+{
+	m5_t *addr;
+
+	if (len % M5_PAGE_SIZE) {
+		printk("m5: invalid read size (%d).\n", len);
+		return FAILED;
+	}
+
+	addr = (m5_t *)(m5_addr[MINOR(CURRENT_DEV)] + offset);
+
+	DEBUG(1, "m5: reading 0x%08x - 0x%08x\n", \
+		(int)addr, (int)addr + len);
+
+	for (; len > 0; len -= M5_PAGE_SIZE) {
+		if (m5_read_page(buf, addr) != SUCCESS)
+			return FAILED;
+		buf = (m5_t *)((int)buf + M5_PAGE_SIZE);
+		addr = (m5_t *)((int)addr + M5_PAGE_SIZE);
+	}
+	return SUCCESS;
+}
+
+/*
+ * int m5_erase_blk()
+ *	m5_t *addr:
+ */
+static int m5_erase_blk(m5_t *addr)
+{
+	int result;
+
+	DEBUG(1, "m5: erasing addr=0x%08x\n", (int)addr);
+	m5_out(M5_CMD_BLOCK_ERASE, addr);
+	m5_out(M5_CMD_CONFIRM, addr);
+	result = m5_wait_for_ready(addr);
+	return result;
+}
+
+/*
+ * void m5_request()
+ *	request_queue_t *req:	I/O request
+ *	end_request(0):	error (-EIO)
+ *	end_request(1): ok
+ */
+static void m5_request(request_queue_t *req)
+{
+    	unsigned int minor;
+    	int offset;
+	int len;
+	static int error_count = 0;
+
+	sti();
+	while (1) {
+		INIT_REQUEST;
+		minor = MINOR(CURRENT_DEV);
+		if (minor >= M5_PARTITIONS) {
+	    		printk( "m5: out of partition (%d)\n", minor );
+	    		end_request(0);
+	    		continue;
+		}
+		offset = CURRENT->sector * m5_hardsect_size[minor];
+		len = (CURRENT->current_nr_sectors *
+			m5_hardsect_size[minor]);
+		if ((offset + len) > m5_len[minor]) {
+	    		printk( "m5: out of sector (sector=%d, nr=%d)\n",
+				(int)(CURRENT->sector),
+				(int)(CURRENT->current_nr_sectors));
+	    		end_request(0);
+	    		continue;
+		}
+		switch(CURRENT->cmd) {
+	    	case READ:
+			if (m5_read((m5_t *)CURRENT->buffer,
+					offset, len) != SUCCESS)
+		    		end_request(0);
+			else
+		    		end_request(1);
+			break;
+	    	case WRITE:
+			if (m5_write((m5_t *)(CURRENT->buffer),
+					offset, len) != SUCCESS)
+		    		end_request(0);
+			else
+		    		end_request(1);
+                	break;
+	    	default:
+			if (error_count++ < M5_MAX_ERROR) {
+				printk("m5: invalid I/O request(%d)\n",
+					CURRENT->cmd);
+			}
+			end_request(0);
+			break;
+		}
+	}
+}
+
+/*
+ * int m5_ioctl()
+ *	struct inode *inode:
+ *	struct file *file:
+ *	unsigned int cmd:
+ *	unsigned long arg:
+ */
+static int m5_ioctl(struct inode *inode, struct file *fp, unsigned int cmd, unsigned long arg)
+{
+	int size;
+
+	DEBUG(2, "m5_ioctl()\n");
+    	switch (cmd) {
+      	case BLKGETSIZE:
+		if (!arg) return -EINVAL;
+		size = (1024 * m5_blk_size[MINOR(inode->i_rdev)] /
+			m5_hardsect_size[MINOR(inode->i_rdev)]);
+		return put_user(size, (long __user *)arg);
+      	case BLKFLSBUF:
+		if (!capable(CAP_SYS_ADMIN)) return -EACCES;
+		fsync_dev(inode->i_rdev);
+		invalidate_buffers(inode->i_rdev);
+		return 0;
+	case BLKRRPART:
+		return -EINVAL;
+
+	case BLKRAGET:
+	case BLKRASET:
+	case BLKGETSIZE64:
+	case BLKROSET:
+	case BLKROGET:
+      	case BLKSSZGET:
+		return blk_ioctl(inode->i_rdev, cmd, arg);
+      	default:
+		printk( "m5: unsupported ioctl(0x%08x)\n", cmd);
+		return -EINVAL;
+    	}
+    	return 0;
+}
+
+/*
+ * int m5_open()
+ *	struct inode *inode:
+ *	struct file *fp:
+ */
+static int m5_open(struct inode *inode, struct file *fp)
+{
+    	if (DEVICE_NR(inode->i_rdev) >= M5_PARTITIONS) return -ENXIO;
+    	MOD_INC_USE_COUNT;
+    	return 0;
+}
+
+/*
+ * int m5_release()
+ *	struct inode *inode:
+ *	struct file *fp:
+ */
+static int m5_release(struct inode *inode, struct file *fp)
+{
+    	sync_dev(inode->i_rdev);
+    	MOD_DEC_USE_COUNT;
+    	return 0;
+}
+
+#ifdef CONFIG_PROC_FS
+/*
+ * int proc_m5_read()
+ *	char *buf:
+ *	char **start:
+ *	off_t offset:
+ *	int len:
+ *	int *eof:
+ *	void *unused:
+ */
+static int proc_m5_read(char *buf, char **start, off_t offset, int len, int *eof, void *unused)
+{
+	len = sprintf(buf, "partition: %d\n", M5_PARTITIONS);
+	return len;
+}
+#endif
+
+static struct block_device_operations m5_fops = {
+	open:		m5_open,
+	release:	m5_release,
+	ioctl:		m5_ioctl,
+	/* check_media_change: */
+	/* revalidate: */
+	owner:		THIS_MODULE,
+};
+
+/*
+ * int m5_init()
+ */
+static int __init m5_init(void)
+{
+	int i;
+	int result;
+
+	result = -EIO;
+
+	printk("%s (%s %s)\n", version, date, time);
+#if M5_SUPPORT_PROBE
+	if (m5_probe((m5_t *)M5_BASE_ADDR) != SUCCESS)
+		return result;
+#endif	/* M5_SUPPORT_PROBE */
+
+	if (register_blkdev(major, DEVICE_NAME, &m5_fops) ) {
+		printk("m5: can not not get major %d", major);
+		return result;
+	}
+
+	if (devfs_register_blkdev(major, DEVICE_NAME, &m5_fops) ) {
+		printk("m5: can not not get major %d", major);
+		goto fail_devfs;
+	}
+	devfs_handle = devfs_mk_dir(NULL, "m5", NULL);
+	devfs_register_series(devfs_handle, "%u", M5_PARTITIONS,
+			      DEVFS_FL_DEFAULT, major, 0,
+			      S_IFBLK | S_IRUSR | S_IWUSR,
+			      &m5_fops, NULL);
+
+	for (i = 0; i < M5_PARTITIONS; i++) {
+		if (i) {
+			m5_addr[i] = m5_addr[i-1] + m5_len[i-1];
+		} else { 
+			m5_addr[i] = M5_BASE_ADDR;
+		}
+		m5_blk_size[i] = m5_len[i]/1024;	/* KB order */
+		m5_blksize_size[i] = BLOCK_SIZE;  	/* 1024 byte */
+		m5_hardsect_size[i] = BLOCK_SIZE/2;	/* 512 byte */
+	}
+	/* defined in ll_rw_blk.c */
+	blk_size[major] = m5_blk_size;
+	blksize_size[major] = m5_blksize_size;
+	hardsect_size[major] = m5_hardsect_size;
+	read_ahead[major] = m5_read_ahead;
+
+	blk_init_queue(BLK_DEFAULT_QUEUE(major), &m5_request);
+
+	for (i = 0; i < M5_PARTITIONS; i++)
+		register_disk(  NULL, MKDEV(major,i), 1, 
+				&m5_fops, m5_len[i]>>9 );
+
+#ifdef CONFIG_PROC_FS
+#if	1
+	proc_m5 = proc_mkdir("m5", proc_root_driver);
+	if (!proc_m5) {
+		printk(KERN_ERR "m5: unable to register driver/m5\n");
+		goto fail_proc;
+	}
+	create_proc_read_entry("0", 0, proc_m5, proc_m5_read, 0);
+	create_proc_read_entry("1", 0, proc_m5, proc_m5_read, 0);
+	create_proc_read_entry("2", 0, proc_m5, proc_m5_read, 0);
+#else
+	proc_m5 = create_proc_entry("driver/m5", 666, 0);
+	if (!proc_m5) {
+		printk(KERN_ERR "m5: unable to register driver/m5\n");
+		goto fail_proc;
+	}
+	proc_m5->read_proc = proc_m5_read;
+#endif
+#endif
+
+	printk("m5: Major=%d Partitions=%d\n", major,M5_PARTITIONS);
+	for (i = 0; i < M5_PARTITIONS; i++) {
+	printk("  %d: 0x%08x-0x%08x (all=%dKB,blk=%dB,sect=%dB,ahead=%d)\n",
+	        i, m5_addr[i],
+		m5_addr[i] + m5_len[i], 
+		m5_blk_size[i],
+		m5_blksize_size[i],
+		m5_hardsect_size[i],
+		m5_read_ahead);
+	}
+
+	/* clear cache */
+	M5_MARK_CLEAN();
+	M5_MARK_NOCACHED();
+
+	m5_led_off();
+	return 0;
+
+fail_proc:
+	devfs_unregister(devfs_handle);
+fail_devfs:
+	unregister_blkdev(major, DEVICE_NAME);
+	return result;
+}
+
+static int __init m5_init_module(void)
+{
+    return m5_init();
+}
+
+static void __exit m5_cleanup_module(void)
+{
+    	int i;
+ 
+    	for (i = 0 ; i < M5_PARTITIONS; i++) {
+		fsync_dev(MKDEV(major, i));	/* flush buffer */
+      		destroy_buffers(MKDEV(major, i));
+	}
+	m5_write_blk_cache();		/* flush m5 cache */
+    	devfs_unregister(devfs_handle);
+    	unregister_blkdev(major, DEVICE_NAME);
+#ifdef CONFIG_PROC_FS
+	remove_proc_entry("0", proc_m5);
+	remove_proc_entry("1", proc_m5);
+	remove_proc_entry("2", proc_m5);
+	remove_proc_entry("m5", proc_root_driver);
+#endif
+    	blk_cleanup_queue(BLK_DEFAULT_QUEUE(major));
+	blk_size[major] = NULL;
+	blksize_size[major] = NULL;
+	hardsect_size[major] = NULL;
+	read_ahead[major] = 0;
+}
+
+module_init(m5_init_module);
+module_exit(m5_cleanup_module);
+
+MODULE_AUTHOR("Takeo Takahashi");
+MODULE_DESCRIPTION("M5 Flash Driver for M32700UT-CPU");
+MODULE_LICENSE("GPL");
+EXPORT_NO_SYMBOLS;
+
diff -ruN linux-2.6.7.org/arch/m32r/drivers/m5.h linux-2.6.7/arch/m32r/drivers/m5.h
--- linux-2.6.7.org/arch/m32r/drivers/m5.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/drivers/m5.h	2003-09-09 10:15:02.000000000 +0900
@@ -0,0 +1,73 @@
+/*
+ * Flash Memory Driver for M32700UT-CPU
+ *
+ * Copyright 2003 (C)   Takeo Takahashi
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * 2003-02-01: 	Takeo Takahashi, support M5M29GT320VP.
+ */
+
+#include <asm/m32r.h>
+
+#ifdef __KERNEL__
+#undef DEBUG
+/* debug routine:
+ *   0x00000001: print debug information
+ */
+#  define DEBUG(n, args...) if ((n) & debug) \
+	printk(KERN_DEBUG args)
+#endif	/* __KERNEL__ */
+
+/*
+ * data type to access flash memory
+ */
+typedef volatile unsigned short m5_t;
+
+/*
+ * - Page program buffer size in byte
+ * - block size in byte
+ * - number of block
+ */
+#define M5_PAGE_SIZE		(256)
+#define M5_BLOCK_SIZE8		(8*1024)
+#define M5_BLOCK_SIZE64		(64*1024)
+#define MAX_BLOCK_NUM		70
+
+/*
+ * Software commands
+ */
+#define M5_CMD_READ_ARRAY            0xff
+#define M5_CMD_DEVICE_IDENT          0x90
+#define M5_CMD_READ_STATUS           0x70
+#define M5_CMD_CLEAR_STATUS          0x50
+#define M5_CMD_BLOCK_ERASE           0x20
+#define M5_CMD_CONFIRM               0xd0
+#define M5_CMD_PROGRAM_BYTE          0x40
+#define M5_CMD_PROGRAM_WORD          M5_CMD_PROGRAM_BYTE
+#define M5_CMD_PROGRAM_PAGE          0x41
+#define M5_CMD_SINGLE_LOAD_DATA      0x74
+#define M5_CMD_BUFF2FLASH            0x0e
+#define M5_CMD_FLASH2BUFF            0xf1
+#define M5_CMD_CLEAR_BUFF            0x55
+#define M5_CMD_SUSPEND               0xb0
+#define M5_CMD_RESUME                0xd0
+
+/*
+ * Status
+ */
+#define M5_STATUS_READY              0x80 /* 0:busy 1:ready */
+#define M5_STATUS_SUSPEND            0x40 /* 0:progress/complete 1:suspend */
+#define M5_STATUS_ERASE              0x20 /* 0:pass 1:error */
+#define M5_STATUS_PROGRAM            0x10 /* 0:pass 1:error */
+#define M5_STATUS_BLOCK              0x08 /* 0:pass 1:error */
+
+/*
+ * Device Code
+ */
+#define M5_MAKER		(0x1c)
+#define M5_M5M29GT320VP		(0x20)
+#define M5_M5M29GB320VP		(0x21)
diff -ruN linux-2.6.7.org/arch/m32r/drivers/m5drv.c linux-2.6.7/arch/m32r/drivers/m5drv.c
--- linux-2.6.7.org/arch/m32r/drivers/m5drv.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/drivers/m5drv.c	2003-09-09 10:15:02.000000000 +0900
@@ -0,0 +1,664 @@
+/*
+ * MTD chip driver for M5M29GT320VP
+ *
+ * Copyright (C) 2003   Takeo Takahashi
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * $Id$
+ */
+
+#ifndef __KERNEL__
+#  define __KERNEL__
+#endif
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/cfi.h>
+#include <linux/delay.h>
+
+#define M5DRV_DEBUG(n, args...) if ((n) & m5drv_debug) printk(KERN_DEBUG args)
+
+#undef UNLOCK_BEFORE_ERASE
+
+#define M5DRV_PAGE_SIZE		(256)		/* page program size */
+#define M5DRV_BLOCK_SIZE8	(8*1024)	/* 8K block size in byte */
+#define M5DRV_BLOCK_SIZE64	(64*1024)	/* 64K block size in byte */
+#define M5DRV_MAX_BLOCK_NUM	70		/* number of blocks */
+#define M5DRV_ERASE_REGION	2		/* 64KB and 8KB */
+
+/*
+ * Software commands
+ */
+#define CMD_READ_ARRAY          0xff
+#define CMD_DEVICE_IDENT        0x90
+#define CMD_READ_STATUS         0x70
+#define CMD_CLEAR_STATUS        0x50
+#define CMD_BLOCK_ERASE         0x20
+#define CMD_CONFIRM             0xd0
+#define CMD_PROGRAM_BYTE        0x40
+#define CMD_PROGRAM_WORD        CMD_PROGRAM_BYTE
+#define CMD_PROGRAM_PAGE        0x41
+#define CMD_SINGLE_LOAD_DATA    0x74
+#define CMD_BUFF2FLASH          0x0e
+#define CMD_FLASH2BUFF          0xf1
+#define CMD_CLEAR_BUFF          0x55
+#define CMD_SUSPEND             0xb0
+#define CMD_RESUME              0xd0
+#define IDENT_OFFSET        	0	/* indent command offset */
+
+/*
+ * Status
+ */
+#define STATUS_READY              0x80 /* 0:busy 1:ready */
+#define STATUS_SUSPEND            0x40 /* 0:progress/complete 1:suspend */
+#define STATUS_ERASE              0x20 /* 0:pass 1:error */
+#define STATUS_PROGRAM            0x10 /* 0:pass 1:error */
+#define STATUS_BLOCK              0x08 /* 0:pass 1:error */
+
+/*
+ * Device Code
+ */
+#define MAKER		(0x1c)
+#define M5M29GT320VP	(0x20)
+#define M5M29GB320VP	(0x21)
+
+static const char version[] = "M5DRV Flash Driver";
+static const char date[] = __DATE__;
+static const char time[] = __TIME__;
+static int m5drv_debug = 0;
+MODULE_PARM(m5drv_debug, "i");
+
+struct m5drv_info {
+	struct flchip *chip;
+	int chipshift;
+	int numchips;
+	struct flchip chips[1];
+	unsigned char buf[M5DRV_BLOCK_SIZE64];
+#define M5BUF	(m5drv->buf)
+};
+
+struct mtd_info *m5drv_probe(struct map_info *map);
+static int m5drv_probe_map(struct map_info *map, struct mtd_info *mtd);
+static int m5drv_wait(struct map_info *map, struct flchip *chip, loff_t adr);
+static void m5drv_release(struct flchip *chip);
+static int m5drv_query_blksize(loff_t ofs);
+static int m5drv_read(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf);
+static int m5drv_read_oneblock(struct map_info *map, loff_t from);
+static int m5drv_write(struct mtd_info *mtd, loff_t adr, size_t len, size_t *retlen, const u_char *buf);
+static int m5drv_write_oneblock(struct map_info *map, loff_t adr, size_t len, const u_char *buf);
+static int m5drv_write_onepage(struct map_info *map, struct flchip *chip, unsigned long adr, const u_char *buf);
+static int m5drv_erase(struct mtd_info *mtd, struct erase_info *instr);
+static int m5drv_do_wait_for_ready(struct map_info *map, struct flchip *chip, unsigned long adr);
+static int m5drv_erase_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr);
+static void m5drv_sync(struct mtd_info *mtd);
+static int m5drv_suspend(struct mtd_info *mtd);
+static void m5drv_resume(struct mtd_info *mtd);
+static void m5drv_destroy(struct mtd_info *mtd);
+#ifdef UNLOCK_BEFORE_ERASE
+static void m5drv_unlock_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr);
+#endif
+
+static struct mtd_chip_driver m5drv_chipdrv = {
+	probe:		m5drv_probe,
+	destroy:	m5drv_destroy,
+	name:		"m5drv",
+	module:		THIS_MODULE
+};
+	
+struct mtd_info *m5drv_probe(struct map_info *map)
+{
+	struct mtd_info *mtd = NULL;
+	struct m5drv_info *m5drv = NULL;
+	int width;
+
+	mtd = kmalloc(sizeof(*mtd), GFP_KERNEL);
+	if (!mtd) {
+		printk("m5drv: can not allocate memory for mtd_info\n");
+		return NULL;
+	}
+
+	m5drv = kmalloc(sizeof(*m5drv), GFP_KERNEL);
+	if (!m5drv) {
+		printk("m5drv: can not allocate memory for m5drv_info\n");
+		kfree(mtd);
+		return NULL;
+	}
+
+	memset(mtd, 0, sizeof(*mtd));
+	width = m5drv_probe_map(map, mtd);
+	if (!width) {
+		printk("m5drv: m5drv_probe_map error (width=%d)\n", width);
+		kfree(mtd);
+		kfree(m5drv);
+		return NULL;
+	}
+	mtd->priv = map;
+	mtd->type = MTD_OTHER;
+	mtd->erase = m5drv_erase;
+	mtd->read = m5drv_read;
+	mtd->write = m5drv_write;
+	mtd->sync = m5drv_sync;
+	mtd->suspend = m5drv_suspend;
+	mtd->resume = m5drv_resume;
+	mtd->flags = MTD_CAP_NORFLASH;	/* ??? */
+	mtd->name = map->name;
+
+	memset(m5drv, 0, sizeof(*m5drv));
+	m5drv->chipshift = 23;
+	m5drv->numchips = 1;
+	m5drv->chips[0].start = 0;
+	m5drv->chips[0].state = FL_READY;
+	m5drv->chips[0].mutex = &m5drv->chips[0]._spinlock;
+	m5drv->chips[0].word_write_time = 0;
+	init_waitqueue_head(&m5drv->chips[0].wq);
+	spin_lock_init(&m5drv->chips[0]._spinlock);
+
+	map->fldrv = &m5drv_chipdrv;
+	map->fldrv_priv = m5drv;
+
+	MOD_INC_USE_COUNT;
+	return mtd;
+}
+
+static int m5drv_probe_map(struct map_info *map, struct mtd_info *mtd)
+{
+	u16 tmp;
+	u16 maker, device;
+	int width = 2;
+	struct mtd_erase_region_info *einfo;
+
+	map->write16(map, CMD_READ_ARRAY, IDENT_OFFSET);
+	tmp = map->read16(map, IDENT_OFFSET);
+	map->write16(map, CMD_DEVICE_IDENT, IDENT_OFFSET);
+	maker = map->read16(map, IDENT_OFFSET);
+	maker &= 0xff;
+	if (maker == MAKER) {
+		/* FIXME: check device */
+		device = maker >> 8;
+		printk("m5drv: detected M5M29GT320VP\n");
+		einfo = kmalloc(sizeof(*einfo) * M5DRV_ERASE_REGION, GFP_KERNEL);
+		if (!einfo) {
+			printk("m5drv: cannot allocate memory for erase_region\n");
+			return 0;
+		}
+		/* 64KB erase block (blk no# 0-62) */
+		einfo[0].offset = 0;
+		einfo[0].erasesize = 0x8000 * width;
+		einfo[0].numblocks = (7 + 8 + 24 + 24);
+		/* 8KB erase block (blk no# 63-70) */
+		einfo[1].offset = 0x3f0000;
+		einfo[1].erasesize = 0x1000 * width;
+		einfo[1].numblocks = (2 + 8);
+		mtd->numeraseregions = M5DRV_ERASE_REGION;
+		mtd->eraseregions = einfo;
+		mtd->size = 0x200000 * width;		/* total 4MB */
+		/*
+		 * mtd->erasesize is used in parse_xxx_partitions.
+		 * last erase block has a partition table.
+		 */
+		mtd->erasesize = 0x8000 * width;
+		return width;
+	} else if (map->read16(map, IDENT_OFFSET) == CMD_DEVICE_IDENT) {
+		printk("m5drv: looks like RAM\n");
+		map->write16(map, tmp, IDENT_OFFSET);
+	} else {
+		printk("m5drv: can not detect flash memory (0x%04x)\n", maker);
+	}
+	map->write16(map, CMD_READ_ARRAY, IDENT_OFFSET);
+	return 0;
+}
+ 
+static int m5drv_query_blksize(loff_t ofs)
+{
+	int blk;
+	
+	blk = ofs >> 16;
+	if (blk > 0x3f) {
+		printk("m5drv: out of block address (0x%08x)\n", (u32)ofs);
+		return M5DRV_BLOCK_SIZE64;
+	}
+	if (blk == 63) blk += ((ofs & 0x0000e000) >> 13);
+	if (blk > M5DRV_MAX_BLOCK_NUM) {
+		printk("m5drv: out of block address (0x%08x)\n", (u32)ofs);
+		return M5DRV_BLOCK_SIZE64;
+	}
+	return ((blk >= 63)? M5DRV_BLOCK_SIZE8:M5DRV_BLOCK_SIZE64);
+}
+
+static int m5drv_wait(struct map_info *map, struct flchip *chip, loff_t adr)
+{
+	__u16 status;
+	unsigned long timeo;
+	DECLARE_WAITQUEUE(wait, current);
+
+ 	timeo = jiffies + HZ;
+	adr &= ~1;	/* align 2 */
+
+retry:
+	spin_lock_bh(chip->mutex);
+
+	switch (chip->state) {
+	case FL_READY:
+		map->write16(map, CMD_READ_STATUS, adr);
+		chip->state = FL_STATUS;
+	case FL_STATUS:
+		status = map->read16(map, adr);
+		if ((status & STATUS_READY) != STATUS_READY) {
+			udelay(100);
+		}
+		break;
+	default:
+		printk("m5drv: waiting for chip\n");
+		if (time_after(jiffies, timeo)) { /* jiffies is after timeo */
+			set_current_state(TASK_INTERRUPTIBLE);
+			add_wait_queue(&chip->wq, &wait);
+			spin_unlock_bh(chip->mutex);
+			schedule();
+			remove_wait_queue(&chip->wq, &wait);
+			spin_lock_bh(chip->mutex);	// by takeo
+			if (signal_pending(current)) {
+				printk("m5drv: canceled\n");
+				map->write16(map, CMD_CLEAR_STATUS, adr);
+				map->write16(map, CMD_READ_ARRAY, adr);
+				chip->state = FL_READY;
+				return -EINTR;
+			}
+		}
+		timeo = jiffies + HZ;
+		goto retry;
+	}
+	map->write16(map, CMD_READ_ARRAY, adr);
+	chip->state = FL_READY;
+	return 0;
+}
+
+static void m5drv_release(struct flchip *chip)
+{
+	M5DRV_DEBUG(1, "m5drv_release\n");
+	wake_up(&chip->wq);
+	spin_unlock_bh(chip->mutex);
+}
+
+static int m5drv_read(struct mtd_info *mtd, loff_t from, size_t len, size_t *retlen, u_char *buf)
+{
+	struct map_info *map = mtd->priv;
+	struct m5drv_info *m5drv = map->fldrv_priv;
+	int chipnum;
+	int ret;
+
+	*retlen = 0;
+
+	chipnum = (from >> m5drv->chipshift);
+	if (chipnum >= m5drv->numchips) {
+		printk("m5drv: out of chip number (%d)\n", chipnum);
+		return -EIO;
+	}
+
+	/* We don't support erase suspend */
+	ret = m5drv_wait(map, &m5drv->chips[chipnum], from);
+	if (ret < 0) return ret;
+
+	map->copy_from(map, buf, from, len);
+
+	m5drv_release(&m5drv->chips[chipnum]);
+	*retlen = len;
+	return 0;
+}
+
+static int m5drv_read_oneblock(struct map_info *map, loff_t from)
+{
+	struct m5drv_info *m5drv = map->fldrv_priv;
+	int ofs;
+	int ret;
+	int blksize;
+	int chipnum;
+
+	M5DRV_DEBUG(1, "m5drv_read_oneblock(0x%08x)\n", (u32)from);
+	chipnum = (from >> m5drv->chipshift);
+	blksize = m5drv_query_blksize(from);
+	ofs = (from & ~(blksize - 1));
+
+	ret = m5drv_wait(map, &m5drv->chips[chipnum], from);
+	if (ret < 0) return ret;
+
+	map->copy_from(map, M5BUF, ofs, blksize);
+
+	m5drv_release(&m5drv->chips[chipnum]);
+	return 0;
+}
+
+static int m5drv_write(struct mtd_info *mtd, loff_t to, size_t len, size_t *retlen, const u_char *buf)
+{
+	struct map_info *map = mtd->priv;
+	struct m5drv_info *m5drv = map->fldrv_priv;
+	int ret = 0;
+	int blksize;
+	int chipnum;
+	int thislen;
+
+	M5DRV_DEBUG(1, "m5drv_write(to=0x%08x, len=%d, buf=0x%08x\n", (u32)to, (u32)len, (u32)buf);
+	*retlen = 0;
+	blksize = m5drv_query_blksize(to);
+	chipnum = (to >> m5drv->chipshift);
+
+	/*
+	 * we does not support byte/word program yet.
+	 */
+	for (thislen = len; thislen > 0; thislen -= blksize) {
+		thislen = ((thislen >= blksize)? blksize:thislen);
+		ret = m5drv_write_oneblock(map, to, thislen, buf);
+		if (ret < 0) return ret;
+		to += blksize;
+		buf += blksize;
+		*retlen += thislen;
+	}
+	return 0;
+}
+
+static int m5drv_write_oneblock(struct map_info *map, loff_t adr, size_t len, const u_char *buf)
+{
+	struct m5drv_info *m5drv = map->fldrv_priv;
+	int ofs;
+	int blksize;
+	int ret;
+	int chipnum;
+	int i;
+
+	M5DRV_DEBUG(1, "m5drv_write_oneblock(0x%08x, %d)\n", (u32)adr, (u32)len);
+	chipnum = (adr >> m5drv->chipshift);
+	ret = m5drv_read_oneblock(map, adr);
+	if (ret < 0) return ret;
+	blksize = m5drv_query_blksize(adr);
+	ofs = (adr & (blksize - 1));
+	adr = adr & ~(blksize - 1);
+	memcpy(M5BUF + ofs, buf, len);	/* copy to block buffer */
+#if 0	/*
+	 * FIXME: erasing is unnecessary.
+	 */
+	ret = m5drv_erase_oneblock(map, &m5drv->chips[chipnum], adr);
+	if (ret < 0) return ret;
+#endif
+	for (i = 0; i < len; i += M5DRV_PAGE_SIZE) {
+		ret = m5drv_write_onepage(map, &m5drv->chips[chipnum], adr, M5BUF+i);
+		if (ret < 0) return ret;
+		adr += M5DRV_PAGE_SIZE;
+	}
+	return 0;
+}
+
+static int m5drv_write_onepage(struct map_info *map, struct flchip *chip, unsigned long adr, const u_char *buf)
+{
+	int ret;
+	int i;
+	u_short data;
+	long padr;	/* page address */
+	u_short status;
+	int chipnum;
+	struct m5drv_info *m5drv = map->fldrv_priv;
+
+	M5DRV_DEBUG(1, "m5drv_write_onepage(0x%08x, 0x%08x)\n", (u32)adr, (u32)buf);
+	padr = adr;
+	padr &= ~1;	/* align 2 */
+	chipnum = (adr >> m5drv->chipshift);
+
+	ret = m5drv_wait(map, chip, padr);
+	if (ret < 0) return ret;
+
+	map->write16(map, CMD_PROGRAM_PAGE, padr);
+	chip->state = FL_WRITING;
+	for (i = 0; i < M5DRV_PAGE_SIZE; i += map->buswidth) {
+		data = ((*buf << 8)| *(buf + 1));
+		/*
+		 * FIXME: convert be->le ?
+		 */
+		map->write16(map, data, adr);
+		adr += map->buswidth;
+		buf += map->buswidth;
+	}
+
+	ret = m5drv_do_wait_for_ready(map, chip, padr);
+	if (ret < 0) {
+		m5drv_release(&m5drv->chips[chipnum]);
+		return ret;
+	}
+
+	status = map->read16(map, padr);
+	if ((status & STATUS_READY) != STATUS_READY) {
+		printk("m5drv: error page writing at addr=0x%08x status=0x%08x\n",
+			(u32)padr, (u32)status);
+		map->write16(map, CMD_CLEAR_STATUS, padr);
+	}
+	map->write16(map, CMD_READ_ARRAY, padr);
+	chip->state = FL_READY;
+	m5drv_release(&m5drv->chips[chipnum]);
+	return 0;
+}
+
+static int m5drv_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct map_info *map = mtd->priv;
+	struct m5drv_info *m5drv = map->fldrv_priv;
+	unsigned long adr,len;
+	int chipnum, ret=0;
+	int erasesize = 0;
+	int i;
+
+	M5DRV_DEBUG(2, "m5drv_erase(0x%08x)\n", instr->addr);
+	chipnum = instr->addr >> m5drv->chipshift;
+	if (chipnum >= m5drv->numchips) {
+		printk("m5drv: out of chip number (%d)\n", chipnum);
+		return -EIO;
+	}
+	adr = instr->addr & ((1<<m5drv->chipshift)-1);
+	len = instr->len;
+	if (mtd->numeraseregions == 0) {
+		erasesize = mtd->erasesize;
+	} else if (mtd->numeraseregions == 1) {
+		erasesize = mtd->eraseregions->erasesize;
+	} else {
+		for (i = 0; i < (mtd->numeraseregions - 1); i++) {
+			if (adr < mtd->eraseregions[i+1].offset) {
+				erasesize = mtd->eraseregions[i].erasesize;
+				break;
+			}
+		}
+		if (i == (mtd->numeraseregions - 1)) {	/* last region */
+			erasesize = mtd->eraseregions[i].erasesize;
+		}
+	}
+	M5DRV_DEBUG(2, "erasesize=%d, len=%ld\n", erasesize, len);
+	if (erasesize == 0) return -EINVAL;
+	if(instr->addr & (erasesize - 1))
+		return -EINVAL;
+	if(instr->len & (erasesize - 1))
+		return -EINVAL;
+	if(instr->len + instr->addr > mtd->size)
+		return -EINVAL;
+
+	while (len) {
+		ret = m5drv_erase_oneblock(map, &m5drv->chips[chipnum], adr);
+		if (ret < 0) return ret;
+
+		adr += erasesize;
+		len -= erasesize;
+		if(adr >> m5drv->chipshift){
+			adr = 0;
+			chipnum++;
+			if(chipnum >= m5drv->numchips)
+				break;
+		}
+	}
+	instr->state = MTD_ERASE_DONE;
+	if(instr->callback) {
+		M5DRV_DEBUG(1, "m5drv: call callback\n");
+		instr->callback(instr);
+	}
+	return 0;
+}
+
+static int m5drv_do_wait_for_ready(struct map_info *map, struct flchip *chip, unsigned long adr)
+{
+	int ret;
+	int timeo;
+	u_short status;
+	DECLARE_WAITQUEUE(wait, current);
+
+	/* unnecessary CMD_READ_STATUS */
+/*
+	map->write16(map, CMD_READ_STATUS, adr);
+	status = map->read16(map, adr);
+*/
+
+	timeo = jiffies + HZ;
+
+	while (time_before(jiffies, timeo)) {
+/*
+		map->write16(map, CMD_READ_STATUS, adr);
+*/
+		status = map->read16(map, adr);
+		if ((status & STATUS_READY) == STATUS_READY) {
+			M5DRV_DEBUG(1, "m5drv_wait_for_ready: ok, ready\n");
+			/*
+		 	 * FIXME: do full status check
+		 	 */
+			ret = 0;
+			goto out;
+		}
+		set_current_state(TASK_INTERRUPTIBLE);
+		add_wait_queue(&chip->wq, &wait);
+
+		// enabled by takeo
+		spin_unlock_bh(chip->mutex);
+
+		schedule_timeout(1);
+		schedule();
+		remove_wait_queue(&chip->wq, &wait);
+
+		// enabled by takeo
+		spin_lock_bh(chip->mutex);
+		
+		if (signal_pending(current)) {
+			ret = -EINTR;
+			goto out;
+		}
+		//timeo = jiffies + HZ;
+	}
+	ret = -ETIME;
+out:
+	if (ret < 0) {
+		map->write16(map, CMD_CLEAR_STATUS, adr);
+		map->write16(map, CMD_READ_ARRAY, adr);
+		chip->state = FL_READY;
+	}
+	return ret;
+}
+
+static int m5drv_erase_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr)
+{
+	int ret;
+	u_short status;
+	struct m5drv_info *m5drv = map->fldrv_priv;
+	int chipnum;
+
+	M5DRV_DEBUG(1, "m5drv_erase_oneblock()\n");
+
+#ifdef UNLOCK_BEFORE_ERASE
+	m5drv_unlock_oneblock(map, chip, adr);
+#endif
+
+	chipnum = (adr >> m5drv->chipshift);
+	adr &= ~1;		/* align 2 */
+
+	ret = m5drv_wait(map, chip, adr);
+	if (ret < 0) return ret;
+
+	map->write16(map, CMD_BLOCK_ERASE, adr);
+	map->write16(map, CMD_CONFIRM, adr);
+	chip->state = FL_ERASING;
+
+	ret = m5drv_do_wait_for_ready(map, chip, adr);
+	if(ret < 0) {
+		m5drv_release(&m5drv->chips[chipnum]);
+		return ret;
+	}
+
+	status = map->read16(map, adr);
+	if ((status & STATUS_READY) == STATUS_READY) {
+		M5DRV_DEBUG(1, "m5drv: erase completed status=%04x\n", status);
+		map->write16(map, CMD_READ_ARRAY, adr);
+		chip->state = FL_READY;
+		m5drv_release(&m5drv->chips[chipnum]);
+		return 0;		/* ok, erasing completed */
+	}
+
+	printk("m5drv: error erasing block at addr=%08lx status=%08x\n",
+		adr,status);
+	map->write16(map, CMD_READ_ARRAY, adr);		/* cancel erasing */
+	chip->state = FL_READY;
+	m5drv_release(&m5drv->chips[chipnum]);
+	return -EIO;
+}
+
+
+#ifdef UNLOCK_BEFORE_ERASE
+/*
+ * we don't support unlock yet
+ */
+static void m5drv_unlock_oneblock(struct map_info *map, struct flchip *chip, unsigned long adr)
+{
+	M5DRV_DEBUG(1, "m5drv_unlock_oneblock\n");
+}
+#endif
+
+static void m5drv_sync(struct mtd_info *mtd)
+{
+	M5DRV_DEBUG(1, "m5drv_sync()\n");
+}
+
+static int m5drv_suspend(struct mtd_info *mtd)
+{
+	M5DRV_DEBUG(1, "m5drv_suspend()\n");
+	return -EINVAL;
+}
+
+static void m5drv_resume(struct mtd_info *mtd)
+{
+	M5DRV_DEBUG(1, "m5drv_resume()\n");
+}
+
+static void m5drv_destroy(struct mtd_info *mtd)
+{
+	M5DRV_DEBUG(1, "m5drv_destroy()\n");
+}
+
+int __init m5drv_probe_init(void)
+{
+	printk("MTD chip driver\n");
+	register_mtd_chip_driver(&m5drv_chipdrv);
+	return 0;
+}
+
+static void __exit m5drv_probe_exit(void)
+{
+	M5DRV_DEBUG(1, "m5drv_probe_exit()\n");
+	unregister_mtd_chip_driver(&m5drv_chipdrv);
+}
+
+module_init(m5drv_probe_init);
+module_exit(m5drv_probe_exit);
+
+MODULE_AUTHOR("Takeo Takahashi");
+MODULE_DESCRIPTION("MTD chip driver for M5M29GT320VP");
+MODULE_LICENSE("GPL");
+EXPORT_NO_SYMBOLS;
diff -ruN linux-2.6.7.org/arch/m32r/drivers/mappi_ne.c linux-2.6.7/arch/m32r/drivers/mappi_ne.c
--- linux-2.6.7.org/arch/m32r/drivers/mappi_ne.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/drivers/mappi_ne.c	2004-04-01 16:29:44.000000000 +0900
@@ -0,0 +1,861 @@
+/* mappi_ne.c: A general non-shared-memory NS8390 ethernet driver for linux. */
+/*
+    Written 1992-94 by Donald Becker.
+
+    Copyright 1993 United States Government as represented by the
+    Director, National Security Agency.
+
+    This software may be used and distributed according to the terms
+    of the GNU General Public License, incorporated herein by reference.
+
+    The author may be reached as becker@scyld.com, or C/O
+    Scyld Computing Corporation, 410 Severn Ave., Suite 210, Annapolis MD 21403
+
+    This driver should work with many programmed-I/O 8390-based ethernet
+    boards.  Currently it supports the NE1000, NE2000, many clones,
+    and some Cabletron products.
+
+    Changelog:
+
+    Paul Gortmaker	: use ENISR_RDC to monitor Tx PIO uploads, made
+			  sanity checks and bad clone support optional.
+    Paul Gortmaker	: new reset code, reset card after probe at boot.
+    Paul Gortmaker	: multiple card support for module users.
+    Paul Gortmaker	: Support for PCI ne2k clones, similar to lance.c
+    Paul Gortmaker	: Allow users with bad cards to avoid full probe.
+    Paul Gortmaker	: PCI probe changes, more PCI cards supported.
+    rjohnson@analogic.com : Changed init order so an interrupt will only
+    occur after memory is allocated for dev->priv. Deallocated memory
+    last in cleanup_modue()
+    Richard Guenther    : Added support for ISAPnP cards
+    Paul Gortmaker	: Discontinued PCI support - use ne2k-pci.c instead.
+
+*/
+
+/* Routines for the NatSemi-based designs (NE[12]000). */
+
+static const char version1[] =
+"ne.c:v1.10 9/23/94 Donald Becker (becker@scyld.com)\n";
+static const char version2[] =
+"Last modified Nov 1, 2000 by Paul Gortmaker\n";
+
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/isapnp.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+
+#include <asm/system.h>
+#include <asm/io.h>
+
+#include "8390.h"
+
+/* Some defines that people can play with if so inclined. */
+
+/* Do we support clones that don't adhere to 14,15 of the SAprom ? */
+#define SUPPORT_NE_BAD_CLONES
+
+/* Do we perform extra sanity checks on stuff ? */
+/* #define NE_SANITY_CHECK */
+
+/* Do we implement the read before write bugfix ? */
+/* #define NE_RW_BUGFIX */
+
+/* Do we have a non std. amount of memory? (in units of 256 byte pages) */
+/* #define PACKETBUF_MEMSIZE	0x40 */
+
+/* A zero-terminated list of I/O addresses to be probed at boot. */
+#ifndef MODULE
+static unsigned int netcard_portlist[] __initdata = {
+	0x300, 0x280, 0x320, 0x340, 0x360, 0x380, 0
+};
+#endif
+
+static struct isapnp_device_id isapnp_clone_list[] __initdata = {
+	{	ISAPNP_CARD_ID('A','X','E',0x2011),
+		ISAPNP_VENDOR('A','X','E'), ISAPNP_FUNCTION(0x2011),
+		(long) "NetGear EA201" },
+	{	ISAPNP_ANY_ID, ISAPNP_ANY_ID,
+		ISAPNP_VENDOR('E','D','I'), ISAPNP_FUNCTION(0x0216),
+		(long) "NN NE2000" },
+	{	ISAPNP_ANY_ID, ISAPNP_ANY_ID,
+		ISAPNP_VENDOR('P','N','P'), ISAPNP_FUNCTION(0x80d6),
+		(long) "Generic PNP" },
+	{ }	/* terminate list */
+};
+
+MODULE_DEVICE_TABLE(isapnp, isapnp_clone_list);
+
+#ifdef SUPPORT_NE_BAD_CLONES
+/* A list of bad clones that we none-the-less recognize. */
+static struct { const char *name8, *name16; unsigned char SAprefix[4];}
+bad_clone_list[] __initdata = {
+    {"DE100", "DE200", {0x00, 0xDE, 0x01,}},
+    {"DE120", "DE220", {0x00, 0x80, 0xc8,}},
+    {"DFI1000", "DFI2000", {'D', 'F', 'I',}}, /* Original, eh?  */
+    {"EtherNext UTP8", "EtherNext UTP16", {0x00, 0x00, 0x79}},
+    {"NE1000","NE2000-invalid", {0x00, 0x00, 0xd8}}, /* Ancient real NE1000. */
+    {"NN1000", "NN2000",  {0x08, 0x03, 0x08}}, /* Outlaw no-name clone. */
+    {"4-DIM8","4-DIM16", {0x00,0x00,0x4d,}},  /* Outlaw 4-Dimension cards. */
+    {"Con-Intl_8", "Con-Intl_16", {0x00, 0x00, 0x24}}, /* Connect Int'nl */
+    {"ET-100","ET-200", {0x00, 0x45, 0x54}}, /* YANG and YA clone */
+    {"COMPEX","COMPEX16",{0x00,0x80,0x48}}, /* Broken ISA Compex cards */
+    {"E-LAN100", "E-LAN200", {0x00, 0x00, 0x5d}}, /* Broken ne1000 clones */
+    {"PCM-4823", "PCM-4823", {0x00, 0xc0, 0x6c}}, /* Broken Advantech MoBo */
+    {"REALTEK", "RTL8019", {0x00, 0x00, 0xe8}}, /* no-name with Realtek chip */
+    {"LCS-8834", "LCS-8836", {0x04, 0x04, 0x37}}, /* ShinyNet (SET) */
+    {0,}
+};
+#endif
+
+/* ---- No user-serviceable parts below ---- */
+
+#define NE_BASE	 (dev->base_addr)
+#define NE_CMD	 	0x00
+#define NE_DATAPORT	0x10	/* NatSemi-defined port window offset. */
+#define NE_RESET	0x1f	/* Issue a read to reset, a write to clear. */
+#define NE_IO_EXTENT	0x20
+
+#define NE1SM_START_PG	0x20	/* First page of TX buffer */
+#define NE1SM_STOP_PG 	0x40	/* Last page +1 of RX ring */
+#define NESM_START_PG	0x40	/* First page of TX buffer */
+#define NESM_STOP_PG	0x80	/* Last page +1 of RX ring */
+
+static int ne_probe1(struct net_device *dev, int ioaddr);
+static int ne_probe_isapnp(struct net_device *dev);
+
+static int ne_open(struct net_device *dev);
+static int ne_close(struct net_device *dev);
+
+static void ne_reset_8390(struct net_device *dev);
+static void ne_get_8390_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr,
+			  int ring_page);
+static void ne_block_input(struct net_device *dev, int count,
+			  struct sk_buff *skb, int ring_offset);
+static void ne_block_output(struct net_device *dev, const int count,
+		const unsigned char *buf, const int start_page);
+
+
+/*  Probe for various non-shared-memory ethercards.
+
+   NEx000-clone boards have a Station Address PROM (SAPROM) in the packet
+   buffer memory space.  NE2000 clones have 0x57,0x57 in bytes 0x0e,0x0f of
+   the SAPROM, while other supposed NE2000 clones must be detected by their
+   SA prefix.
+
+   Reading the SAPROM from a word-wide card with the 8390 set in byte-wide
+   mode results in doubled values, which can be detected and compensated for.
+
+   The probe is also responsible for initializing the card and filling
+   in the 'dev' and 'ei_status' structures.
+
+   We use the minimum memory size for some ethercard product lines, iff we can't
+   distinguish models.  You can increase the packet buffer size by setting
+   PACKETBUF_MEMSIZE.  Reported Cabletron packet buffer locations are:
+	E1010   starts at 0x100 and ends at 0x2000.
+	E1010-x starts at 0x100 and ends at 0x8000. ("-x" means "more memory")
+	E2010	 starts at 0x100 and ends at 0x4000.
+	E2010-x starts at 0x100 and ends at 0xffff.  */
+
+static int __init do_ne_probe(struct net_device *dev)
+{
+	unsigned int base_addr = dev->base_addr;
+#ifndef MODULE
+	int orig_irq = dev->irq;
+#endif
+
+	SET_MODULE_OWNER(dev);
+
+	/* First check any supplied i/o locations. User knows best. <cough> */
+	if (base_addr > 0x1ff)	/* Check a single specified location. */
+		return ne_probe1(dev, base_addr);
+	else if (base_addr != 0)	/* Don't probe at all. */
+		return -ENXIO;
+
+	/* Then look for any installed ISAPnP clones */
+	if (isapnp_present() && (ne_probe_isapnp(dev) == 0))
+		return 0;
+
+#ifndef MODULE
+	/* Last resort. The semi-risky ISA auto-probe. */
+	for (base_addr = 0; netcard_portlist[base_addr] != 0; base_addr++) {
+		int ioaddr = netcard_portlist[base_addr];
+		dev->irq = orig_irq;
+		if (ne_probe1(dev, ioaddr) == 0)
+			return 0;
+	}
+#endif
+
+	return -ENODEV;
+}
+
+static void cleanup_card(struct net_device *dev)
+{
+	struct pnp_dev *idev = (struct pnp_dev *)ei_status.priv;
+	if (idev)
+		pnp_device_detach(idev);
+	free_irq(dev->irq, dev);
+	release_region(dev->base_addr, NE_IO_EXTENT);
+}
+
+struct net_device * __init ne_probe(int unit)
+{
+	struct net_device *dev = alloc_ei_netdev();
+	int err;
+
+	if (!dev)
+		return ERR_PTR(-ENOMEM);
+
+	sprintf(dev->name, "eth%d", unit);
+	netdev_boot_setup_check(dev);
+
+	err = do_ne_probe(dev);
+	if (err)
+		goto out;
+	err = register_netdev(dev);
+	if (err)
+		goto out1;
+	return dev;
+out1:
+	cleanup_card(dev);
+out:
+	free_netdev(dev);
+	return ERR_PTR(err);
+}
+
+static int __init ne_probe_isapnp(struct net_device *dev)
+{
+	int i;
+
+	for (i = 0; isapnp_clone_list[i].vendor != 0; i++) {
+		struct pnp_dev *idev = NULL;
+
+		while ((idev = pnp_find_dev(NULL,
+					    isapnp_clone_list[i].vendor,
+					    isapnp_clone_list[i].function,
+					    idev))) {
+			/* Avoid already found cards from previous calls */
+			if (pnp_device_attach(idev) < 0)
+				continue;
+			if (pnp_activate_dev(idev) < 0) {
+			      	pnp_device_detach(idev);
+			      	continue;
+			}
+			/* if no io and irq, search for next */
+			if (!pnp_port_valid(idev, 0) || !pnp_irq_valid(idev, 0)) {
+				pnp_device_detach(idev);
+				continue;
+			}
+			/* found it */
+			dev->base_addr = pnp_port_start(idev, 0);
+			dev->irq = pnp_irq(idev, 0);
+			printk(KERN_INFO "ne.c: ISAPnP reports %s at i/o %#lx, irq %d.\n",
+				(char *) isapnp_clone_list[i].driver_data,
+				dev->base_addr, dev->irq);
+			if (ne_probe1(dev, dev->base_addr) != 0) {	/* Shouldn't happen. */
+				printk(KERN_ERR "ne.c: Probe of ISAPnP card at %#lx failed.\n", dev->base_addr);
+				pnp_device_detach(idev);
+				return -ENXIO;
+			}
+			ei_status.priv = (unsigned long)idev;
+			break;
+		}
+		if (!idev)
+			continue;
+		return 0;
+	}
+
+	return -ENODEV;
+}
+
+static int __init ne_probe1(struct net_device *dev, int ioaddr)
+{
+	int i;
+	unsigned char SA_prom[32];
+	int wordlength = 2;
+	const char *name = NULL;
+	int start_page, stop_page;
+	int neX000, ctron, copam, bad_card;
+	int reg0, ret;
+	static unsigned version_printed;
+
+	if (!request_region(ioaddr, NE_IO_EXTENT, dev->name))
+		return -EBUSY;
+
+	reg0 = inb_p(ioaddr);
+	if (reg0 == 0xFF) {
+		ret = -ENODEV;
+		goto err_out;
+	}
+
+	/* Do a preliminary verification that we have a 8390. */
+	{
+		int regd;
+		outb_p(E8390_NODMA+E8390_PAGE1+E8390_STOP, ioaddr + E8390_CMD);
+		regd = inb_p(ioaddr + 0x0d);
+		outb_p(0xff, ioaddr + 0x0d);
+		outb_p(E8390_NODMA+E8390_PAGE0, ioaddr + E8390_CMD);
+		inb_p(ioaddr + EN0_COUNTER0); /* Clear the counter by reading. */
+		if (inb_p(ioaddr + EN0_COUNTER0) != 0) {
+			outb_p(reg0, ioaddr);
+			outb_p(regd, ioaddr + 0x0d);	/* Restore the old values. */
+			ret = -ENODEV;
+			goto err_out;
+		}
+	}
+
+	if (ei_debug  &&  version_printed++ == 0)
+		printk(KERN_INFO "%s" KERN_INFO "%s", version1, version2);
+
+	printk(KERN_INFO "NE*000 ethercard probe at %#3x:", ioaddr);
+
+	/* A user with a poor card that fails to ack the reset, or that
+	   does not have a valid 0x57,0x57 signature can still use this
+	   without having to recompile. Specifying an i/o address along
+	   with an otherwise unused dev->mem_end value of "0xBAD" will
+	   cause the driver to skip these parts of the probe. */
+
+	bad_card = ((dev->base_addr != 0) && (dev->mem_end == 0xbad));
+
+	/* Reset card. Who knows what dain-bramaged state it was left in. */
+
+	{
+		unsigned long reset_start_time = jiffies;
+
+		/* DON'T change these to inb_p/outb_p or reset will fail on clones. */
+		outb(inb(ioaddr + NE_RESET), ioaddr + NE_RESET);
+
+		while ((inb_p(ioaddr + EN0_ISR) & ENISR_RESET) == 0)
+		if (jiffies - reset_start_time > 2*HZ/100) {
+			if (bad_card) {
+				printk(" (warning: no reset ack)");
+				break;
+			} else {
+				printk(" not found (no reset ack).\n");
+				ret = -ENODEV;
+				goto err_out;
+			}
+		}
+
+		outb_p(0xff, ioaddr + EN0_ISR);		/* Ack all intr. */
+	}
+
+	/* Read the 16 bytes of station address PROM.
+	   We must first initialize registers, similar to NS8390_init(eifdev, 0).
+	   We can't reliably read the SAPROM address without this.
+	   (I learned the hard way!). */
+	{
+		struct {unsigned char value, offset; } program_seq[] =
+		{
+			{E8390_NODMA+E8390_PAGE0+E8390_STOP, E8390_CMD}, /* Select page 0*/
+			{0x48,	EN0_DCFG},	/* Set byte-wide (0x48) access. */
+			{0x00,	EN0_RCNTLO},	/* Clear the count regs. */
+			{0x00,	EN0_RCNTHI},
+			{0x00,	EN0_IMR},	/* Mask completion irq. */
+			{0xFF,	EN0_ISR},
+			{E8390_RXOFF, EN0_RXCR},	/* 0x20  Set to monitor */
+			{E8390_TXOFF, EN0_TXCR},	/* 0x02  and loopback mode. */
+			{32,	EN0_RCNTLO},
+			{0x00,	EN0_RCNTHI},
+			{0x00,	EN0_RSARLO},	/* DMA starting at 0x0000. */
+			{0x00,	EN0_RSARHI},
+			{E8390_RREAD+E8390_START, E8390_CMD},
+		};
+
+		for (i = 0; i < sizeof(program_seq)/sizeof(program_seq[0]); i++)
+			outb_p(program_seq[i].value, ioaddr + program_seq[i].offset);
+
+	}
+	for(i = 0; i < 32 /*sizeof(SA_prom)*/; i+=2) {
+		SA_prom[i] = inb(ioaddr + NE_DATAPORT);
+		SA_prom[i+1] = inb(ioaddr + NE_DATAPORT);
+		if (SA_prom[i] != SA_prom[i+1])
+			wordlength = 1;
+	}
+
+	if (wordlength == 2)
+	{
+		for (i = 0; i < 16; i++)
+			SA_prom[i] = SA_prom[i+i];
+		/* We must set the 8390 for word mode. */
+#ifdef CONFIG_PLAT_MAPPI
+		outb_p(0x4b, ioaddr + EN0_DCFG);
+#elif CONFIG_PLAT_OAKS32R
+		outb_p(0x48, ioaddr + EN0_DCFG);
+#else
+		outb_p(0x49, ioaddr + EN0_DCFG);
+#endif
+		start_page = NESM_START_PG;
+		stop_page = NESM_STOP_PG;
+	} else {
+		start_page = NE1SM_START_PG;
+		stop_page = NE1SM_STOP_PG;
+	}
+
+#if  defined(CONFIG_PLAT_MAPPI) || defined(CONFIG_PLAT_OAKS32R)
+	neX000 = ((SA_prom[14] == 0x57  &&  SA_prom[15] == 0x57) 
+		|| (SA_prom[14] == 0x42 && SA_prom[15] == 0x42));
+#else
+	neX000 = (SA_prom[14] == 0x57  &&  SA_prom[15] == 0x57);
+#endif
+	ctron =  (SA_prom[0] == 0x00 && SA_prom[1] == 0x00 && SA_prom[2] == 0x1d);
+	copam =  (SA_prom[14] == 0x49 && SA_prom[15] == 0x00);
+
+	/* Set up the rest of the parameters. */
+	if (neX000 || bad_card || copam) {
+		name = (wordlength == 2) ? "NE2000" : "NE1000";
+	}
+	else if (ctron)
+	{
+		name = (wordlength == 2) ? "Ctron-8" : "Ctron-16";
+		start_page = 0x01;
+		stop_page = (wordlength == 2) ? 0x40 : 0x20;
+	}
+	else
+	{
+#ifdef SUPPORT_NE_BAD_CLONES
+		/* Ack!  Well, there might be a *bad* NE*000 clone there.
+		   Check for total bogus addresses. */
+		for (i = 0; bad_clone_list[i].name8; i++)
+		{
+			if (SA_prom[0] == bad_clone_list[i].SAprefix[0] &&
+				SA_prom[1] == bad_clone_list[i].SAprefix[1] &&
+				SA_prom[2] == bad_clone_list[i].SAprefix[2])
+			{
+				if (wordlength == 2)
+				{
+					name = bad_clone_list[i].name16;
+				} else {
+					name = bad_clone_list[i].name8;
+				}
+				break;
+			}
+		}
+		if (bad_clone_list[i].name8 == NULL)
+		{
+			printk(" not found (invalid signature %2.2x %2.2x).\n",
+				SA_prom[14], SA_prom[15]);
+			ret = -ENXIO;
+			goto err_out;
+		}
+#else
+		printk(" not found.\n");
+		ret = -ENXIO;
+		goto err_out;
+#endif
+	}
+
+	if (dev->irq < 2)
+	{
+		unsigned long cookie = probe_irq_on();
+		outb_p(0x50, ioaddr + EN0_IMR);	/* Enable one interrupt. */
+		outb_p(0x00, ioaddr + EN0_RCNTLO);
+		outb_p(0x00, ioaddr + EN0_RCNTHI);
+		outb_p(E8390_RREAD+E8390_START, ioaddr); /* Trigger it... */
+		mdelay(10);		/* wait 10ms for interrupt to propagate */
+		outb_p(0x00, ioaddr + EN0_IMR); 		/* Mask it again. */
+		dev->irq = probe_irq_off(cookie);
+		if (ei_debug > 2)
+			printk(" autoirq is %d\n", dev->irq);
+	} else if (dev->irq == 2)
+		/* Fixup for users that don't know that IRQ 2 is really IRQ 9,
+		   or don't know which one to set. */
+		dev->irq = 9;
+
+	if (! dev->irq) {
+		printk(" failed to detect IRQ line.\n");
+		ret = -EAGAIN;
+		goto err_out;
+	}
+
+	/* Snarf the interrupt now.  There's no point in waiting since we cannot
+	   share and the board will usually be enabled. */
+	ret = request_irq(dev->irq, ei_interrupt, 0, name, dev);
+	if (ret) {
+		printk (" unable to get IRQ %d (errno=%d).\n", dev->irq, ret);
+		goto err_out;
+	}
+
+	dev->base_addr = ioaddr;
+
+#ifdef CONFIG_PLAT_MAPPI
+	outb_p(E8390_NODMA + E8390_PAGE1 + E8390_STOP, 
+		ioaddr + E8390_CMD); /* 0x61 */
+	for (i = 0 ; i < ETHER_ADDR_LEN ; i++) {
+		dev->dev_addr[i] = SA_prom[i] 
+			= inb_p(ioaddr + EN1_PHYS_SHIFT(i));
+		printk(" %2.2x", SA_prom[i]);
+	}
+#else
+	for(i = 0; i < ETHER_ADDR_LEN; i++) {
+		printk(" %2.2x", SA_prom[i]);
+		dev->dev_addr[i] = SA_prom[i];
+	}
+#endif
+
+	printk("\n%s: %s found at %#x, using IRQ %d.\n",
+		dev->name, name, ioaddr, dev->irq);
+
+	ei_status.name = name;
+	ei_status.tx_start_page = start_page;
+	ei_status.stop_page = stop_page;
+#ifdef CONFIG_PLAT_OAKS32R
+	ei_status.word16 = 0;
+#else
+	ei_status.word16 = (wordlength == 2);
+#endif
+
+	ei_status.rx_start_page = start_page + TX_PAGES;
+#ifdef PACKETBUF_MEMSIZE
+	 /* Allow the packet buffer size to be overridden by know-it-alls. */
+	ei_status.stop_page = ei_status.tx_start_page + PACKETBUF_MEMSIZE;
+#endif
+
+	ei_status.reset_8390 = &ne_reset_8390;
+	ei_status.block_input = &ne_block_input;
+	ei_status.block_output = &ne_block_output;
+	ei_status.get_8390_hdr = &ne_get_8390_hdr;
+	ei_status.priv = 0;
+	dev->open = &ne_open;
+	dev->stop = &ne_close;
+	NS8390_init(dev, 0);
+	return 0;
+
+err_out:
+	release_region(ioaddr, NE_IO_EXTENT);
+	return ret;
+}
+
+static int ne_open(struct net_device *dev)
+{
+	ei_open(dev);
+	return 0;
+}
+
+static int ne_close(struct net_device *dev)
+{
+	if (ei_debug > 1)
+		printk(KERN_DEBUG "%s: Shutting down ethercard.\n", dev->name);
+	ei_close(dev);
+	return 0;
+}
+
+/* Hard reset the card.  This used to pause for the same period that a
+   8390 reset command required, but that shouldn't be necessary. */
+
+static void ne_reset_8390(struct net_device *dev)
+{
+	unsigned long reset_start_time = jiffies;
+
+	if (ei_debug > 1)
+		printk(KERN_DEBUG "resetting the 8390 t=%ld...", jiffies);
+
+	/* DON'T change these to inb_p/outb_p or reset will fail on clones. */
+	outb(inb(NE_BASE + NE_RESET), NE_BASE + NE_RESET);
+
+	ei_status.txing = 0;
+	ei_status.dmaing = 0;
+
+	/* This check _should_not_ be necessary, omit eventually. */
+	while ((inb_p(NE_BASE+EN0_ISR) & ENISR_RESET) == 0)
+		if (jiffies - reset_start_time > 2*HZ/100) {
+			printk(KERN_WARNING "%s: ne_reset_8390() did not complete.\n", dev->name);
+			break;
+		}
+	outb_p(ENISR_RESET, NE_BASE + EN0_ISR);	/* Ack intr. */
+}
+
+/* Grab the 8390 specific header. Similar to the block_input routine, but
+   we don't need to be concerned with ring wrap as the header will be at
+   the start of a page, so we optimize accordingly. */
+
+static void ne_get_8390_hdr(struct net_device *dev, struct e8390_pkt_hdr *hdr, int ring_page)
+{
+	int nic_base = dev->base_addr;
+
+	/* This *shouldn't* happen. If it does, it's the last thing you'll see */
+
+	if (ei_status.dmaing)
+	{
+		printk(KERN_EMERG "%s: DMAing conflict in ne_get_8390_hdr "
+			"[DMAstat:%d][irqlock:%d].\n",
+			dev->name, ei_status.dmaing, ei_status.irqlock);
+		return;
+	}
+
+	ei_status.dmaing |= 0x01;
+	outb_p(E8390_NODMA+E8390_PAGE0+E8390_START, nic_base+ NE_CMD);
+	outb_p(sizeof(struct e8390_pkt_hdr), nic_base + EN0_RCNTLO);
+	outb_p(0, nic_base + EN0_RCNTHI);
+	outb_p(0, nic_base + EN0_RSARLO);		/* On page boundary */
+	outb_p(ring_page, nic_base + EN0_RSARHI);
+	outb_p(E8390_RREAD+E8390_START, nic_base + NE_CMD);
+
+	if (ei_status.word16)
+		insw(NE_BASE + NE_DATAPORT, hdr, sizeof(struct e8390_pkt_hdr)>>1);
+	else
+		insb(NE_BASE + NE_DATAPORT, hdr, sizeof(struct e8390_pkt_hdr));
+
+	outb_p(ENISR_RDC, nic_base + EN0_ISR);	/* Ack intr. */
+	ei_status.dmaing &= ~0x01;
+
+	le16_to_cpus(&hdr->count);
+}
+
+/* Block input and output, similar to the Crynwr packet driver.  If you
+   are porting to a new ethercard, look at the packet driver source for hints.
+   The NEx000 doesn't share the on-board packet memory -- you have to put
+   the packet out through the "remote DMA" dataport using outb. */
+
+static void ne_block_input(struct net_device *dev, int count, struct sk_buff *skb, int ring_offset)
+{
+#ifdef NE_SANITY_CHECK
+	int xfer_count = count;
+#endif
+	int nic_base = dev->base_addr;
+	char *buf = skb->data;
+
+	/* This *shouldn't* happen. If it does, it's the last thing you'll see */
+	if (ei_status.dmaing)
+	{
+		printk(KERN_EMERG "%s: DMAing conflict in ne_block_input "
+			"[DMAstat:%d][irqlock:%d].\n",
+			dev->name, ei_status.dmaing, ei_status.irqlock);
+		return;
+	}
+	ei_status.dmaing |= 0x01;
+	outb_p(E8390_NODMA+E8390_PAGE0+E8390_START, nic_base+ NE_CMD);
+	outb_p(count & 0xff, nic_base + EN0_RCNTLO);
+	outb_p(count >> 8, nic_base + EN0_RCNTHI);
+	outb_p(ring_offset & 0xff, nic_base + EN0_RSARLO);
+	outb_p(ring_offset >> 8, nic_base + EN0_RSARHI);
+	outb_p(E8390_RREAD+E8390_START, nic_base + NE_CMD);
+	if (ei_status.word16)
+	{
+		insw(NE_BASE + NE_DATAPORT,buf,count>>1);
+		if (count & 0x01)
+		{
+			buf[count-1] = inb(NE_BASE + NE_DATAPORT);
+#ifdef NE_SANITY_CHECK
+			xfer_count++;
+#endif
+		}
+	} else {
+		insb(NE_BASE + NE_DATAPORT, buf, count);
+	}
+
+#ifdef NE_SANITY_CHECK
+	/* This was for the ALPHA version only, but enough people have
+	   been encountering problems so it is still here.  If you see
+	   this message you either 1) have a slightly incompatible clone
+	   or 2) have noise/speed problems with your bus. */
+
+	if (ei_debug > 1)
+	{
+		/* DMA termination address check... */
+		int addr, tries = 20;
+		do {
+			/* DON'T check for 'inb_p(EN0_ISR) & ENISR_RDC' here
+			   -- it's broken for Rx on some cards! */
+			int high = inb_p(nic_base + EN0_RSARHI);
+			int low = inb_p(nic_base + EN0_RSARLO);
+			addr = (high << 8) + low;
+			if (((ring_offset + xfer_count) & 0xff) == low)
+				break;
+		} while (--tries > 0);
+	 	if (tries <= 0)
+			printk(KERN_WARNING "%s: RX transfer address mismatch,"
+				"%#4.4x (expected) vs. %#4.4x (actual).\n",
+				dev->name, ring_offset + xfer_count, addr);
+	}
+#endif
+	outb_p(ENISR_RDC, nic_base + EN0_ISR);	/* Ack intr. */
+	ei_status.dmaing &= ~0x01;
+}
+
+static void ne_block_output(struct net_device *dev, int count,
+		const unsigned char *buf, const int start_page)
+{
+	int nic_base = NE_BASE;
+	unsigned long dma_start;
+#ifdef NE_SANITY_CHECK
+	int retries = 0;
+#endif
+
+	/* Round the count up for word writes.  Do we need to do this?
+	   What effect will an odd byte count have on the 8390?
+	   I should check someday. */
+
+	if (ei_status.word16 && (count & 0x01))
+		count++;
+
+	/* This *shouldn't* happen. If it does, it's the last thing you'll see */
+	if (ei_status.dmaing)
+	{
+		printk(KERN_EMERG "%s: DMAing conflict in ne_block_output."
+			"[DMAstat:%d][irqlock:%d]\n",
+			dev->name, ei_status.dmaing, ei_status.irqlock);
+		return;
+	}
+	ei_status.dmaing |= 0x01;
+	/* We should already be in page 0, but to be safe... */
+	outb_p(E8390_PAGE0+E8390_START+E8390_NODMA, nic_base + NE_CMD);
+
+#ifdef NE_SANITY_CHECK
+retry:
+#endif
+
+#ifdef NE8390_RW_BUGFIX
+	/* Handle the read-before-write bug the same way as the
+	   Crynwr packet driver -- the NatSemi method doesn't work.
+	   Actually this doesn't always work either, but if you have
+	   problems with your NEx000 this is better than nothing! */
+
+	outb_p(0x42, nic_base + EN0_RCNTLO);
+	outb_p(0x00,   nic_base + EN0_RCNTHI);
+	outb_p(0x42, nic_base + EN0_RSARLO);
+	outb_p(0x00, nic_base + EN0_RSARHI);
+	outb_p(E8390_RREAD+E8390_START, nic_base + NE_CMD);
+	/* Make certain that the dummy read has occurred. */
+	udelay(6);
+#endif
+
+	outb_p(ENISR_RDC, nic_base + EN0_ISR);
+
+	/* Now the normal output. */
+	outb_p(count & 0xff, nic_base + EN0_RCNTLO);
+	outb_p(count >> 8,   nic_base + EN0_RCNTHI);
+	outb_p(0x00, nic_base + EN0_RSARLO);
+	outb_p(start_page, nic_base + EN0_RSARHI);
+
+	outb_p(E8390_RWRITE+E8390_START, nic_base + NE_CMD);
+	if (ei_status.word16) {
+		outsw(NE_BASE + NE_DATAPORT, buf, count>>1);
+	} else {
+		outsb(NE_BASE + NE_DATAPORT, buf, count);
+	}
+
+	dma_start = jiffies;
+
+#ifdef NE_SANITY_CHECK
+	/* This was for the ALPHA version only, but enough people have
+	   been encountering problems so it is still here. */
+
+	if (ei_debug > 1)
+	{
+		/* DMA termination address check... */
+		int addr, tries = 20;
+		do {
+			int high = inb_p(nic_base + EN0_RSARHI);
+			int low = inb_p(nic_base + EN0_RSARLO);
+			addr = (high << 8) + low;
+			if ((start_page << 8) + count == addr)
+				break;
+		} while (--tries > 0);
+
+		if (tries <= 0)
+		{
+			printk(KERN_WARNING "%s: Tx packet transfer address mismatch,"
+				"%#4.4x (expected) vs. %#4.4x (actual).\n",
+				dev->name, (start_page << 8) + count, addr);
+			if (retries++ == 0)
+				goto retry;
+		}
+	}
+#endif
+
+	while ((inb_p(nic_base + EN0_ISR) & ENISR_RDC) == 0)
+		if (jiffies - dma_start > 2*HZ/100) {		/* 20ms */
+			printk(KERN_WARNING "%s: timeout waiting for Tx RDC.\n", dev->name);
+			ne_reset_8390(dev);
+			NS8390_init(dev,1);
+			break;
+		}
+
+	outb_p(ENISR_RDC, nic_base + EN0_ISR);	/* Ack intr. */
+	ei_status.dmaing &= ~0x01;
+	return;
+}
+
+
+#ifdef MODULE
+#define MAX_NE_CARDS	4	/* Max number of NE cards per module */
+static struct net_device *dev_ne[MAX_NE_CARDS];
+static int io[MAX_NE_CARDS];
+static int irq[MAX_NE_CARDS];
+static int bad[MAX_NE_CARDS];	/* 0xbad = bad sig or no reset ack */
+
+MODULE_PARM(io, "1-" __MODULE_STRING(MAX_NE_CARDS) "i");
+MODULE_PARM(irq, "1-" __MODULE_STRING(MAX_NE_CARDS) "i");
+MODULE_PARM(bad, "1-" __MODULE_STRING(MAX_NE_CARDS) "i");
+MODULE_PARM_DESC(io, "I/O base address(es),required");
+MODULE_PARM_DESC(irq, "IRQ number(s)");
+MODULE_PARM_DESC(bad, "Accept card(s) with bad signatures");
+MODULE_DESCRIPTION("NE1000/NE2000 ISA/PnP Ethernet driver");
+MODULE_LICENSE("GPL");
+
+/* This is set up so that no ISA autoprobe takes place. We can't guarantee
+that the ne2k probe is the last 8390 based probe to take place (as it
+is at boot) and so the probe will get confused by any other 8390 cards.
+ISA device autoprobes on a running machine are not recommended anyway. */
+
+int init_module(void)
+{
+	int this_dev, found = 0;
+
+	for (this_dev = 0; this_dev < MAX_NE_CARDS; this_dev++) {
+		struct net_device *dev = alloc_ei_netdev();
+		if (!dev)
+			break;
+		dev->irq = irq[this_dev];
+		dev->mem_end = bad[this_dev];
+		dev->base_addr = io[this_dev];
+		if (do_ne_probe(dev) == 0) {
+			if (register_netdev(dev) == 0) {
+				dev_ne[found++] = dev;
+				continue;
+			}
+			cleanup_card(dev);
+		}
+		free_netdev(dev);
+		if (found)
+			break;
+		if (io[this_dev] != 0)
+			printk(KERN_WARNING "ne.c: No NE*000 card found at i/o = %#x\n", io[this_dev]);
+		else
+			printk(KERN_NOTICE "ne.c: You must supply \"io=0xNNN\" value(s) for ISA cards.\n");
+		return -ENXIO;
+	}
+	if (found)
+		return 0;
+	return -ENODEV;
+}
+
+void cleanup_module(void)
+{
+	int this_dev;
+
+	for (this_dev = 0; this_dev < MAX_NE_CARDS; this_dev++) {
+		struct net_device *dev = dev_ne[this_dev];
+		if (dev) {
+			unregister_netdev(dev);
+			cleanup_card(dev);
+			free_netdev(dev);
+		}
+	}
+}
+#endif /* MODULE */
+
+
+/*
+ * Local variables:
+ *  compile-command: "gcc -DKERNEL -Wall -O6 -fomit-frame-pointer -I/usr/src/linux/net/tcp -c ne.c"
+ *  version-control: t
+ *  kept-new-versions: 5
+ * End:
+ */
diff -ruN linux-2.6.7.org/arch/m32r/drivers/smc91111.c linux-2.6.7/arch/m32r/drivers/smc91111.c
--- linux-2.6.7.org/arch/m32r/drivers/smc91111.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/drivers/smc91111.c	2004-07-27 15:54:20.000000000 +0900
@@ -0,0 +1,3896 @@
+/*------------------------------------------------------------------------
+ . smc91111.c
+ . This is a driver for SMSC's 91C111 single-chip Ethernet device.
+ .
+ . Copyright (C) 2001 Standard Microsystems Corporation (SMSC)
+ .       Developed by Simple Network Magic Corporation (SNMC)
+ . Copyright (C) 1996 by Erik Stahlman (ES)
+ .
+ . This program is free software; you can redistribute it and/or modify
+ . it under the terms of the GNU General Public License as published by
+ . the Free Software Foundation; either version 2 of the License, or
+ . (at your option) any later version.
+ .
+ . This program is distributed in the hope that it will be useful,
+ . but WITHOUT ANY WARRANTY; without even the implied warranty of
+ . MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ . GNU General Public License for more details.
+ .
+ . You should have received a copy of the GNU General Public License
+ . along with this program; if not, write to the Free Software
+ . Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ .
+ . Information contained in this file was obtained from the LAN91C111
+ . manual from SMC.  To get a copy, if you really want one, you can find 
+ . information under www.smsc.com.
+ . 
+ .
+ . "Features" of the SMC chip:
+ .   Integrated PHY/MAC for 10/100BaseT Operation
+ .   Supports internal and external MII
+ .   Integrated 8K packet memory
+ .   EEPROM interface for configuration
+ .
+ . Arguments:
+ . 	io	= for the base address
+ .	irq	= for the IRQ
+ .	nowait	= 0 for normal wait states, 1 eliminates additional wait states
+ .
+ . author:
+ . 	Erik Stahlman				( erik@vt.edu )
+ . 	Daris A Nevil				( dnevil@snmc.com )
+ .  	Pramod B Bhardwaj   			(pramod.bhardwaj@smsc.com)
+ .
+ .
+ . Hardware multicast code from Peter Cammaert ( pc@denkart.be )
+ .
+ . Sources:
+ .    o   SMSC LAN91C111 databook (www.smsc.com)
+ .    o   smc9194.c by Erik Stahlman
+ .    o   skeleton.c by Donald Becker ( becker@cesdis.gsfc.nasa.gov )
+ .
+ . History:
+ .    09/24/01  Pramod B Bhardwaj, Added the changes for Kernel 2.4
+ .    08/21/01  Pramod B Bhardwaj Added support for RevB of LAN91C111
+ .	04/25/01  Daris A Nevil  Initial public release through SMSC
+ .	03/16/01  Daris A Nevil  Modified smc9194.c for use with LAN91C111
+ . 	01/14/03  Takeo Takahashi Support M32RUT-LAN(Rev.B)
+ . 	02/25/04  Hirokazu Takata, Hayato Fujiwara, Mamoru Sakugawa
+ .                SMP support for Linux/M32R.
+ ----------------------------------------------------------------------------*/
+#include <linux/config.h>
+#if defined(__m32r__)
+#define SMC_DEBUG 0
+#define smc_init	m32r_smc_init
+#endif
+#if defined(CONFIG_PLAT_M32700UT) || defined(CONFIG_PLAT_MAPPI2) || defined(CONFIG_PLAT_OPSPUT)
+#define NO_AUTOPROBE
+#endif
+
+// Use power-down feature of the chip
+#define POWER_DOWN	0
+
+
+static const char version[] =
+	"SMSC LAN91C111 Driver (v2.0), (Linux Kernel 2.4 + Support for Odd Byte) 09/24/01 -      by Pramod Bhardwaj (pramod.bhardwaj@smsc.com)\n\n";
+
+#ifdef MODULE
+#include <linux/module.h>
+#include <linux/version.h>
+#endif
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/fcntl.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/in.h>
+#if defined(__m32r__)
+#include <linux/slab.h>
+#else	/* Not __m32r__ */
+#include <linux/malloc.h>
+#endif
+#include <linux/string.h>
+#include <linux/init.h>
+#include <asm/bitops.h>
+#include <asm/io.h>
+#include <linux/errno.h>
+#include <linux/delay.h>
+
+#include <linux/netdevice.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+//#include <linux/kcomp.h>
+
+#include <linux/spinlock.h>
+
+#ifdef CONFIG_SYSCTL
+#include <linux/proc_fs.h>
+#include <linux/sysctl.h>
+#endif
+
+#include "smc91111.h"
+/*------------------------------------------------------------------------
+ .
+ . Configuration options, for the experienced user to change.
+ .
+ -------------------------------------------------------------------------*/
+
+/*
+ . Do you want to use 32 bit xfers?  This should work on all chips, as
+ . the chipset is designed to accommodate them.
+*/
+#if !defined(__m32r__)
+#define USE_32_BIT 1
+#endif
+
+
+/*
+ .the LAN91C111 can be at any of the following port addresses.  To change,
+ .for a slightly different card, you can add it to the array.  Keep in
+ .mind that the array must end in zero.
+*/
+static unsigned int smc_portlist[] __initdata =
+   { 0x200, 0x220, 0x240, 0x260, 0x280, 0x2A0, 0x2C0, 0x2E0,
+	 0x300, 0x320, 0x340, 0x360, 0x380, 0x3A0, 0x3C0, 0x3E0, 0};
+
+
+/*
+ . Wait time for memory to be free.  This probably shouldn't be
+ . tuned that much, as waiting for this means nothing else happens
+ . in the system
+*/
+#define MEMORY_WAIT_TIME 16
+
+/*
+ . This selects whether TX packets are sent one by one to the SMC91x internal
+ . memory ans throttled until transmission completes.  This may prevent
+ . RX overruns a litle by keeping much of the memory free for RX packets
+ . but to the expense of reduced TX throughput and increased IRQ overhead.
+ . Note this is not a cure for a too slow data bus or too high IRQ latency.
+ */
+#define THROTTLE_TX_PKTS        1
+
+/*
+ . DEBUGGING LEVELS
+ .
+ . 0 for normal operation
+ . 1 for slightly more details
+ . >2 for various levels of increasingly useless information
+ .    2 for interrupt tracking, status flags
+ .    3 for packet info
+ .    4 for complete packet dumps
+*/
+//#define SMC_DEBUG 3 // Must be defined in makefile
+
+#if (SMC_DEBUG > 2 )
+#define PRINTK3(args...) printk(args)
+#else
+#define PRINTK3(args...)
+#endif
+
+#if SMC_DEBUG > 1
+#define PRINTK2(args...) printk(args)
+#else
+#define PRINTK2(args...)
+#endif
+
+#ifdef SMC_DEBUG
+#define PRINTK(args...) printk(args)
+#else
+#define PRINTK(args...)
+#endif
+
+
+/*------------------------------------------------------------------------
+ .
+ . The internal workings of the driver.  If you are changing anything
+ . here with the SMC stuff, you should have the datasheet and know
+ . what you are doing.
+ .
+ -------------------------------------------------------------------------*/
+#define CARDNAME "LAN91C111"
+
+// Memory sizing constant
+#define LAN91C111_MEMORY_MULTIPLIER	(1024*2)
+
+/* store this information for the driver.. */
+struct smc_local {
+
+ 	// these are things that the kernel wants me to keep, so users
+	// can find out semi-useless statistics of how well the card is
+	// performing
+	struct net_device_stats stats;
+
+	// If I have to wait until memory is available to send
+	// a packet, I will store the skbuff here, until I get the
+	// desired memory.  Then, I'll send it out and free it.
+	struct sk_buff * saved_skb;
+
+ 	// This keeps track of how many packets that I have
+ 	// sent out.  When an TX_EMPTY interrupt comes, I know
+	// that all of these have been sent.
+	int	packets_waiting;
+
+	// Set to true during the auto-negotiation sequence
+	int	autoneg_active;
+
+	// Address of our PHY port
+	word	phyaddr;
+
+	// Type of PHY
+	word	phytype;
+
+	// Last contents of PHY Register 18
+	word	lastPhy18;
+
+	// Contains the current active transmission mode
+	word	tcr_cur_mode;
+
+	// Contains the current active receive mode
+	word	rcr_cur_mode;
+
+	// Contains the current active receive/phy mode
+	word	rpc_cur_mode;
+
+	/* => Pramod, Odd Byte issue */
+	// Contains the Current ChipID
+	unsigned short ChipID;
+
+	//Contains the Current ChipRevision
+	unsigned short ChipRev;
+	/* <= Pramod, Odd Byte issue */
+
+        spinlock_t lock;
+
+#ifdef CONFIG_SYSCTL
+
+	// Root directory /proc/sys/dev
+	// Second entry must be null to terminate the table
+	ctl_table root_table[2];
+
+	// Directory for this device /proc/sys/dev/ethX
+	// Again the second entry must be zero to terminate
+	ctl_table eth_table[2];
+
+	// This is the parameters (file) table
+	ctl_table param_table[CTL_SMC_LAST_ENTRY];
+
+	// Saves the sysctl header returned by register_sysctl_table()
+	// we send this to unregister_sysctl_table()
+	struct ctl_table_header *sysctl_header;
+
+	// Parameter variables (files) go here
+	char ctl_info[1024];
+	int ctl_swfdup;
+	int ctl_ephloop;
+	int ctl_miiop;
+	int ctl_autoneg;
+	int ctl_rfduplx;
+	int ctl_rspeed;
+	int ctl_afduplx;
+	int ctl_aspeed;
+	int ctl_lnkfail;
+	int ctl_forcol;
+	int ctl_filtcar;
+	int ctl_freemem;
+	int ctl_totmem;
+	int ctl_leda;
+	int ctl_ledb;
+	int ctl_chiprev;
+#ifdef SMC_DEBUG
+	int ctl_reg_bsr;
+	int ctl_reg_tcr;
+	int ctl_reg_esr;
+	int ctl_reg_rcr;
+	int ctl_reg_ctrr;
+	int ctl_reg_mir;
+	int ctl_reg_rpcr;
+	int ctl_reg_cfgr;
+	int ctl_reg_bar;
+	int ctl_reg_iar0;
+	int ctl_reg_iar1;
+	int ctl_reg_iar2;
+	int ctl_reg_gpr;
+	int ctl_reg_ctlr;
+	int ctl_reg_mcr;
+	int ctl_reg_pnr;
+	int ctl_reg_fpr;
+	int ctl_reg_ptr;
+	int ctl_reg_dr;
+	int ctl_reg_isr;
+	int ctl_reg_mtr1;
+	int ctl_reg_mtr2;
+	int ctl_reg_mtr3;
+	int ctl_reg_mtr4;
+	int ctl_reg_miir;
+	int ctl_reg_revr;
+	int ctl_reg_ercvr;
+	int ctl_reg_extr;
+	int ctl_phy_ctrl;
+	int ctl_phy_stat;
+	int ctl_phy_id1;
+	int ctl_phy_id2;
+	int ctl_phy_adc;
+	int ctl_phy_remc;
+	int ctl_phy_cfg1;
+	int ctl_phy_cfg2;
+	int ctl_phy_int;
+	int ctl_phy_mask;
+#endif // SMC_DEBUG
+
+
+#endif // CONFIG_SYSCTL
+
+};
+
+
+/*-----------------------------------------------------------------
+ .
+ .  The driver can be entered at any of the following entry points.
+ .
+ .------------------------------------------------------------------  */
+
+/*
+ . This is called by  register_netdev().  It is responsible for
+ . checking the portlist for the SMC9000 series chipset.  If it finds
+ . one, then it will initialize the device, find the hardware information,
+ . and sets up the appropriate device parameters.
+ . NOTE: Interrupts are *OFF* when this procedure is called.
+ .
+ . NB:This shouldn't be static since it is referred to externally.
+*/
+struct net_device *smc_init(int unit);
+
+/*
+ . This is called by  unregister_netdev().  It is responsible for
+ . cleaning up before the driver is finally unregistered and discarded.
+*/
+void smc_destructor(struct net_device *dev);
+
+/*
+ . The kernel calls this function when someone wants to use the net_device,
+ . typically 'ifconfig ethX up'.
+*/
+static int smc_open(struct net_device *dev);
+
+/*
+ . This is called by the kernel to send a packet out into the net.  it's
+ . responsible for doing a best-effort send, but if it's simply not possible
+ . to send it, the packet gets dropped.
+*/
+static void smc_timeout (struct net_device *dev);
+/*
+ . This is called by the kernel in response to 'ifconfig ethX down'.  It
+ . is responsible for cleaning up everything that the open routine
+ . does, and maybe putting the card into a powerdown state.
+*/
+static int smc_close(struct net_device *dev);
+
+/*
+ . This routine allows the proc file system to query the driver's
+ . statistics.
+*/
+static struct net_device_stats * smc_query_statistics( struct net_device *dev);
+
+/*
+ . Finally, a call to set promiscuous mode ( for TCPDUMP and related
+ . programs ) and multicast modes.
+*/
+static void smc_set_multicast_list(struct net_device *dev);
+
+/*
+ . Configures the PHY through the MII Management interface
+*/
+static void smc_phy_configure(struct net_device* dev);
+
+/*---------------------------------------------------------------
+ .
+ . Interrupt level calls..
+ .
+ ----------------------------------------------------------------*/
+
+/*
+ . Handles the actual interrupt
+*/
+static irqreturn_t smc_interrupt(int irq, void *, struct pt_regs *regs);
+/*
+ . This is a separate procedure to handle the receipt of a packet, to
+ . leave the interrupt code looking slightly cleaner
+*/
+inline static void smc_rcv( struct net_device *dev );
+/*
+ . This handles a TX interrupt, which is only called when an error
+ . relating to a packet is sent.
+*/
+inline static void smc_tx( struct net_device * dev );
+
+/*
+ . This handles interrupts generated from PHY register 18
+*/
+static void smc_phy_interrupt(struct net_device* dev);
+
+/*
+ ------------------------------------------------------------
+ .
+ . Internal routines
+ .
+ ------------------------------------------------------------
+*/
+
+/*
+ . Test if a given location contains a chip, trying to cause as
+ . little damage as possible if it's not a SMC chip.
+*/
+static int smc_probe(struct net_device *dev, int ioaddr);
+
+/*
+ . A rather simple routine to print out a packet for debugging purposes.
+*/
+#if SMC_DEBUG > 2
+static void print_packet( byte *, int );
+#endif
+
+#define tx_done(dev) 1
+
+/* this is called to actually send the packet to the chip */
+static void smc_hardware_send_packet( struct net_device * dev );
+
+/* Since I am not sure if I will have enough room in the chip's ram
+ . to store the packet, I call this routine, which either sends it
+ . now, or generates an interrupt when the card is ready for the
+ . packet */
+static int  smc_wait_to_send_packet( struct sk_buff * skb, struct net_device *dev );
+
+/* this does a soft reset on the device */
+static void smc_reset( struct net_device* dev );
+
+/* Enable Interrupts, Receive, and Transmit */
+static void smc_enable( struct net_device *dev );
+
+/* this puts the device in an inactive state */
+static void smc_shutdown( int ioaddr );
+
+#ifndef NO_AUTOPROBE
+/* This routine will find the IRQ of the driver if one is not
+ . specified in the input to the device.  */
+static int smc_findirq( int ioaddr );
+#endif
+
+/*
+  this routine will set the hardware multicast table to the specified
+  values given it by the higher level routines
+*/
+static void smc_setmulticast( int ioaddr, int count, struct dev_mc_list *  );
+static int crc32( char *, int );
+
+/* Routines to Read and Write the PHY Registers across the
+   MII Management Interface
+*/
+
+static word smc_read_phy_register(int ioaddr, byte phyaddr, byte phyreg);
+static void smc_write_phy_register(int ioaddr, byte phyaddr, byte phyreg, word phydata);
+
+/* Initilizes our device's sysctl proc filesystem */
+
+#ifdef CONFIG_SYSCTL
+static void smc_sysctl_register(struct net_device *);
+static void smc_sysctl_unregister(struct net_device *);
+#endif /* CONFIG_SYSCTL */ 
+
+/*
+ . Function: smc_reset( struct device* dev )
+ . Purpose:
+ .  	This sets the SMC91111 chip to its normal state, hopefully from whatever
+ . 	mess that any other DOS driver has put it in.
+ .
+ . Maybe I should reset more registers to defaults in here?  SOFTRST  should
+ . do that for me.
+ .
+ . Method:
+ .	1.  send a SOFT RESET
+ .	2.  wait for it to finish
+ .	3.  enable autorelease mode
+ .	4.  reset the memory management unit
+ .	5.  clear all interrupts
+ .
+*/
+static void smc_reset( struct net_device* dev )
+{
+	//struct smc_local *lp 	= (struct smc_local *)dev->priv;
+	int	ioaddr = dev->base_addr;
+
+	PRINTK2("%s:smc_reset\n", dev->name);
+
+	/* This resets the registers mostly to defaults, but doesn't
+	   affect EEPROM.  That seems unnecessary */
+	SMC_SELECT_BANK( 0 );
+	outw( RCR_SOFTRST, ioaddr + RCR_REG );
+
+	/* Setup the Configuration Register */
+	/* This is necessary because the CONFIG_REG is not affected */
+	/* by a soft reset */
+
+	SMC_SELECT_BANK( 1 );
+	outw( CONFIG_DEFAULT, ioaddr + CONFIG_REG);
+
+	/* Setup for fast accesses if requested */
+	/* If the card/system can't handle it then there will */
+	/* be no recovery except for a hard reset or power cycle */
+
+	if (dev->dma)
+		outw( inw( ioaddr + CONFIG_REG ) | CONFIG_NO_WAIT,
+			ioaddr + CONFIG_REG );
+
+#ifdef POWER_DOWN
+	/* Release from possible power-down state */
+	/* Configuration register is not affected by Soft Reset */
+	SMC_SELECT_BANK( 1 );
+	outw( inw( ioaddr + CONFIG_REG ) | CONFIG_EPH_POWER_EN,
+		ioaddr + CONFIG_REG  );
+#endif
+
+	SMC_SELECT_BANK( 0 );
+
+	/* this should pause enough for the chip to be happy */
+	mdelay(10);
+
+	/* Disable transmit and receive functionality */
+	outw( RCR_CLEAR, ioaddr + RCR_REG );
+	outw( TCR_CLEAR, ioaddr + TCR_REG );
+
+	/* set the control register to automatically
+	   release successfully transmitted packets, to make the best
+	   use out of our limited memory */
+	SMC_SELECT_BANK( 1 );
+#if ! THROTTLE_TX_PKTS
+	outw( inw( ioaddr + CTL_REG ) | CTL_AUTO_RELEASE , ioaddr + CTL_REG );
+#else
+	outw( inw( ioaddr + CTL_REG ) & ~CTL_AUTO_RELEASE , ioaddr + CTL_REG );
+#endif
+
+	/* Reset the MMU */
+	SMC_SELECT_BANK( 2 );
+	outw( MC_RESET, ioaddr + MMU_CMD_REG );
+
+	/* Note:  It doesn't seem that waiting for the MMU busy is needed here,
+	   but this is a place where future chipsets _COULD_ break.  Be wary
+ 	   of issuing another MMU command right after this */
+
+	/* Disable all interrupts */
+	outb( 0, ioaddr + IM_REG );
+}
+
+/*
+ . Function: smc_enable
+ . Purpose: let the chip talk to the outside work
+ . Method:
+ .	1.  Enable the transmitter
+ .	2.  Enable the receiver
+ .	3.  Enable interrupts
+*/
+static void smc_enable( struct net_device *dev )
+{
+	unsigned short ioaddr 	= dev->base_addr;
+	struct smc_local *lp 	= (struct smc_local *)dev->priv;
+
+	PRINTK2("%s:smc_enable\n", dev->name);
+
+	SMC_SELECT_BANK( 0 );
+	/* see the header file for options in TCR/RCR DEFAULT*/
+	outw( lp->tcr_cur_mode, ioaddr + TCR_REG );
+	outw( lp->rcr_cur_mode, ioaddr + RCR_REG );
+
+	/* now, enable interrupts */
+	SMC_SELECT_BANK( 2 );
+	outb( SMC_INTERRUPT_MASK, ioaddr + IM_REG );
+}
+
+/*
+ . Function: smc_shutdown
+ . Purpose:  closes down the SMC91xxx chip.
+ . Method:
+ .	1. zero the interrupt mask
+ .	2. clear the enable receive flag
+ .	3. clear the enable xmit flags
+ .
+ . TODO:
+ .   (1) maybe utilize power down mode.
+ .	Why not yet?  Because while the chip will go into power down mode,
+ .	the manual says that it will wake up in response to any I/O requests
+ .	in the register space.   Empirical results do not show this working.
+*/
+static void smc_shutdown( int ioaddr )
+{
+	PRINTK2("CARDNAME:smc_shutdown\n");
+
+	/* no more interrupts for me */
+	SMC_SELECT_BANK( 2 );
+	outb( 0, ioaddr + IM_REG );
+
+	/* and tell the card to stay away from that nasty outside world */
+	SMC_SELECT_BANK( 0 );
+	outb( RCR_CLEAR, ioaddr + RCR_REG );
+	outb( TCR_CLEAR, ioaddr + TCR_REG );
+
+#ifdef POWER_DOWN
+	/* finally, shut the chip down */
+	SMC_SELECT_BANK( 1 );
+	outw( inw( ioaddr + CONFIG_REG ) & ~CONFIG_EPH_POWER_EN,
+		ioaddr + CONFIG_REG  );
+#endif
+}
+
+
+/*
+ . Function: smc_setmulticast( int ioaddr, int count, dev_mc_list * adds )
+ . Purpose:
+ .    This sets the internal hardware table to filter out unwanted multicast
+ .    packets before they take up memory.
+ .
+ .    The SMC chip uses a hash table where the high 6 bits of the CRC of
+ .    address are the offset into the table.  If that bit is 1, then the
+ .    multicast packet is accepted.  Otherwise, it's dropped silently.
+ .
+ .    To use the 6 bits as an offset into the table, the high 3 bits are the
+ .    number of the 8 bit register, while the low 3 bits are the bit within
+ .    that register.
+ .
+ . This routine is based very heavily on the one provided by Peter Cammaert.
+*/
+
+
+static void smc_setmulticast( int ioaddr, int count, struct dev_mc_list * addrs ) {
+	int			i;
+	unsigned char		multicast_table[ 8 ];
+	struct dev_mc_list	* cur_addr;
+	/* table for flipping the order of 3 bits */
+	unsigned char invert3[] = { 0, 4, 2, 6, 1, 5, 3, 7 };
+
+	PRINTK2("CARDNAME:smc_setmulticast\n");
+
+	/* start with a table of all zeros: reject all */
+	memset( multicast_table, 0, sizeof( multicast_table ) );
+
+	cur_addr = addrs;
+	for ( i = 0; i < count ; i ++, cur_addr = cur_addr->next  ) {
+		int position;
+
+		/* do we have a pointer here? */
+		if ( !cur_addr )
+			break;
+		/* make sure this is a multicast address - shouldn't this
+		   be a given if we have it here ? */
+		if ( !( *cur_addr->dmi_addr & 1 ) )
+			continue;
+
+		/* only use the low order bits */
+		position = crc32( cur_addr->dmi_addr, 6 ) & 0x3f;
+
+		/* do some messy swapping to put the bit in the right spot */
+		multicast_table[invert3[position&7]] |=
+					(1<<invert3[(position>>3)&7]);
+
+	}
+	/* now, the table can be loaded into the chipset */
+	SMC_SELECT_BANK( 3 );
+
+	for ( i = 0; i < 8 ; i++ ) {
+		outb( multicast_table[i], ioaddr + MCAST_REG1 + i );
+	}
+}
+
+/*
+  Finds the CRC32 of a set of bytes.
+  Again, from Peter Cammaert's code.
+*/
+static int crc32( char * s, int length ) {
+	/* indices */
+	int perByte;
+	int perBit;
+	/* crc polynomial for Ethernet */
+	const unsigned long poly = 0xedb88320;
+	/* crc value - preinitialized to all 1's */
+	unsigned long crc_value = 0xffffffff;
+
+	for ( perByte = 0; perByte < length; perByte ++ ) {
+		unsigned char	c;
+
+		c = *(s++);
+		for ( perBit = 0; perBit < 8; perBit++ ) {
+			crc_value = (crc_value>>1)^
+				(((crc_value^c)&0x01)?poly:0);
+			c >>= 1;
+		}
+	}
+	return	crc_value;
+}
+
+
+/*
+ . Function: smc_wait_to_send_packet( struct sk_buff * skb, struct device * )
+ . Purpose:
+ .    Attempt to allocate memory for a packet, if chip-memory is not
+ .    available, then tell the card to generate an interrupt when it
+ .    is available.
+ .
+ . Algorithm:
+ .
+ . o	if the saved_skb is not currently null, then drop this packet
+ .	on the floor.  This should never happen, because of TBUSY.
+ . o	if the saved_skb is null, then replace it with the current packet,
+ . o	See if I can sending it now.
+ . o 	(NO): Enable interrupts and let the interrupt handler deal with it.
+ . o	(YES):Send it now.
+*/
+static int smc_wait_to_send_packet( struct sk_buff * skb, struct net_device * dev )
+{
+	struct smc_local *lp 	= (struct smc_local *)dev->priv;
+	unsigned short ioaddr 	= dev->base_addr;
+	word 			length;
+	unsigned short 		numPages;
+	word			time_out;
+	word			status;
+	unsigned long flags;
+
+	PRINTK3("%s:smc_wait_to_send_packet\n", dev->name);
+
+	spin_lock_irqsave(&lp->lock, flags);
+
+	if ( lp->saved_skb) {
+		/* THIS SHOULD NEVER HAPPEN. */
+		lp->stats.tx_aborted_errors++;
+		printk("%s: Bad Craziness - sent packet while busy.\n",
+			dev->name);
+		spin_unlock_irqrestore(&lp->lock, flags);
+		return 1;
+	}
+	lp->saved_skb = skb;
+
+	length = ETH_ZLEN < skb->len ? skb->len : ETH_ZLEN;
+		
+	/*
+	** The MMU wants the number of pages to be the number of 256 bytes
+	** 'pages', minus 1 ( since a packet can't ever have 0 pages :) )
+	**
+	** The 91C111 ignores the size bits, but the code is left intact
+	** for backwards and future compatibility.
+	**
+	** Pkt size for allocating is data length +6 (for additional status
+	** words, length and ctl!)
+	**
+	** If odd size then last byte is included in this header.
+	*/
+	numPages =   ((length & 0xfffe) + 6);
+	numPages >>= 8; // Divide by 256
+
+	if (numPages > 7 ) {
+		printk("%s: Far too big packet error. \n", dev->name);
+		/* freeing the packet is a good thing here... but should
+		 . any packets of this size get down here?   */
+		dev_kfree_skb (skb);
+		lp->saved_skb = NULL;
+		/* this IS an error, but, i don't want the skb saved */
+		netif_wake_queue(dev);
+		spin_unlock_irqrestore(&lp->lock, flags);
+		return 0;
+	}
+	/* either way, a packet is waiting now */
+	lp->packets_waiting++;
+
+	/* now, try to allocate the memory */
+	SMC_SELECT_BANK( 2 );
+	outw( MC_ALLOC | numPages, ioaddr + MMU_CMD_REG );
+	/*
+ 	. Performance Hack
+	.
+ 	. wait a short amount of time.. if I can send a packet now, I send
+	. it now.  Otherwise, I enable an interrupt and wait for one to be
+	. available.
+	.
+	. I could have handled this a slightly different way, by checking to
+	. see if any memory was available in the FREE MEMORY register.  However,
+	. either way, I need to generate an allocation, and the allocation works
+	. no matter what, so I saw no point in checking free memory.
+	*/
+	time_out = MEMORY_WAIT_TIME;
+	do {
+		status = inb( ioaddr + INT_REG );
+		if ( status & IM_ALLOC_INT ) {
+			/* acknowledge the interrupt */
+			outb( IM_ALLOC_INT, ioaddr + INT_REG );
+  			break;
+		}
+   	} while ( -- time_out );
+
+   	if ( !time_out ) {
+#if defined(__m32r__)
+//		netif_stop_queue(dev); 	// 2003-07-13 by takeo
+#endif
+		/* oh well, wait until the chip finds memory later */
+		SMC_ENABLE_INT( IM_ALLOC_INT );
+
+		/* Check the status bit one more time just in case */
+		/* it snuk in between the time we last checked it */
+		/* and when we set the interrupt bit */
+		status = inb( ioaddr + INT_REG );
+		if ( !(status & IM_ALLOC_INT) ) {
+      			PRINTK2("%s: memory allocation deferred. \n",
+				dev->name);
+			/* it's deferred, but I'll handle it later */
+			spin_unlock_irqrestore(&lp->lock, flags);
+      			return 0;
+		}
+
+		/* Looks like it did sneak in, so disable */
+		/* the interrupt */
+		SMC_DISABLE_INT( IM_ALLOC_INT );
+	}
+	/* or YES! I can send the packet now.. */
+#if THROTTLE_TX_PKTS
+                netif_stop_queue(dev);
+#endif
+	smc_hardware_send_packet(dev);
+//	netif_wake_queue(dev);
+
+	spin_unlock_irqrestore(&lp->lock, flags);
+
+	return 0;
+}
+
+/*
+ . Function:  smc_hardware_send_packet(struct device * )
+ . Purpose:
+ .	This sends the actual packet to the SMC9xxx chip.
+ .
+ . Algorithm:
+ . 	First, see if a saved_skb is available.
+ .		( this should NOT be called if there is no 'saved_skb'
+ .	Now, find the packet number that the chip allocated
+ .	Point the data pointers at it in memory
+ .	Set the length word in the chip's memory
+ .	Dump the packet to chip memory
+ .	Check if a last byte is needed ( odd length packet )
+ .		if so, set the control flag right
+ . 	Tell the card to send it
+ .	Enable the transmit interrupt, so I know if it failed
+ . 	Free the kernel data if I actually sent it.
+*/
+static void smc_hardware_send_packet( struct net_device * dev )
+{
+	struct smc_local *lp = (struct smc_local *)dev->priv;
+	byte	 		packet_no;
+	struct sk_buff * 	skb = lp->saved_skb;
+	word			length;
+	unsigned short		ioaddr;
+	byte			* buf;
+
+	PRINTK3("%s:smc_hardware_send_packet\n", dev->name);
+
+	ioaddr = dev->base_addr;
+
+	if ( !skb ) {
+		PRINTK("%s: In XMIT with no packet to send \n", dev->name);
+		return;
+	}
+	length = ETH_ZLEN < skb->len ? skb->len : ETH_ZLEN;
+	buf = skb->data;
+
+	/* If I get here, I _know_ there is a packet slot waiting for me */
+	packet_no = inb( ioaddr + AR_REG );
+	if ( packet_no & AR_FAILED ) {
+		/* or isn't there?  BAD CHIP! */
+		printk(KERN_DEBUG "%s: Memory allocation failed. \n",
+			dev->name);
+		dev_kfree_skb_any (skb);
+		lp->saved_skb = NULL;
+		netif_wake_queue(dev);
+		return;
+	}
+
+	/* we have a packet address, so tell the card to use it */
+	outb( packet_no, ioaddr + PN_REG );
+
+	/* point to the beginning of the packet */
+	outw( PTR_AUTOINC , ioaddr + PTR_REG );
+
+   	PRINTK3("%s: Trying to xmit packet of length %x\n",
+		dev->name, length);
+
+#if SMC_DEBUG > 2
+	printk("Transmitting Packet\n");
+	print_packet( buf, length );
+#endif
+
+	/* send the packet length ( +6 for status, length and ctl byte )
+ 	   and the status word ( set to zeros ) */
+#ifdef USE_32_BIT
+	outl(  (length +6 ) << 16 , ioaddr + DATA_REG );
+#else
+	outw( 0, ioaddr + DATA_REG );
+	/* send the packet length ( +6 for status words, length, and ctl*/
+	outb( (length+6) & 0xFF,ioaddr + DATA_REG );
+	outb( (length+6) >> 8 , ioaddr + DATA_REG );
+#endif
+
+	/* send the actual data
+	 . I _think_ it's faster to send the longs first, and then
+	 . mop up by sending the last word.  It depends heavily
+ 	 . on alignment, at least on the 486.  Maybe it would be
+ 	 . a good idea to check which is optimal?  But that could take
+	 . almost as much time as is saved?
+	*/
+#ifdef USE_32_BIT
+	outsl(ioaddr + DATA_REG, buf,  length >> 2 );
+	if ( length & 0x2  )
+		outw(*((word *)(buf + (length & 0xFFFFFFFC))),ioaddr +DATA_REG);
+#else
+	outsw(ioaddr + DATA_REG , buf, (length ) >> 1);
+#endif // USE_32_BIT
+
+	/* Send the last byte, if there is one.   */
+	if ( (length & 1) == 0 ) {
+		outw( 0, ioaddr + DATA_REG );
+	} else {
+		outb( buf[length -1 ], ioaddr + DATA_REG );
+		outb( 0x20, ioaddr + DATA_REG); // Set odd bit in CONTROL BYTE
+	}
+
+	/* and let the chipset deal with it */
+	outw( MC_ENQUEUE , ioaddr + MMU_CMD_REG );
+
+	/* enable the interrupts */
+	SMC_ENABLE_INT( (IM_TX_INT | IM_TX_EMPTY_INT) );
+
+	PRINTK2("%s: Sent packet of length %d \n", dev->name, length);
+#if defined(__m32r__)
+	lp->stats.tx_bytes += length;
+#endif
+
+	lp->saved_skb = NULL;
+	dev_kfree_skb_any (skb);
+
+	dev->trans_start = jiffies;
+
+	/* we can send another packet */
+//	netif_wake_queue(dev);
+
+	return;
+}
+
+/*-------------------------------------------------------------------------
+ |
+ | smc_init( int unit )
+ |   Input parameters:
+ |	dev->base_addr == 0, try to find all possible locations
+ |	dev->base_addr == 1, return failure code
+ |	dev->base_addr == 2, always allocate space,  and return success
+ |	dev->base_addr == <anything else>   this is the address to check
+ |
+ |   Output:
+ |	pointer to net_device or ERR_PTR(error)
+ |
+ ---------------------------------------------------------------------------
+*/
+static int io;
+static int irq;
+static int ifport;
+
+struct net_device * __init smc_init(int unit)
+{
+	struct net_device *dev = alloc_etherdev(sizeof(struct smc_local));
+	unsigned int *port;
+	int err = 0;
+
+	if (!dev)
+		return ERR_PTR(-ENODEV);
+
+	if (unit >= 0) {
+	      sprintf(dev->name, "eth%d", unit);
+	      netdev_boot_setup_check(dev);
+	      io = dev->base_addr;
+	      irq = dev->irq;
+	}
+
+#ifdef MODULE
+	SET_MODULE_OWNER (dev);
+#endif
+	if (io > 0x1ff) {	/* Check a single specified location. */
+		err = smc_probe(dev, io);
+	} else if (io != 0) {	/* Don't probe at all. */
+		err = -ENXIO;
+	} else {
+		for (port = smc_portlist; *port; port++) {
+			if (smc_probe(dev, *port) == 0)
+				break;
+		}
+		if (!*port)
+			err = -ENODEV;
+	}
+	if (err)
+		goto out;
+	err = register_netdev(dev);
+	if (err)
+		goto out1;
+	return dev;
+out1:
+	free_irq(dev->irq, dev);
+	release_region(dev->base_addr, SMC_IO_EXTENT);
+out:
+	free_netdev(dev);
+	return ERR_PTR(err);
+}
+
+
+/*-------------------------------------------------------------------------
+ |
+ | smc_destructor( struct device * dev )
+ |   Input parameters:
+ |	dev, pointer to the device structure
+ |
+ |   Output:
+ |	None.
+ |
+ ---------------------------------------------------------------------------
+*/
+void smc_destructor(struct net_device *dev)
+{
+	PRINTK2("CARDNAME:smc_destructor\n");
+}
+
+
+#ifndef NO_AUTOPROBE
+/*----------------------------------------------------------------------
+ . smc_findirq
+ .
+ . This routine has a simple purpose -- make the SMC chip generate an
+ . interrupt, so an auto-detect routine can detect it, and find the IRQ,
+ ------------------------------------------------------------------------
+*/
+int __init smc_findirq( int ioaddr )
+{
+	int	timeout = 20;
+	unsigned long cookie;
+
+	PRINTK2("CARDNAME:smc_findirq\n");
+
+	/* I have to do a STI() here, because this is called from
+	   a routine that does an CLI during this process, making it
+	   rather difficult to get interrupts for auto detection */
+	sti();
+
+	cookie = probe_irq_on();
+
+	/*
+	 * What I try to do here is trigger an ALLOC_INT. This is done
+	 * by allocating a small chunk of memory, which will give an interrupt
+	 * when done.
+	 */
+
+
+	SMC_SELECT_BANK(2);
+	/* enable ALLOCation interrupts ONLY */
+	outb( IM_ALLOC_INT, ioaddr + IM_REG );
+
+	/*
+ 	 . Allocate 512 bytes of memory.  Note that the chip was just
+	 . reset so all the memory is available
+	*/
+	outw( MC_ALLOC | 1, ioaddr + MMU_CMD_REG );
+
+	/*
+	 . Wait until positive that the interrupt has been generated
+	*/
+	while ( timeout ) {
+		byte	int_status;
+
+		int_status = inb( ioaddr + INT_REG );
+
+		if ( int_status & IM_ALLOC_INT )
+			break;		/* got the interrupt */
+		timeout--;
+	}
+
+	/* there is really nothing that I can do here if timeout fails,
+	   as autoirq_report will return a 0 anyway, which is what I
+	   want in this case.   Plus, the clean up is needed in both
+	   cases.  */
+
+	/* DELAY HERE!
+	   On a fast machine, the status might change before the interrupt
+	   is given to the processor.  This means that the interrupt was
+	   never detected, and autoirq_report fails to report anything.
+	   This should fix autoirq_* problems.
+	*/
+	mdelay(10);
+
+	/* and disable all interrupts again */
+	outb( 0, ioaddr + IM_REG );
+
+	/* clear hardware interrupts again, because that's how it
+	   was when I was called... */
+	cli();
+	
+	/* and return what I found */
+	return probe_irq_off(cookie);
+}
+#endif
+
+/*----------------------------------------------------------------------
+ . Function: smc_probe( int ioaddr )
+ .
+ . Purpose:
+ .	Tests to see if a given ioaddr points to an SMC91111 chip.
+ .	Returns a 0 on success
+ .
+ . Algorithm:
+ .	(1) see if the high byte of BANK_SELECT is 0x33
+ . 	(2) compare the ioaddr with the base register's address
+ .	(3) see if I recognize the chip ID in the appropriate register
+ .
+ .---------------------------------------------------------------------
+ */
+/*---------------------------------------------------------------
+ . Here I do typical initialization tasks.
+ .
+ . o  Initialize the structure if needed
+ . o  print out my vanity message if not done so already
+ . o  print out what type of hardware is detected
+ . o  print out the ethernet address
+ . o  find the IRQ
+ . o  set up my private data
+ . o  configure the dev structure with my subroutines
+ . o  actually GRAB the irq.
+ . o  GRAB the region
+ .-----------------------------------------------------------------*/
+
+static int __init smc_probe(struct net_device *dev, int ioaddr )
+{
+	int i, memory, retval;
+	static unsigned version_printed = 0;
+	unsigned int	bank;
+
+        const char *version_string;
+
+	/*registers */
+	word	revision_register;
+	word	base_address_register;
+	word  	memory_info_register;
+	/*=> Pramod */
+	struct smc_local *lp;
+	/*<= Pramod */
+
+	PRINTK2("CARDNAME:smc_probe\n");
+
+	/* Grab the region so that no one else tries to probe our ioports. */
+	if (!request_region(ioaddr, SMC_IO_EXTENT, dev->name)) return -EBUSY;
+
+	dev->irq = irq;
+	dev->if_port = ifport;
+
+	/* First, see if the high byte is 0x33 */
+	bank = inw( ioaddr + BANK_SELECT );
+	if ( (bank & 0xFF00) != 0x3300 ) return -ENODEV;
+
+	/* The above MIGHT indicate a device, but I need to write to further test this.  */
+	outw( 0x0, ioaddr + BANK_SELECT );
+	bank = inw( ioaddr + BANK_SELECT );
+	if ( (bank & 0xFF00 ) != 0x3300 )
+	{
+		retval = -ENODEV;
+		goto err_out;
+	}
+
+	/* well, we've already written once, so hopefully another time won't
+ 	   hurt.  This time, I need to switch the bank register to bank 1,
+	   so I can access the base address register */
+	SMC_SELECT_BANK(1);
+	base_address_register = inw( ioaddr + BASE_REG );
+	if ( ioaddr != ( base_address_register >> 3 & 0x3E0 ) )
+	{
+		printk("CARDNAME: IOADDR %x doesn't match configuration (%x)."
+			"Probably not a SMC chip\n",
+			ioaddr, base_address_register >> 3 & 0x3E0 );
+		/* well, the base address register didn't match.  Must not have
+		   been a SMC chip after all. */
+		retval = -ENODEV;
+		goto err_out;
+	}
+
+	/*  check if the revision register is something that I recognize.
+	    These might need to be added to later, as future revisions
+	    could be added.  */
+	SMC_SELECT_BANK(3);
+	revision_register  = inw( ioaddr + REV_REG );
+	if ( !chip_ids[ ( revision_register  >> 4 ) & 0xF  ] )
+	{
+		/* I don't recognize this chip, so... */
+		printk("CARDNAME: IO %x: Unrecognized revision register:"
+			" %x, Contact author. \n",
+			ioaddr, revision_register );
+		retval =  -ENODEV;
+		goto err_out;
+	}
+
+	/* at this point I'll assume that the chip is an SMC9xxx.
+	   It might be prudent to check a listing of MAC addresses
+	   against the hardware address, or do some other tests. */
+
+	if (version_printed++ == 0)
+		printk("%s", version);
+
+	/* fill in some of the fields */
+	dev->base_addr = ioaddr;
+
+	/*
+ 	 . Get the MAC address ( bank 1, regs 4 - 9 )
+	*/
+	SMC_SELECT_BANK( 1 );
+	for ( i = 0; i < 6; i += 2 )
+	{
+		word	address;
+
+		address = inw( ioaddr + ADDR0_REG + i  );
+		dev->dev_addr[ i + 1] = address >> 8;
+		dev->dev_addr[ i ] = address & 0xFF;
+	}
+
+	/* get the memory information */
+
+	SMC_SELECT_BANK( 0 );
+	memory_info_register = inw( ioaddr + MIR_REG );
+	memory = memory_info_register & (word)0x00ff;
+	memory *= LAN91C111_MEMORY_MULTIPLIER;
+
+	/*
+	 Now, I want to find out more about the chip.  This is sort of
+ 	 redundant, but it's cleaner to have it in both, rather than having
+ 	 one VERY long probe procedure.
+	*/
+	SMC_SELECT_BANK(3);
+	revision_register  = inw( ioaddr + REV_REG );
+	version_string = chip_ids[ ( revision_register  >> 4 ) & 0xF  ];
+	if ( !version_string )
+	{
+		/* I shouldn't get here because this call was done before.... */
+		retval =  -ENODEV;
+		goto err_out;
+	}
+
+	/* now, reset the chip, and put it into a known state */
+	smc_reset( dev );
+
+	/*
+	 . If dev->irq is 0, then the device has to be banged on to see
+	 . what the IRQ is.
+ 	 .
+	 . This banging doesn't always detect the IRQ, for unknown reasons.
+	 . a workaround is to reset the chip and try again.
+	 .
+	 . Interestingly, the DOS packet driver *SETS* the IRQ on the card to
+	 . be what is requested on the command line.   I don't do that, mostly
+	 . because the card that I have uses a non-standard method of accessing
+	 . the IRQs, and because this _should_ work in most configurations.
+	 .
+	 . Specifying an IRQ is done with the assumption that the user knows
+	 . what (s)he is doing.  No checking is done!!!!
+ 	 .
+	*/
+#if defined(CONFIG_PLAT_M32700UT) && defined(NO_AUTOPROBE)
+	dev->irq = M32700UT_LAN_IRQ_LAN;
+#endif
+#if defined(CONFIG_PLAT_OPSPUT) && defined(NO_AUTOPROBE)
+	dev->irq = OPSPUT_LAN_IRQ_LAN;
+#endif
+#ifndef NO_AUTOPROBE	// by takeo
+	if ( dev->irq < 2 ) {
+		int	trials;
+
+		trials = 3;
+		while ( trials-- ) {
+			dev->irq = smc_findirq( ioaddr );
+			if ( dev->irq )
+				break;
+			/* kick the card and try again */
+			smc_reset( dev );
+		}
+	}
+
+	if (dev->irq == 0 ) {
+		printk("%s: Couldn't autodetect your IRQ. Use irq=xx.\n",
+			dev->name);
+		retval =  -ENODEV;
+		goto err_out;
+	}
+
+	if (dev->irq == 2) {
+		/* Fixup for users that don't know that IRQ 2 is really IRQ 9,
+		 * or don't know which one to set.
+		 */
+		dev->irq = 9;
+	}
+#endif
+
+	/* now, print out the card info, in a short format.. */
+
+	printk("%s: %s(rev:%d) at %#3x IRQ:%d MEMSIZE:%db NOWAIT:%d ",
+		dev->name,
+		version_string, revision_register & 0xF, ioaddr, dev->irq,
+		memory, dev->dma);
+	/*
+	 . Print the Ethernet address
+	*/
+	printk("ADDR: ");
+	for (i = 0; i < 5; i++)
+		printk("%2.2x:", dev->dev_addr[i] );
+	printk("%2.2x \n", dev->dev_addr[5] );
+
+	/* set the private data to zero by default */
+	memset(dev->priv, 0, sizeof(struct smc_local));
+
+	/* Grab the IRQ */
+    retval = request_irq(dev->irq, &smc_interrupt, 0, dev->name, dev);
+    if (retval) {
+       	  printk("%s: unable to get IRQ %d (irqval=%d).\n",
+		dev->name, dev->irq, retval);
+		  goto err_out;
+      	}
+
+	dev->open		        = smc_open;
+	dev->stop		        = smc_close;
+	dev->hard_start_xmit   	= smc_wait_to_send_packet;
+	dev->tx_timeout			= smc_timeout;
+	dev->get_stats			= smc_query_statistics;
+#ifdef	HAVE_MULTICAST
+	dev->set_multicast_list 	= &smc_set_multicast_list;
+#endif
+
+	/* => Store the ChipRevision and ChipID, to be used in resolving the Odd-Byte issue in RevB of LAN91C111; Pramod */
+	SMC_SELECT_BANK(3);
+	revision_register  = inw( ioaddr + REV_REG );
+	lp = (struct smc_local *)dev->priv;
+	lp->ChipID = (revision_register >> 4) & 0xF;
+	lp->ChipRev = revision_register & 0xF;
+
+        spin_lock_init(&lp->lock);
+
+	return 0;
+
+err_out:
+	release_region (ioaddr, SMC_IO_EXTENT);
+	return retval;
+}
+
+#if SMC_DEBUG > 2
+static void print_packet( byte * buf, int length )
+{
+#if 1
+	int i;
+	int remainder;
+	int lines;
+
+	printk("Packet of length %d \n", length );
+
+#if SMC_DEBUG > 3
+	lines = length / 16;
+	remainder = length % 16;
+
+	for ( i = 0; i < lines ; i ++ ) {
+		int cur;
+
+		for ( cur = 0; cur < 8; cur ++ ) {
+			byte a, b;
+
+			a = *(buf ++ );
+			b = *(buf ++ );
+			printk("%02x%02x ", a, b );
+		}
+		printk("\n");
+	}
+	for ( i = 0; i < remainder/2 ; i++ ) {
+		byte a, b;
+
+		a = *(buf ++ );
+		b = *(buf ++ );
+		printk("%02x%02x ", a, b );
+	}
+	printk("\n");
+#endif
+#endif
+}
+#endif
+
+
+/*
+ * Open and Initialize the board
+ *
+ * Set up everything, reset the card, etc ..
+ *
+ */
+static int smc_open(struct net_device *dev)
+{
+	struct smc_local *lp 	= (struct smc_local *)dev->priv;
+	int	ioaddr = dev->base_addr;
+	int	i;	/* used to set hw ethernet address */
+
+	PRINTK2("%s:smc_open\n", dev->name);
+
+#if 0
+	/* clear out all the junk that was put here before... */
+	memset(dev->priv, 0, sizeof(struct smc_local));
+#endif
+
+	netif_start_queue(dev);
+#ifdef MODULE
+	MOD_INC_USE_COUNT;
+#endif
+
+	// Setup the default Register Modes
+	lp->tcr_cur_mode = TCR_DEFAULT;
+	lp->rcr_cur_mode = RCR_DEFAULT;
+	lp->rpc_cur_mode = RPC_DEFAULT;
+
+	// Set default parameters (files)
+	lp->ctl_swfdup = 0;
+	lp->ctl_ephloop = 0;
+	lp->ctl_miiop = 0;
+	lp->ctl_autoneg = 1;
+	lp->ctl_rfduplx = 1;
+	lp->ctl_rspeed = 100;
+	lp->ctl_afduplx = 1;
+	lp->ctl_aspeed = 100;
+	lp->ctl_lnkfail = 1;
+	lp->ctl_forcol = 0;
+	lp->ctl_filtcar = 0;
+
+	/* reset the hardware */
+
+	smc_reset( dev );
+	smc_enable( dev );
+
+	/* Configure the PHY */
+	smc_phy_configure(dev);
+
+	/*
+  		According to Becker, I have to set the hardware address
+		at this point, because the (l)user can set it with an
+		ioctl.  Easily done...
+	*/
+	SMC_SELECT_BANK( 1 );
+	for ( i = 0; i < 6; i += 2 ) {
+		word	address;
+
+		address = dev->dev_addr[ i + 1 ] << 8 ;
+		address  |= dev->dev_addr[ i ];
+		outw( address, ioaddr + ADDR0_REG + i );
+	}
+
+#ifdef CONFIG_SYSCTL
+	smc_sysctl_register(dev);
+#endif /* CONFIG_SYSCTL */ 
+
+	netif_start_queue(dev);
+	return 0;
+}
+
+/*--------------------------------------------------------
+ . Called by the kernel to send a packet out into the void
+ . of the net.  This routine is largely based on
+ . skeleton.c, from Becker.
+ .--------------------------------------------------------
+*/
+static void smc_timeout (struct net_device *dev)
+{
+
+        struct smc_local *lp = (struct smc_local *)dev->priv;
+        unsigned long flags;
+
+        /*
+         *      Best would be to use synchronize_irq(); spin_lock() here
+         *      lets make it work first..
+         */
+         
+        spin_lock_irqsave(&lp->lock, flags);
+
+	PRINTK3("%s:smc_send_packet\n", dev->name);
+
+	/* If we get here, some higher level has decided we are broken.
+	There should really be a "kick me" function call instead. */
+	printk(KERN_WARNING "%s: transmit timed out, %s?\n",dev->name, tx_done(dev) ? "IRQ conflict" :"network cable problem");
+	/* "kick" the adaptor */
+	smc_reset( dev );
+	smc_enable( dev );
+
+	/* Reconfigure the PHY */
+	smc_phy_configure(dev);
+
+	dev->trans_start = jiffies;
+	/* clear anything saved */
+	((struct smc_local *)dev->priv)->saved_skb = NULL;
+
+	spin_unlock_irqrestore(&lp->lock, flags);
+
+	netif_wake_queue(dev);
+}
+
+/*--------------------------------------------------------------------
+ .
+ . This is the main routine of the driver, to handle the net_device when
+ . it needs some attention.
+ .
+ . So:
+ .   first, save state of the chipset
+ .   branch off into routines to handle each case, and acknowledge
+ .	    each to the interrupt register
+ .   and finally restore state.
+ .
+ ---------------------------------------------------------------------*/
+static irqreturn_t smc_interrupt(int irq, void * dev_id,  struct pt_regs * regs)
+{
+	struct net_device *dev 	= dev_id;
+	int ioaddr 		= dev->base_addr;
+	struct smc_local *lp 	= (struct smc_local *)dev->priv;
+
+	byte	status;
+	word	card_stats;
+	byte	mask;
+	int	timeout;
+	/* state registers */
+	word	saved_bank;
+	word	saved_pointer;
+	int handled = 0;
+
+	PRINTK3("%s: SMC interrupt started \n", dev->name);
+
+	if (dev == NULL) {
+		printk(KERN_WARNING "%s: irq %d for unknown device.\n",
+			dev->name, irq);
+		return IRQ_RETVAL(handled);
+	}
+
+/* will Linux let this happen ??  If not, this costs some speed 
+	if ( dev->interrupt ) {
+		printk(KERN_WARNING "%s: interrupt inside interrupt.\n",
+			dev->name);
+		return;
+	}
+
+	dev->interrupt = 1; */
+
+	spin_lock(&lp->lock);
+
+	saved_bank = inw( ioaddr + BANK_SELECT );
+
+	SMC_SELECT_BANK(2);
+	saved_pointer = inw( ioaddr + PTR_REG );
+
+	/* read the interrupt status register */
+	mask = inb( ioaddr + IM_REG );
+
+	/* disable all interrupts */
+	outb( 0, ioaddr + IM_REG );
+
+
+	/* set a timeout value, so I don't stay here forever */
+	timeout = 8;
+
+	PRINTK2(KERN_WARNING "%s: MASK IS %x \n", dev->name, mask);
+	do {
+		/* read the status flag, and mask it */
+		status = inb( ioaddr + INT_REG ) & mask;
+		if (!status )
+			break;
+
+		handled = 1;
+
+		PRINTK3(KERN_WARNING "%s: Handling interrupt status %x \n",
+			dev->name, status);
+
+		if (status & IM_RCV_INT) {
+			/* Got a packet(s). */
+			PRINTK2(KERN_WARNING
+				"%s: Receive Interrupt\n", dev->name);
+			smc_rcv(dev);
+		} else if (status & IM_TX_INT ) {
+			PRINTK2(KERN_WARNING "%s: TX ERROR handled\n",
+				dev->name);
+			smc_tx(dev);
+			// Acknowledge the interrupt
+			outb(IM_TX_INT, ioaddr + INT_REG );
+#if THROTTLE_TX_PKTS
+                        netif_wake_queue(dev);
+#endif
+		} else if (status & IM_TX_EMPTY_INT ) {
+			/* update stats */
+			SMC_SELECT_BANK( 0 );
+			card_stats = inw( ioaddr + COUNTER_REG );
+			/* single collisions */
+			lp->stats.collisions += card_stats & 0xF;
+			card_stats >>= 4;
+			/* multiple collisions */
+			lp->stats.collisions += card_stats & 0xF;
+
+			/* these are for when linux supports these statistics */
+#if 0
+			card_stats >>= 4;
+			/* deferred */
+			card_stats >>= 4;
+			/* excess deferred */
+#endif
+			SMC_SELECT_BANK( 2 );
+			PRINTK2(KERN_WARNING "%s: TX_BUFFER_EMPTY handled\n",
+				dev->name);
+			// Acknowledge the interrupt
+			outb( IM_TX_EMPTY_INT, ioaddr + INT_REG );
+			mask &= ~IM_TX_EMPTY_INT;
+			lp->stats.tx_packets += lp->packets_waiting;
+			lp->packets_waiting = 0;
+
+		} else if (status & IM_ALLOC_INT ) {
+			PRINTK2(KERN_DEBUG "%s: Allocation interrupt \n",
+				dev->name);
+			/* clear this interrupt so it doesn't happen again */
+			mask &= ~IM_ALLOC_INT;
+
+			smc_hardware_send_packet( dev );
+
+			/* enable xmit interrupts based on this */
+			mask |= ( IM_TX_EMPTY_INT | IM_TX_INT );
+
+			/* and let the card send more packets to me */
+#if ! THROTTLE_TX_PKTS
+			netif_wake_queue(dev);
+#endif
+
+			PRINTK2("%s: Handoff done successfully.\n",
+				dev->name);
+		} else if (status & IM_RX_OVRN_INT ) {
+			PRINTK2("%s: IM_RX_OVRN_INT \n",dev->name);
+			lp->stats.rx_errors++;
+			lp->stats.rx_fifo_errors++;
+			// Acknowledge the interrupt
+			outb( IM_RX_OVRN_INT, ioaddr + INT_REG );
+		} else if (status & IM_EPH_INT ) {
+			PRINTK("%s: UNSUPPORTED: EPH INTERRUPT \n",
+				dev->name);
+		} else if (status & IM_MDINT ) {
+			smc_phy_interrupt(dev);
+			// Acknowledge the interrupt
+			outb(IM_MDINT, ioaddr + INT_REG );
+		} else if (status & IM_ERCV_INT ) {
+			PRINTK("%s: UNSUPPORTED: ERCV INTERRUPT \n",
+				dev->name);
+			// Acknowledge the interrupt
+			outb( IM_ERCV_INT, ioaddr + INT_REG );
+		}
+	} while ( timeout -- );
+
+
+	/* restore register states */
+
+	SMC_SELECT_BANK( 2 );
+
+	outb( mask, ioaddr + IM_REG );
+
+	PRINTK3( KERN_WARNING "%s: MASK is now %x \n", dev->name, mask);
+	outw( saved_pointer, ioaddr + PTR_REG );
+
+	SMC_SELECT_BANK( saved_bank );
+
+	//dev->interrupt = 0;
+	PRINTK3("%s: Interrupt done\n", dev->name);
+
+	spin_unlock(&lp->lock);
+
+	return IRQ_RETVAL(handled);
+}
+
+/*-------------------------------------------------------------
+ .
+ . smc_rcv -  receive a packet from the card
+ .
+ . There is ( at least ) a packet waiting to be read from
+ . chip-memory.
+ .
+ . o Read the status
+ . o If an error, record it
+ . o otherwise, read in the packet
+ --------------------------------------------------------------
+*/
+static void smc_rcv(struct net_device *dev)
+{
+	struct smc_local *lp = (struct smc_local *)dev->priv;
+	int 	ioaddr = dev->base_addr;
+	int 	packet_number;
+	word	status;
+	word	packet_length;
+
+	PRINTK3("%s:smc_rcv\n", dev->name);
+
+	/* assume bank 2 */
+
+	packet_number = inw( ioaddr + RXFIFO_REG );
+
+	if ( packet_number & RXFIFO_REMPTY ) {
+
+		/* we got called , but nothing was on the FIFO */
+		PRINTK("%s: WARNING: smc_rcv with nothing on FIFO. \n",
+			dev->name);
+		/* don't need to restore anything */
+		return;
+	}
+
+	/*  start reading from the start of the packet */
+	outw( PTR_READ | PTR_RCV | PTR_AUTOINC, ioaddr + PTR_REG );
+
+	/* First two words are status and packet_length */
+	status 		= inw( ioaddr + DATA_REG );
+	packet_length 	= inw( ioaddr + DATA_REG );
+
+	packet_length &= 0x07ff;  /* mask off top bits */
+
+	PRINTK2("RCV: STATUS %4x LENGTH %4x\n", status, packet_length );
+
+	if ( !(status & RS_ERRORS ) ){
+		/* do stuff to make a new packet */
+		struct sk_buff  * skb;
+		byte		* data;
+
+		/* set multicast stats */
+		if ( status & RS_MULTICAST )
+			lp->stats.multicast++;
+
+		// Allocate enough memory for entire receive frame, to be safe
+		skb = dev_alloc_skb( packet_length );
+
+		/* Adjust for having already read the first two words */
+		packet_length -= 4;
+
+		if ( skb == NULL ) {
+			printk(KERN_NOTICE "%s: Low memory, packet dropped.\n",
+				dev->name);
+			lp->stats.rx_dropped++;
+			goto done;
+		}
+
+		/*
+		 ! This should work without alignment, but it could be
+		 ! in the worse case
+		*/
+		/* TODO: Should I use 32bit alignment here ? */
+		skb_reserve( skb, 2 );   /* 16 bit alignment */
+
+		skb->dev = dev;
+
+		/* =>
+    ODD-BYTE ISSUE : The odd byte problem has been fixed in the LAN91C111 Rev B.
+		So we check if the Chip Revision, stored in smsc_local->ChipRev, is = 1.
+		If so then we increment the packet length only if RS_ODDFRAME is set.
+		If the Chip's revision is equal to 0, then we blindly increment the packet length
+		by 1, thus always assuming that the packet is odd length, leaving the higher layer
+		to decide the actual length.
+			-- Pramod
+		<= */
+		if ((9 == lp->ChipID) && (1 == lp->ChipRev))
+		{
+			if (status & RS_ODDFRAME)
+				data = skb_put( skb, packet_length + 1 );	
+			else
+				data = skb_put( skb, packet_length);			
+			
+		}
+		else
+		{
+			// set odd length for bug in LAN91C111, REV A
+			// which never sets RS_ODDFRAME
+			data = skb_put( skb, packet_length + 1 );
+		}
+
+#ifdef USE_32_BIT
+		PRINTK3(" Reading %d dwords (and %d bytes) \n",
+			packet_length >> 2, packet_length & 3 );
+		/* QUESTION:  Like in the TX routine, do I want
+		   to send the DWORDs or the bytes first, or some
+		   mixture.  A mixture might improve already slow PIO
+		   performance  */
+		insl(ioaddr + DATA_REG , data, packet_length >> 2 );
+		/* read the left over bytes */
+		insb( ioaddr + DATA_REG, data + (packet_length & 0xFFFFFC),
+			packet_length & 0x3  );
+#else
+		PRINTK3(" Reading %d words and %d byte(s) \n",
+			(packet_length >> 1 ), packet_length & 1 );
+		insw(ioaddr + DATA_REG , data, packet_length >> 1);
+
+#endif // USE_32_BIT
+
+#if	SMC_DEBUG > 2
+		printk("Receiving Packet\n");
+		print_packet( data, packet_length );
+#endif
+
+		skb->protocol = eth_type_trans(skb, dev );
+		netif_rx(skb);
+		lp->stats.rx_packets++;
+#if defined(__m32r__)
+		lp->stats.rx_bytes += packet_length;
+#endif
+	} else {
+		/* error ... */
+		lp->stats.rx_errors++;
+
+		if ( status & RS_ALGNERR )  lp->stats.rx_frame_errors++;
+		if ( status & (RS_TOOSHORT | RS_TOOLONG ) )
+			lp->stats.rx_length_errors++;
+		if ( status & RS_BADCRC)	lp->stats.rx_crc_errors++;
+	}
+
+	while ( inw( ioaddr + MMU_CMD_REG ) & MC_BUSY )
+		udelay(1); // Wait until not busy
+done:
+	/*  error or good, tell the card to get rid of this packet */
+	outw( MC_RELEASE, ioaddr + MMU_CMD_REG );
+
+	return;
+}
+
+
+/*************************************************************************
+ . smc_tx
+ .
+ . Purpose:  Handle a transmit error message.   This will only be called
+ .   when an error, because of the AUTO_RELEASE mode.
+ .
+ . Algorithm:
+ .	Save pointer and packet no
+ .	Get the packet no from the top of the queue
+ .	check if it's valid ( if not, is this an error??? )
+ .	read the status word
+ .	record the error
+ .	( resend?  Not really, since we don't want old packets around )
+ .	Restore saved values
+ ************************************************************************/
+static void smc_tx( struct net_device * dev )
+{
+	int	ioaddr = dev->base_addr;
+	struct smc_local *lp = (struct smc_local *)dev->priv;
+	byte saved_packet;
+	byte packet_no;
+	word tx_status;
+
+
+	PRINTK3("%s:smc_tx\n", dev->name);
+
+	/* assume bank 2  */
+
+	saved_packet = inb( ioaddr + PN_REG );
+	packet_no = inw( ioaddr + RXFIFO_REG );
+#if defined(__m32r__)
+	/* If the TX FIFO is empty then nothing to do */
+	if ( packet_no & TXFIFO_TEMPTY )
+		return;
+
+	packet_no &= 0x7F;
+#else
+	packet_no &= 0x7F;
+
+	/* If the TX FIFO is empty then nothing to do */
+	if ( packet_no & TXFIFO_TEMPTY )
+		return;
+#endif
+
+	/* select this as the packet to read from */
+	outb( packet_no, ioaddr + PN_REG );
+
+	/* read the first word (status word) from this packet */
+	outw( PTR_AUTOINC | PTR_READ, ioaddr + PTR_REG );
+
+	tx_status = inw( ioaddr + DATA_REG );
+	PRINTK3("%s: TX DONE STATUS: %4x \n", dev->name, tx_status);
+
+	lp->stats.tx_errors++;
+	if ( tx_status & TS_LOSTCAR ) lp->stats.tx_carrier_errors++;
+	if ( tx_status & TS_LATCOL  ) {
+		printk(KERN_DEBUG
+			"%s: Late collision occurred on last xmit.\n",
+			dev->name);
+		lp->stats.tx_window_errors++;
+		lp->ctl_forcol = 0; // Reset forced collsion
+	}
+#if 0
+	if ( tx_status & TS_16COL ) { ... }
+#endif
+
+	if ( tx_status & TS_SUCCESS ) {
+	  //	  	printk("%s: Successful packet caused interrupt \n", dev->name);
+	}
+	/* re-enable transmit */
+	SMC_SELECT_BANK( 0 );
+	outw( inw( ioaddr + TCR_REG ) | TCR_ENABLE, ioaddr + TCR_REG );
+
+	/* kill the packet */
+	SMC_SELECT_BANK( 2 );
+	outw( MC_FREEPKT, ioaddr + MMU_CMD_REG );
+
+	/* one less packet waiting for me */
+	lp->packets_waiting--;
+
+	/* Don't change Packet Number Reg until busy bit is cleared */
+	/* Per LAN91C111 Spec, Page 50 */
+	while ( inw( ioaddr + MMU_CMD_REG ) & MC_BUSY );
+
+	outb( saved_packet, ioaddr + PN_REG );
+	return;
+}
+
+
+/*----------------------------------------------------
+ . smc_close
+ .
+ . this makes the board clean up everything that it can
+ . and not talk to the outside world.   Caused by
+ . an 'ifconfig ethX down'
+ .
+ -----------------------------------------------------*/
+static int smc_close(struct net_device *dev)
+{
+	netif_stop_queue(dev);
+	//dev->start = 0;
+
+	PRINTK2("%s:smc_close\n", dev->name);
+
+#ifdef CONFIG_SYSCTL
+	smc_sysctl_unregister(dev);
+#endif /* CONFIG_SYSCTL */ 
+
+	/* clear everything */
+	smc_shutdown( dev->base_addr );
+
+	/* Update the statistics here. */
+#ifdef MODULE
+	MOD_DEC_USE_COUNT;
+#endif
+
+	return 0;
+}
+
+/*------------------------------------------------------------
+ . Get the current statistics.
+ . This may be called with the card open or closed.
+ .-------------------------------------------------------------*/
+static struct net_device_stats* smc_query_statistics(struct net_device *dev) {
+	struct smc_local *lp = (struct smc_local *)dev->priv;
+
+	PRINTK2("%s:smc_query_statistics\n", dev->name);
+
+	return &lp->stats;
+}
+
+/*-----------------------------------------------------------
+ . smc_set_multicast_list
+ .
+ . This routine will, depending on the values passed to it,
+ . either make it accept multicast packets, go into
+ . promiscuous mode ( for TCPDUMP and cousins ) or accept
+ . a select set of multicast packets
+*/
+static void smc_set_multicast_list(struct net_device *dev)
+{
+	short ioaddr = dev->base_addr;
+
+	PRINTK2("%s:smc_set_multicast_list\n", dev->name);
+
+	SMC_SELECT_BANK(0);
+	if ( dev->flags & IFF_PROMISC )
+		{
+		PRINTK2("%s:smc_set_multicast_list:RCR_PRMS\n", dev->name);
+		outw( inw(ioaddr + RCR_REG ) | RCR_PRMS, ioaddr + RCR_REG );
+		}
+
+/* BUG?  I never disable promiscuous mode if multicasting was turned on.
+   Now, I turn off promiscuous mode, but I don't do anything to multicasting
+   when promiscuous mode is turned on.
+*/
+
+	/* Here, I am setting this to accept all multicast packets.
+	   I don't need to zero the multicast table, because the flag is
+	   checked before the table is
+	*/
+	else if (dev->flags & IFF_ALLMULTI)
+		{
+		outw( inw(ioaddr + RCR_REG ) | RCR_ALMUL, ioaddr + RCR_REG );
+		PRINTK2("%s:smc_set_multicast_list:RCR_ALMUL\n", dev->name);
+		}
+
+	/* We just get all multicast packets even if we only want them
+	 . from one source.  This will be changed at some future
+	 . point. */
+	else if (dev->mc_count )  {
+		/* support hardware multicasting */
+
+		/* be sure I get rid of flags I might have set */
+		outw( inw( ioaddr + RCR_REG ) & ~(RCR_PRMS | RCR_ALMUL),
+			ioaddr + RCR_REG );
+		/* NOTE: this has to set the bank, so make sure it is the
+		   last thing called.  The bank is set to zero at the top */
+		smc_setmulticast( ioaddr, dev->mc_count, dev->mc_list );
+	} else  {
+		PRINTK2("%s:smc_set_multicast_list:~(RCR_PRMS|RCR_ALMUL)\n",
+			dev->name);
+		outw( inw( ioaddr + RCR_REG ) & ~(RCR_PRMS | RCR_ALMUL),
+			ioaddr + RCR_REG );
+
+		/*
+		  since I'm disabling all multicast entirely, I need to
+		  clear the multicast list
+		*/
+		SMC_SELECT_BANK( 3 );
+		outw( 0, ioaddr + MCAST_REG1 );
+		outw( 0, ioaddr + MCAST_REG2 );
+		outw( 0, ioaddr + MCAST_REG3 );
+		outw( 0, ioaddr + MCAST_REG4 );
+	}
+}
+
+#ifdef MODULE
+
+static struct net_device *devSMC91111;
+int nowait = 0;
+
+MODULE_PARM(io, "i");
+MODULE_PARM(irq, "i");
+MODULE_PARM(nowait, "i");
+
+/*------------------------------------------------------------
+ . Module initialization function
+ .-------------------------------------------------------------*/
+int init_module(void)
+{
+	PRINTK2("CARDNAME:init_module\n");
+	if (io == 0)
+		printk(KERN_WARNING
+		CARDNAME": You shouldn't use auto-probing with insmod!\n" );
+
+	/* copy the parameters from insmod into the device structure */
+	devSMC91111 = smc_init(-1);
+	if (IS_ERR(devSMC91111))
+		return PTR_ERR(devSMC91111);
+
+	return 0;
+}
+
+/*------------------------------------------------------------
+ . Cleanup when module is removed with rmmod
+ .-------------------------------------------------------------*/
+void cleanup_module(void)
+{
+	unregister_netdev(devSMC91111);
+	free_irq(devSMC91111->irq, devSMC91111);
+	release_region(devSMC91111->base_addr, SMC_IO_EXTENT);
+	free_netdev(devSMC91111);
+}
+
+#endif /* MODULE */
+
+
+#ifdef CONFIG_SYSCTL
+
+
+/*------------------------------------------------------------
+ . Modify a bit in the LAN91C111 register set
+ .-------------------------------------------------------------*/
+static word smc_modify_regbit(int bank, int ioaddr, int reg,
+	unsigned int bit, int val)
+{
+	word regval;
+
+	SMC_SELECT_BANK( bank );
+
+	regval = inw( ioaddr+reg );
+	if (val)
+		regval |= bit;
+	else
+		regval &= ~bit;
+
+	outw( regval, ioaddr );
+	return(regval);
+}
+
+
+/*------------------------------------------------------------
+ . Retrieve a bit in the LAN91C111 register set
+ .-------------------------------------------------------------*/
+static int smc_get_regbit(int bank, int ioaddr, int reg, unsigned int bit)
+{
+	SMC_SELECT_BANK( bank );
+	if ( inw( ioaddr+reg ) & bit)
+		return(1);
+	else
+		return(0);
+}
+
+
+/*------------------------------------------------------------
+ . Modify a LAN91C111 register (word access only)
+ .-------------------------------------------------------------*/
+static void smc_modify_reg(int bank, int ioaddr, int reg, word val)
+{
+	SMC_SELECT_BANK( bank );
+	outw( val, ioaddr+reg );
+}
+
+
+/*------------------------------------------------------------
+ . Retrieve a LAN91C111 register (word access only)
+ .-------------------------------------------------------------*/
+static int smc_get_reg(int bank, int ioaddr, int reg)
+{
+	SMC_SELECT_BANK( bank );
+	return(inw( ioaddr+reg ));
+}
+
+
+static const char smc_info_string[] =
+"\n"
+"info           Provides this information blurb\n"
+"swver          Prints the software version information of this driver\n"
+"autoneg        Auto-negotiate Mode = 1\n"
+"rspeed         Requested Speed, 100=100Mbps, 10=10Mpbs\n"
+"rfduplx        Requested Full Duplex Operation\n"
+"aspeed         Actual Speed, 100=100Mbps, 10=10Mpbs\n"
+"afduplx        Actual Full Duplex Operation\n"
+"lnkfail        PHY Link Failure when 1\n"
+"miiop          External MII when 1, Internal PHY when 0\n"
+"swfdup         Switched Full Duplex Mode (allowed only in MII operation)\n"
+"ephloop        EPH Block Loopback\n"
+"forcol         Force a collision\n"
+"filtcar        Filter leading edge of carrier sense for 12 bit times\n"
+"freemem        Free buffer memory in bytes\n"
+"totmem         Total buffer memory in bytes\n"
+"leda           Output of LED-A (green)\n"
+"ledb           Output of LED-B (yellow)\n"
+"chiprev        Revision ID of the LAN91C111 chip\n"
+"";
+
+/*------------------------------------------------------------
+ . Sysctl handler for all integer parameters
+ .-------------------------------------------------------------*/
+static int smc_sysctl_handler(ctl_table *ctl, int write, struct file * filp,
+				void *buffer, size_t *lenp)
+{
+	struct net_device *dev = (struct net_device*)ctl->extra1;
+	struct smc_local *lp = (struct smc_local *)ctl->extra2;
+	int ioaddr = dev->base_addr;
+	int *valp = ctl->data;
+	int val;
+	int ret;
+
+	// Update parameters from the real registers
+	switch (ctl->ctl_name)
+	{
+	case CTL_SMC_FORCOL:
+		*valp = smc_get_regbit(0, ioaddr, TCR_REG, TCR_FORCOL);
+		break;
+
+	case CTL_SMC_FREEMEM:
+		*valp = ( (word)smc_get_reg(0, ioaddr, MIR_REG) >> 8 )
+			* LAN91C111_MEMORY_MULTIPLIER;
+		break;
+
+
+	case CTL_SMC_TOTMEM:
+		*valp = ( smc_get_reg(0, ioaddr, MIR_REG) & (word)0x00ff )
+			* LAN91C111_MEMORY_MULTIPLIER;
+		break;
+
+	case CTL_SMC_CHIPREV:
+		*valp = smc_get_reg(3, ioaddr, REV_REG);
+		break;
+
+	case CTL_SMC_AFDUPLX:
+		*valp = (lp->lastPhy18 & PHY_INT_DPLXDET) ? 1 : 0;
+		break;
+
+	case CTL_SMC_ASPEED:
+		*valp = (lp->lastPhy18 & PHY_INT_SPDDET) ? 100 : 10;
+		break;
+
+	case CTL_SMC_LNKFAIL:
+		*valp = (lp->lastPhy18 & PHY_INT_LNKFAIL) ? 1 : 0;
+		break;
+
+	case CTL_SMC_LEDA:
+		*valp = (lp->rpc_cur_mode >> RPC_LSXA_SHFT) & (word)0x0007;
+		break;
+
+	case CTL_SMC_LEDB:
+		*valp = (lp->rpc_cur_mode >> RPC_LSXB_SHFT) & (word)0x0007;
+		break;
+
+	case CTL_SMC_MIIOP:
+		*valp = smc_get_regbit(1, ioaddr, CONFIG_REG, CONFIG_EXT_PHY);
+		break;
+
+#ifdef SMC_DEBUG
+	case CTL_SMC_REG_BSR:	// Bank Select
+		*valp = smc_get_reg(0, ioaddr, BSR_REG);
+		break;
+
+	case CTL_SMC_REG_TCR:	// Transmit Control
+		*valp = smc_get_reg(0, ioaddr, TCR_REG);
+		break;
+
+	case CTL_SMC_REG_ESR:	// EPH Status
+		*valp = smc_get_reg(0, ioaddr, EPH_STATUS_REG);
+		break;
+
+	case CTL_SMC_REG_RCR:	// Receive Control
+		*valp = smc_get_reg(0, ioaddr, RCR_REG);
+		break;
+
+	case CTL_SMC_REG_CTRR:	// Counter
+		*valp = smc_get_reg(0, ioaddr, COUNTER_REG);
+		break;
+
+	case CTL_SMC_REG_MIR:	// Memory Information
+		*valp = smc_get_reg(0, ioaddr, MIR_REG);
+		break;
+
+	case CTL_SMC_REG_RPCR:	// Receive/Phy Control
+		*valp = smc_get_reg(0, ioaddr, RPC_REG);
+		break;
+
+	case CTL_SMC_REG_CFGR:	// Configuration
+		*valp = smc_get_reg(1, ioaddr, CONFIG_REG);
+		break;
+
+	case CTL_SMC_REG_BAR:	// Base Address
+		*valp = smc_get_reg(1, ioaddr, BASE_REG);
+		break;
+
+	case CTL_SMC_REG_IAR0:	// Individual Address
+		*valp = smc_get_reg(1, ioaddr, ADDR0_REG);
+		break;
+
+	case CTL_SMC_REG_IAR1:	// Individual Address
+		*valp = smc_get_reg(1, ioaddr, ADDR1_REG);
+		break;
+
+	case CTL_SMC_REG_IAR2:	// Individual Address
+		*valp = smc_get_reg(1, ioaddr, ADDR2_REG);
+		break;
+
+	case CTL_SMC_REG_GPR:	// General Purpose
+		*valp = smc_get_reg(1, ioaddr, GP_REG);
+		break;
+
+	case CTL_SMC_REG_CTLR:	// Control
+		*valp = smc_get_reg(1, ioaddr, CTL_REG);
+		break;
+
+	case CTL_SMC_REG_MCR:	// MMU Command
+		*valp = smc_get_reg(2, ioaddr, MMU_CMD_REG);
+		break;
+
+	case CTL_SMC_REG_PNR:	// Packet Number
+		*valp = smc_get_reg(2, ioaddr, PN_REG);
+		break;
+
+	case CTL_SMC_REG_FPR:	// Allocation Result/FIFO Ports
+		*valp = smc_get_reg(2, ioaddr, RXFIFO_REG);
+		break;
+
+	case CTL_SMC_REG_PTR:	// Pointer
+		*valp = smc_get_reg(2, ioaddr, PTR_REG);
+		break;
+
+	case CTL_SMC_REG_DR:	// Data 
+		*valp = smc_get_reg(2, ioaddr, DATA_REG);
+		break;
+
+	case CTL_SMC_REG_ISR:	// Interrupt Status/Mask
+		*valp = smc_get_reg(2, ioaddr, INT_REG);
+		break;
+
+	case CTL_SMC_REG_MTR1:	// Multicast Table Entry 1
+		*valp = smc_get_reg(3, ioaddr, MCAST_REG1);
+		break;
+
+	case CTL_SMC_REG_MTR2:	// Multicast Table Entry 2
+		*valp = smc_get_reg(3, ioaddr, MCAST_REG2);
+		break;
+
+	case CTL_SMC_REG_MTR3:	// Multicast Table Entry 3
+		*valp = smc_get_reg(3, ioaddr, MCAST_REG3);
+		break;
+
+	case CTL_SMC_REG_MTR4:	// Multicast Table Entry 4
+		*valp = smc_get_reg(3, ioaddr, MCAST_REG4);
+		break;
+
+	case CTL_SMC_REG_MIIR:	// Management Interface
+		*valp = smc_get_reg(3, ioaddr, MII_REG);
+		break;
+
+	case CTL_SMC_REG_REVR:	// Revision
+		*valp = smc_get_reg(3, ioaddr, REV_REG);
+		break;
+
+	case CTL_SMC_REG_ERCVR:	// Early RCV
+		*valp = smc_get_reg(3, ioaddr, ERCV_REG);
+		break;
+
+	case CTL_SMC_REG_EXTR:	// External
+		*valp = smc_get_reg(7, ioaddr, EXT_REG);
+		break;
+
+	case CTL_SMC_PHY_CTRL:
+		*valp = smc_read_phy_register(ioaddr, lp->phyaddr,
+			PHY_CNTL_REG);
+		break;
+
+	case CTL_SMC_PHY_STAT:
+		*valp = smc_read_phy_register(ioaddr, lp->phyaddr,
+			PHY_STAT_REG);
+		break;
+
+	case CTL_SMC_PHY_ID1:
+		*valp = smc_read_phy_register(ioaddr, lp->phyaddr,
+			PHY_ID1_REG);
+		break;
+
+	case CTL_SMC_PHY_ID2:
+		*valp = smc_read_phy_register(ioaddr, lp->phyaddr,
+			PHY_ID2_REG);
+		break;
+
+	case CTL_SMC_PHY_ADC:
+		*valp = smc_read_phy_register(ioaddr, lp->phyaddr,
+			PHY_AD_REG);
+		break;
+
+	case CTL_SMC_PHY_REMC:
+		*valp = smc_read_phy_register(ioaddr, lp->phyaddr,
+			PHY_RMT_REG);
+		break;
+
+	case CTL_SMC_PHY_CFG1:
+		*valp = smc_read_phy_register(ioaddr, lp->phyaddr,
+			PHY_CFG1_REG);
+		break;
+
+	case CTL_SMC_PHY_CFG2:
+		*valp = smc_read_phy_register(ioaddr, lp->phyaddr,
+			PHY_CFG2_REG);
+		break;
+
+	case CTL_SMC_PHY_INT:
+		*valp = smc_read_phy_register(ioaddr, lp->phyaddr,
+			PHY_INT_REG);
+		break;
+
+	case CTL_SMC_PHY_MASK:
+		*valp = smc_read_phy_register(ioaddr, lp->phyaddr,
+			PHY_MASK_REG);
+		break;
+
+#endif // SMC_DEBUG
+
+	default:
+		// Just ignore unsupported parameters
+		break;
+	}
+
+	// Save old state
+	val = *valp;
+
+	// Perform the generic integer operation	
+	if ((ret = proc_dointvec(ctl, write, filp, buffer, lenp)) != 0)
+		return(ret);
+
+	// Write changes out to the registers
+	if (write && *valp != val) {
+
+		val = *valp;
+		switch (ctl->ctl_name) {
+
+		case CTL_SMC_SWFDUP:
+			if (val)
+				lp->tcr_cur_mode |= TCR_SWFDUP;
+			else
+				lp->tcr_cur_mode &= ~TCR_SWFDUP;
+
+			smc_modify_regbit(0, ioaddr, TCR_REG, TCR_SWFDUP, val);
+			break;
+
+		case CTL_SMC_EPHLOOP:
+			if (val)
+				lp->tcr_cur_mode |= TCR_EPH_LOOP;
+			else
+				lp->tcr_cur_mode &= ~TCR_EPH_LOOP;
+
+			smc_modify_regbit(0, ioaddr, TCR_REG, TCR_EPH_LOOP, val);
+			break;
+
+		case CTL_SMC_FORCOL:
+			if (val)
+				lp->tcr_cur_mode |= TCR_FORCOL;
+			else
+				lp->tcr_cur_mode &= ~TCR_FORCOL;
+
+			// Update the EPH block
+			smc_modify_regbit(0, ioaddr, TCR_REG, TCR_FORCOL, val);
+			break;
+
+		case CTL_SMC_FILTCAR:
+			if (val)
+				lp->rcr_cur_mode |= RCR_FILT_CAR;
+			else
+				lp->rcr_cur_mode &= ~RCR_FILT_CAR;
+
+			// Update the EPH block
+			smc_modify_regbit(0, ioaddr, RCR_REG, RCR_FILT_CAR, val);
+			break;
+
+		case CTL_SMC_RFDUPLX:
+			// Disallow changes if in auto-negotiation mode
+			if (lp->ctl_autoneg)
+				break;
+
+			if (val)
+				{
+				lp->rpc_cur_mode |= RPC_DPLX;
+				}
+			else
+				{
+				lp->rpc_cur_mode &= ~RPC_DPLX;
+				}
+
+			// Reconfigure the PHY
+			smc_phy_configure(dev);
+
+			break;
+
+		case CTL_SMC_RSPEED:
+			// Disallow changes if in auto-negotiation mode
+			if (lp->ctl_autoneg)
+				break;
+
+			if (val > 10)
+				lp->rpc_cur_mode |= RPC_SPEED;
+			else
+				lp->rpc_cur_mode &= ~RPC_SPEED;
+
+			// Reconfigure the PHY
+			smc_phy_configure(dev);
+
+			break;
+
+		case CTL_SMC_AUTONEG:
+			if (val)
+				lp->rpc_cur_mode |= RPC_ANEG;
+			else
+				lp->rpc_cur_mode &= ~RPC_ANEG;
+
+			// Reconfigure the PHY
+			smc_phy_configure(dev);
+
+			break;
+
+		case CTL_SMC_LEDA:
+			val &= 0x07; // Restrict to 3 ls bits
+			lp->rpc_cur_mode &= ~(word)(0x07<<RPC_LSXA_SHFT);
+			lp->rpc_cur_mode |= (word)(val<<RPC_LSXA_SHFT);
+
+			// Update the Internal PHY block
+			smc_modify_reg(0, ioaddr, RPC_REG, lp->rpc_cur_mode);
+			break;
+
+		case CTL_SMC_LEDB:
+			val &= 0x07; // Restrict to 3 ls bits
+			lp->rpc_cur_mode &= ~(word)(0x07<<RPC_LSXB_SHFT);
+			lp->rpc_cur_mode |= (word)(val<<RPC_LSXB_SHFT);
+
+			// Update the Internal PHY block
+			smc_modify_reg(0, ioaddr, RPC_REG, lp->rpc_cur_mode);
+			break;
+
+		case CTL_SMC_MIIOP:
+			// Update the Internal PHY block
+			smc_modify_regbit(1, ioaddr, CONFIG_REG,
+				CONFIG_EXT_PHY, val);
+			break;
+
+#ifdef SMC_DEBUG
+		case CTL_SMC_REG_BSR:	// Bank Select
+			smc_modify_reg(0, ioaddr, BSR_REG, val);
+			break;
+
+		case CTL_SMC_REG_TCR:	// Transmit Control
+			smc_modify_reg(0, ioaddr, TCR_REG, val);
+			break;
+
+		case CTL_SMC_REG_ESR:	// EPH Status
+			smc_modify_reg(0, ioaddr, EPH_STATUS_REG, val);
+			break;
+
+		case CTL_SMC_REG_RCR:	// Receive Control
+			smc_modify_reg(0, ioaddr, RCR_REG, val);
+			break;
+
+		case CTL_SMC_REG_CTRR:	// Counter
+			smc_modify_reg(0, ioaddr, COUNTER_REG, val);
+			break;
+
+		case CTL_SMC_REG_MIR:	// Memory Information
+			smc_modify_reg(0, ioaddr, MIR_REG, val);
+			break;
+
+		case CTL_SMC_REG_RPCR:	// Receive/Phy Control
+			smc_modify_reg(0, ioaddr, RPC_REG, val);
+			break;
+
+		case CTL_SMC_REG_CFGR:	// Configuration
+			smc_modify_reg(1, ioaddr, CONFIG_REG, val);
+			break;
+
+		case CTL_SMC_REG_BAR:	// Base Address
+			smc_modify_reg(1, ioaddr, BASE_REG, val);
+			break;
+
+		case CTL_SMC_REG_IAR0:	// Individual Address
+			smc_modify_reg(1, ioaddr, ADDR0_REG, val);
+			break;
+
+		case CTL_SMC_REG_IAR1:	// Individual Address
+			smc_modify_reg(1, ioaddr, ADDR1_REG, val);
+			break;
+
+		case CTL_SMC_REG_IAR2:	// Individual Address
+			smc_modify_reg(1, ioaddr, ADDR2_REG, val);
+			break;
+
+		case CTL_SMC_REG_GPR:	// General Purpose
+			smc_modify_reg(1, ioaddr, GP_REG, val);
+			break;
+
+		case CTL_SMC_REG_CTLR:	// Control
+			smc_modify_reg(1, ioaddr, CTL_REG, val);
+			break;
+
+		case CTL_SMC_REG_MCR:	// MMU Command
+			smc_modify_reg(2, ioaddr, MMU_CMD_REG, val);
+			break;
+
+		case CTL_SMC_REG_PNR:	// Packet Number
+			smc_modify_reg(2, ioaddr, PN_REG, val);
+			break;
+
+		case CTL_SMC_REG_FPR:	// Allocation Result/FIFO Ports
+			smc_modify_reg(2, ioaddr, RXFIFO_REG, val);
+			break;
+
+		case CTL_SMC_REG_PTR:	// Pointer
+			smc_modify_reg(2, ioaddr, PTR_REG, val);
+			break;
+
+		case CTL_SMC_REG_DR:	// Data 
+			smc_modify_reg(2, ioaddr, DATA_REG, val);
+			break;
+
+		case CTL_SMC_REG_ISR:	// Interrupt Status/Mask
+			smc_modify_reg(2, ioaddr, INT_REG, val);
+			break;
+
+		case CTL_SMC_REG_MTR1:	// Multicast Table Entry 1
+			smc_modify_reg(3, ioaddr, MCAST_REG1, val);
+			break;
+
+		case CTL_SMC_REG_MTR2:	// Multicast Table Entry 2
+			smc_modify_reg(3, ioaddr, MCAST_REG2, val);
+			break;
+
+		case CTL_SMC_REG_MTR3:	// Multicast Table Entry 3
+			smc_modify_reg(3, ioaddr, MCAST_REG3, val);
+			break;
+
+		case CTL_SMC_REG_MTR4:	// Multicast Table Entry 4
+			smc_modify_reg(3, ioaddr, MCAST_REG4, val);
+			break;
+
+		case CTL_SMC_REG_MIIR:	// Management Interface
+			smc_modify_reg(3, ioaddr, MII_REG, val);
+			break;
+
+		case CTL_SMC_REG_REVR:	// Revision
+			smc_modify_reg(3, ioaddr, REV_REG, val);
+			break;
+
+		case CTL_SMC_REG_ERCVR:	// Early RCV
+			smc_modify_reg(3, ioaddr, ERCV_REG, val);
+			break;
+
+		case CTL_SMC_REG_EXTR:	// External
+			smc_modify_reg(7, ioaddr, EXT_REG, val);
+			break;
+
+		case CTL_SMC_PHY_CTRL:
+			smc_write_phy_register(ioaddr, lp->phyaddr,
+				PHY_CNTL_REG, val);
+			break;
+
+		case CTL_SMC_PHY_STAT:
+			smc_write_phy_register(ioaddr, lp->phyaddr,
+				PHY_STAT_REG, val);
+			break;
+
+		case CTL_SMC_PHY_ID1:
+			smc_write_phy_register(ioaddr, lp->phyaddr,
+				PHY_ID1_REG, val);
+			break;
+
+		case CTL_SMC_PHY_ID2:
+			smc_write_phy_register(ioaddr, lp->phyaddr,
+				PHY_ID2_REG, val);
+			break;
+
+		case CTL_SMC_PHY_ADC:
+			smc_write_phy_register(ioaddr, lp->phyaddr,
+				PHY_AD_REG, val);
+			break;
+
+		case CTL_SMC_PHY_REMC:
+			smc_write_phy_register(ioaddr, lp->phyaddr,
+				PHY_RMT_REG, val);
+			break;
+
+		case CTL_SMC_PHY_CFG1:
+			smc_write_phy_register(ioaddr, lp->phyaddr,
+				PHY_CFG1_REG, val);
+			break;
+
+		case CTL_SMC_PHY_CFG2:
+			smc_write_phy_register(ioaddr, lp->phyaddr,
+				PHY_CFG2_REG, val);
+			break;
+
+		case CTL_SMC_PHY_INT:
+			smc_write_phy_register(ioaddr, lp->phyaddr,
+				PHY_INT_REG, val);
+			break;
+
+		case CTL_SMC_PHY_MASK:
+			smc_write_phy_register(ioaddr, lp->phyaddr,
+				PHY_MASK_REG, val);
+			break;
+
+#endif // SMC_DEBUG
+
+		default:
+			// Just ignore unsupported parameters
+			break;
+		} // end switch
+
+	} // end if
+
+        return ret;
+}
+
+/*------------------------------------------------------------
+ . Sysctl registration function for all parameters (files)
+ .-------------------------------------------------------------*/
+static void smc_sysctl_register(struct net_device *dev)
+{
+	struct smc_local *lp = (struct smc_local *)dev->priv;
+	static int ctl_name = CTL_SMC;
+	ctl_table* ct;
+	int i;
+
+	// Make sure the ctl_tables start out as all zeros
+	memset(lp->root_table, 0, sizeof lp->root_table);
+	memset(lp->eth_table, 0, sizeof lp->eth_table);
+	memset(lp->param_table, 0, sizeof lp->param_table);
+
+	// Initialize the root table
+	ct = lp->root_table;
+	ct->ctl_name = CTL_DEV;
+	ct->procname = "dev";
+	ct->maxlen = 0;
+	ct->mode = 0555;
+	ct->child = lp->eth_table;
+	// remaining fields are zero
+
+	// Initialize the ethX table (this device's table)
+	ct = lp->eth_table;
+	ct->ctl_name = ctl_name++; // Must be unique
+	ct->procname = dev->name;
+	ct->maxlen = 0;
+	ct->mode = 0555;
+	ct->child = lp->param_table;
+	// remaining fields are zero
+
+	// Initialize the parameter (files) table
+	// Make sure the last entry remains null
+	ct = lp->param_table;
+	for (i = 0; i < (CTL_SMC_LAST_ENTRY-1); ++i)
+		{
+		// Initialize fields common to all table entries
+		ct[i].proc_handler = smc_sysctl_handler;
+		ct[i].extra1 = (void*)dev; // Save our device pointer
+		ct[i].extra2 = (void*)lp;  // Save our smc_local data pointer
+		}
+
+	// INFO - this is our only string parameter
+	i = 0;
+	ct[i].proc_handler = proc_dostring; // use default handler
+	ct[i].ctl_name = CTL_SMC_INFO;
+	ct[i].procname = "info";
+	ct[i].data = (void*)smc_info_string;
+	ct[i].maxlen = sizeof smc_info_string;
+	ct[i].mode = 0444; // Read only
+
+	// SWVER
+	++i;
+	ct[i].proc_handler = proc_dostring; // use default handler
+	ct[i].ctl_name = CTL_SMC_SWVER;
+	ct[i].procname = "swver";
+	ct[i].data = (void*)version;
+	ct[i].maxlen = sizeof version;
+	ct[i].mode = 0444; // Read only
+
+	// SWFDUP
+	++i;
+	ct[i].ctl_name = CTL_SMC_SWFDUP;
+	ct[i].procname = "swfdup";
+	ct[i].data = (void*)&(lp->ctl_swfdup);
+	ct[i].maxlen = sizeof lp->ctl_swfdup;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// EPHLOOP
+	++i;
+	ct[i].ctl_name = CTL_SMC_EPHLOOP;
+	ct[i].procname = "ephloop";
+	ct[i].data = (void*)&(lp->ctl_ephloop);
+	ct[i].maxlen = sizeof lp->ctl_ephloop;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// MIIOP
+	++i;
+	ct[i].ctl_name = CTL_SMC_MIIOP;
+	ct[i].procname = "miiop";
+	ct[i].data = (void*)&(lp->ctl_miiop);
+	ct[i].maxlen = sizeof lp->ctl_miiop;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// AUTONEG
+	++i;
+	ct[i].ctl_name = CTL_SMC_AUTONEG;
+	ct[i].procname = "autoneg";
+	ct[i].data = (void*)&(lp->ctl_autoneg);
+	ct[i].maxlen = sizeof lp->ctl_autoneg;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// RFDUPLX
+	++i;
+	ct[i].ctl_name = CTL_SMC_RFDUPLX;
+	ct[i].procname = "rfduplx";
+	ct[i].data = (void*)&(lp->ctl_rfduplx);
+	ct[i].maxlen = sizeof lp->ctl_rfduplx;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// RSPEED
+	++i;
+	ct[i].ctl_name = CTL_SMC_RSPEED;
+	ct[i].procname = "rspeed";
+	ct[i].data = (void*)&(lp->ctl_rspeed);
+	ct[i].maxlen = sizeof lp->ctl_rspeed;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// AFDUPLX
+	++i;
+	ct[i].ctl_name = CTL_SMC_AFDUPLX;
+	ct[i].procname = "afduplx";
+	ct[i].data = (void*)&(lp->ctl_afduplx);
+	ct[i].maxlen = sizeof lp->ctl_afduplx;
+	ct[i].mode = 0444; // Read only
+
+	// ASPEED
+	++i;
+	ct[i].ctl_name = CTL_SMC_ASPEED;
+	ct[i].procname = "aspeed";
+	ct[i].data = (void*)&(lp->ctl_aspeed);
+	ct[i].maxlen = sizeof lp->ctl_aspeed;
+	ct[i].mode = 0444; // Read only
+
+	// LNKFAIL
+	++i;
+	ct[i].ctl_name = CTL_SMC_LNKFAIL;
+	ct[i].procname = "lnkfail";
+	ct[i].data = (void*)&(lp->ctl_lnkfail);
+	ct[i].maxlen = sizeof lp->ctl_lnkfail;
+	ct[i].mode = 0444; // Read only
+
+	// FORCOL
+	++i;
+	ct[i].ctl_name = CTL_SMC_FORCOL;
+	ct[i].procname = "forcol";
+	ct[i].data = (void*)&(lp->ctl_forcol);
+	ct[i].maxlen = sizeof lp->ctl_forcol;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// FILTCAR
+	++i;
+	ct[i].ctl_name = CTL_SMC_FILTCAR;
+	ct[i].procname = "filtcar";
+	ct[i].data = (void*)&(lp->ctl_filtcar);
+	ct[i].maxlen = sizeof lp->ctl_filtcar;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// FREEMEM
+	++i;
+	ct[i].ctl_name = CTL_SMC_FREEMEM;
+	ct[i].procname = "freemem";
+	ct[i].data = (void*)&(lp->ctl_freemem);
+	ct[i].maxlen = sizeof lp->ctl_freemem;
+	ct[i].mode = 0444; // Read only
+
+	// TOTMEM
+	++i;
+	ct[i].ctl_name = CTL_SMC_TOTMEM;
+	ct[i].procname = "totmem";
+	ct[i].data = (void*)&(lp->ctl_totmem);
+	ct[i].maxlen = sizeof lp->ctl_totmem;
+	ct[i].mode = 0444; // Read only
+
+	// LEDA
+	++i;
+	ct[i].ctl_name = CTL_SMC_LEDA;
+	ct[i].procname = "leda";
+	ct[i].data = (void*)&(lp->ctl_leda);
+	ct[i].maxlen = sizeof lp->ctl_leda;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// LEDB
+	++i;
+	ct[i].ctl_name = CTL_SMC_LEDB;
+	ct[i].procname = "ledb";
+	ct[i].data = (void*)&(lp->ctl_ledb);
+	ct[i].maxlen = sizeof lp->ctl_ledb;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// CHIPREV
+	++i;
+	ct[i].ctl_name = CTL_SMC_CHIPREV;
+	ct[i].procname = "chiprev";
+	ct[i].data = (void*)&(lp->ctl_chiprev);
+	ct[i].maxlen = sizeof lp->ctl_chiprev;
+	ct[i].mode = 0444; // Read only
+
+#ifdef SMC_DEBUG
+	// REG_BSR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_BSR;
+	ct[i].procname = "reg_bsr";
+	ct[i].data = (void*)&(lp->ctl_reg_bsr);
+	ct[i].maxlen = sizeof lp->ctl_reg_bsr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_TCR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_TCR;
+	ct[i].procname = "reg_tcr";
+	ct[i].data = (void*)&(lp->ctl_reg_tcr);
+	ct[i].maxlen = sizeof lp->ctl_reg_tcr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_ESR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_ESR;
+	ct[i].procname = "reg_esr";
+	ct[i].data = (void*)&(lp->ctl_reg_esr);
+	ct[i].maxlen = sizeof lp->ctl_reg_esr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_RCR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_RCR;
+	ct[i].procname = "reg_rcr";
+	ct[i].data = (void*)&(lp->ctl_reg_rcr);
+	ct[i].maxlen = sizeof lp->ctl_reg_rcr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_CTRR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_CTRR;
+	ct[i].procname = "reg_ctrr";
+	ct[i].data = (void*)&(lp->ctl_reg_ctrr);
+	ct[i].maxlen = sizeof lp->ctl_reg_ctrr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_MIR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_MIR;
+	ct[i].procname = "reg_mir";
+	ct[i].data = (void*)&(lp->ctl_reg_mir);
+	ct[i].maxlen = sizeof lp->ctl_reg_mir;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_RPCR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_RPCR;
+	ct[i].procname = "reg_rpcr";
+	ct[i].data = (void*)&(lp->ctl_reg_rpcr);
+	ct[i].maxlen = sizeof lp->ctl_reg_rpcr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_CFGR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_CFGR;
+	ct[i].procname = "reg_cfgr";
+	ct[i].data = (void*)&(lp->ctl_reg_cfgr);
+	ct[i].maxlen = sizeof lp->ctl_reg_cfgr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_BAR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_BAR;
+	ct[i].procname = "reg_bar";
+	ct[i].data = (void*)&(lp->ctl_reg_bar);
+	ct[i].maxlen = sizeof lp->ctl_reg_bar;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_IAR0
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_IAR0;
+	ct[i].procname = "reg_iar0";
+	ct[i].data = (void*)&(lp->ctl_reg_iar0);
+	ct[i].maxlen = sizeof lp->ctl_reg_iar0;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_IAR1
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_IAR1;
+	ct[i].procname = "reg_iar1";
+	ct[i].data = (void*)&(lp->ctl_reg_iar1);
+	ct[i].maxlen = sizeof lp->ctl_reg_iar1;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_IAR2
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_IAR2;
+	ct[i].procname = "reg_iar2";
+	ct[i].data = (void*)&(lp->ctl_reg_iar2);
+	ct[i].maxlen = sizeof lp->ctl_reg_iar2;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_GPR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_GPR;
+	ct[i].procname = "reg_gpr";
+	ct[i].data = (void*)&(lp->ctl_reg_gpr);
+	ct[i].maxlen = sizeof lp->ctl_reg_gpr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_CTLR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_CTLR;
+	ct[i].procname = "reg_ctlr";
+	ct[i].data = (void*)&(lp->ctl_reg_ctlr);
+	ct[i].maxlen = sizeof lp->ctl_reg_ctlr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_MCR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_MCR;
+	ct[i].procname = "reg_mcr";
+	ct[i].data = (void*)&(lp->ctl_reg_mcr);
+	ct[i].maxlen = sizeof lp->ctl_reg_mcr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_PNR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_PNR;
+	ct[i].procname = "reg_pnr";
+	ct[i].data = (void*)&(lp->ctl_reg_pnr);
+	ct[i].maxlen = sizeof lp->ctl_reg_pnr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_FPR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_FPR;
+	ct[i].procname = "reg_fpr";
+	ct[i].data = (void*)&(lp->ctl_reg_fpr);
+	ct[i].maxlen = sizeof lp->ctl_reg_fpr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_PTR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_PTR;
+	ct[i].procname = "reg_ptr";
+	ct[i].data = (void*)&(lp->ctl_reg_ptr);
+	ct[i].maxlen = sizeof lp->ctl_reg_ptr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_DR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_DR;
+	ct[i].procname = "reg_dr";
+	ct[i].data = (void*)&(lp->ctl_reg_dr);
+	ct[i].maxlen = sizeof lp->ctl_reg_dr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_ISR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_ISR;
+	ct[i].procname = "reg_isr";
+	ct[i].data = (void*)&(lp->ctl_reg_isr);
+	ct[i].maxlen = sizeof lp->ctl_reg_isr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_MTR1
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_MTR1;
+	ct[i].procname = "reg_mtr1";
+	ct[i].data = (void*)&(lp->ctl_reg_mtr1);
+	ct[i].maxlen = sizeof lp->ctl_reg_mtr1;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_MTR2
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_MTR2;
+	ct[i].procname = "reg_mtr2";
+	ct[i].data = (void*)&(lp->ctl_reg_mtr2);
+	ct[i].maxlen = sizeof lp->ctl_reg_mtr2;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_MTR3
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_MTR3;
+	ct[i].procname = "reg_mtr3";
+	ct[i].data = (void*)&(lp->ctl_reg_mtr3);
+	ct[i].maxlen = sizeof lp->ctl_reg_mtr3;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_MTR4
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_MTR4;
+	ct[i].procname = "reg_mtr4";
+	ct[i].data = (void*)&(lp->ctl_reg_mtr4);
+	ct[i].maxlen = sizeof lp->ctl_reg_mtr4;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_MIIR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_MIIR;
+	ct[i].procname = "reg_miir";
+	ct[i].data = (void*)&(lp->ctl_reg_miir);
+	ct[i].maxlen = sizeof lp->ctl_reg_miir;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_REVR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_REVR;
+	ct[i].procname = "reg_revr";
+	ct[i].data = (void*)&(lp->ctl_reg_revr);
+	ct[i].maxlen = sizeof lp->ctl_reg_revr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_ERCVR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_ERCVR;
+	ct[i].procname = "reg_ercvr";
+	ct[i].data = (void*)&(lp->ctl_reg_ercvr);
+	ct[i].maxlen = sizeof lp->ctl_reg_ercvr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// REG_EXTR
+	++i;
+	ct[i].ctl_name = CTL_SMC_REG_EXTR;
+	ct[i].procname = "reg_extr";
+	ct[i].data = (void*)&(lp->ctl_reg_extr);
+	ct[i].maxlen = sizeof lp->ctl_reg_extr;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// PHY Control
+	++i;
+	ct[i].ctl_name = CTL_SMC_PHY_CTRL;
+	ct[i].procname = "phy_ctrl";
+	ct[i].data = (void*)&(lp->ctl_phy_ctrl);
+	ct[i].maxlen = sizeof lp->ctl_phy_ctrl;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// PHY Status
+	++i;
+	ct[i].ctl_name = CTL_SMC_PHY_STAT;
+	ct[i].procname = "phy_stat";
+	ct[i].data = (void*)&(lp->ctl_phy_stat);
+	ct[i].maxlen = sizeof lp->ctl_phy_stat;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// PHY ID1
+	++i;
+	ct[i].ctl_name = CTL_SMC_PHY_ID1;
+	ct[i].procname = "phy_id1";
+	ct[i].data = (void*)&(lp->ctl_phy_id1);
+	ct[i].maxlen = sizeof lp->ctl_phy_id1;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// PHY ID2
+	++i;
+	ct[i].ctl_name = CTL_SMC_PHY_ID2;
+	ct[i].procname = "phy_id2";
+	ct[i].data = (void*)&(lp->ctl_phy_id2);
+	ct[i].maxlen = sizeof lp->ctl_phy_id2;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// PHY Advertise Capabilities
+	++i;
+	ct[i].ctl_name = CTL_SMC_PHY_ADC;
+	ct[i].procname = "phy_adc";
+	ct[i].data = (void*)&(lp->ctl_phy_adc);
+	ct[i].maxlen = sizeof lp->ctl_phy_adc;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// PHY Remote Capabilities
+	++i;
+	ct[i].ctl_name = CTL_SMC_PHY_REMC;
+	ct[i].procname = "phy_remc";
+	ct[i].data = (void*)&(lp->ctl_phy_remc);
+	ct[i].maxlen = sizeof lp->ctl_phy_remc;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// PHY Configuration 1
+	++i;
+	ct[i].ctl_name = CTL_SMC_PHY_CFG1;
+	ct[i].procname = "phy_cfg1";
+	ct[i].data = (void*)&(lp->ctl_phy_cfg1);
+	ct[i].maxlen = sizeof lp->ctl_phy_cfg1;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// PHY Configuration 2
+	++i;
+	ct[i].ctl_name = CTL_SMC_PHY_CFG2;
+	ct[i].procname = "phy_cfg2";
+	ct[i].data = (void*)&(lp->ctl_phy_cfg2);
+	ct[i].maxlen = sizeof lp->ctl_phy_cfg2;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// PHY Interrupt/Status Output
+	++i;
+	ct[i].ctl_name = CTL_SMC_PHY_INT;
+	ct[i].procname = "phy_int";
+	ct[i].data = (void*)&(lp->ctl_phy_int);
+	ct[i].maxlen = sizeof lp->ctl_phy_int;
+	ct[i].mode = 0644; // Read by all, write by root
+
+	// PHY Interrupt/Status Mask
+	++i;
+	ct[i].ctl_name = CTL_SMC_PHY_MASK;
+	ct[i].procname = "phy_mask";
+	ct[i].data = (void*)&(lp->ctl_phy_mask);
+	ct[i].maxlen = sizeof lp->ctl_phy_mask;
+	ct[i].mode = 0644; // Read by all, write by root
+
+#endif // SMC_DEBUG
+
+	// Register /proc/sys/dev/ethX
+	lp->sysctl_header = register_sysctl_table(lp->root_table, 1);
+}
+
+
+/*------------------------------------------------------------
+ . Sysctl unregistration when driver is closed
+ .-------------------------------------------------------------*/
+static void smc_sysctl_unregister(struct net_device *dev)
+{
+	struct smc_local *lp = (struct smc_local *)dev->priv;
+
+	unregister_sysctl_table(lp->sysctl_header);
+}
+
+#endif /* endif CONFIG_SYSCTL */
+
+
+//---PHY CONTROL AND CONFIGURATION-----------------------------------------
+
+#if (SMC_DEBUG > 2 )
+
+/*------------------------------------------------------------
+ . Debugging function for viewing MII Management serial bitstream
+ .-------------------------------------------------------------*/
+static void smc_dump_mii_stream(byte* bits, int size)
+{
+	int i;
+
+	printk("BIT#:");
+	for (i = 0; i < size; ++i)
+		{
+		printk("%d", i%10);
+		}
+
+	printk("\nMDOE:");
+	for (i = 0; i < size; ++i)
+		{
+		if (bits[i] & MII_MDOE)
+			printk("1");
+		else
+			printk("0");
+		}
+
+	printk("\nMDO :");
+	for (i = 0; i < size; ++i)
+		{
+		if (bits[i] & MII_MDO)
+			printk("1");
+		else
+			printk("0");
+		}
+
+	printk("\nMDI :");
+	for (i = 0; i < size; ++i)
+		{
+		if (bits[i] & MII_MDI)
+			printk("1");
+		else
+			printk("0");
+		}
+
+	printk("\n");
+}
+#endif
+
+/*------------------------------------------------------------
+ . Reads a register from the MII Management serial interface
+ .-------------------------------------------------------------*/
+static word smc_read_phy_register(int ioaddr, byte phyaddr, byte phyreg)
+{
+	int oldBank;
+	int i;
+	byte mask;
+	word mii_reg;
+	byte bits[64];
+	int clk_idx = 0;
+	int input_idx;
+	word phydata;
+
+	// 32 consecutive ones on MDO to establish sync
+	for (i = 0; i < 32; ++i)
+		bits[clk_idx++] = MII_MDOE | MII_MDO;
+
+	// Start code <01>
+	bits[clk_idx++] = MII_MDOE;
+	bits[clk_idx++] = MII_MDOE | MII_MDO;
+
+	// Read command <10>
+	bits[clk_idx++] = MII_MDOE | MII_MDO;
+	bits[clk_idx++] = MII_MDOE;
+
+	// Output the PHY address, msb first
+	mask = (byte)0x10;
+	for (i = 0; i < 5; ++i)
+		{
+		if (phyaddr & mask)
+			bits[clk_idx++] = MII_MDOE | MII_MDO;
+		else
+			bits[clk_idx++] = MII_MDOE;
+
+		// Shift to next lowest bit
+		mask >>= 1;
+		}
+
+	// Output the phy register number, msb first
+	mask = (byte)0x10;
+	for (i = 0; i < 5; ++i)
+		{
+		if (phyreg & mask)
+			bits[clk_idx++] = MII_MDOE | MII_MDO;
+		else
+			bits[clk_idx++] = MII_MDOE;
+
+		// Shift to next lowest bit
+		mask >>= 1;
+		}
+
+	// Tristate and turnaround (2 bit times)
+	bits[clk_idx++] = 0;
+	//bits[clk_idx++] = 0;
+
+	// Input starts at this bit time
+	input_idx = clk_idx;
+
+	// Will input 16 bits
+	for (i = 0; i < 16; ++i)
+		bits[clk_idx++] = 0;
+
+	// Final clock bit
+	bits[clk_idx++] = 0;
+
+	// Save the current bank
+	oldBank = inw( ioaddr+BANK_SELECT );
+
+	// Select bank 3
+	SMC_SELECT_BANK( 3 );
+
+	// Get the current MII register value
+	mii_reg = inw( ioaddr+MII_REG );
+
+	// Turn off all MII Interface bits
+	mii_reg &= ~(MII_MDOE|MII_MCLK|MII_MDI|MII_MDO);
+
+	// Clock all 64 cycles
+	for (i = 0; i < sizeof bits; ++i)
+		{
+		// Clock Low - output data
+		outw( mii_reg | bits[i], ioaddr+MII_REG );
+		udelay(50);
+
+
+		// Clock Hi - input data
+		outw( mii_reg | bits[i] | MII_MCLK, ioaddr+MII_REG );
+		udelay(50);
+		bits[i] |= inw( ioaddr+MII_REG ) & MII_MDI;
+		}
+
+	// Return to idle state
+	// Set clock to low, data to low, and output tristated
+	outw( mii_reg, ioaddr+MII_REG );
+	udelay(50);
+
+	// Restore original bank select
+	SMC_SELECT_BANK( oldBank );
+
+	// Recover input data
+	phydata = 0;
+	for (i = 0; i < 16; ++i)
+		{
+		phydata <<= 1;
+
+		if (bits[input_idx++] & MII_MDI)
+			phydata |= 0x0001;
+		}
+
+#if (SMC_DEBUG > 2 )
+	printk("smc_read_phy_register(): phyaddr=%x,phyreg=%x,phydata=%x\n",
+		phyaddr, phyreg, phydata);
+	smc_dump_mii_stream(bits, sizeof bits);
+#endif
+
+	return(phydata);	
+}
+
+
+/*------------------------------------------------------------
+ . Writes a register to the MII Management serial interface
+ .-------------------------------------------------------------*/
+static void smc_write_phy_register(int ioaddr,
+	byte phyaddr, byte phyreg, word phydata)
+{
+	int oldBank;
+	int i;
+	word mask;
+	word mii_reg;
+	byte bits[65];
+	int clk_idx = 0;
+
+	// 32 consecutive ones on MDO to establish sync
+	for (i = 0; i < 32; ++i)
+		bits[clk_idx++] = MII_MDOE | MII_MDO;
+
+	// Start code <01>
+	bits[clk_idx++] = MII_MDOE;
+	bits[clk_idx++] = MII_MDOE | MII_MDO;
+
+	// Write command <01>
+	bits[clk_idx++] = MII_MDOE;
+	bits[clk_idx++] = MII_MDOE | MII_MDO;
+
+	// Output the PHY address, msb first
+	mask = (byte)0x10;
+	for (i = 0; i < 5; ++i)
+		{
+		if (phyaddr & mask)
+			bits[clk_idx++] = MII_MDOE | MII_MDO;
+		else
+			bits[clk_idx++] = MII_MDOE;
+
+		// Shift to next lowest bit
+		mask >>= 1;
+		}
+
+	// Output the phy register number, msb first
+	mask = (byte)0x10;
+	for (i = 0; i < 5; ++i)
+		{
+		if (phyreg & mask)
+			bits[clk_idx++] = MII_MDOE | MII_MDO;
+		else
+			bits[clk_idx++] = MII_MDOE;
+
+		// Shift to next lowest bit
+		mask >>= 1;
+		}
+
+	// Tristate and turnaround (2 bit times)
+	bits[clk_idx++] = 0;
+	bits[clk_idx++] = 0;
+
+	// Write out 16 bits of data, msb first
+	mask = 0x8000;
+	for (i = 0; i < 16; ++i)
+		{
+		if (phydata & mask)
+			bits[clk_idx++] = MII_MDOE | MII_MDO;
+		else
+			bits[clk_idx++] = MII_MDOE;
+
+		// Shift to next lowest bit
+		mask >>= 1;
+		}
+
+	// Final clock bit (tristate)
+	bits[clk_idx++] = 0;
+
+	// Save the current bank
+	oldBank = inw( ioaddr+BANK_SELECT );
+
+	// Select bank 3
+	SMC_SELECT_BANK( 3 );
+
+	// Get the current MII register value
+	mii_reg = inw( ioaddr+MII_REG );
+
+	// Turn off all MII Interface bits
+	mii_reg &= ~(MII_MDOE|MII_MCLK|MII_MDI|MII_MDO);
+
+	// Clock all cycles
+	for (i = 0; i < sizeof bits; ++i)
+		{
+		// Clock Low - output data
+		outw( mii_reg | bits[i], ioaddr+MII_REG );
+		udelay(50);
+
+
+		// Clock Hi - input data
+		outw( mii_reg | bits[i] | MII_MCLK, ioaddr+MII_REG );
+		udelay(50);
+		bits[i] |= inw( ioaddr+MII_REG ) & MII_MDI;
+		}
+
+	// Return to idle state
+	// Set clock to low, data to low, and output tristated
+	outw( mii_reg, ioaddr+MII_REG );
+	udelay(50);
+
+	// Restore original bank select
+	SMC_SELECT_BANK( oldBank );
+
+#if (SMC_DEBUG > 2 )
+	printk("smc_write_phy_register(): phyaddr=%x,phyreg=%x,phydata=%x\n",
+		phyaddr, phyreg, phydata);
+	smc_dump_mii_stream(bits, sizeof bits);
+#endif
+}
+
+
+/*------------------------------------------------------------
+ . Finds and reports the PHY address
+ .-------------------------------------------------------------*/
+static int smc_detect_phy(struct net_device* dev)
+{
+	struct smc_local *lp = (struct smc_local *)dev->priv;
+	int ioaddr = dev->base_addr;
+	word phy_id1 = 0;
+	word phy_id2 = 0;
+	int phyaddr;
+	int found = 0;
+
+	PRINTK3("%s:smc_detect_phy()\n", dev->name);
+
+	// Scan all 32 PHY addresses if necessary
+	for (phyaddr = 0; phyaddr < 32; ++phyaddr)
+		{
+		// Read the PHY identifiers
+		phy_id1  = smc_read_phy_register(ioaddr, phyaddr, PHY_ID1_REG);
+		phy_id2  = smc_read_phy_register(ioaddr, phyaddr, PHY_ID2_REG);
+
+		PRINTK3("%s: phy_id1=%x, phy_id2=%x\n",
+			dev->name, phy_id1, phy_id2);
+
+		// Make sure it is a valid identifier	
+		if ((phy_id2 > 0x0000) && (phy_id2 < 0xffff) &&
+		    (phy_id1 > 0x0000) && (phy_id1 < 0xffff))
+			{
+			if ((phy_id1 != 0x8000) && (phy_id2 != 0x8000))
+				{
+				// Save the PHY's address
+				lp->phyaddr = phyaddr;
+				found = 1;
+				break;
+				}
+			}
+		}
+
+	if (!found)
+		{
+		PRINTK("%s: No PHY found\n", dev->name);
+		return(0);
+		}
+
+	// Set the PHY type
+	if ( (phy_id1 == 0x0016) && ((phy_id2 & 0xFFF0) == 0xF840 ) )
+		{
+		lp->phytype = PHY_LAN83C183;
+		PRINTK("%s: PHY=LAN83C183 (LAN91C111 Internal)\n", dev->name);
+		}
+
+	if ( (phy_id1 == 0x0282) && ((phy_id2 & 0xFFF0) == 0x1C50) )
+		{
+		lp->phytype = PHY_LAN83C180;
+		PRINTK("%s: PHY=LAN83C180\n", dev->name);
+		}
+
+	return(1);
+}
+
+/*------------------------------------------------------------
+ . Waits the specified number of milliseconds - kernel friendly
+ .-------------------------------------------------------------*/
+static void smc_wait_ms(unsigned int ms)
+{
+
+	if (!in_interrupt())
+		{
+		current->state = TASK_UNINTERRUPTIBLE;
+		schedule_timeout(1 + ms * HZ / 1000);
+		}
+	else
+		{
+		current->state = TASK_INTERRUPTIBLE;
+		schedule_timeout(1 + ms * HZ / 1000);
+		current->state = TASK_RUNNING;
+		}
+}
+
+/*------------------------------------------------------------
+ . Sets the PHY to a configuration as determined by the user
+ .-------------------------------------------------------------*/
+static int smc_phy_fixed(struct net_device* dev)
+{
+	int ioaddr = dev->base_addr;
+	struct smc_local *lp = (struct smc_local *)dev->priv;
+	byte phyaddr = lp->phyaddr;
+	word my_fixed_caps;
+	word cfg1;
+
+	PRINTK3("%s:smc_phy_fixed()\n", dev->name);
+
+	// Enter Link Disable state
+	cfg1 = smc_read_phy_register(ioaddr, phyaddr, PHY_CFG1_REG);
+	cfg1 |= PHY_CFG1_LNKDIS;
+	smc_write_phy_register(ioaddr, phyaddr, PHY_CFG1_REG, cfg1);
+
+	// Set our fixed capabilities
+	// Disable auto-negotiation
+	my_fixed_caps = 0;
+
+	if (lp->ctl_rfduplx)
+		my_fixed_caps |= PHY_CNTL_DPLX;
+
+	if (lp->ctl_rspeed == 100)
+		my_fixed_caps |= PHY_CNTL_SPEED;
+
+	// Write our capabilities to the phy control register
+	smc_write_phy_register(ioaddr, phyaddr, PHY_CNTL_REG, my_fixed_caps);
+
+	// Re-Configure the Receive/Phy Control register
+	outw( lp->rpc_cur_mode, ioaddr + RPC_REG );
+
+	// Success
+	return(1);
+}
+
+
+/*------------------------------------------------------------
+ . Configures the specified PHY using Autonegotiation. Calls
+ . smc_phy_fixed() if the user has requested a certain config.
+ .-------------------------------------------------------------*/
+static void smc_phy_configure(struct net_device* dev)
+{
+	int ioaddr = dev->base_addr;
+	struct smc_local *lp = (struct smc_local *)dev->priv;
+	int timeout;
+	byte phyaddr;
+	word my_phy_caps; // My PHY capabilities
+	word my_ad_caps; // My Advertised capabilities
+	word status;
+	int failed = 0;
+
+	PRINTK3("%s:smc_program_phy()\n", dev->name);
+
+	// Set the blocking flag
+	lp->autoneg_active = 1;
+
+	// Find the address and type of our phy
+	if (!smc_detect_phy(dev))
+		{
+		goto smc_phy_configure_exit;
+		}
+
+	// Get the detected phy address
+	phyaddr = lp->phyaddr;
+
+	// Reset the PHY, setting all other bits to zero
+	smc_write_phy_register(ioaddr, phyaddr, PHY_CNTL_REG, PHY_CNTL_RST);
+
+	// Wait for the reset to complete, or time out
+	timeout = 6; // Wait up to 3 seconds
+	while (timeout--)
+		{
+		if (!(smc_read_phy_register(ioaddr, phyaddr, PHY_CNTL_REG)
+		    & PHY_CNTL_RST))
+			{
+			// reset complete
+			break;
+			}
+
+		smc_wait_ms(500); // wait 500 millisecs
+		if (signal_pending(current)) // Exit anyway if signaled
+			{
+			PRINTK2("%s:PHY reset interrupted by signal\n",
+				dev->name);
+			timeout = 0;
+			break;
+			}
+		}
+
+	if (timeout < 1)
+		{
+		PRINTK2("%s:PHY reset timed out\n", dev->name);
+		goto smc_phy_configure_exit;
+		}
+
+	// Read PHY Register 18, Status Output
+	lp->lastPhy18 = smc_read_phy_register(ioaddr, phyaddr, PHY_INT_REG);
+
+	// Enable PHY Interrupts (for register 18)
+	// Interrupts listed here are disabled
+	smc_write_phy_register(ioaddr, phyaddr, PHY_MASK_REG, 
+		PHY_INT_LOSSSYNC | PHY_INT_CWRD | PHY_INT_SSD |
+		PHY_INT_ESD | PHY_INT_RPOL | PHY_INT_JAB |
+		PHY_INT_SPDDET | PHY_INT_DPLXDET);
+
+	/* Configure the Receive/Phy Control register */
+	SMC_SELECT_BANK( 0 );
+	outw( lp->rpc_cur_mode, ioaddr + RPC_REG );
+
+	// Copy our capabilities from PHY_STAT_REG to PHY_AD_REG
+	my_phy_caps = smc_read_phy_register(ioaddr, phyaddr, PHY_STAT_REG);
+	my_ad_caps  = PHY_AD_CSMA; // I am CSMA capable
+
+	if (my_phy_caps & PHY_STAT_CAP_T4)
+		my_ad_caps |= PHY_AD_T4;
+
+	if (my_phy_caps & PHY_STAT_CAP_TXF)
+		my_ad_caps |= PHY_AD_TX_FDX;
+
+	if (my_phy_caps & PHY_STAT_CAP_TXH)
+		my_ad_caps |= PHY_AD_TX_HDX;
+
+	if (my_phy_caps & PHY_STAT_CAP_TF)
+		my_ad_caps |= PHY_AD_10_FDX;
+
+	if (my_phy_caps & PHY_STAT_CAP_TH)
+		my_ad_caps |= PHY_AD_10_HDX;
+
+	// Disable capabilities not selected by our user
+	if (lp->ctl_rspeed != 100)
+		{
+		my_ad_caps &= ~(PHY_AD_T4|PHY_AD_TX_FDX|PHY_AD_TX_HDX);
+		}
+
+	if (!lp->ctl_rfduplx)
+		{
+		my_ad_caps &= ~(PHY_AD_TX_FDX|PHY_AD_10_FDX);
+		}
+
+	// Update our Auto-Neg Advertisement Register
+	smc_write_phy_register(ioaddr, phyaddr, PHY_AD_REG, my_ad_caps);
+
+	PRINTK2("%s:phy caps=%x\n", dev->name, my_phy_caps);
+	PRINTK2("%s:phy advertised caps=%x\n", dev->name, my_ad_caps);
+
+	// If the user requested no auto neg, then go set his request
+	if (!(lp->ctl_autoneg))
+		{
+		smc_phy_fixed(dev);
+		goto smc_phy_configure_exit;
+		}
+
+	// Restart auto-negotiation process in order to advertise my caps
+	smc_write_phy_register( ioaddr, phyaddr, PHY_CNTL_REG,
+		PHY_CNTL_ANEG_EN | PHY_CNTL_ANEG_RST );
+
+	// Wait for the auto-negotiation to complete.  This may take from
+	// 2 to 3 seconds.
+	// Wait for the reset to complete, or time out
+	timeout = 20; // Wait up to 10 seconds
+	while (timeout--)
+		{
+		status = smc_read_phy_register(ioaddr, phyaddr, PHY_STAT_REG);
+		if (status & PHY_STAT_ANEG_ACK)
+			{
+			// auto-negotiate complete
+			break;
+			}
+
+		smc_wait_ms(500); // wait 500 millisecs
+		if (signal_pending(current)) // Exit anyway if signaled
+			{
+			printk(KERN_DEBUG
+				"%s:PHY auto-negotiate interrupted by signal\n",
+				dev->name);
+			timeout = 0;
+			break;
+			}
+	PRINTK3("%s:phy phy_fixed\n", dev->name);
+
+
+		// Restart auto-negotiation if remote fault
+		if (status & PHY_STAT_REM_FLT)
+			{
+			PRINTK2("%s:PHY remote fault detected\n", dev->name);
+
+			// Restart auto-negotiation
+			PRINTK2("%s:PHY restarting auto-negotiation\n",
+				dev->name);
+			smc_write_phy_register( ioaddr, phyaddr, PHY_CNTL_REG,
+				PHY_CNTL_ANEG_EN | PHY_CNTL_ANEG_RST |
+				PHY_CNTL_SPEED | PHY_CNTL_DPLX);
+			}
+		}
+
+	if (timeout < 1)
+		{
+		printk(KERN_DEBUG "%s:PHY auto-negotiate timed out\n",
+			dev->name);
+		PRINTK2("%s:PHY auto-negotiate timed out\n", dev->name);
+		failed = 1;
+		}
+
+	// Fail if we detected an auto-negotiate remote fault
+	if (status & PHY_STAT_REM_FLT)
+		{
+		printk(KERN_DEBUG "%s:PHY remote fault detected\n", dev->name);
+		PRINTK2("%s:PHY remote fault detected\n", dev->name);
+		failed = 1;
+		}
+
+	// The smc_phy_interrupt() routine will be called to update lastPhy18
+
+	// Set our sysctl parameters to match auto-negotiation results
+	if ( lp->lastPhy18 & PHY_INT_SPDDET )
+		{
+		PRINTK2("%s:PHY 100BaseT\n", dev->name);
+		lp->rpc_cur_mode |= RPC_SPEED;
+		}
+	else
+		{
+		PRINTK2("%s:PHY 10BaseT\n", dev->name);
+		lp->rpc_cur_mode &= ~RPC_SPEED;
+		}
+
+	if ( lp->lastPhy18 & PHY_INT_DPLXDET )
+		{
+		PRINTK2("%s:PHY Full Duplex\n", dev->name);
+		lp->rpc_cur_mode |= RPC_DPLX;
+		}
+	else
+		{
+		PRINTK2("%s:PHY Half Duplex\n", dev->name);
+		lp->rpc_cur_mode &= ~RPC_DPLX;
+		}
+
+	// Re-Configure the Receive/Phy Control register
+	outw( lp->rpc_cur_mode, ioaddr + RPC_REG );
+
+  smc_phy_configure_exit:
+
+	// Exit auto-negotiation
+	lp->autoneg_active = 0;
+}
+
+
+
+/*************************************************************************
+ . smc_phy_interrupt
+ .
+ . Purpose:  Handle interrupts relating to PHY register 18. This is
+ .  called from the "hard" interrupt handler.
+ .
+ ************************************************************************/
+static void smc_phy_interrupt(struct net_device* dev)
+{
+	int ioaddr 		= dev->base_addr;
+	struct smc_local *lp 	= (struct smc_local *)dev->priv;
+	byte phyaddr = lp->phyaddr;
+	word phy18;
+
+	PRINTK2("%s: smc_phy_interrupt\n", dev->name);
+
+  while (1)
+	{ 
+	// Read PHY Register 18, Status Output
+	phy18 = smc_read_phy_register(ioaddr, phyaddr, PHY_INT_REG);
+
+	// Exit if not more changes
+	if (phy18 == lp->lastPhy18)
+		break;
+
+#if (SMC_DEBUG > 1 )
+
+	PRINTK2("%s:     phy18=0x%x\n", dev->name, phy18);
+	PRINTK2("%s: lastPhy18=0x%x\n", dev->name, lp->lastPhy18);
+
+	// Handle events
+	if ((phy18 & PHY_INT_LNKFAIL) != (lp->lastPhy18 & PHY_INT_LNKFAIL))
+		{
+		PRINTK2("%s: PHY Link Fail=%x\n", dev->name,
+			phy18 & PHY_INT_LNKFAIL);
+		}
+
+	if ((phy18 & PHY_INT_LOSSSYNC) != (lp->lastPhy18 & PHY_INT_LOSSSYNC))
+		{
+		PRINTK2("%s: PHY LOSS SYNC=%x\n", dev->name,
+			phy18 & PHY_INT_LOSSSYNC);
+		}
+
+	if ((phy18 & PHY_INT_CWRD) != (lp->lastPhy18 & PHY_INT_CWRD))
+		{
+		PRINTK2("%s: PHY INVALID 4B5B code=%x\n", dev->name,
+			phy18 & PHY_INT_CWRD);
+		}
+
+	if ((phy18 & PHY_INT_SSD) != (lp->lastPhy18 & PHY_INT_SSD))
+		{
+		PRINTK2("%s: PHY No Start Of Stream=%x\n", dev->name,
+			phy18 & PHY_INT_SSD);
+		}
+
+	if ((phy18 & PHY_INT_ESD) != (lp->lastPhy18 & PHY_INT_ESD))
+		{
+		PRINTK2("%s: PHY No End Of Stream=%x\n", dev->name,
+			phy18 & PHY_INT_ESD);
+		}
+
+	if ((phy18 & PHY_INT_RPOL) != (lp->lastPhy18 & PHY_INT_RPOL))
+		{
+		PRINTK2("%s: PHY Reverse Polarity Detected=%x\n", dev->name,
+			phy18 & PHY_INT_RPOL);
+		}
+
+	if ((phy18 & PHY_INT_JAB) != (lp->lastPhy18 & PHY_INT_JAB))
+		{
+		PRINTK2("%s: PHY Jabber Detected=%x\n", dev->name,
+			phy18 & PHY_INT_JAB);
+		}
+
+	if ((phy18 & PHY_INT_SPDDET) != (lp->lastPhy18 & PHY_INT_SPDDET))
+		{
+		PRINTK2("%s: PHY Speed Detect=%x\n", dev->name,
+			phy18 & PHY_INT_SPDDET);
+		}
+
+	if ((phy18 & PHY_INT_DPLXDET) != (lp->lastPhy18 & PHY_INT_DPLXDET))
+		{
+		PRINTK2("%s: PHY Duplex Detect=%x\n", dev->name,
+			phy18 & PHY_INT_DPLXDET);
+		}
+#endif
+
+	// Update the last phy 18 variable
+	lp->lastPhy18 = phy18;
+
+	} // end while
+}
+
+
diff -ruN linux-2.6.7.org/arch/m32r/drivers/smc91111.copying linux-2.6.7/arch/m32r/drivers/smc91111.copying
--- linux-2.6.7.org/arch/m32r/drivers/smc91111.copying	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/drivers/smc91111.copying	2004-03-16 22:11:26.000000000 +0900
@@ -0,0 +1,352 @@
+
+   NOTE! This copyright does *not* cover user programs that use kernel
+ services by normal system calls - this is merely considered normal use
+ of the kernel, and does *not* fall under the heading of "derived work".
+ Also note that the GPL below is copyrighted by the Free Software
+ Foundation, but the instance of code that it refers to (the Linux
+ kernel) is copyrighted by me and others who actually wrote it.
+
+			Linus Torvalds
+
+----------------------------------------
+
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) 19yy  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) 19yy name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
diff -ruN linux-2.6.7.org/arch/m32r/drivers/smc91111.h linux-2.6.7/arch/m32r/drivers/smc91111.h
--- linux-2.6.7.org/arch/m32r/drivers/smc91111.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/drivers/smc91111.h	2003-09-09 10:15:02.000000000 +0900
@@ -0,0 +1,570 @@
+/*------------------------------------------------------------------------
+ . smc91111.h - macros for the LAN91C111 Ethernet Driver
+ .
+ . Copyright (C) 2001 Standard Microsystems Corporation (SMSC)
+ .       Developed by Simple Network Magic Corporation (SNMC)
+ . Copyright (C) 1996 by Erik Stahlman (ES)
+ .
+ . This program is free software; you can redistribute it and/or modify
+ . it under the terms of the GNU General Public License as published by
+ . the Free Software Foundation; either version 2 of the License, or
+ . (at your option) any later version.
+ .
+ . This program is distributed in the hope that it will be useful,
+ . but WITHOUT ANY WARRANTY; without even the implied warranty of
+ . MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ . GNU General Public License for more details.
+ .
+ . You should have received a copy of the GNU General Public License
+ . along with this program; if not, write to the Free Software
+ . Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ .
+ . This file contains register information and access macros for 
+ . the LAN91C111 single chip ethernet controller.  It is a modified
+ . version of the smc9194.h file.
+ . 
+ . Information contained in this file was obtained from the LAN91C111
+ . manual from SMC.  To get a copy, if you really want one, you can find 
+ . information under www.smsc.com.
+ . 
+ . Authors
+ . 	Erik Stahlman				( erik@vt.edu )
+ .	Daris A Nevil				( dnevil@snmc.com )
+ .
+ . History
+ . 03/16/01		Daris A Nevil	Modified for use with LAN91C111 device
+ .
+ ---------------------------------------------------------------------------*/
+#ifndef _SMC91111_H_
+#define _SMC91111_H_
+
+/* I want some simple types */
+
+typedef unsigned char			byte;
+typedef unsigned short			word;
+typedef unsigned long int 		dword;
+
+
+/* Because of bank switching, the LAN91xxx uses only 16 I/O ports */
+
+#define SMC_IO_EXTENT	16
+
+
+/*---------------------------------------------------------------
+ .  
+ . A description of the SMSC registers is probably in order here,
+ . although for details, the SMC datasheet is invaluable.  
+ . 
+ . Basically, the chip has 4 banks of registers ( 0 to 3 ), which
+ . are accessed by writing a number into the BANK_SELECT register
+ . ( I also use a SMC_SELECT_BANK macro for this ).
+ . 
+ . The banks are configured so that for most purposes, bank 2 is all
+ . that is needed for simple run time tasks.  
+ -----------------------------------------------------------------------*/
+
+/*
+ . Bank Select Register: 
+ .
+ .		yyyy yyyy 0000 00xx  
+ .		xx 		= bank number
+ .		yyyy yyyy	= 0x33, for identification purposes.
+*/
+#define	BANK_SELECT		14
+
+// Transmit Control Register
+/* BANK 0  */
+#define	TCR_REG 	0x0000 	// transmit control register 
+#define TCR_ENABLE	0x0001	// When 1 we can transmit
+#define TCR_LOOP	0x0002	// Controls output pin LBK
+#define TCR_FORCOL	0x0004	// When 1 will force a collision
+#define TCR_PAD_EN	0x0080	// When 1 will pad tx frames < 64 bytes w/0
+#define TCR_NOCRC	0x0100	// When 1 will not append CRC to tx frames
+#define TCR_MON_CSN	0x0400	// When 1 tx monitors carrier
+#define TCR_FDUPLX    	0x0800  // When 1 enables full duplex operation
+#define TCR_STP_SQET	0x1000	// When 1 stops tx if Signal Quality Error
+#define	TCR_EPH_LOOP	0x2000	// When 1 enables EPH block loopback
+#define	TCR_SWFDUP	0x8000	// When 1 enables Switched Full Duplex mode
+
+#define	TCR_CLEAR	0	/* do NOTHING */
+/* the default settings for the TCR register : */ 
+/* QUESTION: do I want to enable padding of short packets ? */
+#define	TCR_DEFAULT  	TCR_ENABLE 
+
+
+// EPH Status Register
+/* BANK 0  */
+#define EPH_STATUS_REG	0x0002
+#define ES_TX_SUC	0x0001	// Last TX was successful
+#define ES_SNGL_COL	0x0002	// Single collision detected for last tx
+#define ES_MUL_COL	0x0004	// Multiple collisions detected for last tx
+#define ES_LTX_MULT	0x0008	// Last tx was a multicast
+#define ES_16COL	0x0010	// 16 Collisions Reached
+#define ES_SQET		0x0020	// Signal Quality Error Test
+#define ES_LTXBRD	0x0040	// Last tx was a broadcast
+#define ES_TXDEFR	0x0080	// Transmit Deferred
+#define ES_LATCOL	0x0200	// Late collision detected on last tx
+#define ES_LOSTCARR	0x0400	// Lost Carrier Sense
+#define ES_EXC_DEF	0x0800	// Excessive Deferral
+#define ES_CTR_ROL	0x1000	// Counter Roll Over indication
+#define ES_LINK_OK	0x4000	// Driven by inverted value of nLNK pin
+#define ES_TXUNRN	0x8000	// Tx Underrun
+
+
+// Receive Control Register
+/* BANK 0  */
+#define	RCR_REG		0x0004
+#define	RCR_RX_ABORT	0x0001	// Set if a rx frame was aborted
+#define	RCR_PRMS	0x0002	// Enable promiscuous mode
+#define	RCR_ALMUL	0x0004	// When set accepts all multicast frames
+#define RCR_RXEN	0x0100	// IFF this is set, we can receive packets
+#define	RCR_STRIP_CRC	0x0200	// When set strips CRC from rx packets
+#define	RCR_ABORT_ENB	0x0200	// When set will abort rx on collision 
+#define	RCR_FILT_CAR	0x0400	// When set filters leading 12 bit s of carrier
+#define RCR_SOFTRST	0x8000 	// resets the chip
+
+/* the normal settings for the RCR register : */
+#define	RCR_DEFAULT	(RCR_STRIP_CRC | RCR_RXEN)
+#define RCR_CLEAR	0x0	// set it to a base state
+
+// Counter Register
+/* BANK 0  */
+#define	COUNTER_REG	0x0006
+
+// Memory Information Register
+/* BANK 0  */
+#define	MIR_REG		0x0008
+
+// Receive/Phy Control Register
+/* BANK 0  */
+#define	RPC_REG		0x000A
+#define	RPC_SPEED	0x2000	// When 1 PHY is in 100Mbps mode.
+#define	RPC_DPLX	0x1000	// When 1 PHY is in Full-Duplex Mode
+#define	RPC_ANEG	0x0800	// When 1 PHY is in Auto-Negotiate Mode
+#define	RPC_LSXA_SHFT	5	// Bits to shift LS2A,LS1A,LS0A to lsb
+#define	RPC_LSXB_SHFT	2	// Bits to get LS2B,LS1B,LS0B to lsb
+#define RPC_LED_100_10	(0x00)	// LED = 100Mbps OR's with 10Mbps link detect
+#define RPC_LED_RES	(0x01)	// LED = Reserved
+#define RPC_LED_10	(0x02)	// LED = 10Mbps link detect
+#define RPC_LED_FD	(0x03)	// LED = Full Duplex Mode
+#define RPC_LED_TX_RX	(0x04)	// LED = TX or RX packet occurred
+#define RPC_LED_100	(0x05)	// LED = 100Mbps link dectect
+#define RPC_LED_TX	(0x06)	// LED = TX packet occurred
+#define RPC_LED_RX	(0x07)	// LED = RX packet occurred
+#if defined(__m32r__)
+#define RPC_DEFAULT (RPC_ANEG | (RPC_LED_TX_RX << RPC_LSXA_SHFT) | (RPC_LED_100_10 << RPC_LSXB_SHFT) | RPC_SPEED | RPC_DPLX)
+#else
+#define RPC_DEFAULT (RPC_ANEG | (RPC_LED_100 << RPC_LSXA_SHFT) | (RPC_LED_FD << RPC_LSXB_SHFT) | RPC_SPEED | RPC_DPLX)
+#endif
+
+/* Bank 0 0x000C is reserved */
+
+// Bank Select Register
+/* All Banks */
+#define BSR_REG	0x000E
+
+
+// Configuration Reg
+/* BANK 1 */
+#define CONFIG_REG	0x0000
+#define CONFIG_EXT_PHY	0x0200	// 1=external MII, 0=internal Phy
+#define CONFIG_GPCNTRL	0x0400	// Inverse value drives pin nCNTRL
+#define CONFIG_NO_WAIT	0x1000	// When 1 no extra wait states on ISA bus
+#define CONFIG_EPH_POWER_EN 0x8000 // When 0 EPH is placed into low power mode.
+
+// Default is powered-up, Internal Phy, Wait States, and pin nCNTRL=low
+#define CONFIG_DEFAULT	(CONFIG_EPH_POWER_EN)
+
+
+// Base Address Register
+/* BANK 1 */
+#define	BASE_REG	0x0002
+
+
+// Individual Address Registers
+/* BANK 1 */
+#define	ADDR0_REG	0x0004
+#define	ADDR1_REG	0x0006
+#define	ADDR2_REG	0x0008
+
+
+// General Purpose Register
+/* BANK 1 */
+#define	GP_REG		0x000A
+
+
+// Control Register
+/* BANK 1 */
+#define	CTL_REG		0x000C
+#define CTL_RCV_BAD	0x4000 // When 1 bad CRC packets are received
+#define CTL_AUTO_RELEASE 0x0800 // When 1 tx pages are released automatically
+#define	CTL_LE_ENABLE	0x0080 // When 1 enables Link Error interrupt
+#define	CTL_CR_ENABLE	0x0040 // When 1 enables Counter Rollover interrupt
+#define	CTL_TE_ENABLE	0x0020 // When 1 enables Transmit Error interrupt
+#define	CTL_EEPROM_SELECT 0x0004 // Controls EEPROM reload & store
+#define	CTL_RELOAD	0x0002 // When set reads EEPROM into registers
+#define	CTL_STORE	0x0001 // When set stores registers into EEPROM
+
+
+// MMU Command Register
+/* BANK 2 */
+#define MMU_CMD_REG	0x0000
+#define MC_BUSY		1	// When 1 the last release has not completed
+#define MC_NOP		(0<<5)	// No Op
+#define	MC_ALLOC	(1<<5) 	// OR with number of 256 byte packets
+#define	MC_RESET	(2<<5)	// Reset MMU to initial state
+#define	MC_REMOVE	(3<<5) 	// Remove the current rx packet
+#define MC_RELEASE  	(4<<5) 	// Remove and release the current rx packet
+#define MC_FREEPKT  	(5<<5) 	// Release packet in PNR register
+#define MC_ENQUEUE	(6<<5)	// Enqueue the packet for transmit
+#define MC_RSTTXFIFO	(7<<5)	// Reset the TX FIFOs
+
+
+// Packet Number Register
+/* BANK 2 */
+#define	PN_REG		0x0002
+
+
+// Allocation Result Register
+/* BANK 2 */
+#define	AR_REG		0x0003
+#define AR_FAILED	0x80	// Alocation Failed
+
+
+// RX FIFO Ports Register
+/* BANK 2 */
+#define RXFIFO_REG	0x0004	// Must be read as a word
+#define RXFIFO_REMPTY	0x8000	// RX FIFO Empty
+
+
+// TX FIFO Ports Register
+/* BANK 2 */
+#define TXFIFO_REG	RXFIFO_REG	// Must be read as a word
+#define TXFIFO_TEMPTY	0x80	// TX FIFO Empty
+
+
+// Pointer Register
+/* BANK 2 */
+#define PTR_REG		0x0006
+#define	PTR_RCV		0x8000 // 1=Receive area, 0=Transmit area
+#define	PTR_AUTOINC 	0x4000 // Auto increment the pointer on each access
+#define PTR_READ	0x2000 // When 1 the operation is a read
+
+
+// Data Register
+/* BANK 2 */
+#define	DATA_REG	0x0008
+
+
+// Interrupt Status/Acknowledge Register
+/* BANK 2 */
+#define	INT_REG		0x000C
+
+
+// Interrupt Mask Register
+/* BANK 2 */
+#define IM_REG		0x000D
+#define	IM_MDINT	0x80 // PHY MI Register 18 Interrupt
+#define	IM_ERCV_INT	0x40 // Early Receive Interrupt
+#define	IM_EPH_INT	0x20 // Set by Etheret Protocol Handler section
+#define	IM_RX_OVRN_INT	0x10 // Set by Receiver Overruns
+#define	IM_ALLOC_INT	0x08 // Set when allocation request is completed
+#define	IM_TX_EMPTY_INT	0x04 // Set if the TX FIFO goes empty
+#define	IM_TX_INT	0x02 // Transmit Interrrupt
+#define IM_RCV_INT	0x01 // Receive Interrupt
+
+
+// Multicast Table Registers
+/* BANK 3 */
+#define	MCAST_REG1	0x0000
+#define	MCAST_REG2	0x0002
+#define	MCAST_REG3	0x0004
+#define	MCAST_REG4	0x0006
+
+
+// Management Interface Register (MII)
+/* BANK 3 */
+#define	MII_REG		0x0008
+#define MII_MSK_CRS100	0x4000 // Disables CRS100 detection during tx half dup
+#define MII_MDOE	0x0008 // MII Output Enable
+#define MII_MCLK	0x0004 // MII Clock, pin MDCLK
+#define MII_MDI		0x0002 // MII Input, pin MDI
+#define MII_MDO		0x0001 // MII Output, pin MDO
+
+
+// Revision Register
+/* BANK 3 */
+#define	REV_REG		0x000A /* ( hi: chip id   low: rev # ) */
+
+
+// Early RCV Register
+/* BANK 3 */
+/* this is NOT on SMC9192 */
+#define	ERCV_REG	0x000C
+#define ERCV_RCV_DISCRD	0x0080 // When 1 discards a packet being received
+#define ERCV_THRESHOLD	0x001F // ERCV Threshold Mask
+
+// External Register
+/* BANK 7 */
+#define	EXT_REG		0x0000
+
+
+#define CHIP_9192	3
+#define CHIP_9194	4
+#define CHIP_9195	5
+#define CHIP_9196	6
+#define CHIP_91100	7
+#define CHIP_91100FD	8
+#define CHIP_91111FD	9
+
+static const char * chip_ids[ 15 ] =  { 
+	NULL, NULL, NULL, 
+	/* 3 */ "SMC91C90/91C92",
+	/* 4 */ "SMC91C94",
+	/* 5 */ "SMC91C95",
+	/* 6 */ "SMC91C96",
+	/* 7 */ "SMC91C100", 
+	/* 8 */ "SMC91C100FD", 
+	/* 9 */ "SMC91C11xFD", 
+	NULL, NULL, 
+	NULL, NULL, NULL};  
+
+/* 
+ . Transmit status bits 
+*/
+#define TS_SUCCESS 0x0001
+#define TS_LOSTCAR 0x0400
+#define TS_LATCOL  0x0200
+#define TS_16COL   0x0010
+
+/*
+ . Receive status bits
+*/
+#define RS_ALGNERR	0x8000
+#define RS_BRODCAST	0x4000
+#define RS_BADCRC	0x2000
+#define RS_ODDFRAME	0x1000	// bug: the LAN91C111 never sets this on receive
+#define RS_TOOLONG	0x0800
+#define RS_TOOSHORT	0x0400
+#define RS_MULTICAST	0x0001
+#define RS_ERRORS	(RS_ALGNERR | RS_BADCRC | RS_TOOLONG | RS_TOOSHORT) 
+
+
+// PHY Types
+enum {
+	PHY_LAN83C183 = 1,	// LAN91C111 Internal PHY
+	PHY_LAN83C180
+};
+
+
+// PHY Register Addresses (LAN91C111 Internal PHY)
+
+// PHY Control Register
+#define PHY_CNTL_REG		0x00
+#define PHY_CNTL_RST		0x8000	// 1=PHY Reset
+#define PHY_CNTL_LPBK		0x4000	// 1=PHY Loopback
+#define PHY_CNTL_SPEED		0x2000	// 1=100Mbps, 0=10Mpbs
+#define PHY_CNTL_ANEG_EN	0x1000 // 1=Enable Auto negotiation
+#define PHY_CNTL_PDN		0x0800	// 1=PHY Power Down mode
+#define PHY_CNTL_MII_DIS	0x0400	// 1=MII 4 bit interface disabled
+#define PHY_CNTL_ANEG_RST	0x0200 // 1=Reset Auto negotiate
+#define PHY_CNTL_DPLX		0x0100	// 1=Full Duplex, 0=Half Duplex
+#define PHY_CNTL_COLTST		0x0080	// 1= MII Colision Test
+
+// PHY Status Register
+#define PHY_STAT_REG		0x01
+#define PHY_STAT_CAP_T4		0x8000	// 1=100Base-T4 capable
+#define PHY_STAT_CAP_TXF	0x4000	// 1=100Base-X full duplex capable
+#define PHY_STAT_CAP_TXH	0x2000	// 1=100Base-X half duplex capable
+#define PHY_STAT_CAP_TF		0x1000	// 1=10Mbps full duplex capable
+#define PHY_STAT_CAP_TH		0x0800	// 1=10Mbps half duplex capable
+#define PHY_STAT_CAP_SUPR	0x0040	// 1=recv mgmt frames with not preamble
+#define PHY_STAT_ANEG_ACK	0x0020	// 1=ANEG has completed
+#define PHY_STAT_REM_FLT	0x0010	// 1=Remote Fault detected
+#define PHY_STAT_CAP_ANEG	0x0008	// 1=Auto negotiate capable
+#define PHY_STAT_LINK		0x0004	// 1=valid link
+#define PHY_STAT_JAB		0x0002	// 1=10Mbps jabber condition
+#define PHY_STAT_EXREG		0x0001	// 1=extended registers implemented
+
+// PHY Identifier Registers
+#define PHY_ID1_REG		0x02	// PHY Identifier 1
+#define PHY_ID2_REG		0x03	// PHY Identifier 2
+
+// PHY Auto-Negotiation Advertisement Register
+#define PHY_AD_REG		0x04
+#define PHY_AD_NP		0x8000	// 1=PHY requests exchange of Next Page
+#define PHY_AD_ACK		0x4000	// 1=got link code word from remote
+#define PHY_AD_RF		0x2000	// 1=advertise remote fault
+#define PHY_AD_T4		0x0200	// 1=PHY is capable of 100Base-T4
+#define PHY_AD_TX_FDX		0x0100	// 1=PHY is capable of 100Base-TX FDPLX
+#define PHY_AD_TX_HDX		0x0080	// 1=PHY is capable of 100Base-TX HDPLX
+#define PHY_AD_10_FDX		0x0040	// 1=PHY is capable of 10Base-T FDPLX
+#define PHY_AD_10_HDX		0x0020	// 1=PHY is capable of 10Base-T HDPLX
+#define PHY_AD_CSMA		0x0001	// 1=PHY is capable of 802.3 CMSA
+
+// PHY Auto-negotiation Remote End Capability Register
+#define PHY_RMT_REG		0x05
+// Uses same bit definitions as PHY_AD_REG
+
+// PHY Configuration Register 1
+#define PHY_CFG1_REG		0x10
+#define PHY_CFG1_LNKDIS		0x8000	// 1=Rx Link Detect Function disabled
+#define PHY_CFG1_XMTDIS		0x4000	// 1=TP Transmitter Disabled
+#define PHY_CFG1_XMTPDN		0x2000	// 1=TP Transmitter Powered Down
+#define PHY_CFG1_BYPSCR		0x0400	// 1=Bypass scrambler/descrambler
+#define PHY_CFG1_UNSCDS		0x0200	// 1=Unscramble Idle Reception Disable
+#define PHY_CFG1_EQLZR		0x0100	// 1=Rx Equalizer Disabled
+#define PHY_CFG1_CABLE		0x0080	// 1=STP(150ohm), 0=UTP(100ohm)
+#define PHY_CFG1_RLVL0		0x0040	// 1=Rx Squelch level reduced by 4.5db
+#define PHY_CFG1_TLVL_SHIFT	2	// Transmit Output Level Adjust
+#define PHY_CFG1_TLVL_MASK	0x003C
+#define PHY_CFG1_TRF_MASK	0x0003	// Transmitter Rise/Fall time
+
+
+// PHY Configuration Register 2
+#define PHY_CFG2_REG		0x11
+#define PHY_CFG2_APOLDIS	0x0020	// 1=Auto Polarity Correction disabled
+#define PHY_CFG2_JABDIS		0x0010	// 1=Jabber disabled
+#define PHY_CFG2_MREG		0x0008	// 1=Multiple register access (MII mgt)
+#define PHY_CFG2_INTMDIO	0x0004	// 1=Interrupt signaled with MDIO pulseo
+
+// PHY Status Output (and Interrupt status) Register
+#define PHY_INT_REG		0x12	// Status Output (Interrupt Status)
+#define PHY_INT_INT		0x8000	// 1=bits have changed since last read
+#define	PHY_INT_LNKFAIL		0x4000	// 1=Link Not detected
+#define PHY_INT_LOSSSYNC	0x2000	// 1=Descrambler has lost sync
+#define PHY_INT_CWRD		0x1000	// 1=Invalid 4B5B code detected on rx
+#define PHY_INT_SSD		0x0800	// 1=No Start Of Stream detected on rx
+#define PHY_INT_ESD		0x0400	// 1=No End Of Stream detected on rx
+#define PHY_INT_RPOL		0x0200	// 1=Reverse Polarity detected
+#define PHY_INT_JAB		0x0100	// 1=Jabber detected
+#define PHY_INT_SPDDET		0x0080	// 1=100Base-TX mode, 0=10Base-T mode
+#define PHY_INT_DPLXDET		0x0040	// 1=Device in Full Duplex
+
+// PHY Interrupt/Status Mask Register
+#define PHY_MASK_REG		0x13	// Interrupt Mask
+// Uses the same bit definitions as PHY_INT_REG
+
+
+
+/*-------------------------------------------------------------------------
+ .  I define some macros to make it easier to do somewhat common
+ . or slightly complicated, repeated tasks. 
+ --------------------------------------------------------------------------*/
+
+/* select a register bank, 0 to 3  */
+
+#define SMC_SELECT_BANK(x)  { outw( x, ioaddr + BANK_SELECT ); } 
+
+/* this enables an interrupt in the interrupt mask register */
+#define SMC_ENABLE_INT(x) {\
+		unsigned char mask;\
+		SMC_SELECT_BANK(2);\
+		mask = inb( ioaddr + IM_REG );\
+		mask |= (x);\
+		outb( mask, ioaddr + IM_REG ); \
+}
+
+/* this disables an interrupt from the interrupt mask register */
+
+#define SMC_DISABLE_INT(x) {\
+		unsigned char mask;\
+		SMC_SELECT_BANK(2);\
+		mask = inb( ioaddr + IM_REG );\
+		mask &= ~(x);\
+		outb( mask, ioaddr + IM_REG ); \
+}
+
+/*----------------------------------------------------------------------
+ . Define the interrupts that I want to receive from the card
+ . 
+ . I want: 
+ .  IM_EPH_INT, for nasty errors
+ .  IM_RCV_INT, for happy received packets
+ .  IM_RX_OVRN_INT, because I have to kick the receiver
+ .  IM_MDINT, for PHY Register 18 Status Changes
+ --------------------------------------------------------------------------*/
+#define SMC_INTERRUPT_MASK   (IM_EPH_INT | IM_RX_OVRN_INT | IM_RCV_INT | \
+	IM_MDINT) 
+
+
+#ifdef CONFIG_SYSCTL
+
+
+/*
+ * Declarations for the sysctl interface, which allows users the ability to
+ * control the finer aspects of the LAN91C111 chip.  Since the smc
+ * module currently registers its sysctl table dynamically, the sysctl path
+ * for module FOO is /proc/sys/dev/ethX/FOO
+ */
+#define CTL_SMC         (CTL_BUS+1389)      // arbitrary and hopefully unused
+
+enum {
+	CTL_SMC_INFO = 1,	// Sysctl files information
+	CTL_SMC_SWVER,		// Driver Software Version Info
+	CTL_SMC_SWFDUP,		// Switched Full Duplex Mode
+	CTL_SMC_EPHLOOP,	// EPH Block Internal Loopback
+	CTL_SMC_MIIOP,		// MII Operation
+	CTL_SMC_AUTONEG,	// Auto-negotiate Mode
+	CTL_SMC_RFDUPLX,	// Request Full Duplex Mode
+	CTL_SMC_RSPEED,		// Request Speed Selection
+	CTL_SMC_AFDUPLX,	// Actual Full Duplex Mode
+	CTL_SMC_ASPEED,		// Actual Speed Selection
+	CTL_SMC_LNKFAIL,	// Link Failed
+	CTL_SMC_FORCOL,		// Force a Collision
+	CTL_SMC_FILTCAR,	// Filter Carrier
+	CTL_SMC_FREEMEM,	// Free Buffer Memory
+	CTL_SMC_TOTMEM,		// Total Buffer Memory
+	CTL_SMC_LEDA,		// Output of LED-A
+	CTL_SMC_LEDB,		// Output of LED-B
+	CTL_SMC_CHIPREV,	// LAN91C111 Chip Revision ID
+#ifdef SMC_DEBUG
+	// Register access for debugging
+	CTL_SMC_REG_BSR,	// Bank Select
+	CTL_SMC_REG_TCR,	// Transmit Control
+	CTL_SMC_REG_ESR,	// EPH Status
+	CTL_SMC_REG_RCR,	// Receive Control
+	CTL_SMC_REG_CTRR,	// Counter
+	CTL_SMC_REG_MIR,	// Memory Information
+	CTL_SMC_REG_RPCR,	// Receive/Phy Control
+	CTL_SMC_REG_CFGR,	// Configuration
+	CTL_SMC_REG_BAR,	// Base Address
+	CTL_SMC_REG_IAR0,	// Individual Address 0
+	CTL_SMC_REG_IAR1,	// Individual Address 1 
+	CTL_SMC_REG_IAR2,	// Individual Address 2
+	CTL_SMC_REG_GPR,	// General Purpose
+	CTL_SMC_REG_CTLR,	// Control
+	CTL_SMC_REG_MCR,	// MMU Command
+	CTL_SMC_REG_PNR,	// Packet Number
+	CTL_SMC_REG_FPR,	// FIFO Ports
+	CTL_SMC_REG_PTR,	// Pointer
+	CTL_SMC_REG_DR,		// Data 
+	CTL_SMC_REG_ISR,	// Interrupt Status
+	CTL_SMC_REG_MTR1,	// Multicast Table Entry 1
+	CTL_SMC_REG_MTR2,	// Multicast Table Entry 2
+	CTL_SMC_REG_MTR3,	// Multicast Table Entry 3
+	CTL_SMC_REG_MTR4,	// Multicast Table Entry 4
+	CTL_SMC_REG_MIIR,	// Management Interface
+	CTL_SMC_REG_REVR,	// Revision
+	CTL_SMC_REG_ERCVR,	// Early RCV
+	CTL_SMC_REG_EXTR,	// External
+	CTL_SMC_PHY_CTRL,	// PHY Control
+	CTL_SMC_PHY_STAT,	// PHY Status
+	CTL_SMC_PHY_ID1,	// PHY ID1
+	CTL_SMC_PHY_ID2,	// PHY ID2
+	CTL_SMC_PHY_ADC,	// PHY Advertise Capability
+	CTL_SMC_PHY_REMC,	// PHY Advertise Capability
+	CTL_SMC_PHY_CFG1,	// PHY Configuration 1
+	CTL_SMC_PHY_CFG2,	// PHY Configuration 2
+	CTL_SMC_PHY_INT,	// PHY Interrupt/Status Output
+	CTL_SMC_PHY_MASK,	// PHY Interrupt/Status Mask
+#endif
+	// ---------------------------------------------------
+	CTL_SMC_LAST_ENTRY	// Add new entries above the line
+};
+
+#endif // CONFIG_SYSCTL
+ 
+#endif  /* _SMC_91111_H_ */
+
+
diff -ruN linux-2.6.7.org/arch/m32r/drivers/smc91111.readme.txt linux-2.6.7/arch/m32r/drivers/smc91111.readme.txt
--- linux-2.6.7.org/arch/m32r/drivers/smc91111.readme.txt	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/drivers/smc91111.readme.txt	2004-03-16 22:11:26.000000000 +0900
@@ -0,0 +1,561 @@
+SMSC LAN91C111 Driver
+Revision 2.0
+9/24/01
+Copyright (C) 2001 Standard Microsystems Corporation (SMSC)
+Copyright (C) 1996 by Erik Stahlman (ES)
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+This file contains the instructions, test methods, and caveats for the
+smc91111.c driver.  You may not be using the driver without reading this file.  
+
+Driver Description:
+===================
+This driver has been modified to work on kernel 2.4. And it also contains the
+latest SMSC updates for the Odd Byte issue. Important thing to note about this
+is that, this driver might not compile on kernel version older than 2.4.
+  Please visit the SMSC website (http://www.smsc.com) for latest updates on the
+drivers.
+
+
+Things to note about installation:
+==================================
+
+  1.  This is designed to be compiled and loaded as a module.  While putting
+     it into your kernel should be possible, it has not yet been tested.  
+ 
+  2.  The driver will only load on recent kernels because of changes to
+     the network driver interface.  I have compiled this under kernel 2.4.   
+	
+ 
+  3.  To compile, run 'make' .   
+
+  4.  Loading the driver:
+
+	use:   insmod smc91111.o 
+	optional parameters:
+		io=0x###   : your base address
+		irq=##	   : your irq 
+		nowait=x   :	0 for standard I/O access (IOCHRDY wait states)
+				1 for fast access (no IOCHRDY wait states)
+
+  5. To allow automatic loading and intialization of the driver at boot-up
+     add the following line to /etc/modules.conf (in RedHat 7.0):
+
+	alias eth0 smc91111
+        options eth0 io=0x### irq=##
+
+     See the man pages on module.conf.  You must also be sure to copy the
+     smc91111.o file to the modules directory:
+
+         su
+         cd /lib/modules/YOUR_CURRENT_KERNEL_VERSION/net
+         cp 'directory where the file resides'/smc91111.o .
+         chown root:root smc91111.o
+         chmod a+r smc91111.o
+
+     Then you must update the module dependencies (as root):
+
+         /sbin/depmod
+
+
+
+Advanced Features:
+==================
+
+If your Linux Kernel was compiled with the configuration options CONFIG_PROC_FS
+and CONFIG_SYSCTL enabled then the smc91111 driver provides several sysctl
+files for accessing extended features. These files can be found in
+/proc/sys/dev/ethX, where X is the interface number of the ethernet port. For
+example, if your SMC91C111 card is the only one in the system then your sysctl
+files will be located at /proc/sys/dev/eth0.
+
+The following lists the files supported by the driver.
+
+ sysctl file                       Description
+-------------   --------------------------------------------------------------
+ info           Prints a list of supported files along with a terse
+                description of each one.
+
+ swver          Prints the software version information of the driver.
+
+ autoneg        When set to 1 enables auto negotiation mode.  The LAN91C111
+                supports auto negotiation per IEEE 802.3 Clause 28.  When auto
+                negotiation is set the files "rspeed" and "rfduplx" (below)
+                limit what capabilities are broadcast to the remote end.
+                When "autoneg" is set to 0 the auto-negotiation feature
+                is disabled, and the speed and duplex can be controlled
+                directly and immediately with "rspeed" and "rfduplx".
+                You can change the value of this file by issuing the command
+                "echo 0 > autoneg", assuming that you are in the directory
+                /proc/sys/dev/ethX.
+                The default value of "autoneg" is 1.
+
+ aspeed         Reports the actual speed of the link.  This file is read-only.
+
+ afduplx        Reports the actual duplex of the link. A value of 1 indicates
+                the link is currently operating in full duplex.  This file
+                is read-only.
+
+ rspeed         Requested speed, controls the speed of the interface.  The
+                behavior invoked by this file depends on the value of
+                the "autoneg" file. See the "autoneg" description above. A value
+                of 100 indicates 100Mpbs, and a speed of 10 indicates 10Mbps.
+                You cannot change the value of "rspeed" when "autoneg" is
+                set to 1.  You can issue the following commands to restrict
+                the LAN91C111 to 10Mbps operation:
+                   cd /proc/sys/dev/eth0
+                   echo 0 > autoneg
+                   echo 10 > speed
+                   echo 1 > autoneg
+                The default value of "speed" is 100.
+
+ rfduplx        Requested duplex, controls the duplex operation of the
+                interface.  The behavior invoked by this file depends on the
+                value of the "autoneg" file.  See the "autoneg" description
+                above.  A value of 1 indicates full duplex, while a value of 0
+                indicates half duplex operation.  You cannot change the value
+                of "rfduplx" when "autoneg" is set to 1.  The default value of
+                "rfduplx" is 1.
+
+ lnkfail        When 1 indicates the PHY link is in a failure state (i.e.
+                not connected to a valid LAN).  A value of 0 indicates
+                normal operation.
+
+ miiop          When set to 1 selects an external PHY.  This feature has not
+                yet been tested.  The default value of "miiop" is 0.
+
+ swfdup         When set to 1 enables Switched Full Duplex Operation.  This
+                is to be used only when miiop is set to 1 (according to the
+                LAN91C111 documentation).  This feature has not yet been
+                tested.  The default value of "swfdup" is 0.
+
+ ephloop        When set to 1 enables a loopback in the EPH block.  This feature
+                has not yet been tested.  The default value of "ephloop" is 0.
+
+ forcol         When set to 1 forces a collision.  This feature has not yet been
+                tested.  The default value of "forcol" is 0.
+
+ filtcar        When set to 1 the LAN91C111 filters the leading edge of carrier
+                sense for 12 bit times.  This feature has not yet been tested.
+                The default value of "filtcar" is 0.
+
+ freemem        Reports the amount of buffer memory currently free, in bytes.
+
+ totmem         Reports the total amount of buffer memory contained in the
+                LAN91C111, in bytes.
+
+ leda           Reports and controls which line condition is reported on
+                LEDA.  I tested this feature with the SMSC EVB111-ISA board.
+                LED A on this card is green and is labelled "100".  This
+                file accepts values from 0 thru 7.
+
+                      Value              Line Condition Reported
+                      -----    ----------------------------------------------
+                        0      Logical OR of 100Mbps and 10Mbps link detected
+                        1      Reserved
+                        2      10Mpbs link detected
+                        3      Full Duplex Mode Enabled
+                        4      Transmit or Receive packet occurred
+                        5      100Mbps Link Detected
+                        6      Transmit packet occurred
+                        7      Receive packet occurred
+
+                The default value of "leda" is 5.
+
+ ledb           Reports and controls which line condition is reported on
+                LEDB.  I tested this feature with the SMSC EVB111-ISA board.
+                LED B on this card is yellow and is labelled "FD".  This
+                file accepts values from 0 thru 7 (see above).
+                The default value of "ledb" is 3.
+
+ chiprev        Reports the chip revision number of the LAN91C111.
+
+
+Testing Methodology and Report:
+===============================
+
+I tested the smc91111.c driver using RedHat 7.1.  The version I tested with
+came with kernel version 2.4.2.  I updated the gcc tools because of
+known bugs in this version of the RedHat distribution.  It should not have
+made a difference though, as the module is actually compiled using the "kgcc"
+compiler provided by RedHat 7.1 (you have to manually install the kgcc rpm
+from the CDROM).
+
+I used two machines to perform tests. The first is an AST Bravo MS-T PRO 6200,
+Model 2500C.  It contains a PentiumPro w/integrated 256KB L2 cache, 64Mbytes of
+EDO DRAM, and a 2.5GB EIDE hard drive.
+
+The second machine is a generic Pentium II running at 360MHz.  It contains
+64Mbytes of SDRAM, and a 30GB hard drive. I used a NetGear FA311 PCI Ethernet
+card in this machine.  I compiled and installed the fa311.c driver provided
+with the card.
+
+I tested in two configurations.  The first was in isolation, where the two
+machines were connected to each other with a CAT5 crossover cable.  The second
+configuration connected both machines to a local area network running at
+10Mbps.  This lan containes three Windows machines and an Efficient Networks
+SpeedStream router, connected to the Internet through an IDSL (today it is
+served by Northpoint, tomorrow it is serviced by ????)
+
+Test Scenerio #1
+Testing in Isolated Network
+
+The PentiumPro machine with the EVB111-ISA card is named "LOCAL", with IP address 216.36.95.135, netmask 255.255.255.240.
+
+The PentiumII machine with the NetGear FA311 is named "REMOTE", with IP address of 216.36.95.134, netmask 255.255.255.240.
+
+1. Bring the interface up.
+
+   The insmod and ifconfig programs must be executed as root.
+
+   LOCAL: /sbin/insmod smc91111.o
+   Check /var/log/messages (at end) for results. You should see the I/O address
+   and IRQ assigned to the card by the auto probe function.
+
+   LOCAL: /sbin/ifconfig eth0 216.36.95.135 netmask 255.255.255.240
+   Verify that the interace is up by checking the results of ifconfig:
+
+   LOCAL: /sbin/ifconfig
+   Verify that the Ethernet MAC address reported by ifconfig looks reasonable.
+   The card I tested with contained the address "00:80:0F:6A:00:00".  Beware
+   of addresses with all zeros, all ones, or repeating bytes.
+
+   Test Result: Passed
+
+
+2. Ping Remote Side
+
+   LOCAL: ping -c5 216.36.95.134
+   Verify that 5 pings were returned.
+
+   Test Result: Passed
+
+
+3. Check sysctl variables
+
+   LOCAL: cd /proc/sys/dev/eth0
+   LOCAL: ls
+   Verify that the following files are shown:
+      afduplx autoneg  ephloop  forcol   info  ledb    miiop   rspeed swver
+      aspeed  chiprev  filtcar  freemem  leda  lnkfail rfduplx swfdup totmem
+
+   LOCAL: more autoneg
+   Verify that the value printed is 1.
+
+   LOCAL: more rspeed
+   Verify that the value printed is 100.
+
+   LOCAL: more rfduplx
+   Verify that the value printed is 1.
+
+   LOCAL: more aspeed
+   Verify that the value printed is 100.
+
+   LOCAL: more afduplx
+   Verify that the value printed is 1.
+
+   LOCAL: more lnkfail
+   Verify that the value printed is 0.
+
+   LOCAL: more totmem
+   Verify that the value printed is 8192.
+
+   LOCAL: more freemem
+   Verify that the value printed is 8192.
+
+   LOCAL: more leda
+   Verify that the value printed is 5
+
+   LOCAL: more ledb
+   Verify that the value printed is 3
+
+   Test Result: Passed
+
+
+4. Check LEDs
+
+   You may not be able to do this depending on the LEDs supported on your
+   card.
+
+   Verify that the "100" LED is on, indicating a 100Mbps connection.
+
+   Verify that the "FD" LED is on, indicating Full-Duplex connection.
+
+   Test Result: Passed
+
+
+5. Check Transport - use ftp to transport a large file across the ethernet
+
+   Obtain a large file, preferably several megabytes in size. I used the
+   file XFree86-4.0.1-1.i386.rpm from Disk 1 of the RedHat 7.0 distribution
+   because it was 15Mbytes in size.
+
+   REMOTE: ftp 216.36.95.135
+   REMOTE: bin
+   REMOTE: put large_file
+   REMOTE: get large_file large_file_ftp
+   REMOTE: quit
+   REMOTE: diff large_file large_file_ftp
+   Verify that the transfer occurred correctly, and that the file was not
+   modified after transport.
+
+   Test Result: Passed
+
+
+6. Disable Auto-Negotiate, Force Half Duplex, 100Mbps
+
+   The files in /proc/sys/dev/ethX can only be changed by root.
+
+   LOCAL: echo 0 > autoneg
+   Wait 5 seconds.
+   LOCAL: echo 0 > rfduplx
+   Wait 5 seconds.
+   LOCAL: more rfduplx
+   Verify that the result printed is 0.
+   LOCAL: more afduplx
+   Verify that the result printed is 0.  Verify that the "100" LED is on,
+   and the "FD" LED is off.
+   Perform Test #2 (Ping Remote Side) to verify connection.
+   Perform Test #5 (Check Transport).
+
+   Test Result: Passed
+
+
+7. Eanble Auto-Negotiate, Advertising Half Duplex, 100Mbps
+
+   LOCAL: echo 1 > autoneg
+   Wait 5 seconds.
+   Verify that the "100" LED is on, and the "FD" LED is off.
+   LOCAL: more autoneg
+   Verify that the result printed is 1.
+   LOCAL: more afduplx
+   Verify that the result printed is 0.
+   LOCAL: more aspeed
+   Verify that the result printed is 100.
+   Perform Test #2 (Ping Remote Side) to verify connection.
+   LOCAL: more lnkfail
+   Verify that the result printed is 0.
+   Remove the ethernet cable from the RJ-45 connector.
+   LOCAL: more lnkfail
+   Verify that the result printed is 1.
+   Reinsert the ethernet cable into the RJ-45 connector. 
+   LOCAL: more lnkfail
+   Verify that the result printed is 0.
+   LOCAL: more afduplx
+   Verify that the result printed is 0.
+   LOCAL: more aspeed
+   Verify that the result printed is 100.
+   Perform Test #2 (Ping Remote Side) to verify connection.
+
+   Test Result: Passed
+
+
+8. Force Half Duplex, 10Mbps
+
+   LOCAL: echo 0 > autoneg
+   Wait 5 seconds.
+   LOCAL: echo 10 > rspeed
+   Wait 5 seconds.
+   LOCAL: more aspeed
+   Verify that the result printed is 10.  Verify that the "100" LED is off,
+   and the "FD" LED is off.
+   LOCAL: more afduplx
+   Verify that the result printed is 0.
+   Perform Test #2 (Ping Remote Side) to verify connection.
+   Perform Test #5 (Check Transport).
+
+   Test Result: Passed
+
+
+9. Eanble Auto-Negotiate, Advertising Half Duplex, 10Mbps
+
+   LOCAL: echo 1 > autoneg
+   Wait 5 seconds.
+   Verify that the "100" LED is off, and the "FD" LED is off.
+   LOCAL: more autoneg
+   Verify that the result printed is 1.
+   LOCAL: more afduplx
+   Verify that the result printed is 0.
+   LOCAL: more aspeed
+   Verify that the result printed is 10.
+   Perform Test #2 (Ping Remote Side) to verify connection.
+   LOCAL: more lnkfail
+   Verify that the result printed is 0.
+   Remove the ethernet cable from the RJ-45 connector.
+   LOCAL: more lnkfail
+   Verify that the result printed is 1.
+   Reinsert the ethernet cable into the RJ-45 connector. 
+   LOCAL: more lnkfail
+   Verify that the result printed is 0.
+   LOCAL: more afduplx
+   Verify that the result printed is 0.
+   LOCAL: more aspeed
+   Verify that the result printed is 10.
+   Perform Test #2 (Ping Remote Side) to verify connection.
+
+   Test Result: Passed
+
+
+10. Force Full Duplex, 10Mbps
+
+   LOCAL: echo 0 > autoneg
+   Wait 5 seconds.
+   LOCAL: echo 1 > rfduplx
+   Wait 5 seconds.
+   LOCAL: more afduplx
+   Verify that the result printed is 1.  Verify that the "100" LED is off,
+   and the "FD" LED is on.
+   LOCAL: more aspeed
+   Verify that the result printed is 10.
+   Perform Test #2 (Ping Remote Side) to verify connection.
+   Perform Test #5 (Check Transport).
+
+   Test Result: Passed
+
+
+11. Eanble Auto-Negotiate, Advertising Full Duplex, 10Mbps
+
+   LOCAL: echo 1 > autoneg
+   Wait 5 seconds.
+   Verify that the "100" LED is off, and the "FD" LED is on.
+   LOCAL: more autoneg
+   Verify that the result printed is 1.
+   LOCAL: more afduplx
+   Verify that the result printed is 1.
+   LOCAL: more aspeed
+   Verify that the result printed is 10.
+   Perform Test #2 (Ping Remote Side) to verify connection.
+
+   Test Result: Passed
+
+
+
+12. Return to Full Duplex, 100Mbps
+
+   LOCAL: echo 0 > autoneg
+   Wait 5 seconds.
+   LOCAL: echo 1 > rfduplx
+   Wait 5 seconds.
+   LOCAL: more afduplx
+   Verify that the result printed is 1.
+   LOCAL: echo 100 > rspeed
+   Wait 5 seconds.
+   LOCAL: more espeed
+   Verify that the result printed is 100.
+   Verify that the "100" LED is on, and the "FD" LED is on.
+   Perform Test #2 (Ping Remote Side) to verify connection.
+   LOCAL: echo 1 > autoneg
+   Wait 5 seconds.
+   Verify that the "100" LED is on, and the "FD" LED is on.
+   LOCAL: more autoneg
+   Verify that the result printed is 1.
+   LOCAL: more afduplx
+   Verify that the result printed is 1.
+   LOCAL: more aspeed
+   Verify that the result printed is 100.
+   Perform Test #2 (Ping Remote Side) to verify connection.
+
+   Test Result: Passed
+
+
+
+Test Scenerio #2
+Testing in a Mixed-Mode 10Mbps LAN
+
+This section of testing was perform in a 10Mbps LAN with mixed 10Base2 and
+10BaseT interfaces.  The LAN was interconnected with a D-Link HUB, and a
+connection to the Internet was secured through an Efficient Networks
+SpeedStream router. The address of the router is 216.36.95.129.
+
+
+13. Connect to LAN
+
+   Connect both the LOCAL and REMOTE ethernet cards to the non-isolated LAN.
+   Verify that the "100" LED is off, and the "FD" LED is off.
+   LOCAL: more lnkfail
+   Verify that the result printed is 0.
+   LOCAL: more afduplx
+   Verify that the result printed is 0.
+   LOCAL: more aspeed
+   Verify that the result printed is 10.
+   Perform Test #2 (Ping Remote Side) to verify connection.
+
+   Test Results: Passed
+
+
+14. Test Promiscuous Mode
+
+   LOCAL: /usr/sbin/tcpdump -p -i eth0 host 216.36.95.129
+   REMOTE: ping -c5 216.36.95.129
+   Verify that the LOCAL "tcpdump" program sees the pings to 216.36.95.129.
+
+   Test Results: Passed
+
+15. Test Multicast Mode
+
+   The "route" command must be executed as root.
+   LOCAL: route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0
+   REMOTE: route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0
+   LOCAL: /usr/sbin/tcpdump -p -i eth0 host 216.36.95.129
+   REMOTE: ping 224.0.0.1
+   Verify that the REMOTE machine gets at least one ICMP response from
+   216.36.95.135. You will probably also see ICMP responses from other
+   Linux machines listening on the LAN.
+   Also, by inspecting the output of the LOCAL "tcpdump" you can see which
+   packets are Broadcast (B), Multicast (M), or Point-to-point (P).
+
+   Test Results:  Passed
+
+16. Test LED Control
+
+   LOCAL: echo 6 > leda
+   LOCAL: echo 7 > ledb
+   LOCAL: more leda
+   Verify that the result printed is 6.
+   LOCAL: more ledb
+   Verify that the result printed is 7.
+   Perform Test #2 (Ping Remote Side) to verify connection.
+   Verify that the two LEDs toggle when packets are received and transmitted.
+
+   Test Results:  Passed
+
+
+
+How to obtain the latest version:
+=================================
+	
+	http://www.smsc.com
+
+
+Known bugs:
+===========
+
+   1.   You cannot yet set the hardware address.  
+
+   2.	Hardware multicast filtering is not yet supported.
+
+   3.	The driver does not support multiple cards in a system (yet)
+
+   4.   One anomoly was observed during testing with an Athlon Thunderbird 1GHz system
+        during FTP uploads to a Pentim 4 1.3GHz system running Windows 2000 Adv Server,
+        where FTP transfer speed were observed to be 40-50% below normal. The cause
+        of the anomoly is unknown.
+
+
+Contacting me:
+==============
+   Pramod Bhardwaj, pramod.bhardwaj@smsc.com
+ 
diff -ruN linux-2.6.7.org/arch/m32r/kernel/Makefile linux-2.6.7/arch/m32r/kernel/Makefile
--- linux-2.6.7.org/arch/m32r/kernel/Makefile	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/Makefile	2004-07-27 15:54:20.000000000 +0900
@@ -0,0 +1,20 @@
+# 
+# Makefile for the Linux/M32R kernel.
+#
+
+extra-y	:= head.o init_task.o vmlinux.lds.s
+
+obj-y	:= process.o entry.o traps.o align.o irq.o setup.o time.o \
+	m32r_ksyms.o sys_m32r.o semaphore.o signal.o ptrace.o
+
+obj-$(CONFIG_SMP)		+= smp.o smpboot.o
+obj-$(CONFIG_PLAT_MAPPI)	+= setup_mappi.o io_mappi.o
+obj-$(CONFIG_PLAT_MAPPI2)	+= setup_mappi2.o io_mappi2.o
+obj-$(CONFIG_PLAT_USRV)		+= setup_usrv.o io_usrv.o
+obj-$(CONFIG_PLAT_M32700UT)	+= setup_m32700ut.o io_m32700ut.o
+obj-$(CONFIG_PLAT_OPSPUT)	+= setup_opsput.o io_opsput.o
+obj-$(CONFIG_MODULES)		+= module.o
+obj-$(CONFIG_PLAT_OAKS32R)	+= setup_oaks32r.o io_oaks32r.o
+
+EXTRA_AFLAGS	:= -traditional
+
diff -ruN linux-2.6.7.org/arch/m32r/kernel/align.c linux-2.6.7/arch/m32r/kernel/align.c
--- linux-2.6.7.org/arch/m32r/kernel/align.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/align.c	2003-09-09 10:26:52.000000000 +0900
@@ -0,0 +1,585 @@
+/*
+ * align.c - address exception handler for M32R
+ * 
+ * Copyright (c) 2003 Hitoshi Yamamoto
+ */
+
+#include <linux/config.h>
+#include <asm/ptrace.h>
+#include <asm/uaccess.h>
+
+static int get_reg(struct pt_regs *regs, int nr)
+{
+	int val;
+
+	if (nr < 4)
+		val = *(unsigned long *)(&regs->r0 + nr);
+	else if (nr < 7)
+		val = *(unsigned long *)(&regs->r4 + (nr - 4));
+	else if (nr < 13)
+		val = *(unsigned long *)(&regs->r7 + (nr - 7));
+	else 
+		val = *(unsigned long *)(&regs->fp + (nr - 13));
+
+	return val;
+}
+
+static void set_reg(struct pt_regs *regs, int nr, int val)
+{
+	if (nr < 4)
+		*(unsigned long *)(&regs->r0 + nr) = val;
+	else if (nr < 7)
+		*(unsigned long *)(&regs->r4 + (nr - 4)) = val;
+	else if (nr < 13)
+		*(unsigned long *)(&regs->r7 + (nr - 7)) = val;
+	else 
+		*(unsigned long *)(&regs->fp + (nr - 13)) = val;
+}
+
+#define REG1(insn)	(((insn) & 0x0f00) >> 8)
+#define REG2(insn)	((insn) & 0x000f)
+#define PSW_BC		0x100
+
+/* O- instruction */
+#define ISA_LD1		0x20c0	/* ld Rdest, @Rsrc */
+#define ISA_LD2		0x20e0	/* ld Rdest, @Rsrc+ */
+#define ISA_LDH		0x20a0	/* ldh Rdest, @Rsrc */
+#define ISA_LDUH	0x20b0	/* lduh Rdest, @Rsrc */
+#define ISA_ST1		0x2040	/* st Rsrc1, @Rsrc2 */
+#define ISA_ST2		0x2060	/* st Rsrc1, @+Rsrc2 */
+#define ISA_ST3		0x2070	/* st Rsrc1, @-Rsrc2 */
+#define ISA_STH1	0x2020	/* sth Rsrc1, @Rsrc2 */
+#define ISA_STH2	0x2030	/* sth Rsrc1, @Rsrc2+ */
+
+#ifdef CONFIG_ISA_DUAL_ISSUE
+
+/* OS instruction */
+#define ISA_ADD		0x00a0	/* add Rdest, Rsrc */
+#define ISA_ADDI	0x4000	/* addi Rdest, #imm8 */
+#define ISA_ADDX	0x0090	/* addx Rdest, Rsrc */
+#define ISA_AND		0x00c0	/* and Rdest, Rsrc */
+#define ISA_CMP		0x0040	/* cmp Rsrc1, Rsrc2 */
+#define ISA_CMPEQ	0x0060	/* cmpeq Rsrc1, Rsrc2 */
+#define ISA_CMPU	0x0050	/* cmpu Rsrc1, Rsrc2 */
+#define ISA_CMPZ	0x0070	/* cmpz Rsrc */
+#define ISA_LDI		0x6000	/* ldi Rdest, #imm8 */
+#define ISA_MV		0x1080	/* mv Rdest, Rsrc */
+#define ISA_NEG		0x0030	/* neg Rdest, Rsrc */
+#define ISA_NOP		0x7000	/* nop */
+#define ISA_NOT		0x00b0	/* not Rdest, Rsrc */
+#define ISA_OR		0x00e0	/* or Rdest, Rsrc */
+#define ISA_SUB		0x0020	/* sub Rdest, Rsrc */
+#define ISA_SUBX	0x0010	/* subx Rdest, Rsrc */
+#define ISA_XOR		0x00d0	/* xor Rdest, Rsrc */
+
+/* -S instruction */
+#define ISA_MUL		0x1060	/* mul Rdest, Rsrc */
+#define ISA_MULLO_A0	0x3010	/* mullo Rsrc1, Rsrc2, A0 */
+#define ISA_MULLO_A1	0x3090	/* mullo Rsrc1, Rsrc2, A1 */
+#define ISA_MVFACMI_A0	0x50f2	/* mvfacmi Rdest, A0 */
+#define ISA_MVFACMI_A1	0x50f6	/* mvfacmi Rdest, A1 */
+
+static int emu_addi(unsigned short insn, struct pt_regs *regs)
+{
+	char imm = (char)(insn & 0xff);
+	int dest = REG1(insn);
+	int val;
+
+	val = get_reg(regs, dest);
+	val += imm;
+	set_reg(regs, dest, val);
+
+	return 0;
+}
+
+static int emu_ldi(unsigned short insn, struct pt_regs *regs)
+{
+	char imm = (char)(insn & 0xff);
+
+	set_reg(regs, REG1(insn), (int)imm);
+
+	return 0;
+}
+
+static int emu_add(unsigned short insn, struct pt_regs *regs)
+{
+	int dest = REG1(insn);
+	int src = REG2(insn);
+	int val;
+
+	val = get_reg(regs, dest);
+	val += get_reg(regs, src);
+	set_reg(regs, dest, val);
+
+	return 0;
+}
+
+static int emu_addx(unsigned short insn, struct pt_regs *regs)
+{
+	int dest = REG1(insn);
+	unsigned int val, tmp;
+
+	val = regs->psw & PSW_BC ? 1 : 0;
+	tmp = get_reg(regs, dest);
+	val += tmp;
+	val += (unsigned int)get_reg(regs, REG2(insn));
+	set_reg(regs, dest, val);
+
+	/* C bit set */
+	if (val < tmp)
+		regs->psw |= PSW_BC;
+	else
+		regs->psw &= ~(PSW_BC);
+
+	return 0;
+}
+
+static int emu_and(unsigned short insn, struct pt_regs *regs)
+{
+	int dest = REG1(insn);
+	int val;
+
+	val = get_reg(regs, dest);
+	val &= get_reg(regs, REG2(insn));
+	set_reg(regs, dest, val);
+
+	return 0;
+}
+
+static int emu_cmp(unsigned short insn, struct pt_regs *regs)
+{
+	if (get_reg(regs, REG1(insn)) < get_reg(regs, REG2(insn)))
+		regs->psw |= PSW_BC;
+	else
+		regs->psw &= ~(PSW_BC);
+
+	return 0;
+}
+
+static int emu_cmpeq(unsigned short insn, struct pt_regs *regs)
+{
+	if (get_reg(regs, REG1(insn)) == get_reg(regs, REG2(insn)))
+		regs->psw |= PSW_BC;
+	else
+		regs->psw &= ~(PSW_BC);
+
+	return 0;
+}
+
+static int emu_cmpu(unsigned short insn, struct pt_regs *regs)
+{
+	if ((unsigned int)get_reg(regs, REG1(insn))
+		< (unsigned int)get_reg(regs, REG2(insn)))
+		regs->psw |= PSW_BC;
+	else
+		regs->psw &= ~(PSW_BC);
+
+	return 0;
+}
+
+static int emu_cmpz(unsigned short insn, struct pt_regs *regs)
+{
+	if (!get_reg(regs, REG2(insn)))
+		regs->psw |= PSW_BC;
+	else
+		regs->psw &= ~(PSW_BC);
+
+	return 0;
+}
+
+static int emu_mv(unsigned short insn, struct pt_regs *regs)
+{
+	int val;
+
+	val = get_reg(regs, REG2(insn));
+	set_reg(regs, REG1(insn), val);
+
+	return 0;
+}
+
+static int emu_neg(unsigned short insn, struct pt_regs *regs)
+{
+	int val;
+
+	val = get_reg(regs, REG2(insn));
+	set_reg(regs, REG1(insn), 0 - val);
+
+	return 0;
+}
+
+static int emu_not(unsigned short insn, struct pt_regs *regs)
+{
+	int val;
+
+	val = get_reg(regs, REG2(insn));
+	set_reg(regs, REG1(insn), ~val);
+
+	return 0;
+}
+
+static int emu_or(unsigned short insn, struct pt_regs *regs)
+{
+	int dest = REG1(insn);
+	int val;
+
+	val = get_reg(regs, dest);
+	val |= get_reg(regs, REG2(insn));
+	set_reg(regs, dest, val);
+
+	return 0;
+}
+
+static int emu_sub(unsigned short insn, struct pt_regs *regs)
+{
+	int dest = REG1(insn);
+	int val;
+
+	val = get_reg(regs, dest);
+	val -= get_reg(regs, REG2(insn));
+	set_reg(regs, dest, val);
+
+	return 0;
+}
+
+static int emu_subx(unsigned short insn, struct pt_regs *regs)
+{
+	int dest = REG1(insn);
+	unsigned int val, tmp;
+
+	val = tmp = get_reg(regs, dest);
+	val -= (unsigned int)get_reg(regs, REG2(insn));
+	val -= regs->psw & PSW_BC ? 1 : 0;
+	set_reg(regs, dest, val);
+
+	/* C bit set */
+	if (val > tmp)
+		regs->psw |= PSW_BC;
+	else
+		regs->psw &= ~(PSW_BC);
+
+	return 0;
+}
+
+static int emu_xor(unsigned short insn, struct pt_regs *regs)
+{
+	int dest = REG1(insn);
+	unsigned int val;
+
+	val = (unsigned int)get_reg(regs, dest);
+	val ^= (unsigned int)get_reg(regs, REG2(insn));
+	set_reg(regs, dest, val);
+
+	return 0;
+}
+
+static int emu_mul(unsigned short insn, struct pt_regs *regs)
+{
+	int dest = REG1(insn);
+	int reg1, reg2;
+
+	reg1 = get_reg(regs, dest);
+	reg2 = get_reg(regs, REG2(insn));
+
+	__asm__ __volatile__ (
+		"mul	%0, %1;		\n\t"
+		: "+r" (reg1) : "r" (reg2)
+	);
+
+	set_reg(regs, dest, reg1);
+
+	return 0;
+}
+
+static int emu_mullo_a0(unsigned short insn, struct pt_regs *regs)
+{
+	int reg1, reg2;
+
+	reg1 = get_reg(regs, REG1(insn));
+	reg2 = get_reg(regs, REG2(insn));
+
+	__asm__ __volatile__ (
+		"mullo		%0, %1, a0;	\n\t"
+		"mvfachi	%0, a0;		\n\t"
+		"mvfaclo	%1, a0;		\n\t"
+		: "+r" (reg1), "+r" (reg2)
+	);
+
+	regs->acc0h = reg1;
+	regs->acc0l = reg2;
+
+	return 0;
+}
+
+static int emu_mullo_a1(unsigned short insn, struct pt_regs *regs)
+{
+	int reg1, reg2;
+
+	reg1 = get_reg(regs, REG1(insn));
+	reg2 = get_reg(regs, REG2(insn));
+
+	__asm__ __volatile__ (
+		"mullo		%0, %1, a0;	\n\t"
+		"mvfachi	%0, a0;		\n\t"
+		"mvfaclo	%1, a0;		\n\t"
+		: "+r" (reg1), "+r" (reg2)
+	);
+
+	regs->acc1h = reg1;
+	regs->acc1l = reg2;
+
+	return 0;
+}
+
+static int emu_mvfacmi_a0(unsigned short insn, struct pt_regs *regs)
+{
+	unsigned long val;
+
+	val = (regs->acc0h << 16) | (regs->acc0l >> 16);
+	set_reg(regs, REG1(insn), (int)val);
+
+	return 0;
+}
+
+static int emu_mvfacmi_a1(unsigned short insn, struct pt_regs *regs)
+{
+	unsigned long val;
+
+	val = (regs->acc1h << 16) | (regs->acc1l >> 16);
+	set_reg(regs, REG1(insn), (int)val);
+
+	return 0;
+}
+
+static int emu_m32r2(unsigned short insn, struct pt_regs *regs)
+{
+	int res = -1;
+
+	if ((insn & 0x7fff) == ISA_NOP)	/* nop */
+		return 0;
+
+	switch(insn & 0x7000) {
+	case ISA_ADDI:		/* addi Rdest, #imm8 */
+		res = emu_addi(insn, regs);
+		break;
+	case ISA_LDI:		/* ldi Rdest, #imm8 */
+		res = emu_ldi(insn, regs);
+		break;
+	default:
+		break;
+	}
+
+	if (!res)
+		return 0;
+
+	switch(insn & 0x70f0) {
+	case ISA_ADD:		/* add Rdest, Rsrc */
+		res = emu_add(insn, regs);
+		break;
+	case ISA_ADDX:		/* addx Rdest, Rsrc */
+		res = emu_addx(insn, regs);
+		break;
+	case ISA_AND:		/* and Rdest, Rsrc */
+		res = emu_and(insn, regs);
+		break;
+	case ISA_CMP:		/* cmp Rsrc1, Rsrc2 */
+		res = emu_cmp(insn, regs);
+		break;
+	case ISA_CMPEQ:		/* cmpeq Rsrc1, Rsrc2 */
+		res = emu_cmpeq(insn, regs);
+		break;
+	case ISA_CMPU:		/* cmpu Rsrc1, Rsrc2 */
+		res = emu_cmpu(insn, regs);
+		break;
+	case ISA_CMPZ:		/* cmpz Rsrc */
+		res = emu_cmpz(insn, regs);
+		break;
+	case ISA_MV:		/* mv Rdest, Rsrc */
+		res = emu_mv(insn, regs);
+		break;
+	case ISA_NEG:		/* neg Rdest, Rsrc */
+		res = emu_neg(insn, regs);
+		break;
+	case ISA_NOT:		/* not Rdest, Rsrc */
+		res = emu_not(insn, regs);
+		break;
+	case ISA_OR:		/* or Rdest, Rsrc */
+		res = emu_or(insn, regs);
+		break;
+	case ISA_SUB:		/* sub Rdest, Rsrc */
+		res = emu_sub(insn, regs);
+		break;
+	case ISA_SUBX:		/* subx Rdest, Rsrc */
+		res = emu_subx(insn, regs);
+		break;
+	case ISA_XOR:		/* xor Rdest, Rsrc */
+		res = emu_xor(insn, regs);
+		break;
+	case ISA_MUL:		/* mul Rdest, Rsrc */
+		res = emu_mul(insn, regs);
+		break;
+	case ISA_MULLO_A0:	/* mullo Rsrc1, Rsrc2 */
+		res = emu_mullo_a0(insn, regs);
+		break;
+	case ISA_MULLO_A1:	/* mullo Rsrc1, Rsrc2 */
+		res = emu_mullo_a1(insn, regs);
+		break;
+	default:
+		break;
+	}
+
+	if (!res)
+		return 0;
+
+	switch(insn & 0x70ff) {
+	case ISA_MVFACMI_A0:	/* mvfacmi Rdest */
+		res = emu_mvfacmi_a0(insn, regs);
+		break;
+	case ISA_MVFACMI_A1:	/* mvfacmi Rdest */
+		res = emu_mvfacmi_a1(insn, regs);
+		break;
+	default:
+		break;
+	}
+
+	return res;
+}
+
+#endif	/* CONFIG_ISA_DUAL_ISSUE */
+
+/*
+ * ld   : ?010 dest 1100 src
+ *        0010 dest 1110 src : ld Rdest, @Rsrc+
+ * ldh  : ?010 dest 1010 src
+ * lduh : ?010 dest 1011 src
+ * st   : ?010 src1 0100 src2
+ *        0010 src1 0110 src2 : st Rsrc1, @+Rsrc2
+ *        0010 src1 0111 src2 : st Rsrc1, @-Rsrc2
+ * sth  : ?010 src1 0010 src2
+ */
+
+static int insn_check(unsigned long insn, struct pt_regs *regs, 
+	unsigned char **ucp)
+{
+	int res = 0;
+
+	/*
+	 * 32bit insn
+	 *  ld Rdest, @(disp16, Rsrc)
+	 *  st Rdest, @(disp16, Rsrc)
+	 */
+	if (insn & 0x80000000) {	/* 32bit insn */
+		*ucp += (short)(insn & 0x0000ffff);
+		regs->bpc += 4;
+	} else {			/* 16bit insn */
+#ifdef CONFIG_ISA_DUAL_ISSUE
+		/* parallel exec check */
+		if (!(regs->bpc & 0x2) && insn & 0x8000) {
+			res = emu_m32r2((unsigned short)insn, regs);
+			regs->bpc += 4;
+		} else
+#endif	/* CONFIG_ISA_DUAL_ISSUE */
+			regs->bpc += 2;
+	}
+
+	return res;
+}
+
+static int emu_ld(unsigned long insn32, struct pt_regs *regs)
+{
+	unsigned char *ucp;
+	unsigned long val;
+	unsigned short insn16;
+	int size, src;
+
+	insn16 = insn32 >> 16;
+	src = REG2(insn16);
+	ucp = (unsigned char *)get_reg(regs, src);
+
+	if (insn_check(insn32, regs, &ucp))
+		return -1;
+
+	size = insn16 & 0x0040 ? 4 : 2;
+	if (copy_from_user(&val, ucp, size))
+		return -1;
+
+	if (size == 2)
+		val >>= 16;
+
+	/* ldh sign check */
+	if ((insn16 & 0x00f0) == 0x00a0 && (val & 0x8000))
+		val |= 0xffff0000;
+
+	set_reg(regs, REG1(insn16), val);
+
+	/* ld increment check */
+	if ((insn16 & 0xf0f0) == ISA_LD2)	/* ld Rdest, @Rsrc+ */
+		set_reg(regs, src, (unsigned long)(ucp + 4));
+
+	return 0;
+}
+
+static int emu_st(unsigned long insn32, struct pt_regs *regs)
+{
+	unsigned char *ucp;
+	unsigned long val;
+	unsigned short insn16;
+	int size, src2;
+
+	insn16 = insn32 >> 16;
+	src2 = REG2(insn16);
+
+	ucp = (unsigned char *)get_reg(regs, src2);
+
+	if (insn_check(insn32, regs, &ucp))
+		return -1;
+
+	size = insn16 & 0x0040 ? 4 : 2;
+	val = get_reg(regs, REG1(insn16));
+	if (size == 2)
+		val <<= 16;
+
+	/* st inc/dec check */
+	if ((insn16 & 0xf0e0) == 0x2060) {
+		if (insn16 & 0x0010)
+			ucp -= 4;
+		else
+			ucp += 4;
+
+		set_reg(regs, src2, (unsigned long)ucp);
+	}
+
+	if (copy_to_user(ucp, &val, size))
+		return -1;
+
+	/* sth inc check */
+	if ((insn16 & 0xf0f0) == ISA_STH2) {
+		ucp += 2;
+		set_reg(regs, src2, (unsigned long)ucp);
+	}
+
+	return 0;
+}
+
+int handle_unaligned_access(unsigned long insn32, struct pt_regs *regs)
+{
+	unsigned short insn16;
+	int res;
+
+	insn16 = insn32 >> 16;
+
+	/* ld or st check */
+	if ((insn16 & 0x7000) != 0x2000)
+		return -1;
+
+	/* insn alignment check */
+	if ((insn16 & 0x8000) && (regs->bpc & 3))
+		return -1;
+
+	if (insn16 & 0x0080)	/* ld */
+		res = emu_ld(insn32, regs);
+	else			/* st */
+		res = emu_st(insn32, regs);
+
+	return res;
+}
+
diff -ruN linux-2.6.7.org/arch/m32r/kernel/entry.S linux-2.6.7/arch/m32r/kernel/entry.S
--- linux-2.6.7.org/arch/m32r/kernel/entry.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/entry.S	2004-07-27 15:54:20.000000000 +0900
@@ -0,0 +1,993 @@
+/*
+ *  linux/arch/m32r/kernel/entry.S
+ *
+ *  Copyright (c) 2001, 2002  Hirokazu Takata, Hitoshi Yamamoto, H. Kondo
+ *  Copyright (c) 2003  Hitoshi Yamamoto
+ *
+ *  Taken from i386 version.
+ *    Copyright (C) 1991, 1992  Linus Torvalds
+ */
+
+/*
+ * entry.S contains the system-call and fault low-level handling routines.
+ * This also contains the timer-interrupt handler, as well as all interrupts
+ * and faults that can result in a task-switch.
+ *
+ * NOTE: This code handles signal-recognition, which happens every time
+ * after a timer-interrupt and after each system call.
+ *
+ * Stack layout in 'ret_from_system_call':
+ * 	ptrace needs to have all regs on the stack.
+ *	if the order here is changed, it needs to be
+ *	updated in fork.c:copy_process, signal.c:do_signal,
+ *	ptrace.c and ptrace.h
+ *
+ * M32Rx/M32R2				M32R
+ *       @(sp)      - r4		ditto
+ *       @(0x04,sp) - r5		ditto
+ *       @(0x08,sp) - r6		ditto
+ *       @(0x0c,sp) - *pt_regs		ditto
+ *       @(0x10,sp) - r0		ditto
+ *       @(0x14,sp) - r1		ditto
+ *       @(0x18,sp) - r2		ditto
+ *       @(0x1c,sp) - r3		ditto
+ *       @(0x20,sp) - r7		ditto
+ *       @(0x24,sp) - r8		ditto
+ *       @(0x28,sp) - r9		ditto
+ *       @(0x2c,sp) - r10		ditto
+ *       @(0x30,sp) - r11		ditto
+ *       @(0x34,sp) - r12		ditto
+ *       @(0x38,sp) - syscall_nr	ditto
+ *       @(0x3c,sp) - acc0h		@(0x3c,sp) - acch
+ *       @(0x40,sp) - acc0l		@(0x40,sp) - accl
+ *       @(0x44,sp) - acc1h		@(0x44,sp) - psw
+ *       @(0x48,sp) - acc1l		@(0x48,sp) - bpc
+ *       @(0x4c,sp) - psw		@(0x4c,sp) - bbpsw
+ *       @(0x50,sp) - bpc		@(0x50,sp) - bbpc
+ *       @(0x54,sp) - bbpsw		@(0x54,sp) - spu (cr3)
+ *       @(0x58,sp) - bbpc		@(0x58,sp) - fp (r13)
+ *       @(0x5c,sp) - spu (cr3)		@(0x5c,sp) - lr (r14)
+ *       @(0x60,sp) - fp (r13)		@(0x60,sp) - spi (cr12)
+ *       @(0x64,sp) - lr (r14)		@(0x64,sp) - orig_r0
+ *       @(0x68,sp) - spi (cr2)
+ *       @(0x6c,sp) - orig_r0
+ *
+ */
+
+#include <linux/config.h>
+#include <linux/linkage.h>
+#include <asm/irq.h>
+#include <asm/unistd.h>
+#include <asm/assembler.h>
+#include <asm/thread_info.h>
+#include <asm/errno.h>
+#include <asm/segment.h>
+#include <asm/smp.h>
+#include <asm/page.h>
+#include <asm/m32r.h>
+#include <asm/mmu_context.h>
+
+#if !defined(CONFIG_MMU)
+#define sys_madvise             sys_ni_syscall
+#define sys_readahead           sys_ni_syscall
+#define sys_mprotect            sys_ni_syscall
+#define sys_msync               sys_ni_syscall
+#define sys_mlock               sys_ni_syscall
+#define sys_munlock             sys_ni_syscall
+#define sys_mlockall            sys_ni_syscall
+#define sys_munlockall          sys_ni_syscall
+#define sys_mremap              sys_ni_syscall
+#define sys_mincore             sys_ni_syscall
+#endif /* CONFIG_MMU */
+		
+#define R4(reg)			@reg
+#define R5(reg)			@(0x04,reg)
+#define R6(reg)			@(0x08,reg)
+#define PTREGS(reg)		@(0x0C,reg)
+#define R0(reg)			@(0x10,reg)
+#define R1(reg)			@(0x14,reg)
+#define R2(reg)			@(0x18,reg)
+#define R3(reg)			@(0x1C,reg)
+#define R7(reg)			@(0x20,reg)
+#define R8(reg)			@(0x24,reg)
+#define R9(reg)			@(0x28,reg)
+#define R10(reg)		@(0x2C,reg)
+#define R11(reg)		@(0x30,reg)
+#define R12(reg)		@(0x34,reg)
+#define SYSCALL_NR(reg)		@(0x38,reg)
+#if defined(CONFIG_ISA_M32R2) && defined(CONFIG_ISA_DSP_LEVEL2)
+#define ACC0H(reg)		@(0x3C,reg)
+#define ACC0L(reg)		@(0x40,reg)
+#define ACC1H(reg)		@(0x44,reg)
+#define ACC1L(reg)		@(0x48,reg)
+#define PSW(reg)		@(0x4C,reg)
+#define BPC(reg)		@(0x50,reg)
+#define BBPSW(reg)		@(0x54,reg)
+#define BBPC(reg)		@(0x58,reg)
+#define SPU(reg)		@(0x5C,reg)
+#define FP(reg)			@(0x60,reg)  /* FP = R13 */
+#define LR(reg)			@(0x64,reg)
+#define SP(reg)			@(0x68,reg)
+#define ORIG_R0(reg)		@(0x6C,reg)
+#elif defined(CONFIG_ISA_M32R2) || defined(CONFIG_ISA_M32R)
+#define ACCH(reg)		@(0x3C,reg)
+#define ACCL(reg)		@(0x40,reg)
+#define PSW(reg)		@(0x44,reg)
+#define BPC(reg)		@(0x48,reg)
+#define BBPSW(reg)		@(0x4C,reg)
+#define BBPC(reg)		@(0x50,reg)
+#define SPU(reg)		@(0x54,reg)
+#define FP(reg)			@(0x58,reg)  /* FP = R13 */
+#define LR(reg)			@(0x5C,reg)
+#define SP(reg)			@(0x60,reg)
+#define ORIG_R0(reg)		@(0x64,reg)
+#else
+#error unknown isa configuration
+#endif
+
+CF_MASK		= 0x00000001
+TF_MASK		= 0x00000100
+IF_MASK		= 0x00000200
+DF_MASK		= 0x00000400 
+NT_MASK		= 0x00004000
+VM_MASK		= 0x00020000
+
+#ifdef CONFIG_PREEMPT
+#define preempt_stop(x)		CLI(x)
+#else
+#define preempt_stop(x)
+#define resume_kernel		restore_all
+#endif
+
+ENTRY(ret_from_fork)
+	ld	r0, @sp+
+	bl	schedule_tail
+	GET_THREAD_INFO(r8)
+	bra	syscall_exit
+
+/*
+ * Return to user mode is not as complex as all this looks,
+ * but we want the default path for a system call return to
+ * go as quickly as possible which is why some of this is
+ * less clear than it otherwise should be.
+ */
+
+	; userspace resumption stub bypassing syscall exit tracing
+	ALIGN
+ret_from_exception:
+	preempt_stop(r4)
+ret_from_intr:
+	ld	r4, PSW(sp)
+#ifdef CONFIG_ISA_M32R2
+	and3	r4, r4, #0x8800		; check BSM and BPM bits
+#else
+	and3	r4, r4, #0x8000		; check BSM bit
+#endif
+	beqz	r4, resume_kernel
+ENTRY(resume_userspace)
+	CLI(r4)				; make sure we don't miss an interrupt
+					; setting need_resched or sigpending
+					; between sampling and the iret
+	GET_THREAD_INFO(r8)
+	ld	r9, @(TI_FLAGS, r8)
+	and3	r4, r9, #_TIF_WORK_MASK	; is there any work to be done on
+					; int/exception return?
+	bnez	r4, work_pending
+	bra	restore_all
+
+#ifdef CONFIG_PREEMPT
+ENTRY(resume_kernel)
+	GET_THREAD_INFO(r8)
+	ld	r9, @(TI_PRE_COUNT, r8)	; non-zero preempt_count ?
+	bnez	r9, restore_all
+need_resched:
+	ld	r9, @(TI_FLAGS, r8)	; need_resched set ?
+	and3	r4, r9, #_TIF_NEED_RESCHED
+	beqz	r4, restore_all
+	ld	r4, PSW(sp)		; interrupts off (exception path) ?
+	and3	r4, r4, #0x4000
+	beqz	r4, restore_all
+	LDIMM	(r4, PREEMPT_ACTIVE)
+	st	r4, @(TI_PRE_COUNT, r8)
+	STI(r4)
+	bl	schedule
+	ldi	r4, #0
+	st	r4, @(TI_PRE_COUNT, r8)
+	CLI(r4)
+	bra	need_resched
+#endif
+
+	; system call handler stub
+ENTRY(system_call)
+	SWITCH_TO_KERNEL_STACK
+	SAVE_ALL
+	STI(r4)				; Enable interrupt
+	st	sp, PTREGS(sp)		; implicit pt_regs parameter
+	cmpui	r7, #NR_syscalls
+	bnc	syscall_badsys
+	st	r7, SYSCALL_NR(sp)	; syscall_nr
+					; system call tracing in operation
+	GET_THREAD_INFO(r8)
+	ld	r9, @(TI_FLAGS, r8)
+	and3	r4, r9, #_TIF_SYSCALL_TRACE
+	bnez	r4, syscall_trace_entry
+syscall_call:
+	slli	r7, #2			; table jump for the system call
+	LDIMM	(r4, sys_call_table)
+	add	r7, r4
+	ld	r7, @r7
+	jl	r7			; execute system call
+	st	r0, R0(sp)		; save the return value
+syscall_exit:
+	CLI(r4)				; make sure we don't miss an interrupt
+					; setting need_resched or sigpending
+					; between sampling and the iret
+	ld	r9, @(TI_FLAGS, r8)
+	and3	r4, r9, #_TIF_ALLWORK_MASK	; current->work
+	bnez	r4, syscall_exit_work
+restore_all:
+	RESTORE_ALL
+
+	# perform work that needs to be done immediately before resumption
+	# r9 : frags
+	ALIGN
+work_pending:
+	and3	r4, r9, #_TIF_NEED_RESCHED
+	beqz	r4, work_notifysig
+work_resched:
+	bl	schedule
+	CLI(r4)				; make sure we don't miss an interrupt
+					; setting need_resched or sigpending
+					; between sampling and the iret
+	ld	r9, @(TI_FLAGS, r8)
+	and3	r4, r9, #_TIF_WORK_MASK	; is there any work to be done other
+					; than syscall tracing?
+	beqz	r4, restore_all
+	and3	r4, r4, #_TIF_NEED_RESCHED
+	bnez	r4, work_resched
+
+work_notifysig:				; deal with pending signals and
+					; notify-resume requests
+	mv	r0, sp			; arg1 : struct pt_regs *regs
+	ldi	r1, #0			; arg2 : sigset_t *oldset
+	mv	r2, r9			; arg3 : __u32 thread_info_flags
+	bl	do_notify_resume
+	bra	restore_all
+
+	; perform syscall exit tracing
+	ALIGN
+syscall_trace_entry:
+	ldi	r4, #-ENOSYS
+	st	r4, R0(sp)
+	bl	do_syscall_trace
+	ld	r0, ORIG_R0(sp)
+	ld	r1, R1(sp)
+	ld	r2, R2(sp)
+	ld	r3, R3(sp)
+	ld	r4, R4(sp)
+	ld	r5, R5(sp)
+	ld	r6, R6(sp)
+	ld	r7, SYSCALL_NR(sp)
+	cmpui	r7, #NR_syscalls
+	bc	syscall_call
+	bra	syscall_exit
+
+	; perform syscall exit tracing
+	ALIGN
+syscall_exit_work:
+	ld	r9, @(TI_FLAGS, r8)
+	and3	r4, r9, #_TIF_SYSCALL_TRACE
+	beqz	r4, work_pending
+	STI(r4)				; could let do_syscall_trace() call
+					; schedule() instead
+	bl	do_syscall_trace
+	bra	resume_userspace
+
+	ALIGN
+syscall_fault:
+	SAVE_ALL
+	GET_THREAD_INFO(r8)
+	ldi	r4, #-EFAULT
+	st	r4, R0(sp)
+	bra	resume_userspace
+
+	ALIGN
+syscall_badsys:
+	ldi	r4, #-ENOSYS
+	st	r4, R0(sp)
+	bra	resume_userspace
+
+/* 
+ * EI handler routine
+ */
+ENTRY(ei_handler)
+#if defined(CONFIG_CHIP_M32700) 
+	SWITCH_TO_KERNEL_STACK
+	; WORKAROUND: force to clear SM bit and use the kernel stack (SPI).
+#endif
+	SAVE_ALL
+	mv	r1, sp			; arg1(regs)
+#if defined(CONFIG_CHIP_VDEC2) || defined(CONFIG_CHIP_XNUX2) \
+	|| defined(CONFIG_CHIP_M32700) || defined(CONFIG_CHIP_M32102) \
+	|| defined(CONFIG_CHIP_OPSP)
+
+;    GET_ICU_STATUS;
+	seth	r0, #shigh(M32R_ICU_ISTS_ADDR)
+	ld	r0, @(low(M32R_ICU_ISTS_ADDR),r0)
+	st	r0, @-sp
+#if defined(CONFIG_SMP)
+	/*
+	 * If IRQ == 0      --> Nothing to do,  Not write IMASK
+	 * If IRQ == IPI    --> Do IPI handler, Not write IMASK
+	 * If IRQ != 0, IPI --> Do do_IRQ(),    Write IMASK
+	 */
+	slli	r0, #4
+	srli	r0, #24			; r0(irq_num<<2)
+	;; IRQ exist check
+#if defined(CONFIG_CHIP_M32700)
+	/* WORKAROUND: IMASK bug M32700-TS1, TS2 chip. */
+	beqz	r0, 3f			; if (!irq_num) goto exit
+#else
+	beqz	r0, 1f			; if (!irq_num) goto exit
+#endif	/* WORKAROUND */
+	;; IPI check
+	cmpi	r0, #(M32R_IRQ_IPI0<<2)	; ISN < IPI0 check
+	bc	2f
+	cmpi	r0, #((M32R_IRQ_IPI7+1)<<2)	; ISN > IPI7 check
+	bnc	2f
+	LDIMM	(r2, _EI_VEC_TABLE)
+	add	r2, r0
+	ld	r2, @r2
+	beqz	r2, 1f			; if (no IPI handler) goto exit
+	mv	r0, r1			; arg0(regs)
+	jl	r2
+	.fillinsn
+1:
+	addi	sp, #4
+	bra	ret_to_intr
+#if defined(CONFIG_CHIP_M32700)
+	/* WORKAROUND: IMASK bug M32700-TS1, TS2 chip. */
+	.fillinsn
+3:
+	ld24	r14, #0x00070000
+	seth	r0, #shigh(M32R_ICU_IMASK_ADDR)
+	st	r14, @(low(M32R_ICU_IMASK_ADDR), r0)
+	addi	sp, #4
+	bra	ret_to_intr
+#endif	/* WORKAROUND */
+	;; do_IRQ
+	.fillinsn
+2:
+	srli	r0, #2
+#if defined(CONFIG_PLAT_USRV)
+	add3	r2, r0, #-(M32R_IRQ_INT1)	; INT1# interrupt
+	bnez	r2, 9f
+	; read ICU status register of PLD
+	seth	r0, #high(PLD_ICUISTS)
+	or3	r0, r0, #low(PLD_ICUISTS)
+	lduh	r0, @r0
+	slli	r0, #21
+	srli	r0, #27				; ISN
+	addi	r0, #(M32700UT_PLD_IRQ_BASE)
+	.fillinsn
+9:
+#elif defined(CONFIG_PLAT_M32700UT)
+	add3	r2, r0, #-(M32R_IRQ_INT1)       ; INT1# interrupt
+	bnez	r2, check_int0
+	; read ICU status register of PLD
+	seth	r0, #high(PLD_ICUISTS)
+	or3	r0, r0, #low(PLD_ICUISTS)
+	lduh	r0, @r0
+	slli	r0, #21
+	srli	r0, #27                         ; ISN
+	addi	r0, #(M32700UT_PLD_IRQ_BASE)
+	bra	check_end
+	.fillinsn
+check_int0:
+	add3	r2, r0, #-(M32R_IRQ_INT0)       ; INT0# interrupt
+	bnez	r2, check_int2
+	; read ICU status of LAN-board
+	seth	r0, #high(M32700UT_LAN_ICUISTS)
+	or3	r0, r0, #low(M32700UT_LAN_ICUISTS)
+	lduh	r0, @r0
+	slli	r0, #21
+	srli	r0, #27                         ; ISN
+	add3	r0, r0, #(M32700UT_LAN_PLD_IRQ_BASE)
+	bra	check_end
+	.fillinsn
+check_int2:
+	add3	r2, r0, #-(M32R_IRQ_INT2)       ; INT2# interrupt
+	bnez	r2, check_end
+	; read ICU status of LCD-board
+	seth	r0, #high(M32700UT_LCD_ICUISTS)
+	or3	r0, r0, #low(M32700UT_LCD_ICUISTS)
+	lduh	r0, @r0
+	slli	r0, #21
+	srli	r0, #27                         ; ISN
+	add3	r0, r0, #(M32700UT_LCD_PLD_IRQ_BASE)
+	bra	check_end
+	.fillinsn
+check_end:
+#elif defined(CONFIG_PLAT_OPSPUT)
+	add3	r2, r0, #-(M32R_IRQ_INT1)       ; INT1# interrupt
+	bnez	r2, check_int0
+	; read ICU status register of PLD
+	seth	r0, #high(PLD_ICUISTS)
+	or3	r0, r0, #low(PLD_ICUISTS)
+	lduh	r0, @r0
+	slli	r0, #21
+	srli	r0, #27                         ; ISN
+	addi	r0, #(OPSPUT_PLD_IRQ_BASE)
+	bra	check_end
+	.fillinsn
+check_int0:
+	add3	r2, r0, #-(M32R_IRQ_INT0)       ; INT0# interrupt
+	bnez	r2, check_int2
+	; read ICU status of LAN-board
+	seth	r0, #high(OPSPUT_LAN_ICUISTS)
+	or3	r0, r0, #low(OPSPUT_LAN_ICUISTS)
+	lduh	r0, @r0
+	slli	r0, #21
+	srli	r0, #27                         ; ISN
+	add3	r0, r0, #(OPSPUT_LAN_PLD_IRQ_BASE)
+	bra	check_end
+	.fillinsn
+check_int2:
+	add3	r2, r0, #-(M32R_IRQ_INT2)       ; INT2# interrupt
+	bnez	r2, check_end
+	; read ICU status of LCD-board
+	seth	r0, #high(OPSPUT_LCD_ICUISTS)
+	or3	r0, r0, #low(OPSPUT_LCD_ICUISTS)
+	lduh	r0, @r0
+	slli	r0, #21
+	srli	r0, #27                         ; ISN
+	add3	r0, r0, #(OPSPUT_LCD_PLD_IRQ_BASE)
+	bra	check_end
+	.fillinsn
+check_end:
+#endif  /* CONFIG_PLAT_OPSPUT */
+	bl	do_IRQ			; r0(irq), r1(regs)
+#else  /* not CONFIG_SMP */
+	srli	r0, #22			; r0(irq)
+#if defined(CONFIG_PLAT_USRV)
+	add3	r2, r0, #-(M32R_IRQ_INT1)	; INT1# interrupt
+	bnez	r2, 1f
+	; read ICU status register of PLD
+	seth	r0, #high(PLD_ICUISTS)
+	or3	r0, r0, #low(PLD_ICUISTS)
+	lduh	r0, @r0
+	slli	r0, #21
+	srli	r0, #27				; ISN
+	addi	r0, #(M32700UT_PLD_IRQ_BASE)
+	.fillinsn
+1:
+#elif defined(CONFIG_PLAT_M32700UT) 
+	add3	r2, r0, #-(M32R_IRQ_INT1)       ; INT1# interrupt
+	bnez	r2, check_int0
+	; read ICU status register of PLD
+	seth	r0, #high(PLD_ICUISTS)
+	or3	r0, r0, #low(PLD_ICUISTS)
+	lduh	r0, @r0
+	slli	r0, #21
+	srli	r0, #27                         ; ISN
+	addi	r0, #(M32700UT_PLD_IRQ_BASE)
+	bra	check_end
+	.fillinsn
+check_int0:
+	add3	r2, r0, #-(M32R_IRQ_INT0)       ; INT0# interrupt
+	bnez	r2, check_int2
+	; read ICU status of LAN-board
+	seth	r0, #high(M32700UT_LAN_ICUISTS)
+	or3	r0, r0, #low(M32700UT_LAN_ICUISTS)
+	lduh	r0, @r0
+	slli	r0, #21
+	srli	r0, #27                         ; ISN
+	add3	r0, r0, #(M32700UT_LAN_PLD_IRQ_BASE)
+	bra	check_end
+	.fillinsn
+check_int2:
+	add3	r2, r0, #-(M32R_IRQ_INT2)       ; INT2# interrupt
+	bnez	r2, check_end
+	; read ICU status of LCD-board
+	seth	r0, #high(M32700UT_LCD_ICUISTS)
+	or3	r0, r0, #low(M32700UT_LCD_ICUISTS)
+	lduh	r0, @r0
+	slli	r0, #21
+	srli	r0, #27                         ; ISN
+	add3	r0, r0, #(M32700UT_LCD_PLD_IRQ_BASE)
+	bra	check_end
+	.fillinsn
+check_end:
+#elif defined(CONFIG_PLAT_OPSPUT)
+	add3	r2, r0, #-(M32R_IRQ_INT1)       ; INT1# interrupt
+	bnez	r2, check_int0
+	; read ICU status register of PLD
+	seth	r0, #high(PLD_ICUISTS)
+	or3	r0, r0, #low(PLD_ICUISTS)
+	lduh	r0, @r0
+	slli	r0, #21
+	srli	r0, #27                         ; ISN
+	addi	r0, #(OPSPUT_PLD_IRQ_BASE)
+	bra	check_end
+	.fillinsn
+check_int0:
+	add3	r2, r0, #-(M32R_IRQ_INT0)       ; INT0# interrupt
+	bnez	r2, check_int2
+	; read ICU status of LAN-board
+	seth	r0, #high(OPSPUT_LAN_ICUISTS)
+	or3	r0, r0, #low(OPSPUT_LAN_ICUISTS)
+	lduh	r0, @r0
+	slli	r0, #21
+	srli	r0, #27                         ; ISN
+	add3	r0, r0, #(OPSPUT_LAN_PLD_IRQ_BASE)
+	bra	check_end
+	.fillinsn
+check_int2:
+	add3	r2, r0, #-(M32R_IRQ_INT2)       ; INT2# interrupt
+	bnez	r2, check_end
+	; read ICU status of LCD-board
+	seth	r0, #high(OPSPUT_LCD_ICUISTS)
+	or3	r0, r0, #low(OPSPUT_LCD_ICUISTS)
+	lduh	r0, @r0
+	slli	r0, #21
+	srli	r0, #27                         ; ISN
+	add3	r0, r0, #(OPSPUT_LCD_PLD_IRQ_BASE)
+	bra	check_end
+	.fillinsn
+check_end:
+#endif  /* CONFIG_PLAT_OPSPUT */
+	bl	do_IRQ
+#endif  /* CONFIG_SMP */
+	ld	r14, @sp+
+	seth	r0, #shigh(M32R_ICU_IMASK_ADDR)
+	st	r14, @(low(M32R_ICU_IMASK_ADDR),r0)
+#else
+#error no chip configuration
+#endif
+ret_to_intr:
+	bra  ret_from_intr
+
+/* 
+ * Default EIT handler
+ */
+	ALIGN
+int_msg:
+	.asciz  "Unknown interrupt\n"
+	.byte	0
+
+ENTRY(default_eit_handler)
+	push	r0
+	mvfc	r0, psw
+	push	r1
+	push	r2
+	push	r3
+	push	r0
+	LDIMM	(r0, __KERNEL_DS)
+	mv	r0, r1
+	mv	r0, r2
+	LDIMM	(r0, int_msg)
+	bl	printk
+	pop	r0
+	pop	r3
+	pop	r2
+	pop	r1
+	mvtc	r0, psw
+	pop	r0
+infinit:
+	bra	infinit
+
+#ifdef CONFIG_MMU
+/* 
+ * Access Exception handler
+ */
+ENTRY(ace_handler)
+	SWITCH_TO_KERNEL_STACK
+	SAVE_ALL
+
+	seth	r2, #shigh(MMU_REG_BASE)	/* Check status register */
+	ld	r4, @(low(MESTS_offset),r2)
+	st	r4, @(low(MESTS_offset),r2)
+	srl3	r1, r4, #4
+#ifdef CONFIG_CHIP_M32700 
+	and3	r1, r1, #0x0000ffff
+	; WORKAROUND: ignore TME bit for the M32700(TS1).
+#endif /* CONFIG_CHIP_M32700 */
+	beqz	r1, inst
+oprand:
+	ld	r2, @(low(MDEVA_offset),r2)	; set address
+	srli	r2, #12
+	slli	r2, #12
+	srli	r1, #1
+	bra	1f
+inst:
+	and3	r1, r4, #2
+	srli	r1, #1
+	or3	r1, r1, #8
+	mvfc	r2, bpc				; set address
+	.fillinsn
+1:
+	mvfc	r3, psw
+	mv	r0, sp
+	and3	r3, r3, 0x800
+	srli	r3, #9
+	or	r1, r3
+	/*
+	 * do_page_fault():
+	 *    r0 : struct pt_regs *regs
+	 *    r1 : unsigned long error-code
+	 *    r2 : unsigned long address
+	 * error-code:
+	 *    +------+------+------+------+
+	 *    | bit3 | bit2 | bit1 | bit0 |
+	 *    +------+------+------+------+
+	 *    bit 3 == 0:means data,          1:means instruction
+	 *    bit 2 == 0:means kernel,        1:means user-mode
+	 *    bit 1 == 0:means read,          1:means write
+	 *    bit 0 == 0:means no page found  1:means protection fault
+	 *
+	 */
+	bl	do_page_fault
+	bra	ret_from_intr
+#endif  /* CONFIG_MMU */
+
+
+ENTRY(alignment_check)
+/* void alignment_check(int error_code) */
+	SWITCH_TO_KERNEL_STACK
+	SAVE_ALL
+	ldi	r1, #0x30			; error_code
+	mv	r0, sp				; pt_regs
+	bl	do_alignment_check
+error_code:
+	bra	ret_from_exception
+
+ENTRY(rie_handler)
+/* void rie_handler(int error_code) */
+	SWITCH_TO_KERNEL_STACK
+	SAVE_ALL
+	mvfc	r0, bpc
+	ld	r1, @r0
+	seth	r0, #0xa0f0
+	st	r1, @r0
+	ldi	r1, #0x20			; error_code
+	mv	r0, sp				; pt_regs
+	bl	do_rie_handler
+	bra	error_code
+
+ENTRY(pie_handler)
+/* void pie_handler(int error_code) */
+	SWITCH_TO_KERNEL_STACK
+	SAVE_ALL
+	ldi	r1, #0				; error_code ; FIXME
+	mv	r0, sp				; pt_regs
+	bl	do_pie_handler
+	bra	error_code
+
+ENTRY(debug_trap)
+	.global	withdraw_debug_trap
+	/* void debug_trap(void) */
+	SWITCH_TO_KERNEL_STACK
+	SAVE_ALL
+	mv	r0, sp				; pt_regs
+	bl	withdraw_debug_trap		
+	ldi	r1, #0				; error_code
+	mv	r0, sp				; pt_regs
+	bl	do_debug_trap
+	bra	error_code
+
+
+/* Cache flushing handler */
+ENTRY(cache_flushing_handler)
+	.global	_flush_cache_all
+	/* void _flush_cache_all(void); */
+	SWITCH_TO_KERNEL_STACK
+	push	r0
+	push	r1
+	push	r2
+	push	r3
+	push	r4
+	push	r5
+	push	r6
+	push	r7
+	push	lr
+	bl	_flush_cache_all
+	pop	lr
+	pop	r7
+	pop	r6
+	pop	r5
+	pop	r4
+	pop	r3
+	pop	r2
+	pop	r1
+	pop	r0
+	rte
+
+.data
+ENTRY(sys_call_table)
+	.long sys_restart_syscall	/* 0  -  old "setup()" system call*/
+	.long sys_exit
+	.long sys_fork
+	.long sys_read
+	.long sys_write
+	.long sys_open			/* 5 */
+	.long sys_close
+	.long sys_waitpid
+	.long sys_creat
+	.long sys_link
+	.long sys_unlink		/* 10 */
+	.long sys_execve
+	.long sys_chdir
+	.long sys_time
+	.long sys_mknod
+	.long sys_chmod			/* 15 */
+	.long sys_lchown
+	.long sys_ni_syscall		/* old break syscall holder */
+	.long sys_stat
+	.long sys_lseek
+	.long sys_getpid		/* 20 */
+	.long sys_mount
+	.long sys_oldumount
+	.long sys_setuid
+	.long sys_getuid
+	.long sys_stime			/* 25 */
+	.long sys_ptrace
+	.long sys_alarm
+	.long sys_fstat
+	.long sys_pause
+	.long sys_utime			/* 30 */
+	.long sys_cacheflush		/* for M32R */ /* old stty syscall holder */
+	.long sys_cachectl		/* for M32R */ /* old gtty syscall holder */
+	.long sys_access
+	.long sys_nice
+	.long sys_ni_syscall		/* 35  -  old ftime syscall holder */
+	.long sys_sync
+	.long sys_kill
+	.long sys_rename
+	.long sys_mkdir
+	.long sys_rmdir			/* 40 */
+	.long sys_dup
+	.long sys_pipe
+	.long sys_times
+	.long sys_ni_syscall		/* old prof syscall holder */
+	.long sys_brk			/* 45 */
+	.long sys_setgid
+	.long sys_getgid
+	.long sys_signal
+	.long sys_geteuid
+	.long sys_getegid		/* 50 */
+	.long sys_acct
+	.long sys_umount		/* recycled never used phys() */
+	.long sys_ni_syscall		/* old lock syscall holder */
+	.long sys_ioctl
+	.long sys_fcntl			/* 55 */
+	.long sys_ni_syscall		/* old mpx syscall holder */
+	.long sys_setpgid
+	.long sys_ni_syscall		/* old ulimit syscall holder */
+	.long sys_ni_syscall		/* sys_olduname */
+	.long sys_umask			/* 60 */
+	.long sys_chroot
+	.long sys_ustat
+	.long sys_dup2
+	.long sys_getppid
+	.long sys_getpgrp		/* 65 */
+	.long sys_setsid
+	.long sys_sigaction
+	.long sys_sgetmask
+	.long sys_ssetmask
+	.long sys_setreuid		/* 70 */
+	.long sys_setregid
+	.long sys_sigsuspend
+	.long sys_sigpending
+	.long sys_sethostname
+	.long sys_setrlimit		/* 75 */
+	.long sys_getrlimit
+	.long sys_getrusage
+	.long sys_gettimeofday
+	.long sys_settimeofday
+	.long sys_getgroups		/* 80 */
+	.long sys_setgroups
+	.long sys_ni_syscall		/* sys_oldselect */
+	.long sys_symlink
+	.long sys_lstat
+	.long sys_readlink		/* 85 */
+	.long sys_uselib
+	.long sys_swapon
+	.long sys_reboot
+	.long old_readdir
+	.long old_mmap			/* 90 */
+	.long sys_munmap
+	.long sys_truncate
+	.long sys_ftruncate
+	.long sys_fchmod
+	.long sys_fchown		/* 95 */
+	.long sys_getpriority
+	.long sys_setpriority
+	.long sys_ni_syscall		/* old profil syscall holder */
+	.long sys_statfs
+	.long sys_fstatfs		/* 100 */
+	.long sys_ni_syscall		/* ioperm */
+	.long sys_socketcall
+	.long sys_syslog
+	.long sys_setitimer
+	.long sys_getitimer		/* 105 */
+	.long sys_newstat
+	.long sys_newlstat
+	.long sys_newfstat
+	.long sys_uname
+	.long sys_ni_syscall		/* 110  -  iopl */
+	.long sys_vhangup
+	.long sys_ni_syscall		/* for idle */
+	.long sys_ni_syscall		/* for vm86old */
+	.long sys_wait4
+	.long sys_swapoff		/* 115 */
+	.long sys_sysinfo
+	.long sys_ipc
+	.long sys_fsync
+	.long sys_sigreturn
+	.long sys_clone			/* 120 */
+	.long sys_setdomainname
+	.long sys_newuname
+	.long sys_ni_syscall		/* sys_modify_ldt */
+	.long sys_adjtimex
+	.long sys_mprotect		/* 125 */
+	.long sys_sigprocmask
+	.long sys_ni_syscall		/* sys_create_module */
+	.long sys_init_module
+	.long sys_delete_module
+	.long sys_ni_syscall		/* 130 sys_get_kernel_syms */
+	.long sys_quotactl
+	.long sys_getpgid
+	.long sys_fchdir
+	.long sys_bdflush
+	.long sys_sysfs			/* 135 */
+	.long sys_personality
+	.long sys_ni_syscall		/* for afs_syscall */
+	.long sys_setfsuid
+	.long sys_setfsgid
+	.long sys_llseek		/* 140 */
+	.long sys_getdents
+	.long sys_select
+	.long sys_flock
+	.long sys_msync
+	.long sys_readv			/* 145 */
+	.long sys_writev
+	.long sys_getsid
+	.long sys_fdatasync
+	.long sys_sysctl
+	.long sys_mlock			/* 150 */
+	.long sys_munlock
+	.long sys_mlockall
+	.long sys_munlockall
+	.long sys_sched_setparam
+	.long sys_sched_getparam	/* 155 */
+	.long sys_sched_setscheduler
+	.long sys_sched_getscheduler
+	.long sys_sched_yield
+	.long sys_sched_get_priority_max
+	.long sys_sched_get_priority_min	/* 160 */
+	.long sys_sched_rr_get_interval
+	.long sys_nanosleep
+	.long sys_mremap
+	.long sys_setresuid
+	.long sys_getresuid		/* 165 */
+	.long sys_tas			/* vm86 */
+	.long sys_ni_syscall		/* sys_query_module */
+	.long sys_poll
+	.long sys_nfsservctl
+	.long sys_setresgid		/* 170 */
+	.long sys_getresgid
+	.long sys_prctl
+	.long sys_rt_sigreturn
+	.long sys_rt_sigaction
+	.long sys_rt_sigprocmask	/* 175 */
+	.long sys_rt_sigpending
+	.long sys_rt_sigtimedwait
+	.long sys_rt_sigqueueinfo
+	.long sys_rt_sigsuspend
+	.long sys_pread64		/* 180 */
+	.long sys_pwrite64
+	.long sys_chown
+	.long sys_getcwd
+	.long sys_capget
+	.long sys_capset		/* 185 */
+	.long sys_sigaltstack
+	.long sys_sendfile
+	.long sys_ni_syscall		/* streams1 */
+	.long sys_ni_syscall		/* streams2 */
+	.long sys_vfork			/* 190 */
+	.long sys_getrlimit
+	.long sys_mmap2
+	.long sys_truncate64
+	.long sys_ftruncate64
+	.long sys_stat64		/* 195 */
+	.long sys_lstat64
+	.long sys_fstat64
+	.long sys_lchown
+	.long sys_getuid
+	.long sys_getgid		/* 200 */
+	.long sys_geteuid
+	.long sys_getegid
+	.long sys_setreuid
+	.long sys_setregid
+	.long sys_getgroups		/* 205 */
+	.long sys_setgroups
+	.long sys_fchown
+	.long sys_setresuid
+	.long sys_getresuid
+	.long sys_setresgid		/* 210 */
+	.long sys_getresgid
+	.long sys_chown
+	.long sys_setuid
+	.long sys_setgid
+	.long sys_setfsuid		/* 215 */
+	.long sys_setfsgid
+	.long sys_pivot_root
+	.long sys_mincore
+	.long sys_madvise
+	.long sys_getdents64		/* 220 */
+	.long sys_fcntl64
+	.long sys_ni_syscall		/* reserved for TUX */
+	.long sys_ni_syscall		/* Reserved for Security */
+	.long sys_gettid
+	.long sys_readahead		/* 225 */
+	.long sys_setxattr
+	.long sys_lsetxattr
+	.long sys_fsetxattr
+	.long sys_getxattr
+	.long sys_lgetxattr		/* 230 */
+	.long sys_fgetxattr
+	.long sys_listxattr
+	.long sys_llistxattr
+	.long sys_flistxattr
+	.long sys_removexattr		/* 235 */
+	.long sys_lremovexattr
+	.long sys_fremovexattr
+	.long sys_tkill
+	.long sys_sendfile64
+	.long sys_futex			/* 240 */
+	.long sys_sched_setaffinity
+	.long sys_sched_getaffinity
+	.long sys_ni_syscall		/* reserved for "set_thread_area" system call */
+	.long sys_ni_syscall		/* reserved for "get_thread_area" system call */
+	.long sys_io_setup		/* 245 */
+	.long sys_io_destroy
+	.long sys_io_getevents
+	.long sys_io_submit
+	.long sys_io_cancel
+	.long sys_fadvise64		/* 250 */
+	.long sys_ni_syscall
+	.long sys_exit_group
+	.long sys_lookup_dcookie
+	.long sys_epoll_create
+	.long sys_epoll_ctl		/* 255 */
+	.long sys_epoll_wait
+ 	.long sys_remap_file_pages
+ 	.long sys_set_tid_address
+ 	.long sys_timer_create
+ 	.long sys_timer_settime		/* 260 */
+ 	.long sys_timer_gettime
+ 	.long sys_timer_getoverrun
+ 	.long sys_timer_delete
+ 	.long sys_clock_settime
+ 	.long sys_clock_gettime		/* 265 */
+ 	.long sys_clock_getres
+ 	.long sys_clock_nanosleep
+	.long sys_statfs64
+	.long sys_fstatfs64     
+	.long sys_tgkill		/* 270 */
+	.long sys_utimes
+ 	.long sys_fadvise64_64
+	.long sys_ni_syscall		/* Reserved for sys_vserver */
+        .long sys_ni_syscall		/* Reserved for sys_mbind */
+        .long sys_ni_syscall		/* Reserved for sys_get_mempolicy */
+        .long sys_ni_syscall		/* Reserved for sys_set_mempolicy */
+        .long sys_mq_open
+        .long sys_mq_unlink
+        .long sys_mq_timedsend
+        .long sys_mq_timedreceive       /* 280 */
+        .long sys_mq_notify
+        .long sys_mq_getsetattr
+        .long sys_ni_syscall            /* reserved for kexec */
+
+syscall_table_size=(.-sys_call_table)
+
diff -ruN linux-2.6.7.org/arch/m32r/kernel/head.S linux-2.6.7/arch/m32r/kernel/head.S
--- linux-2.6.7.org/arch/m32r/kernel/head.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/head.S	2004-06-01 14:00:10.000000000 +0900
@@ -0,0 +1,286 @@
+/*  
+ *  linux/arch/m32r/kernel/head.S
+ *  
+ *  M32R startup code.
+ *  
+ *  Copyright (c) 2001, 2002  Hiroyuki Kondo, Hirokazu Takata,
+ *                            Hitoshi Yamamoto                
+ */
+
+/* $Id$ */
+
+#include <linux/init.h>
+__INIT
+__INITDATA
+
+	.text
+#include <linux/config.h>
+#include <linux/linkage.h>
+#include <asm/segment.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/assembler.h>
+#include <asm/m32r.h>
+#include <asm/mmu_context.h>
+
+/*
+ * References to members of the boot_cpu_data structure.
+ */
+	.text
+	.global	start_kernel
+	.global __bss_start
+	.global _end
+ENTRY(stext)
+ENTRY(_stext)
+ENTRY(startup_32)
+	/* Setup up the stack pointer */
+	LDIMM	(r0, spi_stack_top)
+	LDIMM	(r1, spu_stack_top)
+	mvtc	r0, spi
+	mvtc	r1, spu
+
+	/* Initilalize PSW */
+	ldi	r0, #0x0000		/* use SPI, disable EI */
+	mvtc	r0, psw	
+
+	/* Set up the stack pointer */
+	LDIMM	(r0, stack_start)
+	ld	r0, @r0
+	mvtc	r0, spi
+
+/*
+ * Clear BSS first so that there are no surprises...
+ */
+#ifdef CONFIG_ISA_DUAL_ISSUE
+
+	LDIMM	(r2, __bss_start)
+	LDIMM	(r3, _end)
+	sub	r3, r2		; BSS size in bytes
+	; R4 = BSS size in longwords (rounded down)
+	mv	r4, r3		    ||	ldi	r1, #0
+	srli	r4, #4		    ||	addi	r2, #-4	
+	beqz	r4, .Lendloop1
+.Lloop1:	
+#ifndef CONFIG_CHIP_M32310
+	; Touch memory for the no-write-allocating cache.
+	ld	r0, @(4,r2)
+#endif
+	st	r1, @+r2	    ||	addi	r4, #-1
+	st	r1, @+r2
+	st	r1, @+r2
+	st	r1, @+r2	    ||	cmpeq	r1, r4	; R4 = 0?
+	bnc	.Lloop1
+.Lendloop1:
+	and3	r4, r3, #15
+	addi	r2, #4
+	beqz	r4, .Lendloop2
+.Lloop2:
+	stb	r1, @r2		    ||	addi	r4, #-1
+	addi	r2, #1
+	bnez	r4, .Lloop2
+.Lendloop2:
+
+#else /* not CONFIG_ISA_DUAL_ISSUE */
+
+	LDIMM	(r2, __bss_start)
+	LDIMM	(r3, _end)
+	sub	r3, r2		; BSS size in bytes
+	mv	r4, r3
+	srli	r4, #2		; R4 = BSS size in longwords (rounded down)
+	ldi	r1, #0		; clear R1 for longwords store
+	addi	r2, #-4		; account for pre-inc store
+	beqz	r4, .Lendloop1	; any more to go?
+.Lloop1:	
+	st	r1, @+r2	; yep, zero out another longword
+	addi	r4, #-1		; decrement count
+	bnez	r4, .Lloop1	; go do some more
+.Lendloop1:
+	and3	r4, r3, #3	; get no. of remaining BSS bytes to clear
+	addi	r2, #4		; account for pre-inc store
+	beqz	r4, .Lendloop2	; any more to go?
+.Lloop2:
+	stb	r1, @r2		; yep, zero out another byte
+	addi	r2, #1		; bump address
+	addi	r4, #-1		; decrement count
+	bnez	r4, .Lloop2	; go do some more
+.Lendloop2:		
+
+#endif /* not CONFIG_ISA_DUAL_ISSUE */
+
+#if 0  /* M32R_FIXME */
+/* 
+ * Copy data segment from ROM to RAM.
+ */
+	.global ROM_D, TOP_DATA, END_DATA
+	
+	LDIMM	(r1, ROM_D)
+	LDIMM	(r2, TOP_DATA)
+	LDIMM	(r3, END_DATA)
+	addi	r2, #-4
+	addi	r3, #-4
+loop1:
+	ld	r0, @r1+
+	st	r0, @+r2
+	cmp	r2, r3
+	bc	loop1
+#endif /* 0 */
+		
+/* Jump to kernel */
+	LDIMM	(r2, start_kernel)
+	jl	r2
+	.fillinsn
+1:
+	bra	1b		; main should never return here, but
+				; just in case, we know what happens.
+
+#ifdef CONFIG_SMP
+/* 
+ * AP startup routine
+ */
+	.text
+ENTRY(startup_AP)
+;; setup EVB
+	LDIMM  (r4, _RE)
+	mvtc   r4, cr5
+	
+;; enable MMU
+	LDIMM	(r2, init_tlb)
+	jl	r2
+	seth  r4, #high(MATM)
+	or3   r4, r4, #low(MATM)
+	ldi   r5, #0x01
+	st    r5, @r4            ; Set MATM Reg(T bit ON)
+	ld    r6, @r4            ; MATM Check
+	LDIMM (r5, 1f)
+	jmp   r5                 ; enable MMU
+	nop   
+	.fillinsn
+1:  
+;; ISN check
+	ld    r6, @r4            ; MATM Check
+	seth  r4, #high(M32R_ICU_ISTS_ADDR)
+	or3   r4, r4, #low(M32R_ICU_ISTS_ADDR)
+	ld    r5, @r4		; Read ISTSi reg.
+	mv    r6, r5
+	slli  r5, #13  ; PIML check
+	srli  r5, #13  ; 
+	seth  r4, #high(M32R_ICU_IMASK_ADDR)
+	or3   r4, r4, #low(M32R_ICU_IMASK_ADDR)
+	st    r5, @r4		; Write IMASKi reg.
+	slli  r6, #4   ; ISN check
+	srli  r6, #26  ; 
+	seth  r4, #high(M32R_IRQ_IPI5)
+	or3   r4, r4, #low(M32R_IRQ_IPI5)
+	bne   r4, r6, 2f  ; if (ISN != CPU_BOOT_IPI) goto sleep;
+	
+;; check cpu_bootout_map and set cpu_bootin_map
+	LDIMM (r4, cpu_bootout_map)
+	ld    r4, @r4
+	seth  r5, #high(M32R_CPUID_PORTL)
+	or3   r5, r5, #low(M32R_CPUID_PORTL)
+	ld    r5, @r5
+	ldi   r6, #1
+	sll   r6, r5
+	and   r4, r6
+	beqz  r4, 2f
+	LDIMM (r4, cpu_bootin_map)
+	ld    r5, @r4
+	or    r5, r6
+	st    r6, @r4
+	
+;; clear PSW
+	ldi   r4, #0
+	mvtc  r4, psw
+	
+;; setup SPI
+	LDIMM (r4, stack_start)
+	ld    r4, @r4
+	mvtc  r4, spi
+	
+;; setup BPC (start_secondary)
+	LDIMM (r4, start_secondary)
+	mvtc  r4, bpc
+	
+	rte  ; goto startup_secondary
+	nop
+	nop
+	
+	.fillinsn
+2:  
+	;; disable MMU
+	seth  r4, #high(MATM)
+	or3   r4, r4, #low(MATM)
+	ldi   r5, #0
+    	st    r5, @r4            ; Set MATM Reg(T bit OFF)
+    	ld    r6, @r4            ; MATM Check
+	LDIMM (r4, 3f)
+	seth  r5, #high(__PAGE_OFFSET)
+	or3   r5, r5, #low(__PAGE_OFFSET)
+	not   r5, r5
+	and   r4, r5
+	jmp   r4                 ; disable MMU
+	nop   
+	.fillinsn
+3:
+	;; SLEEP and wait IPI
+	LDIMM (r4, AP_loop)
+	seth  r5, #high(__PAGE_OFFSET)
+	or3   r5, r5, #low(__PAGE_OFFSET)
+	not   r5, r5
+	and   r4, r5
+	jmp   r4
+	nop
+	nop
+#endif  /* CONFIG_SMP */
+
+ENTRY(stack_start)
+	.long	init_thread_union+8192
+	.long	__KERNEL_DS
+
+/*
+ * This is initialized to create a identity-mapping at 0-4M (for bootup
+ * purposes) and another mapping of the 0-4M area at virtual address
+ * PAGE_OFFSET.
+ */
+	.text
+
+#define  MOUNT_ROOT_RDONLY    1
+#define  RAMDISK_FLAGS        0		; 1024KB
+#define  ORIG_ROOT_DEV        0x0100	; /dev/ram0 (major:01, minor:00)
+#define  LOADER_TYPE          1		; (??? - non-zero value seems 
+					; to be needed to boot from initrd)
+
+#define  COMMAND_LINE ""
+
+	.section	.empty_zero_page, "aw"
+ENTRY(empty_zero_page)
+	.long	MOUNT_ROOT_RDONLY		/* offset: +0x00 */
+	.long	RAMDISK_FLAGS
+	.long	ORIG_ROOT_DEV
+	.long	LOADER_TYPE
+	.long	0	/* INITRD_START */	/* +0x10 */
+	.long	0	/* INITRD_SIZE */
+	.long	0	/* CPU_CLOCK */
+	.long	0	/* BUS_CLOCK */
+	.long	0	/* TIMER_DIVIDE */	/* +0x20 */
+	.balign	256,0
+	.asciz	COMMAND_LINE
+  	.byte	0
+	.balign	4096,0,4096
+
+/*------------------------------------------------------------------------
+ * Stack area
+ */
+	.section .spi	
+	ALIGN
+	.global spi_stack_top
+	.zero	1024
+spi_stack_top:
+
+	.section .spu
+	ALIGN
+	.global spu_stack_top
+	.zero	1024
+spu_stack_top:
+
+	.end
diff -ruN linux-2.6.7.org/arch/m32r/kernel/init_task.c linux-2.6.7/arch/m32r/kernel/init_task.c
--- linux-2.6.7.org/arch/m32r/kernel/init_task.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/init_task.c	2003-10-09 13:58:37.000000000 +0900
@@ -0,0 +1,40 @@
+/* orig : i386 init_task.c */
+
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/init.h>
+#include <linux/init_task.h>
+#include <linux/fs.h>
+
+#include <asm/uaccess.h>
+#include <asm/pgtable.h>
+
+static struct fs_struct init_fs = INIT_FS;
+static struct files_struct init_files = INIT_FILES;
+static struct signal_struct init_signals = INIT_SIGNALS(init_signals);
+static struct sighand_struct init_sighand = INIT_SIGHAND(init_sighand);
+struct mm_struct init_mm = INIT_MM(init_mm);
+
+EXPORT_SYMBOL(init_mm);
+
+/*
+ * Initial thread structure.
+ *
+ * We need to make sure that this is 8192-byte aligned due to the
+ * way process stacks are handled. This is done by having a special
+ * "init_task" linker map entry..
+ */
+union thread_union init_thread_union 
+	__attribute__((__section__(".data.init_task"))) =
+		{ INIT_THREAD_INFO(init_task) };
+
+/*
+ * Initial task structure.
+ *
+ * All other task structs will be allocated on slabs in fork.c
+ */
+struct task_struct init_task = INIT_TASK(init_task);
+
+EXPORT_SYMBOL(init_task);
+
diff -ruN linux-2.6.7.org/arch/m32r/kernel/io_m32102.c linux-2.6.7/arch/m32r/kernel/io_m32102.c
--- linux-2.6.7.org/arch/m32r/kernel/io_m32102.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/io_m32102.c	2003-09-09 10:15:02.000000000 +0900
@@ -0,0 +1,277 @@
+/* 
+ * Mitsubishi M32R 32102 group
+ * Typical I/O routines.
+ *
+ * Copyright (c) 2001 Hitoshi Yamamoto
+ */
+
+/* $Id$ */
+
+#include <linux/config.h>
+#include <asm/page.h>
+
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32RPCC)
+#include <linux/types.h>
+
+#define M32R_PCC_IOMAP_SIZE 0x1000
+
+#define M32R_PCC_IOSTART0 0x1000
+#define M32R_PCC_IOEND0   (M32R_PCC_IOSTART0 + M32R_PCC_IOMAP_SIZE - 1)
+#define M32R_PCC_IOSTART1 0x2000
+#define M32R_PCC_IOEND1   (M32R_PCC_IOSTART1 + M32R_PCC_IOMAP_SIZE - 1)
+
+extern void pcc_ioread(int, unsigned long, void *, size_t, size_t, int);
+extern void pcc_iowrite(int, unsigned long, void *, size_t, size_t, int);
+#endif /* CONFIG_PCMCIA && CONFIG_M32RPCC */
+
+
+/* 
+ * Function prototypes
+ */
+unsigned char  ne_inb(unsigned long);
+void  ne_outb(unsigned char, unsigned long);
+void  ne_insb(unsigned int, void *, unsigned long);
+void  ne_insw(unsigned int, void *, unsigned long);
+void  ne_outsb(unsigned int, const void *, unsigned long);
+void  ne_outsw(unsigned int, const void *, unsigned long);
+
+#define PORT2ADDR(port)  m32102_port2addr(port)
+
+static __inline__ unsigned long
+m32102_port2addr(unsigned long port)
+{
+	unsigned long  ul;
+	ul = port + PAGE_OFFSET + 0x20000000;
+	return (ul);
+}
+
+unsigned char
+m32102_inb(unsigned long port)
+{
+#ifdef CONFIG_PLAT_MAPPI
+	if(port >= 0x300 && port < 0x320)
+		return ne_inb(port);
+	else
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32RPCC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   unsigned char b;
+	   pcc_ioread(0, port, &b, sizeof(b), 1, 0);
+	   return b;
+	} else 	if (port >= M32R_PCC_IOSTART1 && port <= M32R_PCC_IOEND1) {
+	  unsigned char b;
+	   pcc_ioread(1, port, &b, sizeof(b), 1, 0);
+	   return b;
+	} else
+#endif
+#endif /*  CONFIG_PLAT_MAPPI  */
+	return *(unsigned char *)PORT2ADDR(port);
+}
+
+unsigned short
+m32102_inw(unsigned long port)
+{
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32RPCC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   unsigned short w;
+	   pcc_ioread(0, port, &w, sizeof(w), 1, 0);
+	   return w;
+	} else 	if (port >= M32R_PCC_IOSTART1 && port <= M32R_PCC_IOEND1) {
+	   unsigned short w;
+	   pcc_ioread(1, port, &w, sizeof(w), 1, 0);
+	   return w;
+	} else
+#endif
+	return *(unsigned short *)PORT2ADDR(port);
+}
+
+unsigned long
+m32102_inl(unsigned long port)
+{
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32RPCC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   unsigned long l;
+	   pcc_ioread(0, port, &l, sizeof(l), 1, 0);
+	   return l;
+	} else 	if (port >= M32R_PCC_IOSTART1 && port <= M32R_PCC_IOEND1) {
+	   unsigned short l;
+	   pcc_ioread(1, port, &l, sizeof(l), 1, 0);
+	   return l;
+	} else
+#endif
+	return *(unsigned long *)PORT2ADDR(port);
+}
+
+void
+m32102_outb(unsigned char b, unsigned long port)
+{
+#ifdef CONFIG_PLAT_MAPPI
+	if(port >= 0x300 && port < 0x320)
+		ne_outb(b,port);
+	else
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32RPCC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite(0, port, &b, sizeof(b), 1, 0);
+	} else 	if (port >= M32R_PCC_IOSTART1 && port <= M32R_PCC_IOEND1) {
+	   pcc_iowrite(1, port, &b, sizeof(b), 1, 0);
+	} else
+#endif
+#endif /*  CONFIG_PLAT_MAPPI  */
+	*(unsigned volatile char *)PORT2ADDR(port) = b;
+}
+
+void
+m32102_outw(unsigned short w, unsigned long port)
+{
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32RPCC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite(0, port, &w, sizeof(w), 1, 0);
+	} else 	if (port >= M32R_PCC_IOSTART1 && port <= M32R_PCC_IOEND1) {
+	   pcc_iowrite(1, port, &w, sizeof(w), 1, 0);
+	} else
+#endif
+*(unsigned volatile short *)PORT2ADDR(port) = w;
+}
+
+void
+m32102_outl(unsigned long l, unsigned long port)
+{
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32RPCC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite(0, port, &l, sizeof(l), 1, 0);
+	} else 	if (port >= M32R_PCC_IOSTART1 && port <= M32R_PCC_IOEND1) {
+	   pcc_iowrite(1, port, &l, sizeof(l), 1, 0);
+	} else
+#endif
+	*(unsigned volatile long *)PORT2ADDR(port) = l;
+}
+
+void
+m32102_insb(unsigned int port, void * addr, unsigned long count)
+{
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32RPCC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_ioread(0, port, (void *)addr, sizeof(unsigned char), count, 1);
+	} else 	if (port >= M32R_PCC_IOSTART1 && port <= M32R_PCC_IOEND1) {
+	   pcc_ioread(1, port, (void *)addr, sizeof(unsigned char), count, 1);
+	} else
+#endif
+	while(count--){
+		*(unsigned char *)addr = *(unsigned volatile char *)PORT2ADDR(port);
+		addr+=1;
+	}
+}
+
+void
+m32102_insw(unsigned int port, void * addr, unsigned long count) 
+{
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32RPCC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_ioread(0, port, (void *)addr, sizeof(unsigned short), count, 1);
+	} else 	if (port >= M32R_PCC_IOSTART1 && port <= M32R_PCC_IOEND1) {
+	   pcc_ioread(1, port, (void *)addr, sizeof(unsigned short), count, 1);
+	} else
+#endif
+while(count--){
+		*(unsigned short *)addr = *(unsigned volatile short *)PORT2ADDR(port);
+		addr+=2;
+	}
+}
+
+void
+m32102_outsb(unsigned int port, const void * addr, unsigned long count) 
+{
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32RPCC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite(0, port, (void *)addr, sizeof(unsigned char), count, 1);
+	} else 	if (port >= M32R_PCC_IOSTART1 && port <= M32R_PCC_IOEND1) {
+	   pcc_iowrite(1, port, (void *)addr, sizeof(unsigned char), count, 1);
+	} else
+#endif
+while(count--){
+		*(unsigned volatile char *)PORT2ADDR(port) = *(unsigned char *)addr;
+		addr+=1;
+	}
+}
+void
+m32102_outsw(unsigned int port, const void * addr, unsigned long count) 
+{
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32RPCC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite(0, port, (void *)addr, sizeof(unsigned short), count, 1);
+	} else 	if (port >= M32R_PCC_IOSTART1 && port <= M32R_PCC_IOEND1) {
+	   pcc_iowrite(1, port, (void *)addr, sizeof(unsigned short), count, 1);
+	} else
+#endif
+while(count--){
+		*(unsigned volatile short *)PORT2ADDR(port) = *(unsigned short *)addr;
+		addr+=2;
+	}
+}
+
+#ifdef CONFIG_PLAT_MAPPI
+unsigned char
+ne_inb(unsigned long port)
+{
+	unsigned short tmp;
+	port <<= 1;
+	port+= PAGE_OFFSET + 0x20000000 + 0x0c000000;
+	tmp = *(unsigned short *)port;
+	return (unsigned char)tmp;
+}
+void
+ne_outb(unsigned char b, unsigned long port)
+{
+	port <<= 1;
+	port += PAGE_OFFSET + 0x20000000 + 0x0c000000;
+	*(unsigned volatile short *)port = (unsigned short)b;
+}
+void
+ne_insb(unsigned int port, void * addr, unsigned long count) 
+{
+
+	unsigned short tmp;
+	port <<= 1;
+	port+= PAGE_OFFSET + 0x20000000 + 0x0c000000;
+	tmp = *(unsigned short *)port;
+	while(count--){
+		*(unsigned char *)addr = *(unsigned volatile char *)port;
+		addr+=1;
+	}
+}
+
+void
+ne_insw(unsigned int port, void * addr, unsigned long count) {
+	unsigned short tmp;
+	port <<= 1;
+	port+= PAGE_OFFSET + 0x20000000 + 0x0c000000;
+	while(count--){
+		tmp = *(unsigned volatile short *)port;
+		*(unsigned short *)addr = (tmp>>8) | (tmp <<8);
+		addr+=2;
+	}
+}
+
+void
+ne_outsb(unsigned int port, const void * addr, unsigned long count) 
+{
+	port <<= 1;
+	port += PAGE_OFFSET + 0x20000000 + 0x0c000000;
+	while(count--){
+		*(unsigned volatile short *)port = *(unsigned char *)addr;
+		addr+=1;
+	}
+}
+void
+ne_outsw(unsigned int port, const void * addr, unsigned long count) 
+{
+	unsigned short tmp;
+	port <<= 1;
+	port += PAGE_OFFSET + 0x20000000 + 0x0c000000;
+	while(count--){
+		tmp = *(unsigned short *)addr;
+		*(unsigned volatile short *)port = (tmp>>8)|(tmp<<8);
+		addr+=2;
+	}
+}
+
+#endif /*  CONFIG_PLAT_MAPPI  */
diff -ruN linux-2.6.7.org/arch/m32r/kernel/io_m32700ut.c linux-2.6.7/arch/m32r/kernel/io_m32700ut.c
--- linux-2.6.7.org/arch/m32r/kernel/io_m32700ut.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/io_m32700ut.c	2004-06-22 18:42:09.000000000 +0900
@@ -0,0 +1,377 @@
+/*  
+ *  linux/arch/m32r/kernel/io_mappi.c
+ *   
+ *  Typical I/O routines for M32700UT board.
+ *  
+ *  Copyright (c) 2001, 2002  Hiroyuki Kondo, Hirokazu Takata, 
+ *                            Hitoshi Yamamoto, Takeo Takahashi
+ *
+ *  This file is subject to the terms and conditions of the GNU General
+ *  Public License.  See the file "COPYING" in the main directory of this
+ *  archive for more details.
+ *
+ */
+
+#include <linux/config.h>
+#include <asm/m32r.h>
+#include <asm/page.h>
+#include <asm/io.h>
+#include <asm/byteorder.h>
+
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+#include <linux/types.h>
+
+#define M32R_PCC_IOMAP_SIZE 0x1000
+
+#define M32R_PCC_IOSTART0 0x1000
+#define M32R_PCC_IOEND0   (M32R_PCC_IOSTART0 + M32R_PCC_IOMAP_SIZE - 1)
+
+extern void pcc_ioread_byte(int, unsigned long, void *, size_t, size_t, int);
+extern void pcc_ioread_word(int, unsigned long, void *, size_t, size_t, int);
+extern void pcc_iowrite_byte(int, unsigned long, void *, size_t, size_t, int);
+extern void pcc_iowrite_word(int, unsigned long, void *, size_t, size_t, int);
+#endif /* CONFIG_PCMCIA && CONFIG_M32R_CFC */
+
+#define PORT2ADDR(port)  _port2addr(port)
+#define PORT2ADDR_USB(port) _port2addr_usb(port)
+
+static __inline__ void *_port2addr(unsigned long port)
+{
+	return (void *)(port + NONCACHE_OFFSET);
+}
+
+/*
+ * M32700UT-LAN is located in the extended bus space
+ * from 0x10000000 to 0x13ffffff on physical address.
+ * The base address of LAN controller(LAN91C111) is 0x300.
+ */
+#define LAN_IOSTART	0x300
+#define LAN_IOEND	0x320
+static __inline__ void *_port2addr_ne(unsigned long port)
+{
+	return (void *)(port + NONCACHE_OFFSET + 0x10000000);
+}
+static __inline__ void *_port2addr_usb(unsigned long port)
+{
+  return (void *)((port & 0x0f) + NONCACHE_OFFSET + 0x10303000);
+}
+
+static __inline__ void delay(void)
+{
+	__asm__ __volatile__ ("push r0; \n\t pop r0;" : : :"memory");	
+}
+
+/* 
+ * NIC I/O function 
+ */
+
+#define PORT2ADDR_NE(port)  _port2addr_ne(port)
+
+static __inline__ unsigned char _ne_inb(void *portp)
+{
+	return *(volatile unsigned char *)portp;
+}
+
+static __inline__ unsigned short _ne_inw(void *portp)
+{
+	return (unsigned short)le16_to_cpu(*(volatile unsigned short *)portp);
+}
+
+static __inline__ void _ne_insb(void *portp, void * addr, unsigned long count) 
+{
+	unsigned char *buf = (unsigned char *)addr;
+	
+	while (count--) *buf++ = _ne_inb(portp);
+}
+
+static __inline__ void _ne_outb(unsigned char b, void *portp)
+{
+	*(volatile unsigned char *)portp = b;
+}
+
+static __inline__ void _ne_outw(unsigned short w, void *portp)
+{
+	*(volatile unsigned short *)portp = cpu_to_le16(w);
+}
+
+unsigned char _inb(unsigned long port)
+{
+	if (port >= LAN_IOSTART && port < LAN_IOEND)
+		return _ne_inb(PORT2ADDR_NE(port));
+
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	else if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   unsigned char b;
+	   pcc_ioread_byte(0, port, &b, sizeof(b), 1, 0);
+	   return b;
+	} else
+#endif
+
+	return *(volatile unsigned char *)PORT2ADDR(port);
+}
+
+unsigned short _inw(unsigned long port)
+{
+	if (port >= LAN_IOSTART && port < LAN_IOEND)
+		return _ne_inw(PORT2ADDR_NE(port));
+#if defined(CONFIG_USB)
+	else if(port >= 0x340 && port < 0x3a0)
+	  return *(volatile unsigned short *)PORT2ADDR_USB(port);
+#endif
+	
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	  else if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   unsigned short w;
+	   pcc_ioread_word(0, port, &w, sizeof(w), 1, 0);
+	   return w;
+	} else
+#endif
+	return *(volatile unsigned short *)PORT2ADDR(port);
+}
+
+unsigned long _inl(unsigned long port)
+{
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   unsigned long l;
+	   pcc_ioread_word(0, port, &l, sizeof(l), 1, 0);
+	   return l;
+	} else
+#endif
+	return *(volatile unsigned long *)PORT2ADDR(port);
+}
+
+unsigned char _inb_p(unsigned long port)
+{
+	unsigned char  v;
+	
+	if (port >= LAN_IOSTART && port < LAN_IOEND)
+		v = _ne_inb(PORT2ADDR_NE(port));
+	else
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   unsigned char b;
+	   pcc_ioread_byte(0, port, &b, sizeof(b), 1, 0);
+	   return b;
+	} else
+#endif
+		v = *(volatile unsigned char *)PORT2ADDR(port);
+	
+	delay();
+	return (v);
+}
+
+unsigned short _inw_p(unsigned long port)
+{
+	unsigned short  v;
+	
+	if (port >= LAN_IOSTART && port < LAN_IOEND)
+		v = _ne_inw(PORT2ADDR_NE(port));
+	else
+#if defined(CONFIG_USB)
+	  if(port >= 0x340 && port < 0x3a0)
+	    return *(volatile unsigned short *)PORT2ADDR_USB(port);
+	else
+#endif
+
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   unsigned short w;
+	   pcc_ioread_word(0, port, &w, sizeof(w), 1, 0);
+	   return w;
+	} else
+#endif
+		v = *(volatile unsigned short *)PORT2ADDR(port);
+	
+	delay();
+	return (v);
+}
+
+unsigned long _inl_p(unsigned long port)
+{
+	unsigned long  v;
+	
+	v = *(volatile unsigned long *)PORT2ADDR(port);
+	delay();
+	return (v);
+}
+
+void _outb(unsigned char b, unsigned long port)
+{
+	if (port >= LAN_IOSTART && port < LAN_IOEND)
+		_ne_outb(b, PORT2ADDR_NE(port));
+	else
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite_byte(0, port, &b, sizeof(b), 1, 0);
+	} else
+#endif
+		*(volatile unsigned char *)PORT2ADDR(port) = b;
+}
+
+void _outw(unsigned short w, unsigned long port)
+{
+	if (port >= LAN_IOSTART && port < LAN_IOEND)
+		_ne_outw(w, PORT2ADDR_NE(port));
+	else
+#if defined(CONFIG_USB)
+	if(port >= 0x340 && port < 0x3a0)
+	  *(volatile unsigned short *)PORT2ADDR_USB(port) = w;
+	else
+#endif
+
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite_word(0, port, &w, sizeof(w), 1, 0);
+	} else
+#endif
+		*(volatile unsigned short *)PORT2ADDR(port) = w;
+}
+
+void _outl(unsigned long l, unsigned long port)
+{
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite_word(0, port, &l, sizeof(l), 1, 0);
+	} else
+#endif
+	*(volatile unsigned long *)PORT2ADDR(port) = l;
+}
+
+void _outb_p(unsigned char b, unsigned long port)
+{
+	if (port >= LAN_IOSTART && port < LAN_IOEND)
+		_ne_outb(b, PORT2ADDR_NE(port));
+	else
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite_byte(0, port, &b, sizeof(b), 1, 0);
+	} else
+#endif
+		*(volatile unsigned char *)PORT2ADDR(port) = b;
+	
+	delay();
+}
+
+void _outw_p(unsigned short w, unsigned long port)
+{
+	if (port >= LAN_IOSTART && port < LAN_IOEND)
+		_ne_outw(w, PORT2ADDR_NE(port));
+	else
+#if defined(CONFIG_USB)
+	  if(port >= 0x340 && port < 0x3a0)
+	    *(volatile unsigned short *)PORT2ADDR_USB(port) = w;
+	else
+#endif
+
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite_word(0, port, &w, sizeof(w), 1, 0);
+	} else
+#endif
+		*(volatile unsigned short *)PORT2ADDR(port) = w;
+	
+	delay();
+}
+
+void _outl_p(unsigned long l, unsigned long port)
+{
+	*(volatile unsigned long *)PORT2ADDR(port) = l;
+	delay();
+}
+
+void _insb(unsigned int port, void * addr, unsigned long count)
+{
+	if (port >= LAN_IOSTART && port < LAN_IOEND)
+		_ne_insb(PORT2ADDR_NE(port), addr, count);
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	  else if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_ioread_byte(0, port, (void *)addr, sizeof(unsigned char), count, 1);
+	} 
+#endif
+	else {
+		unsigned char *buf = addr;
+		unsigned char *portp = PORT2ADDR(port);
+		while(count--) *buf++ = *(volatile unsigned char *)portp;
+	}
+}
+
+void _insw(unsigned int port, void * addr, unsigned long count)
+{
+	unsigned short *buf = addr;
+	unsigned short *portp;
+
+	if (port >= LAN_IOSTART && port < LAN_IOEND) {
+		/*
+		 * This portion is only used by smc91111.c to read data
+		 * from the DATA_REG. Do not swap the data.
+		 */
+		portp = PORT2ADDR_NE(port);
+		while (count--) *buf++ = *(volatile unsigned short *)portp;
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	} else if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_ioread_word(9, port, (void *)addr, sizeof(unsigned short), count, 1);
+#endif
+	} else {
+		portp = PORT2ADDR(port);
+		while (count--) *buf++ = *(volatile unsigned short *)portp;
+	}
+}
+
+void _insl(unsigned int port, void * addr, unsigned long count)
+{
+	unsigned long *buf = addr;
+	unsigned long *portp;
+
+	portp = PORT2ADDR(port);
+	while (count--) *buf++ = *(volatile unsigned long *)portp;
+}
+
+void _outsb(unsigned int port, const void * addr, unsigned long count)
+{
+	const unsigned char *buf = addr;
+	unsigned char *portp;
+
+	if (port >= LAN_IOSTART && port < LAN_IOEND) {
+		portp = PORT2ADDR_NE(port);
+		while (count--) _ne_outb(*buf++, portp);
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	} else if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite_byte(0, port, (void *)addr, sizeof(unsigned char), count, 1);
+#endif
+	} else {
+		portp = PORT2ADDR(port);
+		while(count--) *(volatile unsigned char *)portp = *buf++;
+	}
+}
+
+void _outsw(unsigned int port, const void * addr, unsigned long count)
+{
+	const unsigned short *buf = addr;
+	unsigned short *portp;
+
+	if (port >= LAN_IOSTART && port < LAN_IOEND) {
+		/*
+		 * This portion is only used by smc91111.c to write data
+		 * into the DATA_REG. Do not swap the data.
+		 */
+		portp = PORT2ADDR_NE(port);
+		while(count--) *(volatile unsigned short *)portp = *buf++;
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	} else if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite_word(9, port, (void *)addr, sizeof(unsigned short), count, 1);
+#endif
+	} else {
+		portp = PORT2ADDR(port);
+		while(count--) *(volatile unsigned short *)portp = *buf++;
+	}
+}
+
+void _outsl(unsigned int port, const void * addr, unsigned long count)
+{
+	const unsigned long *buf = addr;
+	unsigned char *portp;
+
+	portp = PORT2ADDR(port);
+	while(count--) *(volatile unsigned long *)portp = *buf++;
+}
diff -ruN linux-2.6.7.org/arch/m32r/kernel/io_mappi.c linux-2.6.7/arch/m32r/kernel/io_mappi.c
--- linux-2.6.7.org/arch/m32r/kernel/io_mappi.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/io_mappi.c	2004-06-22 18:42:09.000000000 +0900
@@ -0,0 +1,368 @@
+/*  
+ *  linux/arch/m32r/kernel/io_mappi.c
+ *   
+ *  Typical I/O routines for Mappi board.
+ *  
+ *  Copyright (c) 2001, 2002  Hiroyuki Kondo, Hirokazu Takata, 
+ *                            Hitoshi Yamamoto
+ */
+
+/* $Id: io_mappi.c,v 1.9 2003/12/02 07:18:08 fujiwara Exp $ */
+
+#include <linux/config.h>
+#include <asm/m32r.h>
+#include <asm/page.h>
+#include <asm/io.h>
+#include <asm/byteorder.h>
+
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32RPCC)
+#include <linux/types.h>
+
+#define M32R_PCC_IOMAP_SIZE 0x1000
+
+#define M32R_PCC_IOSTART0 0x1000
+#define M32R_PCC_IOEND0   (M32R_PCC_IOSTART0 + M32R_PCC_IOMAP_SIZE - 1)
+#define M32R_PCC_IOSTART1 0x2000
+#define M32R_PCC_IOEND1   (M32R_PCC_IOSTART1 + M32R_PCC_IOMAP_SIZE - 1)
+
+extern void pcc_ioread(int, unsigned long, void *, size_t, size_t, int);
+extern void pcc_iowrite(int, unsigned long, void *, size_t, size_t, int);
+#endif /* CONFIG_PCMCIA && CONFIG_M32RPCC */
+
+#define PORT2ADDR(port)  _port2addr(port)
+
+static __inline__ void *_port2addr(unsigned long port)
+{
+	return (void *)(port + NONCACHE_OFFSET);
+}
+
+static __inline__ void *_port2addr_ne(unsigned long port)
+{
+	return (void *)((port<<1) + NONCACHE_OFFSET + 0x0C000000);
+}
+
+static __inline__ void delay(void)
+{
+	__asm__ __volatile__ ("push r0; \n\t pop r0;" : : :"memory");	
+}
+
+/* 
+ * NIC I/O function 
+ */
+
+#define PORT2ADDR_NE(port)  _port2addr_ne(port)
+
+static __inline__ unsigned char _ne_inb(void *portp)
+{
+	return (unsigned char) *(volatile unsigned short *)portp;
+}
+
+static __inline__ unsigned short _ne_inw(void *portp)
+{
+	unsigned short tmp;
+	
+	tmp = *(volatile unsigned short *)portp;
+	return le16_to_cpu(tmp);
+}
+
+static __inline__ void _ne_outb(unsigned char b, void *portp)
+{
+	*(volatile unsigned short *)portp = (unsigned short)b;
+}
+
+static __inline__ void _ne_outw(unsigned short w, void *portp)
+{
+	*(volatile unsigned short *)portp = cpu_to_le16(w);
+}
+
+unsigned char _inb(unsigned long port)
+{
+	if (port >= 0x300 && port < 0x320)
+		return _ne_inb(PORT2ADDR_NE(port));
+	else
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32RPCC)
+        if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   unsigned char b;
+	   pcc_ioread(0, port, &b, sizeof(b), 1, 0);
+	   return b;
+	} else 	if (port >= M32R_PCC_IOSTART1 && port <= M32R_PCC_IOEND1) {
+	  unsigned char b;
+	   pcc_ioread(1, port, &b, sizeof(b), 1, 0);
+	   return b;
+	} else
+#endif
+
+	return *(volatile unsigned char *)PORT2ADDR(port);
+}
+
+unsigned short _inw(unsigned long port)
+{
+	if (port >= 0x300 && port < 0x320)
+		return _ne_inw(PORT2ADDR_NE(port));
+	else
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32RPCC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   unsigned short w;
+	   pcc_ioread(0, port, &w, sizeof(w), 1, 0);
+	   return w;
+	} else 	if (port >= M32R_PCC_IOSTART1 && port <= M32R_PCC_IOEND1) {
+	   unsigned short w;
+	   pcc_ioread(1, port, &w, sizeof(w), 1, 0);
+	   return w;
+	} else
+#endif
+	return *(volatile unsigned short *)PORT2ADDR(port);
+}
+
+unsigned long _inl(unsigned long port)
+{
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32RPCC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   unsigned long l;
+	   pcc_ioread(0, port, &l, sizeof(l), 1, 0);
+	   return l;
+	} else 	if (port >= M32R_PCC_IOSTART1 && port <= M32R_PCC_IOEND1) {
+	   unsigned short l;
+	   pcc_ioread(1, port, &l, sizeof(l), 1, 0);
+	   return l;
+	} else
+#endif
+	return *(volatile unsigned long *)PORT2ADDR(port);
+}
+
+unsigned char _inb_p(unsigned long port)
+{
+	unsigned char  v;
+	
+	if (port >= 0x300 && port < 0x320)
+		v = _ne_inb(PORT2ADDR_NE(port));
+	else
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32RPCC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   unsigned char b;
+	   pcc_ioread(0, port, &b, sizeof(b), 1, 0);
+	   return b;
+	} else 	if (port >= M32R_PCC_IOSTART1 && port <= M32R_PCC_IOEND1) {
+	  unsigned char b;
+	   pcc_ioread(1, port, &b, sizeof(b), 1, 0);
+	   return b;
+	} else
+#endif
+		v = *(volatile unsigned char *)PORT2ADDR(port);
+	
+	delay();
+	return (v);
+}
+
+unsigned short _inw_p(unsigned long port)
+{
+	unsigned short  v;
+	
+	if (port >= 0x300 && port < 0x320)
+		v = _ne_inw(PORT2ADDR_NE(port));
+	else
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32RPCC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   unsigned short w;
+	   pcc_ioread(0, port, &w, sizeof(w), 1, 0);
+	   return w;
+	} else 	if (port >= M32R_PCC_IOSTART1 && port <= M32R_PCC_IOEND1) {
+	   unsigned short w;
+	   pcc_ioread(1, port, &w, sizeof(w), 1, 0);
+	   return w;
+	} else
+#endif
+		v = *(volatile unsigned short *)PORT2ADDR(port);
+	
+	delay();
+	return (v);
+}
+
+unsigned long _inl_p(unsigned long port)
+{
+	unsigned long  v;
+	
+	v = *(volatile unsigned long *)PORT2ADDR(port);
+	delay();
+	return (v);
+}
+
+void _outb(unsigned char b, unsigned long port)
+{
+	if (port >= 0x300 && port < 0x320)
+		_ne_outb(b, PORT2ADDR_NE(port));
+	else
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32RPCC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite(0, port, &b, sizeof(b), 1, 0);
+	} else 	if (port >= M32R_PCC_IOSTART1 && port <= M32R_PCC_IOEND1) {
+	   pcc_iowrite(1, port, &b, sizeof(b), 1, 0);
+	} else
+#endif
+		*(volatile unsigned char *)PORT2ADDR(port) = b;
+}
+
+void _outw(unsigned short w, unsigned long port)
+{
+	if (port >= 0x300 && port < 0x320)
+		_ne_outw(w, PORT2ADDR_NE(port));
+	else
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32RPCC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite(0, port, &w, sizeof(w), 1, 0);
+	} else 	if (port >= M32R_PCC_IOSTART1 && port <= M32R_PCC_IOEND1) {
+	   pcc_iowrite(1, port, &w, sizeof(w), 1, 0);
+	} else
+#endif
+		*(volatile unsigned short *)PORT2ADDR(port) = w;
+}
+
+void _outl(unsigned long l, unsigned long port)
+{
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32RPCC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite(0, port, &l, sizeof(l), 1, 0);
+	} else 	if (port >= M32R_PCC_IOSTART1 && port <= M32R_PCC_IOEND1) {
+	   pcc_iowrite(1, port, &l, sizeof(l), 1, 0);
+	} else
+#endif
+	*(volatile unsigned long *)PORT2ADDR(port) = l;
+}
+
+void _outb_p(unsigned char b, unsigned long port)
+{
+	if (port >= 0x300 && port < 0x320)
+		_ne_outb(b, PORT2ADDR_NE(port));
+	else
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32RPCC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite(0, port, &b, sizeof(b), 1, 0);
+	} else 	if (port >= M32R_PCC_IOSTART1 && port <= M32R_PCC_IOEND1) {
+	   pcc_iowrite(1, port, &b, sizeof(b), 1, 0);
+	} else
+#endif
+		*(volatile unsigned char *)PORT2ADDR(port) = b;
+	
+	delay();
+}
+
+void _outw_p(unsigned short w, unsigned long port)
+{
+	if (port >= 0x300 && port < 0x320)
+		_ne_outw(w, PORT2ADDR_NE(port));
+	else
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32RPCC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite(0, port, &w, sizeof(w), 1, 0);
+	} else 	if (port >= M32R_PCC_IOSTART1 && port <= M32R_PCC_IOEND1) {
+	   pcc_iowrite(1, port, &w, sizeof(w), 1, 0);
+	} else
+#endif
+		*(volatile unsigned short *)PORT2ADDR(port) = w;
+	
+	delay();
+}
+
+void _outl_p(unsigned long l, unsigned long port)
+{
+	*(volatile unsigned long *)PORT2ADDR(port) = l;
+	delay();
+}
+
+void _insb(unsigned int port, void * addr, unsigned long count)
+{
+	unsigned short *buf = addr;
+	unsigned short *portp;
+
+	if (port >= 0x300 && port < 0x320){
+		portp = PORT2ADDR_NE(port);
+		while(count--) *buf++ = *(volatile unsigned char *)portp;
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32RPCC)
+	} else if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_ioread(0, port, (void *)addr, sizeof(unsigned char), count, 1);
+	} else 	if (port >= M32R_PCC_IOSTART1 && port <= M32R_PCC_IOEND1) {
+	   pcc_ioread(1, port, (void *)addr, sizeof(unsigned char), count, 1);
+#endif	
+	} else {
+		portp = PORT2ADDR(port);
+		while(count--) *buf++ = *(volatile unsigned char *)portp;
+	}
+}
+
+void _insw(unsigned int port, void * addr, unsigned long count)
+{
+	unsigned short *buf = addr;
+	unsigned short *portp;
+
+	if (port >= 0x300 && port < 0x320) {
+		portp = PORT2ADDR_NE(port);
+		while (count--) *buf++ = _ne_inw(portp);
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32RPCC)
+	} else if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_ioread(0, port, (void *)addr, sizeof(unsigned short), count, 1);
+	} else 	if (port >= M32R_PCC_IOSTART1 && port <= M32R_PCC_IOEND1) {
+	   pcc_ioread(1, port, (void *)addr, sizeof(unsigned short), count, 1);
+#endif
+	} else {
+		portp = PORT2ADDR(port);
+		while (count--) *buf++ = *(volatile unsigned short *)portp;
+	}
+}
+
+void _insl(unsigned int port, void * addr, unsigned long count)
+{
+	unsigned long *buf = addr;
+	unsigned long *portp;
+
+	portp = PORT2ADDR(port);
+	while (count--) *buf++ = *(volatile unsigned long *)portp;
+}
+
+void _outsb(unsigned int port, const void * addr, unsigned long count)
+{
+	const unsigned char *buf = addr;
+	unsigned char *portp;
+
+	if (port >= 0x300 && port < 0x320) {
+		portp = PORT2ADDR_NE(port);
+		while (count--) _ne_outb(*buf++, portp);
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32RPCC)
+	} else if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite(0, port, (void *)addr, sizeof(unsigned char), count, 1);
+	} else if (port >= M32R_PCC_IOSTART1 && port <= M32R_PCC_IOEND1) {
+	   pcc_iowrite(1, port, (void *)addr, sizeof(unsigned char), count, 1);
+#endif
+	} else {
+		portp = PORT2ADDR(port);
+		while(count--) *(volatile unsigned char *)portp = *buf++;
+	}
+}
+
+void _outsw(unsigned int port, const void * addr, unsigned long count)
+{
+	const unsigned short *buf = addr;
+	unsigned short *portp;
+
+	if (port >= 0x300 && port < 0x320) {
+		portp = PORT2ADDR_NE(port);
+		while (count--) _ne_outw(*buf++, portp);
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32RPCC)
+	} else if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite(0, port, (void *)addr, sizeof(unsigned short), count, 1);
+	} else 	if (port >= M32R_PCC_IOSTART1 && port <= M32R_PCC_IOEND1) {
+	   pcc_iowrite(1, port, (void *)addr, sizeof(unsigned short), count, 1);
+#endif
+	} else {
+		portp = PORT2ADDR(port);
+		while(count--) *(volatile unsigned short *)portp = *buf++;
+	}
+}
+
+void _outsl(unsigned int port, const void * addr, unsigned long count)
+{
+	const unsigned long *buf = addr;
+	unsigned char *portp;
+
+	portp = PORT2ADDR(port);
+	while(count--) *(volatile unsigned long *)portp = *buf++;
+}
diff -ruN linux-2.6.7.org/arch/m32r/kernel/io_mappi2.c linux-2.6.7/arch/m32r/kernel/io_mappi2.c
--- linux-2.6.7.org/arch/m32r/kernel/io_mappi2.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/io_mappi2.c	2004-06-22 18:42:09.000000000 +0900
@@ -0,0 +1,367 @@
+/*  
+ *  linux/arch/m32r/kernel/io_mappi2.c
+ *   
+ *  Typical I/O routines for Mappi2 board.
+ *  
+ *  Copyright (c) 2001-2003  Hiroyuki Kondo, Hirokazu Takata, 
+ *                            Hitoshi Yamamoto, Mamoru Sakugawa
+ */
+
+/* $Id:$ */
+
+#include <linux/config.h>
+#include <asm/m32r.h>
+#include <asm/page.h>
+#include <asm/io.h>
+
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+#include <linux/types.h>
+
+#define M32R_PCC_IOMAP_SIZE 0x1000
+
+#define M32R_PCC_IOSTART0 0x1000
+#define M32R_PCC_IOEND0   (M32R_PCC_IOSTART0 + M32R_PCC_IOMAP_SIZE - 1)
+
+extern void pcc_ioread_byte(int, unsigned long, void *, size_t, size_t, int);
+extern void pcc_ioread_word(int, unsigned long, void *, size_t, size_t, int);
+extern void pcc_iowrite_byte(int, unsigned long, void *, size_t, size_t, int);
+extern void pcc_iowrite_word(int, unsigned long, void *, size_t, size_t, int);
+#endif /* CONFIG_PCMCIA && CONFIG_MAPPI2_CFC */
+
+#define PORT2ADDR(port)      _port2addr(port)
+#define PORT2ADDR_NE(port)   _port2addr_ne(port)
+#define PORT2ADDR_USB(port)  _port2addr_usb(port)
+
+static __inline__ void *_port2addr(unsigned long port)
+{
+	return (void *)(port + NONCACHE_OFFSET);
+}
+#ifdef CONFIG_CHIP_OPSP
+static __inline__ void *_port2addr_ne(unsigned long port)
+{
+	return (void *)(port + NONCACHE_OFFSET + 0x10000000);
+}
+#else
+static __inline__ void *_port2addr_ne(unsigned long port)
+{
+	return (void *)(port + NONCACHE_OFFSET + 0x04000000);
+}
+#endif
+static __inline__ void *_port2addr_usb(unsigned long port)
+{
+	return (void *)(port + NONCACHE_OFFSET + 0x14000000);
+}
+static __inline__ void delay(void)
+{
+	__asm__ __volatile__ ("push r0; \n\t pop r0;" : : :"memory");	
+}
+
+/* 
+ * NIC I/O function 
+ */
+
+static __inline__ unsigned char _ne_inb(void *portp)
+{
+	return (unsigned char) *(volatile unsigned char *)portp;
+}
+
+static __inline__ unsigned short _ne_inw(void *portp)
+{
+#if 1  /* byte swap */
+	unsigned short tmp,tmp2;
+	tmp = *(volatile unsigned short *)portp;
+	tmp2 = (tmp>>8|tmp<<8);
+	return tmp2;
+#else
+	return *(volatile unsigned short *)portp;
+#endif
+}
+
+static __inline__ void _ne_insb(void *portp, void * addr, unsigned long count) 
+{
+	unsigned short tmp;
+	unsigned char *buf = addr;
+	
+	tmp = *(volatile unsigned char *)portp;
+	while (count--) *buf++ = *(volatile unsigned char *)portp;
+}
+
+static __inline__ void _ne_outb(unsigned char b, void *portp)
+{
+	*(volatile unsigned char *)portp = (unsigned char)b;
+}
+
+static __inline__ void _ne_outw(unsigned short w, void *portp)
+{
+	*(volatile unsigned short *)portp = (w>>8|w<<8);
+}
+
+unsigned char _inb(unsigned long port)
+{
+	if (port >= 0x300 && port < 0x320)
+		return _ne_inb(PORT2ADDR_NE(port));
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	else if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   unsigned char b;
+	   pcc_ioread_byte(0, port, &b, sizeof(b), 1, 0);
+	   return b;
+	} else
+#endif
+
+	return *(volatile unsigned char *)PORT2ADDR(port);
+}
+
+unsigned short _inw(unsigned long port)
+{
+	if (port >= 0x300 && port < 0x320)
+		return _ne_inw(PORT2ADDR_NE(port));
+#if defined(CONFIG_USB)
+        else if (port >= 0x340 && port < 0x3a0)
+	  return *(volatile unsigned short *)PORT2ADDR_USB(port);
+#endif
+	
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	  else if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   unsigned short w;
+	   pcc_ioread_word(0, port, &w, sizeof(w), 1, 0);
+	   return w;
+	} else
+#endif
+	return *(volatile unsigned short *)PORT2ADDR(port);
+}
+
+unsigned long _inl(unsigned long port)
+{
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   unsigned long l;
+	   pcc_ioread_word(0, port, &l, sizeof(l), 1, 0);
+	   return l;
+	} else
+#endif
+	return *(volatile unsigned long *)PORT2ADDR(port);
+}
+
+unsigned char _inb_p(unsigned long port)
+{
+	unsigned char  v;
+	
+	if (port >= 0x300 && port < 0x320)
+		v = _ne_inb(PORT2ADDR_NE(port));
+	else
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   unsigned char b;
+	   pcc_ioread_byte(0, port, &b, sizeof(b), 1, 0);
+	   return b;
+	} else
+#endif
+		v = *(volatile unsigned char *)PORT2ADDR(port);
+	
+	delay();
+	return (v);
+}
+
+unsigned short _inw_p(unsigned long port)
+{
+	unsigned short  v;
+	
+	if (port >= 0x300 && port < 0x320)
+		v = _ne_inw(PORT2ADDR_NE(port));
+	else
+#if defined(CONFIG_USB)
+	  if (port >= 0x340 && port < 0x3a0)
+		v = *(volatile unsigned short *)PORT2ADDR_USB(port);
+	  else
+#endif
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   unsigned short w;
+	   pcc_ioread_word(0, port, &w, sizeof(w), 1, 0);
+	   return w;
+	} else
+#endif
+		v = *(volatile unsigned short *)PORT2ADDR(port);
+	
+	delay();
+	return (v);
+}
+
+unsigned long _inl_p(unsigned long port)
+{
+	unsigned long  v;
+	
+	v = *(volatile unsigned long *)PORT2ADDR(port);
+	delay();
+	return (v);
+}
+
+void _outb(unsigned char b, unsigned long port)
+{
+	if (port >= 0x300 && port < 0x320)
+		_ne_outb(b, PORT2ADDR_NE(port));
+	else
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite_byte(0, port, &b, sizeof(b), 1, 0);
+	} else
+#endif
+		*(volatile unsigned char *)PORT2ADDR(port) = b;
+}
+
+void _outw(unsigned short w, unsigned long port)
+{
+	if (port >= 0x300 && port < 0x320)
+		_ne_outw(w, PORT2ADDR_NE(port));
+	else
+#if defined(CONFIG_USB)
+	  if (port >= 0x340 && port < 0x3a0)
+	    *(volatile unsigned short *)PORT2ADDR_USB(port) = w;
+	else
+#endif
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite_word(0, port, &w, sizeof(w), 1, 0);
+	} else
+#endif
+		*(volatile unsigned short *)PORT2ADDR(port) = w;
+}
+
+void _outl(unsigned long l, unsigned long port)
+{
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite_word(0, port, &l, sizeof(l), 1, 0);
+	} else
+#endif
+	*(volatile unsigned long *)PORT2ADDR(port) = l;
+}
+
+void _outb_p(unsigned char b, unsigned long port)
+{
+	if (port >= 0x300 && port < 0x320)
+		_ne_outb(b, PORT2ADDR_NE(port));
+	else
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite_byte(0, port, &b, sizeof(b), 1, 0);
+	} else
+#endif
+		*(volatile unsigned char *)PORT2ADDR(port) = b;
+	
+	delay();
+}
+
+void _outw_p(unsigned short w, unsigned long port)
+{
+	if (port >= 0x300 && port < 0x320)
+		_ne_outw(w, PORT2ADDR_NE(port));
+	else
+#if defined(CONFIG_USB)
+	  if (port >= 0x340 && port < 0x3a0)
+		*(volatile unsigned short *)PORT2ADDR_USB(port) = w;
+	else
+#endif
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite_word(0, port, &w, sizeof(w), 1, 0);
+	} else
+#endif
+		*(volatile unsigned short *)PORT2ADDR(port) = w;
+	
+	delay();
+}
+
+void _outl_p(unsigned long l, unsigned long port)
+{
+	*(volatile unsigned long *)PORT2ADDR(port) = l;
+	delay();
+}
+
+void _insb(unsigned int port, void * addr, unsigned long count)
+{
+	if (port >= 0x300 && port < 0x320)
+		_ne_insb(PORT2ADDR_NE(port), addr, count);
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	  else if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_ioread_byte(0, port, (void *)addr, sizeof(unsigned char), count, 1);
+	} 
+#endif
+	else {
+		unsigned char *buf = addr;
+		unsigned char *portp = PORT2ADDR(port);
+		while(count--) *buf++ = *(volatile unsigned char *)portp;
+	}
+}
+
+void _insw(unsigned int port, void * addr, unsigned long count)
+{
+	unsigned short *buf = addr;
+	unsigned short *portp;
+
+	if (port >= 0x300 && port < 0x320) {
+		portp = PORT2ADDR_NE(port);
+		while (count--) *buf++ = *(volatile unsigned short *)portp;
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	} else if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_ioread_word(9, port, (void *)addr, sizeof(unsigned short), count, 1);
+#endif
+	} else {
+		portp = PORT2ADDR(port);
+		while (count--) *buf++ = *(volatile unsigned short *)portp;
+	}
+}
+
+void _insl(unsigned int port, void * addr, unsigned long count)
+{
+	unsigned long *buf = addr;
+	unsigned long *portp;
+
+	portp = PORT2ADDR(port);
+	while (count--) *buf++ = *(volatile unsigned long *)portp;
+}
+
+void _outsb(unsigned int port, const void * addr, unsigned long count)
+{
+	const unsigned char *buf = addr;
+	unsigned char *portp;
+
+	if (port >= 0x300 && port < 0x320) {
+		portp = PORT2ADDR_NE(port);
+		while (count--) _ne_outb(*buf++, portp);
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	} else if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite_byte(0, port, (void *)addr, sizeof(unsigned char), count, 1);
+#endif
+	} else {
+		portp = PORT2ADDR(port);
+		while(count--) *(volatile unsigned char *)portp = *buf++;
+	}
+}
+
+void _outsw(unsigned int port, const void * addr, unsigned long count)
+{
+	const unsigned short *buf = addr;
+	unsigned short *portp;
+
+	if (port >= 0x300 && port < 0x320) {
+		portp = PORT2ADDR_NE(port);
+		while (count--) *(volatile unsigned short *)portp = *buf++;
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	} else if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite_word(9, port, (void *)addr, sizeof(unsigned short), count, 1);
+#endif
+	} else {
+		portp = PORT2ADDR(port);
+		while(count--) *(volatile unsigned short *)portp = *buf++;
+	}
+}
+
+void _outsl(unsigned int port, const void * addr, unsigned long count)
+{
+	const unsigned long *buf = addr;
+	unsigned char *portp;
+
+	portp = PORT2ADDR(port);
+	while(count--) *(volatile unsigned long *)portp = *buf++;
+}
diff -ruN linux-2.6.7.org/arch/m32r/kernel/io_oaks32r.c linux-2.6.7/arch/m32r/kernel/io_oaks32r.c
--- linux-2.6.7.org/arch/m32r/kernel/io_oaks32r.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/io_oaks32r.c	2004-06-22 18:42:09.000000000 +0900
@@ -0,0 +1,243 @@
+/*  
+ *  linux/arch/m32r/kernel/io_oaks32r.c
+ *   
+ *  Typical I/O routines for OAKS32R board.
+ *  
+ *  Copyright (c) 2001-2004  Hiroyuki Kondo, Hirokazu Takata, 
+ *                            Hitoshi Yamamoto, Mamoru Sakugawa
+ */
+
+/* $Id$ */
+
+#include <linux/config.h>
+#include <asm/m32r.h>
+#include <asm/page.h>
+#include <asm/io.h>
+
+#define PORT2ADDR(port)  _port2addr(port)
+
+static __inline__ void *_port2addr(unsigned long port)
+{
+	return (void *)(port + NONCACHE_OFFSET);
+}
+
+static __inline__  void *_port2addr_ne(unsigned long port)
+{
+	return (void *)((port<<1) + NONCACHE_OFFSET + 0x02000000);
+}
+
+static __inline__ void delay(void)
+{
+	__asm__ __volatile__ ("push r0; \n\t pop r0;" : : :"memory");	
+}
+
+/* 
+ * NIC I/O function 
+ */
+
+#define PORT2ADDR_NE(port)  _port2addr_ne(port)
+
+static __inline__ unsigned char _ne_inb(void *portp)
+{
+	return *(volatile unsigned char *)(portp+1);
+}
+
+static __inline__ unsigned short _ne_inw(void *portp)
+{
+	unsigned short tmp;
+
+	tmp = *(unsigned short *)(portp) & 0xff;
+	tmp |= *(unsigned short *)(portp+2) << 8;
+	return tmp;
+}
+
+static __inline__  void _ne_insb(void *portp, void * addr, unsigned long count) 
+{
+	unsigned char *buf = addr;
+	while (count--) *buf++ = *(volatile unsigned char *)(portp+1);
+}
+
+static __inline__ void _ne_outb(unsigned char b, void *portp)
+{
+	*(volatile unsigned char *)(portp+1) = b;
+}
+
+static __inline__ void _ne_outw(unsigned short w, void *portp)
+{
+  *(volatile unsigned short *)portp =  (w >> 8);
+  *(volatile unsigned short *)(portp+2) =  (w & 0xff);
+}
+
+unsigned char _inb(unsigned long port)
+{
+	if (port >= 0x300 && port < 0x320)
+		return _ne_inb(PORT2ADDR_NE(port));
+
+	return *(volatile unsigned char *)PORT2ADDR(port);
+}
+
+unsigned short _inw(unsigned long port)
+{
+	if (port >= 0x300 && port < 0x320)
+		return _ne_inw(PORT2ADDR_NE(port));
+	
+	return *(volatile unsigned short *)PORT2ADDR(port);
+}
+
+unsigned long _inl(unsigned long port)
+{
+	return *(volatile unsigned long *)PORT2ADDR(port);
+}
+
+unsigned char _inb_p(unsigned long port)
+{
+	unsigned char  v;
+	
+	if (port >= 0x300 && port < 0x320)
+		v = _ne_inb(PORT2ADDR_NE(port));
+	else
+		v = *(volatile unsigned char *)PORT2ADDR(port);
+	
+	delay();
+	return (v);
+}
+
+unsigned short _inw_p(unsigned long port)
+{
+	unsigned short  v;
+	
+	if (port >= 0x300 && port < 0x320)
+		v = _ne_inw(PORT2ADDR_NE(port));
+	else
+		v = *(volatile unsigned short *)PORT2ADDR(port);
+	
+	delay();
+	return (v);
+}
+
+unsigned long _inl_p(unsigned long port)
+{
+	unsigned long  v;
+	
+	v = *(volatile unsigned long *)PORT2ADDR(port);
+	delay();
+	return (v);
+}
+
+void _outb(unsigned char b, unsigned long port)
+{
+	if (port >= 0x300 && port < 0x320)
+		_ne_outb(b, PORT2ADDR_NE(port));
+	else
+		*(volatile unsigned char *)PORT2ADDR(port) = b;
+}
+
+void _outw(unsigned short w, unsigned long port)
+{
+	if (port >= 0x300 && port < 0x320)
+		_ne_outw(w, PORT2ADDR_NE(port));
+	else
+		*(volatile unsigned short *)PORT2ADDR(port) = w;
+}
+
+void _outl(unsigned long l, unsigned long port)
+{
+	*(volatile unsigned long *)PORT2ADDR(port) = l;
+}
+
+void _outb_p(unsigned char b, unsigned long port)
+{
+	if (port >= 0x300 && port < 0x320)
+		_ne_outb(b, PORT2ADDR_NE(port));
+	else
+		*(volatile unsigned char *)PORT2ADDR(port) = b;
+	
+	delay();
+}
+
+void _outw_p(unsigned short w, unsigned long port)
+{
+	if (port >= 0x300 && port < 0x320)
+		_ne_outw(w, PORT2ADDR_NE(port));
+	else
+		*(volatile unsigned short *)PORT2ADDR(port) = w;
+	
+	delay();
+}
+
+void _outl_p(unsigned long l, unsigned long port)
+{
+	*(volatile unsigned long *)PORT2ADDR(port) = l;
+	delay();
+}
+
+void _insb(unsigned int port, void * addr, unsigned long count)
+{
+	if (port >= 0x300 && port < 0x320)
+		_ne_insb(PORT2ADDR_NE(port), addr, count);
+	else {
+		unsigned char *buf = addr;
+		unsigned char *portp = PORT2ADDR(port);
+		while(count--) *buf++ = *(volatile unsigned char *)portp;
+	}
+}
+
+void _insw(unsigned int port, void * addr, unsigned long count)
+{
+	unsigned short *buf = addr;
+	unsigned short *portp;
+
+	if (port >= 0x300 && port < 0x320) {
+		portp = PORT2ADDR_NE(port);
+		while (count--) *buf++ = _ne_inw(portp);
+	} else {
+		portp = PORT2ADDR(port);
+		while (count--) *buf++ = *(volatile unsigned short *)portp;
+	}
+}
+
+void _insl(unsigned int port, void * addr, unsigned long count)
+{
+	unsigned long *buf = addr;
+	unsigned long *portp;
+
+	portp = PORT2ADDR(port);
+	while (count--) *buf++ = *(volatile unsigned long *)portp;
+}
+
+void _outsb(unsigned int port, const void * addr, unsigned long count)
+{
+	const unsigned char *buf = addr;
+	unsigned char *portp;
+
+	if (port >= 0x300 && port < 0x320) {
+		portp = PORT2ADDR_NE(port);
+		while (count--) _ne_outb(*buf++, portp);
+	} else {
+		portp = PORT2ADDR(port);
+		while(count--) *(volatile unsigned char *)portp = *buf++;
+	}
+}
+
+void _outsw(unsigned int port, const void * addr, unsigned long count)
+{
+	const unsigned short *buf = addr;
+	unsigned short *portp;
+
+	if (port >= 0x300 && port < 0x320) {
+		portp = PORT2ADDR_NE(port);
+		while (count--) _ne_outw(*buf++, portp);
+	} else {
+		portp = PORT2ADDR(port);
+		while(count--) *(volatile unsigned short *)portp = *buf++;
+	}
+}
+
+void _outsl(unsigned int port, const void * addr, unsigned long count)
+{
+	const unsigned long *buf = addr;
+	unsigned char *portp;
+
+	portp = PORT2ADDR(port);
+	while(count--) *(volatile unsigned long *)portp = *buf++;
+}
diff -ruN linux-2.6.7.org/arch/m32r/kernel/io_opsput.c linux-2.6.7/arch/m32r/kernel/io_opsput.c
--- linux-2.6.7.org/arch/m32r/kernel/io_opsput.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/io_opsput.c	2004-07-27 15:54:20.000000000 +0900
@@ -0,0 +1,377 @@
+/*  
+ *  linux/arch/m32r/kernel/io_mappi.c
+ *   
+ *  Typical I/O routines for OPSPUT board.
+ *  
+ *  Copyright (c) 2001, 2002  Hiroyuki Kondo, Hirokazu Takata, 
+ *                            Hitoshi Yamamoto, Takeo Takahashi
+ *
+ *  This file is subject to the terms and conditions of the GNU General
+ *  Public License.  See the file "COPYING" in the main directory of this
+ *  archive for more details.
+ *
+ */
+
+#include <linux/config.h>
+#include <asm/m32r.h>
+#include <asm/page.h>
+#include <asm/io.h>
+#include <asm/byteorder.h>
+
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+#include <linux/types.h>
+
+#define M32R_PCC_IOMAP_SIZE 0x1000
+
+#define M32R_PCC_IOSTART0 0x1000
+#define M32R_PCC_IOEND0   (M32R_PCC_IOSTART0 + M32R_PCC_IOMAP_SIZE - 1)
+
+extern void pcc_ioread_byte(int, unsigned long, void *, size_t, size_t, int);
+extern void pcc_ioread_word(int, unsigned long, void *, size_t, size_t, int);
+extern void pcc_iowrite_byte(int, unsigned long, void *, size_t, size_t, int);
+extern void pcc_iowrite_word(int, unsigned long, void *, size_t, size_t, int);
+#endif /* CONFIG_PCMCIA && CONFIG_M32R_CFC */
+
+#define PORT2ADDR(port)  _port2addr(port)
+#define PORT2ADDR_USB(port) _port2addr_usb(port)
+
+static __inline__ void *_port2addr(unsigned long port)
+{
+	return (void *)(port + NONCACHE_OFFSET);
+}
+
+/*
+ * OPSPUT-LAN is located in the extended bus space
+ * from 0x10000000 to 0x13ffffff on physical address.
+ * The base address of LAN controller(LAN91C111) is 0x300.
+ */
+#define LAN_IOSTART	0x300
+#define LAN_IOEND	0x320
+static __inline__ void *_port2addr_ne(unsigned long port)
+{
+	return (void *)(port + NONCACHE_OFFSET + 0x10000000);
+}
+static __inline__ void *_port2addr_usb(unsigned long port)
+{
+  return (void *)((port & 0x0f) + NONCACHE_OFFSET + 0x10303000);
+}
+
+static __inline__ void delay(void)
+{
+	__asm__ __volatile__ ("push r0; \n\t pop r0;" : : :"memory");	
+}
+
+/* 
+ * NIC I/O function 
+ */
+
+#define PORT2ADDR_NE(port)  _port2addr_ne(port)
+
+static __inline__ unsigned char _ne_inb(void *portp)
+{
+	return *(volatile unsigned char *)portp;
+}
+
+static __inline__ unsigned short _ne_inw(void *portp)
+{
+	return (unsigned short)le16_to_cpu(*(volatile unsigned short *)portp);
+}
+
+static __inline__ void _ne_insb(void *portp, void * addr, unsigned long count) 
+{
+	unsigned char *buf = (unsigned char *)addr;
+	
+	while (count--) *buf++ = _ne_inb(portp);
+}
+
+static __inline__ void _ne_outb(unsigned char b, void *portp)
+{
+	*(volatile unsigned char *)portp = b;
+}
+
+static __inline__ void _ne_outw(unsigned short w, void *portp)
+{
+	*(volatile unsigned short *)portp = cpu_to_le16(w);
+}
+
+unsigned char _inb(unsigned long port)
+{
+	if (port >= LAN_IOSTART && port < LAN_IOEND)
+		return _ne_inb(PORT2ADDR_NE(port));
+
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	else if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   unsigned char b;
+	   pcc_ioread_byte(0, port, &b, sizeof(b), 1, 0);
+	   return b;
+	} else
+#endif
+
+	return *(volatile unsigned char *)PORT2ADDR(port);
+}
+
+unsigned short _inw(unsigned long port)
+{
+	if (port >= LAN_IOSTART && port < LAN_IOEND)
+		return _ne_inw(PORT2ADDR_NE(port));
+#if defined(CONFIG_USB)
+	else if(port >= 0x340 && port < 0x3a0)
+	  return *(volatile unsigned short *)PORT2ADDR_USB(port);
+#endif
+	
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	  else if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   unsigned short w;
+	   pcc_ioread_word(0, port, &w, sizeof(w), 1, 0);
+	   return w;
+	} else
+#endif
+	return *(volatile unsigned short *)PORT2ADDR(port);
+}
+
+unsigned long _inl(unsigned long port)
+{
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   unsigned long l;
+	   pcc_ioread_word(0, port, &l, sizeof(l), 1, 0);
+	   return l;
+	} else
+#endif
+	return *(volatile unsigned long *)PORT2ADDR(port);
+}
+
+unsigned char _inb_p(unsigned long port)
+{
+	unsigned char  v;
+	
+	if (port >= LAN_IOSTART && port < LAN_IOEND)
+		v = _ne_inb(PORT2ADDR_NE(port));
+	else
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   unsigned char b;
+	   pcc_ioread_byte(0, port, &b, sizeof(b), 1, 0);
+	   return b;
+	} else
+#endif
+		v = *(volatile unsigned char *)PORT2ADDR(port);
+	
+	delay();
+	return (v);
+}
+
+unsigned short _inw_p(unsigned long port)
+{
+	unsigned short  v;
+	
+	if (port >= LAN_IOSTART && port < LAN_IOEND)
+		v = _ne_inw(PORT2ADDR_NE(port));
+	else
+#if defined(CONFIG_USB)
+	  if(port >= 0x340 && port < 0x3a0)
+	    return *(volatile unsigned short *)PORT2ADDR_USB(port);
+	else
+#endif
+
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   unsigned short w;
+	   pcc_ioread_word(0, port, &w, sizeof(w), 1, 0);
+	   return w;
+	} else
+#endif
+		v = *(volatile unsigned short *)PORT2ADDR(port);
+	
+	delay();
+	return (v);
+}
+
+unsigned long _inl_p(unsigned long port)
+{
+	unsigned long  v;
+	
+	v = *(volatile unsigned long *)PORT2ADDR(port);
+	delay();
+	return (v);
+}
+
+void _outb(unsigned char b, unsigned long port)
+{
+	if (port >= LAN_IOSTART && port < LAN_IOEND)
+		_ne_outb(b, PORT2ADDR_NE(port));
+	else
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite_byte(0, port, &b, sizeof(b), 1, 0);
+	} else
+#endif
+		*(volatile unsigned char *)PORT2ADDR(port) = b;
+}
+
+void _outw(unsigned short w, unsigned long port)
+{
+	if (port >= LAN_IOSTART && port < LAN_IOEND)
+		_ne_outw(w, PORT2ADDR_NE(port));
+	else
+#if defined(CONFIG_USB)
+	if(port >= 0x340 && port < 0x3a0)
+	  *(volatile unsigned short *)PORT2ADDR_USB(port) = w;
+	else
+#endif
+
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite_word(0, port, &w, sizeof(w), 1, 0);
+	} else
+#endif
+		*(volatile unsigned short *)PORT2ADDR(port) = w;
+}
+
+void _outl(unsigned long l, unsigned long port)
+{
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite_word(0, port, &l, sizeof(l), 1, 0);
+	} else
+#endif
+	*(volatile unsigned long *)PORT2ADDR(port) = l;
+}
+
+void _outb_p(unsigned char b, unsigned long port)
+{
+	if (port >= LAN_IOSTART && port < LAN_IOEND)
+		_ne_outb(b, PORT2ADDR_NE(port));
+	else
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite_byte(0, port, &b, sizeof(b), 1, 0);
+	} else
+#endif
+		*(volatile unsigned char *)PORT2ADDR(port) = b;
+	
+	delay();
+}
+
+void _outw_p(unsigned short w, unsigned long port)
+{
+	if (port >= LAN_IOSTART && port < LAN_IOEND)
+		_ne_outw(w, PORT2ADDR_NE(port));
+	else
+#if defined(CONFIG_USB)
+	  if(port >= 0x340 && port < 0x3a0)
+	    *(volatile unsigned short *)PORT2ADDR_USB(port) = w;
+	else
+#endif
+
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite_word(0, port, &w, sizeof(w), 1, 0);
+	} else
+#endif
+		*(volatile unsigned short *)PORT2ADDR(port) = w;
+	
+	delay();
+}
+
+void _outl_p(unsigned long l, unsigned long port)
+{
+	*(volatile unsigned long *)PORT2ADDR(port) = l;
+	delay();
+}
+
+void _insb(unsigned int port, void * addr, unsigned long count)
+{
+	if (port >= LAN_IOSTART && port < LAN_IOEND)
+		_ne_insb(PORT2ADDR_NE(port), addr, count);
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	  else if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_ioread_byte(0, port, (void *)addr, sizeof(unsigned char), count, 1);
+	} 
+#endif
+	else {
+		unsigned char *buf = addr;
+		unsigned char *portp = PORT2ADDR(port);
+		while(count--) *buf++ = *(volatile unsigned char *)portp;
+	}
+}
+
+void _insw(unsigned int port, void * addr, unsigned long count)
+{
+	unsigned short *buf = addr;
+	unsigned short *portp;
+
+	if (port >= LAN_IOSTART && port < LAN_IOEND) {
+		/*
+		 * This portion is only used by smc91111.c to read data
+		 * from the DATA_REG. Do not swap the data.
+		 */
+		portp = PORT2ADDR_NE(port);
+		while (count--) *buf++ = *(volatile unsigned short *)portp;
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	} else if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_ioread_word(9, port, (void *)addr, sizeof(unsigned short), count, 1);
+#endif
+	} else {
+		portp = PORT2ADDR(port);
+		while (count--) *buf++ = *(volatile unsigned short *)portp;
+	}
+}
+
+void _insl(unsigned int port, void * addr, unsigned long count)
+{
+	unsigned long *buf = addr;
+	unsigned long *portp;
+
+	portp = PORT2ADDR(port);
+	while (count--) *buf++ = *(volatile unsigned long *)portp;
+}
+
+void _outsb(unsigned int port, const void * addr, unsigned long count)
+{
+	const unsigned char *buf = addr;
+	unsigned char *portp;
+
+	if (port >= LAN_IOSTART && port < LAN_IOEND) {
+		portp = PORT2ADDR_NE(port);
+		while (count--) _ne_outb(*buf++, portp);
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	} else if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite_byte(0, port, (void *)addr, sizeof(unsigned char), count, 1);
+#endif
+	} else {
+		portp = PORT2ADDR(port);
+		while(count--) *(volatile unsigned char *)portp = *buf++;
+	}
+}
+
+void _outsw(unsigned int port, const void * addr, unsigned long count)
+{
+	const unsigned short *buf = addr;
+	unsigned short *portp;
+
+	if (port >= LAN_IOSTART && port < LAN_IOEND) {
+		/*
+		 * This portion is only used by smc91111.c to write data
+		 * into the DATA_REG. Do not swap the data.
+		 */
+		portp = PORT2ADDR_NE(port);
+		while(count--) *(volatile unsigned short *)portp = *buf++;
+#if defined(CONFIG_PCMCIA) && defined(CONFIG_M32R_CFC)
+	} else if (port >= M32R_PCC_IOSTART0 && port <= M32R_PCC_IOEND0) {
+	   pcc_iowrite_word(9, port, (void *)addr, sizeof(unsigned short), count, 1);
+#endif
+	} else {
+		portp = PORT2ADDR(port);
+		while(count--) *(volatile unsigned short *)portp = *buf++;
+	}
+}
+
+void _outsl(unsigned int port, const void * addr, unsigned long count)
+{
+	const unsigned long *buf = addr;
+	unsigned char *portp;
+
+	portp = PORT2ADDR(port);
+	while(count--) *(volatile unsigned long *)portp = *buf++;
+}
diff -ruN linux-2.6.7.org/arch/m32r/kernel/io_usrv.c linux-2.6.7/arch/m32r/kernel/io_usrv.c
--- linux-2.6.7.org/arch/m32r/kernel/io_usrv.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/io_usrv.c	2004-06-22 18:42:09.000000000 +0900
@@ -0,0 +1,247 @@
+/*  
+ *  linux/arch/m32r/kernel/io_usrv.c
+ *   
+ *  Typical I/O routines for uServer board.
+ *  
+ *  Copyright (c) 2001 - 2003  Hiroyuki Kondo, Hirokazu Takata, 
+ *                             Hitoshi Yamamoto, Takeo Takahashi
+ *
+ *  This file is subject to the terms and conditions of the GNU General
+ *  Public License.  See the file "COPYING" in the main directory of this
+ *  archive for more details.
+ *
+ */
+
+#include <linux/config.h>
+#include <asm/m32r.h>
+#include <asm/page.h>
+#include <asm/io.h>
+
+#include <linux/types.h>
+#include "../drivers/m32r_cfc.h"
+
+extern void pcc_ioread_byte(int, unsigned long, void *, size_t, size_t, int);
+extern void pcc_ioread_word(int, unsigned long, void *, size_t, size_t, int);
+extern void pcc_iowrite_byte(int, unsigned long, void *, size_t, size_t, int);
+extern void pcc_iowrite_word(int, unsigned long, void *, size_t, size_t, int);
+#define CFC_IOSTART	CFC_IOPORT_BASE
+#define CFC_IOEND	(CFC_IOSTART + (M32R_PCC_MAPSIZE * M32R_MAX_PCC) - 1)
+
+#if defined(CONFIG_SERIAL_8250) || defined(CONFIG_SERIAL_8250_MODULE)
+#define UART0_REGSTART		0x04c20000
+#define UART1_REGSTART		0x04c20100
+#define UART_IOMAP_SIZE		8
+#define UART0_IOSTART		0x3f8
+#define UART0_IOEND		(UART0_IOSTART + UART_IOMAP_SIZE - 1)
+#define UART1_IOSTART		0x2f8
+#define UART1_IOEND		(UART1_IOSTART + UART_IOMAP_SIZE - 1)
+#endif	/* CONFIG_SERIAL_8250 || CONFIG_SERIAL_8250_MODULE */
+
+#define PORT2ADDR(port)	_port2addr(port)
+
+static __inline__ void *_port2addr(unsigned long port)
+{
+#if defined(CONFIG_SERIAL_8250) || defined(CONFIG_SERIAL_8250_MODULE)
+	if (port >= UART0_IOSTART && port <= UART0_IOEND)
+		port = ((port - UART0_IOSTART) << 1) + UART0_REGSTART;
+	else if (port >= UART1_IOSTART && port <= UART1_IOEND)
+		port = ((port - UART1_IOSTART) << 1) + UART1_REGSTART;
+#endif	/* CONFIG_SERIAL_8250 || CONFIG_SERIAL_8250_MODULE */
+	return (void *)(port + NONCACHE_OFFSET);
+}
+
+static __inline__ void delay(void)
+{
+	__asm__ __volatile__ ("push r0; \n\t pop r0;" : : :"memory");	
+}
+
+unsigned char _inb(unsigned long port)
+{
+	if (port >= CFC_IOSTART && port <= CFC_IOEND) {
+		unsigned char b;
+		pcc_ioread_byte(0, port, &b, sizeof(b), 1, 0);
+		return b;
+	} else
+		return *(volatile unsigned char *)PORT2ADDR(port);
+}
+
+unsigned short _inw(unsigned long port)
+{
+	if (port >= CFC_IOSTART && port <= CFC_IOEND) {
+		unsigned short w;
+		pcc_ioread_word(0, port, &w, sizeof(w), 1, 0);
+		return w;
+	} else
+		return *(volatile unsigned short *)PORT2ADDR(port);
+}
+
+unsigned long _inl(unsigned long port)
+{
+	if (port >= CFC_IOSTART && port <= CFC_IOEND) {
+		unsigned long l;
+		pcc_ioread_word(0, port, &l, sizeof(l), 1, 0);
+		return l;
+	} else
+		return *(volatile unsigned long *)PORT2ADDR(port);
+}
+
+unsigned char _inb_p(unsigned long port)
+{
+	unsigned char b;
+
+	if (port >= CFC_IOSTART && port <= CFC_IOEND) {
+		pcc_ioread_byte(0, port, &b, sizeof(b), 1, 0);
+		return b;
+	} else {
+		b = *(volatile unsigned char *)PORT2ADDR(port);
+		delay();
+		return b;
+	}
+}
+
+unsigned short _inw_p(unsigned long port)
+{
+	unsigned short w;
+
+	if (port >= CFC_IOSTART && port <= CFC_IOEND) {
+		pcc_ioread_word(0, port, &w, sizeof(w), 1, 0);
+		return w;
+	} else {
+		w = *(volatile unsigned short *)PORT2ADDR(port);
+		delay();
+		return w;
+	}
+}
+
+unsigned long _inl_p(unsigned long port)
+{
+	unsigned long v;
+
+	v = *(volatile unsigned long *)PORT2ADDR(port);
+	delay();
+
+	return v;
+}
+
+void _outb(unsigned char b, unsigned long port)
+{
+	if (port >= CFC_IOSTART && port <= CFC_IOEND)
+		pcc_iowrite_byte(0, port, &b, sizeof(b), 1, 0);
+	else
+		*(volatile unsigned char *)PORT2ADDR(port) = b;
+}
+
+void _outw(unsigned short w, unsigned long port)
+{
+	if (port >= CFC_IOSTART && port <= CFC_IOEND)
+		pcc_iowrite_word(0, port, &w, sizeof(w), 1, 0);
+	else
+		*(volatile unsigned short *)PORT2ADDR(port) = w;
+}
+
+void _outl(unsigned long l, unsigned long port)
+{
+	if (port >= CFC_IOSTART && port <= CFC_IOEND)
+		pcc_iowrite_word(0, port, &l, sizeof(l), 1, 0);
+	else
+		*(volatile unsigned long *)PORT2ADDR(port) = l;
+}
+
+void _outb_p(unsigned char b, unsigned long port)
+{
+	if (port >= CFC_IOSTART && port <= CFC_IOEND)
+		pcc_iowrite_byte(0, port, &b, sizeof(b), 1, 0);
+	else
+		*(volatile unsigned char *)PORT2ADDR(port) = b;
+	delay();
+}
+
+void _outw_p(unsigned short w, unsigned long port)
+{
+	if (port >= CFC_IOSTART && port <= CFC_IOEND)
+		pcc_iowrite_word(0, port, &w, sizeof(w), 1, 0);
+	else
+		*(volatile unsigned short *)PORT2ADDR(port) = w;
+	delay();
+}
+
+void _outl_p(unsigned long l, unsigned long port)
+{
+	*(volatile unsigned long *)PORT2ADDR(port) = l;
+	delay();
+}
+
+void _insb(unsigned int port, void * addr, unsigned long count)
+{
+	if (port >= CFC_IOSTART && port <= CFC_IOEND)
+		pcc_ioread_byte(0, port, addr, sizeof(unsigned char), count, 1);
+	else {
+		unsigned char *buf = addr;
+		unsigned char *portp = PORT2ADDR(port);
+		while(count--) *buf++ = *(volatile unsigned char *)portp;
+	}
+}
+
+void _insw(unsigned int port, void * addr, unsigned long count)
+{
+	unsigned short *buf = addr;
+	unsigned short *portp;
+
+	if (port >= CFC_IOSTART && port <= CFC_IOEND)
+		pcc_ioread_word(0, port, addr, sizeof(unsigned short), count,
+			1);
+	else {
+		portp = PORT2ADDR(port);
+		while (count--) *buf++ = *(volatile unsigned short *)portp;
+	}
+}
+
+void _insl(unsigned int port, void * addr, unsigned long count)
+{
+	unsigned long *buf = addr;
+	unsigned long *portp;
+
+	portp = PORT2ADDR(port);
+	while (count--)
+		*buf++ = *(volatile unsigned long *)portp;
+}
+
+void _outsb(unsigned int port, const void * addr, unsigned long count)
+{
+	const unsigned char *buf = addr;
+	unsigned char *portp;
+
+	if (port >= CFC_IOSTART && port <= CFC_IOEND)
+		pcc_iowrite_byte(0, port, (void *)addr, sizeof(unsigned char),
+			count, 1);
+	else {
+		portp = PORT2ADDR(port);
+		while (count--)
+			*(volatile unsigned char *)portp = *buf++;
+	}
+}
+
+void _outsw(unsigned int port, const void * addr, unsigned long count)
+{
+	const unsigned short *buf = addr;
+	unsigned short *portp;
+
+	if (port >= CFC_IOSTART && port <= CFC_IOEND)
+		pcc_iowrite_word(0, port, (void *)addr, sizeof(unsigned short),
+			count, 1);
+	else {
+		portp = PORT2ADDR(port);
+		while (count--)
+			*(volatile unsigned short *)portp = *buf++;
+	}
+}
+
+void _outsl(unsigned int port, const void * addr, unsigned long count)
+{
+	const unsigned long *buf = addr;
+	unsigned char *portp;
+
+	portp = PORT2ADDR(port);
+	while (count--)
+		*(volatile unsigned long *)portp = *buf++;
+}
diff -ruN linux-2.6.7.org/arch/m32r/kernel/irq.c linux-2.6.7/arch/m32r/kernel/irq.c
--- linux-2.6.7.org/arch/m32r/kernel/irq.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/irq.c	2004-03-25 13:27:25.000000000 +0900
@@ -0,0 +1,1019 @@
+/*
+ * linux/arch/m32r/kernel/irq.c
+ *
+ *  Copyright (c) 2003, 2004 Hitoshi Yamamoto
+ *
+ *  Taken from i386 2.6.4 version.
+ */
+
+/*
+ *	linux/arch/i386/kernel/irq.c
+ *
+ *	Copyright (C) 1992, 1998 Linus Torvalds, Ingo Molnar
+ *
+ * This file contains the code used by various IRQ handling routines:
+ * asking for different IRQ's should be done through these routines
+ * instead of just grabbing them. Thus setups with different IRQ numbers
+ * shouldn't result in any weird surprises, and installing new handlers
+ * should be easier.
+ */
+
+/*
+ * (mostly architecture independent, will move to kernel/irq.c in 2.5.)
+ *
+ * IRQs are in fact implemented a bit like signal handlers for the kernel.
+ * Naturally it's not a 1:1 relation, but there are similarities.
+ */
+
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/timex.h>
+#include <linux/slab.h>
+#include <linux/random.h>
+#include <linux/smp_lock.h>
+#include <linux/init.h>
+#include <linux/kernel_stat.h>
+#include <linux/irq.h>
+#include <linux/proc_fs.h>
+#include <linux/seq_file.h>
+#include <linux/kallsyms.h>
+
+#include <asm/atomic.h>
+#include <asm/io.h>
+#include <asm/smp.h>
+#include <asm/system.h>
+#include <asm/bitops.h>
+#include <asm/uaccess.h>
+#include <asm/pgalloc.h>
+#include <asm/delay.h>
+#include <asm/irq.h>
+
+/*
+ * Linux has a controller-independent x86 interrupt architecture.
+ * every controller has a 'controller-template', that is used
+ * by the main code to do the right thing. Each driver-visible
+ * interrupt source is transparently wired to the apropriate
+ * controller. Thus drivers need not be aware of the
+ * interrupt-controller.
+ *
+ * Various interrupt controllers we handle: 8259 PIC, SMP IO-APIC,
+ * PIIX4's internal 8259 PIC and SGI's Visual Workstation Cobalt (IO-)APIC.
+ * (IO-APICs assumed to be messaging to Pentium local-APICs)
+ *
+ * the code is designed to be easily extended with new/different
+ * interrupt controllers, without having to do assembly magic.
+ */
+
+/*
+ * Controller mappings for all interrupt sources:
+ */
+irq_desc_t irq_desc[NR_IRQS] __cacheline_aligned = {
+	[0 ... NR_IRQS-1] = {
+		.handler = &no_irq_type,
+		.lock = SPIN_LOCK_UNLOCKED
+	}
+};
+
+static void register_irq_proc (unsigned int irq);
+
+/*
+ * Special irq handlers.
+ */
+
+irqreturn_t no_action(int cpl, void *dev_id, struct pt_regs *regs)
+{ return IRQ_NONE; }
+
+/*
+ * Generic no controller code
+ */
+
+static void enable_none(unsigned int irq) { }
+static unsigned int startup_none(unsigned int irq) { return 0; }
+static void disable_none(unsigned int irq) { }
+static void ack_none(unsigned int irq)
+{
+/*
+ * 'what should we do if we get a hw irq event on an illegal vector'.
+ * each architecture has to answer this themselves, it doesn't deserve
+ * a generic callback i think.
+ */
+	printk("unexpected IRQ trap at vector %02x\n", irq);
+}
+
+/* startup is the same as "enable", shutdown is same as "disable" */
+#define shutdown_none	disable_none
+#define end_none	enable_none
+
+struct hw_interrupt_type no_irq_type = {
+	"none",
+	startup_none,
+	shutdown_none,
+	enable_none,
+	disable_none,
+	ack_none,
+	end_none
+};
+
+atomic_t irq_err_count;
+atomic_t irq_mis_count;
+
+/*
+ * Generic, controller-independent functions:
+ */
+
+int show_interrupts(struct seq_file *p, void *v)
+{
+	int i = *(loff_t *) v, j;
+	struct irqaction * action;
+	unsigned long flags;
+
+	if (i == 0) {
+		seq_printf(p, "           ");
+		for (j=0; j<NR_CPUS; j++)
+			if (cpu_online(j))
+				seq_printf(p, "CPU%d       ",j);
+		seq_putc(p, '\n');
+	}
+
+	if (i < NR_IRQS) {
+		spin_lock_irqsave(&irq_desc[i].lock, flags);
+		action = irq_desc[i].action;
+		if (!action) 
+			goto skip;
+		seq_printf(p, "%3d: ",i);
+#ifndef CONFIG_SMP
+		seq_printf(p, "%10u ", kstat_irqs(i));
+#else
+		for (j = 0; j < NR_CPUS; j++)
+			if (cpu_online(j))
+				seq_printf(p, "%10u ", kstat_cpu(j).irqs[i]);
+#endif
+		seq_printf(p, " %14s", irq_desc[i].handler->typename);
+		seq_printf(p, "  %s", action->name);
+
+		for (action=action->next; action; action = action->next)
+			seq_printf(p, ", %s", action->name);
+
+		seq_putc(p, '\n');
+skip:
+		spin_unlock_irqrestore(&irq_desc[i].lock, flags);
+	} else if (i == NR_IRQS) {
+		seq_printf(p, "ERR: %10u\n", atomic_read(&irq_err_count));
+		seq_printf(p, "MIS: %10u\n", atomic_read(&irq_mis_count));
+	}
+	return 0;
+}
+
+#ifdef CONFIG_SMP
+inline void synchronize_irq(unsigned int irq)
+{
+	while (irq_desc[irq].status & IRQ_INPROGRESS)
+		cpu_relax();
+}
+#endif
+
+/*
+ * This should really return information about whether
+ * we should do bottom half handling etc. Right now we
+ * end up _always_ checking the bottom half, which is a
+ * waste of time and is not what some drivers would
+ * prefer.
+ */
+int handle_IRQ_event(unsigned int irq,
+		struct pt_regs *regs, struct irqaction *action)
+{
+	int status = 1;	/* Force the "do bottom halves" bit */
+	int retval = 0;
+
+	if (!(action->flags & SA_INTERRUPT))
+		local_irq_enable();
+
+	do {
+		status |= action->flags;
+		retval |= action->handler(irq, action->dev_id, regs);
+		action = action->next;
+	} while (action);
+	if (status & SA_SAMPLE_RANDOM)
+		add_interrupt_randomness(irq);
+	local_irq_disable();
+	return retval;
+}
+
+static void __report_bad_irq(int irq, irq_desc_t *desc, irqreturn_t action_ret)
+{
+	struct irqaction *action;
+
+	if (action_ret != IRQ_HANDLED && action_ret != IRQ_NONE) {
+		printk(KERN_ERR "irq event %d: bogus return value %x\n",
+				irq, action_ret);
+	} else {
+		printk(KERN_ERR "irq %d: nobody cared!\n", irq);
+	}
+	dump_stack();
+	printk(KERN_ERR "handlers:\n");
+	action = desc->action;
+	do {
+		printk(KERN_ERR "[<%p>]", action->handler);
+		print_symbol(" (%s)",
+			(unsigned long)action->handler);
+		printk("\n");
+		action = action->next;
+	} while (action);
+}
+
+static void report_bad_irq(int irq, irq_desc_t *desc, irqreturn_t action_ret)
+{
+	static int count = 100;
+
+	if (count) {
+		count--;
+		__report_bad_irq(irq, desc, action_ret);
+	}
+}
+
+static int noirqdebug;
+
+static int __init noirqdebug_setup(char *str)
+{
+	noirqdebug = 1;
+	printk("IRQ lockup detection disabled\n");
+	return 1;
+}
+
+__setup("noirqdebug", noirqdebug_setup);
+
+/*
+ * If 99,900 of the previous 100,000 interrupts have not been handled then
+ * assume that the IRQ is stuck in some manner.  Drop a diagnostic and try to
+ * turn the IRQ off.
+ *
+ * (The other 100-of-100,000 interrupts may have been a correctly-functioning
+ *  device sharing an IRQ with the failing one)
+ *
+ * Called under desc->lock
+ */
+static void note_interrupt(int irq, irq_desc_t *desc, irqreturn_t action_ret)
+{
+	if (action_ret != IRQ_HANDLED) {
+		desc->irqs_unhandled++;
+		if (action_ret != IRQ_NONE)
+			report_bad_irq(irq, desc, action_ret);
+	}
+
+	desc->irq_count++;
+	if (desc->irq_count < 100000)
+		return;
+
+	desc->irq_count = 0;
+	if (desc->irqs_unhandled > 99900) {
+		/*
+		 * The interrupt is stuck
+		 */
+		__report_bad_irq(irq, desc, action_ret);
+		/*
+		 * Now kill the IRQ
+		 */
+		printk(KERN_EMERG "Disabling IRQ #%d\n", irq);
+		desc->status |= IRQ_DISABLED;
+		desc->handler->disable(irq);
+	}
+	desc->irqs_unhandled = 0;
+}
+
+/*
+ * Generic enable/disable code: this just calls
+ * down into the PIC-specific version for the actual
+ * hardware disable after having gotten the irq
+ * controller lock. 
+ */
+ 
+/**
+ *	disable_irq_nosync - disable an irq without waiting
+ *	@irq: Interrupt to disable
+ *
+ *	Disable the selected interrupt line.  Disables and Enables are
+ *	nested.
+ *	Unlike disable_irq(), this function does not ensure existing
+ *	instances of the IRQ handler have completed before returning.
+ *
+ *	This function may be called from IRQ context.
+ */
+ 
+inline void disable_irq_nosync(unsigned int irq)
+{
+	irq_desc_t *desc = irq_desc + irq;
+	unsigned long flags;
+
+	spin_lock_irqsave(&desc->lock, flags);
+	if (!desc->depth++) {
+		desc->status |= IRQ_DISABLED;
+		desc->handler->disable(irq);
+	}
+	spin_unlock_irqrestore(&desc->lock, flags);
+}
+
+/**
+ *	disable_irq - disable an irq and wait for completion
+ *	@irq: Interrupt to disable
+ *
+ *	Disable the selected interrupt line.  Enables and Disables are
+ *	nested.
+ *	This function waits for any pending IRQ handlers for this interrupt
+ *	to complete before returning. If you use this function while
+ *	holding a resource the IRQ handler may need you will deadlock.
+ *
+ *	This function may be called - with care - from IRQ context.
+ */
+ 
+void disable_irq(unsigned int irq)
+{
+	irq_desc_t *desc = irq_desc + irq;
+	disable_irq_nosync(irq);
+	if (desc->action)
+		synchronize_irq(irq);
+}
+
+/**
+ *	enable_irq - enable handling of an irq
+ *	@irq: Interrupt to enable
+ *
+ *	Undoes the effect of one call to disable_irq().  If this
+ *	matches the last disable, processing of interrupts on this
+ *	IRQ line is re-enabled.
+ *
+ *	This function may be called from IRQ context.
+ */
+ 
+void enable_irq(unsigned int irq)
+{
+	irq_desc_t *desc = irq_desc + irq;
+	unsigned long flags;
+
+	spin_lock_irqsave(&desc->lock, flags);
+	switch (desc->depth) {
+	case 1: {
+		unsigned int status = desc->status & ~IRQ_DISABLED;
+		desc->status = status;
+		if ((status & (IRQ_PENDING | IRQ_REPLAY)) == IRQ_PENDING) {
+			desc->status = status | IRQ_REPLAY;
+			hw_resend_irq(desc->handler,irq);
+		}
+		desc->handler->enable(irq);
+		/* fall-through */
+	}
+	default:
+		desc->depth--;
+		break;
+	case 0:
+		printk("enable_irq(%u) unbalanced from %p\n", irq,
+		       __builtin_return_address(0));
+	}
+	spin_unlock_irqrestore(&desc->lock, flags);
+}
+
+/*
+ * do_IRQ handles all normal device IRQ's (the special
+ * SMP cross-CPU interrupts have their own specific
+ * handlers).
+ */
+asmlinkage unsigned int do_IRQ(int irq, struct pt_regs *regs)
+{	
+	/* 
+	 * We ack quickly, we don't want the irq controller
+	 * thinking we're snobs just because some other CPU has
+	 * disabled global interrupts (we have already done the
+	 * INT_ACK cycles, it's too late to try to pretend to the
+	 * controller that we aren't taking the interrupt).
+	 *
+	 * 0 return value means that this irq is already being
+	 * handled by some other CPU. (or is disabled)
+	 */
+	irq_desc_t *desc = irq_desc + irq;
+	struct irqaction * action;
+	unsigned int status;
+
+	irq_enter();
+
+#ifdef CONFIG_DEBUG_STACKOVERFLOW
+	/* FIXME M32R */
+#endif
+	kstat_this_cpu.irqs[irq]++;
+	spin_lock(&desc->lock);
+	desc->handler->ack(irq);
+	/*
+	   REPLAY is when Linux resends an IRQ that was dropped earlier
+	   WAITING is used by probe to mark irqs that are being tested
+	   */
+	status = desc->status & ~(IRQ_REPLAY | IRQ_WAITING);
+	status |= IRQ_PENDING; /* we _want_ to handle it */
+
+	/*
+	 * If the IRQ is disabled for whatever reason, we cannot
+	 * use the action we have.
+	 */
+	action = NULL;
+	if (likely(!(status & (IRQ_DISABLED | IRQ_INPROGRESS)))) {
+		action = desc->action;
+		status &= ~IRQ_PENDING; /* we commit to handling */
+		status |= IRQ_INPROGRESS; /* we are handling it */
+	}
+	desc->status = status;
+
+	/*
+	 * If there is no IRQ handler or it was disabled, exit early.
+	   Since we set PENDING, if another processor is handling
+	   a different instance of this same irq, the other processor
+	   will take care of it.
+	 */
+	if (unlikely(!action))
+		goto out;
+
+	/*
+	 * Edge triggered interrupts need to remember
+	 * pending events.
+	 * This applies to any hw interrupts that allow a second
+	 * instance of the same irq to arrive while we are in do_IRQ
+	 * or in the handler. But the code here only handles the _second_
+	 * instance of the irq, not the third or fourth. So it is mostly
+	 * useful for irq hardware that does not mask cleanly in an
+	 * SMP environment.
+	 */
+	for (;;) {
+		irqreturn_t action_ret;
+
+		spin_unlock(&desc->lock);
+		action_ret = handle_IRQ_event(irq, regs, action);
+		spin_lock(&desc->lock);
+		if (!noirqdebug)
+			note_interrupt(irq, desc, action_ret);
+		if (likely(!(desc->status & IRQ_PENDING)))
+			break;
+		desc->status &= ~IRQ_PENDING;
+	}
+	desc->status &= ~IRQ_INPROGRESS;
+
+out:
+	/*
+	 * The ->end() handler has to deal with interrupts which got
+	 * disabled while the handler was running.
+	 */
+	desc->handler->end(irq);
+	spin_unlock(&desc->lock);
+
+	irq_exit();
+
+#if defined(CONFIG_SMP)
+	if (irq == M32R_IRQ_MFT2)
+		smp_send_timer();
+#endif	/* CONFIG_SMP */
+
+	return 1;
+}
+
+int can_request_irq(unsigned int irq, unsigned long irqflags)
+{
+	struct irqaction *action;
+
+	if (irq >= NR_IRQS)
+		return 0;
+	action = irq_desc[irq].action;
+	if (action) {
+		if (irqflags & action->flags & SA_SHIRQ)
+			action = NULL;
+	}
+	return !action;
+}
+
+/**
+ *	request_irq - allocate an interrupt line
+ *	@irq: Interrupt line to allocate
+ *	@handler: Function to be called when the IRQ occurs
+ *	@irqflags: Interrupt type flags
+ *	@devname: An ascii name for the claiming device
+ *	@dev_id: A cookie passed back to the handler function
+ *
+ *	This call allocates interrupt resources and enables the
+ *	interrupt line and IRQ handling. From the point this
+ *	call is made your handler function may be invoked. Since
+ *	your handler function must clear any interrupt the board 
+ *	raises, you must take care both to initialise your hardware
+ *	and to set up the interrupt handler in the right order.
+ *
+ *	Dev_id must be globally unique. Normally the address of the
+ *	device data structure is used as the cookie. Since the handler
+ *	receives this value it makes sense to use it.
+ *
+ *	If your interrupt is shared you must pass a non NULL dev_id
+ *	as this is required when freeing the interrupt.
+ *
+ *	Flags:
+ *
+ *	SA_SHIRQ		Interrupt is shared
+ *
+ *	SA_INTERRUPT		Disable local interrupts while processing
+ *
+ *	SA_SAMPLE_RANDOM	The interrupt can be used for entropy
+ *
+ */
+ 
+int request_irq(unsigned int irq, 
+		irqreturn_t (*handler)(int, void *, struct pt_regs *),
+		unsigned long irqflags, 
+		const char * devname,
+		void *dev_id)
+{
+	int retval;
+	struct irqaction * action;
+
+#if 1
+	/*
+	 * Sanity-check: shared interrupts should REALLY pass in
+	 * a real dev-ID, otherwise we'll have trouble later trying
+	 * to figure out which interrupt is which (messes up the
+	 * interrupt freeing logic etc).
+	 */
+	if (irqflags & SA_SHIRQ) {
+		if (!dev_id)
+			printk("Bad boy: %s (at 0x%x) called us without a dev_id!\n", devname, (&irq)[-1]);
+	}
+#endif
+
+	if (irq >= NR_IRQS)
+		return -EINVAL;
+	if (!handler)
+		return -EINVAL;
+
+	action = (struct irqaction *)
+			kmalloc(sizeof(struct irqaction), GFP_ATOMIC);
+	if (!action)
+		return -ENOMEM;
+
+	action->handler = handler;
+	action->flags = irqflags;
+	action->mask = 0;
+	action->name = devname;
+	action->next = NULL;
+	action->dev_id = dev_id;
+
+	retval = setup_irq(irq, action);
+	if (retval)
+		kfree(action);
+	return retval;
+}
+
+EXPORT_SYMBOL(request_irq);
+
+/**
+ *	free_irq - free an interrupt
+ *	@irq: Interrupt line to free
+ *	@dev_id: Device identity to free
+ *
+ *	Remove an interrupt handler. The handler is removed and if the
+ *	interrupt line is no longer in use by any driver it is disabled.
+ *	On a shared IRQ the caller must ensure the interrupt is disabled
+ *	on the card it drives before calling this function. The function
+ *	does not return until any executing interrupts for this IRQ
+ *	have completed.
+ *
+ *	This function must not be called from interrupt context. 
+ */
+ 
+void free_irq(unsigned int irq, void *dev_id)
+{
+	irq_desc_t *desc;
+	struct irqaction **p;
+	unsigned long flags;
+
+	if (irq >= NR_IRQS)
+		return;
+
+	desc = irq_desc + irq;
+	spin_lock_irqsave(&desc->lock,flags);
+	p = &desc->action;
+	for (;;) {
+		struct irqaction * action = *p;
+		if (action) {
+			struct irqaction **pp = p;
+			p = &action->next;
+			if (action->dev_id != dev_id)
+				continue;
+
+			/* Found it - now remove it from the list of entries */
+			*pp = action->next;
+			if (!desc->action) {
+				desc->status |= IRQ_DISABLED;
+				desc->handler->shutdown(irq);
+			}
+			spin_unlock_irqrestore(&desc->lock,flags);
+
+			/* Wait to make sure it's not being used on another CPU */
+			synchronize_irq(irq);
+			kfree(action);
+			return;
+		}
+		printk("Trying to free free IRQ%d\n",irq);
+		spin_unlock_irqrestore(&desc->lock,flags);
+		return;
+	}
+}
+
+EXPORT_SYMBOL(free_irq);
+
+/*
+ * IRQ autodetection code..
+ *
+ * This depends on the fact that any interrupt that
+ * comes in on to an unassigned handler will get stuck
+ * with "IRQ_WAITING" cleared and the interrupt
+ * disabled.
+ */
+
+static DECLARE_MUTEX(probe_sem);
+
+/**
+ *	probe_irq_on	- begin an interrupt autodetect
+ *
+ *	Commence probing for an interrupt. The interrupts are scanned
+ *	and a mask of potential interrupt lines is returned.
+ *
+ */
+ 
+unsigned long probe_irq_on(void)
+{
+	unsigned int i;
+	irq_desc_t *desc;
+	unsigned long val;
+	unsigned long delay;
+
+	down(&probe_sem);
+	/* 
+	 * something may have generated an irq long ago and we want to
+	 * flush such a longstanding irq before considering it as spurious. 
+	 */
+	for (i = NR_IRQS-1; i > 0; i--)  {
+		desc = irq_desc + i;
+
+		spin_lock_irq(&desc->lock);
+		if (!irq_desc[i].action) 
+			irq_desc[i].handler->startup(i);
+		spin_unlock_irq(&desc->lock);
+	}
+
+	/* Wait for longstanding interrupts to trigger. */
+	for (delay = jiffies + HZ/50; time_after(delay, jiffies); )
+		/* about 20ms delay */ barrier();
+
+	/*
+	 * enable any unassigned irqs
+	 * (we must startup again here because if a longstanding irq
+	 * happened in the previous stage, it may have masked itself)
+	 */
+	for (i = NR_IRQS-1; i > 0; i--) {
+		desc = irq_desc + i;
+
+		spin_lock_irq(&desc->lock);
+		if (!desc->action) {
+			desc->status |= IRQ_AUTODETECT | IRQ_WAITING;
+			if (desc->handler->startup(i))
+				desc->status |= IRQ_PENDING;
+		}
+		spin_unlock_irq(&desc->lock);
+	}
+
+	/*
+	 * Wait for spurious interrupts to trigger
+	 */
+	for (delay = jiffies + HZ/10; time_after(delay, jiffies); )
+		/* about 100ms delay */ barrier();
+
+	/*
+	 * Now filter out any obviously spurious interrupts
+	 */
+	val = 0;
+	for (i = 0; i < NR_IRQS; i++) {
+		irq_desc_t *desc = irq_desc + i;
+		unsigned int status;
+
+		spin_lock_irq(&desc->lock);
+		status = desc->status;
+
+		if (status & IRQ_AUTODETECT) {
+			/* It triggered already - consider it spurious. */
+			if (!(status & IRQ_WAITING)) {
+				desc->status = status & ~IRQ_AUTODETECT;
+				desc->handler->shutdown(i);
+			} else
+				if (i < 32)
+					val |= 1 << i;
+		}
+		spin_unlock_irq(&desc->lock);
+	}
+
+	return val;
+}
+
+EXPORT_SYMBOL(probe_irq_on);
+
+/*
+ * Return a mask of triggered interrupts (this
+ * can handle only legacy ISA interrupts).
+ */
+ 
+/**
+ *	probe_irq_mask - scan a bitmap of interrupt lines
+ *	@val:	mask of interrupts to consider
+ *
+ *	Scan the ISA bus interrupt lines and return a bitmap of
+ *	active interrupts. The interrupt probe logic state is then
+ *	returned to its previous value.
+ *
+ *	Note: we need to scan all the irq's even though we will
+ *	only return ISA irq numbers - just so that we reset them
+ *	all to a known state.
+ */
+unsigned int probe_irq_mask(unsigned long val)
+{
+	int i;
+	unsigned int mask;
+
+	mask = 0;
+	for (i = 0; i < NR_IRQS; i++) {
+		irq_desc_t *desc = irq_desc + i;
+		unsigned int status;
+
+		spin_lock_irq(&desc->lock);
+		status = desc->status;
+
+		if (status & IRQ_AUTODETECT) {
+			if (i < 16 && !(status & IRQ_WAITING))
+				mask |= 1 << i;
+
+			desc->status = status & ~IRQ_AUTODETECT;
+			desc->handler->shutdown(i);
+		}
+		spin_unlock_irq(&desc->lock);
+	}
+	up(&probe_sem);
+
+	return mask & val;
+}
+
+/*
+ * Return the one interrupt that triggered (this can
+ * handle any interrupt source).
+ */
+
+/**
+ *	probe_irq_off	- end an interrupt autodetect
+ *	@val: mask of potential interrupts (unused)
+ *
+ *	Scans the unused interrupt lines and returns the line which
+ *	appears to have triggered the interrupt. If no interrupt was
+ *	found then zero is returned. If more than one interrupt is
+ *	found then minus the first candidate is returned to indicate
+ *	their is doubt.
+ *
+ *	The interrupt probe logic state is returned to its previous
+ *	value.
+ *
+ *	BUGS: When used in a module (which arguably shouldnt happen)
+ *	nothing prevents two IRQ probe callers from overlapping. The
+ *	results of this are non-optimal.
+ */
+ 
+int probe_irq_off(unsigned long val)
+{
+	int i, irq_found, nr_irqs;
+
+	nr_irqs = 0;
+	irq_found = 0;
+	for (i = 0; i < NR_IRQS; i++) {
+		irq_desc_t *desc = irq_desc + i;
+		unsigned int status;
+
+		spin_lock_irq(&desc->lock);
+		status = desc->status;
+
+		if (status & IRQ_AUTODETECT) {
+			if (!(status & IRQ_WAITING)) {
+				if (!nr_irqs)
+					irq_found = i;
+				nr_irqs++;
+			}
+			desc->status = status & ~IRQ_AUTODETECT;
+			desc->handler->shutdown(i);
+		}
+		spin_unlock_irq(&desc->lock);
+	}
+	up(&probe_sem);
+
+	if (nr_irqs > 1)
+		irq_found = -irq_found;
+	return irq_found;
+}
+
+EXPORT_SYMBOL(probe_irq_off);
+
+/* this was setup_x86_irq but it seems pretty generic */
+int setup_irq(unsigned int irq, struct irqaction * new)
+{
+	int shared = 0;
+	unsigned long flags;
+	struct irqaction *old, **p;
+	irq_desc_t *desc = irq_desc + irq;
+
+	if (desc->handler == &no_irq_type)
+		return -ENOSYS;
+	/*
+	 * Some drivers like serial.c use request_irq() heavily,
+	 * so we have to be careful not to interfere with a
+	 * running system.
+	 */
+	if (new->flags & SA_SAMPLE_RANDOM) {
+		/*
+		 * This function might sleep, we want to call it first,
+		 * outside of the atomic block.
+		 * Yes, this might clear the entropy pool if the wrong
+		 * driver is attempted to be loaded, without actually
+		 * installing a new handler, but is this really a problem,
+		 * only the sysadmin is able to do this.
+		 */
+		rand_initialize_irq(irq);
+	}
+
+	/*
+	 * The following block of code has to be executed atomically
+	 */
+	spin_lock_irqsave(&desc->lock,flags);
+	p = &desc->action;
+	if ((old = *p) != NULL) {
+		/* Can't share interrupts unless both agree to */
+		if (!(old->flags & new->flags & SA_SHIRQ)) {
+			spin_unlock_irqrestore(&desc->lock,flags);
+			return -EBUSY;
+		}
+
+		/* add new interrupt at end of irq queue */
+		do {
+			p = &old->next;
+			old = *p;
+		} while (old);
+		shared = 1;
+	}
+
+	*p = new;
+
+	if (!shared) {
+		desc->depth = 0;
+		desc->status &= ~(IRQ_DISABLED | IRQ_AUTODETECT | IRQ_WAITING | IRQ_INPROGRESS);
+		desc->handler->startup(irq);
+	}
+	spin_unlock_irqrestore(&desc->lock,flags);
+
+	register_irq_proc(irq);
+	return 0;
+}
+
+static struct proc_dir_entry * root_irq_dir;
+static struct proc_dir_entry * irq_dir [NR_IRQS];
+
+#ifdef CONFIG_SMP
+
+static struct proc_dir_entry *smp_affinity_entry[NR_IRQS];
+
+cpumask_t irq_affinity[NR_IRQS] = { [0 ... NR_IRQS-1] = CPU_MASK_ALL };
+
+static int irq_affinity_read_proc(char *page, char **start, off_t off,
+			int count, int *eof, void *data)
+{
+	int len = cpumask_scnprintf(page, count, irq_affinity[(long)data]);
+	if (count - len < 2)
+		return -EINVAL;
+	len += sprintf(page + len, "\n");
+	return len;
+}
+
+static int irq_affinity_write_proc(struct file *file, const char __user *buffer,
+					unsigned long count, void *data)
+{
+	int irq = (long)data, full_count = count, err;
+	cpumask_t new_value, tmp;
+
+	if (!irq_desc[irq].handler->set_affinity)
+		return -EIO;
+
+	err = cpumask_parse(buffer, count, new_value);
+	if (err)
+		return err;
+
+	/*
+	 * Do not allow disabling IRQs completely - it's a too easy
+	 * way to make the system unusable accidentally :-) At least
+	 * one online CPU still has to be targeted.
+	 */
+	cpus_and(tmp, new_value, cpu_online_map);
+	if (cpus_empty(tmp))
+		return -EINVAL;
+
+	irq_affinity[irq] = new_value;
+	irq_desc[irq].handler->set_affinity(irq,
+					cpumask_of_cpu(first_cpu(new_value)));
+
+	return full_count;
+}
+
+#endif
+
+static int prof_cpu_mask_read_proc (char *page, char **start, off_t off,
+			int count, int *eof, void *data)
+{
+	int len = cpumask_scnprintf(page, count, *(cpumask_t *)data);
+	if (count - len < 2)
+		return -EINVAL;
+	len += sprintf(page + len, "\n");
+	return len;
+}
+
+static int prof_cpu_mask_write_proc (struct file *file, const char __user *buffer,
+					unsigned long count, void *data)
+{
+	cpumask_t *mask = (cpumask_t *)data;
+	unsigned long full_count = count, err;
+	cpumask_t new_value;
+
+	err = cpumask_parse(buffer, count, new_value);
+	if (err)
+		return err;
+
+	*mask = new_value;
+	return full_count;
+}
+
+#define MAX_NAMELEN 10
+
+static void register_irq_proc (unsigned int irq)
+{
+	char name [MAX_NAMELEN];
+
+	if (!root_irq_dir || (irq_desc[irq].handler == &no_irq_type) ||
+			irq_dir[irq])
+		return;
+
+	memset(name, 0, MAX_NAMELEN);
+	sprintf(name, "%d", irq);
+
+	/* create /proc/irq/1234 */
+	irq_dir[irq] = proc_mkdir(name, root_irq_dir);
+
+#ifdef CONFIG_SMP
+	{
+		struct proc_dir_entry *entry;
+
+		/* create /proc/irq/1234/smp_affinity */
+		entry = create_proc_entry("smp_affinity", 0600, irq_dir[irq]);
+
+		if (entry) {
+			entry->nlink = 1;
+			entry->data = (void *)(long)irq;
+			entry->read_proc = irq_affinity_read_proc;
+			entry->write_proc = irq_affinity_write_proc;
+		}
+
+		smp_affinity_entry[irq] = entry;
+	}
+#endif
+}
+
+unsigned long prof_cpu_mask = -1;
+
+void init_irq_proc (void)
+{
+	struct proc_dir_entry *entry;
+	int i;
+
+	/* create /proc/irq */
+	root_irq_dir = proc_mkdir("irq", 0);
+
+	/* create /proc/irq/prof_cpu_mask */
+	entry = create_proc_entry("prof_cpu_mask", 0600, root_irq_dir);
+
+	if (!entry)
+	    return;
+
+	entry->nlink = 1;
+	entry->data = (void *)&prof_cpu_mask;
+	entry->read_proc = prof_cpu_mask_read_proc;
+	entry->write_proc = prof_cpu_mask_write_proc;
+
+	/*
+	 * Create entries for all existing IRQs.
+	 */
+	for (i = 0; i < NR_IRQS; i++)
+		register_irq_proc(i);
+}
+
diff -ruN linux-2.6.7.org/arch/m32r/kernel/m32r_ksyms.c linux-2.6.7/arch/m32r/kernel/m32r_ksyms.c
--- linux-2.6.7.org/arch/m32r/kernel/m32r_ksyms.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/m32r_ksyms.c	2004-07-27 14:44:00.000000000 +0900
@@ -0,0 +1,143 @@
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/smp.h>
+#include <linux/user.h>
+#include <linux/elfcore.h>
+#include <linux/sched.h>
+#include <linux/in6.h>
+#include <linux/interrupt.h>
+#include <linux/smp_lock.h>
+#include <linux/string.h>
+
+#include <asm/semaphore.h>
+#include <asm/processor.h>
+#include <asm/uaccess.h>
+#include <asm/checksum.h>
+#include <asm/io.h>
+#include <asm/hardirq.h>
+#include <asm/delay.h>
+#include <asm/irq.h>
+#include <asm/tlbflush.h>
+
+extern void dump_thread(struct pt_regs *, struct user *);
+
+#if defined(CONFIG_BLK_DEV_IDE) || defined(CONFIG_BLK_DEV_HD) || defined(CONFIG_BLK_DEV_IDE_MODULE) || defined(CONFIG_BLK_DEV_HD_MODULE)
+extern struct drive_info_struct drive_info;
+EXPORT_SYMBOL(drive_info);
+#endif
+
+/* platform dependent support */
+EXPORT_SYMBOL(boot_cpu_data);
+EXPORT_SYMBOL(dump_thread);
+EXPORT_SYMBOL(dump_fpu);
+EXPORT_SYMBOL(__ioremap);
+EXPORT_SYMBOL(iounmap);
+EXPORT_SYMBOL(enable_irq);
+EXPORT_SYMBOL(disable_irq);
+EXPORT_SYMBOL(disable_irq_nosync);
+EXPORT_SYMBOL(kernel_thread);
+EXPORT_SYMBOL(__down);
+EXPORT_SYMBOL(__down_interruptible);
+EXPORT_SYMBOL(__up);
+EXPORT_SYMBOL(__down_trylock);
+
+/* Networking helper routines. */
+EXPORT_SYMBOL(csum_partial_copy);
+/* Delay loops */
+EXPORT_SYMBOL(__udelay);
+EXPORT_SYMBOL(__delay);
+EXPORT_SYMBOL(__const_udelay);
+
+EXPORT_SYMBOL_NOVERS(__get_user_1);
+EXPORT_SYMBOL_NOVERS(__get_user_2);
+EXPORT_SYMBOL_NOVERS(__get_user_4);
+
+EXPORT_SYMBOL(strpbrk);
+EXPORT_SYMBOL(strstr);
+
+EXPORT_SYMBOL(strncpy_from_user);
+EXPORT_SYMBOL(__strncpy_from_user);
+EXPORT_SYMBOL(clear_user);
+EXPORT_SYMBOL(__clear_user);
+EXPORT_SYMBOL(__generic_copy_from_user);
+EXPORT_SYMBOL(__generic_copy_to_user);
+EXPORT_SYMBOL(strnlen_user);
+
+#ifdef CONFIG_SMP
+#ifdef CONFIG_CHIP_M32700_TS1
+extern void *dcache_dummy;
+EXPORT_SYMBOL(dcache_dummy);
+#endif
+EXPORT_SYMBOL(cpu_data);
+EXPORT_SYMBOL(cpu_online_map);
+EXPORT_SYMBOL(cpu_callout_map);
+
+/* Global SMP stuff */
+EXPORT_SYMBOL(synchronize_irq);
+EXPORT_SYMBOL(smp_call_function);
+
+/* TLB flushing */
+EXPORT_SYMBOL(smp_flush_tlb_page);
+EXPORT_SYMBOL_GPL(smp_flush_tlb_all);
+#endif
+
+/* compiler generated symbol */
+extern void __ashldi3(void);
+extern void __ashrdi3(void);
+extern void __lshldi3(void);
+extern void __lshrdi3(void);
+extern void __muldi3(void);
+EXPORT_SYMBOL_NOVERS(__ashldi3);
+EXPORT_SYMBOL_NOVERS(__ashrdi3);
+EXPORT_SYMBOL_NOVERS(__lshldi3);
+EXPORT_SYMBOL_NOVERS(__lshrdi3);
+EXPORT_SYMBOL_NOVERS(__muldi3);
+
+/* memory and string operations */
+EXPORT_SYMBOL_NOVERS(memchr);
+EXPORT_SYMBOL_NOVERS(memcpy);
+/* EXPORT_SYMBOL_NOVERS(memcpy_fromio); // not implement yet */
+/* EXPORT_SYMBOL_NOVERS(memcpy_toio); // not implement yet */
+EXPORT_SYMBOL_NOVERS(memset);
+/* EXPORT_SYMBOL_NOVERS(memset_io); // not implement yet */
+EXPORT_SYMBOL_NOVERS(memmove);
+EXPORT_SYMBOL_NOVERS(memcmp);
+EXPORT_SYMBOL_NOVERS(memscan);
+EXPORT_SYMBOL_NOVERS(copy_page);
+EXPORT_SYMBOL_NOVERS(clear_page);
+
+EXPORT_SYMBOL_NOVERS(strcat);
+EXPORT_SYMBOL_NOVERS(strchr);
+EXPORT_SYMBOL_NOVERS(strcmp);
+EXPORT_SYMBOL_NOVERS(strcpy);
+EXPORT_SYMBOL_NOVERS(strlen);
+EXPORT_SYMBOL_NOVERS(strncat);
+EXPORT_SYMBOL_NOVERS(strncmp);
+EXPORT_SYMBOL_NOVERS(strnlen);
+EXPORT_SYMBOL_NOVERS(strncpy);
+
+EXPORT_SYMBOL_NOVERS(_inb);
+EXPORT_SYMBOL_NOVERS(_inw);
+EXPORT_SYMBOL_NOVERS(_inl);
+EXPORT_SYMBOL_NOVERS(_outb);
+EXPORT_SYMBOL_NOVERS(_outw);
+EXPORT_SYMBOL_NOVERS(_outl);
+EXPORT_SYMBOL_NOVERS(_inb_p);
+EXPORT_SYMBOL_NOVERS(_inw_p);
+EXPORT_SYMBOL_NOVERS(_inl_p);
+EXPORT_SYMBOL_NOVERS(_outb_p);
+EXPORT_SYMBOL_NOVERS(_outw_p);
+EXPORT_SYMBOL_NOVERS(_outl_p);
+EXPORT_SYMBOL_NOVERS(_insb);
+EXPORT_SYMBOL_NOVERS(_insw);
+EXPORT_SYMBOL_NOVERS(_insl);
+EXPORT_SYMBOL_NOVERS(_outsb);
+EXPORT_SYMBOL_NOVERS(_outsw);
+EXPORT_SYMBOL_NOVERS(_outsl);
+EXPORT_SYMBOL_NOVERS(_readb);
+EXPORT_SYMBOL_NOVERS(_readw);
+EXPORT_SYMBOL_NOVERS(_readl);
+EXPORT_SYMBOL_NOVERS(_writeb);
+EXPORT_SYMBOL_NOVERS(_writew);
+EXPORT_SYMBOL_NOVERS(_writel);
+
diff -ruN linux-2.6.7.org/arch/m32r/kernel/module.c linux-2.6.7/arch/m32r/kernel/module.c
--- linux-2.6.7.org/arch/m32r/kernel/module.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/module.c	2004-05-11 13:54:57.000000000 +0900
@@ -0,0 +1,253 @@
+/*  Kernel module help for M32R.
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+*/
+#include <linux/moduleloader.h>
+#include <linux/elf.h>
+#include <linux/vmalloc.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+
+#if 0
+#define DEBUGP printk
+#else
+#define DEBUGP(fmt...)
+#endif
+
+void *module_alloc(unsigned long size)
+{
+	if (size == 0)
+		return NULL;
+	return vmalloc(size);
+}
+
+
+/* Free memory returned from module_alloc */
+void module_free(struct module *mod, void *module_region)
+{
+	vfree(module_region);
+	/* FIXME: If module_region == mod->init_region, trim exception
+           table entries. */
+}
+
+/* We don't need anything special. */
+int module_frob_arch_sections(Elf_Ehdr *hdr,
+			      Elf_Shdr *sechdrs,
+			      char *secstrings,
+			      struct module *mod)
+{
+	return 0;
+}
+
+#define COPY_UNALIGNED_WORD(sw, tw, align) \
+{ \
+	void *__s = &(sw), *__t = &(tw); \
+	unsigned short *__s2 = __s, *__t2 =__t; \
+	unsigned char *__s1 = __s, *__t1 =__t; \
+	switch ((align)) \
+	{ \
+	case 0: \
+		*(unsigned long *) __t = *(unsigned long *) __s; \
+		break; \
+	case 2: \
+		*__t2++ = *__s2++; \
+		*__t2 = *__s2; \
+		break; \
+	default: \
+		*__t1++ = *__s1++; \
+		*__t1++ = *__s1++; \
+		*__t1++ = *__s1++; \
+		*__t1 = *__s1; \
+		break; \
+	} \
+}
+
+#define COPY_UNALIGNED_HWORD(sw, tw, align) \
+  { \
+    void *__s = &(sw), *__t = &(tw); \
+    unsigned short *__s2 = __s, *__t2 =__t; \
+    unsigned char *__s1 = __s, *__t1 =__t; \
+    switch ((align)) \
+    { \
+    case 0: \
+      *__t2 = *__s2; \
+      break; \
+    default: \
+      *__t1++ = *__s1++; \
+      *__t1 = *__s1; \
+      break; \
+    } \
+  }
+
+int apply_relocate_add(Elf32_Shdr *sechdrs,
+		   const char *strtab,
+		   unsigned int symindex,
+		   unsigned int relsec,
+		   struct module *me)
+{
+	unsigned int i;
+	Elf32_Rela *rel = (void *)sechdrs[relsec].sh_addr;
+	Elf32_Sym *sym;
+	Elf32_Addr relocation;
+	uint32_t *location;
+	uint32_t value;
+	unsigned short *hlocation;
+	unsigned short hvalue;
+	int svalue;
+	int align;
+
+	DEBUGP("Applying relocate section %u to %u\n", relsec,
+	       sechdrs[relsec].sh_info);
+	for (i = 0; i < sechdrs[relsec].sh_size / sizeof(*rel); i++) {
+		/* This is where to make the change */
+		location = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr
+			+ rel[i].r_offset;
+		/* This is the symbol it is referring to.  Note that all
+		   undefined symbols have been resolved.  */
+		sym = (Elf32_Sym *)sechdrs[symindex].sh_addr
+			+ ELF32_R_SYM(rel[i].r_info);
+		relocation = sym->st_value + rel[i].r_addend;
+		align = (int)location & 3;
+
+		switch (ELF32_R_TYPE(rel[i].r_info)) {
+		case R_M32R_32_RELA:
+	    		COPY_UNALIGNED_WORD (*location, value, align);
+			value += relocation;
+	    		COPY_UNALIGNED_WORD (value, *location, align);
+			break;
+		case R_M32R_HI16_ULO_RELA:
+	    		COPY_UNALIGNED_WORD (*location, value, align);
+                        relocation = (relocation >>16) & 0xffff;
+			/* RELA must has 0 at relocation field. */
+			value += relocation;
+	    		COPY_UNALIGNED_WORD (value, *location, align);
+			break;
+		case R_M32R_HI16_SLO_RELA:
+	    		COPY_UNALIGNED_WORD (*location, value, align);
+			if (relocation & 0x8000) relocation += 0x10000;
+                        relocation = (relocation >>16) & 0xffff;
+			/* RELA must has 0 at relocation field. */
+			value += relocation;
+	    		COPY_UNALIGNED_WORD (value, *location, align);
+			break;
+		case R_M32R_16_RELA:
+			hlocation = (unsigned short *)location;
+                        relocation = relocation & 0xffff;
+			/* RELA must has 0 at relocation field. */
+			hvalue = relocation;
+	    		COPY_UNALIGNED_WORD (hvalue, *hlocation, align);
+			break;
+		case R_M32R_SDA16_RELA:
+		case R_M32R_LO16_RELA:
+	    		COPY_UNALIGNED_WORD (*location, value, align);
+                        relocation = relocation & 0xffff;
+			/* RELA must has 0 at relocation field. */
+			value += relocation;
+	    		COPY_UNALIGNED_WORD (value, *location, align);
+			break;
+		case R_M32R_24_RELA:
+	    		COPY_UNALIGNED_WORD (*location, value, align);
+                        relocation = relocation & 0xffffff;
+			/* RELA must has 0 at relocation field. */
+			value += relocation;
+	    		COPY_UNALIGNED_WORD (value, *location, align);
+			break;
+		case R_M32R_18_PCREL_RELA:
+	  		relocation = (relocation - (Elf32_Addr) location);
+			if (relocation < -0x20000 || 0x1fffc < relocation)
+				{
+					printk(KERN_ERR "module %s: relocation overflow: %u\n",
+					me->name, relocation);
+					return -ENOEXEC;
+				}
+	    		COPY_UNALIGNED_WORD (*location, value, align);
+			if (value & 0xffff)
+				{
+					/* RELA must has 0 at relocation field. */
+					printk(KERN_ERR "module %s: illegal relocation field: %u\n",
+					me->name, value);
+					return -ENOEXEC;
+				}
+                        relocation = (relocation >> 2) & 0xffff;
+			value += relocation;
+	    		COPY_UNALIGNED_WORD (value, *location, align);
+			break;
+		case R_M32R_10_PCREL_RELA:
+			hlocation = (unsigned short *)location;
+	  		relocation = (relocation - (Elf32_Addr) location);
+	    		COPY_UNALIGNED_HWORD (*hlocation, hvalue, align);
+			svalue = (int)hvalue;
+			svalue = (signed char)svalue << 2;
+			relocation += svalue;
+                        relocation = (relocation >> 2) & 0xff;
+			hvalue = hvalue & 0xff00;
+			hvalue += relocation;
+	    		COPY_UNALIGNED_HWORD (hvalue, *hlocation, align);
+			break;
+		case R_M32R_26_PCREL_RELA:
+	  		relocation = (relocation - (Elf32_Addr) location);
+			if (relocation < -0x2000000 || 0x1fffffc < relocation)
+				{
+					printk(KERN_ERR "module %s: relocation overflow: %u\n",
+					me->name, relocation);
+					return -ENOEXEC;
+				}
+	    		COPY_UNALIGNED_WORD (*location, value, align);
+			if (value & 0xffffff)
+				{
+					/* RELA must has 0 at relocation field. */
+					printk(KERN_ERR "module %s: illegal relocation field: %u\n",
+					me->name, value);
+					return -ENOEXEC;
+				}
+                        relocation = (relocation >> 2) & 0xffffff;
+			value += relocation;
+	    		COPY_UNALIGNED_WORD (value, *location, align);
+			break;
+		default:
+			printk(KERN_ERR "module %s: Unknown relocation: %u\n",
+			       me->name, ELF32_R_TYPE(rel[i].r_info));
+			return -ENOEXEC;
+		}
+	}
+	return 0;
+}
+
+int apply_relocate(Elf32_Shdr *sechdrs,
+		       const char *strtab,
+		       unsigned int symindex,
+		       unsigned int relsec,
+		       struct module *me)
+{
+#if 0
+	printk(KERN_ERR "module %s: REL RELOCATION unsupported\n",
+	       me->name);
+	return -ENOEXEC;
+#endif
+	return 0;
+
+}
+
+int module_finalize(const Elf_Ehdr *hdr,
+		    const Elf_Shdr *sechdrs,
+		    struct module *me)
+{
+	return 0;
+}
+
+void module_arch_cleanup(struct module *mod)
+{
+}
diff -ruN linux-2.6.7.org/arch/m32r/kernel/process.c linux-2.6.7/arch/m32r/kernel/process.c
--- linux-2.6.7.org/arch/m32r/kernel/process.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/process.c	2004-07-15 13:43:14.000000000 +0900
@@ -0,0 +1,357 @@
+/* 
+ *  linux/arch/m32r/kernel/process.c
+ *    orig : sh
+ *
+ *  Copyright (c) 2001, 2002  Hiroyuki Kondo, Hirokazu Takata, 
+ *                            Hitoshi Yamamoto
+ *  Taken from sh version.
+ *    Copyright (C) 1995  Linus Torvalds
+ *    SuperH version:  Copyright (C) 1999, 2000  Niibe Yutaka & Kaz Kojima
+ */
+
+#undef DEBUG_PROCESS
+#ifdef DEBUG_PROCESS
+#define DPRINTK(fmt, args...)  printk("%s:%d:%s: " fmt, __FILE__, __LINE__, \
+  __FUNCTION__, ##args)
+#else
+#define DPRINTK(fmt, args...)
+#endif
+
+/*
+ * This file handles the architecture-dependent parts of process handling..
+ */
+
+#include <linux/fs.h>
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/ptrace.h>
+#include <linux/unistd.h>
+#include <linux/slab.h>
+
+#include <asm/hardirq.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/mmu_context.h>
+#include <asm/elf.h>
+#include <asm/m32r.h>
+
+#include <linux/err.h>
+
+static int hlt_counter=0;
+
+/*
+ * Return saved PC of a blocked thread.
+ */
+unsigned long thread_saved_pc(struct task_struct *tsk)
+{
+	return tsk->thread.lr;
+}
+
+/*
+ * Powermanagement idle function, if any..
+ */
+void (*pm_idle)(void) = NULL;
+
+void disable_hlt(void)
+{
+	hlt_counter++;
+}
+
+EXPORT_SYMBOL(disable_hlt);
+
+void enable_hlt(void)
+{
+	hlt_counter--;
+}
+
+EXPORT_SYMBOL(enable_hlt);
+
+/*
+ * We use this is we don't have any better
+ * idle routine..
+ */ 
+void default_idle(void)
+{
+	/* M32R_FIXME: Please use "cpu_sleep" mode.  */
+	cpu_relax();
+}
+
+/*
+ * On SMP it's slightly faster (but much more power-consuming!)
+ * to poll the ->work.need_resched flag instead of waiting for the
+ * cross-CPU IPI to arrive. Use this option with caution.
+ */
+static void poll_idle (void)
+{
+	/* M32R_FIXME */
+	cpu_relax();
+}
+
+/* 
+ * The idle thread. There's no useful work to be
+ * done, so just try to conserve power and have a
+ * low exit latency (ie sit in a loop waiting for 
+ * somebody to say that they'd like to reschedule)
+ */
+void cpu_idle (void)
+{
+	/* endless idle loop with no priority at all */
+	while (1) {
+		while (!need_resched()) {
+			void (*idle)(void) = pm_idle;
+
+			if (!idle)
+				idle = default_idle;
+
+			idle();
+		}
+		schedule();
+	}
+}
+
+void machine_restart(char *__unused)
+{
+	printk("Please push reset button!\n");
+	while (1)
+		cpu_relax();
+}
+
+EXPORT_SYMBOL(machine_restart);
+
+void machine_halt(void)
+{
+	printk("Please push reset button!\n");
+	while (1)
+		cpu_relax();
+}
+
+EXPORT_SYMBOL(machine_halt);
+
+void machine_power_off(void)
+{
+	/* M32R_FIXME */
+}
+
+EXPORT_SYMBOL(machine_power_off);
+
+static int __init idle_setup (char *str)
+{
+	if (!strncmp(str, "poll", 4)) {
+		printk("using poll in idle threads.\n");
+		pm_idle = poll_idle;
+	} else if (!strncmp(str, "sleep", 4)) {
+		printk("using sleep in idle threads.\n");
+		pm_idle = default_idle;
+	}
+
+	return 1;
+}
+
+__setup("idle=", idle_setup);
+
+void show_regs(struct pt_regs * regs)
+{
+	printk("\n");
+	printk("BPC[%08lx]:PSW[%08lx]:LR [%08lx]:FP [%08lx]\n", \
+	  regs->bpc, regs->psw, regs->lr, regs->fp);
+	printk("BBPC[%08lx]:BBPSW[%08lx]:SPU[%08lx]:SPI[%08lx]\n", \
+	  regs->bbpc, regs->bbpsw, regs->spu, regs->spi);
+	printk("R0 [%08lx]:R1 [%08lx]:R2 [%08lx]:R3 [%08lx]\n", \
+	  regs->r0, regs->r1, regs->r2, regs->r3);
+	printk("R4 [%08lx]:R5 [%08lx]:R6 [%08lx]:R7 [%08lx]\n", \
+	  regs->r4, regs->r5, regs->r6, regs->r7);
+	printk("R8 [%08lx]:R9 [%08lx]:R10[%08lx]:R11[%08lx]\n", \
+	  regs->r8, regs->r9, regs->r10, regs->r11);
+	printk("R12[%08lx]\n", \
+	  regs->r12);
+	
+#if defined(CONFIG_ISA_M32R2) && defined(CONFIG_ISA_DSP_LEVEL2)
+	printk("ACC0H[%08lx]:ACC0L[%08lx]\n", \
+	  regs->acc0h, regs->acc0l);
+	printk("ACC1H[%08lx]:ACC1L[%08lx]\n", \
+	  regs->acc1h, regs->acc1l);
+#elif defined(CONFIG_ISA_M32R2) || defined(CONFIG_ISA_M32R)
+	printk("ACCH[%08lx]:ACCL[%08lx]\n", \
+	  regs->acch, regs->accl);
+#else
+#error unknown isa configuration
+#endif
+}
+
+/*
+ * Create a kernel thread
+ */
+
+/*
+ * This is the mechanism for creating a new kernel thread.
+ *
+ * NOTE! Only a kernel-only process(ie the swapper or direct descendants
+ * who haven't done an "execve()") should use this: it will work within
+ * a system call from a "real" process, but the process memory space will
+ * not be free'd until both the parent and the child have exited.
+ */
+static void kernel_thread_helper(void *nouse, int (*fn)(void *), void *arg)
+{
+	fn(arg);
+	do_exit(-1);
+}
+
+int kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
+{
+	struct pt_regs regs;
+
+	memset(&regs, 0, sizeof (regs));
+	regs.r1 = (unsigned long)fn;
+	regs.r2 = (unsigned long)arg;
+
+	regs.bpc = (unsigned long)kernel_thread_helper;
+
+	regs.psw = M32R_PSW_BIE;
+
+	/* Ok, create the new process. */
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, 
+		NULL);
+}
+
+/*
+ * Free current thread data structures etc..
+ */
+void exit_thread(void)
+{
+	/* Nothing to do. */
+	DPRINTK("pid = %d\n", current->pid);
+}
+
+void flush_thread(void)
+{
+	DPRINTK("pid = %d\n", current->pid);
+	memset(&current->thread.debug_trap, 0, sizeof(struct debug_trap));
+}
+
+void release_thread(struct task_struct *dead_task)
+{
+	/* do nothing */
+	DPRINTK("pid = %d\n", dead_task->pid);
+}
+
+/* Fill in the fpu structure for a core dump.. */
+int dump_fpu(struct pt_regs *regs, elf_fpregset_t *fpu)
+{
+	return 0; /* Task didn't use the fpu at all. */
+}
+
+int copy_thread(int nr, unsigned long clone_flags, unsigned long spu,
+	unsigned long unused, struct task_struct *tsk, struct pt_regs *regs)
+{
+	struct pt_regs *childregs;
+	unsigned long sp = (unsigned long)tsk->thread_info + THREAD_SIZE;
+	extern void ret_from_fork(void);
+
+	tsk->set_child_tid = tsk->clear_child_tid = NULL;
+
+	/* Copy registers */
+	sp -= sizeof (struct pt_regs);
+	childregs = (struct pt_regs *)sp;
+	*childregs = *regs;
+
+	childregs->spu = spu;
+	childregs->r0 = 0;	/* Child gets zero as return value */
+	regs->r0 = tsk->pid;
+	tsk->thread.sp = (unsigned long)childregs;
+	tsk->thread.lr = (unsigned long)ret_from_fork;
+
+	return 0;
+}
+
+/*
+ * fill in the user structure for a core dump..
+ */
+void dump_thread(struct pt_regs * regs, struct user * dump)
+{
+	/* M32R_FIXME */
+}
+
+/*
+ * Capture the user space registers if the task is not running (in user space)
+ */
+int dump_task_regs(struct task_struct *tsk, elf_gregset_t *regs)
+{
+	/* M32R_FIXME */
+	return 1;
+}
+
+asmlinkage int sys_fork(unsigned long r0, unsigned long r1, unsigned long r2,
+	unsigned long r3, unsigned long r4, unsigned long r5, unsigned long r6,
+	struct pt_regs regs)
+{
+#ifdef CONFIG_MMU
+	return do_fork(SIGCHLD, regs.spu, &regs, 0, NULL, NULL);
+#else
+	return -EINVAL;
+#endif /* CONFIG_MMU */
+}
+
+asmlinkage int sys_clone(unsigned long clone_flags, unsigned long newsp,
+	unsigned long r2, unsigned long r3, unsigned long r4, unsigned long r5,
+	unsigned long r6, struct pt_regs regs)
+{
+	if (!newsp)
+		newsp = regs.spu;
+
+	return do_fork(clone_flags & ~CLONE_IDLETASK, newsp, &regs, 0, NULL,
+			NULL);
+}
+
+/*
+ * This is trivial, and on the face of it looks like it
+ * could equally well be done in user mode.
+ *
+ * Not so, for quite unobvious reasons - register pressure.
+ * In user mode vfork() cannot have a stack frame, and if
+ * done by calling the "clone()" system call directly, you
+ * do not have enough call-clobbered registers to hold all
+ * the information you need.
+ */
+asmlinkage int sys_vfork(unsigned long r0, unsigned long r1, unsigned long r2,
+	unsigned long r3, unsigned long r4, unsigned long r5, unsigned long r6,
+	struct pt_regs regs)
+{
+	return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, regs.spu, &regs, 0,
+			NULL, NULL);
+}
+
+/*
+ * sys_execve() executes a new program.
+ */
+asmlinkage int sys_execve(char __user *ufilename, char __user * __user *uargv, char __user * __user *uenvp, 
+  unsigned long r3, unsigned long r4, unsigned long r5, unsigned long r6, 
+  struct pt_regs regs)
+{
+	int error;
+	char *filename;
+	
+	filename = getname(ufilename);
+	error = PTR_ERR(filename);
+	if (IS_ERR(filename))
+		goto out;
+	
+	error = do_execve(filename, uargv, uenvp, &regs);
+	if (error == 0)
+		current->ptrace &= ~PT_DTRACE;
+	putname(filename);
+out:
+	return error;
+}
+
+/*
+ * These bracket the sleeping functions..
+ */
+#define first_sched	((unsigned long) scheduling_functions_start_here)
+#define last_sched	((unsigned long) scheduling_functions_end_here)
+
+unsigned long get_wchan(struct task_struct *p)
+{
+	/* M32R_FIXME */
+	return (0);
+}
+
diff -ruN linux-2.6.7.org/arch/m32r/kernel/ptrace.c linux-2.6.7/arch/m32r/kernel/ptrace.c
--- linux-2.6.7.org/arch/m32r/kernel/ptrace.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/ptrace.c	2004-07-15 13:43:14.000000000 +0900
@@ -0,0 +1,828 @@
+/* 
+ * linux/arch/sh/kernel/ptrace.c
+ *
+ * Copyright (C) 2002  Hirokazu Takata, Takeo Takahashi
+ *
+ * Original x86 implementation:
+ *	By Ross Biro 1/23/92
+ *	edited by Linus Torvalds
+ *
+ * Some code taken from sh version:
+ *   Copyright (C) 1999, 2000  Kaz Kojima & Niibe Yutaka
+ *
+ */
+
+/* $Id$ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+#include <linux/errno.h>
+#include <linux/ptrace.h>
+#include <linux/user.h>
+#include <linux/string.h>
+
+#include <asm/cacheflush.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <asm/pgtable.h>
+#include <asm/system.h>
+#include <asm/processor.h>
+#include <asm/mmu_context.h>
+
+#define DEBUG_PTRACE	0
+
+/*
+ * does not yet catch signals sent when the child dies.
+ * in exit.c or in signal.c.
+ */
+
+/*
+ * This routine will get a word off of the process kernel stack.
+ */
+static __inline__ unsigned long int get_stack_long(struct task_struct *task, 
+	int offset)
+{
+
+	unsigned char *stack;
+
+	stack = (unsigned char *)(task->thread_info) + THREAD_SIZE 
+		- sizeof(struct pt_regs);
+	stack += offset;
+
+	return *((unsigned long *)stack);
+}
+
+/*
+ * This routine will put a word on the process kernel stack.
+ */
+static __inline__ int put_stack_long(struct task_struct *task, int offset, 
+	unsigned long data)
+{
+	unsigned char *stack;
+
+	stack = (unsigned char *)(task->thread_info) + THREAD_SIZE 
+		- sizeof(struct pt_regs);
+	stack += offset;
+	*((unsigned long *)stack) = data;
+
+	return 0;
+}
+
+static int reg_offset[] = {
+	(4 * PT_R0), (4 * PT_R1), (4 * PT_R2), (4 * PT_R3),
+	(4 * PT_R4), (4 * PT_R5), (4 * PT_R6), (4 * PT_R7),
+	(4 * PT_R8), (4 * PT_R9), (4 * PT_R10), (4 * PT_R11),
+	(4 * PT_R12), (4 * PT_FP), (4 * PT_LR), (4 * PT_SPU),
+};
+
+static __inline__ int
+check_condition_bit(struct task_struct *child)
+{
+	return (int)((get_stack_long(child, (4 * PT_PSW)) >> 8) & 1);
+}
+
+static int
+check_condition_src(unsigned long op, unsigned long regno1, unsigned long regno2, struct task_struct *child)
+{
+	unsigned long reg1, reg2;
+
+	reg2 = get_stack_long(child, reg_offset[regno2]);
+
+	switch (op) {
+	case 0x0: /* BEQ */
+		reg1 = get_stack_long(child, reg_offset[regno1]);
+		return reg1 == reg2;
+	case 0x1: /* BNE */
+		reg1 = get_stack_long(child, reg_offset[regno1]);
+		return reg1 != reg2;
+	case 0x8: /* BEQZ */
+		return reg2 == 0;
+	case 0x9: /* BNEZ */
+		return reg2 != 0;
+	case 0xa: /* BLTZ */
+		return (int)reg2 < 0;
+	case 0xb: /* BGEZ */
+		return (int)reg2 >= 0;
+	case 0xc: /* BLEZ */
+		return (int)reg2 <= 0;
+	case 0xd: /* BGTZ */
+		return (int)reg2 > 0;
+	default:
+		/* never reached */
+		return 0;
+	}
+}
+
+static void
+compute_next_pc_for_16bit_insn(unsigned long insn, unsigned long pc, 
+	unsigned long *next_pc, struct task_struct *child)
+{
+	unsigned long op, op2, op3;
+	unsigned long disp;
+	unsigned long regno;
+	int parallel = 0;
+
+	if (insn & 0x00008000)
+		parallel = 1;
+	if (pc & 3)
+		insn &= 0x7fff;	/* right slot */
+	else
+		insn >>= 16;	/* left slot */
+	
+	op = (insn >> 12) & 0xf;
+	op2 = (insn >> 8) & 0xf;
+	op3 = (insn >> 4) & 0xf;
+
+	if (op == 0x7) {
+		switch (op2) {
+		case 0xd: /* BNC */
+		case 0x9: /* BNCL */
+			if (!check_condition_bit(child)) {
+				disp = (long)(insn << 24) >> 22;
+				*next_pc = (pc & ~0x3) + disp;
+				return;
+			}
+			break;
+		case 0x8: /* BCL */
+		case 0xc: /* BC */
+			if (check_condition_bit(child)) {
+				disp = (long)(insn << 24) >> 22;
+				*next_pc = (pc & ~0x3) + disp;
+				return;
+			}
+			break;
+		case 0xe: /* BL */
+		case 0xf: /* BRA */
+			disp = (long)(insn << 24) >> 22;
+			*next_pc = (pc & ~0x3) + disp;
+			return;
+			break;
+		}
+	} else if (op == 0x1) {
+		switch (op2) {
+		case 0x0:
+			if (op3 == 0xf) { /* TRAP */
+#if 1
+				/* pass through */
+#else
+ 				/* kernel space is not allowed as next_pc */
+				unsigned long evb;
+				unsigned long trapno;
+				trapno = insn & 0xf;
+				__asm__ __volatile__ (
+					"mvfc %0, cr5\n"
+		 			:"=r"(evb)
+		 			:
+				);
+				*next_pc = evb + (trapno << 2);
+				return;
+#endif
+			} else if (op3 == 0xd) { /* RTE */
+				*next_pc = get_stack_long(child, (4 * PT_BPC));
+				return;
+			}
+			break;
+		case 0xc: /* JC */
+			if (op3 == 0xc && check_condition_bit(child)) {
+				regno = insn & 0xf;
+				*next_pc = get_stack_long(child, reg_offset[regno]);
+				return;
+			}
+			break;
+		case 0xd: /* JNC */
+			if (op3 == 0xc && !check_condition_bit(child)) {
+				regno = insn & 0xf;
+				*next_pc = get_stack_long(child, reg_offset[regno]);
+				return;
+			}
+			break;
+		case 0xe: /* JL */
+		case 0xf: /* JMP */
+			if (op3 == 0xc) { /* JMP */
+				regno = insn & 0xf;
+				*next_pc = get_stack_long(child, reg_offset[regno]);
+				return;
+			}
+			break;
+		}
+	}
+	if (parallel)
+		*next_pc = pc + 4;
+	else
+		*next_pc = pc + 2;
+}
+
+static void
+compute_next_pc_for_32bit_insn(unsigned long insn, unsigned long pc, 
+	unsigned long *next_pc, struct task_struct *child)
+{
+	unsigned long op;
+	unsigned long op2;
+	unsigned long disp;
+	unsigned long regno1, regno2;
+
+	op = (insn >> 28) & 0xf;
+	if (op == 0xf) { 	/* branch 24-bit relative */
+		op2 = (insn >> 24) & 0xf;
+		switch (op2) {
+		case 0xd:	/* BNC */
+		case 0x9:	/* BNCL */
+			if (!check_condition_bit(child)) {
+				disp = (long)(insn << 8) >> 6;
+				*next_pc = (pc & ~0x3) + disp;
+				return;
+			}
+			break;
+		case 0x8:	/* BCL */
+		case 0xc:	/* BC */
+			if (check_condition_bit(child)) {
+				disp = (long)(insn << 8) >> 6;
+				*next_pc = (pc & ~0x3) + disp;
+				return;
+			}
+			break;
+		case 0xe:	/* BL */
+		case 0xf:	/* BRA */
+			disp = (long)(insn << 8) >> 6;
+			*next_pc = (pc & ~0x3) + disp;
+			return;
+		}
+	} else if (op == 0xb) { /* branch 16-bit relative */
+		op2 = (insn >> 20) & 0xf;
+		switch (op2) {
+		case 0x0: /* BEQ */
+		case 0x1: /* BNE */
+		case 0x8: /* BEQZ */
+		case 0x9: /* BNEZ */
+		case 0xa: /* BLTZ */
+		case 0xb: /* BGEZ */
+		case 0xc: /* BLEZ */
+		case 0xd: /* BGTZ */
+			regno1 = ((insn >> 24) & 0xf);
+			regno2 = ((insn >> 16) & 0xf);
+			if (check_condition_src(op2, regno1, regno2, child)) {
+				disp = (long)(insn << 16) >> 14;
+				*next_pc = (pc & ~0x3) + disp;
+				return;
+			}
+			break;
+		}
+	}
+	*next_pc = pc + 4;
+}
+
+static __inline__ void
+compute_next_pc(unsigned long insn, unsigned long pc, 
+	unsigned long *next_pc, struct task_struct *child)
+{
+	if (insn & 0x80000000)
+		compute_next_pc_for_32bit_insn(insn, pc, next_pc, child);
+	else
+		compute_next_pc_for_16bit_insn(insn, pc, next_pc, child);
+}
+
+static int 
+register_debug_trap(struct task_struct *child, unsigned long next_pc,
+	unsigned long next_insn, unsigned long *code)
+{
+	struct debug_trap *p = &child->thread.debug_trap;
+	unsigned long addr = next_pc & ~3;
+
+	if (p->nr_trap != 0) {
+		printk("kernel BUG at %s %d: p->nr_trap = %d\n",
+					__FILE__, __LINE__, p->nr_trap);
+		return -1;
+	}
+	p->addr = addr;
+	p->insn = next_insn;
+	p->nr_trap++;
+	if (next_pc & 3) {
+		*code = (next_insn & 0xffff0000) | 0x10f1;
+		/* xxx --> TRAP1 */
+	} else {
+		if ((next_insn & 0x80000000) || (next_insn & 0x8000)) {
+			*code = 0x10f17000;
+			/* TRAP1 --> NOP */
+		} else {
+			*code = (next_insn & 0xffff) | 0x10f10000;
+			/* TRAP1 --> xxx */
+		}
+	}
+	return 0;
+}
+
+int withdraw_debug_trap_for_signal(struct task_struct *child)
+{
+	struct debug_trap *p = &child->thread.debug_trap;
+	int nr_trap = p->nr_trap;
+
+	if (nr_trap) {
+		access_process_vm(child, p->addr, &p->insn, sizeof(p->insn), 1);
+		p->nr_trap = 0;
+		p->addr = 0;
+		p->insn = 0;
+	}
+	return nr_trap;
+}
+
+static int 
+unregister_debug_trap(struct task_struct *child, unsigned long addr, unsigned long *code)
+{
+	struct debug_trap *p = &child->thread.debug_trap;
+	
+	if (p->nr_trap != 1 || p->addr != addr) {
+		/* The trap may be requested from debugger.
+		 * ptrace should do nothing in this case.
+		 */
+		return 0;
+	}
+	*code = p->insn;
+	p->insn = 0;
+	p->addr = 0;
+	p->nr_trap--;
+	return 1;
+}
+
+static void
+unregister_all_debug_traps(struct task_struct *child)
+{
+	struct debug_trap *p = &child->thread.debug_trap;
+	
+	if (p->nr_trap) {
+		access_process_vm(child, p->addr, &p->insn, sizeof(p->insn), 1);
+		p->addr = 0;
+		p->insn = 0;
+		p->nr_trap = 0;
+	}
+}
+
+static void
+invalidate_cache(void)
+{
+#if defined(CONFIG_CHIP_M32700) || defined(CONFIG_CHIP_OPSP)
+
+	_flush_cache_copyback_all();
+
+#else	/* ! CONFIG_CHIP_M32700 */
+
+	/* Invalidate cache */
+	__asm__ __volatile__ (
+                "ldi    r0, #-1					\n\t" 
+                "ldi    r1, #0					\n\t"
+                "stb    r1, @r0		; cache off		\n\t" 
+                ";						\n\t"
+                "ldi    r0, #-2					\n\t"
+                "ldi    r1, #1					\n\t"
+                "stb    r1, @r0		; cache invalidate	\n\t"  
+                ".fillinsn					\n"  
+                "0:						\n\t"
+                "ldb    r1, @r0		; invalidate check	\n\t"
+                "bnez   r1, 0b					\n\t"
+                ";						\n\t"
+                "ldi    r0, #-1					\n\t"
+                "ldi    r1, #1					\n\t" 
+                "stb    r1, @r0		; cache on		\n\t"
+		: : : "r0", "r1", "memory"
+	);
+	/* FIXME: copying-back d-cache and invalidating i-cache are needed.
+	 */
+#endif	/* CONFIG_CHIP_M32700 */
+}
+
+/* Embed a debug trap (TRAP1) code */
+static int
+embed_debug_trap(struct task_struct *child, unsigned long next_pc)
+{
+	unsigned long next_insn, code;
+	unsigned long addr = next_pc & ~3;
+
+	if (access_process_vm(child, addr, &next_insn, sizeof(next_insn), 0)
+	    != sizeof(next_insn)) {
+		return -1; /* error */
+	}
+
+	/* Set a trap code. */
+	if (register_debug_trap(child, next_pc, next_insn, &code)) {
+		return -1; /* error */
+	}
+	if (access_process_vm(child, addr, &code, sizeof(code), 1)
+	    != sizeof(code)) {
+		return -1; /* error */
+	}
+	return 0; /* success */
+}
+
+void
+embed_debug_trap_for_signal(struct task_struct *child)
+{
+	unsigned long next_pc;
+	unsigned long pc, insn;
+	int ret;
+
+	pc = get_stack_long(child, (4 * PT_BPC));
+	ret = access_process_vm(child, pc&~3, &insn, sizeof(insn), 0);
+	if (ret != sizeof(insn)) {
+		printk("kernel BUG at %s %d: access_process_vm returns %d\n",
+					__FILE__, __LINE__, ret);
+		return;
+	}
+	compute_next_pc(insn, pc, &next_pc, child);
+	if (next_pc & 0x80000000) {
+		printk("kernel BUG at %s %d: next_pc = 0x%08x\n",
+				__FILE__, __LINE__, (int)next_pc);
+		return;
+	}
+	if (embed_debug_trap(child, next_pc)) {
+		printk("kernel BUG at %s %d: embed_debug_trap error\n",
+					__FILE__, __LINE__);
+		return;
+	}
+	invalidate_cache();
+}
+
+void
+withdraw_debug_trap(struct pt_regs *regs)
+{
+	unsigned long addr;
+	unsigned long code;
+
+ 	addr = (regs->bpc - 2) & ~3;
+	regs->bpc -= 2;
+	if (unregister_debug_trap(current, addr, &code)) {
+	    access_process_vm(current, addr, &code, sizeof(code), 1);
+	    invalidate_cache();
+	}
+}
+
+
+/*
+ * Called by kernel/ptrace.c when detaching..
+ *
+ * Make sure single step bits etc are not set.
+ */
+void ptrace_disable(struct task_struct *child)
+{
+	/* nothing to do.. */
+}
+
+static void
+init_debug_traps(struct task_struct *child)
+{
+	struct debug_trap *p = &child->thread.debug_trap;
+	p->nr_trap = 0;
+	p->addr = 0;
+	p->insn = 0;
+}
+
+asmlinkage int sys_ptrace(long request, long pid, long addr, long data)
+{
+	struct task_struct *child;
+	int ret;
+#ifndef NO_FPU
+	struct user * dummy = NULL;
+#endif
+
+	lock_kernel();
+	ret = -EPERM;
+	if (request == PTRACE_TRACEME) {
+		/* are we already being traced? */
+		if (current->ptrace & PT_PTRACED)
+			goto out;
+		/* set the ptrace bit in the process flags. */
+		current->ptrace |= PT_PTRACED;
+		ret = 0;
+		goto out;
+	}
+	ret = -ESRCH;
+	read_lock(&tasklist_lock);
+	child = find_task_by_pid(pid);
+	if (child)
+		get_task_struct(child);
+	read_unlock(&tasklist_lock);
+	if (!child)
+		goto out;
+
+	ret = -EPERM;
+	if (pid == 1)		/* you may not mess with init */
+		goto out;
+
+	if (request == PTRACE_ATTACH) {
+#if (DEBUG_PTRACE > 1)
+printk("ptrace: PTRACE_ATTACH: child:%08lx\n", (unsigned long)child);
+#endif
+		ret = ptrace_attach(child);
+		if (ret == 0)
+			init_debug_traps(child);
+		goto out_tsk;
+	}
+
+	ret = ptrace_check_attach(child, request == PTRACE_KILL);
+	if (ret < 0)
+		goto out_tsk;
+
+	switch (request) {
+	/* when I and D space are separate, these will need to be fixed. */
+	case PTRACE_PEEKTEXT: /* read word at location addr. */ 
+	case PTRACE_PEEKDATA: {
+		unsigned long tmp;
+		int copied;
+
+#if (DEBUG_PTRACE > 1)
+printk("ptrace: PTRACE_PEEKTEXT/PEEKDATA: child:%08lx, addr:%08lx\n", 
+	(unsigned long)child, addr);
+#endif
+		copied = access_process_vm(child, addr, &tmp, sizeof(tmp), 0);
+		ret = -EIO;
+		if (copied != sizeof(tmp))
+			break;
+		ret = put_user(tmp,(unsigned long __user *) data);
+		break;
+	}
+
+	/* read the word at location addr in the USER area. */
+	case PTRACE_PEEKUSR: {
+		unsigned long tmp;
+
+#if DEBUG_PTRACE
+printk("ptrace: PTRACE_PEEKUSER: child:%08lx, addr:%08lx\n", 
+	(unsigned long)child, addr);
+#endif
+		ret = -EIO;
+		if ((addr & 3) || addr < 0 || 
+		    addr > sizeof(struct user) - 3)
+			break;
+
+		switch (addr) {
+		case (4 * PT_BPC):
+			addr = (4 * PT_BBPC);
+			break;
+		case (4 * PT_EVB): 
+			__asm__ __volatile__ (
+				"mvfc %0, cr5\n"
+		 		:"=r"(tmp)
+		 		:
+			);
+			ret = put_user(tmp, (unsigned long __user *)data);
+			goto out_tsk;
+			break;
+		case (4 * PT_CBR): {
+				unsigned long psw;
+				psw = get_stack_long(child, (4 * PT_PSW));
+				tmp = ((psw >> 8) & 1);
+				ret = put_user(tmp, (unsigned long __user *)data);
+				goto out_tsk;
+			}
+			break;
+		case (4 * PT_PSW): {
+				unsigned long psw, bbpsw;
+				psw = get_stack_long(child, (4 * PT_PSW));
+				bbpsw = get_stack_long(child, (4 * PT_BBPSW));
+				tmp = ((psw >> 8) & 0xff) | ((bbpsw & 0xff) << 8);
+				ret = put_user(tmp, (unsigned long __user *)data);
+				goto out_tsk;
+			}
+			break;
+		case (4 * PT_PC): {
+				unsigned long pc;
+				pc = get_stack_long(child, (4 * PT_BPC));
+				ret = put_user(pc, (unsigned long __user *)data);
+				goto out_tsk;
+			}
+			break;
+		}
+
+		if (addr < sizeof(struct pt_regs))
+			tmp = get_stack_long(child, addr);
+#ifndef NO_FPU
+		else if (addr >= (long) &dummy->fpu &&
+			 addr < (long) &dummy->u_fpvalid) {
+			if (!child->used_math) {
+				if (addr == (long)&dummy->fpu.fpscr)
+					tmp = FPSCR_INIT;
+				else
+					tmp = 0;
+			} else
+				tmp = ((long *)&child->thread.fpu)
+					[(addr - (long)&dummy->fpu) >> 2];
+		} else if (addr == (long) &dummy->u_fpvalid)
+			tmp = child->used_math;
+#endif /* not NO_FPU */
+		else
+			tmp = 0;
+		ret = put_user(tmp, (unsigned long __user *)data);
+		break;
+	}
+
+	/* when I and D space are separate, this will have to be fixed. */
+	case PTRACE_POKETEXT: /* write the word at location addr. */
+	case PTRACE_POKEDATA:
+#if DEBUG_PTRACE
+printk("ptrace: PTRACE_POKETEXT/POKEDATA: child:%08lx, addr:%08lx, data:%08lx\n", 
+	(unsigned long)child, addr, data);
+#endif
+		ret = -EIO;
+		if (access_process_vm(child, addr, &data, sizeof(data), 1) 
+		    != sizeof(data)) {
+			break;
+		}
+		ret = 0;
+		if (request == PTRACE_POKETEXT) {
+			invalidate_cache();
+		}
+		break;
+
+	case PTRACE_POKEUSR: /* write the word at location addr in the USER area */
+#if DEBUG_PTRACE
+printk("ptrace: PTRACE_POKEUSR: child:%08lx, addr:%08lx, data:%08lx\n", 
+	(unsigned long)child, addr, data);
+#endif
+		ret = -EIO;
+		if ((addr & 3) || addr < 0 || 
+		    addr > sizeof(struct user) - 3)
+			break;
+
+		switch (addr) {
+		case (4 * PT_EVB): 
+		case (4 * PT_BPC):
+		case (4 * PT_SPI):
+			/* We don't allow to modify evb. */
+			ret = 0;
+			goto out_tsk;
+			break;
+		case (4 * PT_PSW):
+		case (4 * PT_CBR): {
+			/* We allow to modify only cbr in psw */
+			unsigned long psw;
+			psw = get_stack_long(child, (4 * PT_PSW));
+			psw = (psw & ~0x100) | ((data & 1) << 8);
+			ret = put_stack_long(child, (4 * PT_PSW), psw);
+			goto out_tsk;
+			}
+			break;
+		case (4 * PT_PC):
+			addr = (4 * PT_BPC);
+			data &= ~1;
+			break;
+		}
+
+		if (addr < sizeof(struct pt_regs))
+			ret = put_stack_long(child, addr, data);
+#ifndef NO_FPU
+		else if (addr >= (long) &dummy->fpu &&
+			 addr < (long) &dummy->u_fpvalid) {
+			child->used_math = 1;
+			((long *)&child->thread.fpu)
+				[(addr - (long)&dummy->fpu) >> 2] = data;
+			ret = 0;
+		} else if (addr == (long) &dummy->u_fpvalid) {
+			child->used_math = data?1:0;
+			ret = 0;
+		}
+#endif /* not NO_FPU */
+		break;
+
+	case PTRACE_SYSCALL: /* continue and stop at next (return from) syscall */
+	case PTRACE_CONT: { /* restart after signal. */
+#if DEBUG_PTRACE
+printk("ptrace: PTRACE_SYSCALL/CONT: child:%08lx, data:%08lx\n", 
+	(unsigned long)child, data);
+#endif
+		ret = -EIO;
+		if ((unsigned long) data > _NSIG)
+			break;
+		if (request == PTRACE_SYSCALL)
+			set_tsk_thread_flag(child, TIF_SYSCALL_TRACE);
+		else
+			clear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);
+		child->exit_code = data;
+		wake_up_process(child);
+		ret = 0;
+		break;
+	}
+
+/*
+ * make the child exit.  Best I can do is send it a sigkill. 
+ * perhaps it should be put in the status that it wants to 
+ * exit.
+ */
+	case PTRACE_KILL: {
+#if DEBUG_PTRACE
+printk("ptrace: PTRACE_KILL: child:%08lx\n", (unsigned long)child);
+#endif
+		ret = 0;
+		unregister_all_debug_traps(child);
+		invalidate_cache();
+		if (child->state == TASK_ZOMBIE)	/* already dead */
+			break;
+		child->exit_code = SIGKILL;
+		wake_up_process(child);
+		break;
+	}
+
+	case PTRACE_SINGLESTEP: {  /* set the trap flag. */
+		unsigned long next_pc;
+		unsigned long pc, insn;
+
+		ret = -EIO;
+		if ((unsigned long) data > _NSIG)
+			break;
+		clear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);
+		if ((child->ptrace & PT_DTRACE) == 0) {
+			/* Spurious delayed TF traps may occur */
+			child->ptrace |= PT_DTRACE;
+		}
+
+		/* Compute next pc.  */
+		pc = get_stack_long(child, (4 * PT_BPC));
+
+#if DEBUG_PTRACE
+printk("ptrace: PTRACE_SINGLESTEP: child:%08lx, pc:%08lx, ", 
+	(unsigned long)child, pc);
+#endif
+		if (access_process_vm(child, pc&~3, &insn, sizeof(insn), 0) != sizeof(insn))
+			break;
+ 
+#if DEBUG_PTRACE
+printk("(pc&~3):%08lx, insn:%08lx, ", (pc & ~3), insn);
+#endif
+
+		compute_next_pc(insn, pc, &next_pc, child);
+#if DEBUG_PTRACE
+printk("nextpc:%08lx\n", next_pc);
+#endif
+		if (next_pc & 0x80000000)
+			break;
+
+		if (embed_debug_trap(child, next_pc)) 
+			break;
+
+		invalidate_cache();
+		child->exit_code = data;
+		/* give it a chance to run. */
+		wake_up_process(child);
+		ret = 0;
+		break;
+	}
+
+	case PTRACE_DETACH: /* detach a process that was attached. */
+#if DEBUG_PTRACE
+printk("ptrace: PTRACE_DETACH: child:%08lx, data:%08lx\n",
+	(unsigned long)child, data);
+#endif
+		ret = 0;
+		ret = ptrace_detach(child, data);
+		break;
+
+	case PTRACE_SETOPTIONS: {
+#if DEBUG_PTRACE
+printk("ptrace: PTRACE_SETOPTIONS:\n");
+#endif
+		if (data & PTRACE_O_TRACESYSGOOD)
+			child->ptrace |= PT_TRACESYSGOOD;
+		else
+			child->ptrace &= ~PT_TRACESYSGOOD;
+		ret = 0;
+		break;
+	}
+
+	default:
+		ret = -EIO;
+		break;
+	}
+out_tsk:
+	put_task_struct(child);
+out:
+	unlock_kernel();
+
+	return ret;
+}
+
+/* notification of system call entry/exit
+ * - triggered by current->work.syscall_trace
+ */
+void do_syscall_trace(void)
+{
+	if (!test_thread_flag(TIF_SYSCALL_TRACE))
+		return;
+	if (!(current->ptrace & PT_PTRACED))
+		return;
+	/* the 0x80 provides a way for the tracing parent to distinguish
+	   between a syscall stop and SIGTRAP delivery */
+	ptrace_notify(SIGTRAP | ((current->ptrace & PT_TRACESYSGOOD)
+				 ? 0x80 : 0));
+
+	/*
+	 * this isn't the same as continuing with a signal, but it will do
+	 * for normal use.  strace only continues with a signal if the
+	 * stopping signal is not SIGTRAP.  -brl
+	 */
+	if (current->exit_code) {
+		send_sig(current->exit_code, current, 1);
+		current->exit_code = 0;
+	}
+}
+
diff -ruN linux-2.6.7.org/arch/m32r/kernel/semaphore.c linux-2.6.7/arch/m32r/kernel/semaphore.c
--- linux-2.6.7.org/arch/m32r/kernel/semaphore.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/semaphore.c	2004-05-19 18:53:08.000000000 +0900
@@ -0,0 +1,186 @@
+/*
+ *  linux/arch/m32r/semaphore.c
+ *    orig : i386 2.6.4
+ *  
+ *  M32R semaphore implementation.
+ *  
+ *	Copyright (c) 2002 - 2004 Hitoshi Yamamoto
+ */
+
+/*
+ * i386 semaphore implementation.
+ *
+ * (C) Copyright 1999 Linus Torvalds
+ *
+ * Portions Copyright 1999 Red Hat, Inc.
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ * rw semaphores implemented November 1999 by Benjamin LaHaise <bcrl@redhat.com>
+ */
+#include <linux/config.h>
+#include <linux/sched.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <asm/semaphore.h>
+
+/*
+ * Semaphores are implemented using a two-way counter:
+ * The "count" variable is decremented for each process
+ * that tries to acquire the semaphore, while the "sleeping"
+ * variable is a count of such acquires.
+ *
+ * Notably, the inline "up()" and "down()" functions can
+ * efficiently test if they need to do any extra work (up
+ * needs to do something only if count was negative before
+ * the increment operation.
+ *
+ * "sleeping" and the contention routine ordering is protected
+ * by the spinlock in the semaphore's waitqueue head.
+ *
+ * Note that these functions are only called when there is
+ * contention on the lock, and as such all this is the
+ * "non-critical" part of the whole semaphore business. The
+ * critical part is the inline stuff in <asm/semaphore.h>
+ * where we want to avoid any extra jumps and calls.
+ */
+
+/*
+ * Logic:
+ *  - only on a boundary condition do we need to care. When we go
+ *    from a negative count to a non-negative, we wake people up.
+ *  - when we go from a non-negative count to a negative do we
+ *    (a) synchronize with the "sleeper" count and (b) make sure
+ *    that we're on the wakeup list before we synchronize so that
+ *    we cannot lose wakeup events.
+ */
+
+asmlinkage void __up(struct semaphore *sem)
+{
+	wake_up(&sem->wait);
+}
+
+asmlinkage void __sched __down(struct semaphore * sem)
+{
+	struct task_struct *tsk = current;
+	DECLARE_WAITQUEUE(wait, tsk);
+	unsigned long flags;
+
+	tsk->state = TASK_UNINTERRUPTIBLE;
+	spin_lock_irqsave(&sem->wait.lock, flags);
+	add_wait_queue_exclusive_locked(&sem->wait, &wait);
+
+	sem->sleepers++;
+	for (;;) {
+		int sleepers = sem->sleepers;
+
+		/*
+		 * Add "everybody else" into it. They aren't
+		 * playing, because we own the spinlock in
+		 * the wait_queue_head.
+		 */
+		if (!atomic_add_negative(sleepers - 1, &sem->count)) {
+			sem->sleepers = 0;
+			break;
+		}
+		sem->sleepers = 1;	/* us - see -1 above */
+		spin_unlock_irqrestore(&sem->wait.lock, flags);
+
+		schedule();
+
+		spin_lock_irqsave(&sem->wait.lock, flags);
+		tsk->state = TASK_UNINTERRUPTIBLE;
+	}
+	remove_wait_queue_locked(&sem->wait, &wait);
+	wake_up_locked(&sem->wait);
+	spin_unlock_irqrestore(&sem->wait.lock, flags);
+	tsk->state = TASK_RUNNING;
+}
+
+asmlinkage int __sched __down_interruptible(struct semaphore * sem)
+{
+	int retval = 0;
+	struct task_struct *tsk = current;
+	DECLARE_WAITQUEUE(wait, tsk);
+	unsigned long flags;
+
+	tsk->state = TASK_INTERRUPTIBLE;
+	spin_lock_irqsave(&sem->wait.lock, flags);
+	add_wait_queue_exclusive_locked(&sem->wait, &wait);
+
+	sem->sleepers++;
+	for (;;) {
+		int sleepers = sem->sleepers;
+
+		/*
+		 * With signals pending, this turns into
+		 * the trylock failure case - we won't be
+		 * sleeping, and we* can't get the lock as
+		 * it has contention. Just correct the count
+		 * and exit.
+		 */
+		if (signal_pending(current)) {
+			retval = -EINTR;
+			sem->sleepers = 0;
+			atomic_add(sleepers, &sem->count);
+			break;
+		}
+
+		/*
+		 * Add "everybody else" into it. They aren't
+		 * playing, because we own the spinlock in
+		 * wait_queue_head. The "-1" is because we're
+		 * still hoping to get the semaphore.
+		 */
+		if (!atomic_add_negative(sleepers - 1, &sem->count)) {
+			sem->sleepers = 0;
+			break;
+		}
+		sem->sleepers = 1;	/* us - see -1 above */
+		spin_unlock_irqrestore(&sem->wait.lock, flags);
+
+		schedule();
+
+		spin_lock_irqsave(&sem->wait.lock, flags);
+		tsk->state = TASK_INTERRUPTIBLE;
+	}
+	remove_wait_queue_locked(&sem->wait, &wait);
+	wake_up_locked(&sem->wait);
+	spin_unlock_irqrestore(&sem->wait.lock, flags);
+
+	tsk->state = TASK_RUNNING;
+	return retval;
+}
+
+/*
+ * Trylock failed - make sure we correct for
+ * having decremented the count.
+ *
+ * We could have done the trylock with a
+ * single "cmpxchg" without failure cases,
+ * but then it wouldn't work on a 386.
+ */
+asmlinkage int __down_trylock(struct semaphore * sem)
+{
+	int sleepers;
+	unsigned long flags;
+
+	spin_lock_irqsave(&sem->wait.lock, flags);
+	sleepers = sem->sleepers + 1;
+	sem->sleepers = 0;
+
+	/*
+	 * Add "everybody else" and us into it. They aren't
+	 * playing, because we own the spinlock in the
+	 * wait_queue_head.
+	 */
+	if (!atomic_add_negative(sleepers, &sem->count)) {
+		wake_up_locked(&sem->wait);
+	}
+
+	spin_unlock_irqrestore(&sem->wait.lock, flags);
+	return 1;
+}
diff -ruN linux-2.6.7.org/arch/m32r/kernel/setup.c linux-2.6.7/arch/m32r/kernel/setup.c
--- linux-2.6.7.org/arch/m32r/kernel/setup.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/setup.c	2004-08-04 10:55:09.000000000 +0900
@@ -0,0 +1,404 @@
+/*  
+ *  linux/arch/m32r/kernel/setup.c
+ *  
+ *  Setup routines for MITSUBISHI M32R
+ *  
+ *  Copyright (c) 2001, 2002  Hiroyuki Kondo, Hirokazu Takata, 
+ *                            Hitoshi Yamamoto
+ */
+
+/* $Id$ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/stddef.h>
+#include <linux/fs.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+#include <linux/console.h>
+#include <linux/initrd.h>
+#include <linux/major.h>
+#include <linux/root_dev.h>
+#include <linux/seq_file.h>
+#include <linux/timex.h>
+#include <linux/tty.h>
+#include <asm/processor.h>
+#include <asm/pgtable.h>
+#include <asm/io.h>
+#include <asm/mmu_context.h>
+#include <asm/m32r.h>
+#include <asm/setup.h>
+#include <asm/sections.h>
+
+extern void init_IRQ(void);
+#ifdef CONFIG_MMU
+extern void init_mmu(void);
+#endif
+
+#if defined(CONFIG_BLK_DEV_IDE) || defined(CONFIG_BLK_DEV_HD)	\
+	|| defined(CONFIG_BLK_DEV_IDE_MODULE)			\
+	|| defined(CONFIG_BLK_DEV_HD_MODULE)
+struct drive_info_struct { char dummy[32]; } drive_info;
+#endif
+
+extern char _end[];
+
+/*
+ * Machine setup..
+ */
+struct cpuinfo_m32r boot_cpu_data;
+
+#ifdef CONFIG_BLK_DEV_RAM
+extern int rd_doload;	/* 1 = load ramdisk, 0 = don't load */
+extern int rd_prompt;	/* 1 = prompt for ramdisk, 0 = don't prompt */
+extern int rd_image_start;  /* starting block # of image */
+#endif
+
+#if defined(CONFIG_VGA_CONSOLE)
+struct screen_info screen_info = {
+	.orig_video_lines      = 25,
+	.orig_video_cols       = 80,
+	.orig_video_mode       = 0,
+	.orig_video_ega_bx     = 0,
+	.orig_video_isVGA      = 1,
+	.orig_video_points     = 8
+};
+#endif
+
+extern int root_mountflags;
+
+static char command_line[COMMAND_LINE_SIZE] = { 0 };
+char saved_command_line[COMMAND_LINE_SIZE];
+
+static struct resource code_resource = { "Kernel code", 0x100000, 0 };
+static struct resource data_resource = { "Kernel data", 0, 0 };
+
+unsigned long memory_start;
+unsigned long memory_end;
+
+void __init setup_arch(char **);
+int get_cpuinfo(char *);
+
+static __inline__ void parse_mem_cmdline(char ** cmdline_p)
+{
+	char c = ' ';
+	char *to = command_line;
+	char *from = COMMAND_LINE;
+	int len = 0;
+	int usermem = 0;
+
+	/* Save unparsed command line copy for /proc/cmdline */
+	memcpy(saved_command_line, COMMAND_LINE, COMMAND_LINE_SIZE);
+	saved_command_line[COMMAND_LINE_SIZE-1] = '\0';
+
+	/*
+	 * Due to prefetching and similar mechanism the CPU sometimes
+	 * generates addresses beyond the end of memory.  We leave the size
+	 * of one cache line at the end of memory unused to make shure we
+	 * don't catch this type of bus errors.
+	 */
+	memory_start = (unsigned long)CONFIG_MEMORY_START+PAGE_OFFSET;
+	memory_end = memory_start+(unsigned long)CONFIG_MEMORY_SIZE;
+	memory_end -= 128;
+	memory_end &= PAGE_MASK;
+
+	for ( ; ; ) {
+		if (c == ' ' && !memcmp(from, "mem=", 4)) {
+			if (to != command_line)
+				to--;
+
+			{
+				unsigned long mem_size;
+
+				usermem = 1;
+				mem_size = memparse(from+4, &from);
+				memory_end = memory_start + mem_size;
+			}
+		}
+		c = *(from++);
+		if (!c)
+			break;
+
+		if (COMMAND_LINE_SIZE <= ++len)
+			break;
+
+		*(to++) = c;
+	}
+	*to = '\0';
+	*cmdline_p = command_line;
+	if (usermem)
+		printk(KERN_INFO "user-defined physical RAM map:\n");
+}
+
+#ifndef CONFIG_DISCONTIGMEM
+static unsigned long __init setup_memory(void)
+{
+	unsigned long start_pfn, max_low_pfn, bootmap_size;
+
+	start_pfn = PFN_UP( __pa(_end) );
+	max_low_pfn = PFN_DOWN( __pa(memory_end) );
+
+	/* 
+	 * Initialize the boot-time allocator (with low memory only):
+	 */
+	bootmap_size = init_bootmem_node(NODE_DATA(0), start_pfn,
+		CONFIG_MEMORY_START>>PAGE_SHIFT, max_low_pfn);
+
+	/*
+	 * Register fully available low RAM pages with the bootmem allocator.
+	 */
+	{
+		unsigned long curr_pfn;
+		unsigned long last_pfn;
+		unsigned long pages;
+
+		/*
+		 * We are rounding up the start address of usable memory:
+		 */
+		curr_pfn = PFN_UP(__pa(memory_start));
+
+		/*
+		 * ... and at the end of the usable range downwards:
+		 */
+		last_pfn = PFN_DOWN(__pa(memory_end));
+
+		if (last_pfn > max_low_pfn)
+			last_pfn = max_low_pfn;
+
+		pages = last_pfn - curr_pfn;
+		free_bootmem(PFN_PHYS(curr_pfn), PFN_PHYS(pages));
+	}
+
+	/*
+	 * Reserve the kernel text and
+	 * Reserve the bootmem bitmap. We do this in two steps (first step
+	 * was init_bootmem()), because this catches the (definitely buggy)
+	 * case of us accidentally initializing the bootmem allocator with
+	 * an invalid RAM area.
+	 */
+	reserve_bootmem(CONFIG_MEMORY_START + PAGE_SIZE, 
+		(PFN_PHYS(start_pfn) + bootmap_size + PAGE_SIZE - 1)
+		- CONFIG_MEMORY_START);
+
+	/*
+	 * reserve physical page 0 - it's a special BIOS page on many boxes,
+	 * enabling clean reboots, SMP operation, laptop functions.
+	 */
+	reserve_bootmem(CONFIG_MEMORY_START, PAGE_SIZE);
+
+	/* 
+	 * reserve memory hole
+	 */
+#ifdef CONFIG_MEMHOLE
+	reserve_bootmem(CONFIG_MEMHOLE_START, CONFIG_MEMHOLE_SIZE);
+#endif
+
+#ifdef CONFIG_BLK_DEV_INITRD
+	if (LOADER_TYPE && INITRD_START) {
+		if (INITRD_START + INITRD_SIZE <= (max_low_pfn << PAGE_SHIFT)) {
+			reserve_bootmem(INITRD_START, INITRD_SIZE);
+			initrd_start = INITRD_START ? 
+				INITRD_START + PAGE_OFFSET : 0;
+
+			initrd_end = initrd_start + INITRD_SIZE;
+			printk("initrd:start[%08lx],size[%08lx]\n", 
+				initrd_start, INITRD_SIZE);
+		} else {
+			printk("initrd extends beyond end of memory "
+				"(0x%08lx > 0x%08lx)\ndisabling initrd\n", 
+				INITRD_START + INITRD_SIZE, 
+				max_low_pfn << PAGE_SHIFT);
+
+			initrd_start = 0;
+		}
+	}
+#endif
+
+	return max_low_pfn;
+}
+#else	/* CONFIG_DISCONTIGMEM */
+extern unsigned long setup_memory(void);
+#endif	/* CONFIG_DISCONTIGMEM */
+
+#define M32R_PCC_PCATCR	0x00ef7014	/* will move to m32r.h */
+
+void __init setup_arch(char **cmdline_p)
+{
+	ROOT_DEV = old_decode_dev(ORIG_ROOT_DEV);
+
+	boot_cpu_data.cpu_clock = M32R_CPUCLK;
+	boot_cpu_data.bus_clock = M32R_BUSCLK;
+	boot_cpu_data.timer_divide = M32R_TIMER_DIVIDE;
+
+#ifdef CONFIG_BLK_DEV_RAM
+	rd_image_start = RAMDISK_FLAGS & RAMDISK_IMAGE_START_MASK;
+	rd_prompt = ((RAMDISK_FLAGS & RAMDISK_PROMPT_FLAG) != 0);
+	rd_doload = ((RAMDISK_FLAGS & RAMDISK_LOAD_FLAG) != 0);
+#endif
+
+	if (!MOUNT_ROOT_RDONLY)
+		root_mountflags &= ~MS_RDONLY;
+
+#ifdef CONFIG_VT
+#if defined(CONFIG_VGA_CONSOLE)
+        conswitchp = &vga_con;
+#elif defined(CONFIG_DUMMY_CONSOLE)
+        conswitchp = &dummy_con;
+#endif
+#endif
+
+#ifdef CONFIG_DISCONTIGMEM
+	numnodes = 2;
+#endif	/* CONFIG_DISCONTIGMEM */
+
+	init_mm.start_code = (unsigned long) _text;
+	init_mm.end_code = (unsigned long) _etext;
+	init_mm.end_data = (unsigned long) _edata;
+	init_mm.brk = (unsigned long) _end;
+
+	code_resource.start = virt_to_phys(_text);
+	code_resource.end = virt_to_phys(_etext)-1;
+	data_resource.start = virt_to_phys(_etext);
+	data_resource.end = virt_to_phys(_edata)-1;
+
+	parse_mem_cmdline(cmdline_p);
+
+	setup_memory();
+
+	paging_init();
+
+	init_IRQ();
+}
+
+#ifdef CONFIG_PROC_FS
+/*
+ *	Get CPU information for use by the procfs.
+ */
+static int show_cpuinfo(struct seq_file *m, void *v)
+{
+	struct cpuinfo_m32r *c = v;
+	unsigned long cpu = c - cpu_data;
+	
+#ifdef CONFIG_SMP
+	if (!(cpu_online_map & (1 << cpu)))
+		return 0;
+#endif  /* CONFIG_SMP */
+
+	seq_printf(m, "processor\t: %ld\n", cpu);
+
+#ifdef CONFIG_CHIP_VDEC2
+	seq_printf(m, "cpu family\t: VDEC2\n"
+		"cache size\t: Unknown\n");
+#elif  CONFIG_CHIP_M32700
+	seq_printf(m,"cpu family\t: M32700\n"
+		"cache size\t: I-8KB/D-8KB\n");
+#elif  CONFIG_CHIP_M32102
+	seq_printf(m,"cpu family\t: M32102\n"
+		"cache size\t: I-8KB\n");
+#elif  CONFIG_CHIP_OPSP
+	seq_printf(m,"cpu family\t: OPSP\n"
+		"cache size\t: I-8KB/D-8KB\n");
+#elif  CONFIG_CHIP_MP
+	seq_printf(m, "cpu family\t: M32R-MP\n"
+		"cache size\t: I-xxKB/D-xxKB\n");
+#else
+	seq_printf(m, "cpu family\t: Unknown\n");
+#endif
+	seq_printf(m, "bogomips\t: %lu.%02lu\n",
+		c->loops_per_jiffy/(500000/HZ),
+		(c->loops_per_jiffy/(5000/HZ)) % 100);
+#ifdef CONFIG_PLAT_MAPPI
+	seq_printf(m, "Machine\t\t: Mappi Evaluation board\n");
+#elif CONFIG_PLAT_MAPPI2
+	seq_printf(m, "Machine\t\t: Mappi-II Evaluation board\n");
+#elif  CONFIG_PLAT_M32700UT
+	seq_printf(m, "Machine\t\t: M32700UT Evaluation board\n");
+#elif  CONFIG_PLAT_OPSPUT
+	seq_printf(m, "Machine\t\t: OPSPUT Evaluation board\n");
+#elif  CONFIG_PLAT_USRV
+	seq_printf(m, "Machine\t\t: uServer\n");
+#elif  CONFIG_PLAT_OAKS32R
+	seq_printf(m, "Machine\t\t: OAKS32R\n");
+#else
+	seq_printf(m, "Machine\t\t: Unknown\n");
+#endif
+	
+#define PRINT_CLOCK(name, value)				\
+	seq_printf(m, name " clock\t: %d.%02dMHz\n",		\
+		((value) / 1000000), ((value) % 1000000)/10000)
+
+	PRINT_CLOCK("CPU", (int)c->cpu_clock);
+	PRINT_CLOCK("Bus", (int)c->bus_clock);
+
+	seq_printf(m, "\n");
+
+	return 0;
+}
+
+static void *c_start(struct seq_file *m, loff_t *pos)
+{
+	return *pos < NR_CPUS ? cpu_data + *pos : NULL;
+}
+
+static void *c_next(struct seq_file *m, void *v, loff_t *pos)
+{
+	++*pos;
+	return c_start(m, pos);
+}
+
+static void c_stop(struct seq_file *m, void *v)
+{
+}
+
+struct seq_operations cpuinfo_op = {
+	start:	c_start,
+	next:	c_next,
+	stop:	c_stop,
+	show:	show_cpuinfo,
+};
+#endif  /* CONFIG_PROC_FS */
+
+unsigned long cpu_initialized __initdata = 0;
+
+/*
+ * cpu_init() initializes state that is per-CPU. Some data is already
+ * initialized (naturally) in the bootstrap process.
+ * We reload them nevertheless, this function acts as a
+ * 'CPU state barrier', nothing should get across.
+ */
+#if defined(CONFIG_CHIP_VDEC2) || defined(CONFIG_CHIP_XNUX2)	\
+	|| defined(CONFIG_CHIP_M32700) || defined(CONFIG_CHIP_M32102) \
+        || defined(CONFIG_CHIP_OPSP)
+void __init cpu_init (void)
+{
+	int cpu_id = smp_processor_id();
+
+	if (test_and_set_bit(cpu_id, &cpu_initialized)) {
+		printk(KERN_WARNING "CPU#%d already initialized!\n", cpu_id);
+		for ( ; ; )
+			local_irq_enable();
+	}
+	printk(KERN_INFO "Initializing CPU#%d\n", cpu_id);
+
+	/* Set up and load the per-CPU TSS and LDT */
+	atomic_inc(&init_mm.mm_count);
+	current->active_mm = &init_mm;
+	if (current->mm)
+		BUG();
+
+	/* Force FPU initialization */
+	current_thread_info()->status = 0;
+	current->used_math = 0;
+
+#ifdef CONFIG_MMU
+	/* Set up MMU */
+	init_mmu();
+#endif
+
+	/* Set up ICUIMASK */
+	outl(0x00070000, M32R_ICU_IMASK_PORTL);   /* imask=111 */
+}
+#endif  /* defined(CONFIG_CHIP_VDEC2) ... */
+
diff -ruN linux-2.6.7.org/arch/m32r/kernel/setup_m32700ut.c linux-2.6.7/arch/m32r/kernel/setup_m32700ut.c
--- linux-2.6.7.org/arch/m32r/kernel/setup_m32700ut.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/setup_m32700ut.c	2004-01-27 10:58:04.000000000 +0900
@@ -0,0 +1,453 @@
+/*  
+ *  linux/arch/m32r/kernel/setup_m32700ut.c
+ *  
+ *  Setup routines for MITSUBISHI M32700UT Board
+ *
+ *  Copyright (c) 2002 	Hiroyuki Kondo, Hirokazu Takata, 
+ *                      Hitoshi Yamamoto, Takeo Takahashi
+ *
+ *  This file is subject to the terms and conditions of the GNU General
+ *  Public License.  See the file "COPYING" in the main directory of this
+ *  archive for more details.
+ *
+ *  $Id: setup_m32700ut.c,v 1.6 2003/11/27 10:18:49 takeo Exp $
+ */
+
+#include <linux/config.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/system.h>
+#include <asm/m32r.h>
+#include <asm/io.h>
+
+/*
+ * M32700 Interrupt Control Unit (Level 1)
+ */
+#define irq2port(x) (M32R_ICU_CR1_PORTL + ((x - 1) * sizeof(unsigned long)))
+
+#ifndef CONFIG_SMP
+typedef struct {
+	unsigned long icucr;  /* ICU Control Register */
+} icu_data_t;
+#endif /* CONFIG_SMP */
+
+static icu_data_t icu_data[M32700UT_NUM_CPU_IRQ];
+
+static void disable_m32700ut_irq(unsigned int irq)
+{
+	unsigned long port, data;
+	
+	port = irq2port(irq);
+	data = icu_data[irq].icucr|M32R_ICUCR_ILEVEL7;
+	outl(data, port);
+}
+
+static void enable_m32700ut_irq(unsigned int irq)
+{
+	unsigned long port, data;
+	
+	port = irq2port(irq);
+	data = icu_data[irq].icucr|M32R_ICUCR_IEN|M32R_ICUCR_ILEVEL6;
+	outl(data, port);
+}
+
+static void mask_and_ack_m32700ut(unsigned int irq)
+{
+	disable_m32700ut_irq(irq);
+}
+
+static void end_m32700ut_irq(unsigned int irq)
+{
+	enable_m32700ut_irq(irq);
+}
+
+static unsigned int startup_m32700ut_irq(unsigned int irq)
+{
+	enable_m32700ut_irq(irq);
+	return (0);
+}
+
+static void shutdown_m32700ut_irq(unsigned int irq)
+{
+	unsigned long port;
+	
+	port = irq2port(irq);
+	outl(M32R_ICUCR_ILEVEL7, port);
+}
+
+static struct hw_interrupt_type m32700ut_irq_type = 
+{
+	"M32700UT-IRQ",
+	startup_m32700ut_irq,
+	shutdown_m32700ut_irq,
+	enable_m32700ut_irq,
+	disable_m32700ut_irq,
+	mask_and_ack_m32700ut,
+	end_m32700ut_irq
+};
+
+/*
+ * Interrupt Control Unit of PLD on M32700UT (Level 2)
+ */
+#define irq2pldirq(x)		((x) - M32700UT_PLD_IRQ_BASE)
+#define pldirq2port(x)		(unsigned long)((int)PLD_ICUCR1 + \
+				 (((x) - 1) * sizeof(unsigned short)))
+
+typedef struct {
+	unsigned short icucr;  /* ICU Control Register */
+} pld_icu_data_t;
+
+static pld_icu_data_t pld_icu_data[M32700UT_NUM_PLD_IRQ];
+
+static void disable_m32700ut_pld_irq(unsigned int irq)
+{
+	unsigned long port, data; 
+	unsigned int pldirq;
+
+	pldirq = irq2pldirq(irq);
+//	disable_m32700ut_irq(M32R_IRQ_INT1);
+	port = pldirq2port(pldirq);
+	data = pld_icu_data[pldirq].icucr|PLD_ICUCR_ILEVEL7;
+	outw(data, port);
+}
+
+static void enable_m32700ut_pld_irq(unsigned int irq)
+{
+	unsigned long port, data;
+	unsigned int pldirq;
+
+	pldirq = irq2pldirq(irq);
+//	enable_m32700ut_irq(M32R_IRQ_INT1);
+	port = pldirq2port(pldirq);
+	data = pld_icu_data[pldirq].icucr|PLD_ICUCR_IEN|PLD_ICUCR_ILEVEL6;
+	outw(data, port);
+}
+
+static void mask_and_ack_m32700ut_pld(unsigned int irq)
+{
+	disable_m32700ut_pld_irq(irq);
+//	mask_and_ack_m32700ut(M32R_IRQ_INT1);
+}
+
+static void end_m32700ut_pld_irq(unsigned int irq)
+{
+	enable_m32700ut_pld_irq(irq);
+	end_m32700ut_irq(M32R_IRQ_INT1);
+}
+
+static unsigned int startup_m32700ut_pld_irq(unsigned int irq)
+{
+	enable_m32700ut_pld_irq(irq);
+	return (0);
+}
+
+static void shutdown_m32700ut_pld_irq(unsigned int irq)
+{
+	unsigned long port;
+	unsigned int pldirq;
+
+	pldirq = irq2pldirq(irq);
+//	shutdown_m32700ut_irq(M32R_IRQ_INT1);
+	port = pldirq2port(pldirq);
+	outw(PLD_ICUCR_ILEVEL7, port);
+}
+
+static struct hw_interrupt_type m32700ut_pld_irq_type =
+{
+	"M32700UT-PLD-IRQ",
+	startup_m32700ut_pld_irq,
+	shutdown_m32700ut_pld_irq,
+	enable_m32700ut_pld_irq,
+	disable_m32700ut_pld_irq,
+	mask_and_ack_m32700ut_pld,
+	end_m32700ut_pld_irq
+};
+
+/*
+ * Interrupt Control Unit of PLD on M32700UT-LAN (Level 2)
+ */
+#define irq2lanpldirq(x)	((x) - M32700UT_LAN_PLD_IRQ_BASE)
+#define lanpldirq2port(x)	(unsigned long)((int)M32700UT_LAN_ICUCR1 + \
+				 (((x) - 1) * sizeof(unsigned short)))
+
+static pld_icu_data_t lanpld_icu_data[M32700UT_NUM_LAN_PLD_IRQ];
+
+static void disable_m32700ut_lanpld_irq(unsigned int irq)
+{
+	unsigned long port, data; 
+	unsigned int pldirq;
+
+	pldirq = irq2lanpldirq(irq);
+	port = lanpldirq2port(pldirq);
+	data = lanpld_icu_data[pldirq].icucr|PLD_ICUCR_ILEVEL7;
+	outw(data, port);
+}
+
+static void enable_m32700ut_lanpld_irq(unsigned int irq)
+{
+	unsigned long port, data;
+	unsigned int pldirq;
+
+	pldirq = irq2lanpldirq(irq);
+	port = lanpldirq2port(pldirq);
+	data = lanpld_icu_data[pldirq].icucr|PLD_ICUCR_IEN|PLD_ICUCR_ILEVEL6;
+	outw(data, port);
+}
+
+static void mask_and_ack_m32700ut_lanpld(unsigned int irq)
+{
+	disable_m32700ut_lanpld_irq(irq);
+}
+
+static void end_m32700ut_lanpld_irq(unsigned int irq)
+{
+	enable_m32700ut_lanpld_irq(irq);
+	end_m32700ut_irq(M32R_IRQ_INT0);
+}
+
+static unsigned int startup_m32700ut_lanpld_irq(unsigned int irq)
+{
+	enable_m32700ut_lanpld_irq(irq);
+	return (0);
+}
+
+static void shutdown_m32700ut_lanpld_irq(unsigned int irq)
+{
+	unsigned long port;
+	unsigned int pldirq;
+
+	pldirq = irq2lanpldirq(irq);
+	port = lanpldirq2port(pldirq);
+	outw(PLD_ICUCR_ILEVEL7, port);
+}
+
+static struct hw_interrupt_type m32700ut_lanpld_irq_type =
+{
+	"M32700UT-PLD-LAN-IRQ",
+	startup_m32700ut_lanpld_irq,
+	shutdown_m32700ut_lanpld_irq,
+	enable_m32700ut_lanpld_irq,
+	disable_m32700ut_lanpld_irq,
+	mask_and_ack_m32700ut_lanpld,
+	end_m32700ut_lanpld_irq
+};
+
+/*
+ * Interrupt Control Unit of PLD on M32700UT-LCD (Level 2)
+ */
+#define irq2lcdpldirq(x)	((x) - M32700UT_LCD_PLD_IRQ_BASE)
+#define lcdpldirq2port(x)	(unsigned long)((int)M32700UT_LCD_ICUCR1 + \
+				 (((x) - 1) * sizeof(unsigned short)))
+
+static pld_icu_data_t lcdpld_icu_data[M32700UT_NUM_LCD_PLD_IRQ];
+
+static void disable_m32700ut_lcdpld_irq(unsigned int irq)
+{
+	unsigned long port, data; 
+	unsigned int pldirq;
+
+	pldirq = irq2lcdpldirq(irq);
+	port = lcdpldirq2port(pldirq);
+	data = lcdpld_icu_data[pldirq].icucr|PLD_ICUCR_ILEVEL7;
+	outw(data, port);
+}
+
+static void enable_m32700ut_lcdpld_irq(unsigned int irq)
+{
+	unsigned long port, data;
+	unsigned int pldirq;
+
+	pldirq = irq2lcdpldirq(irq);
+	port = lcdpldirq2port(pldirq);
+	data = lcdpld_icu_data[pldirq].icucr|PLD_ICUCR_IEN|PLD_ICUCR_ILEVEL6;
+	outw(data, port);
+}
+
+static void mask_and_ack_m32700ut_lcdpld(unsigned int irq)
+{
+	disable_m32700ut_lcdpld_irq(irq);
+}
+
+static void end_m32700ut_lcdpld_irq(unsigned int irq)
+{
+	enable_m32700ut_lcdpld_irq(irq);
+	end_m32700ut_irq(M32R_IRQ_INT2);
+}
+
+static unsigned int startup_m32700ut_lcdpld_irq(unsigned int irq)
+{
+	enable_m32700ut_lcdpld_irq(irq);
+	return (0);
+}
+
+static void shutdown_m32700ut_lcdpld_irq(unsigned int irq)
+{
+	unsigned long port;
+	unsigned int pldirq;
+
+	pldirq = irq2lcdpldirq(irq);
+	port = lcdpldirq2port(pldirq);
+	outw(PLD_ICUCR_ILEVEL7, port);
+}
+
+static struct hw_interrupt_type m32700ut_lcdpld_irq_type =
+{
+	"M32700UT-PLD-LCD-IRQ",
+	startup_m32700ut_lcdpld_irq,
+	shutdown_m32700ut_lcdpld_irq,
+	enable_m32700ut_lcdpld_irq,
+	disable_m32700ut_lcdpld_irq,
+	mask_and_ack_m32700ut_lcdpld,
+	end_m32700ut_lcdpld_irq
+};
+
+void __init init_IRQ(void)
+{
+#ifdef CONFIG_M32R_SMC91111
+	/* INT#0: LAN controller on M32700UT-LAN (SMC91C111)*/
+	irq_desc[M32700UT_LAN_IRQ_LAN].status = IRQ_DISABLED;
+	irq_desc[M32700UT_LAN_IRQ_LAN].handler = &m32700ut_lanpld_irq_type;
+	irq_desc[M32700UT_LAN_IRQ_LAN].action = 0;
+	irq_desc[M32700UT_LAN_IRQ_LAN].depth = 1;	/* disable nested irq */
+	lanpld_icu_data[irq2lanpldirq(M32700UT_LAN_IRQ_LAN)].icucr = PLD_ICUCR_IEN|PLD_ICUCR_ISMOD02;	/* "H" edge sense */
+	disable_m32700ut_lanpld_irq(M32700UT_LAN_IRQ_LAN);
+#endif  /* CONFIG_M32R_SMC91111 */
+
+	/* MFT2 : system timer */
+	irq_desc[M32R_IRQ_MFT2].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_MFT2].handler = &m32700ut_irq_type;
+	irq_desc[M32R_IRQ_MFT2].action = 0;
+	irq_desc[M32R_IRQ_MFT2].depth = 1;
+	icu_data[M32R_IRQ_MFT2].icucr = M32R_ICUCR_IEN;
+	disable_m32700ut_irq(M32R_IRQ_MFT2);
+	
+	/* SIO0 : receive */
+	irq_desc[M32R_IRQ_SIO0_R].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_SIO0_R].handler = &m32700ut_irq_type;
+	irq_desc[M32R_IRQ_SIO0_R].action = 0;
+	irq_desc[M32R_IRQ_SIO0_R].depth = 1;
+	icu_data[M32R_IRQ_SIO0_R].icucr = 0;
+	disable_m32700ut_irq(M32R_IRQ_SIO0_R);
+	
+	/* SIO0 : send */
+	irq_desc[M32R_IRQ_SIO0_S].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_SIO0_S].handler = &m32700ut_irq_type;
+	irq_desc[M32R_IRQ_SIO0_S].action = 0;
+	irq_desc[M32R_IRQ_SIO0_S].depth = 1;
+	icu_data[M32R_IRQ_SIO0_S].icucr = 0;
+	disable_m32700ut_irq(M32R_IRQ_SIO0_S);
+
+	/* SIO1 : receive */
+	irq_desc[M32R_IRQ_SIO1_R].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_SIO1_R].handler = &m32700ut_irq_type;
+	irq_desc[M32R_IRQ_SIO1_R].action = 0;
+	irq_desc[M32R_IRQ_SIO1_R].depth = 1;
+	icu_data[M32R_IRQ_SIO1_R].icucr = 0;
+	disable_m32700ut_irq(M32R_IRQ_SIO1_R);
+
+	/* SIO1 : send */
+	irq_desc[M32R_IRQ_SIO1_S].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_SIO1_S].handler = &m32700ut_irq_type;
+	irq_desc[M32R_IRQ_SIO1_S].action = 0;
+	irq_desc[M32R_IRQ_SIO1_S].depth = 1;
+	icu_data[M32R_IRQ_SIO1_S].icucr = 0;
+	disable_m32700ut_irq(M32R_IRQ_SIO1_S);
+
+	/* DMA1 : */
+	irq_desc[M32R_IRQ_DMA1].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_DMA1].handler = &m32700ut_irq_type;
+	irq_desc[M32R_IRQ_DMA1].action = 0;
+	irq_desc[M32R_IRQ_DMA1].depth = 1;
+	icu_data[M32R_IRQ_DMA1].icucr = 0;
+	disable_m32700ut_irq(M32R_IRQ_DMA1);
+
+#ifdef CONFIG_SERIAL_M32R_PLDSIO
+	/* INT#1: SIO0 Receive on PLD */
+	irq_desc[PLD_IRQ_SIO0_RCV].status = IRQ_DISABLED;
+	irq_desc[PLD_IRQ_SIO0_RCV].handler = &m32700ut_pld_irq_type;
+	irq_desc[PLD_IRQ_SIO0_RCV].action = 0;
+	irq_desc[PLD_IRQ_SIO0_RCV].depth = 1;	/* disable nested irq */
+	pld_icu_data[irq2pldirq(PLD_IRQ_SIO0_RCV)].icucr = PLD_ICUCR_IEN|PLD_ICUCR_ISMOD03;
+	disable_m32700ut_pld_irq(PLD_IRQ_SIO0_RCV);
+
+	/* INT#1: SIO0 Send on PLD */
+	irq_desc[PLD_IRQ_SIO0_SND].status = IRQ_DISABLED;
+	irq_desc[PLD_IRQ_SIO0_SND].handler = &m32700ut_pld_irq_type;
+	irq_desc[PLD_IRQ_SIO0_SND].action = 0;
+	irq_desc[PLD_IRQ_SIO0_SND].depth = 1;	/* disable nested irq */
+	pld_icu_data[irq2pldirq(PLD_IRQ_SIO0_SND)].icucr = PLD_ICUCR_IEN|PLD_ICUCR_ISMOD03;
+	disable_m32700ut_pld_irq(PLD_IRQ_SIO0_SND);
+#endif  /* CONFIG_SERIAL_M32R_PLDSIO */
+
+#if defined(CONFIG_M32R_CFC)
+	/* INT#1: CFC IREQ on PLD */
+	irq_desc[PLD_IRQ_CFIREQ].status = IRQ_DISABLED;
+	irq_desc[PLD_IRQ_CFIREQ].handler = &m32700ut_pld_irq_type;
+	irq_desc[PLD_IRQ_CFIREQ].action = 0;
+	irq_desc[PLD_IRQ_CFIREQ].depth = 1;	/* disable nested irq */
+	pld_icu_data[irq2pldirq(PLD_IRQ_CFIREQ)].icucr = PLD_ICUCR_IEN|PLD_ICUCR_ISMOD01;	/* 'L' level sense */
+	disable_m32700ut_pld_irq(PLD_IRQ_CFIREQ);
+
+	/* INT#1: CFC Insert on PLD */
+	irq_desc[PLD_IRQ_CFC_INSERT].status = IRQ_DISABLED;
+	irq_desc[PLD_IRQ_CFC_INSERT].handler = &m32700ut_pld_irq_type;
+	irq_desc[PLD_IRQ_CFC_INSERT].action = 0;
+	irq_desc[PLD_IRQ_CFC_INSERT].depth = 1;	/* disable nested irq */
+	pld_icu_data[irq2pldirq(PLD_IRQ_CFC_INSERT)].icucr = PLD_ICUCR_IEN|PLD_ICUCR_ISMOD00;	/* 'L' edge sense */
+	disable_m32700ut_pld_irq(PLD_IRQ_CFC_INSERT);
+
+	/* INT#1: CFC Eject on PLD */
+	irq_desc[PLD_IRQ_CFC_EJECT].status = IRQ_DISABLED;
+	irq_desc[PLD_IRQ_CFC_EJECT].handler = &m32700ut_pld_irq_type;
+	irq_desc[PLD_IRQ_CFC_EJECT].action = 0;
+	irq_desc[PLD_IRQ_CFC_EJECT].depth = 1;	/* disable nested irq */
+	pld_icu_data[irq2pldirq(PLD_IRQ_CFC_EJECT)].icucr = PLD_ICUCR_IEN|PLD_ICUCR_ISMOD02;	/* 'H' edge sense */
+	disable_m32700ut_pld_irq(PLD_IRQ_CFC_EJECT);
+#endif /* CONFIG_M32R_CFC */
+
+
+	/*
+	 * INT0# is used for LAN, DIO
+	 * We enable it here.
+	 */
+	icu_data[M32R_IRQ_INT0].icucr = M32R_ICUCR_IEN|M32R_ICUCR_ISMOD11;
+	enable_m32700ut_irq(M32R_IRQ_INT0);
+
+	/*
+	 * INT1# is used for UART, MMC, CF Controller in FPGA.
+	 * We enable it here.
+	 */
+	icu_data[M32R_IRQ_INT1].icucr = M32R_ICUCR_IEN|M32R_ICUCR_ISMOD11;
+	enable_m32700ut_irq(M32R_IRQ_INT1);
+
+#if defined(CONFIG_USB)
+	outw(USBCR_OTGS, USBCR); 	/* USBCR: non-OTG */
+
+    irq_desc[M32700UT_LCD_IRQ_USB_INT1].status = IRQ_DISABLED;
+    irq_desc[M32700UT_LCD_IRQ_USB_INT1].handler = &m32700ut_lcdpld_irq_type;
+    irq_desc[M32700UT_LCD_IRQ_USB_INT1].action = 0;
+    irq_desc[M32700UT_LCD_IRQ_USB_INT1].depth = 1;
+    lcdpld_icu_data[irq2lcdpldirq(M32700UT_LCD_IRQ_USB_INT1)].icucr = PLD_ICUCR_IEN|PLD_ICUCR_ISMOD01;	/* "L" level sense */
+    disable_m32700ut_lcdpld_irq(M32700UT_LCD_IRQ_USB_INT1);
+#endif 
+	/*
+	 * INT2# is used for BAT, USB, AUDIO
+	 * We enable it here.
+	 */
+	icu_data[M32R_IRQ_INT2].icucr = M32R_ICUCR_IEN|M32R_ICUCR_ISMOD01;
+	enable_m32700ut_irq(M32R_IRQ_INT2);
+
+//#if defined(CONFIG_M32R_AR_VGA)
+	/*
+	 * INT3# is used for AR 
+	 */
+	irq_desc[M32R_IRQ_INT3].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_INT3].handler = &m32700ut_irq_type;
+	irq_desc[M32R_IRQ_INT3].action = 0;
+	irq_desc[M32R_IRQ_INT3].depth = 1;
+	icu_data[M32R_IRQ_INT3].icucr = M32R_ICUCR_IEN|M32R_ICUCR_ISMOD10;
+	disable_m32700ut_irq(M32R_IRQ_INT3);
+//#endif	/* CONFIG_M32R_ARV */
+}
diff -ruN linux-2.6.7.org/arch/m32r/kernel/setup_mappi.c linux-2.6.7/arch/m32r/kernel/setup_mappi.c
--- linux-2.6.7.org/arch/m32r/kernel/setup_mappi.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/setup_mappi.c	2004-03-25 13:27:25.000000000 +0900
@@ -0,0 +1,164 @@
+/*  
+ *  linux/arch/m32r/kernel/setup_mappi.c
+ *  
+ *  Setup routines for MITSUBISHI MAPPI Board
+ *  
+ *  Copyright (c) 2001, 2002  Hiroyuki Kondo, Hirokazu Takata, 
+ *                            Hitoshi Yamamoto
+ */
+
+static char *rcsid =
+"$Id$";
+static void use_rcsid(void) {rcsid = rcsid; use_rcsid();}
+
+#include <linux/config.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/system.h>
+#include <asm/m32r.h>
+#include <asm/io.h>
+
+#define irq2port(x) (M32R_ICU_CR1_PORTL + ((x - 1) * sizeof(unsigned long)))
+
+#ifndef CONFIG_SMP
+typedef struct {
+	unsigned long icucr;  /* ICU Control Register */
+} icu_data_t;
+#endif /* CONFIG_SMP */
+
+icu_data_t icu_data[NR_IRQS];
+
+static void disable_mappi_irq(unsigned int irq)
+{
+	unsigned long port, data;
+	
+	port = irq2port(irq);
+	data = icu_data[irq].icucr|M32R_ICUCR_ILEVEL7;
+	outl(data, port);
+}
+
+static void enable_mappi_irq(unsigned int irq)
+{
+	unsigned long port, data;
+	
+	port = irq2port(irq);
+	data = icu_data[irq].icucr|M32R_ICUCR_IEN|M32R_ICUCR_ILEVEL6;
+	outl(data, port);
+}
+
+static void mask_and_ack_mappi(unsigned int irq)
+{
+	disable_mappi_irq(irq);
+}
+
+static void end_mappi_irq(unsigned int irq)
+{
+	enable_mappi_irq(irq);
+}
+
+static unsigned int startup_mappi_irq(unsigned int irq)
+{
+	enable_mappi_irq(irq);
+	return (0);
+}
+
+static void shutdown_mappi_irq(unsigned int irq)
+{
+	unsigned long port;
+	
+	port = irq2port(irq);
+	outl(M32R_ICUCR_ILEVEL7, port);
+}
+
+static struct hw_interrupt_type mappi_irq_type = 
+{
+	"MAPPI-IRQ",
+	startup_mappi_irq,
+	shutdown_mappi_irq,
+	enable_mappi_irq,
+	disable_mappi_irq,
+	mask_and_ack_mappi,
+	end_mappi_irq
+};
+
+void __init init_IRQ(void)
+{
+	static int once = 0;
+
+	if (once)
+		return;
+	else
+		once++;
+
+#ifdef CONFIG_M32R_NE2000
+	/* INT0 : LAN controller (RTL8019AS) */
+	irq_desc[M32R_IRQ_INT0].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_INT0].handler = &mappi_irq_type;
+	irq_desc[M32R_IRQ_INT0].action = 0;
+	irq_desc[M32R_IRQ_INT0].depth = 1;
+	icu_data[M32R_IRQ_INT0].icucr = M32R_ICUCR_IEN|M32R_ICUCR_ISMOD10;
+	disable_mappi_irq(M32R_IRQ_INT0);
+#endif /* CONFIG_M32R_NE2000 */
+
+	/* MFT2 : system timer */
+	irq_desc[M32R_IRQ_MFT2].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_MFT2].handler = &mappi_irq_type;
+	irq_desc[M32R_IRQ_MFT2].action = 0;
+	irq_desc[M32R_IRQ_MFT2].depth = 1;
+	icu_data[M32R_IRQ_MFT2].icucr = M32R_ICUCR_IEN;
+	disable_mappi_irq(M32R_IRQ_MFT2);
+
+#ifdef CONFIG_SERIAL_M32R_SIO
+	/* SIO0_R : uart receive data */
+	irq_desc[M32R_IRQ_SIO0_R].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_SIO0_R].handler = &mappi_irq_type;
+	irq_desc[M32R_IRQ_SIO0_R].action = 0;
+	irq_desc[M32R_IRQ_SIO0_R].depth = 1;
+	icu_data[M32R_IRQ_SIO0_R].icucr = 0;
+	disable_mappi_irq(M32R_IRQ_SIO0_R);
+
+	/* SIO0_S : uart send data */
+	irq_desc[M32R_IRQ_SIO0_S].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_SIO0_S].handler = &mappi_irq_type;
+	irq_desc[M32R_IRQ_SIO0_S].action = 0;
+	irq_desc[M32R_IRQ_SIO0_S].depth = 1;
+	icu_data[M32R_IRQ_SIO0_S].icucr = 0;
+	disable_mappi_irq(M32R_IRQ_SIO0_S);
+
+	/* SIO1_R : uart receive data */
+	irq_desc[M32R_IRQ_SIO1_R].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_SIO1_R].handler = &mappi_irq_type;
+	irq_desc[M32R_IRQ_SIO1_R].action = 0;
+	irq_desc[M32R_IRQ_SIO1_R].depth = 1;
+	icu_data[M32R_IRQ_SIO1_R].icucr = 0;
+	disable_mappi_irq(M32R_IRQ_SIO1_R);
+
+	/* SIO1_S : uart send data */
+	irq_desc[M32R_IRQ_SIO1_S].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_SIO1_S].handler = &mappi_irq_type;
+	irq_desc[M32R_IRQ_SIO1_S].action = 0;
+	irq_desc[M32R_IRQ_SIO1_S].depth = 1;
+	icu_data[M32R_IRQ_SIO1_S].icucr = 0;
+	disable_mappi_irq(M32R_IRQ_SIO1_S);
+#endif /* CONFIG_SERIAL_M32R_SIO */
+
+#if defined(CONFIG_M32RPCC)
+	/* INT1 : pccard0 interrupt */
+	irq_desc[M32R_IRQ_INT1].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_INT1].handler = &mappi_irq_type;
+	irq_desc[M32R_IRQ_INT1].action = 0;
+	irq_desc[M32R_IRQ_INT1].depth = 1;
+	icu_data[M32R_IRQ_INT1].icucr = M32R_ICUCR_IEN | M32R_ICUCR_ISMOD00;
+	disable_mappi_irq(M32R_IRQ_INT1);
+
+	/* INT2 : pccard1 interrupt */
+	irq_desc[M32R_IRQ_INT2].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_INT2].handler = &mappi_irq_type;
+	irq_desc[M32R_IRQ_INT2].action = 0;
+	irq_desc[M32R_IRQ_INT2].depth = 1;
+	icu_data[M32R_IRQ_INT2].icucr = M32R_ICUCR_IEN | M32R_ICUCR_ISMOD00;
+	disable_mappi_irq(M32R_IRQ_INT2);
+#endif /* CONFIG_M32RPCC */
+}
diff -ruN linux-2.6.7.org/arch/m32r/kernel/setup_mappi2.c linux-2.6.7/arch/m32r/kernel/setup_mappi2.c
--- linux-2.6.7.org/arch/m32r/kernel/setup_mappi2.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/setup_mappi2.c	2004-04-13 19:46:45.000000000 +0900
@@ -0,0 +1,186 @@
+/*  
+ *  linux/arch/m32r/kernel/setup_mappi.c
+ *  
+ *  Setup routines for Renesas MAPPI-II(M3A-ZA36) Board
+ *  
+ *  Copyright (c) 2001, 2002  Hiroyuki Kondo, Hirokazu Takata, 
+ *                            Hitoshi Yamamoto, Mamoru Sakugawa
+ */
+
+static char *rcsid =
+"$Id$";
+static void use_rcsid(void) {rcsid = rcsid; use_rcsid();}
+
+#include <linux/config.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/system.h>
+#include <asm/m32r.h>
+#include <asm/io.h>
+
+#define irq2port(x) (M32R_ICU_CR1_PORTL + ((x - 1) * sizeof(unsigned long)))
+
+#ifndef CONFIG_SMP
+typedef struct {
+	unsigned long icucr;  /* ICU Control Register */
+} icu_data_t;
+#endif /* CONFIG_SMP */
+
+icu_data_t icu_data[NR_IRQS];
+
+static void disable_mappi2_irq(unsigned int irq)
+{
+	unsigned long port, data;
+	
+	if ((irq == 0) ||(irq >= NR_IRQS))  {
+		printk("bad irq 0x%08x\n", irq);
+		return;
+	}
+	port = irq2port(irq);
+	data = icu_data[irq].icucr|M32R_ICUCR_ILEVEL7;
+	outl(data, port);
+}
+
+static void enable_mappi2_irq(unsigned int irq)
+{
+	unsigned long port, data;
+	
+	if ((irq == 0) ||(irq >= NR_IRQS))  {
+		printk("bad irq 0x%08x\n", irq);
+		return;
+	}
+	port = irq2port(irq);
+	data = icu_data[irq].icucr|M32R_ICUCR_IEN|M32R_ICUCR_ILEVEL6;
+	outl(data, port);
+}
+
+static void mask_and_ack_mappi2(unsigned int irq)
+{
+	disable_mappi2_irq(irq);
+}
+
+static void end_mappi2_irq(unsigned int irq)
+{
+	enable_mappi2_irq(irq);
+}
+
+static unsigned int startup_mappi2_irq(unsigned int irq)
+{
+	enable_mappi2_irq(irq);
+	return (0);
+}
+
+static void shutdown_mappi2_irq(unsigned int irq)
+{
+	unsigned long port;
+	
+	port = irq2port(irq);
+	outl(M32R_ICUCR_ILEVEL7, port);
+}
+
+static struct hw_interrupt_type mappi2_irq_type = 
+{
+	"MAPPI2-IRQ",
+	startup_mappi2_irq,
+	shutdown_mappi2_irq,
+	enable_mappi2_irq,
+	disable_mappi2_irq,
+	mask_and_ack_mappi2,
+	end_mappi2_irq
+};
+
+void __init init_IRQ(void)
+{
+#ifdef CONFIG_M32R_SMC91111
+	/* INT0 : LAN controller (SMC91111) */
+	irq_desc[M32R_IRQ_INT0].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_INT0].handler = &mappi2_irq_type;
+	irq_desc[M32R_IRQ_INT0].action = 0;
+	irq_desc[M32R_IRQ_INT0].depth = 1;
+	icu_data[M32R_IRQ_INT0].icucr = M32R_ICUCR_IEN|M32R_ICUCR_ISMOD10;
+	disable_mappi2_irq(M32R_IRQ_INT0);
+#endif  /* CONFIG_MAPPI2_SMC9111 */
+
+	/* MFT2 : system timer */
+	irq_desc[M32R_IRQ_MFT2].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_MFT2].handler = &mappi2_irq_type;
+	irq_desc[M32R_IRQ_MFT2].action = 0;
+	irq_desc[M32R_IRQ_MFT2].depth = 1;
+	icu_data[M32R_IRQ_MFT2].icucr = M32R_ICUCR_IEN;
+	disable_mappi2_irq(M32R_IRQ_MFT2);
+	
+#ifdef CONFIG_SERIAL_M32R_SIO
+	/* SIO0_R : uart receive data */
+	irq_desc[M32R_IRQ_SIO0_R].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_SIO0_R].handler = &mappi2_irq_type;
+	irq_desc[M32R_IRQ_SIO0_R].action = 0;
+	irq_desc[M32R_IRQ_SIO0_R].depth = 1;
+	icu_data[M32R_IRQ_SIO0_R].icucr = 0;
+	disable_mappi2_irq(M32R_IRQ_SIO0_R);
+	
+	/* SIO0_S : uart send data */
+	irq_desc[M32R_IRQ_SIO0_S].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_SIO0_S].handler = &mappi2_irq_type;
+	irq_desc[M32R_IRQ_SIO0_S].action = 0;
+	irq_desc[M32R_IRQ_SIO0_S].depth = 1;
+	icu_data[M32R_IRQ_SIO0_S].icucr = 0;
+	disable_mappi2_irq(M32R_IRQ_SIO0_S);
+	/* SIO1_R : uart receive data */
+	irq_desc[M32R_IRQ_SIO1_R].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_SIO1_R].handler = &mappi2_irq_type;
+	irq_desc[M32R_IRQ_SIO1_R].action = 0;
+	irq_desc[M32R_IRQ_SIO1_R].depth = 1;
+	icu_data[M32R_IRQ_SIO1_R].icucr = 0;
+	disable_mappi2_irq(M32R_IRQ_SIO1_R);
+	
+	/* SIO1_S : uart send data */
+	irq_desc[M32R_IRQ_SIO1_S].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_SIO1_S].handler = &mappi2_irq_type;
+	irq_desc[M32R_IRQ_SIO1_S].action = 0;
+	irq_desc[M32R_IRQ_SIO1_S].depth = 1;
+	icu_data[M32R_IRQ_SIO1_S].icucr = 0;
+	disable_mappi2_irq(M32R_IRQ_SIO1_S);
+#endif  /* CONFIG_M32R_USE_DBG_CONSOLE */
+
+#if defined(CONFIG_USB)
+	/* INT1 : USB Host controller interrupt */
+	irq_desc[M32R_IRQ_INT1].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_INT1].handler = &mappi2_irq_type;
+	irq_desc[M32R_IRQ_INT1].action = 0;
+	irq_desc[M32R_IRQ_INT1].depth = 1;
+	icu_data[M32R_IRQ_INT1].icucr = M32R_ICUCR_ISMOD01;
+	disable_mappi2_irq(M32R_IRQ_INT1);
+#endif /* CONFIG_USB */
+
+#if defined(CONFIG_M32R_CFC)
+	/* ICUCR40: CFC IREQ */
+	irq_desc[PLD_IRQ_CFIREQ].status = IRQ_DISABLED;
+	irq_desc[PLD_IRQ_CFIREQ].handler = &mappi2_irq_type;
+	irq_desc[PLD_IRQ_CFIREQ].action = 0;
+	irq_desc[PLD_IRQ_CFIREQ].depth = 1;	/* disable nested irq */
+//	icu_data[PLD_IRQ_CFIREQ].icucr = M32R_ICUCR_IEN|M32R_ICUCR_ISMOD00;
+	icu_data[PLD_IRQ_CFIREQ].icucr = M32R_ICUCR_IEN|M32R_ICUCR_ISMOD01;
+	disable_mappi2_irq(PLD_IRQ_CFIREQ);
+
+	/* ICUCR41: CFC Insert */
+	irq_desc[PLD_IRQ_CFC_INSERT].status = IRQ_DISABLED;
+	irq_desc[PLD_IRQ_CFC_INSERT].handler = &mappi2_irq_type;
+	irq_desc[PLD_IRQ_CFC_INSERT].action = 0;
+	irq_desc[PLD_IRQ_CFC_INSERT].depth = 1;	/* disable nested irq */
+	icu_data[PLD_IRQ_CFC_INSERT].icucr = M32R_ICUCR_IEN|M32R_ICUCR_ISMOD00;
+//	icu_data[PLD_IRQ_CFC_INSERT].icucr = 0;
+	disable_mappi2_irq(PLD_IRQ_CFC_INSERT);
+
+	/* ICUCR42: CFC Eject */
+	irq_desc[PLD_IRQ_CFC_EJECT].status = IRQ_DISABLED;
+	irq_desc[PLD_IRQ_CFC_EJECT].handler = &mappi2_irq_type;
+	irq_desc[PLD_IRQ_CFC_EJECT].action = 0;
+	irq_desc[PLD_IRQ_CFC_EJECT].depth = 1;	/* disable nested irq */
+	icu_data[PLD_IRQ_CFC_EJECT].icucr = M32R_ICUCR_IEN|M32R_ICUCR_ISMOD10;
+//	icu_data[PLD_IRQ_CFC_EJECT].icucr = 0;
+	disable_mappi2_irq(PLD_IRQ_CFC_EJECT);
+
+#endif /* CONFIG_MAPPI2_CFC */
+}
diff -ruN linux-2.6.7.org/arch/m32r/kernel/setup_oaks32r.c linux-2.6.7/arch/m32r/kernel/setup_oaks32r.c
--- linux-2.6.7.org/arch/m32r/kernel/setup_oaks32r.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/setup_oaks32r.c	2004-04-06 22:01:10.000000000 +0900
@@ -0,0 +1,147 @@
+/*  
+ *  linux/arch/m32r/kernel/setup_oaks32r.c
+ *  
+ *  Setup routines for OAKS32R Board
+ *  
+ *  Copyright (c) 2002-2004   Hiroyuki Kondo, Hirokazu Takata, 
+ *                            Hitoshi Yamamoto, Mamoru Sakugawa
+ */
+
+static char *rcsid =
+"$Id: setup_oaks32r.c,v 1.1 2004/03/31 05:06:18 sakugawa Exp $";
+static void use_rcsid(void) {rcsid = rcsid; use_rcsid();}
+
+#include <linux/config.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/system.h>
+#include <asm/m32r.h>
+#include <asm/io.h>
+
+#define irq2port(x) (M32R_ICU_CR1_PORTL + ((x - 1) * sizeof(unsigned long)))
+
+#ifndef CONFIG_SMP
+typedef struct {
+	unsigned long icucr;  /* ICU Control Register */
+} icu_data_t;
+#endif /* CONFIG_SMP */
+
+icu_data_t icu_data[NR_IRQS];
+
+static void disable_oaks32r_irq(unsigned int irq)
+{
+	unsigned long port, data;
+	
+	port = irq2port(irq);
+	data = icu_data[irq].icucr|M32R_ICUCR_ILEVEL7;
+	outl(data, port);
+}
+
+static void enable_oaks32r_irq(unsigned int irq)
+{
+	unsigned long port, data;
+	
+	port = irq2port(irq);
+	data = icu_data[irq].icucr|M32R_ICUCR_IEN|M32R_ICUCR_ILEVEL6;
+	outl(data, port);
+}
+
+static void mask_and_ack_mappi(unsigned int irq)
+{
+	disable_oaks32r_irq(irq);
+}
+
+static void end_oaks32r_irq(unsigned int irq)
+{
+	enable_oaks32r_irq(irq);
+}
+
+static unsigned int startup_oaks32r_irq(unsigned int irq)
+{
+	enable_oaks32r_irq(irq);
+	return (0);
+}
+
+static void shutdown_oaks32r_irq(unsigned int irq)
+{
+	unsigned long port;
+	
+	port = irq2port(irq);
+	outl(M32R_ICUCR_ILEVEL7, port);
+}
+
+static struct hw_interrupt_type oaks32r_irq_type = 
+{
+	"OAKS32R-IRQ",
+	startup_oaks32r_irq,
+	shutdown_oaks32r_irq,
+	enable_oaks32r_irq,
+	disable_oaks32r_irq,
+	mask_and_ack_mappi,
+	end_oaks32r_irq
+};
+
+void __init init_IRQ(void)
+{
+	static int once = 0;
+
+	if (once)
+		return;
+	else
+		once++;
+
+#ifdef CONFIG_M32R_NE2000
+	/* INT3 : LAN controller (RTL8019AS) */
+	irq_desc[M32R_IRQ_INT3].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_INT3].handler = &oaks32r_irq_type;
+	irq_desc[M32R_IRQ_INT3].action = 0;
+	irq_desc[M32R_IRQ_INT3].depth = 1;
+	icu_data[M32R_IRQ_INT3].icucr = M32R_ICUCR_IEN|M32R_ICUCR_ISMOD10;
+	disable_oaks32r_irq(M32R_IRQ_INT3);
+#endif /* CONFIG_M32R_NE2000 */
+
+	/* MFT2 : system timer */
+	irq_desc[M32R_IRQ_MFT2].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_MFT2].handler = &oaks32r_irq_type;
+	irq_desc[M32R_IRQ_MFT2].action = 0;
+	irq_desc[M32R_IRQ_MFT2].depth = 1;
+	icu_data[M32R_IRQ_MFT2].icucr = M32R_ICUCR_IEN;
+	disable_oaks32r_irq(M32R_IRQ_MFT2);
+
+#ifdef CONFIG_SERIAL_M32R_SIO
+	/* SIO0_R : uart receive data */
+	irq_desc[M32R_IRQ_SIO0_R].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_SIO0_R].handler = &oaks32r_irq_type;
+	irq_desc[M32R_IRQ_SIO0_R].action = 0;
+	irq_desc[M32R_IRQ_SIO0_R].depth = 1;
+	icu_data[M32R_IRQ_SIO0_R].icucr = 0;
+	disable_oaks32r_irq(M32R_IRQ_SIO0_R);
+
+	/* SIO0_S : uart send data */
+	irq_desc[M32R_IRQ_SIO0_S].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_SIO0_S].handler = &oaks32r_irq_type;
+	irq_desc[M32R_IRQ_SIO0_S].action = 0;
+	irq_desc[M32R_IRQ_SIO0_S].depth = 1;
+	icu_data[M32R_IRQ_SIO0_S].icucr = 0;
+	disable_oaks32r_irq(M32R_IRQ_SIO0_S);
+
+	/* SIO1_R : uart receive data */
+	irq_desc[M32R_IRQ_SIO1_R].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_SIO1_R].handler = &oaks32r_irq_type;
+	irq_desc[M32R_IRQ_SIO1_R].action = 0;
+	irq_desc[M32R_IRQ_SIO1_R].depth = 1;
+	icu_data[M32R_IRQ_SIO1_R].icucr = 0;
+	disable_oaks32r_irq(M32R_IRQ_SIO1_R);
+
+	/* SIO1_S : uart send data */
+	irq_desc[M32R_IRQ_SIO1_S].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_SIO1_S].handler = &oaks32r_irq_type;
+	irq_desc[M32R_IRQ_SIO1_S].action = 0;
+	irq_desc[M32R_IRQ_SIO1_S].depth = 1;
+	icu_data[M32R_IRQ_SIO1_S].icucr = 0;
+	disable_oaks32r_irq(M32R_IRQ_SIO1_S);
+#endif /* CONFIG_SERIAL_M32R_SIO */
+
+}
diff -ruN linux-2.6.7.org/arch/m32r/kernel/setup_opsput.c linux-2.6.7/arch/m32r/kernel/setup_opsput.c
--- linux-2.6.7.org/arch/m32r/kernel/setup_opsput.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/setup_opsput.c	2004-07-27 15:54:20.000000000 +0900
@@ -0,0 +1,454 @@
+/*  
+ *  linux/arch/m32r/kernel/setup_opsput.c
+ *  
+ *  Setup routines for Renesas OPSPUT Board
+ *
+ *  Copyright (c) 2002-2004
+ * 	Hiroyuki Kondo, Hirokazu Takata, 
+ *      Hitoshi Yamamoto, Takeo Takahashi, Mamoru Sakugawa
+ *
+ *  This file is subject to the terms and conditions of the GNU General
+ *  Public License.  See the file "COPYING" in the main directory of this
+ *  archive for more details.
+ *
+ *  $Id: setup_opsput.c,v 1.1 2004/07/27 06:54:20 sakugawa Exp $
+ */
+
+#include <linux/config.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/system.h>
+#include <asm/m32r.h>
+#include <asm/io.h>
+
+/*
+ * OPSP Interrupt Control Unit (Level 1)
+ */
+#define irq2port(x) (M32R_ICU_CR1_PORTL + ((x - 1) * sizeof(unsigned long)))
+
+#ifndef CONFIG_SMP
+typedef struct {
+	unsigned long icucr;  /* ICU Control Register */
+} icu_data_t;
+#endif /* CONFIG_SMP */
+
+static icu_data_t icu_data[OPSPUT_NUM_CPU_IRQ];
+
+static void disable_opsput_irq(unsigned int irq)
+{
+	unsigned long port, data;
+	
+	port = irq2port(irq);
+	data = icu_data[irq].icucr|M32R_ICUCR_ILEVEL7;
+	outl(data, port);
+}
+
+static void enable_opsput_irq(unsigned int irq)
+{
+	unsigned long port, data;
+	
+	port = irq2port(irq);
+	data = icu_data[irq].icucr|M32R_ICUCR_IEN|M32R_ICUCR_ILEVEL6;
+	outl(data, port);
+}
+
+static void mask_and_ack_opsput(unsigned int irq)
+{
+	disable_opsput_irq(irq);
+}
+
+static void end_opsput_irq(unsigned int irq)
+{
+	enable_opsput_irq(irq);
+}
+
+static unsigned int startup_opsput_irq(unsigned int irq)
+{
+	enable_opsput_irq(irq);
+	return (0);
+}
+
+static void shutdown_opsput_irq(unsigned int irq)
+{
+	unsigned long port;
+	
+	port = irq2port(irq);
+	outl(M32R_ICUCR_ILEVEL7, port);
+}
+
+static struct hw_interrupt_type opsput_irq_type = 
+{
+	"OPSPUT-IRQ",
+	startup_opsput_irq,
+	shutdown_opsput_irq,
+	enable_opsput_irq,
+	disable_opsput_irq,
+	mask_and_ack_opsput,
+	end_opsput_irq
+};
+
+/*
+ * Interrupt Control Unit of PLD on OPSPUT (Level 2)
+ */
+#define irq2pldirq(x)		((x) - OPSPUT_PLD_IRQ_BASE)
+#define pldirq2port(x)		(unsigned long)((int)PLD_ICUCR1 + \
+				 (((x) - 1) * sizeof(unsigned short)))
+
+typedef struct {
+	unsigned short icucr;  /* ICU Control Register */
+} pld_icu_data_t;
+
+static pld_icu_data_t pld_icu_data[OPSPUT_NUM_PLD_IRQ];
+
+static void disable_opsput_pld_irq(unsigned int irq)
+{
+	unsigned long port, data; 
+	unsigned int pldirq;
+
+	pldirq = irq2pldirq(irq);
+//	disable_opsput_irq(M32R_IRQ_INT1);
+	port = pldirq2port(pldirq);
+	data = pld_icu_data[pldirq].icucr|PLD_ICUCR_ILEVEL7;
+	outw(data, port);
+}
+
+static void enable_opsput_pld_irq(unsigned int irq)
+{
+	unsigned long port, data;
+	unsigned int pldirq;
+
+	pldirq = irq2pldirq(irq);
+//	enable_opsput_irq(M32R_IRQ_INT1);
+	port = pldirq2port(pldirq);
+	data = pld_icu_data[pldirq].icucr|PLD_ICUCR_IEN|PLD_ICUCR_ILEVEL6;
+	outw(data, port);
+}
+
+static void mask_and_ack_opsput_pld(unsigned int irq)
+{
+	disable_opsput_pld_irq(irq);
+//	mask_and_ack_opsput(M32R_IRQ_INT1);
+}
+
+static void end_opsput_pld_irq(unsigned int irq)
+{
+	enable_opsput_pld_irq(irq);
+	end_opsput_irq(M32R_IRQ_INT1);
+}
+
+static unsigned int startup_opsput_pld_irq(unsigned int irq)
+{
+	enable_opsput_pld_irq(irq);
+	return (0);
+}
+
+static void shutdown_opsput_pld_irq(unsigned int irq)
+{
+	unsigned long port;
+	unsigned int pldirq;
+
+	pldirq = irq2pldirq(irq);
+//	shutdown_opsput_irq(M32R_IRQ_INT1);
+	port = pldirq2port(pldirq);
+	outw(PLD_ICUCR_ILEVEL7, port);
+}
+
+static struct hw_interrupt_type opsput_pld_irq_type =
+{
+	"OPSPUT-PLD-IRQ",
+	startup_opsput_pld_irq,
+	shutdown_opsput_pld_irq,
+	enable_opsput_pld_irq,
+	disable_opsput_pld_irq,
+	mask_and_ack_opsput_pld,
+	end_opsput_pld_irq
+};
+
+/*
+ * Interrupt Control Unit of PLD on OPSPUT-LAN (Level 2)
+ */
+#define irq2lanpldirq(x)	((x) - OPSPUT_LAN_PLD_IRQ_BASE)
+#define lanpldirq2port(x)	(unsigned long)((int)OPSPUT_LAN_ICUCR1 + \
+				 (((x) - 1) * sizeof(unsigned short)))
+
+static pld_icu_data_t lanpld_icu_data[OPSPUT_NUM_LAN_PLD_IRQ];
+
+static void disable_opsput_lanpld_irq(unsigned int irq)
+{
+	unsigned long port, data; 
+	unsigned int pldirq;
+
+	pldirq = irq2lanpldirq(irq);
+	port = lanpldirq2port(pldirq);
+	data = lanpld_icu_data[pldirq].icucr|PLD_ICUCR_ILEVEL7;
+	outw(data, port);
+}
+
+static void enable_opsput_lanpld_irq(unsigned int irq)
+{
+	unsigned long port, data;
+	unsigned int pldirq;
+
+	pldirq = irq2lanpldirq(irq);
+	port = lanpldirq2port(pldirq);
+	data = lanpld_icu_data[pldirq].icucr|PLD_ICUCR_IEN|PLD_ICUCR_ILEVEL6;
+	outw(data, port);
+}
+
+static void mask_and_ack_opsput_lanpld(unsigned int irq)
+{
+	disable_opsput_lanpld_irq(irq);
+}
+
+static void end_opsput_lanpld_irq(unsigned int irq)
+{
+	enable_opsput_lanpld_irq(irq);
+	end_opsput_irq(M32R_IRQ_INT0);
+}
+
+static unsigned int startup_opsput_lanpld_irq(unsigned int irq)
+{
+	enable_opsput_lanpld_irq(irq);
+	return (0);
+}
+
+static void shutdown_opsput_lanpld_irq(unsigned int irq)
+{
+	unsigned long port;
+	unsigned int pldirq;
+
+	pldirq = irq2lanpldirq(irq);
+	port = lanpldirq2port(pldirq);
+	outw(PLD_ICUCR_ILEVEL7, port);
+}
+
+static struct hw_interrupt_type opsput_lanpld_irq_type =
+{
+	"OPSPUT-PLD-LAN-IRQ",
+	startup_opsput_lanpld_irq,
+	shutdown_opsput_lanpld_irq,
+	enable_opsput_lanpld_irq,
+	disable_opsput_lanpld_irq,
+	mask_and_ack_opsput_lanpld,
+	end_opsput_lanpld_irq
+};
+
+/*
+ * Interrupt Control Unit of PLD on OPSPUT-LCD (Level 2)
+ */
+#define irq2lcdpldirq(x)	((x) - OPSPUT_LCD_PLD_IRQ_BASE)
+#define lcdpldirq2port(x)	(unsigned long)((int)OPSPUT_LCD_ICUCR1 + \
+				 (((x) - 1) * sizeof(unsigned short)))
+
+static pld_icu_data_t lcdpld_icu_data[OPSPUT_NUM_LCD_PLD_IRQ];
+
+static void disable_opsput_lcdpld_irq(unsigned int irq)
+{
+	unsigned long port, data; 
+	unsigned int pldirq;
+
+	pldirq = irq2lcdpldirq(irq);
+	port = lcdpldirq2port(pldirq);
+	data = lcdpld_icu_data[pldirq].icucr|PLD_ICUCR_ILEVEL7;
+	outw(data, port);
+}
+
+static void enable_opsput_lcdpld_irq(unsigned int irq)
+{
+	unsigned long port, data;
+	unsigned int pldirq;
+
+	pldirq = irq2lcdpldirq(irq);
+	port = lcdpldirq2port(pldirq);
+	data = lcdpld_icu_data[pldirq].icucr|PLD_ICUCR_IEN|PLD_ICUCR_ILEVEL6;
+	outw(data, port);
+}
+
+static void mask_and_ack_opsput_lcdpld(unsigned int irq)
+{
+	disable_opsput_lcdpld_irq(irq);
+}
+
+static void end_opsput_lcdpld_irq(unsigned int irq)
+{
+	enable_opsput_lcdpld_irq(irq);
+	end_opsput_irq(M32R_IRQ_INT2);
+}
+
+static unsigned int startup_opsput_lcdpld_irq(unsigned int irq)
+{
+	enable_opsput_lcdpld_irq(irq);
+	return (0);
+}
+
+static void shutdown_opsput_lcdpld_irq(unsigned int irq)
+{
+	unsigned long port;
+	unsigned int pldirq;
+
+	pldirq = irq2lcdpldirq(irq);
+	port = lcdpldirq2port(pldirq);
+	outw(PLD_ICUCR_ILEVEL7, port);
+}
+
+static struct hw_interrupt_type opsput_lcdpld_irq_type =
+{
+	"OPSPUT-PLD-LCD-IRQ",
+	startup_opsput_lcdpld_irq,
+	shutdown_opsput_lcdpld_irq,
+	enable_opsput_lcdpld_irq,
+	disable_opsput_lcdpld_irq,
+	mask_and_ack_opsput_lcdpld,
+	end_opsput_lcdpld_irq
+};
+
+void __init init_IRQ(void)
+{
+#ifdef CONFIG_M32R_SMC91111
+	/* INT#0: LAN controller on OPSPUT-LAN (SMC91C111)*/
+	irq_desc[OPSPUT_LAN_IRQ_LAN].status = IRQ_DISABLED;
+	irq_desc[OPSPUT_LAN_IRQ_LAN].handler = &opsput_lanpld_irq_type;
+	irq_desc[OPSPUT_LAN_IRQ_LAN].action = 0;
+	irq_desc[OPSPUT_LAN_IRQ_LAN].depth = 1;	/* disable nested irq */
+	lanpld_icu_data[irq2lanpldirq(OPSPUT_LAN_IRQ_LAN)].icucr = PLD_ICUCR_IEN|PLD_ICUCR_ISMOD02;	/* "H" edge sense */
+	disable_opsput_lanpld_irq(OPSPUT_LAN_IRQ_LAN);
+#endif  /* CONFIG_M32R_SMC91111 */
+
+	/* MFT2 : system timer */
+	irq_desc[M32R_IRQ_MFT2].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_MFT2].handler = &opsput_irq_type;
+	irq_desc[M32R_IRQ_MFT2].action = 0;
+	irq_desc[M32R_IRQ_MFT2].depth = 1;
+	icu_data[M32R_IRQ_MFT2].icucr = M32R_ICUCR_IEN;
+	disable_opsput_irq(M32R_IRQ_MFT2);
+	
+	/* SIO0 : receive */
+	irq_desc[M32R_IRQ_SIO0_R].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_SIO0_R].handler = &opsput_irq_type;
+	irq_desc[M32R_IRQ_SIO0_R].action = 0;
+	irq_desc[M32R_IRQ_SIO0_R].depth = 1;
+	icu_data[M32R_IRQ_SIO0_R].icucr = 0;
+	disable_opsput_irq(M32R_IRQ_SIO0_R);
+	
+	/* SIO0 : send */
+	irq_desc[M32R_IRQ_SIO0_S].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_SIO0_S].handler = &opsput_irq_type;
+	irq_desc[M32R_IRQ_SIO0_S].action = 0;
+	irq_desc[M32R_IRQ_SIO0_S].depth = 1;
+	icu_data[M32R_IRQ_SIO0_S].icucr = 0;
+	disable_opsput_irq(M32R_IRQ_SIO0_S);
+
+	/* SIO1 : receive */
+	irq_desc[M32R_IRQ_SIO1_R].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_SIO1_R].handler = &opsput_irq_type;
+	irq_desc[M32R_IRQ_SIO1_R].action = 0;
+	irq_desc[M32R_IRQ_SIO1_R].depth = 1;
+	icu_data[M32R_IRQ_SIO1_R].icucr = 0;
+	disable_opsput_irq(M32R_IRQ_SIO1_R);
+
+	/* SIO1 : send */
+	irq_desc[M32R_IRQ_SIO1_S].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_SIO1_S].handler = &opsput_irq_type;
+	irq_desc[M32R_IRQ_SIO1_S].action = 0;
+	irq_desc[M32R_IRQ_SIO1_S].depth = 1;
+	icu_data[M32R_IRQ_SIO1_S].icucr = 0;
+	disable_opsput_irq(M32R_IRQ_SIO1_S);
+
+	/* DMA1 : */
+	irq_desc[M32R_IRQ_DMA1].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_DMA1].handler = &opsput_irq_type;
+	irq_desc[M32R_IRQ_DMA1].action = 0;
+	irq_desc[M32R_IRQ_DMA1].depth = 1;
+	icu_data[M32R_IRQ_DMA1].icucr = 0;
+	disable_opsput_irq(M32R_IRQ_DMA1);
+
+#ifdef CONFIG_SERIAL_M32R_PLDSIO
+	/* INT#1: SIO0 Receive on PLD */
+	irq_desc[PLD_IRQ_SIO0_RCV].status = IRQ_DISABLED;
+	irq_desc[PLD_IRQ_SIO0_RCV].handler = &opsput_pld_irq_type;
+	irq_desc[PLD_IRQ_SIO0_RCV].action = 0;
+	irq_desc[PLD_IRQ_SIO0_RCV].depth = 1;	/* disable nested irq */
+	pld_icu_data[irq2pldirq(PLD_IRQ_SIO0_RCV)].icucr = PLD_ICUCR_IEN|PLD_ICUCR_ISMOD03;
+	disable_opsput_pld_irq(PLD_IRQ_SIO0_RCV);
+
+	/* INT#1: SIO0 Send on PLD */
+	irq_desc[PLD_IRQ_SIO0_SND].status = IRQ_DISABLED;
+	irq_desc[PLD_IRQ_SIO0_SND].handler = &opsput_pld_irq_type;
+	irq_desc[PLD_IRQ_SIO0_SND].action = 0;
+	irq_desc[PLD_IRQ_SIO0_SND].depth = 1;	/* disable nested irq */
+	pld_icu_data[irq2pldirq(PLD_IRQ_SIO0_SND)].icucr = PLD_ICUCR_IEN|PLD_ICUCR_ISMOD03;
+	disable_opsput_pld_irq(PLD_IRQ_SIO0_SND);
+#endif  /* CONFIG_SERIAL_M32R_PLDSIO */
+
+#if defined(CONFIG_M32R_CFC)
+	/* INT#1: CFC IREQ on PLD */
+	irq_desc[PLD_IRQ_CFIREQ].status = IRQ_DISABLED;
+	irq_desc[PLD_IRQ_CFIREQ].handler = &opsput_pld_irq_type;
+	irq_desc[PLD_IRQ_CFIREQ].action = 0;
+	irq_desc[PLD_IRQ_CFIREQ].depth = 1;	/* disable nested irq */
+	pld_icu_data[irq2pldirq(PLD_IRQ_CFIREQ)].icucr = PLD_ICUCR_IEN|PLD_ICUCR_ISMOD01;	/* 'L' level sense */
+	disable_opsput_pld_irq(PLD_IRQ_CFIREQ);
+
+	/* INT#1: CFC Insert on PLD */
+	irq_desc[PLD_IRQ_CFC_INSERT].status = IRQ_DISABLED;
+	irq_desc[PLD_IRQ_CFC_INSERT].handler = &opsput_pld_irq_type;
+	irq_desc[PLD_IRQ_CFC_INSERT].action = 0;
+	irq_desc[PLD_IRQ_CFC_INSERT].depth = 1;	/* disable nested irq */
+	pld_icu_data[irq2pldirq(PLD_IRQ_CFC_INSERT)].icucr = PLD_ICUCR_IEN|PLD_ICUCR_ISMOD00;	/* 'L' edge sense */
+	disable_opsput_pld_irq(PLD_IRQ_CFC_INSERT);
+
+	/* INT#1: CFC Eject on PLD */
+	irq_desc[PLD_IRQ_CFC_EJECT].status = IRQ_DISABLED;
+	irq_desc[PLD_IRQ_CFC_EJECT].handler = &opsput_pld_irq_type;
+	irq_desc[PLD_IRQ_CFC_EJECT].action = 0;
+	irq_desc[PLD_IRQ_CFC_EJECT].depth = 1;	/* disable nested irq */
+	pld_icu_data[irq2pldirq(PLD_IRQ_CFC_EJECT)].icucr = PLD_ICUCR_IEN|PLD_ICUCR_ISMOD02;	/* 'H' edge sense */
+	disable_opsput_pld_irq(PLD_IRQ_CFC_EJECT);
+#endif /* CONFIG_M32R_CFC */
+
+
+	/*
+	 * INT0# is used for LAN, DIO
+	 * We enable it here.
+	 */
+	icu_data[M32R_IRQ_INT0].icucr = M32R_ICUCR_IEN|M32R_ICUCR_ISMOD11;
+	enable_opsput_irq(M32R_IRQ_INT0);
+
+	/*
+	 * INT1# is used for UART, MMC, CF Controller in FPGA.
+	 * We enable it here.
+	 */
+	icu_data[M32R_IRQ_INT1].icucr = M32R_ICUCR_IEN|M32R_ICUCR_ISMOD11;
+	enable_opsput_irq(M32R_IRQ_INT1);
+
+#if defined(CONFIG_USB)
+	outw(USBCR_OTGS, USBCR); 	/* USBCR: non-OTG */
+
+    irq_desc[OPSPUT_LCD_IRQ_USB_INT1].status = IRQ_DISABLED;
+    irq_desc[OPSPUT_LCD_IRQ_USB_INT1].handler = &opsput_lcdpld_irq_type;
+    irq_desc[OPSPUT_LCD_IRQ_USB_INT1].action = 0;
+    irq_desc[OPSPUT_LCD_IRQ_USB_INT1].depth = 1;
+    lcdpld_icu_data[irq2lcdpldirq(OPSPUT_LCD_IRQ_USB_INT1)].icucr = PLD_ICUCR_IEN|PLD_ICUCR_ISMOD01;	/* "L" level sense */
+    disable_opsput_lcdpld_irq(OPSPUT_LCD_IRQ_USB_INT1);
+#endif 
+	/*
+	 * INT2# is used for BAT, USB, AUDIO
+	 * We enable it here.
+	 */
+	icu_data[M32R_IRQ_INT2].icucr = M32R_ICUCR_IEN|M32R_ICUCR_ISMOD01;
+	enable_opsput_irq(M32R_IRQ_INT2);
+
+//#if defined(CONFIG_M32R_AR_VGA)
+	/*
+	 * INT3# is used for AR 
+	 */
+	irq_desc[M32R_IRQ_INT3].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_INT3].handler = &opsput_irq_type;
+	irq_desc[M32R_IRQ_INT3].action = 0;
+	irq_desc[M32R_IRQ_INT3].depth = 1;
+	icu_data[M32R_IRQ_INT3].icucr = M32R_ICUCR_IEN|M32R_ICUCR_ISMOD10;
+	disable_opsput_irq(M32R_IRQ_INT3);
+//#endif	/* CONFIG_M32R_ARV */
+}
diff -ruN linux-2.6.7.org/arch/m32r/kernel/setup_usrv.c linux-2.6.7/arch/m32r/kernel/setup_usrv.c
--- linux-2.6.7.org/arch/m32r/kernel/setup_usrv.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/setup_usrv.c	2004-03-25 13:27:25.000000000 +0900
@@ -0,0 +1,260 @@
+/*  
+ *  linux/arch/m32r/kernel/setup_usrv.c
+ *  
+ *  Setup routines for MITSUBISHI uServer
+ *  
+ *  Copyright (c) 2001, 2002, 2003  Hiroyuki Kondo, Hirokazu Takata, 
+ *                                  Hitoshi Yamamoto
+ */
+
+static char *rcsid =
+"$Id$";
+static void use_rcsid(void) {rcsid = rcsid; use_rcsid();}
+
+#include <linux/config.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/system.h>
+#include <asm/m32r.h>
+#include <asm/io.h>
+
+#define irq2port(x) (M32R_ICU_CR1_PORTL + ((x - 1) * sizeof(unsigned long)))
+
+#if !defined(CONFIG_SMP)
+typedef struct {
+	unsigned long icucr;	/* ICU Control Register */
+} icu_data_t;
+#endif /* CONFIG_SMP */
+
+icu_data_t icu_data[M32700UT_NUM_CPU_IRQ];
+
+static void disable_mappi_irq(unsigned int irq)
+{
+	unsigned long port, data;
+	
+	port = irq2port(irq);
+	data = icu_data[irq].icucr|M32R_ICUCR_ILEVEL7;
+	outl(data, port);
+}
+
+static void enable_mappi_irq(unsigned int irq)
+{
+	unsigned long port, data;
+	
+	port = irq2port(irq);
+	data = icu_data[irq].icucr|M32R_ICUCR_IEN|M32R_ICUCR_ILEVEL6;
+	outl(data, port);
+}
+
+static void mask_and_ack_mappi(unsigned int irq)
+{
+	disable_mappi_irq(irq);
+}
+
+static void end_mappi_irq(unsigned int irq)
+{
+	enable_mappi_irq(irq);
+}
+
+static unsigned int startup_mappi_irq(unsigned int irq)
+{
+	enable_mappi_irq(irq);
+	return 0;
+}
+
+static void shutdown_mappi_irq(unsigned int irq)
+{
+	unsigned long port;
+	
+	port = irq2port(irq);
+	outl(M32R_ICUCR_ILEVEL7, port);
+}
+
+static struct hw_interrupt_type mappi_irq_type = 
+{
+	"M32700-IRQ",
+	startup_mappi_irq,
+	shutdown_mappi_irq,
+	enable_mappi_irq,
+	disable_mappi_irq,
+	mask_and_ack_mappi,
+	end_mappi_irq
+};
+
+/*
+ * Interrupt Control Unit of PLD on M32700UT (Level 2)
+ */
+#define irq2pldirq(x)		((x) - M32700UT_PLD_IRQ_BASE)
+#define pldirq2port(x)		(unsigned long)((int)PLD_ICUCR1 + \
+				 (((x) - 1) * sizeof(unsigned short)))
+
+typedef struct {
+	unsigned short icucr;  /* ICU Control Register */
+} pld_icu_data_t;
+
+static pld_icu_data_t pld_icu_data[M32700UT_NUM_PLD_IRQ];
+
+static void disable_m32700ut_pld_irq(unsigned int irq)
+{
+	unsigned long port, data; 
+	unsigned int pldirq;
+
+	pldirq = irq2pldirq(irq);
+	port = pldirq2port(pldirq);
+	data = pld_icu_data[pldirq].icucr|PLD_ICUCR_ILEVEL7;
+	outw(data, port);
+}
+
+static void enable_m32700ut_pld_irq(unsigned int irq)
+{
+	unsigned long port, data;
+	unsigned int pldirq;
+
+	pldirq = irq2pldirq(irq);
+	port = pldirq2port(pldirq);
+	data = pld_icu_data[pldirq].icucr|PLD_ICUCR_IEN|PLD_ICUCR_ILEVEL6;
+	outw(data, port);
+}
+
+static void mask_and_ack_m32700ut_pld(unsigned int irq)
+{
+	disable_m32700ut_pld_irq(irq);
+}
+
+static void end_m32700ut_pld_irq(unsigned int irq)
+{
+	enable_m32700ut_pld_irq(irq);
+	end_mappi_irq(M32R_IRQ_INT1);
+}
+
+static unsigned int startup_m32700ut_pld_irq(unsigned int irq)
+{
+	enable_m32700ut_pld_irq(irq);
+	return 0;
+}
+
+static void shutdown_m32700ut_pld_irq(unsigned int irq)
+{
+	unsigned long port;
+	unsigned int pldirq;
+
+	pldirq = irq2pldirq(irq);
+	port = pldirq2port(pldirq);
+	outw(PLD_ICUCR_ILEVEL7, port);
+}
+
+static struct hw_interrupt_type m32700ut_pld_irq_type =
+{
+	"USRV-PLD-IRQ",
+	startup_m32700ut_pld_irq,
+	shutdown_m32700ut_pld_irq,
+	enable_m32700ut_pld_irq,
+	disable_m32700ut_pld_irq,
+	mask_and_ack_m32700ut_pld,
+	end_m32700ut_pld_irq
+};
+
+void __init init_IRQ(void)
+{
+	static int once = 0;
+	int i;
+
+	if (once)
+		return;
+	else
+		once++;
+
+	/* MFT2 : system timer */
+	irq_desc[M32R_IRQ_MFT2].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_MFT2].handler = &mappi_irq_type;
+	irq_desc[M32R_IRQ_MFT2].action = 0;
+	irq_desc[M32R_IRQ_MFT2].depth = 1;
+	icu_data[M32R_IRQ_MFT2].icucr = M32R_ICUCR_IEN;
+	disable_mappi_irq(M32R_IRQ_MFT2);
+
+#if defined(CONFIG_SERIAL_M32R_SIO)
+	/* SIO0_R : uart receive data */
+	irq_desc[M32R_IRQ_SIO0_R].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_SIO0_R].handler = &mappi_irq_type;
+	irq_desc[M32R_IRQ_SIO0_R].action = 0;
+	irq_desc[M32R_IRQ_SIO0_R].depth = 1;
+	icu_data[M32R_IRQ_SIO0_R].icucr = 0;
+	disable_mappi_irq(M32R_IRQ_SIO0_R);
+
+	/* SIO0_S : uart send data */
+	irq_desc[M32R_IRQ_SIO0_S].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_SIO0_S].handler = &mappi_irq_type;
+	irq_desc[M32R_IRQ_SIO0_S].action = 0;
+	irq_desc[M32R_IRQ_SIO0_S].depth = 1;
+	icu_data[M32R_IRQ_SIO0_S].icucr = 0;
+	disable_mappi_irq(M32R_IRQ_SIO0_S);
+
+	/* SIO1_R : uart receive data */
+	irq_desc[M32R_IRQ_SIO1_R].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_SIO1_R].handler = &mappi_irq_type;
+	irq_desc[M32R_IRQ_SIO1_R].action = 0;
+	irq_desc[M32R_IRQ_SIO1_R].depth = 1;
+	icu_data[M32R_IRQ_SIO1_R].icucr = 0;
+	disable_mappi_irq(M32R_IRQ_SIO1_R);
+
+	/* SIO1_S : uart send data */
+	irq_desc[M32R_IRQ_SIO1_S].status = IRQ_DISABLED;
+	irq_desc[M32R_IRQ_SIO1_S].handler = &mappi_irq_type;
+	irq_desc[M32R_IRQ_SIO1_S].action = 0;
+	irq_desc[M32R_IRQ_SIO1_S].depth = 1;
+	icu_data[M32R_IRQ_SIO1_S].icucr = 0;
+	disable_mappi_irq(M32R_IRQ_SIO1_S);
+#endif  /* CONFIG_SERIAL_M32R_SIO */
+
+	/* INT#67-#71: CFC#0 IREQ on PLD */
+	for (i = 0 ; i < CONFIG_CFC_NUM ; i++ ) {
+		irq_desc[PLD_IRQ_CF0 + i].status = IRQ_DISABLED;
+		irq_desc[PLD_IRQ_CF0 + i].handler = &m32700ut_pld_irq_type;
+		irq_desc[PLD_IRQ_CF0 + i].action = 0;
+		irq_desc[PLD_IRQ_CF0 + i].depth = 1;	/* disable nested irq */
+		pld_icu_data[irq2pldirq(PLD_IRQ_CF0 + i)].icucr 
+			= PLD_ICUCR_ISMOD01;	/* 'L' level sense */
+		disable_m32700ut_pld_irq(PLD_IRQ_CF0 + i);
+	}
+
+#if defined(CONFIG_SERIAL_8250) || defined(CONFIG_SERIAL_8250_MODULE)
+	/* INT#76: 16552D#0 IREQ on PLD */
+	irq_desc[PLD_IRQ_UART0].status = IRQ_DISABLED;
+	irq_desc[PLD_IRQ_UART0].handler = &m32700ut_pld_irq_type;
+	irq_desc[PLD_IRQ_UART0].action = 0;
+	irq_desc[PLD_IRQ_UART0].depth = 1;	/* disable nested irq */
+	pld_icu_data[irq2pldirq(PLD_IRQ_UART0)].icucr 
+		= PLD_ICUCR_ISMOD03;	/* 'H' level sense */
+	disable_m32700ut_pld_irq(PLD_IRQ_UART0);
+
+	/* INT#77: 16552D#1 IREQ on PLD */
+	irq_desc[PLD_IRQ_UART1].status = IRQ_DISABLED;
+	irq_desc[PLD_IRQ_UART1].handler = &m32700ut_pld_irq_type;
+	irq_desc[PLD_IRQ_UART1].action = 0;
+	irq_desc[PLD_IRQ_UART1].depth = 1;	/* disable nested irq */
+	pld_icu_data[irq2pldirq(PLD_IRQ_UART1)].icucr 
+		= PLD_ICUCR_ISMOD03;	/* 'H' level sense */
+	disable_m32700ut_pld_irq(PLD_IRQ_UART1);
+#endif	/* CONFIG_SERIAL_8250 || CONFIG_SERIAL_8250_MODULE */
+
+#if defined(CONFIG_IDC_AK4524) || defined(CONFIG_IDC_AK4524_MODULE)
+	/* INT#80: AK4524 IREQ on PLD */
+	irq_desc[PLD_IRQ_SNDINT].status = IRQ_DISABLED;
+	irq_desc[PLD_IRQ_SNDINT].handler = &m32700ut_pld_irq_type;
+	irq_desc[PLD_IRQ_SNDINT].action = 0;
+	irq_desc[PLD_IRQ_SNDINT].depth = 1;	/* disable nested irq */
+	pld_icu_data[irq2pldirq(PLD_IRQ_SNDINT)].icucr 
+		= PLD_ICUCR_ISMOD01;	/* 'L' level sense */
+	disable_m32700ut_pld_irq(PLD_IRQ_SNDINT);
+#endif	/* CONFIG_IDC_AK4524 || CONFIG_IDC_AK4524_MODULE */
+
+	/*
+	 * INT1# is used for UART, MMC, CF Controller in FPGA.
+	 * We enable it here.
+	 */
+	icu_data[M32R_IRQ_INT1].icucr = M32R_ICUCR_ISMOD11;
+	enable_mappi_irq(M32R_IRQ_INT1);
+}
+
diff -ruN linux-2.6.7.org/arch/m32r/kernel/signal.c linux-2.6.7/arch/m32r/kernel/signal.c
--- linux-2.6.7.org/arch/m32r/kernel/signal.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/signal.c	2004-07-15 13:43:14.000000000 +0900
@@ -0,0 +1,620 @@
+/*
+ *  linux/arch/m32r/kernel/signal.c
+ *    orig : i386 2.5.67
+ *
+ *  Copyright (c) 2003  Hitoshi Yamamoto
+ *  
+ *  Taken from i386 version.
+ *  Copyright (C) 1991, 1992  Linus Torvalds
+ *
+ *  1997-11-28  Modified for POSIX.1b signals by Richard Henderson
+ *  2000-06-20  Pentium III FXSR, SSE support by Gareth Hughes
+ */
+
+#include <linux/config.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+#include <linux/kernel.h>
+#include <linux/signal.h>
+#include <linux/errno.h>
+#include <linux/wait.h>
+#include <linux/unistd.h>
+#include <linux/stddef.h>
+#include <linux/personality.h>
+#include <linux/suspend.h>
+#include <asm/cacheflush.h>
+#include <asm/ucontext.h>
+#include <asm/uaccess.h>
+
+#define DEBUG_SIG 0
+
+#define _BLOCKABLE (~(sigmask(SIGKILL) | sigmask(SIGSTOP)))
+
+int do_signal(struct pt_regs *, sigset_t *);
+
+/*
+ * Atomically swap in the new signal mask, and wait for a signal.
+ */
+asmlinkage int sys_sigsuspend(old_sigset_t mask, unsigned long r1, 
+	unsigned long r2, unsigned long r3, unsigned long r4, 
+	unsigned long r5, unsigned long r6, struct pt_regs regs)
+{
+	sigset_t saveset;
+
+	mask &= _BLOCKABLE;
+	spin_lock_irq(&current->sighand->siglock);
+	saveset = current->blocked;
+	siginitset(&current->blocked, mask);
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
+
+	regs.r0 = -EINTR;
+	while (1) {
+		current->state = TASK_INTERRUPTIBLE;
+		schedule();
+		if (do_signal(&regs, &saveset))
+			return regs.r0;
+	}
+}
+
+asmlinkage int sys_rt_sigsuspend(sigset_t *unewset, size_t sigsetsize, 
+	unsigned long r2, unsigned long r3, unsigned long r4, 
+	unsigned long r5, unsigned long r6, struct pt_regs regs)
+{
+	sigset_t saveset, newset;
+
+	/* XXX: Don't preclude handling different sized sigset_t's.  */
+	if (sigsetsize != sizeof(sigset_t))
+		return -EINVAL;
+
+	if (copy_from_user(&newset, unewset, sizeof(newset)))
+		return -EFAULT;
+	sigdelsetmask(&newset, ~_BLOCKABLE);
+
+	spin_lock_irq(&current->sighand->siglock);
+	saveset = current->blocked;
+	current->blocked = newset;
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
+
+	regs.r0 = -EINTR;
+	while (1) {
+		current->state = TASK_INTERRUPTIBLE;
+		schedule();
+		if (do_signal(&regs, &saveset))
+			return regs.r0;
+	}
+}
+
+asmlinkage int sys_sigaction(int sig, const struct old_sigaction __user *act,
+	      struct old_sigaction __user *oact)
+{
+	struct k_sigaction new_ka, old_ka;
+	int ret;
+
+	if (act) {
+		old_sigset_t mask;
+		if (verify_area(VERIFY_READ, act, sizeof(*act)) ||
+		    __get_user(new_ka.sa.sa_handler, &act->sa_handler) ||
+		    __get_user(new_ka.sa.sa_restorer, &act->sa_restorer))
+			return -EFAULT;
+		__get_user(new_ka.sa.sa_flags, &act->sa_flags);
+		__get_user(mask, &act->sa_mask);
+		siginitset(&new_ka.sa.sa_mask, mask);
+	}
+
+	ret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);
+
+	if (!ret && oact) {
+		if (verify_area(VERIFY_WRITE, oact, sizeof(*oact)) ||
+		    __put_user(old_ka.sa.sa_handler, &oact->sa_handler) ||
+		    __put_user(old_ka.sa.sa_restorer, &oact->sa_restorer))
+			return -EFAULT;
+		__put_user(old_ka.sa.sa_flags, &oact->sa_flags);
+		__put_user(old_ka.sa.sa_mask.sig[0], &oact->sa_mask);
+	}
+
+	return ret;
+}
+
+asmlinkage int sys_sigaltstack(const stack_t __user *uss, stack_t __user *uoss, 
+	unsigned long r2, unsigned long r3, unsigned long r4, 
+	unsigned long r5, unsigned long r6, struct pt_regs regs)
+{
+	return do_sigaltstack(uss, uoss, regs.spu);
+}
+
+
+/*
+ * Do a signal return; undo the signal stack.
+ */
+
+struct sigframe
+{
+//	char *pretcode;
+	int sig;
+	struct sigcontext sc;
+//	struct _fpstate fpstate;
+	unsigned long extramask[_NSIG_WORDS-1];
+	char retcode[4];
+};
+
+struct rt_sigframe
+{
+//	char *pretcode;
+	int sig;
+	struct siginfo *pinfo;
+	void *puc;
+	struct siginfo info;
+	struct ucontext uc;
+//	struct _fpstate fpstate;
+	char retcode[8];
+};
+
+static int restore_sigcontext(struct pt_regs *regs, struct sigcontext __user *sc, 
+	int *r0_p)
+{
+	unsigned int err = 0;
+
+	/* Always make any pending restarted system calls return -EINTR */
+	current_thread_info()->restart_block.fn = do_no_restart_syscall;
+
+#define COPY(x)		err |= __get_user(regs->x, &sc->sc_##x)
+	COPY(r4);
+	COPY(r5);
+	COPY(r6);
+	COPY(pt_regs);
+	/* COPY(r0); Skip r0 */
+	COPY(r1);
+	COPY(r2);
+	COPY(r3);
+	COPY(r7);
+	COPY(r8);
+	COPY(r9);
+	COPY(r10);
+	COPY(r11);
+	COPY(r12);
+#if defined(CONFIG_ISA_M32R2) && defined(CONFIG_ISA_DSP_LEVEL2)
+	COPY(acc0h);
+	COPY(acc0l);
+	COPY(acc1h);
+	COPY(acc1l);
+#elif defined(CONFIG_ISA_M32R2) || defined(CONFIG_ISA_M32R)
+	COPY(acch);
+	COPY(accl);
+#else
+#error unknown isa configuration
+#endif
+	COPY(psw);
+	COPY(bpc);
+	COPY(bbpsw);
+	COPY(bbpc);
+	COPY(spu);
+	COPY(fp);
+	COPY(lr);
+	COPY(spi);
+#undef COPY
+
+	regs->syscall_nr = -1;	/* disable syscall checks */
+	err |= __get_user(*r0_p, &sc->sc_r0);
+
+	return err;
+}
+
+asmlinkage int sys_sigreturn(unsigned long r0, unsigned long r1, 
+	unsigned long r2, unsigned long r3, unsigned long r4, 
+	unsigned long r5, unsigned long r6, struct pt_regs regs)
+{
+	struct sigframe __user *frame = (struct sigframe __user *)regs.spu;
+	sigset_t set;
+	int result;
+
+	if (verify_area(VERIFY_READ, frame, sizeof(*frame)))
+		goto badframe;
+	if (__get_user(set.sig[0], &frame->sc.oldmask)
+	    || (_NSIG_WORDS > 1
+		&& __copy_from_user(&set.sig[1], &frame->extramask,
+				    sizeof(frame->extramask))))
+		goto badframe;
+
+	sigdelsetmask(&set, ~_BLOCKABLE);
+	spin_lock_irq(&current->sighand->siglock);
+	current->blocked = set;
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
+	
+	if (restore_sigcontext(&regs, &frame->sc, &result))
+		goto badframe;
+	return result;
+
+badframe:
+	force_sig(SIGSEGV, current);
+	return 0;
+}	
+
+asmlinkage int sys_rt_sigreturn(unsigned long r0, unsigned long r1, 
+	unsigned long r2, unsigned long r3, unsigned long r4, 
+	unsigned long r5, unsigned long r6, struct pt_regs regs)
+{
+	struct rt_sigframe __user *frame = (struct rt_sigframe __user *)regs.spu;
+	sigset_t set;
+	stack_t st;
+	int result;
+
+	if (verify_area(VERIFY_READ, frame, sizeof(*frame)))
+		goto badframe;
+	if (__copy_from_user(&set, &frame->uc.uc_sigmask, sizeof(set)))
+		goto badframe;
+
+	sigdelsetmask(&set, ~_BLOCKABLE);
+	spin_lock_irq(&current->sighand->siglock);
+	current->blocked = set;
+	recalc_sigpending();
+	spin_unlock_irq(&current->sighand->siglock);
+	
+	if (restore_sigcontext(&regs, &frame->uc.uc_mcontext, &result))
+		goto badframe;
+
+	if (__copy_from_user(&st, &frame->uc.uc_stack, sizeof(st)))
+		goto badframe;
+	/* It is more difficult to avoid calling this function than to
+	   call it and ignore errors.  */
+	do_sigaltstack(&st, NULL, regs.spu);
+
+	return result;
+
+badframe:
+	force_sig(SIGSEGV, current);
+	return 0;
+}	
+
+/*
+ * Set up a signal frame.
+ */
+
+static int setup_sigcontext(struct sigcontext __user *sc, struct pt_regs *regs,
+	unsigned long mask)
+{
+	int err = 0;
+
+#define COPY(x)	err |= __put_user(regs->x, &sc->sc_##x)
+	COPY(r4);
+	COPY(r5);
+	COPY(r6);
+	COPY(pt_regs);
+	COPY(r0);
+	COPY(r1);
+	COPY(r2);
+	COPY(r3);
+	COPY(r7);
+	COPY(r8);
+	COPY(r9);
+	COPY(r10);
+	COPY(r11);
+	COPY(r12);
+#if defined(CONFIG_ISA_M32R2) && defined(CONFIG_ISA_DSP_LEVEL2)
+	COPY(acc0h);
+	COPY(acc0l);
+	COPY(acc1h);
+	COPY(acc1l);
+#elif defined(CONFIG_ISA_M32R2) || defined(CONFIG_ISA_M32R)
+	COPY(acch);
+	COPY(accl);
+#else
+#error unknown isa configuration
+#endif
+	COPY(psw);
+	COPY(bpc);
+	COPY(bbpsw);
+	COPY(bbpc);
+	COPY(spu);
+	COPY(fp);
+	COPY(lr);
+	COPY(spi);
+#undef COPY
+
+	err |= __put_user(mask, &sc->oldmask);
+
+	return err;
+}
+
+/*
+ * Determine which stack to use..
+ */
+static __inline__ void __user *get_sigframe(struct k_sigaction *ka, unsigned long sp, 
+	size_t frame_size)
+{
+	/* This is the X/Open sanctioned signal stack switching.  */
+	if (ka->sa.sa_flags & SA_ONSTACK) {
+		if (sas_ss_flags(sp) == 0)
+			sp = current->sas_ss_sp + current->sas_ss_size;
+	}
+
+	return (void __user *)((sp - frame_size) & -8ul);
+}
+
+static void setup_frame(int sig, struct k_sigaction *ka, 
+	sigset_t *set, struct pt_regs *regs)
+{
+	struct sigframe __user *frame;
+	int err = 0;
+	int signal;
+
+	frame = get_sigframe(ka, regs->spu, sizeof(*frame));
+
+	if (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))
+		goto give_sigsegv;
+
+	signal = current_thread_info()->exec_domain
+		&& current_thread_info()->exec_domain->signal_invmap
+		&& sig < 32
+		? current_thread_info()->exec_domain->signal_invmap[sig]
+		: sig;
+
+	err |= __put_user(signal, &frame->sig);
+	if (err)
+		goto give_sigsegv;
+
+	err |= setup_sigcontext(&frame->sc, regs, set->sig[0]);
+	if (err)
+		goto give_sigsegv;
+
+	if (_NSIG_WORDS > 1) {
+		err |= __copy_to_user(frame->extramask, &set->sig[1],
+				      sizeof(frame->extramask));
+		if (err)
+			goto give_sigsegv;
+	}
+
+	if (ka->sa.sa_flags & SA_RESTORER)
+		regs->lr = (unsigned long)ka->sa.sa_restorer;
+	else {
+		/* This is : ldi r7, #__NR_sigreturn ; trap #2 */
+		unsigned long code = 0x670010f2 | (__NR_sigreturn << 16);
+
+		regs->lr = (unsigned long)frame->retcode;
+		err |= __put_user(code, (long __user *)(frame->retcode+0));
+		if (err)
+			goto give_sigsegv;
+		flush_cache_sigtramp((unsigned long)frame->retcode);
+	}
+
+	/* Set up registers for signal handler */
+	regs->spu = (unsigned long)frame;
+	regs->r0 = signal;	/* Arg for signal handler */
+	regs->r1 = (unsigned long)&frame->sc;
+	regs->bpc = (unsigned long)ka->sa.sa_handler;
+
+	set_fs(USER_DS);
+
+#if DEBUG_SIG
+	printk("SIG deliver (%s:%d): sp=%p pc=%p\n",
+		current->comm, current->pid, frame, regs->pc);
+#endif
+
+	return;
+
+give_sigsegv:
+	if (sig == SIGSEGV)
+		ka->sa.sa_handler = SIG_DFL;
+	force_sig(SIGSEGV, current);
+}
+
+static void setup_rt_frame(int sig, struct k_sigaction *ka, siginfo_t *info, 
+	sigset_t *set, struct pt_regs *regs)
+{
+	struct rt_sigframe __user *frame;
+	int err = 0;
+	int signal;
+
+	frame = get_sigframe(ka, regs->spu, sizeof(*frame));
+
+	if (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))
+		goto give_sigsegv;
+
+	signal = current_thread_info()->exec_domain
+		&& current_thread_info()->exec_domain->signal_invmap
+		&& sig < 32
+		? current_thread_info()->exec_domain->signal_invmap[sig]
+		: sig;
+
+	err |= __put_user(signal, &frame->sig);
+	if (err)
+		goto give_sigsegv;
+
+	err |= __put_user(&frame->info, &frame->pinfo);
+	err |= __put_user(&frame->uc, &frame->puc);
+	err |= copy_siginfo_to_user(&frame->info, info);
+	if (err)
+		goto give_sigsegv;
+
+	/* Create the ucontext.  */
+	err |= __put_user(0, &frame->uc.uc_flags);
+	err |= __put_user(0, &frame->uc.uc_link);
+	err |= __put_user(current->sas_ss_sp, &frame->uc.uc_stack.ss_sp);
+	err |= __put_user(sas_ss_flags(regs->spu),
+			  &frame->uc.uc_stack.ss_flags);
+	err |= __put_user(current->sas_ss_size, &frame->uc.uc_stack.ss_size);
+	err |= setup_sigcontext(&frame->uc.uc_mcontext, regs, set->sig[0]);
+	err |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));
+	if (err)
+		goto give_sigsegv;
+
+	/* Set up to return from userspace.  */
+	if (ka->sa.sa_flags & SA_RESTORER)
+		regs->lr = (unsigned long)ka->sa.sa_restorer;
+	else {
+		/* This is : ldi r7, #__NR_rt_sigreturn ; trap #2 */
+		unsigned long code1 = 0x97f00000 | (__NR_rt_sigreturn);
+		unsigned long code2 = 0x10f2f000;
+
+		regs->lr = (unsigned long)frame->retcode;
+		err |= __put_user(code1, (long __user *)(frame->retcode+0));
+		err |= __put_user(code2, (long __user *)(frame->retcode+4));
+		if (err)
+			goto give_sigsegv;
+		flush_cache_sigtramp((unsigned long)frame->retcode);
+	}
+
+	/* Set up registers for signal handler */
+	regs->spu = (unsigned long)frame;
+	regs->r0 = signal;	/* Arg for signal handler */
+	regs->r1 = (unsigned long)&frame->info;
+	regs->r2 = (unsigned long)&frame->uc;
+	regs->bpc = (unsigned long)ka->sa.sa_handler;
+
+	set_fs(USER_DS);
+
+#if DEBUG_SIG
+	printk("SIG deliver (%s:%d): sp=%p pc=%p\n",
+		current->comm, current->pid, frame, regs->pc);
+#endif
+
+	return;
+
+give_sigsegv:
+	if (sig == SIGSEGV)
+		ka->sa.sa_handler = SIG_DFL;
+	force_sig(SIGSEGV, current);
+}
+
+/*
+ * OK, we're invoking a handler
+ */	
+
+static void handle_signal(unsigned long sig, siginfo_t *info, sigset_t *oldset,
+	struct pt_regs *regs)
+{
+	struct k_sigaction *ka = &current->sighand->action[sig-1];
+	unsigned short inst;
+
+	/* Are we from a system call? */
+	if (regs->syscall_nr >= 0) {
+		/* If so, check system call restarting.. */
+		switch (regs->r0) {
+		        case -ERESTART_RESTARTBLOCK:
+			case -ERESTARTNOHAND:
+				regs->r0 = -EINTR;
+				break;
+
+			case -ERESTARTSYS:
+				if (!(ka->sa.sa_flags & SA_RESTART)) {
+					regs->r0 = -EINTR;
+					break;
+				}
+			/* fallthrough */
+			case -ERESTARTNOINTR:
+				regs->r0 = regs->orig_r0;
+				inst = *(unsigned short *)(regs->bpc - 2);
+				if ((inst & 0xfff0) == 0x10f0)	/* trap ? */
+					regs->bpc -= 2;
+				else
+					regs->bpc -= 4;
+		}
+	}
+
+	/* Set up the stack frame */
+	if (ka->sa.sa_flags & SA_SIGINFO)
+		setup_rt_frame(sig, ka, info, oldset, regs);
+	else
+		setup_frame(sig, ka, oldset, regs);
+
+	if (ka->sa.sa_flags & SA_ONESHOT)
+		ka->sa.sa_handler = SIG_DFL;
+
+	if (!(ka->sa.sa_flags & SA_NODEFER)) {
+		spin_lock_irq(&current->sighand->siglock);
+		sigorsets(&current->blocked,&current->blocked,&ka->sa.sa_mask);
+		sigaddset(&current->blocked,sig);
+		recalc_sigpending();
+		spin_unlock_irq(&current->sighand->siglock);
+	}
+}
+
+/*
+ * Note that 'init' is a special process: it doesn't get signals it doesn't
+ * want to handle. Thus you cannot kill init even with a SIGKILL even by
+ * mistake.
+ */
+int do_signal(struct pt_regs *regs, sigset_t *oldset)
+{
+	siginfo_t info;
+	int signr;
+	unsigned short inst;
+
+	/*
+	 * We want the common case to go fast, which
+	 * is why we may in certain cases get here from
+	 * kernel mode. Just return without doing anything
+	 * if so.
+	 */
+	if (!user_mode(regs))
+		return 1;
+
+	if (current->flags & PF_FREEZE) {
+		refrigerator(0);
+		goto no_signal;
+	}
+
+	if (!oldset)
+		oldset = &current->blocked;
+
+	signr = get_signal_to_deliver(&info, regs, NULL);
+	if (signr > 0) {
+		/* Reenable any watchpoints before delivering the
+		 * signal to user space. The processor register will
+		 * have been cleared if the watchpoint triggered
+		 * inside the kernel.
+		 */
+
+		/* Whee!  Actually deliver the signal.  */
+		handle_signal(signr, &info, oldset, regs);
+		return 1;
+	}
+
+ no_signal:
+	/* Did we come from a system call? */
+	if (regs->syscall_nr >= 0) {
+		/* Restart the system call - no handlers present */
+		if (regs->r0 == -ERESTARTNOHAND ||
+		    regs->r0 == -ERESTARTSYS ||
+		    regs->r0 == -ERESTARTNOINTR) {
+			regs->r0 = regs->orig_r0;
+			inst = *(unsigned short *)(regs->bpc - 2);
+			if ((inst & 0xfff0) == 0x10f0)	/* trap ? */
+				regs->bpc -= 2;
+			else
+				regs->bpc -= 4;
+		}
+		if (regs->r0 == -ERESTART_RESTARTBLOCK){
+			regs->r0 = regs->orig_r0;
+			regs->r7 = __NR_restart_syscall;
+			inst = *(unsigned short *)(regs->bpc - 2);
+			if ((inst & 0xfff0) == 0x10f0)	/* trap ? */
+				regs->bpc -= 2;
+			else
+				regs->bpc -= 4;
+		}
+	}
+	return 0;
+}
+
+/*
+ * notification of userspace execution resumption
+ * - triggered by current->work.notify_resume
+ */
+void do_notify_resume(struct pt_regs *regs, sigset_t *oldset,
+		      __u32 thread_info_flags)
+{
+	/* Pending single-step? */
+	if (thread_info_flags & _TIF_SINGLESTEP)
+		clear_thread_flag(TIF_SINGLESTEP);
+
+	/* deal with pending signal delivery */
+	if (thread_info_flags & _TIF_SIGPENDING)
+		do_signal(regs,oldset);
+	
+	clear_thread_flag(TIF_IRET);
+}
diff -ruN linux-2.6.7.org/arch/m32r/kernel/smp.c linux-2.6.7/arch/m32r/kernel/smp.c
--- linux-2.6.7.org/arch/m32r/kernel/smp.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/smp.c	2004-08-27 17:18:48.000000000 +0900
@@ -0,0 +1,940 @@
+/*  
+ *  linux/arch/m32r/kernel/smp.c
+ *    orig : i386 2.4.10
+ *  
+ *  MITSUBISHI M32R SMP support routines.
+ *  
+ *  Copyright (c) 2001, 2002  Hitoshi Yamamoto
+ *  
+ *  Taken from i386 version.
+ *    (c) 1995 Alan Cox, Building #3 <alan@redhat.com>
+ *    (c) 1998-99, 2000 Ingo Molnar <mingo@redhat.com>
+ *  
+ *  This code is released under the GNU General Public License version 2 or
+ *  later.
+ */
+
+/* $Id$ */
+
+#undef DEBUG_SMP
+
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/spinlock.h>
+#include <linux/mm.h>
+#include <linux/smp.h>
+
+#include <asm/cacheflush.h>
+#include <asm/pgalloc.h>
+#include <asm/atomic.h>
+#include <asm/io.h>
+#include <asm/mmu_context.h>
+#include <asm/m32r.h>
+
+/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
+/* Data structures and variables                                             */
+/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
+
+/*
+ * Structure and data for smp_call_function(). This is designed to minimise
+ * static memory requirements. It also looks cleaner.
+ */
+static spinlock_t call_lock = SPIN_LOCK_UNLOCKED;
+
+struct call_data_struct {
+	void (*func) (void *info);
+	void *info;
+	atomic_t started;
+	atomic_t finished;
+	int wait;
+} __attribute__ ((__aligned__(SMP_CACHE_BYTES)));
+
+static struct call_data_struct *call_data;
+
+/*
+ * For flush_cache_all()
+ */
+static spinlock_t flushcache_lock = SPIN_LOCK_UNLOCKED;
+static volatile unsigned long flushcache_cpumask;
+
+/* 
+ * For flush_tlb_others()
+ */
+static volatile cpumask_t flush_cpumask;
+static struct mm_struct *flush_mm;
+static struct vm_area_struct *flush_vma;
+static volatile unsigned long flush_va;
+static spinlock_t tlbstate_lock = SPIN_LOCK_UNLOCKED;
+#define FLUSH_ALL 0xffffffff
+
+DECLARE_PER_CPU(int, prof_multiplier);
+DECLARE_PER_CPU(int, prof_old_multiplier);
+DECLARE_PER_CPU(int, prof_counter);
+
+extern spinlock_t ipi_lock[];
+
+/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
+/* Function Prototypes                                                       */
+/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
+
+void smp_send_reschedule(int);
+void smp_reschedule_interrupt(void);
+
+void smp_flush_cache_all(void);
+void smp_flush_cache_all_interrupt(void);
+
+void smp_flush_tlb_all(void);
+static void flush_tlb_all_ipi(void *);
+
+void smp_flush_tlb_mm(struct mm_struct *);
+void smp_flush_tlb_range(struct vm_area_struct *, unsigned long, \
+	unsigned long);
+void smp_flush_tlb_page(struct vm_area_struct *, unsigned long);
+static void flush_tlb_others(unsigned long, struct mm_struct *,
+	struct vm_area_struct *, unsigned long);
+void smp_invalidate_interrupt(void);
+
+void smp_send_stop(void);
+static void stop_this_cpu(void *);
+
+int smp_call_function(void (*) (void *), void *, int, int);
+void smp_call_function_interrupt(void);
+
+void smp_send_timer(void);
+void smp_ipi_timer_interrupt(struct pt_regs *);
+void smp_local_timer_interrupt(struct pt_regs *);
+
+void send_IPI_allbutself(int, int);
+static void send_IPI_mask(cpumask_t, int, int);
+unsigned long send_IPI_mask_phys(cpumask_t, int, int);
+
+/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
+/* Rescheduling request Routins                                              */
+/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
+
+/*==========================================================================*
+ * Name:         smp_send_reschedule
+ * 
+ * Description:  This routine requests other CPU to execute rescheduling.
+ *               1.Send 'RESCHEDULE_IPI' to other CPU.
+ *                 Request other CPU to execute 'smp_reschedule_interrupt()'.
+ * 
+ * Born on Date: 2002.02.05
+ * 
+ * Arguments:    cpu_id - Target CPU ID
+ * 
+ * Returns:      void (cannot fail)
+ * 
+ * Modification log:
+ * Date       Who Description
+ * ---------- --- --------------------------------------------------------
+ * 
+ *==========================================================================*/
+void smp_send_reschedule(int cpu_id)
+{
+	send_IPI_mask(1 << cpu_id, RESCHEDULE_IPI, 1);
+}
+
+/*==========================================================================*
+ * Name:         smp_reschedule_interrupt
+ * 
+ * Description:  This routine executes on CPU which received
+ *               'RESCHEDULE_IPI'.
+ *               Rescheduling is processed at the exit of interrupt
+ *               operation.
+ * 
+ * Born on Date: 2002.02.05
+ * 
+ * Arguments:    NONE
+ * 
+ * Returns:      void (cannot fail)
+ * 
+ * Modification log:
+ * Date       Who Description
+ * ---------- --- --------------------------------------------------------
+ * 
+ *==========================================================================*/
+void smp_reschedule_interrupt(void)
+{
+	/* nothing to do */
+}
+
+/*==========================================================================*
+ * Name:         smp_flush_cache_all
+ * 
+ * Description:  This routine sends a 'INVALIDATE_CACHE_IPI' to all other 
+ *               CPUs in the system.
+ * 
+ * Born on Date: 2003-05-28
+ * 
+ * Arguments:    NONE
+ * 
+ * Returns:      void (cannot fail)
+ * 
+ * Modification log:
+ * Date       Who Description
+ * ---------- --- --------------------------------------------------------
+ * 
+ *==========================================================================*/
+void smp_flush_cache_all(void)
+{
+	cpumask_t cpumask;
+
+	preempt_disable();
+	cpumask = 1UL << smp_processor_id();
+	cpumask = cpu_online_map & ~cpumask;
+	spin_lock(&flushcache_lock);
+	atomic_set_mask(cpumask, (atomic_t *)&flushcache_cpumask);
+	send_IPI_mask(cpumask, INVALIDATE_CACHE_IPI, 0);
+	_flush_cache_copyback_all();
+	while (flushcache_cpumask);
+	spin_unlock(&flushcache_lock);
+	preempt_enable();
+}
+
+void smp_flush_cache_all_interrupt(void)
+{
+	_flush_cache_copyback_all();
+	clear_bit(smp_processor_id(), &flushcache_cpumask);
+}
+
+/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
+/* TLB flush request Routins                                                 */
+/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
+
+/*==========================================================================*
+ * Name:         smp_flush_tlb_all
+ * 
+ * Description:  This routine flushes all processes TLBs.
+ *               1.Request other CPU to execute 'flush_tlb_all_ipi()'.
+ *               2.Execute 'do_flush_tlb_all_local()'.
+ * 
+ * Born on Date: 2002.02.05
+ * 
+ * Arguments:    NONE
+ * 
+ * Returns:      void (cannot fail)
+ * 
+ * Modification log:
+ * Date       Who Description
+ * ---------- --- --------------------------------------------------------
+ * 
+ *==========================================================================*/
+void smp_flush_tlb_all(void)
+{
+	unsigned long flags;
+
+	preempt_disable();
+	local_irq_save(flags);
+	__flush_tlb_all();
+	local_irq_restore(flags);
+	smp_call_function(flush_tlb_all_ipi, 0, 1, 1);
+	preempt_enable();
+}
+
+/*==========================================================================*
+ * Name:         flush_tlb_all_ipi
+ * 
+ * Description:  This routine flushes all local TLBs.
+ *               1.Execute 'do_flush_tlb_all_local()'.
+ * 
+ * Born on Date: 2002.02.05
+ * 
+ * Arguments:    *info - not used
+ * 
+ * Returns:      void (cannot fail)
+ * 
+ * Modification log:
+ * Date       Who Description
+ * ---------- --- --------------------------------------------------------
+ * 
+ *==========================================================================*/
+static void flush_tlb_all_ipi(void *info)
+{
+	__flush_tlb_all();
+}
+
+/*==========================================================================*
+ * Name:         smp_flush_tlb_mm
+ * 
+ * Description:  This routine flushes the specified mm context TLB's.
+ * 
+ * Born on Date: 2002.02.05
+ * 
+ * Arguments:    *mm - a pointer to the mm struct for flush TLB
+ * 
+ * Returns:      void (cannot fail)
+ * 
+ * Modification log:
+ * Date       Who Description
+ * ---------- --- --------------------------------------------------------
+ * 
+ *==========================================================================*/
+void smp_flush_tlb_mm(struct mm_struct *mm)
+{
+	int cpu_id = smp_processor_id();
+	cpumask_t cpu_mask = mm->cpu_vm_mask & ~(1 << cpu_id);
+	unsigned long *mmc = &mm->context[cpu_id];
+	unsigned long flags;
+
+	preempt_disable();
+	if (*mmc != NO_CONTEXT) {
+		local_irq_save(flags);
+		*mmc = NO_CONTEXT;
+		if (mm == current->mm)
+			activate_context(mm);
+		else
+			cpu_clear(cpu_id, mm->cpu_vm_mask);
+		local_irq_restore(flags);
+	}
+	if (cpu_mask)
+		flush_tlb_others(cpu_mask, mm, NULL, FLUSH_ALL);
+
+	preempt_enable();
+}
+
+/*==========================================================================*
+ * Name:         smp_flush_tlb_range
+ * 
+ * Description:  This routine flushes a range of pages.
+ * 
+ * Born on Date: 2002.02.05
+ * 
+ * Arguments:    *mm - a pointer to the mm struct for flush TLB
+ *               start - not used
+ *               end - not used
+ * 
+ * Returns:      void (cannot fail)
+ * 
+ * Modification log:
+ * Date       Who Description
+ * ---------- --- --------------------------------------------------------
+ * 
+ *==========================================================================*/
+void smp_flush_tlb_range(struct vm_area_struct *vma, unsigned long start, 
+	unsigned long end)
+{
+	smp_flush_tlb_mm(vma->vm_mm);
+}
+
+/*==========================================================================*
+ * Name:         smp_flush_tlb_page
+ * 
+ * Description:  This routine flushes one page.
+ * 
+ * Born on Date: 2002.02.05
+ * 
+ * Arguments:    *vma - a pointer to the vma struct include va
+ *               va - virtual address for flush TLB
+ * 
+ * Returns:      void (cannot fail)
+ * 
+ * Modification log:
+ * Date       Who Description
+ * ---------- --- --------------------------------------------------------
+ * 
+ *==========================================================================*/
+void smp_flush_tlb_page(struct vm_area_struct *vma, unsigned long va)
+{
+	struct mm_struct *mm = vma->vm_mm;
+	int cpu_id = smp_processor_id();
+	cpumask_t cpu_mask = mm->cpu_vm_mask & ~(1 << cpu_id);
+	unsigned long *mmc = &mm->context[cpu_id];
+	unsigned long flags;
+
+	preempt_disable();
+#ifdef DEBUG_SMP
+	if (!mm)
+		BUG();
+#endif
+
+	if (*mmc != NO_CONTEXT) {
+		local_irq_save(flags);
+		va &= PAGE_MASK;
+		va |= (*mmc & MMU_CONTEXT_ASID_MASK);
+		__flush_tlb_page(va);
+		local_irq_restore(flags);
+	}
+	if (cpu_mask)
+		flush_tlb_others(cpu_mask, mm, vma, va);
+
+	preempt_enable();
+}
+
+/*==========================================================================*
+ * Name:         flush_tlb_others
+ * 
+ * Description:  This routine requests other CPU to execute flush TLB.
+ *               1.Setup parmeters.
+ *               2.Send 'INVALIDATE_TLB_IPI' to other CPU.
+ *                 Request other CPU to execute 'smp_invalidate_interrupt()'.
+ *               3.Wait for other CPUs operation finished.
+ * 
+ * Born on Date: 2002.02.05
+ * 
+ * Arguments:    cpumask - bitmap of target CPUs
+ *               *mm -  a pointer to the mm struct for flush TLB
+ *               *vma -  a pointer to the vma struct include va
+ *               va - virtual address for flush TLB
+ * 
+ * Returns:      void (cannot fail)
+ * 
+ * Modification log:
+ * Date       Who Description
+ * ---------- --- --------------------------------------------------------
+ * 
+ *==========================================================================*/
+static void flush_tlb_others(cpumask_t cpumask, struct mm_struct *mm, 
+	struct vm_area_struct *vma, unsigned long va)
+{
+#ifdef DEBUG_SMP
+	unsigned long flags;
+	__save_flags(flags);
+	if (!(flags & 0x0040))	/* Interrupt Disable NONONO */
+		BUG();
+#endif /* DEBUG_SMP */
+
+	/*
+	 * A couple of (to be removed) sanity checks:
+	 *
+	 * - we do not send IPIs to not-yet booted CPUs.
+	 * - current CPU must not be in mask
+	 * - mask must exist :)
+	 */
+	if (!cpumask)
+		BUG();
+	if ((cpumask & cpu_online_map) != cpumask)
+		BUG();
+	if (cpumask & (1 << smp_processor_id()))
+		BUG();
+	if (!mm)
+		BUG();
+
+	/*
+	 * i'm not happy about this global shared spinlock in the
+	 * MM hot path, but we'll see how contended it is.
+	 * Temporarily this turns IRQs off, so that lockups are
+	 * detected by the NMI watchdog.
+	 */
+	spin_lock(&tlbstate_lock);
+
+	flush_mm = mm;
+	flush_vma = vma;
+	flush_va = va;
+
+	atomic_set_mask(cpumask, (atomic_t *)&flush_cpumask);
+
+	/*
+	 * We have to send the IPI only to
+	 * CPUs affected.
+	 */
+	send_IPI_mask(cpumask, INVALIDATE_TLB_IPI, 0);
+
+	while (flush_cpumask)
+		/* nothing. lockup detection does not belong here */;
+
+	flush_mm = NULL;
+	flush_vma = NULL;
+	flush_va = 0;
+	spin_unlock(&tlbstate_lock);
+}
+
+/*==========================================================================*
+ * Name:         smp_invalidate_interrupt
+ * 
+ * Description:  This routine executes on CPU which received
+ *               'INVALIDATE_TLB_IPI'.
+ *               1.Flush local TLB.
+ *               2.Report flush TLB process was finished.
+ * 
+ * Born on Date: 2002.02.05
+ * 
+ * Arguments:    NONE
+ * 
+ * Returns:      void (cannot fail)
+ * 
+ * Modification log:
+ * Date       Who Description
+ * ---------- --- --------------------------------------------------------
+ * 
+ *==========================================================================*/
+void smp_invalidate_interrupt(void)
+{
+	int cpu_id = smp_processor_id();
+	unsigned long *mmc = &flush_mm->context[cpu_id];
+
+	if (!cpu_isset(cpu_id, flush_cpumask))
+		return;
+
+	if (flush_va == FLUSH_ALL) {
+		*mmc = NO_CONTEXT;
+		if (flush_mm == current->active_mm)
+			activate_context(flush_mm);
+		else
+			cpu_clear(cpu_id, flush_mm->cpu_vm_mask);
+	} else {
+		unsigned long va = flush_va;
+
+		if (*mmc != NO_CONTEXT) {
+			va &= PAGE_MASK;
+			va |= (*mmc & MMU_CONTEXT_ASID_MASK);
+			__flush_tlb_page(va);
+		}
+	}
+	cpu_clear(cpu_id, flush_cpumask);
+}
+
+/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
+/* Stop CPU reequest Routins                                                 */
+/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
+
+/*==========================================================================*
+ * Name:         smp_send_stop
+ * 
+ * Description:  This routine requests stop all CPUs.
+ *               1.Request other CPU to execute 'stop_this_cpu()'.
+ * 
+ * Born on Date: 2002.02.05
+ * 
+ * Arguments:    NONE
+ * 
+ * Returns:      void (cannot fail)
+ * 
+ * Modification log:
+ * Date       Who Description
+ * ---------- --- --------------------------------------------------------
+ * 
+ *==========================================================================*/
+void smp_send_stop(void)
+{
+	smp_call_function(stop_this_cpu, NULL, 1, 0);
+}
+
+/*==========================================================================*
+ * Name:         stop_this_cpu
+ * 
+ * Description:  This routine halt CPU.
+ * 
+ * Born on Date: 2002.02.05
+ * 
+ * Arguments:    NONE
+ * 
+ * Returns:      void (cannot fail)
+ * 
+ * Modification log:
+ * Date       Who Description
+ * ---------- --- --------------------------------------------------------
+ * 
+ *==========================================================================*/
+static void stop_this_cpu(void *dummy)
+{
+	int cpu_id = smp_processor_id();
+
+	/*
+	 * Remove this CPU:
+	 */
+	cpu_clear(cpu_id, cpu_online_map);
+
+	/* 
+	 * PSW IE = 1;
+	 * IMASK = 0;
+	 * goto SLEEP
+	 */
+	local_irq_disable();
+	outl(0, M32R_ICU_IMASK_PORTL);
+	inl(M32R_ICU_IMASK_PORTL);	/* dummy read */
+	local_irq_enable();
+
+	for ( ; ; );
+}
+
+/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
+/* Call function Routins                                                     */
+/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
+
+/*==========================================================================*
+ * Name:         smp_call_function
+ * 
+ * Description:  This routine sends a 'CALL_FUNCTION_IPI' to all other CPUs 
+ *               in the system.
+ * 
+ * Born on Date: 2002.02.05
+ * 
+ * Arguments:    *func - The function to run. This must be fast and
+ *                       non-blocking.
+ *               *info - An arbitrary pointer to pass to the function.
+ *               nonatomic - currently unused.
+ *               wait - If true, wait (atomically) until function has 
+ *                      completed on other CPUs.
+ * 
+ * Returns:      0 on success, else a negative status code. Does not return
+ *               until remote CPUs are nearly ready to execute <<func>> or 
+ *               are or have executed.
+ * 
+ * Cautions:     You must not call this function with disabled interrupts or
+ *               from a hardware interrupt handler, you may call it from a 
+ *               bottom half handler.
+ *               
+ * Modification log:
+ * Date       Who Description
+ * ---------- --- --------------------------------------------------------
+ * 
+ *==========================================================================*/
+int smp_call_function(void (*func) (void *info), void *info, int nonatomic, 
+	int wait)
+{
+	struct call_data_struct data;
+	int cpus = num_online_cpus() - 1;
+
+#ifdef DEBUG_SMP
+	unsigned long flags;
+	__save_flags(flags);
+	if (!(flags & 0x0040))	/* Interrupt Disable NONONO */
+		BUG();
+#endif /* DEBUG_SMP */
+
+	if (!cpus)
+		return 0;
+
+	/* Can deadlock when called with interrupts disabled */
+	WARN_ON(irqs_disabled());
+
+	data.func = func;
+	data.info = info;
+	atomic_set(&data.started, 0);
+	data.wait = wait;
+	if (wait)
+		atomic_set(&data.finished, 0);
+
+	spin_lock(&call_lock);
+	call_data = &data;
+	wmb();
+	/* Send a message to all other CPUs and wait for them to respond */
+	send_IPI_allbutself(CALL_FUNCTION_IPI, 0);
+
+	/* Wait for response */
+	while (atomic_read(&data.started) != cpus)
+		barrier();
+
+	if (wait)
+		while (atomic_read(&data.finished) != cpus)
+			barrier();
+	spin_unlock(&call_lock);
+
+	return 0;
+}
+
+/*==========================================================================*
+ * Name:         smp_call_function_interrupt
+ * 
+ * Description:  This routine executes on CPU which received
+ *               'CALL_FUNCTION_IPI'.
+ * 
+ * Born on Date: 2002.02.05
+ * 
+ * Arguments:    NONE
+ * 
+ * Returns:      void (cannot fail)
+ * 
+ * Modification log:
+ * Date       Who Description
+ * ---------- --- --------------------------------------------------------
+ * 
+ *==========================================================================*/
+void smp_call_function_interrupt(void)
+{
+	void (*func) (void *info) = call_data->func;
+	void *info = call_data->info;
+	int wait = call_data->wait;
+
+	/*
+	 * Notify initiating CPU that I've grabbed the data and am
+	 * about to execute the function
+	 */
+	mb();
+	atomic_inc(&call_data->started);
+	/*
+	 * At this point the info structure may be out of scope unless wait==1
+	 */
+	irq_enter();
+	(*func)(info);
+	irq_exit();
+	if (wait) {
+		mb();
+		atomic_inc(&call_data->finished);
+	}
+}
+
+/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
+/* Timer Routins                                                             */
+/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
+
+/*==========================================================================*
+ * Name:         smp_send_timer
+ * 
+ * Description:  This routine sends a 'LOCAL_TIMER_IPI' to all other CPUs 
+ *               in the system.
+ * 
+ * Born on Date: 2002.02.05
+ * 
+ * Arguments:    NONE
+ * 
+ * Returns:      void (cannot fail)
+ * 
+ * Modification log:
+ * Date       Who Description
+ * ---------- --- --------------------------------------------------------
+ * 
+ *==========================================================================*/
+void smp_send_timer(void)
+{
+	send_IPI_allbutself(LOCAL_TIMER_IPI, 1);
+}
+
+/*==========================================================================*
+ * Name:         smp_send_timer
+ * 
+ * Description:  This routine executes on CPU which received
+ *               'LOCAL_TIMER_IPI'.
+ * 
+ * Born on Date: 2002.02.05
+ * 
+ * Arguments:    *regs - a pointer to the saved regster info
+ * 
+ * Returns:      void (cannot fail)
+ * 
+ * Modification log:
+ * Date       Who Description
+ * ---------- --- --------------------------------------------------------
+ * 
+ *==========================================================================*/
+void smp_ipi_timer_interrupt(struct pt_regs *regs)
+{
+	irq_enter();
+	smp_local_timer_interrupt(regs);
+	irq_exit();
+}
+
+/*==========================================================================*
+ * Name:         smp_local_timer_interrupt
+ * 
+ * Description:  Local timer interrupt handler. It does both profiling and
+ *               process statistics/rescheduling.
+ *               We do profiling in every local tick, statistics/rescheduling
+ *               happen only every 'profiling multiplier' ticks. The default
+ *               multiplier is 1 and it can be changed by writing the new 
+ *               multiplier value into /proc/profile.
+ * 
+ * Born on Date: 2002.02.05
+ * 
+ * Arguments:    *regs - a pointer to the saved regster info
+ * 
+ * Returns:      void (cannot fail)
+ * 
+ * Original:     arch/i386/kernel/apic.c
+ * 
+ * Modification log:
+ * Date       Who Description
+ * ---------- --- --------------------------------------------------------
+ * 2003-06-24 hy  use per_cpu structure.
+ *==========================================================================*/
+void smp_local_timer_interrupt(struct pt_regs *regs)
+{
+	int user = user_mode(regs);
+	int cpu_id = smp_processor_id();
+
+	/*
+	 * The profiling function is SMP safe. (nothing can mess
+	 * around with "current", and the profiling counters are
+	 * updated with atomic operations). This is especially
+	 * useful with a profiling multiplier != 1
+	 */
+
+	m32r_do_profile(regs);
+
+	if (--per_cpu(prof_counter, cpu_id) <= 0) {
+		/*
+		 * The multiplier may have changed since the last time we got
+		 * to this point as a result of the user writing to
+		 * /proc/profile. In this case we need to adjust the APIC
+		 * timer accordingly.
+		 *
+		 * Interrupts are already masked off at this point.
+		 */
+		per_cpu(prof_counter, cpu_id) 
+			= per_cpu(prof_multiplier, cpu_id);
+		if (per_cpu(prof_counter, cpu_id) 
+			!= per_cpu(prof_old_multiplier, cpu_id))
+		{
+			per_cpu(prof_old_multiplier, cpu_id) 
+				= per_cpu(prof_counter, cpu_id);
+		}
+
+		update_process_times(user);
+	}
+}
+
+/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
+/* Send IPI Routins                                                          */
+/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
+
+/*==========================================================================*
+ * Name:         send_IPI_allbutself
+ * 
+ * Description:  This routine sends a IPI to all other CPUs in the system.
+ * 
+ * Born on Date: 2002.02.05
+ * 
+ * Arguments:    ipi_num - Number of IPI
+ *               try -  0 : Send IPI certainly.
+ *                     !0 : The following IPI is not sended when Target CPU
+ *                          has not received the before IPI.
+ * 
+ * Returns:      void (cannot fail)
+ * 
+ * Modification log:
+ * Date       Who Description
+ * ---------- --- --------------------------------------------------------
+ * 
+ *==========================================================================*/
+void send_IPI_allbutself(int ipi_num, int try)
+{
+	cpumask_t cpumask = (cpu_online_map & ~(1 << smp_processor_id()));
+
+	send_IPI_mask(cpumask, ipi_num, try);
+}
+
+/*==========================================================================*
+ * Name:         send_IPI_mask
+ * 
+ * Description:  This routine sends a IPI to CPUs in the system.
+ * 
+ * Born on Date: 2002.02.05
+ * 
+ * Arguments:    cpu_mask - Bitmap of target CPUs logical ID
+ *               ipi_num - Number of IPI
+ *               try -  0 : Send IPI certainly.
+ *                     !0 : The following IPI is not sended when Target CPU
+ *                          has not received the before IPI.
+ * 
+ * Returns:      void (cannot fail)
+ * 
+ * Modification log:
+ * Date       Who Description
+ * ---------- --- --------------------------------------------------------
+ * 
+ *==========================================================================*/
+static void send_IPI_mask(cpumask_t cpumask, int ipi_num, int try)
+{
+	cpumask_t physid_mask;
+	int cpu_id, phys_id;
+	int num_cpus = num_online_cpus();
+
+	if (num_cpus <= 1)	/* NO MP */
+		return;
+
+	if ((cpumask & cpu_online_map) != cpumask) /* include not online CPU */
+		BUG();
+
+	physid_mask = 0;
+	for (cpu_id = 0 ; cpu_id < num_cpus ; cpu_id++)
+		if (cpumask & (1 << cpu_id))
+			if ((phys_id = cpu_to_physid(cpu_id)) != -1)
+				cpu_set(phys_id, physid_mask);
+
+	send_IPI_mask_phys(physid_mask, ipi_num, try);
+}
+
+/*==========================================================================*
+ * Name:         send_IPI_mask_phys
+ * 
+ * Description:  This routine sends a IPI to other CPUs in the system.
+ * 
+ * Born on Date: 2002.02.05
+ * 
+ * Arguments:    cpu_mask - Bitmap of target CPUs physical ID
+ *               ipi_num - Number of IPI
+ *               try -  0 : Send IPI certainly.
+ *                     !0 : The following IPI is not sended when Target CPU
+ *                          has not received the before IPI.
+ * 
+ * Returns:      IPICRi regster value.
+ * 
+ * Modification log:
+ * Date       Who Description
+ * ---------- --- --------------------------------------------------------
+ * 
+ *==========================================================================*/
+unsigned long send_IPI_mask_phys(cpumask_t physid_mask, int ipi_num, 
+	int try)
+{
+	spinlock_t *ipilock;
+	unsigned long flags = 0;
+	volatile unsigned long *ipicr_addr;
+	unsigned long ipicr_val;
+	cpumask_t my_physid_mask;
+
+	if (physid_mask & ~phys_cpu_present_map)
+		BUG();
+	if (ipi_num >= NR_IPIS)
+		BUG();
+
+	physid_mask <<= IPI_SHIFT;
+	ipilock = &ipi_lock[ipi_num];
+	ipicr_addr = (volatile unsigned long *)(M32R_ICU_IPICR_ADDR 
+		+ (ipi_num << 2));
+	my_physid_mask = ~(1 << smp_processor_id());
+
+	/* 
+	 * lock ipi_lock[i]
+	 * check IPICRi == 0
+	 * write IPICRi (send IPIi)
+	 * unlock ipi_lock[i]
+	 */
+	__asm__ __volatile__ (
+		";; LOCK ipi_lock[i]		\n\t"
+		".fillinsn			\n"
+		"1:				\n\t"
+		"mvfc	%1, psw 		\n\t"
+		"clrpsw	#0x40 -> nop		\n\t"
+		DCACHE_CLEAR("r4", "r5", "%2")
+		"lock	r4, @%2			\n\t"
+		"addi	r4, #-1			\n\t"
+		"unlock	r4, @%2			\n\t"
+		"mvtc	%1, psw			\n\t"
+		"bnez	r4, 2f			\n\t"
+		LOCK_SECTION_START(".balign 4 \n\t")
+		".fillinsn			\n"
+		"2:				\n\t"
+		"ld	r4, @%2			\n\t"
+		"blez	r4, 2b			\n\t"
+		"bra	1b			\n\t"
+		LOCK_SECTION_END
+		";; CHECK IPICRi == 0		\n\t"
+		".fillinsn			\n"
+		"3:				\n\t"
+		"ld	%0, @%3			\n\t"
+		"and	%0, %6			\n\t"
+		"beqz	%0, 4f			\n\t"
+		"bnez	%5, 5f			\n\t"
+		"bra	3b			\n\t"
+		";; WRITE IPICRi (send IPIi)	\n\t"
+		".fillinsn			\n"
+		"4:				\n\t"
+		"st	%4, @%3			\n\t"
+		";; UNLOCK ipi_lock[i]		\n\t"
+		".fillinsn			\n"
+		"5:				\n\t"
+		"ldi	r4, #1			\n\t"
+		"st	r4, @%2			\n\t"
+		: "=&r"(ipicr_val)
+		: "r"(flags), "r"(&ipilock->lock), "r"(ipicr_addr),
+		  "r"(physid_mask), "r"(try), "r"(my_physid_mask)
+		: "memory", "r4"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r5"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+
+	return ipicr_val;
+}
diff -ruN linux-2.6.7.org/arch/m32r/kernel/smpboot.c linux-2.6.7/arch/m32r/kernel/smpboot.c
--- linux-2.6.7.org/arch/m32r/kernel/smpboot.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/smpboot.c	2003-10-09 13:58:37.000000000 +0900
@@ -0,0 +1,660 @@
+/*  
+ *  linux/arch/m32r/kernel/smpboot.c
+ *    orig : i386 2.4.10
+ *  
+ *  MITSUBISHI M32R SMP booting functions
+ *  
+ *  Copyright (c) 2001, 2002, 2003  Hitoshi Yamamoto
+ *  
+ *  Taken from i386 version.
+ *	  (c) 1995 Alan Cox, Building #3 <alan@redhat.com>
+ *	  (c) 1998, 1999, 2000 Ingo Molnar <mingo@redhat.com>
+ *  
+ *	Much of the core SMP work is based on previous work by Thomas Radke, to
+ *	whom a great many thanks are extended.
+ *  
+ *	Thanks to Intel for making available several different Pentium,
+ *	Pentium Pro and Pentium-II/Xeon MP machines.
+ *	Original development of Linux SMP code supported by Caldera.
+ *  
+ *	This code is released under the GNU General Public License version 2 or
+ *	later.
+ *  
+ *	Fixes
+ *		Felix Koop	:	NR_CPUS used properly
+ *		Jose Renau	:	Handle single CPU case.
+ *		Alan Cox	:	By repeated request 
+ *					8) - Total BogoMIP report.
+ *		Greg Wright	:	Fix for kernel stacks panic.
+ *		Erich Boleyn	:	MP v1.4 and additional changes.
+ *	Matthias Sattler	:	Changes for 2.1 kernel map.
+ *	Michel Lespinasse	:	Changes for 2.1 kernel map.
+ *	Michael Chastain	:	Change trampoline.S to gnu as.
+ *		Alan Cox	:	Dumb bug: 'B' step PPro's are fine
+ *		Ingo Molnar	:	Added APIC timers, based on code
+ *					from Jose Renau
+ *		Ingo Molnar	:	various cleanups and rewrites
+ *		Tigran Aivazian	:	fixed "0.00 in /proc/uptime on SMP" bug.
+ *	Maciej W. Rozycki	:	Bits for genuine 82489DX APICs
+ *		Martin J. Bligh	: 	Added support for multi-quad systems
+ */
+
+/* $Id$ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/smp_lock.h>
+#include <linux/irq.h>
+#include <linux/bootmem.h>
+#include <linux/delay.h>
+
+#include <asm/io.h>
+#include <asm/pgalloc.h>
+#include <asm/tlbflush.h>
+
+#define DEBUG_SMP
+#ifdef DEBUG_SMP
+#define Dprintk(x...) printk(x)
+#else
+#define Dprintk(x...)
+#endif
+
+extern int cpu_idle(void);
+extern unsigned long cpu_initialized;
+
+/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
+/* Data structures and variables                                             */
+/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
+
+/* Processor that is doing the boot up */
+static unsigned int bsp_phys_id = -1;
+
+/* Bitmask of physically existing CPUs */
+cpumask_t phys_cpu_present_map;
+
+/* Bitmask of currently online CPUs */
+cpumask_t cpu_online_map;
+
+cpumask_t cpu_bootout_map;
+cpumask_t cpu_bootin_map;
+cpumask_t cpu_callout_map;
+static cpumask_t cpu_callin_map;
+
+/* Per CPU bogomips and other parameters */
+struct cpuinfo_m32r cpu_data[NR_CPUS] __cacheline_aligned;
+
+/* Set when the idlers are all forked */
+int smp_threads_ready;
+
+static int cpucount;
+static cpumask_t smp_commenced_mask;
+
+extern struct {
+	void * spi;
+	unsigned short ss;
+} stack_start;
+
+/* which physical physical ID maps to which logical CPU number */
+static volatile int physid_2_cpu[NR_CPUS];
+
+/* which logical CPU number maps to which physical ID */
+volatile int cpu_2_physid[NR_CPUS];
+
+DEFINE_PER_CPU(int, prof_multiplier) = 1;
+DEFINE_PER_CPU(int, prof_old_multiplier) = 1;
+DEFINE_PER_CPU(int, prof_counter) = 1;
+
+spinlock_t ipi_lock[NR_IPIS];
+
+static unsigned int calibration_result;
+
+unsigned long cache_decay_ticks = HZ / 100;
+
+/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
+/* Function Prototypes                                                       */
+/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
+
+void smp_prepare_boot_cpu(void);
+void smp_prepare_cpus(unsigned int);
+static struct task_struct *fork_by_hand(void);
+static void smp_tune_scheduling(void);
+static void init_ipi_lock(void);
+static void do_boot_cpu(int);
+int __cpu_up(unsigned int);
+void smp_cpus_done(unsigned int);
+
+int start_secondary(void *);
+static void smp_callin(void);
+static void smp_online(void);
+
+static void show_mp_info(int);
+static void smp_store_cpu_info(int);
+static void show_cpu_info(int);
+int setup_profiling_timer(unsigned int);
+static void init_cpu_to_physid(void);
+static void map_cpu_to_physid(int, int);
+static void unmap_cpu_to_physid(int, int);
+
+/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
+/* Boot up APs Routins : BSP                                                 */
+/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
+void __devinit smp_prepare_boot_cpu(void)
+{
+	bsp_phys_id = hard_smp_processor_id();
+	cpu_set(bsp_phys_id, phys_cpu_present_map);
+	cpu_set(0, cpu_online_map);	/* BSP's cpu_id == 0 */
+	cpu_set(0, cpu_callout_map);
+	cpu_set(0, cpu_callin_map);
+
+	/*
+	 * Initialize the logical to physical CPU number mapping
+	 */
+	init_cpu_to_physid();
+	map_cpu_to_physid(0, bsp_phys_id);
+	current_thread_info()->cpu = 0;
+}
+
+/*==========================================================================*
+ * Name:         smp_prepare_cpus (old smp_boot_cpus)
+ * 
+ * Description:  This routine boot up APs.
+ * 
+ * Born on Date: 2002.02.05
+ * 
+ * Arguments:    NONE
+ * 
+ * Returns:      void (cannot fail)
+ * 
+ * Modification log:
+ * Date       Who Description
+ * ---------- --- --------------------------------------------------------
+ * 2003-06-24 hy  modify for linux-2.5.69
+ * 
+ *==========================================================================*/
+void __init smp_prepare_cpus(unsigned int max_cpus)
+{
+	int phys_id;
+	unsigned long nr_cpu;
+
+	nr_cpu = inl(M32R_FPGA_NUM_OF_CPUS_PORTL);
+	if (nr_cpu > NR_CPUS) {
+		printk(KERN_INFO "NUM_OF_CPUS reg. value [%ld] > NR_CPU [%d]", 
+			nr_cpu, NR_CPUS);
+		goto smp_done;
+	}
+	for (phys_id = 0 ; phys_id < nr_cpu ; phys_id++)
+		cpu_set(phys_id, phys_cpu_present_map);
+
+	show_mp_info(nr_cpu);
+
+	init_ipi_lock();
+
+	/*
+	 * Setup boot CPU information
+	 */
+	smp_store_cpu_info(0); /* Final full version of the data */
+	smp_tune_scheduling();
+
+	/*
+	 * If SMP should be disabled, then really disable it!
+	 */
+	if (!max_cpus) {
+		printk(KERN_INFO "SMP mode deactivated by commandline.\n");
+		goto smp_done;
+	}
+
+	/*
+	 * Now scan the CPU present map and fire up the other CPUs.
+	 */
+	Dprintk("CPU present map : %lx\n", phys_cpu_present_map);
+
+	for (phys_id = 0 ; phys_id < NR_CPUS ; phys_id++) {
+		/*
+		 * Don't even attempt to start the boot CPU!
+		 */
+		if (phys_id == bsp_phys_id)
+			continue;
+
+		if (!cpu_isset(phys_id, phys_cpu_present_map))
+			continue;
+
+		if ((max_cpus >= 0) && (max_cpus <= cpucount + 1))
+			continue;
+
+		do_boot_cpu(phys_id);
+
+		/*
+		 * Make sure we unmap all failed CPUs
+		 */
+		if (physid_to_cpu(phys_id) == -1) {
+			cpu_clear(phys_id, phys_cpu_present_map);
+			printk("phys CPU#%d not responding - " \
+				"cannot use it.\n", phys_id);
+		}
+	}
+
+smp_done:
+	Dprintk("Boot done.\n");
+}
+
+/*
+ * fork_by_hand : This routin executes do_fork for APs idle process.
+ */
+static struct task_struct * __init fork_by_hand(void)
+{
+	struct pt_regs regs = { 0 };
+
+	/*
+	 * don't care about the eip and regs settings since
+	 * we'll never reschedule the forked task.
+	 */
+	return copy_process(CLONE_VM | CLONE_IDLETASK, 0, &regs, 0, NULL, NULL);
+}
+
+static void __init smp_tune_scheduling(void)
+{
+	/* Nothing to do. */
+}
+
+/* 
+ * init_ipi_lock : Initialize IPI locks.
+ */
+static void __init init_ipi_lock(void)
+{
+	int ipi;
+
+	for (ipi = 0 ; ipi < NR_IPIS ; ipi++)
+		ipi_lock[ipi] = SPIN_LOCK_UNLOCKED;
+}
+
+/*==========================================================================*
+ * Name:         do_boot_cpu
+ * 
+ * Description:  This routine boot up one AP.
+ * 
+ * Born on Date: 2002.02.05
+ * 
+ * Arguments:    phys_id - Target CPU physical ID
+ * 
+ * Returns:      void (cannot fail)
+ * 
+ * Modification log:
+ * Date       Who Description
+ * ---------- --- --------------------------------------------------------
+ * 2003-06-24 hy  modify for linux-2.5.69
+ * 
+ *==========================================================================*/
+static void __init do_boot_cpu(int phys_id)
+{
+	struct task_struct *idle;
+	unsigned long send_status, boot_status;
+	int timeout, cpu_id;
+
+	cpu_id = ++cpucount;
+
+	/*
+	 * We can't use kernel_thread since we must avoid to
+	 * reschedule the child.
+	 */
+	idle = fork_by_hand();
+	if (IS_ERR(idle))
+		panic("failed fork for CPU#%d.", cpu_id);
+	wake_up_forked_process(idle);
+
+	/*
+	 * We remove it from the pidhash and the runqueue
+	 * once we got the process:
+	 */
+	init_idle(idle, cpu_id);
+	idle->thread.lr = (unsigned long)start_secondary;
+	unhash_process(idle);
+
+	map_cpu_to_physid(cpu_id, phys_id);
+
+	/* So we see what's up   */
+	printk("Booting processor %d/%d\n", phys_id, cpu_id);
+	stack_start.spi = (void *)idle->thread.sp;
+	idle->thread_info->cpu = cpu_id;
+
+	/*
+	 * Send Startup IPI
+	 *   1.IPI received by CPU#(phys_id).
+	 *   2.CPU#(phys_id) enter startup_AP (arch/m32r/kernel/head.S)
+	 *   3.CPU#(phys_id) enter start_secondary()
+	 */
+	send_status = 0;
+	boot_status = 0;
+
+	cpu_set(phys_id, cpu_bootout_map);
+
+	/* Send Startup IPI */
+	send_IPI_mask_phys((1 << phys_id), CPU_BOOT_IPI, 0);
+
+	Dprintk("Waiting for send to finish...\n");
+	timeout = 0;
+
+	/* Wait 100[ms] */
+	do {
+		Dprintk("+");
+		udelay(1000);
+		send_status = !cpu_isset(phys_id, cpu_bootin_map);
+	} while (send_status && (timeout++ < 100));
+
+	Dprintk("After Startup.\n");
+
+	if (!send_status) {
+		/*
+		 * allow APs to start initializing.
+		 */
+		Dprintk("Before Callout %d.\n", cpu_id);
+		cpu_set(cpu_id, cpu_callout_map);
+		Dprintk("After Callout %d.\n", cpu_id);
+
+		/*
+		 * Wait 5s total for a response
+		 */
+		for (timeout = 0; timeout < 5000; timeout++) {
+			if (cpu_isset(cpu_id, cpu_callin_map))
+				break;	/* It has booted */
+			udelay(1000);
+		}
+
+		if (cpu_isset(cpu_id, cpu_callin_map)) {
+			/* number CPUs logically, starting from 1 (BSP is 0) */
+			Dprintk("OK.\n");
+		} else {
+			boot_status = 1;
+			printk("Not responding.\n");
+		}
+	} else
+		printk("IPI never delivered???\n");
+
+	if (send_status || boot_status) {
+		unmap_cpu_to_physid(cpu_id, phys_id);
+		cpu_clear(cpu_id, cpu_callout_map);
+		cpu_clear(cpu_id, cpu_callin_map);
+		cpu_clear(cpu_id, cpu_initialized);
+		cpucount--;
+	}
+}
+
+int __devinit __cpu_up(unsigned int cpu_id)
+{
+	int timeout;
+
+	cpu_set(cpu_id, smp_commenced_mask);
+
+	/*
+	 * Wait 5s total for a response
+	 */
+	for (timeout = 0; timeout < 5000; timeout++) {
+		if (cpu_isset(cpu_id, cpu_online_map))
+			break;
+		udelay(1000);
+	}
+	if (!cpu_isset(cpu_id, cpu_online_map))
+		BUG();
+
+	return 0;
+}
+
+void __init smp_cpus_done(unsigned int max_cpus)
+{
+	int cpu_id, timeout;
+	unsigned long bogosum = 0;
+
+	for (timeout = 0; timeout < 5000; timeout++) {
+		if (cpu_callin_map == cpu_online_map)
+			break;
+		udelay(1000);
+	}
+	if (cpu_callin_map != cpu_online_map)
+		BUG();
+
+	for (cpu_id = 0 ; cpu_id < num_online_cpus() ; cpu_id++)
+		show_cpu_info(cpu_id);
+
+	/*
+	 * Allow the user to impress friends.
+	 */
+	Dprintk("Before bogomips.\n");
+	if (cpucount) {
+		for (cpu_id = 0 ; cpu_id < NR_CPUS ; cpu_id++)
+			if (cpu_online_map & (1 << cpu_id))
+				bogosum += cpu_data[cpu_id].loops_per_jiffy;
+
+		printk(KERN_INFO "Total of %d processors activated " \
+			"(%lu.%02lu BogoMIPS).\n", cpucount + 1, 
+			bogosum / (500000 / HZ),
+			(bogosum / (5000 / HZ)) % 100);
+		Dprintk("Before bogocount - setting activated=1.\n");
+	}
+}
+
+/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
+/* Activate a secondary processor Routins                                    */
+/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
+
+/*==========================================================================*
+ * Name:         start_secondary
+ * 
+ * Description:  This routine activate a secondary processor.
+ * 
+ * Born on Date: 2002.02.05
+ * 
+ * Arguments:    *unused - currently unused.
+ * 
+ * Returns:      void (cannot fail)
+ * 
+ * Modification log:
+ * Date       Who Description
+ * ---------- --- --------------------------------------------------------
+ * 2003-06-24 hy  modify for linux-2.5.69
+ * 
+ *==========================================================================*/
+int __init start_secondary(void *unused)
+{
+	cpu_init();
+	smp_callin();
+	while (!cpu_isset(smp_processor_id(), smp_commenced_mask))
+		rep_nop();
+
+	smp_online();
+
+	/*
+	 * low-memory mappings have been cleared, flush them from
+	 * the local TLBs too.
+	 */
+	local_flush_tlb_all();
+
+	return cpu_idle();
+}
+
+/*==========================================================================*
+ * Name:         smp_callin
+ * 
+ * Description:  This routine activate a secondary processor.
+ * 
+ * Born on Date: 2002.02.05
+ * 
+ * Arguments:    NONE
+ * 
+ * Returns:      void (cannot fail)
+ * 
+ * Modification log:
+ * Date       Who Description
+ * ---------- --- --------------------------------------------------------
+ * 2003-06-24 hy  modify for linux-2.5.69
+ * 
+ *==========================================================================*/
+static void __init smp_callin(void)
+{
+	int phys_id = hard_smp_processor_id();
+	int cpu_id = smp_processor_id();
+	unsigned long timeout;
+
+	if (cpu_isset(cpu_id, cpu_callin_map)) {
+		printk("huh, phys CPU#%d, CPU#%d already present??\n", 
+			phys_id, cpu_id);
+		BUG();
+	}
+	Dprintk("CPU#%d (phys ID: %d) waiting for CALLOUT\n", cpu_id, phys_id);
+	
+	/* Waiting 2s total for startup (udelay is not yet working) */
+	timeout = jiffies + (2 * HZ);
+	while (time_before(jiffies, timeout)) {
+		/* Has the boot CPU finished it's STARTUP sequence ? */
+		if (cpu_isset(cpu_id, cpu_callout_map))
+			break;
+		rep_nop();
+	}
+
+	if (!time_before(jiffies, timeout)) {
+		printk("BUG: CPU#%d started up but did not get a callout!\n", 
+			cpu_id);
+		BUG();
+	}
+
+	/* Allow the master to continue. */
+	cpu_set(cpu_id, cpu_callin_map);
+}
+
+static void __init smp_online(void)
+{
+	int cpu_id = smp_processor_id();
+
+	local_irq_enable();
+
+	/* Get our bogomips. */
+	calibrate_delay();
+
+	/* Save our processor parameters */
+ 	smp_store_cpu_info(cpu_id);
+
+	cpu_set(cpu_id, cpu_online_map);
+}
+
+/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
+/* Boot up CPUs common Routins                                               */
+/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
+static void __init show_mp_info(int nr_cpu)
+{
+	int i;
+	char cpu_model0[17], cpu_model1[17], cpu_ver[9];
+
+	strncpy(cpu_model0, (char *)M32R_FPGA_CPU_NAME_ADDR, 16);
+	strncpy(cpu_model1, (char *)M32R_FPGA_MODEL_ID_ADDR, 16);
+	strncpy(cpu_ver, (char *)M32R_FPGA_VERSION_ADDR, 8);
+
+	cpu_model0[16] = '\0';
+	for (i = 15 ; i >= 0 ; i--) {
+		if (cpu_model0[i] != ' ')
+			break;
+		cpu_model0[i] = '\0';
+	}
+	cpu_model1[16] = '\0';
+	for (i = 15 ; i >= 0 ; i--) {
+		if (cpu_model1[i] != ' ')
+			break;
+		cpu_model1[i] = '\0';
+	}
+	cpu_ver[8] = '\0';
+	for (i = 7 ; i >= 0 ; i--) {
+		if (cpu_ver[i] != ' ')
+			break;
+		cpu_ver[i] = '\0';
+	}
+
+	printk(KERN_INFO "M32R-mp information\n");
+	printk(KERN_INFO "  On-chip CPUs : %d\n", nr_cpu);
+	printk(KERN_INFO "  CPU model : %s/%s(%s)\n", cpu_model0, 
+		cpu_model1, cpu_ver);
+}
+
+/*
+ * The bootstrap kernel entry code has set these up. Save them for
+ * a given CPU
+ */
+static void __init smp_store_cpu_info(int cpu_id)
+{
+	struct cpuinfo_m32r *ci = cpu_data + cpu_id;
+
+	*ci = boot_cpu_data;
+	ci->loops_per_jiffy = loops_per_jiffy;
+}
+
+static void __init show_cpu_info(int cpu_id)
+{
+	struct cpuinfo_m32r *ci = &cpu_data[cpu_id];
+
+	printk("CPU#%d : ", cpu_id);
+
+#define PRINT_CLOCK(name, value) \
+	printk(name " clock %d.%02dMHz", \
+		((value) / 1000000), ((value) % 1000000) / 10000)
+
+	PRINT_CLOCK("CPU", (int)ci->cpu_clock);
+	PRINT_CLOCK(", Bus", (int)ci->bus_clock);
+	printk(", loops_per_jiffy[%ld]\n", ci->loops_per_jiffy);
+}
+
+/*
+ * the frequency of the profiling timer can be changed
+ * by writing a multiplier value into /proc/profile.
+ */
+int setup_profiling_timer(unsigned int multiplier)
+{
+	int i;
+
+	/*
+	 * Sanity check. [at least 500 APIC cycles should be
+	 * between APIC interrupts as a rule of thumb, to avoid
+	 * irqs flooding us]
+	 */
+	if ( (!multiplier) || (calibration_result / multiplier < 500))
+		return -EINVAL;
+
+	/* 
+	 * Set the new multiplier for each CPU. CPUs don't start using the
+	 * new values until the next timer interrupt in which they do process
+	 * accounting. At that time they also adjust their APIC timers
+	 * accordingly.
+	 */
+	for (i = 0; i < NR_CPUS; ++i)
+		per_cpu(prof_multiplier, i) = multiplier;
+
+	return 0;
+}
+
+/* Initialize all maps between cpu number and apicids */
+static void __init init_cpu_to_physid(void)
+{
+	int  i;
+
+	for (i = 0 ; i < NR_CPUS ; i++) {
+		cpu_2_physid[i] = -1;
+		physid_2_cpu[i] = -1;
+	}
+}
+
+/* 
+ * set up a mapping between cpu and apicid. Uses logical apicids for multiquad,
+ * else physical apic ids
+ */
+static void __init map_cpu_to_physid(int cpu_id, int phys_id)
+{
+	physid_2_cpu[phys_id] = cpu_id;
+	cpu_2_physid[cpu_id] = phys_id;
+}
+
+/* 
+ * undo a mapping between cpu and apicid. Uses logical apicids for multiquad,
+ * else physical apic ids
+ */
+static void __init unmap_cpu_to_physid(int cpu_id, int phys_id)
+{
+	physid_2_cpu[phys_id] = -1;
+	cpu_2_physid[cpu_id] = -1;
+}
+
diff -ruN linux-2.6.7.org/arch/m32r/kernel/sys_m32r.c linux-2.6.7/arch/m32r/kernel/sys_m32r.c
--- linux-2.6.7.org/arch/m32r/kernel/sys_m32r.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/sys_m32r.c	2004-05-07 15:32:01.000000000 +0900
@@ -0,0 +1,281 @@
+/*
+ * linux/arch/m32r/kernel/sys_m32r.c
+ *
+ * This file contains various random system calls that 
+ * have a non-standard calling sequence on the Linux/M32R platform.
+ *
+ * Taken from i386 version.
+ */
+
+/* $Id$ */
+
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+#include <linux/sem.h>
+#include <linux/msg.h>
+#include <linux/shm.h>
+#include <linux/stat.h>
+#include <linux/syscalls.h>
+#include <linux/mman.h>
+#include <linux/file.h>
+#include <linux/utsname.h>
+
+#include <asm/uaccess.h>
+#include <asm/cachectl.h>
+#include <asm/cacheflush.h>
+#include <asm/ipc.h>
+
+/* 
+ * sys_tas() - test-and-set
+ * linuxthreads testing version
+ */
+#ifndef CONFIG_SMP
+asmlinkage int sys_tas(int *addr)
+{
+	int oldval;
+	unsigned long flags;
+
+	if (!access_ok(VERIFY_WRITE, addr, sizeof (int)))
+		return -EFAULT;
+	local_irq_save(flags);
+	oldval = *addr;
+	*addr = 1;
+	local_irq_restore(flags);
+	return oldval;
+}
+#else /* CONFIG_SMP */
+#include <linux/spinlock.h>
+
+static spinlock_t tas_lock = SPIN_LOCK_UNLOCKED;
+
+asmlinkage int sys_tas(int *addr)
+{
+	int oldval;
+
+	if (!access_ok(VERIFY_WRITE, addr, sizeof (int)))
+		return -EFAULT;
+
+	spin_lock(&tas_lock);
+	oldval = *addr;
+	*addr = 1;
+	spin_unlock(&tas_lock);
+
+	return oldval;
+}
+#endif /* CONFIG_SMP */
+
+/*
+ * sys_pipe() is the normal C calling standard for creating
+ * a pipe. It's not the way Unix traditionally does this, though.
+ */
+asmlinkage int
+sys_pipe(unsigned long r0, unsigned long r1, unsigned long r2, 
+	unsigned long r3, unsigned long r4, unsigned long r5, 
+	unsigned long r6, struct pt_regs regs)
+{
+	int fd[2];
+	int error;
+
+	error = do_pipe(fd);
+	if (!error) {
+		if (copy_to_user((void *)r0, (void *)fd, 2*sizeof(int)))
+			error = -EFAULT;
+	}
+	return error;
+}
+
+static inline long do_mmap2(
+	unsigned long addr, unsigned long len, 
+	unsigned long prot, unsigned long flags, 
+	int fd, unsigned long pgoff)
+{
+	int error = -EBADF;
+	struct file *file = NULL;
+
+	flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
+	if (!(flags & MAP_ANONYMOUS)) {
+		file = fget(fd);
+		if (!file)
+			goto out;
+	}
+
+	down_write(&current->mm->mmap_sem);
+	error = do_mmap_pgoff(file, addr, len, prot, flags, pgoff);
+	up_write(&current->mm->mmap_sem);
+
+	if (file)
+		fput(file);
+out:
+	return error;
+}
+
+asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,
+	unsigned long prot, unsigned long flags,
+	unsigned long fd, unsigned long pgoff)
+{
+	return do_mmap2(addr, len, prot, flags, fd, pgoff);
+}
+
+/*
+ * Perform the select(nd, in, out, ex, tv) and mmap() system
+ * calls. Linux/M32R didn't use to be able to handle more than
+ * 4 system call parameters, so these system calls used a memory
+ * block for parameter passing..
+ */
+
+struct mmap_arg_struct {
+	unsigned long addr;
+	unsigned long len;
+	unsigned long prot;
+	unsigned long flags;
+	unsigned long fd;
+	unsigned long offset;
+};
+
+asmlinkage int old_mmap(struct mmap_arg_struct *arg) 
+{
+	struct mmap_arg_struct a;
+	int err = -EFAULT;
+	
+	if (copy_from_user(&a, arg, sizeof(a)))
+		goto out;
+	
+	err = -EINVAL;
+	if (a.offset & ~PAGE_MASK)
+		goto out;
+	err = do_mmap2(a.addr, a.len, a.prot, a.flags, a.fd, 
+		a.offset>>PAGE_SHIFT);
+out:
+	return err;
+}
+
+struct sel_arg_struct {
+	unsigned long n;
+	fd_set __user *inp, *outp, *exp;
+	struct timeval __user *tvp;
+};
+
+asmlinkage int old_select(struct sel_arg_struct __user *arg)
+{
+	struct sel_arg_struct a;
+
+	if (copy_from_user(&a, arg, sizeof(a)))
+		return -EFAULT;
+	/* sys_select() does the appropriate kernel locking */
+	return sys_select(a.n, a.inp, a.outp, a.exp, a.tvp);
+}
+
+/*
+ * sys_ipc() is the de-multiplexer for the SysV IPC calls..
+ *
+ * This is really horribly ugly.
+ */
+asmlinkage int sys_ipc(uint call, int first, int second,
+		       int third, void __user *ptr, long fifth)
+{
+	int version, ret;
+
+	version = call >> 16; /* hack for backward compatibility */
+	call &= 0xffff;
+
+	switch (call) {
+	case SEMOP:
+		return sys_semtimedop(first, (struct sembuf __user *)ptr, 
+				      second, NULL);
+	case SEMTIMEDOP:
+		return sys_semtimedop(first, (struct sembuf __user *)ptr, 
+				      second, (const struct timespec __user *)fifth);
+	case SEMGET:
+		return sys_semget (first, second, third);
+	case SEMCTL: {
+		union semun fourth;
+		if (!ptr)
+			return -EINVAL;
+		if (get_user(fourth.__pad, (void * __user *) ptr))
+			return -EFAULT;
+		return sys_semctl (first, second, third, fourth);
+		}
+
+	case MSGSND:
+		return sys_msgsnd (first, (struct msgbuf __user *) ptr, 
+				   second, third);
+	case MSGRCV:
+		switch (version) {
+		case 0: {
+			struct ipc_kludge tmp;
+			if (!ptr)
+				return -EINVAL;
+			
+			if (copy_from_user(&tmp,
+					   (struct ipc_kludge __user *) ptr, 
+					   sizeof (tmp)))
+				return -EFAULT;
+			return sys_msgrcv (first, tmp.msgp, second,
+					   tmp.msgtyp, third);
+			}
+		default:
+			return sys_msgrcv (first,
+					   (struct msgbuf __user *) ptr,
+					   second, fifth, third);
+		}
+	case MSGGET:
+		return sys_msgget ((key_t) first, second);
+	case MSGCTL:
+		return sys_msgctl (first, second,
+				   (struct msqid_ds __user *) ptr);
+	case SHMAT:
+		switch (version) {
+		default: {
+			ulong raddr;
+			ret = do_shmat (first, (char __user *) ptr,
+					 second, &raddr);
+			if (ret)
+				return ret;
+			return put_user (raddr, (ulong __user *) third);
+		}
+		case 1:	/* iBCS2 emulator entry point */
+			if (!segment_eq(get_fs(), get_ds()))
+				return -EINVAL;
+			return do_shmat (first, (char __user *) ptr,
+					  second, (ulong *) third);
+		}
+	case SHMDT: 
+		return sys_shmdt ((char __user *)ptr);
+	case SHMGET:
+		return sys_shmget (first, second, third);
+	case SHMCTL:
+		return sys_shmctl (first, second,
+				   (struct shmid_ds __user *) ptr);
+	default:
+		return -ENOSYS;
+	}
+}
+
+asmlinkage int sys_uname(struct old_utsname * name)
+{
+	int err;
+	if (!name)
+		return -EFAULT;
+	down_read(&uts_sem);
+	err=copy_to_user(name, &system_utsname, sizeof (*name));
+	up_read(&uts_sem);
+	return err?-EFAULT:0;
+}
+
+asmlinkage int sys_cacheflush(void *addr, int bytes, int cache)
+{
+	/* This should flush more selectivly ...  */
+	_flush_cache_all();
+	return 0;
+}
+
+asmlinkage int sys_cachectl(char *addr, int nbytes, int op)
+{
+	/* Not implemented yet. */
+	return -ENOSYS;
+}
+
diff -ruN linux-2.6.7.org/arch/m32r/kernel/time.c linux-2.6.7/arch/m32r/kernel/time.c
--- linux-2.6.7.org/arch/m32r/kernel/time.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/time.c	2004-05-27 17:45:04.000000000 +0900
@@ -0,0 +1,318 @@
+/*
+ *  linux/arch/m32r/kernel/time.c
+ *
+ *  Copyright (c) 2001, 2002  Hiroyuki Kondo, Hirokazu Takata,
+ *                            Hitoshi Yamamoto
+ *  Taken from i386 version.
+ *    Copyright (C) 1991, 1992, 1995  Linus Torvalds
+ *    Copyright (C) 1996, 1997, 1998  Ralf Baechle
+ *
+ *  This file contains the time handling details for PC-style clocks as
+ *  found in some MIPS systems.
+ *
+ *  Some code taken from sh version.
+ *    Copyright (C) 1999  Tetsuya Okada & Niibe Yutaka
+ *    Copyright (C) 2000  Philipp Rumpf <prumpf@tux.org>
+ */
+
+/* $Id$ */
+
+#undef  DEBUG_TIMER
+
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/param.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+
+#include <asm/io.h>
+#include <asm/m32r.h>
+
+#include <asm/hw_irq.h>
+
+#ifdef CONFIG_SMP
+extern void send_IPI_allbutself(int, int);
+extern void smp_local_timer_interrupt(struct pt_regs *);
+#endif
+
+u64 jiffies_64 = INITIAL_JIFFIES;
+
+EXPORT_SYMBOL(jiffies_64);
+
+extern unsigned long wall_jiffies;
+#define TICK_SIZE	(tick_nsec / 1000)
+
+/*
+ * Change this if you have some constant time drift
+ */
+
+/* This is for machines which generate the exact clock. */
+#define USECS_PER_JIFFY (1000000/HZ)
+
+static unsigned long latch;
+
+static unsigned long do_gettimeoffset(void)
+{
+	unsigned long  elapsed_time = 0;  /* [us] */
+
+#if defined(CONFIG_CHIP_M32102) || defined(CONFIG_CHIP_XNUX2) \
+	|| defined(CONFIG_CHIP_VDEC2) || defined(CONFIG_CHIP_M32700) \
+        || defined(CONFIG_CHIP_OPSP)
+#ifndef CONFIG_SMP
+
+	unsigned long count;
+
+	/* timer count may underflow right here */
+	count = inl(M32R_MFT2CUT_PORTL);
+
+	if (inl(M32R_ICU_CR18_PORTL) & 0x00000100)	/* underflow check */
+		count = 0;
+
+	count = (latch - count) * TICK_SIZE;
+	elapsed_time = (count + latch / 2) / latch;
+	/* NOTE: LATCH is equal to the "interval" value (= reload count). */
+	
+#else /* CONFIG_SMP */
+	unsigned long count;
+	static unsigned long p_jiffies = -1;
+	static unsigned long p_count = 0;
+
+	/* timer count may underflow right here */
+	count = inl(M32R_MFT2CUT_PORTL);
+
+	if (jiffies == p_jiffies && count > p_count)
+		count = 0;
+
+	p_jiffies = jiffies;
+	p_count = count;
+
+	count = (latch - count) * TICK_SIZE;
+	elapsed_time = (count + latch / 2) / latch;
+	/* NOTE: LATCH is equal to the "interval" value (= reload count). */
+#endif /* CONFIG_SMP */
+#elif defined(CONFIG_CHIP_M32310)
+#warning do_gettimeoffse not implemented
+#else
+#error no chip configuration
+#endif
+
+	return elapsed_time;
+}
+
+/*
+ * This version of gettimeofday has near microsecond resolution.
+ */
+void do_gettimeofday(struct timeval *tv)
+{
+	unsigned long seq;
+	unsigned long usec, sec;
+	unsigned long max_ntp_tick = tick_usec - tickadj;
+
+	do {
+		unsigned long lost;
+
+		seq = read_seqbegin(&xtime_lock);
+
+		usec = do_gettimeoffset();
+		lost = jiffies - wall_jiffies;
+
+		/*
+		 * If time_adjust is negative then NTP is slowing the clock
+		 * so make sure not to go into next possible interval.
+		 * Better to lose some accuracy than have time go backwards..
+		 */
+		if (unlikely(time_adjust < 0)) {
+			usec = min(usec, max_ntp_tick);
+			if (lost)
+				usec += lost * max_ntp_tick;
+		} else if (unlikely(lost))
+			usec += lost * tick_usec;
+
+		sec = xtime.tv_sec;
+		usec += (xtime.tv_nsec / 1000);
+	} while (read_seqretry(&xtime_lock, seq));
+
+	while (usec >= 1000000) {
+		usec -= 1000000;
+		sec++;
+	}
+
+	tv->tv_sec = sec;
+	tv->tv_usec = usec;
+}
+
+EXPORT_SYMBOL(do_gettimeofday);
+
+int do_settimeofday(struct timespec *tv)
+{
+	time_t wtm_sec, sec = tv->tv_sec;
+ 	long wtm_nsec, nsec = tv->tv_nsec;
+
+	if ((unsigned long)tv->tv_nsec >= NSEC_PER_SEC)
+		return -EINVAL;
+
+	write_seqlock_irq(&xtime_lock);
+        /*
+         * This is revolting. We need to set "xtime" correctly. However, the
+         * value in this location is the value at the most recent update of
+         * wall time.  Discover what correction gettimeofday() would have
+         * made, and then undo it!
+         */
+	nsec -= do_gettimeoffset() * NSEC_PER_USEC;
+	nsec -= (jiffies - wall_jiffies) * TICK_NSEC;
+
+	wtm_sec = wall_to_monotonic.tv_sec + (xtime.tv_sec - sec);
+	wtm_nsec = wall_to_monotonic.tv_nsec + (xtime.tv_nsec - nsec);
+
+	set_normalized_timespec(&xtime, sec, nsec);
+	set_normalized_timespec(&wall_to_monotonic, wtm_sec, wtm_nsec);
+
+        time_adjust = 0;		/* stop active adjtime() */
+        time_status |= STA_UNSYNC;
+        time_maxerror = NTP_PHASE_LIMIT;
+        time_esterror = NTP_PHASE_LIMIT;
+        write_sequnlock_irq(&xtime_lock);
+	clock_was_set();
+
+	return 0;
+}
+
+EXPORT_SYMBOL(do_settimeofday);
+
+/*
+ * In order to set the CMOS clock precisely, set_rtc_mmss has to be
+ * called 500 ms after the second nowtime has started, because when
+ * nowtime is written into the registers of the CMOS clock, it will
+ * jump to the next second precisely 500 ms later. Check the Motorola
+ * MC146818A or Dallas DS12887 data sheet for details.
+ *
+ * BUG: This routine does not handle hour overflow properly; it just
+ *      sets the minutes. Usually you won't notice until after reboot!
+ */
+static __inline__ int set_rtc_mmss(unsigned long nowtime)
+{
+	return 0;
+}
+
+/* last time the cmos clock got updated */
+static long last_rtc_update = 0;
+
+/*
+ * timer_interrupt() needs to keep up the real-time clock,
+ * as well as call the "do_timer()" routine every clocktick
+ */
+static __inline__ void do_timer_interrupt(int irq, void *dev_id,
+	struct pt_regs * regs)
+{
+	do_timer(regs);
+
+	/*
+	 * If we have an externally synchronized Linux clock, then update
+	 * CMOS clock accordingly every ~11 minutes. Set_rtc_mmss() has to be
+	 * called as close as possible to 500 ms before the new second starts.
+	 */
+	if ((time_status & STA_UNSYNC) == 0
+		&& xtime.tv_sec > last_rtc_update + 660
+		&& (xtime.tv_nsec / 1000) >= 500000 - ((unsigned)TICK_SIZE) / 2
+		&& (xtime.tv_nsec / 1000) <= 500000 + ((unsigned)TICK_SIZE) / 2)
+	{
+		if (set_rtc_mmss(xtime.tv_sec) == 0)
+			last_rtc_update = xtime.tv_sec;
+		else	/* do it again in 60 s */
+			last_rtc_update = xtime.tv_sec - 600;
+	}
+	/* As we return to user mode fire off the other CPU schedulers.. 
+	   this is basically because we don't yet share IRQ's around. 
+	   This message is rigged to be safe on the 386 - basically it's 
+	   a hack, so don't look closely for now.. */
+
+#ifdef CONFIG_SMP
+	smp_local_timer_interrupt(regs);
+#endif
+}
+
+irqreturn_t timer_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	write_seqlock(&xtime_lock);
+	do_timer_interrupt(irq, NULL, regs);
+	write_sequnlock(&xtime_lock);
+
+#ifndef CONFIG_SMP
+	m32r_do_profile(regs);
+#endif
+
+	return IRQ_HANDLED;
+}
+
+struct irqaction irq0 = { timer_interrupt, SA_INTERRUPT, 0, "MFT2", NULL, 
+	NULL };
+
+void __init time_init(void)
+{
+	unsigned int epoch, year, mon, day, hour, min, sec;
+
+	sec = min = hour = day = mon = year = 0;
+	epoch = 0;
+
+	year = 23;
+	mon = 4;
+	day = 17;
+
+	/* Attempt to guess the epoch.  This is the same heuristic as in rtc.c 
+	   so no stupid things will happen to timekeeping.  Who knows, maybe 
+	   Ultrix also uses 1952 as epoch ...  */
+	if (year > 10 && year < 44)
+		epoch = 1980;
+	else if (year < 96)
+		epoch = 1952;
+	year += epoch;
+
+	xtime.tv_sec = mktime(year, mon, day, hour, min, sec);
+	xtime.tv_nsec = (INITIAL_JIFFIES % HZ) * (NSEC_PER_SEC / HZ);
+	wall_to_monotonic.tv_sec = -xtime.tv_sec;
+	wall_to_monotonic.tv_nsec = -xtime.tv_nsec;
+
+#if defined(CONFIG_CHIP_M32102) || defined(CONFIG_CHIP_XNUX2) \
+	|| defined(CONFIG_CHIP_VDEC2) || defined(CONFIG_CHIP_M32700) \
+        || defined(CONFIG_CHIP_OPSP)
+
+	/* M32102 MFT setup */
+	setup_irq(M32R_IRQ_MFT2, &irq0);
+	{
+		unsigned long bus_clock;
+		unsigned short divide;
+
+		bus_clock = boot_cpu_data.bus_clock;
+		divide = boot_cpu_data.timer_divide;
+		latch = (bus_clock/divide + HZ / 2) / HZ;
+
+		printk("Timer start : latch = %ld\n", latch);
+
+		outl((M32R_MFTMOD_CC_MASK | M32R_MFTMOD_TCCR \
+			|M32R_MFTMOD_CSSEL011), M32R_MFT2MOD_PORTL);
+		outl(latch, M32R_MFT2RLD_PORTL);
+		outl(latch, M32R_MFT2CUT_PORTL);
+		outl(0, M32R_MFT2CMPRLD_PORTL);
+		outl((M32R_MFTCR_MFT2MSK|M32R_MFTCR_MFT2EN), M32R_MFTCR_PORTL);
+	}
+
+#elif defined(CONFIG_CHIP_M32310)
+#warning time_init not implemented
+#else
+#error no chip configuration
+#endif
+}
+
+/*
+ *  Scheduler clock - returns current time in nanosec units.
+ */
+unsigned long long sched_clock(void)
+{
+	return (unsigned long long)jiffies * (1000000000 / HZ);
+}
+
diff -ruN linux-2.6.7.org/arch/m32r/kernel/traps.c linux-2.6.7/arch/m32r/kernel/traps.c
--- linux-2.6.7.org/arch/m32r/kernel/traps.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/traps.c	2004-05-19 18:53:08.000000000 +0900
@@ -0,0 +1,383 @@
+/*
+ *  linux/arch/m32r/kernel/traps.c
+ *
+ *  Copyright (C) 2001, 2002  Hirokazu Takata, Hiroyuki Kondo, 
+ *                            Hitoshi Yamamoto
+ */
+
+/* $Id$ */
+
+/*
+ * 'traps.c' handles hardware traps and faults after we have saved some
+ * state in 'entry.S'.
+ */
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/kallsyms.h>
+#include <linux/stddef.h>
+#include <linux/ptrace.h>
+#include <linux/mm.h>
+#include <asm/page.h>
+#include <asm/processor.h>
+
+#include <asm/system.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/atomic.h>
+
+#include <asm/smp.h>
+
+#include <linux/module.h>
+
+#if defined(CONFIG_MMU)
+#define PIE_HANDLER "pie_handler"
+#define ACE_HANDLER "ace_handler"
+#define TME_HANDLER "tme_handler"
+#else
+#define PIE_HANDLER "default_eit_handler"
+#define ACE_HANDLER "default_eit_handler"
+#define TME_HANDLER "default_eit_handler"
+#endif
+
+asmlinkage void alignment_check(void);
+asmlinkage void ei_handler(void);
+asmlinkage void rie_handler(void);
+asmlinkage void debug_trap(void);
+asmlinkage void cache_flushing_handler(void);
+
+asm (
+	"	.section .eit_vector,\"ax\"	\n"
+	"	.balign 4			\n"
+	"	.global _RE			\n"
+	"	.global default_eit_handler	\n"
+	"	.global system_call		\n"
+	"	.global " PIE_HANDLER "		\n"
+	"	.global " ACE_HANDLER "		\n"
+	"	.global " TME_HANDLER "		\n"
+	"_RE:	seth	r0, 0x01		\n"
+	"	bra	default_eit_handler	\n"
+	"	.long	0,0			\n"
+	"_SBI:	seth	r0, 0x10		\n"
+	"	bra	default_eit_handler	\n"
+	"	.long	0,0			\n"
+	"_RIE:	bra	rie_handler		\n"
+	"	.long	0,0,0			\n"
+	"_AE:	bra	alignment_check		\n"
+	"	.long	0,0,0			\n"
+	"_TRAP0:				\n"
+	"	bra	_TRAP0			\n"
+	"_TRAP1:				\n"
+	"	bra	debug_trap		\n"
+	"_TRAP2:				\n"
+	"	bra	system_call		\n"
+	"_TRAP3:				\n"
+	"	bra	_TRAP3			\n"
+	"_TRAP4:				\n"
+	"	bra	_TRAP4			\n"
+	"_TRAP5:				\n"
+	"	bra	_TRAP5			\n"
+	"_TRAP6:				\n"
+	"	bra	_TRAP6			\n"
+	"_TRAP7:				\n"
+	"	bra	_TRAP7			\n"
+	"_TRAP8:				\n"
+	"	bra	_TRAP8			\n"
+	"_TRAP9:				\n"
+	"	bra	_TRAP9			\n"
+	"_TRAP10:				\n"
+	"	bra	_TRAP10			\n"
+	"_TRAP11:				\n"
+	"	bra	_TRAP11			\n"
+	"_TRAP12:				\n"
+	"	bra	cache_flushing_handler	\n"
+	"_TRAP13:				\n"
+	"	bra	_TRAP13			\n"
+	"_TRAP14:				\n"
+	"	bra	_TRAP14			\n"
+	"_TRAP15:				\n"
+	"	bra	_TRAP15			\n"
+	"_EI:	bra	ei_handler		\n"
+	"	.long   0,0,0			\n"
+	"	.previous			\n"
+);
+
+asm (
+	"	.section .eit_vector1,\"ax\"	\n"
+	"_BRA_SYSCAL:				\n"
+	"	bra	system_call		\n"
+	"	.long	0,0,0			\n"
+	"	.previous			\n"
+);
+
+asm (
+	"	.section .eit_vector2,\"ax\"	\n"
+	"_PIE:					\n"
+	"	bra	" PIE_HANDLER "		\n"
+	"	.long   0,0,0			\n"
+	"_TLB_ACE:				\n"
+	"	bra	" ACE_HANDLER "		\n"
+	"	.long   0,0,0			\n"
+	"_TLB_MIS:				\n"
+	"	bra	" TME_HANDLER "		\n"
+	"	.long   0,0,0			\n"
+	"	.previous 			\n"
+);
+
+#ifdef CONFIG_SMP
+/* 
+ * for IPI
+ */
+asm (
+	"	.section .eit_vector3,\"ax\"		\n"
+	"	.global smp_reschedule_interrupt	\n"
+	"	.global smp_invalidate_interrupt	\n"
+	"	.global smp_call_function_interrupt	\n"
+	"	.global smp_ipi_timer_interrupt		\n"
+	"	.global smp_flush_cache_all_interrupt	\n"
+	"	.global _EI_VEC_TABLE			\n"
+	"_EI_VEC_TABLE:					\n"
+	"	.fill 56, 4, 0				\n"
+	"	.long smp_reschedule_interrupt		\n"
+	"	.long smp_invalidate_interrupt		\n"
+	"	.long smp_call_function_interrupt	\n"
+	"	.long smp_ipi_timer_interrupt		\n"
+	"	.long smp_flush_cache_all_interrupt	\n"
+	"	.fill 4, 4, 0				\n"
+	"	.previous				\n"
+);
+
+/* 
+ * for Boot AP function
+ */
+asm (
+	"	.section .eit_vector4,\"ax\"	\n"
+	"	.global _AP_RE			\n"
+	"	.global startup_AP		\n"
+	"_AP_RE:				\n"
+	"	.fill 32, 4, 0			\n"
+	"_AP_EI: bra	startup_AP		\n"
+	"	.previous			\n"
+);
+#endif  /* CONFIG_SMP */
+
+#define	set_eit_vector_entries(void)	do { } while (0)
+
+void __init trap_init(void)
+{
+	set_eit_vector_entries();
+
+	/*
+	 * Should be a barrier for any external CPU state.
+	 */
+	cpu_init();
+}
+
+int kstack_depth_to_print = 24;
+
+void show_trace(struct task_struct *task, unsigned long *stack)
+{
+	unsigned long addr;
+
+	if (!stack)
+		stack = (unsigned long*)&stack;
+
+	printk("Call Trace: ");
+	while (!kstack_end(stack)) {
+		addr = *stack++;
+		if (kernel_text_address(addr)) {
+			printk("[<%08lx>] ", addr);
+			print_symbol("%s\n", addr);
+		}
+	}
+	printk("\n");
+}
+
+void show_stack(struct task_struct *task, unsigned long *sp)
+{
+	unsigned long  *stack;
+	int  i;
+	
+	/* 
+	 * debugging aid: "show_stack(NULL);" prints the
+	 * back trace for this cpu.
+	 */
+
+	if(sp==NULL) {
+		if (task)
+			sp = (unsigned long *)task->thread.sp;
+		else
+			sp=(unsigned long*)&sp;
+	}
+
+	stack = sp;
+	for(i=0; i < kstack_depth_to_print; i++) {
+		if (kstack_end(stack))
+			break;
+		if (i && ((i % 4) == 0))
+			printk("\n       ");
+		printk("%08lx ", *stack++);
+	}
+	printk("\n");
+	show_trace(task, sp);
+}
+
+void dump_stack(void)
+{
+	unsigned long stack;
+
+	show_trace(current, &stack);
+}
+
+EXPORT_SYMBOL(dump_stack);
+
+static void show_registers(struct pt_regs *regs)
+{
+	int i = 0;
+	int in_kernel = 1;
+	unsigned long sp;
+
+	printk("CPU:    %d\n", smp_processor_id());
+	show_regs(regs);
+
+	sp = (unsigned long) (1+regs);
+	if (user_mode(regs)) {
+		in_kernel = 0;
+		sp = regs->spu;
+		printk("SPU: %08lx\n", sp);
+	} else {
+		printk("SPI: %08lx\n", sp);
+	}
+	printk("Process %s (pid: %d, process nr: %d, stackpage=%08lx)",
+		current->comm, current->pid, 0xffff & i, 4096+(unsigned long)current);
+
+	/*
+	 * When in-kernel, we also print out the stack and code at the
+	 * time of the fault..
+	 */
+	if (in_kernel) {
+		printk("\nStack: ");
+		show_stack(current, (unsigned long*) sp);
+
+		printk("\nCode: ");
+		if (regs->bpc < PAGE_OFFSET)
+			goto bad;
+
+		for(i=0;i<20;i++) {
+			unsigned char c;
+			if (__get_user(c, &((unsigned char*)regs->bpc)[i])) {
+bad:
+				printk(" Bad PC value.");
+				break;
+			}
+			printk("%02x ", c);
+		}
+	}
+	printk("\n");
+}	
+
+spinlock_t die_lock = SPIN_LOCK_UNLOCKED;
+
+void die(const char * str, struct pt_regs * regs, long err)
+{
+	console_verbose();
+	spin_lock_irq(&die_lock);
+	bust_spinlocks(1);
+	printk("%s: %04lx\n", str, err & 0xffff);
+	show_registers(regs);
+	bust_spinlocks(0);
+	spin_unlock_irq(&die_lock);
+	do_exit(SIGSEGV);
+}
+
+static __inline__ void die_if_kernel(const char * str, 
+	struct pt_regs * regs, long err)
+{
+	if (!user_mode(regs))
+		die(str, regs, err);
+}
+
+static __inline__ void do_trap(int trapnr, int signr, const char * str, 
+	struct pt_regs * regs, long error_code, siginfo_t *info)
+{
+	if (user_mode(regs)) {
+		/* trap_signal */
+		struct task_struct *tsk = current;
+		tsk->thread.error_code = error_code;
+		tsk->thread.trap_no = trapnr;
+		if (info)
+			force_sig_info(signr, info, tsk);
+		else
+			force_sig(signr, tsk);
+		return;
+	} else {
+		/* kernel_trap */
+		if (!fixup_exception(regs))
+			die(str, regs, error_code);
+		return;
+	}
+}
+
+#define DO_ERROR(trapnr, signr, str, name) \
+asmlinkage void do_##name(struct pt_regs * regs, long error_code) \
+{ \
+	do_trap(trapnr, signr, 0, regs, error_code, NULL); \
+}
+
+#define DO_ERROR_INFO(trapnr, signr, str, name, sicode, siaddr) \
+asmlinkage void do_##name(struct pt_regs * regs, long error_code) \
+{ \
+	siginfo_t info; \
+	info.si_signo = signr; \
+	info.si_errno = 0; \
+	info.si_code = sicode; \
+	info.si_addr = (void *)siaddr; \
+	do_trap(trapnr, signr, str, regs, error_code, &info); \
+}
+
+DO_ERROR( 1, SIGTRAP, "debug trap", debug_trap)
+DO_ERROR_INFO(0x20, SIGILL,  "reserved instruction ", rie_handler, ILL_ILLOPC, regs->bpc)
+DO_ERROR_INFO(0x100, SIGILL,  "privilege instruction", pie_handler, ILL_PRVOPC, regs->bpc)
+
+extern int handle_unaligned_access(unsigned long, struct pt_regs *);
+
+/* This code taken from arch/sh/kernel/traps.c */
+asmlinkage void do_alignment_check(struct pt_regs *regs, long error_code)
+{
+	mm_segment_t oldfs;
+	unsigned long insn;
+	int tmp;
+
+	oldfs = get_fs();
+
+	if (user_mode(regs)) {
+		local_irq_enable();
+		current->thread.error_code = error_code;
+		current->thread.trap_no = 0x17;
+
+		set_fs(USER_DS);
+		if (copy_from_user(&insn, (void *)regs->bpc, 4)) {
+			set_fs(oldfs);
+			goto uspace_segv;
+		}
+		tmp = handle_unaligned_access(insn, regs);
+		set_fs(oldfs);
+
+		if (!tmp)
+			return;
+
+	uspace_segv:
+		printk(KERN_NOTICE "Killing process \"%s\" due to unaligned "
+			"access\n", current->comm);
+		force_sig(SIGSEGV, current);
+	} else {
+		set_fs(KERNEL_DS);
+		if (copy_from_user(&insn, (void *)regs->bpc, 4)) {
+			set_fs(oldfs);
+			die("insn faulting in do_address_error", regs, 0);
+		}
+		handle_unaligned_access(insn, regs);
+		set_fs(oldfs);
+	}
+}
+
diff -ruN linux-2.6.7.org/arch/m32r/kernel/vmlinux.lds.S linux-2.6.7/arch/m32r/kernel/vmlinux.lds.S
--- linux-2.6.7.org/arch/m32r/kernel/vmlinux.lds.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/kernel/vmlinux.lds.S	2004-07-27 15:54:20.000000000 +0900
@@ -0,0 +1,160 @@
+/* ld script to make M32R Linux kernel
+ */
+
+#include <linux/config.h>
+#include <asm-generic/vmlinux.lds.h>
+#include <asm/addrspace.h>
+#include <asm/page.h>
+
+OUTPUT_ARCH(m32r)
+ENTRY(startup_32)
+#if defined(__LITTLE_ENDIAN__)
+       jiffies = jiffies_64;
+#else
+       jiffies = jiffies_64 + 4;
+#endif
+SECTIONS
+{
+#if defined(CONFIG_PLAT_MAPPI) || defined(CONFIG_PLAT_USRV) \
+	|| defined(CONFIG_PLAT_M32700UT) || defined(CONFIG_PLAT_OAKS32R) \
+	|| defined(CONFIG_PLAT_MAPPI2) || defined(CONFIG_PLAT_OPSPUT)
+  . = CONFIG_MEMORY_START + __PAGE_OFFSET + 0x00000000;
+  .eit_vector : { *(.eit_vector) }
+  . = CONFIG_MEMORY_START + __PAGE_OFFSET + 0x00000100;
+  .eit_vector2 : { *(.eit_vector2) }
+#if defined(CONFIG_SMP)
+  . = CONFIG_MEMORY_START + __PAGE_OFFSET + 0x00000200;
+  .eit_vector3 : { *(.eit_vector3) }
+#endif
+  . = CONFIG_MEMORY_START + __PAGE_OFFSET + 0x00001000;
+#else
+#error "Unknown platform"
+#endif
+
+  _boot = .;
+  .boot : { *(.boot) } = 0
+
+  . = ALIGN(4096);
+  .empty_zero_page : { *(.empty_zero_page) } = 0
+
+  /* read-only */
+  _text = .;			/* Text and read-only data */
+  .text : {
+	*(.text)
+	SCHED_TEXT
+	*(.fixup)
+	*(.gnu.warning)
+	} = 0x9090
+#ifdef CONFIG_SMP
+  . = ALIGN(65536);
+  .eit_vector4 : { *(.eit_vector4) }
+#endif
+  _etext = .;			/* End of text section */
+
+  . = ALIGN(16);		/* Exception table */
+  __start___ex_table = .;
+  __ex_table : { *(__ex_table) }
+  __stop___ex_table = .;
+
+  RODATA
+
+  /* writeable */
+  .data : {			/* Data */
+	*(.spu)
+	*(.spi)
+	*(.data)
+	CONSTRUCTORS
+	}
+
+  . = ALIGN(4096);
+  __nosave_begin = .;
+  .data_nosave : { *(.data.nosave) }
+  . = ALIGN(4096);
+  __nosave_end = .;
+
+  . = ALIGN(4096);
+  .data.page_aligned : { *(.data.idt) }
+
+  . = ALIGN(32);
+  .data.cacheline_aligned : { *(.data.cacheline_aligned) }
+
+  _edata = .;			/* End of data section */
+
+  . = ALIGN(8192);		/* init_task */
+  .data.init_task : { *(.data.init_task) }
+
+  /* will be freed after init */
+  . = ALIGN(4096);		/* Init code and data */
+  __init_begin = .;
+  .init.text : {
+	_sinittext = .;
+	*(.init.text)
+	_einittext = .;
+  }
+  .init.data : { *(.init.data) }
+  . = ALIGN(16);
+  __setup_start = .;
+  .init.setup : { *(.init.setup) }
+  __setup_end = .;
+  __start___param = .;
+  __param : { *(__param) }
+  __stop___param = .;
+  __initcall_start = .;
+  .initcall.init : {
+	*(.initcall1.init) 
+	*(.initcall2.init) 
+	*(.initcall3.init) 
+	*(.initcall4.init) 
+	*(.initcall5.init) 
+	*(.initcall6.init) 
+	*(.initcall7.init)
+  }
+  __initcall_end = .;
+  __con_initcall_start = .;
+  .con_initcall.init : { *(.con_initcall.init) }
+  __con_initcall_end = .;
+  SECURITY_INIT
+  . = ALIGN(4);
+  __alt_instructions = .;
+  .altinstructions : { *(.altinstructions) }
+  __alt_instructions_end = .;
+  .altinstr_replacement : { *(.altinstr_replacement) }
+  /* .exit.text is discard at runtime, not link time, to deal with references
+     from .altinstructions and .eh_frame */
+  .exit.text : { *(.exit.text) }
+  .exit.data : { *(.exit.data) }
+  . = ALIGN(4096);
+  __initramfs_start = .;
+  .init.ramfs : { *(.init.ramfs) }
+  __initramfs_end = .;
+  . = ALIGN(32);
+  __per_cpu_start = .;
+  .data.percpu  : { *(.data.percpu) }
+  __per_cpu_end = .;
+  . = ALIGN(4096);
+  __init_end = .;
+  /* freed after init ends here */
+	
+  __bss_start = .;		/* BSS */
+  .bss : { *(.bss) }
+  . = ALIGN(4);
+  __bss_stop = .; 
+
+  _end = . ;
+
+  /* Sections to be discarded */
+  /DISCARD/ : {
+	*(.exit.text)
+	*(.exit.data)
+	*(.exitcall.exit)
+	}
+
+  /* Stabs debugging sections.  */
+  .stab 0 : { *(.stab) }
+  .stabstr 0 : { *(.stabstr) }
+  .stab.excl 0 : { *(.stab.excl) }
+  .stab.exclstr 0 : { *(.stab.exclstr) }
+  .stab.index 0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+  .comment 0 : { *(.comment) }
+}
diff -ruN linux-2.6.7.org/arch/m32r/lib/Makefile linux-2.6.7/arch/m32r/lib/Makefile
--- linux-2.6.7.org/arch/m32r/lib/Makefile	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/lib/Makefile	2004-05-28 21:55:51.000000000 +0900
@@ -0,0 +1,7 @@
+#
+# Makefile for M32R-specific library files..
+#
+
+lib-y  := checksum.o ashxdi3.o memset.o memcpy.o getuser.o \
+	  putuser.o delay.o strlen.o usercopy.o csum_partial_copy.o
+
diff -ruN linux-2.6.7.org/arch/m32r/lib/ashxdi3.S linux-2.6.7/arch/m32r/lib/ashxdi3.S
--- linux-2.6.7.org/arch/m32r/lib/ashxdi3.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/lib/ashxdi3.S	2004-02-09 15:20:30.000000000 +0900
@@ -0,0 +1,297 @@
+/*
+ * linux/arch/m32r/lib/ashxdi3.S
+ *
+ * Copyright (C) 2001,2002  Hiroyuki Kondo, and Hirokazu Takata
+ *
+ */
+/* $Id$ */
+
+#include <linux/config.h>
+
+;
+;      input   (r0,r1)  src
+;      input    r2      shift val
+;               r3      scratch
+;      output  (r0,r1)
+;
+
+#ifdef CONFIG_ISA_DUAL_ISSUE
+
+#ifndef __LITTLE_ENDIAN__
+	
+	.text
+	.align	4
+	.globl __ashrdi3
+__ashrdi3:
+	cmpz	r2		    ||	ldi	r3, #32
+	jc	r14		    ||	cmpu	r2, r3
+	bc      1f
+    ;   case 32 =< shift
+	mv      r1, r0		    ||	srai    r0, #31
+	addi    r2, #-32
+	sra     r1, r2
+	jmp     r14
+	.fillinsn
+1:  ;   case shift <32
+	mv      r3, r0		    ||	srl     r1, r2
+	sra     r0, r2		    ||	neg     r2, r2
+	sll     r3, r2
+	or      r1, r3		    ||	jmp	r14
+
+        .align  4
+        .globl __ashldi3
+        .globl __lshldi3
+__ashldi3:
+__lshldi3:
+	cmpz	r2		    ||	ldi	r3, #32
+	jc	r14		    ||	cmpu	r2, r3
+	bc      1f
+    ;   case 32 =< shift
+	mv      r0, r1		    ||	addi    r2, #-32
+	sll     r0, r2		    ||	ldi     r1, #0
+	jmp     r14
+	.fillinsn
+1:  ;   case shift <32
+	mv      r3, r1		    ||	sll     r0, r2
+	sll     r1, r2		    ||	neg     r2, r2
+	srl     r3, r2
+	or      r0, r3		    ||	jmp	r14
+
+	.align	4
+	.globl __lshrdi3
+__lshrdi3:
+	cmpz	r2		    ||	ldi	r3, #32
+	jc	r14		    ||	cmpu	r2, r3
+	bc      1f
+    ;   case 32 =< shift
+	mv      r1, r0		    ||	addi    r2, #-32
+	ldi	r0, #0		    ||	srl     r1, r2	
+	jmp     r14
+	.fillinsn
+1:  ;   case shift <32
+	mv      r3, r0		    ||	srl     r1, r2
+	srl     r0, r2		    ||	neg     r2, r2
+	sll     r3, r2
+	or      r1, r3		    ||	jmp	r14
+
+#else /* LITTLE_ENDIAN */
+	
+	.text
+	.align	4
+	.globl __ashrdi3
+__ashrdi3:
+	cmpz	r2		    ||	ldi	r3, #32
+	jc	r14		    ||	cmpu	r2, r3
+	bc      1f
+    ;   case 32 =< shift
+	mv      r0, r1		    ||	srai    r1, #31
+	addi    r2, #-32
+	sra     r0, r2
+	jmp     r14
+	.fillinsn
+1:  ;   case shift <32
+	mv      r3, r1		    ||	srl     r0, r2
+	sra     r1, r2		    ||	neg     r2, r2
+	sll     r3, r2
+	or      r0, r3		    ||	jmp	r14
+
+        .align  4
+        .globl __ashldi3
+        .globl __lshldi3
+__ashldi3:
+__lshldi3:
+	cmpz	r2		    ||	ldi	r3, #32
+	jc	r14		    ||	cmpu	r2, r3
+	bc      1f
+    ;   case 32 =< shift
+	mv      r1, r0		    ||	addi    r2, #-32
+	sll     r1, r2		    ||	ldi     r0, #0
+	jmp     r14
+	.fillinsn
+1:  ;   case shift <32
+	mv      r3, r0		    ||	sll     r1, r2
+	sll     r0, r2		    ||	neg     r2, r2
+	srl     r3, r2
+	or      r1, r3		    ||	jmp	r14
+
+	.align	4
+	.globl __lshrdi3
+__lshrdi3:
+	cmpz	r2		    ||	ldi	r3, #32
+	jc	r14		    ||	cmpu	r2, r3
+	bc      1f
+    ;   case 32 =< shift
+	mv      r0, r1		    ||	addi    r2, #-32
+	ldi	r1, #0		    ||	srl     r0, r2	
+	jmp     r14
+	.fillinsn
+1:  ;   case shift <32
+	mv      r3, r1		    ||	srl     r0, r2
+	srl     r1, r2		    ||	neg     r2, r2
+	sll     r3, r2
+	or      r0, r3		    ||	jmp	r14
+
+#endif	
+
+#else /* not CONFIG_ISA_DUAL_ISSUE */
+
+#ifndef __LITTLE_ENDIAN__
+	
+	.text
+	.align	4
+	.globl __ashrdi3
+__ashrdi3:
+	beqz	r2, 2f
+	cmpui   r2, #32
+	bc      1f
+    ;   case 32 =< shift
+	mv      r1, r0
+	srai    r0, #31
+	addi    r2, #-32
+	sra     r1, r2
+	jmp     r14
+	.fillinsn
+1:  ;   case shift <32
+	mv      r3, r0
+	srl     r1, r2
+	sra     r0, r2
+	neg     r2, r2
+	sll     r3, r2
+	or      r1, r3
+	.fillinsn
+2:
+	jmp	r14
+
+        .align  4
+        .globl __ashldi3
+        .globl __lshldi3
+__ashldi3:
+__lshldi3:
+	beqz	r2, 2f
+	cmpui   r2, #32
+	bc      1f
+    ;   case 32 =< shift
+	mv      r0, r1
+	addi    r2, #-32
+	sll     r0, r2
+	ldi     r1, #0
+	jmp     r14
+	.fillinsn
+1:  ;   case shift <32
+	mv      r3, r1
+	sll     r0, r2
+	sll     r1, r2
+	neg     r2, r2
+	srl     r3, r2
+	or      r0, r3
+	.fillinsn
+2:
+	jmp	r14
+
+	.align	4
+	.globl __lshrdi3
+__lshrdi3:
+	beqz	r2, 2f
+	cmpui   r2, #32
+	bc      1f
+    ;   case 32 =< shift
+	mv      r1, r0
+	ldi	r0, #0
+	addi    r2, #-32
+	srl     r1, r2
+	jmp     r14
+	.fillinsn
+1:  ;   case shift <32
+	mv      r3, r0
+	srl     r1, r2
+	srl     r0, r2
+	neg     r2, r2
+	sll     r3, r2
+	or      r1, r3
+	.fillinsn
+2:
+	jmp	r14
+
+#else
+	
+	.text
+	.align	4
+	.globl __ashrdi3
+__ashrdi3:
+	beqz	r2, 2f
+	cmpui   r2, #32
+	bc      1f
+    ;   case 32 =< shift
+	mv      r0, r1
+	srai    r1, #31
+	addi    r2, #-32
+	sra     r0, r2
+	jmp     r14
+	.fillinsn
+1:  ;   case shift <32
+	mv      r3, r1
+	srl     r0, r2
+	sra     r1, r2
+	neg     r2, r2
+	sll     r3, r2
+	or      r0, r3
+	.fillinsn
+2:
+	jmp	r14
+
+        .align  4
+        .globl __ashldi3
+        .globl __lshldi3
+__ashldi3:
+__lshldi3:
+	beqz	r2, 2f
+	cmpui   r2, #32
+	bc      1f
+    ;   case 32 =< shift
+	mv      r1, r0
+	addi    r2, #-32
+	sll     r1, r2
+	ldi     r0, #0
+	jmp     r14
+	.fillinsn
+1:  ;   case shift <32
+	mv      r3, r0
+	sll     r1, r2
+	sll     r0, r2
+	neg     r2, r2
+	srl     r3, r2
+	or      r1, r3
+	.fillinsn
+2:
+	jmp	r14
+
+	.align	4
+	.globl __lshrdi3
+__lshrdi3:
+	beqz	r2, 2f
+	cmpui   r2, #32
+	bc      1f
+    ;   case 32 =< shift
+	mv      r0, r1
+	ldi	r1, #0
+	addi    r2, #-32
+	srl     r0, r2
+	jmp     r14
+	.fillinsn
+1:  ;   case shift <32
+	mv      r3, r1
+	srl     r0, r2
+	srl     r1, r2
+	neg     r2, r2
+	sll     r3, r2
+	or      r0, r3
+	.fillinsn
+2:
+	jmp	r14
+
+#endif		
+
+#endif /* not CONFIG_ISA_DUAL_ISSUE */
+
+	.end
+
diff -ruN linux-2.6.7.org/arch/m32r/lib/checksum.S linux-2.6.7/arch/m32r/lib/checksum.S
--- linux-2.6.7.org/arch/m32r/lib/checksum.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/lib/checksum.S	2004-08-24 17:35:56.000000000 +0900
@@ -0,0 +1,322 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		IP/TCP/UDP checksumming routines
+ *
+ * Authors:	Jorge Cwik, <jorge@laser.satlink.net>
+ *		Arnt Gulbrandsen, <agulbra@nvg.unit.no>
+ *		Tom May, <ftom@netcom.com>
+ *              Pentium Pro/II routines:
+ *              Alexander Kjeldaas <astor@guardian.no>
+ *              Finn Arne Gangstad <finnag@guardian.no>
+ *		Lots of code moved from tcp.c and ip.c; see those files
+ *		for more names.
+ *
+ * Changes:     Ingo Molnar, converted csum_partial_copy() to 2.1 exception
+ *			     handling.
+ *		Andi Kleen,  add zeroing on error
+ *                   converted to pure assembler
+ *		Hirokazu Takata,Hiroyuki Kondo rewrite for the m32r architecture.
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+/* $Id$ */
+
+
+#include <linux/config.h>
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+#include <asm/errno.h>
+				
+/*
+ * computes a partial checksum, e.g. for TCP/UDP fragments
+ */
+
+/*	
+unsigned int csum_partial(const unsigned char * buff, int len, unsigned int sum)
+ */
+		
+		
+#ifdef CONFIG_ISA_DUAL_ISSUE
+
+	/*		
+	 * Experiments with Ethernet and SLIP connections show that buff
+	 * is aligned on either a 2-byte or 4-byte boundary.  We get at
+	 * least a twofold speedup on 486 and Pentium if it is 4-byte aligned.
+	 * Fortunately, it is easy to convert 2-byte alignment to 4-byte
+	 * alignment for the unrolled loop.
+	 */		
+
+	.text
+ENTRY(csum_partial)
+	; Function args
+	;  r0: unsigned char *buff
+	;  r1: int len
+	;  r2: unsigned int sum
+
+	push	r2		    ||	ldi	r2, #0
+	and3	r7, r0, #1		; Check alignment.
+	beqz	r7, 1f	 		; Jump if alignment is ok.
+	; 1-byte mis aligned
+	ldub	r4, @r0		    ||	addi	r0, #1
+	; clear c-bit || Alignment uses up bytes.
+	cmp	r0, r0		    ||	addi	r1, #-1		
+	ldi	r3, #0		    ||	addx	r2, r4
+	addx	r2, r3
+	.fillinsn
+1:
+	and3	r4, r0, #2		; Check alignment.
+	beqz	r4, 2f	 		; Jump if alignment is ok.
+	; clear c-bit || Alignment uses up two bytes.
+	cmp	r0, r0		    ||	addi	r1, #-2
+	bgtz	r1, 1f			; Jump if we had at least two bytes.
+	bra	4f		    ||	addi	r1, #2	
+	.fillinsn			; len(r1) was < 2.  Deal with it.
+1:
+	; 2-byte aligned
+	lduh	r4, @r0		    ||	ldi	r3, #0
+	addx	r2, r4		    ||	addi	r0, #2
+	addx	r2, r3
+	.fillinsn
+2:
+	; 4-byte aligned
+	cmp	r0, r0			; clear c-bit
+	srl3	r6, r1, #5
+	beqz	r6, 2f
+	.fillinsn
+
+1:	ld	r3, @r0+
+	ld	r4, @r0+					; +4
+	ld	r5, @r0+					; +8
+	ld	r3, @r0+	    ||	addx    r2, r3		; +12
+	ld	r4, @r0+	    ||	addx    r2, r4		; +16
+	ld	r5, @r0+	    ||	addx    r2, r5		; +20
+	ld	r3, @r0+	    ||	addx    r2, r3		; +24
+	ld	r4, @r0+	    ||	addx    r2, r4		; +28
+	addx	r2, r5		    ||	addi	r6, #-1
+	addx	r2, r3
+	addx	r2, r4
+	bnez	r6, 1b
+
+	addx	r2, r6			; r6=0
+	cmp	r0, r0			; This clears c-bit
+	.fillinsn
+2:	and3	r6, r1, #0x1c		; withdraw len
+	beqz	r6, 4f
+	srli	r6, #2
+	.fillinsn
+
+3:	ld	r4, @r0+	    ||	addi	r6, #-1
+	addx	r2, r4
+	bnez	r6, 3b
+
+	addx	r2, r6			; r6=0
+	cmp	r0, r0			; This clears c-bit
+	.fillinsn
+4:	and3	r1, r1, #3
+	beqz	r1, 7f			; if len == 0 goto end
+	and3	r6, r1, #2
+	beqz	r6, 5f			; if len < 2  goto 5f(1byte)
+	lduh	r4, @r0		    ||	addi	r0, #2
+	addi	r1, #-2		    ||	slli    r4, #16
+	addx	r2, r4
+	beqz	r1, 6f
+	.fillinsn
+5:	ldub	r4, @r0		    ||	ldi	r1, #0
+#ifndef __LITTLE_ENDIAN__
+	slli    r4, #8
+#endif
+	addx	r2, r4
+	.fillinsn
+6:	addx	r2, r1
+	.fillinsn
+7:	
+	and3	r0, r2, #0xffff
+	srli	r2, #16
+	add	r0, r2
+	srl3	r2, r0, #16
+	beqz	r2, 1f
+	addi	r0, #1
+	and3	r0, r0, #0xffff
+	.fillinsn
+1:
+	beqz	r7, 1f			; swap the upper byte for the lower
+	and3	r2, r0, #0xff
+	srl3	r0, r0, #8
+	slli	r2, #8
+	or	r0, r2
+	.fillinsn
+1:
+	pop	r2		    ||	cmp	r0, r0
+	addx	r0, r2		    ||	ldi	r2, #0
+	addx	r0, r2
+	jmp	r14
+
+#else /* not CONFIG_ISA_DUAL_ISSUE */
+		
+	/*		
+	 * Experiments with Ethernet and SLIP connections show that buff
+	 * is aligned on either a 2-byte or 4-byte boundary.  We get at
+	 * least a twofold speedup on 486 and Pentium if it is 4-byte aligned.
+	 * Fortunately, it is easy to convert 2-byte alignment to 4-byte
+	 * alignment for the unrolled loop.
+	 */		
+
+	.text
+ENTRY(csum_partial)
+	; Function args
+	;  r0: unsigned char *buff
+	;  r1: int len
+	;  r2: unsigned int sum
+
+	push	r2
+	ldi	r2, #0
+	and3	r7, r0, #1		; Check alignment.
+	beqz	r7, 1f	 		; Jump if alignment is ok.
+	; 1-byte mis aligned
+	ldub	r4, @r0
+	addi	r0, #1
+	addi	r1, #-1			; Alignment uses up bytes.
+	cmp	r0, r0			; clear c-bit
+	ldi	r3, #0
+	addx	r2, r4
+	addx	r2, r3
+	.fillinsn
+1:
+	and3	r4, r0, #2		; Check alignment.
+	beqz	r4, 2f	 		; Jump if alignment is ok.
+	addi	r1, #-2			; Alignment uses up two bytes.
+	cmp		r0, r0			; clear c-bit
+	bgtz	r1, 1f			; Jump if we had at least two bytes.
+	addi	r1, #2			; len(r1) was < 2.  Deal with it.
+	bra	4f
+	.fillinsn
+1:
+	; 2-byte aligned
+	lduh	r4, @r0
+	addi	r0, #2
+	ldi		r3, #0
+	addx	r2, r4
+	addx	r2, r3
+	.fillinsn
+2:
+	; 4-byte aligned
+	cmp	r0, r0			; clear c-bit
+	srl3	r6, r1, #5
+	beqz	r6, 2f
+	.fillinsn
+
+1:	ld	r3, @r0+
+	ld	r4, @r0+		; +4
+	ld	r5, @r0+		; +8
+	addx	r2, r3
+	addx	r2, r4
+	addx	r2, r5
+	ld	r3, @r0+		; +12
+	ld	r4, @r0+		; +16
+	ld	r5, @r0+		; +20
+	addx	r2, r3
+	addx	r2, r4
+	addx	r2, r5
+	ld	r3, @r0+		; +24
+	ld	r4, @r0+		; +28
+	addi	r6, #-1
+	addx	r2, r3
+	addx	r2, r4
+	bnez	r6, 1b
+	addx	r2, r6			; r6=0
+	cmp	r0, r0			; This clears c-bit
+	.fillinsn
+
+2:	and3	r6, r1, #0x1c		; withdraw len
+	beqz	r6, 4f
+	srli	r6, #2
+	.fillinsn
+
+3:	ld	r4, @r0+
+	addi	r6, #-1
+	addx	r2, r4
+	bnez	r6, 3b
+	addx	r2, r6			; r6=0
+	cmp	r0, r0			; This clears c-bit
+	.fillinsn
+
+4:	and3	r1, r1, #3
+	beqz	r1, 7f			; if len == 0 goto end
+	and3	r6, r1, #2
+	beqz	r6, 5f			; if len < 2  goto 5f(1byte)
+
+	lduh	r4, @r0
+	addi	r0, #2
+	addi	r1, #-2
+	slli    r4, #16
+	addx	r2, r4
+	beqz	r1, 6f
+	.fillinsn
+5:	ldub	r4, @r0
+#ifndef __LITTLE_ENDIAN__
+	slli    r4, #8
+#endif
+	addx	r2, r4
+	.fillinsn
+6:	ldi	r5, #0
+	addx	r2, r5
+	.fillinsn
+7:	
+	and3	r0, r2, #0xffff
+	srli	r2, #16
+	add	r0, r2
+	srl3	r2, r0, #16
+	beqz	r2, 1f
+	addi	r0, #1
+	and3	r0, r0, #0xffff
+	.fillinsn
+1:
+	beqz	r7, 1f
+	mv	r2, r0
+	srl3	r0, r2, #8
+	and3	r2, r2, #0xff
+	slli	r2, #8
+	or	r0, r2
+	.fillinsn
+1:
+	pop	r2
+	cmp	r0, r0
+	addx	r0, r2
+	ldi	r2, #0
+	addx	r0, r2
+	jmp	r14
+
+#endif /* not CONFIG_ISA_DUAL_ISSUE */
+
+/*
+unsigned int csum_partial_copy_generic (const char *src, char *dst,
+				  int len, int sum, int *src_err_ptr, int *dst_err_ptr)
+ */ 
+
+/*
+ * Copy from ds while checksumming, otherwise like csum_partial
+ *
+ * The macros SRC and DST specify the type of access for the instruction.
+ * thus we can call a custom exception handler for all access types.
+ *
+ * FIXME: could someone double-check whether I haven't mixed up some SRC and
+ *	  DST definitions? It's damn hard to trigger all cases.  I hope I got
+ *	  them all but there's no guarantee.
+ */
+
+ENTRY(csum_partial_copy_generic)
+	nop
+	nop
+	nop
+	nop
+	jmp r14
+	nop
+	nop
+	nop
+
diff -ruN linux-2.6.7.org/arch/m32r/lib/csum_partial_copy.c linux-2.6.7/arch/m32r/lib/csum_partial_copy.c
--- linux-2.6.7.org/arch/m32r/lib/csum_partial_copy.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/lib/csum_partial_copy.c	2003-09-09 10:15:02.000000000 +0900
@@ -0,0 +1,77 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		MIPS specific IP/TCP/UDP checksumming routines
+ *
+ * Authors:	Ralf Baechle, <ralf@waldorf-gmbh.de>
+ *		Lots of code moved from tcp.c and ip.c; see those files
+ *		for more names.
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ * $Id$
+ */
+#include <net/checksum.h>
+#include <linux/types.h>
+#include <asm/byteorder.h>
+#include <asm/string.h>
+#include <asm/uaccess.h>
+
+/*
+ * copy while checksumming, otherwise like csum_partial
+ */
+unsigned int csum_partial_copy(const char *src, char *dst, 
+                               int len, int sum)
+{
+	/*
+	 * It's 2:30 am and I don't feel like doing it real ...
+	 * This is lots slower than the real thing (tm)
+	 */
+	sum = csum_partial(src, len, sum);
+	memcpy(dst, src, len);
+
+	return sum;
+}
+
+/*
+ * Copy from userspace and compute checksum.  If we catch an exception
+ * then zero the rest of the buffer.
+unsigned int csum_partial_copy_from_user (const char *src, char *dst,
+                                          int len, unsigned int sum,
+                                          int *err_ptr)
+ */
+unsigned int csum_partial_copy_generic_from (const char *src, char *dst,
+                                          int len, unsigned int sum,
+                                          int *err_ptr)
+{
+	int missing;
+
+	missing = copy_from_user(dst, src, len);
+	if (missing) {
+		memset(dst + len - missing, 0, missing);
+		*err_ptr = -EFAULT;
+	}
+		
+	return csum_partial(dst, len-missing, sum);
+}
+unsigned int csum_partial_copy_generic_to (const char *src, char *dst,
+                                          int len, unsigned int sum,
+                                          int *err_ptr)
+{
+	int missing;
+
+	missing = copy_to_user(dst, src, len);
+	if (missing) {
+/*
+		memset(dst + len - missing, 0, missing);
+*/
+		*err_ptr = -EFAULT;
+	}
+		
+	return csum_partial(src, len-missing, sum);
+}
diff -ruN linux-2.6.7.org/arch/m32r/lib/delay.c linux-2.6.7/arch/m32r/lib/delay.c
--- linux-2.6.7.org/arch/m32r/lib/delay.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/lib/delay.c	2004-07-06 16:08:16.000000000 +0900
@@ -0,0 +1,124 @@
+/* 
+ * linux/arch/m32r/lib/delay.c
+ *
+ * Copyright (c) 2002  Hitoshi Yamamoto, Hirokazu Takata
+ * Copyright (c) 2004  Hirokazu Takata
+ */
+
+/* $Id$ */
+
+#include <linux/config.h>
+#include <linux/param.h>
+#ifdef CONFIG_SMP
+#include <linux/sched.h>
+#include <asm/current.h>
+#include <asm/smp.h>
+#endif  /* CONFIG_SMP */
+#include <asm/processor.h>
+
+void __delay(unsigned long loops)
+{
+#ifdef CONFIG_ISA_DUAL_ISSUE
+	__asm__ __volatile__ (
+		"beqz	%0, 2f			\n\t"
+		"addi	%0, #-1			\n\t"
+
+		" .fillinsn			\n\t"
+		"1:				\n\t"
+		"cmpz	%0  ||  addi  %0, #-1	\n\t"
+		"bc	2f  ||  cmpz  %0	\n\t"
+		"bc	2f  ||  addi  %0, #-1	\n\t"
+		"cmpz	%0  ||  addi  %0, #-1	\n\t"
+		"bc	2f  ||  cmpz  %0	\n\t"
+		"bnc	1b  ||  addi  %0, #-1	\n\t"
+		" .fillinsn			\n\t"
+		"2:				\n\t"
+		: "+r" (loops)
+		: "r" (0)
+		: "cbit"
+	);
+#else
+	__asm__ __volatile__ (
+		"beqz	%0, 2f			\n\t"
+		" .fillinsn			\n\t"
+		"1:				\n\t"
+		"addi	%0, #-1			\n\t"
+		"blez	%0, 2f			\n\t"
+		"addi	%0, #-1			\n\t"
+		"blez	%0, 2f			\n\t"
+		"addi	%0, #-1			\n\t"
+		"blez	%0, 2f			\n\t"
+		"addi	%0, #-1			\n\t"
+		"bgtz	%0, 1b			\n\t"
+		" .fillinsn			\n\t"
+		"2:i				\n\t"
+		: "+r" (loops)
+		: "r" (0)
+	);
+#endif
+}
+
+void __const_udelay(unsigned long xloops)
+{
+#if defined(CONFIG_ISA_M32R2) && defined(CONFIG_ISA_DSP_LEVEL2)
+	/* 
+	 * loops [1] = (xloops >> 32) [sec] * loops_per_jiffy [1/jiffy] 
+	 *            * HZ [jiffy/sec]
+	 *          = (xloops >> 32) [sec] * (loops_per_jiffy * HZ) [1/sec]
+	 *          = (((xloops * loops_per_jiffy) >> 32) * HZ) [1]
+	 *
+	 * NOTE: 
+	 *   - '[]' depicts variable's dimension in the above equation.
+	 *   - "rac" instruction rounds the accumulator in word size.
+	 */
+	__asm__ __volatile__ (
+		"srli	%0, #1				\n\t"
+		"mulwhi	%0, %1	; a0			\n\t"
+		"mulwu1	%0, %1	; a1			\n\t"
+		"sadd		; a0 += (a1 >> 16)	\n\t"
+		"rac	a0, a0, #1			\n\t"
+		"mvfacmi %0, a0				\n\t"
+		: "+r" (xloops)
+		: "r" (current_cpu_data.loops_per_jiffy)
+		: "a0", "a1"
+	);
+#elif defined(CONFIG_ISA_M32R2) || defined(CONFIG_ISA_M32R)
+	/* 
+	 * u64 ull;
+	 * ull = (u64)xloops * (u64)current_cpu_data.loops_per_jiffy;
+	 * xloops = (ull >> 32);
+	 */
+	__asm__ __volatile__ (
+		"and3	r4, %0, #0xffff		\n\t"
+		"and3	r5, %1, #0xffff		\n\t"
+		"mul	r4, r5			\n\t"
+		"srl3	r6, %0, #16		\n\t"
+		"srli	r4, #16			\n\t"
+		"mul	r5, r6			\n\t"
+		"add	r4, r5			\n\t"
+		"and3	r5, %0, #0xffff		\n\t"
+		"srl3	r6, %1, #16		\n\t"
+		"mul	r5, r6			\n\t"
+		"add	r4, r5			\n\t"
+		"srl3	r5, %0, #16		\n\t"
+		"srli	r4, #16			\n\t"
+		"mul	r5, r6			\n\t"
+		"add	r4, r5			\n\t"
+		"mv	%0, r4			\n\t"
+		: "+r" (xloops)
+		: "r" (current_cpu_data.loops_per_jiffy)
+		: "r4", "r5", "r6"
+	);
+#else
+#error unknown isa configuration
+#endif
+	__delay(xloops * HZ);
+}
+
+/* 
+ * 4294 = 2^32 / 10^6
+ */
+void __udelay(unsigned long usecs)
+{
+	__const_udelay(usecs * 4294UL);
+}
diff -ruN linux-2.6.7.org/arch/m32r/lib/getuser.S linux-2.6.7/arch/m32r/lib/getuser.S
--- linux-2.6.7.org/arch/m32r/lib/getuser.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/lib/getuser.S	2003-09-09 10:15:02.000000000 +0900
@@ -0,0 +1,88 @@
+/*
+ * __get_user functions.
+ *
+ * (C) Copyright 2001 Hirokazu Takata
+ *
+ * These functions have a non-standard call interface
+ * to make them more efficient, especially as they
+ * return an error value in addition to the "real"
+ * return value.
+ */
+
+#include <linux/config.h>
+
+/*
+ * __get_user_X
+ *
+ * Inputs:	r0 contains the address
+ *
+ * Outputs:	r0 is error code (0 or -EFAULT)
+ *		r1 contains zero-extended value
+ *
+ * These functions should not modify any other registers,
+ * as they get called from within inline assembly.
+ */
+
+#ifdef CONFIG_ISA_DUAL_ISSUE
+
+	.text
+	.balign 4
+	.globl __get_user_1
+__get_user_1:
+1:	ldub	r1, @r0		    ||	ldi	r0, #0
+	jmp	r14
+
+	.balign 4
+	.globl __get_user_2
+__get_user_2:
+2:	lduh	r1, @r0		    ||	ldi	r0, #0
+	jmp	r14
+
+	.balign 4
+	.globl __get_user_4
+__get_user_4:
+3:	ld	r1, @r0		    ||	ldi	r0, #0
+	jmp	r14
+
+bad_get_user:
+	ldi	r1, #0		    ||	ldi	r0, #-14
+	jmp	r14
+
+#else /* not CONFIG_ISA_DUAL_ISSUE */
+
+	.text
+	.balign 4
+	.globl __get_user_1
+__get_user_1:
+1:	ldub	r1, @r0
+	ldi	r0, #0
+	jmp	r14
+
+	.balign 4
+	.globl __get_user_2
+__get_user_2:
+2:	lduh	r1, @r0
+	ldi	r0, #0
+	jmp	r14
+
+	.balign 4
+	.globl __get_user_4
+__get_user_4:
+3:	ld	r1, @r0
+	ldi	r0, #0
+	jmp	r14
+
+bad_get_user:
+	ldi	r1, #0
+	ldi	r0, #-14
+	jmp	r14
+
+#endif /* not CONFIG_ISA_DUAL_ISSUE */
+
+.section __ex_table,"a"
+	.long 1b,bad_get_user
+	.long 2b,bad_get_user
+	.long 3b,bad_get_user
+.previous
+
+	.end
diff -ruN linux-2.6.7.org/arch/m32r/lib/memcpy.S linux-2.6.7/arch/m32r/lib/memcpy.S
--- linux-2.6.7.org/arch/m32r/lib/memcpy.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/lib/memcpy.S	2004-03-16 19:34:58.000000000 +0900
@@ -0,0 +1,95 @@
+/*
+ *  linux/arch/m32r/lib/memcpy.S
+ *
+ *  Copyright (C) 2001  Hiroyuki Kondo, and Hirokazu Takata
+ *  Copyright (C) 2004  Hirokazu Takata
+ *
+ *  void *memcopy(void *dst, const void *src, int n);
+ *
+ *        dst: r0
+ *        src: r1
+ *        n  : r2
+ */
+/* $Id$ */
+
+
+	.text
+#include <linux/config.h>
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+
+#ifdef CONFIG_ISA_DUAL_ISSUE
+
+	.text
+ENTRY(memcpy)
+memcopy:
+	mv	r4, r0		    ||	mv	r7, r0
+	or	r7, r1		    ||	cmpz	r2
+	jc	r14		    ||	cmpeq	r0, r1	; return if r2=0
+	jc	r14					; return if r0=r1
+
+	and3	r7, r7, #3
+	bnez	r7, byte_copy
+	srl3	r3, r2, #2
+	and3	r2, r2, #3
+	beqz	r3, byte_copy
+	addi	r4, #-4
+word_copy:
+	ld	r7, @r1+	    ||	addi	r3, #-1
+	st	r7, @+r4	    ||	cmpz	r2
+	bnez	r3, word_copy
+	addi	r4, #4		    ||	jc	r14	; return if r2=0
+#if defined(CONFIG_ISA_M32R2)
+byte_copy:
+	ldb	r7, @r1		    ||	addi	r1, #1
+	addi	r2, #-1		    ||	stb	r7, @r4+
+	bnez	r2, byte_copy
+#elif defined(CONFIG_ISA_M32R)
+byte_copy:
+	ldb	r7, @r1		    ||	addi	r1, #1
+	addi	r2, #-1		    ||	stb	r7, @r4
+	addi	r4, #1
+	bnez	r2, byte_copy
+#else
+#error unknown isa configuration
+#endif
+end_memcopy:
+	jmp	r14
+
+#else /* not CONFIG_ISA_DUAL_ISSUE */
+
+	.text
+ENTRY(memcpy)
+memcopy:
+	mv	r4, r0
+	mv	r7, r0
+	or	r7, r1
+	beq	r0, r1, end_memcopy
+	beqz	r2, end_memcopy
+
+	and3	r7, r7, #3
+	bnez	r7, byte_copy
+	srl3	r3, r2, #2
+	and3	r2, r2, #3
+	beqz	r3, byte_copy
+	addi	r4, #-4
+word_copy:
+	ld	r7, @r1+
+	addi	r3, #-1
+	st	r7, @+r4
+	bnez	r3, word_copy
+	beqz	r2, end_memcopy
+	addi	r4, #4
+byte_copy:
+	ldb	r7, @r1
+	addi	r1, #1
+	addi	r2, #-1
+	stb	r7, @r4
+	addi	r4, #1
+	bnez	r2, byte_copy
+end_memcopy:
+	jmp	r14
+
+#endif /* not CONFIG_ISA_DUAL_ISSUE */
+
+	.end
diff -ruN linux-2.6.7.org/arch/m32r/lib/memset.S linux-2.6.7/arch/m32r/lib/memset.S
--- linux-2.6.7.org/arch/m32r/lib/memset.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/lib/memset.S	2004-07-27 22:00:09.000000000 +0900
@@ -0,0 +1,178 @@
+/*
+ *  linux/arch/m32r/lib/memset.S
+ *
+ *  Copyright (C) 2001,2002  Hiroyuki Kondo, and Hirokazu Takata
+ *  Copyright (C) 2004  Hirokazu Takata
+ *
+ *  void *memset(void *dst, int val, int len);
+ *
+ *        dst: r0
+ *        val: r1
+ *        len: r2
+ *        ret: r0
+ *
+ */
+/* $Id$ */
+
+#include <linux/config.h>
+
+	.text
+	.global	memset
+
+#ifdef CONFIG_ISA_DUAL_ISSUE
+
+	.align 4
+memset:
+	mv      r4, r0		    ||	cmpz	r2
+	jc	r14
+	cmpui	r2, #16
+	bnc	qword_align_check
+	cmpui	r2, #4
+	bc	byte_set
+word_align_check:			/* len >= 4 */
+	and3	r3, r4, #3
+	beqz	r3, word_set
+	addi	r3, #-4
+	neg	r3, r3			/* r3 = -(r3 - 4) */
+align_word:
+	stb	r1, @r4		    ||	addi	r4, #1
+	addi	r2, #-1		    ||	addi	r3, #-1
+	bnez	r3, align_word
+	cmpui	r2, #4
+	bc	byte_set
+word_set:
+	and3	r1, r1, #0x00ff		/* r1: abababab <-- ??????ab */
+	sll3	r3, r1, #8
+	or	r1, r3		    ||	addi	r4, #-4
+	sll3	r3, r1, #16
+	or	r1, r3		    ||	addi	r2, #-4
+word_set_loop:
+	st	r1, @+r4	    ||	addi	r2, #-4
+	bgtz	r2, word_set_loop
+	bnez	r2, byte_set_wrap
+	st	r1, @+r4
+	jmp	r14
+
+qword_align_check:			/* len >= 16 */
+	and3	r3, r4, #15
+	bnez	r3, word_align_check
+qword_set:
+	and3	r1, r1, #0x00ff		/* r1: abababab <-- ??????ab */
+	sll3	r3, r1, #8
+	or	r1, r3		    ||	addi	r4, #-4
+	sll3	r3, r1, #16
+	or	r1, r3		    ||	ldi	r5, #16
+qword_set_loop:
+	ld	r3, @(4,r4)		/* cache line allocate */
+	st	r1, @+r4	    ||	addi	r2, #-16
+	st	r1, @+r4	    ||	cmpu	r2, r5
+	st	r1, @+r4
+	st	r1, @+r4
+	bnc	qword_set_loop	    ||  cmpz	r2
+	jc	r14
+word_set_wrap:
+	cmpui	r2, #4
+	bc	byte_set
+	addi	r2, #-4
+	bra	word_set_loop
+
+byte_set_wrap:
+	addi	r2, #4
+	addi	r4, #4		    ||  cmpz	r2	
+	jc	r14
+#if defined(CONFIG_ISA_M32R2)
+byte_set:
+	addi	r2, #-1		    ||	stb	r1, @r4+
+	bnez	r2, byte_set
+#elif defined(CONFIG_ISA_M32R)
+byte_set:
+	addi	r2, #-1		    ||	stb	r1, @r4
+	addi	r4, #1
+	bnez	r2, byte_set
+#else
+#error unknown isa configuration
+#endif
+end_memset:
+	jmp	r14
+
+#else /* not CONFIG_ISA_DUAL_ISSUE */
+
+	.align 4
+memset:
+	mv      r4, r0
+	beqz	r2, end_memset
+	cmpui	r2, #16
+	bnc	qword_align_check
+	cmpui	r2, #4
+	bc	byte_set
+word_align_check:			/* len >= 4 */
+	and3	r3, r4, #3
+	beqz	r3, word_set
+	addi	r3, #-4
+	neg	r3, r3			/* r3 = -(r3 - 4) */
+align_word:
+	stb	r1, @r4
+	addi	r4, #1
+	addi	r2, #-1
+	addi	r3, #-1
+	bnez	r3, align_word
+	cmpui	r2, #4
+	bc	byte_set
+word_set:
+	and3	r1, r1, #0x00ff		/* r1: abababab <-- ??????ab */
+	sll3	r3, r1, #8
+	or	r1, r3
+	sll3	r3, r1, #16
+	or	r1, r3
+	addi	r2, #-4
+	addi	r4, #-4
+word_set_loop:
+	st	r1, @+r4
+	addi	r2, #-4
+	bgtz    r2, word_set_loop
+	bnez	r2, byte_set_wrap
+	st	r1, @+r4
+	jmp	r14
+
+qword_align_check:			/* len >= 16 */
+	and3	r3, r4, #15
+	bnez	r3, word_align_check
+qword_set:
+	and3	r1, r1, #0x00ff		/* r1: abababab <-- ??????ab */
+	sll3	r3, r1, #8
+	or	r1, r3
+	sll3	r3, r1, #16
+	or	r1, r3
+	addi	r4, #-4
+qword_set_loop:
+	ld	r3, @(4,r4)		/* cache line allocate */
+	addi	r2, #-16
+	st	r1, @+r4
+	st	r1, @+r4
+	cmpui	r2, #16
+	st	r1, @+r4
+	st	r1, @+r4
+	bnc	qword_set_loop
+	bnez	r2, word_set_wrap
+	jmp	r14
+word_set_wrap:
+	cmpui	r2, #4
+	bc	byte_set
+	addi	r2, #-4
+	bra	word_set_loop
+
+byte_set_wrap:
+	addi	r2, #4
+	addi	r4, #4
+	beqz	r2, end_memset
+byte_set:
+	addi	r2, #-1
+	stb	r1, @r4
+	addi	r4, #1
+	bnez	r2, byte_set
+end_memset:
+	jmp	r14
+
+#endif /* not CONFIG_ISA_DUAL_ISSUE */
+
+	.end
diff -ruN linux-2.6.7.org/arch/m32r/lib/putuser.S linux-2.6.7/arch/m32r/lib/putuser.S
--- linux-2.6.7.org/arch/m32r/lib/putuser.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/lib/putuser.S	2003-09-09 10:15:02.000000000 +0900
@@ -0,0 +1,84 @@
+/*
+ * __put_user functions.
+ *
+ * (C) Copyright 1998 Linus Torvalds
+ * (C) Copyright 2001 Hirokazu Takata
+ *
+ * These functions have a non-standard call interface
+ * to make them more efficient.
+ */
+
+#include <linux/config.h>
+
+/*
+ * __put_user_X
+ *
+ * Inputs:	r0 contains the address
+ *		r1 contains the value
+ *
+ * Outputs:	r0 is error code (0 or -EFAULT)
+ *		r1 is corrupted (will contain "current_task").
+ *
+ * These functions should not modify any other registers,
+ * as they get called from within inline assembly.
+ */
+
+#ifdef CONFIG_ISA_DUAL_ISSUE
+
+	.text
+	.balign 4
+	.globl __put_user_1
+__put_user_1:
+1:	stb	r1, @r0		    ||	ldi	r0, #0
+	jmp	r14
+
+	.balign 4
+	.globl __put_user_2
+__put_user_2:
+2:	sth	r1, @r0		    ||	ldi	r0, #0
+	jmp	r14
+
+	.balign 4
+	.globl __put_user_4
+__put_user_4:
+3:	st	r1, @r0		    ||	ldi	r0, #0
+	jmp	r14
+
+bad_put_user:
+	ldi	r0, #-14	    ||	jmp	r14
+
+#else /* not CONFIG_ISA_DUAL_ISSUE */
+
+	.text
+	.balign 4
+	.globl __put_user_1
+__put_user_1:
+1:	stb	r1, @r0
+	ldi	r0, #0
+	jmp	r14
+
+	.balign 4
+	.globl __put_user_2
+__put_user_2:
+2:	sth	r1, @r0
+	ldi	r0, #0
+	jmp	r14
+
+	.balign 4
+	.globl __put_user_4
+__put_user_4:
+3:	st	r1, @r0
+	ldi	r0, #0
+	jmp	r14
+
+bad_put_user:
+	ldi	r0, #-14
+	jmp	r14
+
+#endif /* not CONFIG_ISA_DUAL_ISSUE */
+
+.section __ex_table,"a"
+	.long 1b,bad_put_user
+	.long 2b,bad_put_user
+	.long 3b,bad_put_user
+.previous
diff -ruN linux-2.6.7.org/arch/m32r/lib/strlen.S linux-2.6.7/arch/m32r/lib/strlen.S
--- linux-2.6.7.org/arch/m32r/lib/strlen.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/lib/strlen.S	2003-09-09 10:15:02.000000000 +0900
@@ -0,0 +1,120 @@
+/*
+ *  linux/arch/m32r/strlen.S --  strlen code.
+ *
+ *  Copyright (C) 2001  Hirokazu Takata
+ *
+ *  size_t strlen(const char *s);
+ *
+ */
+/* $Id$ */
+
+
+#include <linux/config.h>
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+
+#ifdef CONFIG_ISA_DUAL_ISSUE
+
+	.text
+ENTRY(strlen)
+	mv	r6, r0		    ||	ldi	r2, #0
+	and3	r0, r0, #3
+	bnez	r0, strlen_byte
+;
+strlen_word:
+	ld	r0, @r6+
+;
+	seth	r5, #high(0x01010101)
+	or3	r5, r5, #low(0x01010101)
+	sll3	r7, r5, #7
+strlen_word_loop:
+	ld	r1, @r6+	    ||	not	r4, r0
+	sub	r0, r5		    ||	and	r4, r7
+	and	r4, r0
+	bnez	r4, strlen_last_bytes
+	ld	r0, @r6+	    ||	not	r4, r1
+	sub	r1, r5		    ||	and	r4, r7
+	and	r4, r1		    ||	addi	r2, #4
+	bnez	r4, strlen_last_bytes
+	addi	r2, #4		    ||	bra.s	strlen_word_loop
+
+	; NOTE: If a null char. exists, return 0.
+	; if ((x - 0x01010101) & ~x & 0x80808080)
+	;     return 0;
+;
+strlen_byte:
+	ldb	r1, @r6		    ||	addi	r6, #1
+	beqz	r1, strlen_exit
+	addi	r2, #1		    ||	bra.s	strlen_byte
+;
+strlen_last_bytes:
+	ldi	r0, #4		    ||	addi	r6, #-8
+;
+strlen_byte_loop:
+	ldb	r1, @r6		    ||	addi	r6, #1
+	addi	r0, #-1		    ||  cmpz	r1
+	bc.s	strlen_exit	    ||  cmpz	r0
+	addi	r2, #1		    ||	bnc.s	strlen_byte_loop
+;
+strlen_exit:
+	mv	r0, r2		    ||	jmp	r14
+
+#else /* not CONFIG_ISA_DUAL_ISSUE */
+
+	.text
+ENTRY(strlen)
+	mv	r6, r0
+	ldi	r2, #0
+	and3	r0, r0, #3
+	bnez	r0, strlen_byte
+;
+strlen_word:
+	ld	r0, @r6+
+;
+	seth	r5, #high(0x01010101)
+	or3	r5, r5, #low(0x01010101)
+	sll3	r7, r5, #7
+strlen_word_loop:
+	ld	r1, @r6+
+	not	r4, r0		; NOTE: If a null char. exists, return 0.
+	sub	r0, r5		; if ((x - 0x01010101) & ~x & 0x80808080)
+	and	r4, r7		;     return 0;
+	and	r4, r0
+	bnez	r4, strlen_last_bytes
+	addi	r2, #4
+;
+	ld	r0, @r6+
+	not	r4, r1		; NOTE: If a null char. exists, return 0.
+	sub	r1, r5		; if ((x - 0x01010101) & ~x & 0x80808080)
+	and	r4, r7		;     return 0;
+	and	r4, r1
+	bnez	r4, strlen_last_bytes
+	addi	r2, #4
+	bra	strlen_word_loop
+;
+strlen_byte:
+	ldb	r1, @r6
+	addi	r6, #1
+	beqz	r1, strlen_exit
+	addi	r2, #1
+	bra	strlen_byte
+;
+strlen_last_bytes:
+	ldi	r0, #4
+	addi	r6, #-8
+;
+strlen_byte_loop:
+	ldb	r1, @r6
+	addi	r6, #1
+	addi	r0, #-1
+	beqz	r1, strlen_exit
+	addi	r2, #1
+	bnez	r0, strlen_byte_loop
+;
+strlen_exit:
+	mv	r0, r2
+	jmp	r14
+
+#endif /* not CONFIG_ISA_DUAL_ISSUE */
+
+	.end
diff -ruN linux-2.6.7.org/arch/m32r/lib/usercopy.c linux-2.6.7/arch/m32r/lib/usercopy.c
--- linux-2.6.7.org/arch/m32r/lib/usercopy.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/lib/usercopy.c	2004-05-25 16:39:20.000000000 +0900
@@ -0,0 +1,391 @@
+/* 
+ * User address space access functions.
+ * The non inlined parts of asm-m32r/uaccess.h are here.
+ *
+ * Copyright 1997 Andi Kleen <ak@muc.de>
+ * Copyright 1997 Linus Torvalds
+ * Copyright 2001, 2002, 2004 Hirokazu Takata
+ */
+#include <linux/config.h>
+#include <linux/prefetch.h>
+#include <linux/string.h>
+#include <linux/thread_info.h>
+#include <asm/uaccess.h>
+
+unsigned long
+__generic_copy_to_user(void *to, const void *from, unsigned long n)
+{
+	prefetch(from);
+	if (access_ok(VERIFY_WRITE, to, n))
+		__copy_user(to,from,n);
+	return n;
+}
+
+unsigned long
+__generic_copy_from_user(void *to, const void *from, unsigned long n)
+{
+	prefetchw(to);
+	if (access_ok(VERIFY_READ, from, n))
+		__copy_user_zeroing(to,from,n);
+	else
+		memset(to, 0, n);
+	return n;
+}
+
+
+/*
+ * Copy a null terminated string from userspace.
+ */
+
+#ifdef CONFIG_ISA_DUAL_ISSUE
+
+#define __do_strncpy_from_user(dst,src,count,res)			\
+do {									\
+	int __d0, __d1, __d2;						\
+	__asm__ __volatile__(						\
+		"	beqz	%1, 2f\n"				\
+		"	.fillinsn\n"					\
+		"0:	ldb	r14, @%3    ||	addi	%3, #1\n"	\
+		"	stb	r14, @%4    ||	addi	%4, #1\n"	\
+		"	beqz	r14, 1f\n"				\
+		"	addi	%1, #-1\n"				\
+		"	bnez	%1, 0b\n"				\
+		"	.fillinsn\n"					\
+		"1:	sub	%0, %1\n"				\
+		"	.fillinsn\n"					\
+		"2:\n"							\
+		".section .fixup,\"ax\"\n"				\
+		"	.balign 4\n"					\
+		"3:	seth	r14, #high(2b)\n"			\
+		"	or3	r14, r14, #low(2b)\n"			\
+		"	jmp	r14	    ||	ldi	%0, #%5\n"	\
+		".previous\n"						\
+		".section __ex_table,\"a\"\n"				\
+		"	.balign 4\n"					\
+		"	.long 0b,3b\n"					\
+		".previous"						\
+		: "=r"(res), "=r"(count), "=&r" (__d0), "=&r" (__d1),	\
+		  "=&r" (__d2)						\
+		: "i"(-EFAULT), "0"(count), "1"(count), "3"(src), 	\
+		  "4"(dst)						\
+		: "r14", "cbit", "memory");				\
+} while (0)
+
+#else /* not CONFIG_ISA_DUAL_ISSUE */
+
+#define __do_strncpy_from_user(dst,src,count,res)			\
+do {									\
+	int __d0, __d1, __d2;						\
+	__asm__ __volatile__(						\
+		"	beqz	%1, 2f\n"				\
+		"	.fillinsn\n"					\
+		"0:	ldb	r14, @%3\n"				\
+		"	stb	r14, @%4\n"				\
+		"	addi	%3, #1\n"				\
+		"	addi	%4, #1\n"				\
+		"	beqz	r14, 1f\n"				\
+		"	addi	%1, #-1\n"				\
+		"	bnez	%1, 0b\n"				\
+		"	.fillinsn\n"					\
+		"1:	sub	%0, %1\n"				\
+		"	.fillinsn\n"					\
+		"2:\n"							\
+		".section .fixup,\"ax\"\n"				\
+		"	.balign 4\n"					\
+		"3:	ldi	%0, #%5\n"				\
+		"	seth	r14, #high(2b)\n"			\
+		"	or3	r14, r14, #low(2b)\n"			\
+		"	jmp	r14\n"					\
+		".previous\n"						\
+		".section __ex_table,\"a\"\n"				\
+		"	.balign 4\n"					\
+		"	.long 0b,3b\n"					\
+		".previous"						\
+		: "=r"(res), "=r"(count), "=&r" (__d0), "=&r" (__d1),	\
+		  "=&r" (__d2)						\
+		: "i"(-EFAULT), "0"(count), "1"(count), "3"(src),	\
+		  "4"(dst)						\
+		: "r14", "cbit", "memory");				\
+} while (0)
+
+#endif /* CONFIG_ISA_DUAL_ISSUE */
+
+long
+__strncpy_from_user(char *dst, const char *src, long count)
+{
+	long res;
+	__do_strncpy_from_user(dst, src, count, res);
+	return res;
+}
+
+long
+strncpy_from_user(char *dst, const char *src, long count)
+{
+	long res = -EFAULT;
+	if (access_ok(VERIFY_READ, src, 1))
+		__do_strncpy_from_user(dst, src, count, res);
+	return res;
+}
+
+
+/*
+ * Zero Userspace
+ */
+
+#ifdef CONFIG_ISA_DUAL_ISSUE
+
+#define __do_clear_user(addr,size)					\
+do {									\
+	int __dst, __c;							\
+  	__asm__ __volatile__(						\
+		"	beqz	%1, 9f\n"				\
+		"	and3	r14, %0, #3\n"				\
+		"	bnez	r14, 2f\n"				\
+		"	and3	r14, %1, #3\n"				\
+		"	bnez	r14, 2f\n"				\
+		"	and3	%1, %1, #3\n"				\
+		"	beqz	%2, 2f\n"				\
+		"	addi	%0, #-4\n"				\
+		"	.fillinsn\n"					\
+		"0:	; word clear \n"				\
+		"	st	%6, @+%0    ||	addi	%2, #-1\n"	\
+		"	bnez	%2, 0b\n"				\
+		"	beqz	%1, 9f\n"				\
+		"	.fillinsn\n"					\
+		"2:	; byte clear \n"				\
+		"	stb	%6, @%0	    ||	addi	%1, #-1\n"	\
+		"	addi	%0, #1\n"				\
+		"	bnez	%1, 2b\n"				\
+		"	.fillinsn\n"					\
+		"9:\n"							\
+		".section .fixup,\"ax\"\n"				\
+		"	.balign 4\n"					\
+		"4:	slli	%2, #2\n"				\
+		"	seth	r14, #high(9b)\n"			\
+		"	or3	r14, r14, #low(9b)\n"			\
+		"	jmp	r14	    ||	add	%1, %2\n"	\
+		".previous\n"						\
+		".section __ex_table,\"a\"\n"				\
+		"	.balign 4\n"					\
+		"	.long 0b,4b\n"					\
+		"	.long 2b,9b\n"					\
+		".previous\n"						\
+		: "=&r"(__dst), "=&r"(size), "=&r"(__c)			\
+		: "0"(addr), "1"(size), "2"(size / 4), "r"(0)		\
+		: "r14", "cbit", "memory");				\
+} while (0)
+
+#else /* not CONFIG_ISA_DUAL_ISSUE */
+
+#define __do_clear_user(addr,size)					\
+do {									\
+	int __dst, __c;							\
+  	__asm__ __volatile__(						\
+		"	beqz	%1, 9f\n"				\
+		"	and3	r14, %0, #3\n"				\
+		"	bnez	r14, 2f\n"				\
+		"	and3	r14, %1, #3\n"				\
+		"	bnez	r14, 2f\n"				\
+		"	and3	%1, %1, #3\n"				\
+		"	beqz	%2, 2f\n"				\
+		"	addi	%0, #-4\n"				\
+		"	.fillinsn\n"					\
+		"0:	st	%6, @+%0	; word clear \n"	\
+		"	addi	%2, #-1\n"				\
+		"	bnez	%2, 0b\n"				\
+		"	beqz	%1, 9f\n"				\
+		"	.fillinsn\n"					\
+		"2:	stb	%6, @%0		; byte clear \n"	\
+		"	addi	%1, #-1\n"				\
+		"	addi	%0, #1\n"				\
+		"	bnez	%1, 2b\n"				\
+		"	.fillinsn\n"					\
+		"9:\n"							\
+		".section .fixup,\"ax\"\n"				\
+		"	.balign 4\n"					\
+		"4:	slli	%2, #2\n"				\
+		"	add	%1, %2\n"				\
+		"	seth	r14, #high(9b)\n"			\
+		"	or3	r14, r14, #low(9b)\n"			\
+		"	jmp	r14\n"					\
+		".previous\n"						\
+		".section __ex_table,\"a\"\n"				\
+		"	.balign 4\n"					\
+		"	.long 0b,4b\n"					\
+		"	.long 2b,9b\n"					\
+		".previous\n"						\
+		: "=&r"(__dst), "=&r"(size), "=&r"(__c)			\
+		: "0"(addr), "1"(size), "2"(size / 4), "r"(0)		\
+		: "r14", "cbit", "memory");				\
+} while (0)
+
+#endif /* not CONFIG_ISA_DUAL_ISSUE */
+
+unsigned long
+clear_user(void *to, unsigned long n)
+{
+	if (access_ok(VERIFY_WRITE, to, n))
+		__do_clear_user(to, n);
+	return n;
+}
+
+unsigned long
+__clear_user(void *to, unsigned long n)
+{
+	__do_clear_user(to, n);
+	return n;
+}
+
+/*
+ * Return the size of a string (including the ending 0)
+ *
+ * Return 0 on exception, a value greater than N if too long
+ */
+
+#ifdef CONFIG_ISA_DUAL_ISSUE
+
+long strnlen_user(const char *s, long n)
+{
+	unsigned long mask = -__addr_ok(s);
+	unsigned long res;
+
+	__asm__ __volatile__(
+		"	and	%0, %5	    ||	mv	r1, %1\n"
+		"	beqz	%0, strnlen_exit\n"
+		"	and3	r0, %1, #3\n"
+		"	bnez	r0, strnlen_byte_loop\n"
+		"	cmpui	%0, #4\n"
+		"	bc	strnlen_byte_loop\n"
+		"strnlen_word_loop:\n"
+		"0:	ld	r0, @%1+\n"
+		"	pcmpbz	r0\n"
+		"	bc	strnlen_last_bytes_fixup\n"
+		"	addi	%0, #-4\n"
+		"	beqz	%0, strnlen_exit\n"
+		"	bgtz	%0, strnlen_word_loop\n"
+		"strnlen_last_bytes:\n"
+		"	mv	%0, %4\n"
+		"strnlen_last_bytes_fixup:\n"
+		"	addi	%1, #-4\n"
+		"strnlen_byte_loop:\n"
+		"1:	ldb	r0, @%1	    ||	addi	%0, #-1\n"
+		"	beqz	r0, strnlen_exit\n"
+		"	addi	%1, #1\n"
+		"	bnez	%0, strnlen_byte_loop\n"
+		"strnlen_exit:\n"
+		"	sub	%1, r1\n"
+		"	add3	%0, %1, #1\n"
+		"	.fillinsn\n"
+		"9:\n"
+		".section .fixup,\"ax\"\n"
+		"	.balign 4\n"
+		"4:	addi	%1, #-4\n"
+		"	.fillinsn\n"
+		"5:	seth	r1, #high(9b)\n"
+		"	or3	r1, r1, #low(9b)\n"
+		"	jmp	r1	    ||	ldi	%0, #0\n"
+		".previous\n"
+		".section __ex_table,\"a\"\n"
+		"	.balign 4\n"
+		"	.long 0b,4b\n"
+		"	.long 1b,5b\n"
+		".previous"
+		: "=&r" (res), "=r" (s)
+		: "0" (n), "1" (s), "r" (n & 3), "r" (mask), "r"(0x01010101)
+		: "r0", "r1", "cbit");
+
+	/* NOTE: strnlen_user() algorism:
+	 * { 
+	 *   char *p;
+	 *   for (p = s; n-- && *p != '\0'; ++p)
+	 *     ;
+	 *   return p - s + 1;
+	 * }
+	 */
+
+	/* NOTE: If a null char. exists, return 0.
+	 * if ((x - 0x01010101) & ~x & 0x80808080)\n"
+	 *   return 0;\n"
+	 */
+
+	return res & mask;
+}
+
+#else /* not CONFIG_ISA_DUAL_ISSUE */
+
+long strnlen_user(const char *s, long n)
+{
+	unsigned long mask = -__addr_ok(s);
+	unsigned long res;
+
+	__asm__ __volatile__(
+		"	and	%0, %5\n"
+		"	mv	r1, %1\n"
+		"	beqz	%0, strnlen_exit\n"
+		"	and3	r0, %1, #3\n"
+		"	bnez	r0, strnlen_byte_loop\n"
+		"	cmpui	%0, #4\n"
+		"	bc	strnlen_byte_loop\n"
+		"	sll3	r3, %6, #7\n"
+		"strnlen_word_loop:\n"
+		"0:	ld	r0, @%1+\n"
+		"	not	r2, r0\n"
+		"	sub	r0, %6\n"
+		"	and	r2, r3\n"
+		"	and	r2, r0\n"
+		"	bnez	r2, strnlen_last_bytes_fixup\n"
+		"	addi	%0, #-4\n"
+		"	beqz	%0, strnlen_exit\n"
+		"	bgtz	%0, strnlen_word_loop\n"
+		"strnlen_last_bytes:\n"
+		"	mv	%0, %4\n"
+		"strnlen_last_bytes_fixup:\n"
+		"	addi	%1, #-4\n"
+		"strnlen_byte_loop:\n"
+		"1:	ldb	r0, @%1\n"
+		"	addi	%0, #-1\n"
+		"	beqz	r0, strnlen_exit\n"
+		"	addi	%1, #1\n"
+		"	bnez	%0, strnlen_byte_loop\n"
+		"strnlen_exit:\n"
+		"	sub	%1, r1\n"
+		"	add3	%0, %1, #1\n"
+		"	.fillinsn\n"
+		"9:\n"
+		".section .fixup,\"ax\"\n"
+		"	.balign 4\n"
+		"4:	addi	%1, #-4\n"
+		"	.fillinsn\n"
+		"5:	ldi	%0, #0\n"
+		"	seth	r1, #high(9b)\n"
+		"	or3	r1, r1, #low(9b)\n"
+		"	jmp	r1\n"
+		".previous\n"
+		".section __ex_table,\"a\"\n"
+		"	.balign 4\n"
+		"	.long 0b,4b\n"
+		"	.long 1b,5b\n"
+		".previous"
+		: "=&r" (res), "=r" (s)
+		: "0" (n), "1" (s), "r" (n & 3), "r" (mask), "r"(0x01010101)
+		: "r0", "r1", "r2", "r3", "cbit");
+
+	/* NOTE: strnlen_user() algorism:
+	 * { 
+	 *   char *p;
+	 *   for (p = s; n-- && *p != '\0'; ++p)
+	 *     ;
+	 *   return p - s + 1;
+	 * }
+	 */
+
+	/* NOTE: If a null char. exists, return 0.
+	 * if ((x - 0x01010101) & ~x & 0x80808080)\n"
+	 *   return 0;\n"
+	 */
+
+	return res & mask;
+}
+
+#endif /* CONFIG_ISA_DUAL_ISSUE */
+
diff -ruN linux-2.6.7.org/arch/m32r/m32700ut/defconfig.m32700ut.smp linux-2.6.7/arch/m32r/m32700ut/defconfig.m32700ut.smp
--- linux-2.6.7.org/arch/m32r/m32700ut/defconfig.m32700ut.smp	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/m32700ut/defconfig.m32700ut.smp	2004-07-15 13:43:14.000000000 +0900
@@ -0,0 +1,649 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_M32R=y
+CONFIG_UID16=y
+CONFIG_GENERIC_ISA_DMA=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_STANDALONE=y
+
+#
+# General setup
+#
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=15
+CONFIG_HOTPLUG=y
+CONFIG_IKCONFIG=y
+# CONFIG_IKCONFIG_PROC is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+# CONFIG_FUTEX is not set
+# CONFIG_EPOLL is not set
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+CONFIG_KMOD=y
+CONFIG_STOP_MACHINE=y
+
+#
+# Processor type and features
+#
+# CONFIG_PLAT_MAPPI is not set
+# CONFIG_PLAT_USRV is not set
+CONFIG_PLAT_M32700UT=y
+# CONFIG_PLAT_OAKS32R is not set
+# CONFIG_PLAT_MAPPI2 is not set
+CONFIG_CHIP_M32700=y
+# CONFIG_CHIP_M32102 is not set
+# CONFIG_CHIP_VDEC2 is not set
+# CONFIG_CHIP_OPSP is not set
+CONFIG_MMU=y
+CONFIG_TLB_ENTRIES=32
+CONFIG_ISA_M32R2=y
+CONFIG_ISA_DSP_LEVEL2=y
+CONFIG_ISA_DUAL_ISSUE=y
+CONFIG_BUS_CLOCK=50000000
+CONFIG_TIMER_DIVIDE=128
+# CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_MEMORY_START=0x08000000
+CONFIG_MEMORY_SIZE=0x01000000
+CONFIG_NOHIGHMEM=y
+# CONFIG_DISCONTIGMEM is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+CONFIG_PREEMPT=y
+# CONFIG_HAVE_DEC_LOCK is not set
+CONFIG_SMP=y
+CONFIG_CHIP_M32700_TS1=y
+CONFIG_NR_CPUS=2
+# CONFIG_NUMA is not set
+
+#
+# M32R drivers
+#
+# CONFIG_M32RPCC is not set
+CONFIG_M32R_CFC=y
+CONFIG_M32700UT_CFC=y
+CONFIG_CFC_NUM=1
+CONFIG_M32R_SMC91111=y
+CONFIG_M32700UT_DS1302=y
+
+#
+# Power management options (ACPI, APM)
+#
+# CONFIG_PM is not set
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+# CONFIG_PCI is not set
+# CONFIG_ISA is not set
+
+#
+# PCMCIA/CardBus support
+#
+CONFIG_PCMCIA=y
+# CONFIG_PCMCIA_DEBUG is not set
+# CONFIG_TCIC is not set
+
+#
+# PCI Hotplug Support
+#
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_FW_LOADER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_NBD=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_BLK_DEV_INITRD is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECS=y
+CONFIG_BLK_DEV_IDECD=m
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+# CONFIG_IDE_TASKFILE_IO is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+# CONFIG_IDE_ARM is not set
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI=m
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=m
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=m
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_EATA_PIO is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# PCMCIA SCSI adapter support
+#
+# CONFIG_PCMCIA_AHA152X is not set
+# CONFIG_PCMCIA_FDOMAIN is not set
+# CONFIG_PCMCIA_NINJA_SCSI is not set
+# CONFIG_PCMCIA_QLOGIC is not set
+# CONFIG_PCMCIA_SYM53C500 is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_NETDEVICES is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_CT82C710 is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_M32R_SIO is not set
+CONFIG_SERIAL_M32R_PLDSIO=y
+CONFIG_SERIAL_M32R_PLDSIO_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_QIC02_TAPE is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+
+#
+# PCMCIA character devices
+#
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+CONFIG_VIDEO_DEV=y
+
+#
+# Video For Linux
+#
+
+#
+# Video Adapters
+#
+# CONFIG_VIDEO_CPIA is not set
+
+#
+# Radio Adapters
+#
+# CONFIG_RADIO_MAXIRADIO is not set
+# CONFIG_RADIO_MAESTRO is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+CONFIG_FB_EPSON_S1D13806=y
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+# CONFIG_MDA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_PCI_CONSOLE=y
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+
+#
+# Logo configuration
+#
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_LOGO_M32R_CLUT224=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+CONFIG_EXT3_FS=m
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=m
+CONFIG_JBD_DEBUG=y
+CONFIG_FS_MBCACHE=y
+CONFIG_REISERFS_FS=m
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_REISERFS_FS_XATTR is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+CONFIG_UDF_FS=m
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=m
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=m
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
+# CONFIG_DEVFS_DEBUG is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_FRAME_POINTER is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
diff -ruN linux-2.6.7.org/arch/m32r/m32700ut/defconfig.m32700ut.up linux-2.6.7/arch/m32r/m32700ut/defconfig.m32700ut.up
--- linux-2.6.7.org/arch/m32r/m32700ut/defconfig.m32700ut.up	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/m32700ut/defconfig.m32700ut.up	2004-07-15 13:43:14.000000000 +0900
@@ -0,0 +1,647 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_M32R=y
+CONFIG_UID16=y
+CONFIG_GENERIC_ISA_DMA=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_STANDALONE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_HOTPLUG=y
+CONFIG_IKCONFIG=y
+# CONFIG_IKCONFIG_PROC is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+# CONFIG_FUTEX is not set
+# CONFIG_EPOLL is not set
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+CONFIG_KMOD=y
+
+#
+# Processor type and features
+#
+# CONFIG_PLAT_MAPPI is not set
+# CONFIG_PLAT_USRV is not set
+CONFIG_PLAT_M32700UT=y
+# CONFIG_PLAT_OAKS32R is not set
+# CONFIG_PLAT_MAPPI2 is not set
+CONFIG_CHIP_M32700=y
+# CONFIG_CHIP_M32102 is not set
+# CONFIG_CHIP_VDEC2 is not set
+# CONFIG_CHIP_OPSP is not set
+CONFIG_MMU=y
+CONFIG_TLB_ENTRIES=32
+CONFIG_ISA_M32R2=y
+CONFIG_ISA_DSP_LEVEL2=y
+CONFIG_ISA_DUAL_ISSUE=y
+CONFIG_BUS_CLOCK=50000000
+CONFIG_TIMER_DIVIDE=128
+# CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_MEMORY_START=0x08000000
+CONFIG_MEMORY_SIZE=0x01000000
+CONFIG_NOHIGHMEM=y
+# CONFIG_DISCONTIGMEM is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+CONFIG_PREEMPT=y
+# CONFIG_HAVE_DEC_LOCK is not set
+# CONFIG_SMP is not set
+
+#
+# M32R drivers
+#
+# CONFIG_M32RPCC is not set
+CONFIG_M32R_CFC=y
+CONFIG_M32700UT_CFC=y
+CONFIG_CFC_NUM=1
+CONFIG_M32R_SMC91111=y
+CONFIG_M32700UT_DS1302=y
+
+#
+# Power management options (ACPI, APM)
+#
+# CONFIG_PM is not set
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+# CONFIG_PCI is not set
+# CONFIG_ISA is not set
+
+#
+# PCMCIA/CardBus support
+#
+CONFIG_PCMCIA=y
+# CONFIG_PCMCIA_DEBUG is not set
+# CONFIG_TCIC is not set
+
+#
+# PCI Hotplug Support
+#
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_FW_LOADER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_NBD=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_BLK_DEV_INITRD is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=y
+CONFIG_BLK_DEV_IDE=y
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+CONFIG_BLK_DEV_IDEDISK=y
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECS=y
+CONFIG_BLK_DEV_IDECD=m
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_BLK_DEV_IDESCSI is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+# CONFIG_IDE_TASKFILE_IO is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=y
+# CONFIG_IDE_ARM is not set
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI=m
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=m
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=m
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_EATA_PIO is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# PCMCIA SCSI adapter support
+#
+# CONFIG_PCMCIA_AHA152X is not set
+# CONFIG_PCMCIA_FDOMAIN is not set
+# CONFIG_PCMCIA_NINJA_SCSI is not set
+# CONFIG_PCMCIA_QLOGIC is not set
+# CONFIG_PCMCIA_SYM53C500 is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_NETDEVICES is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_CT82C710 is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_M32R_SIO is not set
+CONFIG_SERIAL_M32R_PLDSIO=y
+CONFIG_SERIAL_M32R_PLDSIO_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_QIC02_TAPE is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+
+#
+# PCMCIA character devices
+#
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+CONFIG_VIDEO_DEV=y
+
+#
+# Video For Linux
+#
+
+#
+# Video Adapters
+#
+# CONFIG_VIDEO_CPIA is not set
+
+#
+# Radio Adapters
+#
+# CONFIG_RADIO_MAXIRADIO is not set
+# CONFIG_RADIO_MAESTRO is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+CONFIG_FB=y
+CONFIG_FB_EPSON_S1D13806=y
+# CONFIG_FB_VIRTUAL is not set
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+# CONFIG_MDA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+CONFIG_PCI_CONSOLE=y
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+
+#
+# Logo configuration
+#
+CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_LOGO_M32R_CLUT224=y
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+CONFIG_EXT3_FS=m
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=m
+CONFIG_JBD_DEBUG=y
+CONFIG_FS_MBCACHE=y
+CONFIG_REISERFS_FS=m
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_REISERFS_FS_XATTR is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+CONFIG_UDF_FS=m
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=m
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=m
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
+# CONFIG_DEVFS_DEBUG is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_FRAME_POINTER is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
diff -ruN linux-2.6.7.org/arch/m32r/m32700ut/dot.gdbinit_200MHz_16MB linux-2.6.7/arch/m32r/m32700ut/dot.gdbinit_200MHz_16MB
--- linux-2.6.7.org/arch/m32r/m32700ut/dot.gdbinit_200MHz_16MB	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/m32700ut/dot.gdbinit_200MHz_16MB	2004-08-17 11:58:11.000000000 +0900
@@ -0,0 +1,249 @@
+# .gdbinit file
+# $Id: dot.gdbinit_200MHz_16MB,v 1.1 2004/08/17 02:58:11 takata Exp $
+#-----
+# NOTE: this file is generated by a script, "gen_gdbinit.pl".
+# (Please type "gen_gdbinit.pl --help" and check the help message).
+# $ Id: gen_gdbinit.pl,v 1.12 2004/07/26 09:56:10 takata Exp $
+#-----
+# target platform: m32700ut
+
+# setting
+set width 0d70
+set radix 0d16
+
+debug_chaos
+
+# clk xin:cpu:bif:bus=25:200:50:50
+define clock_init
+  set *(unsigned long *)0x00ef4008 = 0x00000000
+  set *(unsigned long *)0x00ef4004 = 0
+  shell sleep 0.1
+  # NOTE: Please change the master clock source from PLL-clock to Xin-clock
+  # and switch off PLL, before resetting the clock gear ratio.
+
+  set *(unsigned long *)0x00ef4024 = 2
+  set *(unsigned long *)0x00ef4020 = 2
+  set *(unsigned long *)0x00ef4010 = 0
+  set *(unsigned long *)0x00ef4014 = 0
+  set *(unsigned long *)0x00ef4004 = 3
+  shell sleep 0.1
+  set *(unsigned long *)0x00ef4008 = 0x00000200
+end
+
+# Initialize SDRAM controller
+define sdram_init
+  # SDIR0
+  set *(unsigned long *)0x00ef6008 = 0x00000182
+  # SDIR1
+  set *(unsigned long *)0x00ef600c = 0x00000001
+  # Initialize wait
+  shell sleep 0.1
+  # Ch0-MOD
+  set *(unsigned long *)0x00ef602c = 0x00000020
+  # Ch0-TR
+  set *(unsigned long *)0x00ef6028 = 0x00041302
+  # Ch0-ADR (size:16MB)
+  set *(unsigned long *)0x00ef6020 = 0x08000002
+  # AutoRef On
+  set *(unsigned long *)0x00ef6004 = 0x00010517
+  # Access enable
+  set *(unsigned long *)0x00ef6024 = 0x00000001
+end
+document sdram_init
+  SDRAM controller initialization
+  0x08000000 - 0x08ffffff (16MB)
+end
+
+# Initialize BSEL3 for UT-CFC
+define cfc_init
+  set $sfrbase = 0xa0ef0000
+# too fast
+#  set *(unsigned long *)($sfrbase + 0x5300) = 0x0b0b8000
+#  set *(unsigned long *)($sfrbase + 0x5304) = 0x00102204
+#  set *(unsigned long *)($sfrbase + 0x5300) = 0x1f1f8000
+#  set *(unsigned long *)($sfrbase + 0x5300) = 0x1f1f1fdf
+#  set *(unsigned long *)($sfrbase + 0x5304) = 0x0013220f
+#  set *(unsigned long *)($sfrbase + 0x5304) = 0x0013330f
+end
+document cfc_init
+  CF controller initialization
+end
+
+# MMU enable
+define mmu_enable
+  set $evb=0x88000000
+  set *(unsigned long *)0xffff0024=1
+end
+
+# MMU disable
+define mmu_disable
+  set $evb=0
+  set *(unsigned long *)0xffff0024=0
+end
+
+# Show TLB entries
+define show_tlb_entries
+  set $i = 0
+  set $addr = $arg0
+  set $nr_entries = $arg1
+  use_mon_code
+  while ($i < $nr_entries)
+    set $tlb_tag = *(unsigned long*)$addr
+    set $tlb_data = *(unsigned long*)($addr + 4)
+    printf " [%2d] 0x%08lx : 0x%08lx - 0x%08lx\n", $i, $addr, $tlb_tag, $tlb_data
+    set $i = $i + 1
+    set $addr = $addr + 8
+  end
+  use_debug_dma
+end
+define itlb
+  set $itlb=0xfe000000
+  show_tlb_entries $itlb 0d32
+end
+define dtlb
+  set $dtlb=0xfe000800
+  show_tlb_entries $dtlb 0d32
+end
+
+# Initialize TLB entries
+define init_tlb_entries
+  set $i = 0
+  set $addr = $arg0
+  set $nr_entries = $arg1
+  use_mon_code
+  while ($i < $nr_entries)
+    set *(unsigned long *)($addr + 0x4) = 0
+    set $i = $i + 1
+    set $addr = $addr + 8
+  end
+  use_debug_dma
+end
+define tlb_init
+  set $itlb=0xfe000000
+  init_tlb_entries $itlb 0d32
+  set $dtlb=0xfe000800
+  init_tlb_entries $dtlb 0d32
+end
+
+# Show current task structure
+define show_current
+  set $current = $spi & 0xffffe000
+  printf "$current=0x%08lX\n",$current
+  print *(struct task_struct *)$current
+end
+
+# Show user assigned task structure
+define show_task
+  set  = $arg0 & 0xffffe000
+  printf "$task=0x%08lX\n",$task
+  print *(struct task_struct *)$task
+end
+document show_task
+  Show user assigned task structure
+  arg0 : task structure address
+end
+
+# Show M32R registers
+define show_regs
+  printf " R0[0x%08lX]   R1[0x%08lX]   R2[0x%08lX]   R3[0x%08lX]\n",$r0,$r1,$r2,$r3
+  printf " R4[0x%08lX]   R5[0x%08lX]   R6[0x%08lX]   R7[0x%08lX]\n",$r4,$r5,$r6,$r7
+  printf " R8[0x%08lX]   R9[0x%08lX]  R10[0x%08lX]  R11[0x%08lX]\n",$r8,$r9,$r10,$r11
+  printf "R12[0x%08lX]   FP[0x%08lX]   LR[0x%08lX]   SP[0x%08lX]\n",$r12,$fp,$lr,$sp
+  printf "PSW[0x%08lX]  CBR[0x%08lX]  SPI[0x%08lX]  SPU[0x%08lX]\n",$psw,$cbr,$spi,$spu
+  printf "BPC[0x%08lX]   PC[0x%08lX] ACCL[0x%08lX] ACCH[0x%08lX]\n",$bpc,$pc,$accl,$acch
+  printf "EVB[0x%08lX]\n",$evb
+end
+
+# Setup all
+define setup
+  use_mon_code
+  set *(unsigned int)0xfffffffc=0x60
+  shell sleep 0.1
+  clock_init
+  shell sleep 0.1
+  # SDRAM: 16MB
+  set *(unsigned long *)0x00ef6020 = 0x08000002
+  cfc_init
+  # USB
+  set *(unsigned short *)0xb0301000 = 0x100
+
+  set $evb=0x08000000
+end
+
+# Load modules
+define load_modules
+  use_debug_dma
+  load
+end
+
+# Set kernel parameters
+define set_kernel_parameters
+  set $param = (void*)0x08002000
+  # INITRD_START
+  set *(unsigned long *)($param + 0x0010) = 0x082a0000
+  # INITRD_SIZE
+  set *(unsigned long *)($param + 0x0014) = 0x00000000
+  # M32R_CPUCLK
+  set *(unsigned long *)($param + 0x0018) = 0d200000000
+  # M32R_BUSCLK
+  set *(unsigned long *)($param + 0x001c) = 0d50000000
+
+  # M32R_TIMER_DIVIDE
+  set *(unsigned long *)($param + 0x0020) = 0d128
+
+  set {char[0x200]}($param + 0x100) = "console=ttyD0,115200n8x console=tty1 video=s1d13xxxfb:mode:240x320-16 root=/dev/nfsroot nfsroot=192.168.0.1:/project/m32r-linux/export/rootfs,rsize=1024,wsize=1024 nfsaddrs=192.168.0.101:192.168.0.1:192.168.0.1:255.255.255.0:mappi001 mem=16M \0"
+end
+
+# Boot
+define boot
+  set_kernel_parameters
+  set $fp = 0
+  set $pc = 0x08001000
+  set *(unsigned char *)0xffffffff = 0x03
+  si
+  c
+end
+
+# Set breakpoints
+define set_breakpoints
+  b *0x08000030
+end
+
+# Restart
+define restart
+  sdireset
+  sdireset
+  set $pc = 0
+  b *0x04001000
+  b *0x08001000
+  b *0x08002000
+  si
+  c
+  tlb_init
+  del
+  setup
+  load_modules
+  boot
+end
+
+define si
+  stepi
+  x/i $pc
+  show_reg
+end
+
+sdireset
+sdireset
+file vmlinux
+target m32rsdi
+set $pc = 0
+b *0x04001000
+b *0x08001000
+b *0x08002000
+c
+tlb_init
+del
+setup
+load_modules
+boot
+
diff -ruN linux-2.6.7.org/arch/m32r/m32700ut/dot.gdbinit_300MHz_32MB linux-2.6.7/arch/m32r/m32700ut/dot.gdbinit_300MHz_32MB
--- linux-2.6.7.org/arch/m32r/m32700ut/dot.gdbinit_300MHz_32MB	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/m32700ut/dot.gdbinit_300MHz_32MB	2004-08-17 11:58:11.000000000 +0900
@@ -0,0 +1,249 @@
+# .gdbinit file
+# $Id: dot.gdbinit_300MHz_32MB,v 1.1 2004/08/17 02:58:11 takata Exp $
+#-----
+# NOTE: this file is generated by a script, "gen_gdbinit.pl".
+# (Please type "gen_gdbinit.pl --help" and check the help message).
+# $ Id: gen_gdbinit.pl,v 1.12 2004/07/26 09:56:10 takata Exp $
+#-----
+# target platform: m32700ut
+
+# setting
+set width 0d70
+set radix 0d16
+
+debug_chaos
+
+# clk xin:cpu:bif:bus=25:300:75:75
+define clock_init
+  set *(unsigned long *)0x00ef4008 = 0x00000000
+  set *(unsigned long *)0x00ef4004 = 0
+  shell sleep 0.1
+  # NOTE: Please change the master clock source from PLL-clock to Xin-clock
+  # and switch off PLL, before resetting the clock gear ratio.
+
+  set *(unsigned long *)0x00ef4024 = 2
+  set *(unsigned long *)0x00ef4020 = 2
+  set *(unsigned long *)0x00ef4010 = 0
+  set *(unsigned long *)0x00ef4014 = 0
+  set *(unsigned long *)0x00ef4004 = 5
+  shell sleep 0.1
+  set *(unsigned long *)0x00ef4008 = 0x00000200
+end
+
+# Initialize SDRAM controller
+define sdram_init
+  # SDIR0
+  set *(unsigned long *)0x00ef6008 = 0x00000182
+  # SDIR1
+  set *(unsigned long *)0x00ef600c = 0x00000001
+  # Initialize wait
+  shell sleep 0.1
+  # Ch0-MOD
+  set *(unsigned long *)0x00ef602c = 0x00000020
+  # Ch0-TR
+  set *(unsigned long *)0x00ef6028 = 0x00051502
+  # Ch0-ADR (size:16MB)
+  set *(unsigned long *)0x00ef6020 = 0x08000002
+  # AutoRef On
+  set *(unsigned long *)0x00ef6004 = 0x00010e24
+  # Access enable
+  set *(unsigned long *)0x00ef6024 = 0x00000001
+end
+document sdram_init
+  SDRAM controller initialization
+  0x08000000 - 0x08ffffff (16MB)
+end
+
+# Initialize BSEL3 for UT-CFC
+define cfc_init
+  set $sfrbase = 0xa0ef0000
+# too fast
+#  set *(unsigned long *)($sfrbase + 0x5300) = 0x0b0b8000
+#  set *(unsigned long *)($sfrbase + 0x5304) = 0x00102204
+#  set *(unsigned long *)($sfrbase + 0x5300) = 0x1f1f8000
+#  set *(unsigned long *)($sfrbase + 0x5300) = 0x1f1f1fdf
+#  set *(unsigned long *)($sfrbase + 0x5304) = 0x0013220f
+#  set *(unsigned long *)($sfrbase + 0x5304) = 0x0013330f
+end
+document cfc_init
+  CF controller initialization
+end
+
+# MMU enable
+define mmu_enable
+  set $evb=0x88000000
+  set *(unsigned long *)0xffff0024=1
+end
+
+# MMU disable
+define mmu_disable
+  set $evb=0
+  set *(unsigned long *)0xffff0024=0
+end
+
+# Show TLB entries
+define show_tlb_entries
+  set $i = 0
+  set $addr = $arg0
+  set $nr_entries = $arg1
+  use_mon_code
+  while ($i < $nr_entries)
+    set $tlb_tag = *(unsigned long*)$addr
+    set $tlb_data = *(unsigned long*)($addr + 4)
+    printf " [%2d] 0x%08lx : 0x%08lx - 0x%08lx\n", $i, $addr, $tlb_tag, $tlb_data
+    set $i = $i + 1
+    set $addr = $addr + 8
+  end
+  use_debug_dma
+end
+define itlb
+  set $itlb=0xfe000000
+  show_tlb_entries $itlb 0d32
+end
+define dtlb
+  set $dtlb=0xfe000800
+  show_tlb_entries $dtlb 0d32
+end
+
+# Initialize TLB entries
+define init_tlb_entries
+  set $i = 0
+  set $addr = $arg0
+  set $nr_entries = $arg1
+  use_mon_code
+  while ($i < $nr_entries)
+    set *(unsigned long *)($addr + 0x4) = 0
+    set $i = $i + 1
+    set $addr = $addr + 8
+  end
+  use_debug_dma
+end
+define tlb_init
+  set $itlb=0xfe000000
+  init_tlb_entries $itlb 0d32
+  set $dtlb=0xfe000800
+  init_tlb_entries $dtlb 0d32
+end
+
+# Show current task structure
+define show_current
+  set $current = $spi & 0xffffe000
+  printf "$current=0x%08lX\n",$current
+  print *(struct task_struct *)$current
+end
+
+# Show user assigned task structure
+define show_task
+  set  = $arg0 & 0xffffe000
+  printf "$task=0x%08lX\n",$task
+  print *(struct task_struct *)$task
+end
+document show_task
+  Show user assigned task structure
+  arg0 : task structure address
+end
+
+# Show M32R registers
+define show_regs
+  printf " R0[0x%08lX]   R1[0x%08lX]   R2[0x%08lX]   R3[0x%08lX]\n",$r0,$r1,$r2,$r3
+  printf " R4[0x%08lX]   R5[0x%08lX]   R6[0x%08lX]   R7[0x%08lX]\n",$r4,$r5,$r6,$r7
+  printf " R8[0x%08lX]   R9[0x%08lX]  R10[0x%08lX]  R11[0x%08lX]\n",$r8,$r9,$r10,$r11
+  printf "R12[0x%08lX]   FP[0x%08lX]   LR[0x%08lX]   SP[0x%08lX]\n",$r12,$fp,$lr,$sp
+  printf "PSW[0x%08lX]  CBR[0x%08lX]  SPI[0x%08lX]  SPU[0x%08lX]\n",$psw,$cbr,$spi,$spu
+  printf "BPC[0x%08lX]   PC[0x%08lX] ACCL[0x%08lX] ACCH[0x%08lX]\n",$bpc,$pc,$accl,$acch
+  printf "EVB[0x%08lX]\n",$evb
+end
+
+# Setup all
+define setup
+  use_mon_code
+  set *(unsigned int)0xfffffffc=0x60
+  shell sleep 0.1
+  clock_init
+  shell sleep 0.1
+  # SDRAM: 16MB
+  set *(unsigned long *)0x00ef6020 = 0x08000002
+  cfc_init
+  # USB
+  set *(unsigned short *)0xb0301000 = 0x100
+
+  set $evb=0x08000000
+end
+
+# Load modules
+define load_modules
+  use_debug_dma
+  load
+end
+
+# Set kernel parameters
+define set_kernel_parameters
+  set $param = (void*)0x08002000
+  # INITRD_START
+  set *(unsigned long *)($param + 0x0010) = 0x082a0000
+  # INITRD_SIZE
+  set *(unsigned long *)($param + 0x0014) = 0x00000000
+  # M32R_CPUCLK
+  set *(unsigned long *)($param + 0x0018) = 0d300000000
+  # M32R_BUSCLK
+  set *(unsigned long *)($param + 0x001c) = 0d75000000
+
+  # M32R_TIMER_DIVIDE
+  set *(unsigned long *)($param + 0x0020) = 0d128
+
+  set {char[0x200]}($param + 0x100) = "console=ttyD0,115200n8x console=tty1 video=s1d13xxxfb:mode:240x320-16 root=/dev/nfsroot nfsroot=192.168.0.1:/project/m32r-linux/export/rootfs,rsize=1024,wsize=1024 nfsaddrs=192.168.0.101:192.168.0.1:192.168.0.1:255.255.255.0:mappi001 mem=16M \0"
+end
+
+# Boot
+define boot
+  set_kernel_parameters
+  set $fp = 0
+  set $pc = 0x08001000
+  set *(unsigned char *)0xffffffff = 0x03
+  si
+  c
+end
+
+# Set breakpoints
+define set_breakpoints
+  b *0x08000030
+end
+
+# Restart
+define restart
+  sdireset
+  sdireset
+  set $pc = 0
+  b *0x04001000
+  b *0x08001000
+  b *0x08002000
+  si
+  c
+  tlb_init
+  del
+  setup
+  load_modules
+  boot
+end
+
+define si
+  stepi
+  x/i $pc
+  show_reg
+end
+
+sdireset
+sdireset
+file vmlinux
+target m32rsdi
+set $pc = 0
+b *0x04001000
+b *0x08001000
+b *0x08002000
+c
+tlb_init
+del
+setup
+load_modules
+boot
+
diff -ruN linux-2.6.7.org/arch/m32r/m32700ut/m32r-flash.c linux-2.6.7/arch/m32r/m32700ut/m32r-flash.c
--- linux-2.6.7.org/arch/m32r/m32700ut/m32r-flash.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/m32700ut/m32r-flash.c	2003-09-09 10:15:02.000000000 +0900
@@ -0,0 +1,227 @@
+/*
+ * Flash memory access on M32R based devices
+ * 
+ * Copyright (C) 2003	Takeo Takahashi
+ * 
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * $Id$
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/map.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/m32r.h>
+#include <asm/io.h>
+
+#define WINDOW_ADDR (0xa0000000)	/* start of flash memory */
+
+static __u8 m32r_read8(struct map_info *map, unsigned long ofs)
+{
+	return readb(map->map_priv_1 + ofs);
+}
+
+static __u16 m32r_read16(struct map_info *map, unsigned long ofs)
+{
+	return readw(map->map_priv_1 + ofs);
+}
+
+static __u32 m32r_read32(struct map_info *map, unsigned long ofs)
+{
+	return readl(map->map_priv_1 + ofs);
+}
+
+static void m32r_copy_from(struct map_info *map, void *to, unsigned long from, ssize_t len)
+{
+	memcpy(to, (void *)(map->map_priv_1 + from), len);
+}
+
+static void m32r_write8(struct map_info *map, __u8 d, unsigned long adr)
+{
+	writeb(d, map->map_priv_1 + adr);
+}
+
+static void m32r_write16(struct map_info *map, __u16 d, unsigned long adr)
+{
+	writew(d, map->map_priv_1 + adr);
+}
+
+static void m32r_write32(struct map_info *map, __u32 d, unsigned long adr)
+{
+	writel(d, map->map_priv_1 + adr);
+}
+
+static void m32r_copy_to(struct map_info *map, unsigned long to, const void *from, ssize_t len)
+{
+	memcpy((void *)(map->map_priv_1 + to), from, len);
+}
+
+static struct map_info m32r_map = {
+	name:		"M32R flash",
+	read8:		m32r_read8,
+	read16:		m32r_read16,
+	read32:		m32r_read32,
+	copy_from:	m32r_copy_from,
+	write8:		m32r_write8,
+	write16:	m32r_write16,
+	write32:	m32r_write32,
+	copy_to:	m32r_copy_to,
+
+	map_priv_1:	WINDOW_ADDR,
+	map_priv_2:	-1,
+};
+
+#ifdef CONFIG_PLAT_M32700UT
+#define M32700UT_FLASH_SIZE		0x00400000
+static struct mtd_partition m32700ut_partitions[] = {
+	{
+		name:		"M32700UT boot firmware",
+		size:		0x30000,		/* 192KB */
+		offset:		0,
+		mask_flags:	MTD_WRITEABLE,  	/* force read-only */
+	}, {
+		name:		"M32700UT kernel",
+		size:		0xd0000,		/* 832KB */
+		offset:		MTDPART_OFS_APPEND,
+	}, {
+		name:		"M32700UT root",
+		size:		0x2f0000,		/* 3008KB */
+		offset:		MTDPART_OFS_APPEND,
+	}, {
+		name:		"M32700UT params",
+		size:		MTDPART_SIZ_FULL,	/* 64KB */
+		offset:		MTDPART_OFS_APPEND,
+	}
+};
+#endif
+
+extern int parse_redboot_partitions(struct mtd_info *master, struct mtd_partition **pparts);
+extern int parse_bootldr_partitions(struct mtd_info *master, struct mtd_partition **pparts);
+
+static struct mtd_partition *parsed_parts;
+static struct mtd_info *mymtd;
+
+int __init m32r_mtd_init(void)
+{
+	struct mtd_partition *parts;
+	int nb_parts = 0, ret;
+	int parsed_nr_parts = 0;
+	const char *part_type;
+	unsigned long base = -1UL;
+
+
+	/* Default flash buswidth */
+	m32r_map.buswidth = 2;
+
+	/*
+	 * Static partition definition selection
+	 */
+	part_type = "static";
+
+#ifdef CONFIG_PLAT_M32700UT
+	parts = m32700ut_partitions;
+	nb_parts = ARRAY_SIZE(m32700ut_partitions);
+	m32r_map.size = M32700UT_FLASH_SIZE;
+	m32r_map.buswidth = 2;
+#endif
+
+	/*
+	 * For simple flash devices, use ioremap to map the flash.
+	 */
+	if (base != (unsigned long)-1) {
+		if (!request_mem_region(base, m32r_map.size, "flash"))
+			return -EBUSY;
+		m32r_map.map_priv_2 = base;
+		m32r_map.map_priv_1 = (unsigned long)
+				ioremap(base, m32r_map.size);
+		ret = -ENOMEM;
+		if (!m32r_map.map_priv_1)
+			goto out_err;
+	}
+
+	/*
+	 * Now let's probe for the actual flash.  Do it here since
+	 * specific machine settings might have been set above.
+	 */
+	printk(KERN_NOTICE "M32R flash: probing %d-bit flash bus\n", m32r_map.buswidth*8);
+	mymtd = do_map_probe("m5drv", &m32r_map);
+	ret = -ENXIO;
+	if (!mymtd)
+		goto out_err;
+	mymtd->module = THIS_MODULE;
+
+	/*
+	 * Dynamic partition selection stuff (might override the static ones)
+	 */
+#ifdef CONFIG_MTD_REDBOOT_PARTS
+	if (parsed_nr_parts == 0) {
+		ret = parse_redboot_partitions(mymtd, &parsed_parts);
+
+		if (ret > 0) {
+			part_type = "RedBoot";
+			parsed_nr_parts = ret;
+		}
+	}
+#endif
+#ifdef CONFIG_MTD_BOOTLDR_PARTS
+	if (parsed_nr_parts == 0) {
+		ret = parse_bootldr_partitions(mymtd, &parsed_parts);
+		if (ret > 0) {
+			part_type = "Compaq bootldr";
+			parsed_nr_parts = ret;
+		}
+	}
+#endif
+
+	if (parsed_nr_parts > 0) {
+		parts = parsed_parts;
+		nb_parts = parsed_nr_parts;
+	}
+
+	if (nb_parts == 0) {
+		printk(KERN_NOTICE "M32R flash: no partition info available, registering whole flash at once\n");
+		add_mtd_device(mymtd);
+	} else {
+		printk(KERN_NOTICE "Using %s partition definition\n", part_type);
+		add_mtd_partitions(mymtd, parts, nb_parts);
+	}
+	return 0;
+
+ out_err:
+	if (m32r_map.map_priv_2 != -1) {
+		iounmap((void *)m32r_map.map_priv_1);
+		release_mem_region(m32r_map.map_priv_2, m32r_map.size);
+	}
+	return ret;
+}
+
+static void __exit m32r_mtd_cleanup(void)
+{
+	if (mymtd) {
+		del_mtd_partitions(mymtd);
+		map_destroy(mymtd);
+		if (parsed_parts)
+			kfree(parsed_parts);
+	}
+	if (m32r_map.map_priv_2 != -1) {
+		iounmap((void *)m32r_map.map_priv_1);
+		release_mem_region(m32r_map.map_priv_2, m32r_map.size);
+	}
+}
+
+module_init(m32r_mtd_init);
+module_exit(m32r_mtd_cleanup);
+
+MODULE_AUTHOR("Takeo Takahashi");
+MODULE_DESCRIPTION("M32R Flash map driver");
+MODULE_LICENSE("GPL");
diff -ruN linux-2.6.7.org/arch/m32r/mappi/defconfig.nommu linux-2.6.7/arch/m32r/mappi/defconfig.nommu
--- linux-2.6.7.org/arch/m32r/mappi/defconfig.nommu	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/mappi/defconfig.nommu	2004-07-15 13:43:14.000000000 +0900
@@ -0,0 +1,522 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_M32R=y
+CONFIG_UID16=y
+CONFIG_GENERIC_ISA_DMA=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_STANDALONE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+# CONFIG_SYSVIPC is not set
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_HOTPLUG=y
+CONFIG_IKCONFIG=y
+# CONFIG_IKCONFIG_PROC is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+# CONFIG_FUTEX is not set
+# CONFIG_EPOLL is not set
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+CONFIG_KMOD=y
+
+#
+# Processor type and features
+#
+CONFIG_PLAT_MAPPI=y
+# CONFIG_PLAT_USRV is not set
+# CONFIG_PLAT_M32700UT is not set
+# CONFIG_PLAT_OAKS32R is not set
+# CONFIG_PLAT_MAPPI2 is not set
+CONFIG_CHIP_M32700=y
+# CONFIG_CHIP_M32102 is not set
+# CONFIG_CHIP_VDEC2 is not set
+# CONFIG_CHIP_OPSP is not set
+# CONFIG_MMU is not set
+CONFIG_TLB_ENTRIES=32
+CONFIG_ISA_M32R2=y
+CONFIG_ISA_DSP_LEVEL2=y
+CONFIG_ISA_DUAL_ISSUE=y
+CONFIG_BUS_CLOCK=50000000
+CONFIG_TIMER_DIVIDE=128
+# CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_MEMORY_START=0x00000000
+CONFIG_MEMORY_SIZE=0x00E00000
+CONFIG_NOHIGHMEM=y
+# CONFIG_DISCONTIGMEM is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+CONFIG_PREEMPT=y
+# CONFIG_HAVE_DEC_LOCK is not set
+# CONFIG_SMP is not set
+
+#
+# M32R drivers
+#
+# CONFIG_M32RPCC is not set
+CONFIG_M32R_NE2000=y
+
+#
+# Power management options (ACPI, APM)
+#
+# CONFIG_PM is not set
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+# CONFIG_PCI is not set
+# CONFIG_ISA is not set
+
+#
+# PCMCIA/CardBus support
+#
+# CONFIG_PCMCIA is not set
+
+#
+# PCI Hotplug Support
+#
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_FLAT=y
+# CONFIG_BINFMT_ZFLAT is not set
+# CONFIG_BINFMT_SHARED_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_FW_LOADER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_NBD=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_BLK_DEV_INITRD is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_NETDEVICES is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_CT82C710 is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_M32R_SIO=y
+CONFIG_SERIAL_M32R_SIO_CONSOLE=y
+# CONFIG_SERIAL_M32R_PLDSIO is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_QIC02_TAPE is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_FAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
+# CONFIG_DEVFS_DEBUG is not set
+CONFIG_DEVPTS_FS_XATTR=y
+CONFIG_DEVPTS_FS_SECURITY=y
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_FRAME_POINTER is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
diff -ruN linux-2.6.7.org/arch/m32r/mappi/defconfig.smp linux-2.6.7/arch/m32r/mappi/defconfig.smp
--- linux-2.6.7.org/arch/m32r/mappi/defconfig.smp	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/mappi/defconfig.smp	2004-07-15 13:43:14.000000000 +0900
@@ -0,0 +1,618 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_M32R=y
+CONFIG_UID16=y
+CONFIG_GENERIC_ISA_DMA=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+# CONFIG_STANDALONE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=15
+CONFIG_HOTPLUG=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+# CONFIG_FUTEX is not set
+# CONFIG_EPOLL is not set
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+CONFIG_KMOD=y
+CONFIG_STOP_MACHINE=y
+
+#
+# Processor type and features
+#
+CONFIG_PLAT_MAPPI=y
+# CONFIG_PLAT_USRV is not set
+# CONFIG_PLAT_M32700UT is not set
+# CONFIG_PLAT_OAKS32R is not set
+# CONFIG_PLAT_MAPPI2 is not set
+CONFIG_CHIP_M32700=y
+# CONFIG_CHIP_M32102 is not set
+# CONFIG_CHIP_VDEC2 is not set
+# CONFIG_CHIP_OPSP is not set
+CONFIG_MMU=y
+CONFIG_TLB_ENTRIES=32
+CONFIG_ISA_M32R2=y
+CONFIG_ISA_DSP_LEVEL2=y
+CONFIG_ISA_DUAL_ISSUE=y
+CONFIG_BUS_CLOCK=10000000
+CONFIG_TIMER_DIVIDE=128
+# CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_MEMORY_START=0x08000000
+CONFIG_MEMORY_SIZE=0x04000000
+CONFIG_NOHIGHMEM=y
+CONFIG_DISCONTIGMEM=y
+CONFIG_IRAM_START=0x00f00000
+CONFIG_IRAM_SIZE=0x00080000
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+CONFIG_PREEMPT=y
+# CONFIG_HAVE_DEC_LOCK is not set
+CONFIG_SMP=y
+CONFIG_CHIP_M32700_TS1=y
+CONFIG_NR_CPUS=2
+# CONFIG_NUMA is not set
+
+#
+# M32R drivers
+#
+CONFIG_M32RPCC=y
+CONFIG_M32R_NE2000=y
+
+#
+# Power management options (ACPI, APM)
+#
+# CONFIG_PM is not set
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+# CONFIG_PCI is not set
+# CONFIG_ISA is not set
+
+#
+# PCMCIA/CardBus support
+#
+CONFIG_PCMCIA=y
+# CONFIG_PCMCIA_DEBUG is not set
+# CONFIG_TCIC is not set
+
+#
+# PCI Hotplug Support
+#
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_FW_LOADER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_REDBOOT_PARTS=y
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_NBD=m
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=m
+CONFIG_BLK_DEV_IDE=m
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+CONFIG_BLK_DEV_IDEDISK=m
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECS=m
+CONFIG_BLK_DEV_IDECD=m
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+# CONFIG_IDE_TASKFILE_IO is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=m
+# CONFIG_IDE_ARM is not set
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_NETDEVICES is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_M32R_SIO=y
+CONFIG_SERIAL_M32R_SIO_CONSOLE=y
+# CONFIG_SERIAL_M32R_PLDSIO is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_QIC02_TAPE is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+
+#
+# PCMCIA character devices
+#
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+# CONFIG_JOLIET is not set
+# CONFIG_ZISOFS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=m
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
+# CONFIG_DEVFS_DEBUG is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS_FS=y
+CONFIG_JFFS_FS_VERBOSE=0
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_FRAME_POINTER is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -ruN linux-2.6.7.org/arch/m32r/mappi/defconfig.up linux-2.6.7/arch/m32r/mappi/defconfig.up
--- linux-2.6.7.org/arch/m32r/mappi/defconfig.up	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/mappi/defconfig.up	2004-07-15 13:43:14.000000000 +0900
@@ -0,0 +1,614 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_M32R=y
+CONFIG_UID16=y
+CONFIG_GENERIC_ISA_DMA=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+# CONFIG_CLEAN_COMPILE is not set
+# CONFIG_STANDALONE is not set
+CONFIG_BROKEN=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_HOTPLUG=y
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+# CONFIG_FUTEX is not set
+# CONFIG_EPOLL is not set
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+CONFIG_KMOD=y
+
+#
+# Processor type and features
+#
+CONFIG_PLAT_MAPPI=y
+# CONFIG_PLAT_USRV is not set
+# CONFIG_PLAT_M32700UT is not set
+# CONFIG_PLAT_OAKS32R is not set
+# CONFIG_PLAT_MAPPI2 is not set
+CONFIG_CHIP_M32700=y
+# CONFIG_CHIP_M32102 is not set
+# CONFIG_CHIP_VDEC2 is not set
+# CONFIG_CHIP_OPSP is not set
+CONFIG_MMU=y
+CONFIG_TLB_ENTRIES=32
+CONFIG_ISA_M32R2=y
+CONFIG_ISA_DSP_LEVEL2=y
+CONFIG_ISA_DUAL_ISSUE=y
+CONFIG_BUS_CLOCK=10000000
+CONFIG_TIMER_DIVIDE=128
+# CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_MEMORY_START=0x08000000
+CONFIG_MEMORY_SIZE=0x04000000
+CONFIG_NOHIGHMEM=y
+CONFIG_DISCONTIGMEM=y
+CONFIG_IRAM_START=0x00f00000
+CONFIG_IRAM_SIZE=0x00080000
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+CONFIG_PREEMPT=y
+# CONFIG_HAVE_DEC_LOCK is not set
+# CONFIG_SMP is not set
+
+#
+# M32R drivers
+#
+CONFIG_M32RPCC=y
+CONFIG_M32R_NE2000=y
+
+#
+# Power management options (ACPI, APM)
+#
+# CONFIG_PM is not set
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+# CONFIG_PCI is not set
+# CONFIG_ISA is not set
+
+#
+# PCMCIA/CardBus support
+#
+CONFIG_PCMCIA=y
+# CONFIG_PCMCIA_DEBUG is not set
+# CONFIG_TCIC is not set
+
+#
+# PCI Hotplug Support
+#
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_FW_LOADER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_CONCAT is not set
+CONFIG_MTD_REDBOOT_PARTS=y
+# CONFIG_MTD_CMDLINE_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+# CONFIG_MTD_OBSOLETE_CHIPS is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLKMTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+
+#
+# NAND Flash Device Drivers
+#
+# CONFIG_MTD_NAND is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_NBD=m
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=4096
+CONFIG_BLK_DEV_INITRD=y
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+CONFIG_IDE=m
+CONFIG_BLK_DEV_IDE=m
+
+#
+# Please see Documentation/ide.txt for help/info on IDE drives
+#
+CONFIG_BLK_DEV_IDEDISK=m
+# CONFIG_IDEDISK_MULTI_MODE is not set
+CONFIG_BLK_DEV_IDECS=m
+CONFIG_BLK_DEV_IDECD=m
+# CONFIG_BLK_DEV_IDETAPE is not set
+# CONFIG_BLK_DEV_IDEFLOPPY is not set
+# CONFIG_IDE_TASK_IOCTL is not set
+# CONFIG_IDE_TASKFILE_IO is not set
+
+#
+# IDE chipset support/bugfixes
+#
+CONFIG_IDE_GENERIC=m
+# CONFIG_IDE_ARM is not set
+# CONFIG_BLK_DEV_IDEDMA is not set
+# CONFIG_IDEDMA_AUTO is not set
+# CONFIG_BLK_DEV_HD is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+# CONFIG_PACKET is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_NETDEVICES is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+CONFIG_INPUT_MOUSEDEV_PSAUX=y
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=1024
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=768
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+# CONFIG_SERIO_SERPORT is not set
+# CONFIG_SERIO_CT82C710 is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_M32R_SIO=y
+CONFIG_SERIAL_M32R_SIO_CONSOLE=y
+# CONFIG_SERIAL_M32R_PLDSIO is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_QIC02_TAPE is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+
+#
+# PCMCIA character devices
+#
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+CONFIG_ROMFS_FS=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=y
+# CONFIG_JOLIET is not set
+# CONFIG_ZISOFS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=m
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
+# CONFIG_DEVFS_DEBUG is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_HUGETLBFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS_FS=y
+CONFIG_JFFS_FS_VERBOSE=0
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+# CONFIG_JFFS2_FS_NAND is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_FRAME_POINTER is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
diff -ruN linux-2.6.7.org/arch/m32r/mappi/dot.gdbinit linux-2.6.7/arch/m32r/mappi/dot.gdbinit
--- linux-2.6.7.org/arch/m32r/mappi/dot.gdbinit	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/mappi/dot.gdbinit	2004-03-16 21:46:44.000000000 +0900
@@ -0,0 +1,242 @@
+# .gdbinit file
+# $Id$
+#-----
+# NOTE: this file is generated by a script, "gen_gdbinit.pl".
+# (Please type "gen_gdbinit.pl --help" and check the help message).
+# $ Id: gen_gdbinit.pl,v 1.8 2004/02/27 07:08:32 takata Exp $
+#-----
+# target platform: mappi
+
+# setting
+set width 0d70
+set radix 0d16
+debug_chaos
+
+# clk xin:cpu:bif:bus=30:360:180:90
+define clock_init
+  set *(unsigned long *)0x00ef4024 = 2
+  set *(unsigned long *)0x00ef4020 = 1
+  set *(unsigned long *)0x00ef4010 = 0
+  set *(unsigned long *)0x00ef4014 = 0
+  set *(unsigned long *)0x00ef4004 = 5
+  shell sleep 0.1
+  set *(unsigned long *)0x00ef4008 = 0x00000200
+end
+
+# Initialize programmable ports
+define port_init
+  set $sfrbase = 0x00ef0000
+  set *(unsigned short *)0x00ef1060 = 0x5555
+  set *(unsigned short *)0x00ef1062 = 0x5555
+  set *(unsigned short *)0x00ef1064 = 0x5555
+  set *(unsigned short *)0x00ef1066 = 0x5555
+  set *(unsigned short *)0x00ef1068 = 0x5555
+  set *(unsigned short *)0x00ef106a = 0x0000
+  set *(unsigned short *)0x00ef106e = 0x5555
+  set *(unsigned short *)0x00ef1070 = 0x5555
+  # LED ON
+  set *(unsigned char *)($sfrbase + 0x1015) = 0xff
+  set *(unsigned char *)($sfrbase + 0x1085) = 0xff
+  shell sleep 0.1
+  # LED OFF
+  set *(unsigned char *)($sfrbase + 0x1085) = 0x00
+end
+document port_init
+  P5=LED(output), P6.b4=LAN_RESET(output)
+end
+
+# Initialize SDRAM controller
+define sdram_init
+  # SDIR0
+  set *(unsigned long *)0x00ef6008 = 0x00000182
+  # SDIR1
+  set *(unsigned long *)0x00ef600c = 0x00000001
+  # Initialize wait
+  shell sleep 0.1
+  # Ch0-MOD
+  set *(unsigned long *)0x00ef602c = 0x00000020
+  # Ch0-TR
+  set *(unsigned long *)0x00ef6028 = 0x00051502
+  # Ch0-ADR (size:64MB)
+  set *(unsigned long *)0x00ef6020 = 0x08000004
+  # AutoRef On
+  set *(unsigned long *)0x00ef6004 = 0x00010e2b
+  # Access enable
+  set *(unsigned long *)0x00ef6024 = 0x00000001
+end
+document sdram_init
+  SDRAM controller initialization
+  0x08000000 - 0x0bffffff (64MB)
+end
+
+# Initialize LAN controller
+define lanc_init
+  set $sfrbase = 0x00ef0000
+  # Set BSEL3 (BSEL3 for the Chaos's bselc)
+  set *(unsigned long *)($sfrbase + 0x5300) = 0x0a0a8040
+  set *(unsigned long *)($sfrbase + 0x5304) = 0x01120203
+  set *(unsigned long *)($sfrbase + 0x5308) = 0x00000001
+  # Reset (P5=LED,P6.b4=LAN_RESET)
+  set *(unsigned short *)($sfrbase + 0x106c) = 0x0000
+  set *(unsigned char *)($sfrbase + 0x1016) = 0xff
+  set *(unsigned char *)($sfrbase + 0x1086) = 0xff
+  shell sleep 0.1
+  # swivel: 0=normal, 4=reverse
+#  set *(unsigned char *)($sfrbase + 0x1086) = 0x00
+  set *(unsigned char *)($sfrbase + 0x1086) = 0x04
+  set *(unsigned long *)(0x0c000330) = 0xffffffff
+  # Set mac address
+  set $lanc = (void*)0x0c000300
+  set *(unsigned long *)($lanc + 0x0000) = 0x00610010
+  set *(unsigned long *)($lanc + 0x0004) = 0x00200030
+  set *(unsigned long *)($lanc + 0x0008) = 0x00400050
+  set *(unsigned long *)($lanc + 0x000c) = 0x00600007
+end
+document lanc_init
+  LAN controller initialization
+  ex.) MAC address:  10 20 30 40 50 60
+end
+
+# LCD & CRT dual-head setting (8bpp)
+define dispc_init
+  set $sfrbase = 0x00ef0000
+  # BSEL4 Dispc
+  set *(unsigned long *)($sfrbase + 0x5400) = 0x0e0e8000
+  set *(unsigned long *)($sfrbase + 0x5404) = 0x0012220a
+end
+
+# MMU enable
+define mmu_enable
+  set $evb=0x88000000
+  set *(unsigned long *)0xffff0024=1
+end
+
+# MMU disable
+define mmu_disable
+  set $evb=0
+  set *(unsigned long *)0xffff0024=0
+end
+
+# Show TLB entries
+define show_tlb_entries
+  set $i = 0
+  set $addr = $arg0
+  set $nr_entries = $arg1
+  use_mon_code
+  while ($i < $nr_entries)
+    set $tlb_tag = *(unsigned long*)$addr
+    set $tlb_data = *(unsigned long*)($addr + 4)
+    printf " [%2d] 0x%08lx : 0x%08lx - 0x%08lx\n", $i, $addr, $tlb_tag, $tlb_data
+    set $i = $i + 1
+    set $addr = $addr + 8
+  end
+  use_debug_dma
+end
+define itlb
+  set $itlb=0xfe000000
+  show_tlb_entries $itlb 0d32
+end
+define dtlb
+  set $dtlb=0xfe000800
+  show_tlb_entries $dtlb 0d32
+end
+
+# Show current task structure
+define show_current
+  set $current = $spi & 0xffffe000
+  printf "$current=0x%08lX\n",$current
+  print *(struct task_struct *)$current
+end
+
+# Show user assigned task structure
+define show_task
+  set  = $arg0 & 0xffffe000
+  printf "$task=0x%08lX\n",$task
+  print *(struct task_struct *)$task
+end
+document show_task
+  Show user assigned task structure
+  arg0 : task structure address
+end
+
+# Show M32R registers
+define show_regs
+  printf " R0[0x%08lX]   R1[0x%08lX]   R2[0x%08lX]   R3[0x%08lX]\n",$r0,$r1,$r2,$r3
+  printf " R4[0x%08lX]   R5[0x%08lX]   R6[0x%08lX]   R7[0x%08lX]\n",$r4,$r5,$r6,$r7
+  printf " R8[0x%08lX]   R9[0x%08lX]  R10[0x%08lX]  R11[0x%08lX]\n",$r8,$r9,$r10,$r11
+  printf "R12[0x%08lX]   FP[0x%08lX]   LR[0x%08lX]   SP[0x%08lX]\n",$r12,$fp,$lr,$sp
+  printf "PSW[0x%08lX]  CBR[0x%08lX]  SPI[0x%08lX]  SPU[0x%08lX]\n",$psw,$cbr,$spi,$spu
+  printf "BPC[0x%08lX]   PC[0x%08lX] ACCL[0x%08lX] ACCH[0x%08lX]\n",$bpc,$pc,$accl,$acch
+  printf "EVB[0x%08lX]\n",$evb
+end
+
+# Setup all
+define setup
+  use_mon_code
+  set *(unsigned int)0xfffffffc=0x60
+  shell sleep 0.1
+  clock_init
+  shell sleep 0.1
+  port_init
+  sdram_init
+  lanc_init
+  dispc_init
+  set $evb=0x08000000
+end
+
+# Load modules
+define load_modules
+  use_debug_dma
+  load
+end
+
+# Set kernel parameters
+define set_kernel_parameters
+  set $param = (void*)0x08002000
+  # INITRD_START
+  set *(unsigned long *)($param + 0x0010) = 0x082a0000
+  # INITRD_SIZE
+  set *(unsigned long *)($param + 0x0014) = 0x00000000
+  # M32R_CPUCLK
+  set *(unsigned long *)($param + 0x0018) = 0d360000000
+  # M32R_BUSCLK
+  set *(unsigned long *)($param + 0x001c) = 0d90000000
+
+  # M32R_TIMER_DIVIDE
+  set *(unsigned long *)($param + 0x0020) = 0d128
+
+  set {char[0x200]}($param + 0x100) = "console=ttyD0,115200n8x root=/dev/nfsroot nfsroot=192.168.0.1:/project/m32r-linux/export/root.x nfsaddrs=192.168.0.101:192.168.0.1:192.168.0.1:255.255.255.0:mappi001 \0"
+end
+
+# Boot
+define boot
+  set_kernel_parameters
+  set $fp = 0
+  set $pc=0x08001000
+  si
+  c
+end
+
+# Set breakpoints
+define set_breakpoints
+  b *0x08000030
+end
+
+# Restart
+define restart
+  sdireset
+  sdireset
+  setup
+  load_modules
+  boot
+end
+
+sdireset
+sdireset
+file vmlinux
+target m32rsdi
+setup
+#load_module
+#set_breakpoints
+#boot
+
diff -ruN linux-2.6.7.org/arch/m32r/mappi/dot.gdbinit.nommu linux-2.6.7/arch/m32r/mappi/dot.gdbinit.nommu
--- linux-2.6.7.org/arch/m32r/mappi/dot.gdbinit.nommu	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/mappi/dot.gdbinit.nommu	2004-03-30 15:47:48.000000000 +0900
@@ -0,0 +1,245 @@
+# .gdbinit file
+# $Id$
+#-----
+# NOTE: this file is generated by a script, "gen_gdbinit.pl".
+# (Please type "gen_gdbinit.pl --help" and check the help message).
+# $ Id: gen_gdbinit.pl,v 1.5 2004/01/23 08:23:25 takata Exp $
+#-----
+# target platform: mappi
+
+# setting
+set width 0d70
+set radix 0d16
+debug_chaos
+
+# clk xin:cpu:bif:bus=25:200:50:50
+define clock_init
+  set *(unsigned long *)0x00ef4024 = 2
+  set *(unsigned long *)0x00ef4020 = 2
+  set *(unsigned long *)0x00ef4010 = 0
+  set *(unsigned long *)0x00ef4014 = 0
+  set *(unsigned long *)0x00ef4004 = 3
+  shell sleep 0.1
+  set *(unsigned long *)0x00ef4008 = 0x00000200
+end
+
+# Initialize programmable ports
+define port_init
+  set $sfrbase = 0x00ef0000
+  set *(unsigned short *)0x00ef1060 = 0x5555
+  set *(unsigned short *)0x00ef1062 = 0x5555
+  set *(unsigned short *)0x00ef1064 = 0x5555
+  set *(unsigned short *)0x00ef1066 = 0x5555
+  set *(unsigned short *)0x00ef1068 = 0x5555
+  set *(unsigned short *)0x00ef106a = 0x0000
+  set *(unsigned short *)0x00ef106e = 0x5555
+  set *(unsigned short *)0x00ef1070 = 0x5555
+  # LED ON
+  set *(unsigned char *)($sfrbase + 0x1015) = 0xff
+  set *(unsigned char *)($sfrbase + 0x1085) = 0xff
+  shell sleep 0.1
+  # LED OFF
+  set *(unsigned char *)($sfrbase + 0x1085) = 0x00
+end
+document port_init
+  P5=LED(output), P6.b4=LAN_RESET(output)
+end
+
+# Initialize SDRAM controller
+define sdram_init
+  # SDIR0
+  set *(unsigned long *)0x00ef6008 = 0x00000182
+  # SDIR1
+  set *(unsigned long *)0x00ef600c = 0x00000001
+  # Initialize wait
+  shell sleep 0.1
+  # Ch0-MOD
+  set *(unsigned long *)0x00ef602c = 0x00000020
+  # Ch0-TR
+  set *(unsigned long *)0x00ef6028 = 0x00051502
+  # Ch0-ADR (size:64MB)
+  set *(unsigned long *)0x00ef6020 = 0x00000004
+  # AutoRef On
+  set *(unsigned long *)0x00ef6004 = 0x00010f05
+  # Access enable
+  set *(unsigned long *)0x00ef6024 = 0x00000001
+end
+document sdram_init
+  SDRAM controller initialization
+  0x08000000 - 0x0bffffff (64MB)
+end
+
+# Initialize LAN controller
+define lanc_init
+  set $sfrbase = 0x00ef0000
+  # Set BSEL3 (BSEL3 for the Chaos's bselc)
+  set *(unsigned long *)($sfrbase + 0x5300) = 0x07078040
+  set *(unsigned long *)($sfrbase + 0x5304) = 0x01110102
+  set *(unsigned long *)($sfrbase + 0x5308) = 0x00000001
+  # Reset (P5=LED,P6.b4=LAN_RESET)
+  set *(unsigned short *)($sfrbase + 0x106c) = 0x0000
+  set *(unsigned char *)($sfrbase + 0x1016) = 0xff
+  set *(unsigned char *)($sfrbase + 0x1086) = 0xff
+  shell sleep 0.1
+  # swivel: 0=normal, 4=reverse
+#  set *(unsigned char *)($sfrbase + 0x1086) = 0x00
+  set *(unsigned char *)($sfrbase + 0x1086) = 0x04
+  set *(unsigned long *)(0x0c000330) = 0xffffffff
+  # Set mac address
+  set $lanc = (void*)0x0c000300
+  set *(unsigned long *)($lanc + 0x0000) = 0x00610010
+  set *(unsigned long *)($lanc + 0x0004) = 0x00200030
+  set *(unsigned long *)($lanc + 0x0008) = 0x00400050
+  set *(unsigned long *)($lanc + 0x000c) = 0x00600007
+end
+document lanc_init
+  LAN controller initialization
+  ex.) MAC address:  10 20 30 40 50 60
+end
+
+# LCD & CRT dual-head setting (8bpp)
+define dispc_init
+  set $sfrbase = 0x00ef0000
+  # BSEL4 Dispc
+  set *(unsigned long *)($sfrbase + 0x5400) = 0x06078000
+  set *(unsigned long *)($sfrbase + 0x5404) = 0x00101101
+end
+
+# MMU enable
+define mmu_enable
+  set $evb=0x88000000
+  set *(unsigned long *)0xffff0024=1
+end
+
+# MMU disable
+define mmu_disable
+  set $evb=0
+  set *(unsigned long *)0xffff0024=0
+end
+
+# Show TLB entries
+define show_tlb_entries
+  set $i = 0
+  set $addr = $arg0
+  set $nr_entries = $arg1
+  use_mon_code
+  while ($i < $nr_entries)
+    set $tlb_tag = *(unsigned long*)$addr
+    set $tlb_data = *(unsigned long*)($addr + 4)
+    printf " [%2d] 0x%08lx : 0x%08lx - 0x%08lx\n", $i, $addr, $tlb_tag, $tlb_data
+    set $i = $i + 1
+    set $addr = $addr + 8
+  end
+  use_debug_dma
+end
+define itlb
+  set $itlb=0xfe000000
+  show_tlb_entries $itlb 0d32
+end
+define dtlb
+  set $dtlb=0xfe000800
+  show_tlb_entries $dtlb 0d32
+end
+
+# Show current task structure
+define show_current
+  set $current = $spi & 0xffffe000
+  printf "$current=0x%08lX\n",$current
+  print *(struct task_struct *)$current
+end
+
+# Show user assigned task structure
+define show_task
+  set  = $arg0 & 0xffffe000
+  printf "$task=0x%08lX\n",$task
+  print *(struct task_struct *)$task
+end
+document show_task
+  Show user assigned task structure
+  arg0 : task structure address
+end
+
+# Show M32R registers
+define show_regs
+  printf " R0[0x%08lX]   R1[0x%08lX]   R2[0x%08lX]   R3[0x%08lX]\n",$r0,$r1,$r2,$r3
+  printf " R4[0x%08lX]   R5[0x%08lX]   R6[0x%08lX]   R7[0x%08lX]\n",$r4,$r5,$r6,$r7
+  printf " R8[0x%08lX]   R9[0x%08lX]  R10[0x%08lX]  R11[0x%08lX]\n",$r8,$r9,$r10,$r11
+  printf "R12[0x%08lX]   FP[0x%08lX]   LR[0x%08lX]   SP[0x%08lX]\n",$r12,$fp,$lr,$sp
+  printf "PSW[0x%08lX]  CBR[0x%08lX]  SPI[0x%08lX]  SPU[0x%08lX]\n",$psw,$cbr,$spi,$spu
+  printf "BPC[0x%08lX]   PC[0x%08lX] ACCL[0x%08lX] ACCH[0x%08lX]\n",$bpc,$pc,$accl,$acch
+  printf "EVB[0x%08lX]\n",$evb
+end
+
+# Setup all
+define setup
+  use_mon_code
+  set *(unsigned int)0xfffffffc=0x60
+  shell sleep 0.1
+  clock_init
+  shell sleep 0.1
+  port_init
+  sdram_init
+  lanc_init
+  dispc_init
+  set $evb=0x00000000
+end
+
+# Load modules
+define load_modules
+  use_debug_dma
+  load
+end
+
+# Set kernel parameters
+define set_kernel_parameters
+  set $param = (void*)0x00002000
+  # INITRD_START
+  #set *(unsigned long *)($param + 0x0010) = 0x082a0000
+  # INITRD_SIZE
+  #set *(unsigned long *)($param + 0x0014) = 0x00000000
+  # M32R_CPUCLK
+  set *(unsigned long *)($param + 0x0018) = 0d200000000
+  # M32R_BUSCLK
+  set *(unsigned long *)($param + 0x001c) = 0d50000000
+
+  # M32R_TIMER_DIVIDE
+  set *(unsigned long *)($param + 0x0020) = 0d128
+
+  set {char[0x200]}($param + 0x100) = "console=ttyD0,115200n8x root=/dev/nfsroot nfsroot=192.168.0.1:/project/m32r-linux/export/root.bbox-httpd nfsaddrs=192.168.0.101:192.168.0.1:192.168.0.1:255.255.255.0:mappi001 \0"
+end
+
+# Boot
+define boot
+  set_kernel_parameters
+  set $fp = 0
+  set $pc=0x00001000
+  set *(long *)0xfffffff4=0x8080
+#  b load_flat_binary
+#  set *(unsigned char *)0x08001003=0x63
+#  set *(unsigned char *)0x08001003=0x02
+  si
+#  c
+end
+
+# Set breakpoints
+define set_breakpoints
+  b *0x08000030
+end
+
+# Restart
+define restart
+  sdireset
+  sdireset
+  setup
+  load_modules
+  boot
+end
+
+sdireset
+sdireset
+file vmlinux
+target m32rsdi
+setup
+load_modules
+boot
+
diff -ruN linux-2.6.7.org/arch/m32r/mappi/dot.gdbinit.smp linux-2.6.7/arch/m32r/mappi/dot.gdbinit.smp
--- linux-2.6.7.org/arch/m32r/mappi/dot.gdbinit.smp	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/mappi/dot.gdbinit.smp	2003-09-09 10:15:02.000000000 +0900
@@ -0,0 +1,344 @@
+# .gdbinit file
+# $Id$
+
+# setting
+set width 0d70
+set radix 0d16
+debug_chaos
+
+# clk xin:cpu:bif:bus=1:4:2:1
+define clock_init_on
+  set *(unsigned long *)0x00ef4024 = 2   
+  set *(unsigned long *)0x00ef4020 = 1   
+  set *(unsigned long *)0x00ef4010 = 0   
+  set *(unsigned long *)0x00ef4014 = 0
+  set *(unsigned long *)0x00ef4004 = 0x1
+  shell sleep 0.1   
+  set *(unsigned long *)0x00ef4008 = 0x0200
+#  set *(unsigned long *)0x00ef4008 = 0x0201
+end
+
+# clk xin:cpu:bif:bus=1:4:1:1
+define clock_init_on_1411
+  set *(unsigned long *)0x00ef4024 = 2   
+  set *(unsigned long *)0x00ef4020 = 2   
+  set *(unsigned long *)0x00ef4010 = 0   
+  set *(unsigned long *)0x00ef4014 = 0
+  set *(unsigned long *)0x00ef4004 = 0x1
+  shell sleep 0.1   
+  set *(unsigned long *)0x00ef4008 = 0x0200
+end
+
+# clk xin:cpu:bif:bus=1:4:2:1
+define clock_init_on_1421
+  set *(unsigned long *)0x00ef4024 = 2   
+  set *(unsigned long *)0x00ef4020 = 1   
+  set *(unsigned long *)0x00ef4010 = 0   
+  set *(unsigned long *)0x00ef4014 = 0
+  set *(unsigned long *)0x00ef4004 = 0x1
+  shell sleep 0.1   
+  set *(unsigned long *)0x00ef4008 = 0x0200
+end
+
+# clk xin:cpu:bif:bus=1:8:2:1
+define clock_init_on_1821
+  set *(unsigned long *)0x00ef4024 = 3   
+  set *(unsigned long *)0x00ef4020 = 2   
+  set *(unsigned long *)0x00ef4010 = 0   
+  set *(unsigned long *)0x00ef4014 = 0
+  set *(unsigned long *)0x00ef4004 = 0x3
+  shell sleep 0.1   
+  set *(unsigned long *)0x00ef4008 = 0x0200
+end
+
+# clk xin:cpu:bif:bus=1:8:4:1
+define clock_init_on_1841
+  set *(unsigned long *)0x00ef4024 = 3   
+  set *(unsigned long *)0x00ef4020 = 1   
+  set *(unsigned long *)0x00ef4010 = 0   
+  set *(unsigned long *)0x00ef4014 = 0
+  set *(unsigned long *)0x00ef4004 = 0x3
+  shell sleep 0.1   
+  set *(unsigned long *)0x00ef4008 = 0x0200
+end
+
+# clk xin:cpu:bif:bus=1:16:8:1
+define clock_init_on_11681
+  set *(unsigned long *)0x00ef4024 = 4   
+  set *(unsigned long *)0x00ef4020 = 2   
+  set *(unsigned long *)0x00ef4010 = 0   
+  set *(unsigned long *)0x00ef4014 = 0
+  set *(unsigned long *)0x00ef4004 = 0x7
+  shell sleep 0.1   
+  set *(unsigned long *)0x00ef4008 = 0x0200
+end
+
+# clk xin:cpu:bif:bus=1:1:1:1
+define clock_init_off
+  # CPU
+  set *(unsigned long *)0x00ef4010 = 0
+  set *(unsigned long *)0x00ef4014 = 0
+  # BIF
+  set *(unsigned long *)0x00ef4020 = 0
+  # BUS
+  set *(unsigned long *)0x00ef4024 = 0
+  # PLL
+  set *(unsigned long *)0x00ef4008 = 0x0000
+end
+
+# Initialize programmable ports
+define port_init
+  set $sfrbase = 0x00ef0000
+  set *(unsigned short *)0x00ef1060 = 0x5555	
+  set *(unsigned short *)0x00ef1062 = 0x5555	
+  set *(unsigned short *)0x00ef1064 = 0x5555	
+  set *(unsigned short *)0x00ef1066 = 0x5555	
+  set *(unsigned short *)0x00ef1068 = 0x5555	
+  set *(unsigned short *)0x00ef106a = 0x0000
+  set *(unsigned short *)0x00ef106e = 0x5555	
+  set *(unsigned short *)0x00ef1070 = 0x5555	
+  # LED ON
+  set *(unsigned char *)($sfrbase + 0x1015) = 0xff
+  set *(unsigned char *)($sfrbase + 0x1085) = 0xff
+  shell sleep 0.1
+  # LED OFF
+  set *(unsigned char *)($sfrbase + 0x1085) = 0x00
+end
+document port_init
+  P5=LED(output), P6.b4=LAN_RESET(output)
+end
+
+# Initialize SDRAM controller for Mappi
+define sdram_init
+  # SDIR0
+  set *(unsigned long *)0x00ef6008 = 0x00000182
+  # SDIR1
+  set *(unsigned long *)0x00ef600c = 0x00000001
+  # Initialize wait
+  shell sleep 0.1
+  # Ch0-MOD
+  set *(unsigned long *)0x00ef602c = 0x00000020
+  # Ch0-TR
+  set *(unsigned long *)0x00ef6028 = 0x00010002
+  # Ch0-ADR
+  set *(unsigned long *)0x00ef6020 = 0x08000004
+  # AutoRef On
+  set *(unsigned long *)0x00ef6004 = 0x00010107
+  # Access enable
+  set *(unsigned long *)0x00ef6024 = 0x00000001
+end
+document sdram_init
+  Mappi SDRAM controller initialization
+  0x08000000 - 0x0bffffff (64MB)
+end
+
+# Initialize LAN controller for Mappi
+define lanc_init
+  set $sfrbase = 0x00ef0000
+  # Set BSEL3 (BSEL3 for the Chaos's bselc)
+#  set *(unsigned long *)($sfrbase + 0x5300) = 0x01018040
+#  set *(unsigned long *)($sfrbase + 0x5304) = 0x01011101
+  set *(unsigned long *)($sfrbase + 0x5300) = 0x04048000
+  set *(unsigned long *)($sfrbase + 0x5304) = 0x01011103
+  set *(unsigned long *)($sfrbase + 0x5308) = 0x00000001
+  # Reset (P5=LED,P6.b4=LAN_RESET)
+  set *(unsigned short *)($sfrbase + 0x106c) = 0x0000
+  set *(unsigned char *)($sfrbase + 0x1016) = 0xff
+  set *(unsigned char *)($sfrbase + 0x1086) = 0xff
+  shell sleep 0.1
+#  set *(unsigned char *)($sfrbase + 0x1086) = 0x00
+  set *(unsigned char *)($sfrbase + 0x1086) = 0x04
+  set *(unsigned long *)(0x0c000330) = 0xffffffff
+  # Set mac address
+  set $lanc = (void*)0x0c000300
+  set *(unsigned long *)($lanc + 0x0000) = 0x00610010
+  set *(unsigned long *)($lanc + 0x0004) = 0x00200030
+  set *(unsigned long *)($lanc + 0x0008) = 0x00400050
+  set *(unsigned long *)($lanc + 0x000c) = 0x00600007
+end
+document lanc_init
+  Mappi LAN controller initialization
+  ex.) MAC address:  10 20 30 40 50 60
+end
+
+# LCD & CRT dual-head setting (8bpp)
+define dispc_init
+  set $sfrbase = 0x00ef0000
+  # BSEL4 Dispc
+  # 20MHz
+#  set *(unsigned long *)($sfrbase + 0x5400) = 0x02028282
+#  set *(unsigned long *)($sfrbase + 0x5404) = 0x00122202
+  # 40MHz
+  set *(unsigned long *)($sfrbase + 0x5400) = 0x04048000
+  set *(unsigned long *)($sfrbase + 0x5404) = 0x00101103
+end
+
+# MMU enable
+define mmu_enable
+  set $evb=0x88000000
+  set *(unsigned long *)0xffff0024=1
+end
+
+# MMU disable
+define mmu_disable
+  set $evb=0
+  set *(unsigned long *)0xffff0024=0
+end
+
+# Show TLB entries
+define show_tlb_entries
+  set $i = 0
+  set $addr = $arg0
+  use_mon_code
+  while ($i < 0d32 )
+    set $tlb_tag = *(unsigned long*)$addr
+    set $tlb_data = *(unsigned long*)($addr + 4)
+    printf " [%2d] 0x%08lx : 0x%08lx - 0x%08lx\n", $i, $addr, $tlb_tag, $tlb_data
+    set $i = $i + 1
+    set $addr = $addr + 8
+  end
+  use_debug_dma
+end
+define itlb
+  set $itlb=0xfe000000
+  show_tlb_entries $itlb
+end
+define dtlb
+  set $dtlb=0xfe000800
+  show_tlb_entries $dtlb
+end
+
+
+# Show current task structure
+define show_current
+  set $current = $spi & 0xffffe000
+  printf "$current=0x%08lX\n",$current
+  print *(struct task_struct *)$current
+end
+
+# Show user assigned task structure
+define show_task
+  set $task = $arg0 & 0xffffe000
+  printf "$task=0x%08lX\n",$task
+  print *(struct task_struct *)$task
+end
+document show_task
+  Show user assigned task structure
+  arg0 : task structure address
+end
+
+# Show M32R registers
+define show_regs
+  printf " R0[0x%08lX]   R1[0x%08lX]   R2[0x%08lX]   R3[0x%08lX]\n",$r0,$r1,$r2,$r3 
+  printf " R4[0x%08lX]   R5[0x%08lX]   R6[0x%08lX]   R7[0x%08lX]\n",$r4,$r5,$r6,$r7 
+  printf " R8[0x%08lX]   R9[0x%08lX]  R10[0x%08lX]  R11[0x%08lX]\n",$r8,$r9,$r10,$r11 
+  printf "R12[0x%08lX]   FP[0x%08lX]   LR[0x%08lX]   SP[0x%08lX]\n",$r12,$fp,$lr,$fp
+  printf "PSW[0x%08lX]  CBR[0x%08lX]  SPI[0x%08lX]  SPU[0x%08lX]\n",$psw,$cbr,$spi,$spu
+  printf "BPC[0x%08lX]   PC[0x%08lX] ACCL[0x%08lX] ACCH[0x%08lX]\n",$bpc,$pc,$accl,$acch
+  printf "EVB[0x%08lX]\n",$evb
+end
+
+
+# Setup all
+define setup
+  use_mon_code
+  set *(unsigned int)0xfffffffc=0x60
+  shell sleep 0.1
+#  clock_init_on_1411
+  clock_init_on_1421
+#  clock_init_on_1821
+#  clock_init_on_1841
+#  clock_init_on_11681
+#  clock_init_off
+  shell sleep 0.1
+  port_init
+  sdram_init
+  lanc_init
+  dispc_init
+  set $evb=0x08000000
+end
+
+# Load modules
+define load_modules
+  use_debug_dma
+  load
+#  load ramdisk_082a0000.mot
+#  load romfs_082a0000.mot
+#  use_mon_code
+end
+
+# Set kernel parameters
+define set_kernel_parameters
+  set $param = (void*)0x08002000
+  # INITRD_START
+# set *(unsigned long *)($param + 0x0010) = 0x082a0000
+  # INITRD_SIZE
+  set *(unsigned long *)($param + 0x0014) = 0x00000000
+  # M32R_CPUCLK
+  set *(unsigned long *)($param + 0x0018) = 0d160000000
+#  set *(unsigned long *)($param + 0x0018) = 0d80000000
+#  set *(unsigned long *)($param + 0x0018) = 0d40000000
+  # M32R_BUSCLK
+  set *(unsigned long *)($param + 0x001c) = 0d40000000
+
+  # M32R_TIMER_DIVIDE
+  set *(unsigned long *)($param + 0x0020) = 0d128
+
+  set {char[0x200]}($param + 0x100) = "console=tty1 console=ttyD0,115200n8x root=/dev/nfsroot nfsroot=192.168.0.1:/project/m32r-linux/export/root.x nfsaddrs=192.168.0.101:192.168.0.1:192.168.0.1:255.255.255.0:mappi001 \0"
+#  set {char[0x200]}($param + 0x100) = "console=tty1 root=/dev/nfsroot nfsroot=192.168.0.1:/project/m32r-linux/export/root.x nfsaddrs=192.168.0.101:192.168.0.1:192.168.0.1:255.255.255.0:mappi001 \0"
+end
+
+# Boot
+define boot
+  set_kernel_parameters
+  set $pc=0x08001000
+  set *(unsigned char *)0x08001003=0x03
+  si
+  c
+end
+
+# Set breakpoints
+define set_breakpoints
+  b *0x08000030
+end
+
+## Boot MP
+define boot_mp
+  set_kernel_parameters
+  set *(unsigned long *)0x00f00000 = boot - 0x80000000
+  set *(unsigned long *)0x00eff2f8 = 0x2
+  x 0x00eff2f8
+
+  set $pc=0x08001000
+  si
+  c
+end
+document boot_mp
+  Boot BSP
+end
+
+## Boot UP
+define boot_up
+  set_kernel_parameters
+  set $pc=0x08001000
+  si
+  c
+end
+document boot_up
+  Boot BSP
+end
+
+# Restart
+define restart
+  sdireset
+  sdireset
+  setup
+  load_modules
+  boot_mp
+end
+
+sdireset
+sdireset
+file vmlinux
+target m32rsdi
+setup
diff -ruN linux-2.6.7.org/arch/m32r/mm/Makefile linux-2.6.7/arch/m32r/mm/Makefile
--- linux-2.6.7.org/arch/m32r/mm/Makefile	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/mm/Makefile	2004-07-27 16:06:56.000000000 +0900
@@ -0,0 +1,12 @@
+#
+# Makefile for the Linux M32R-specific parts of the memory manager.
+#
+
+ifdef CONFIG_MMU
+obj-y	:= init.o fault.o mmu.o extable.o ioremap.o cache.o page.o
+else
+obj-y 	:= init.o fault-nommu.o mmu.o extable.o ioremap-nommu.o cache.o page.o
+endif
+
+obj-$(CONFIG_DISCONTIGMEM)	+= discontig.o
+
diff -ruN linux-2.6.7.org/arch/m32r/mm/cache.c linux-2.6.7/arch/m32r/mm/cache.c
--- linux-2.6.7.org/arch/m32r/mm/cache.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/mm/cache.c	2004-06-07 15:43:13.000000000 +0900
@@ -0,0 +1,68 @@
+/*
+ *  linux/arch/m32r/mm/cache.c
+ *
+ *  Copyright (C) 2002  Hirokazu Takata
+ */
+
+/* $Id$ */
+
+#include <linux/config.h>
+#include <asm/pgtable.h>
+
+#undef MCCR
+
+#if defined(CONFIG_CHIP_XNUX2) || defined(CONFIG_CHIP_M32700) || defined(CONFIG_CHIP_VDEC2) || defined(CONFIG_CHIP_OPSP)
+/* Cache Control Register */
+#define MCCR		((volatile unsigned long*)0xfffffffc)
+#define MCCR_CC		(1UL << 7)	/* Cache mode modify bit */
+#define MCCR_IIV	(1UL << 6)	/* I-cache invalidate */
+#define MCCR_DIV	(1UL << 5)	/* D-cache invalidate */
+#define MCCR_DCB	(1UL << 4)	/* D-cache copy back */
+#define MCCR_ICM	(1UL << 1)	/* I-cache mode [0:off,1:on] */
+#define MCCR_DCM	(1UL << 0)	/* D-cache mode [0:off,1:on] */
+#define MCCR_ICACHE_INV		(MCCR_CC|MCCR_IIV)
+#define MCCR_DCACHE_CB		(MCCR_CC|MCCR_DCB)
+#define MCCR_DCACHE_CBINV	(MCCR_CC|MCCR_DIV|MCCR_DCB)
+#define CHECK_MCCR(mccr)	(mccr = *MCCR)
+#elif defined(CONFIG_CHIP_M32102)
+#define MCCR		((volatile unsigned long*)0xfffffffc)
+#define MCCR_IIV	(1UL << 8)	/* I-cache invalidate */
+#define MCCR_ICACHE_INV		MCCR_IIV
+#endif /* CONFIG_CHIP_XNUX2 || CONFIG_CHIP_M32700 */
+
+#ifndef MCCR
+#error Unknown cache type.
+#endif
+
+
+/* Copy back and invalidate D-cache and invalidate I-cache all */
+void _flush_cache_all(void)
+{
+#if defined(CONFIG_CHIP_M32102)
+	*MCCR = MCCR_ICACHE_INV;
+#else
+	unsigned long mccr;
+
+	/* Copyback and invalidate D-cache */
+	/* Invalidate I-cache */
+	*MCCR = MCCR_ICACHE_INV | MCCR_DCACHE_CBINV;
+	while ((mccr = *MCCR) & MCCR_IIV); /* loop while invalidating... */
+#endif
+}
+
+/* Copy back D-cache and invalidate I-cache all */
+void _flush_cache_copyback_all(void)
+{
+#if defined(CONFIG_CHIP_M32102)
+	*MCCR = MCCR_ICACHE_INV;
+#else
+	unsigned long mccr;
+
+	/* Copyback D-cache */
+	/* Invalidate I-cache */
+	*MCCR = MCCR_ICACHE_INV | MCCR_DCACHE_CB;
+	while ((mccr = *MCCR) & MCCR_IIV); /* loop while invalidating... */
+
+#endif
+}
+
diff -ruN linux-2.6.7.org/arch/m32r/mm/discontig.c linux-2.6.7/arch/m32r/mm/discontig.c
--- linux-2.6.7.org/arch/m32r/mm/discontig.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/mm/discontig.c	2004-07-15 13:43:14.000000000 +0900
@@ -0,0 +1,170 @@
+/*  
+ *  linux/arch/m32r/mm/discontig.c
+ *  
+ *  Discontig memory support
+ *  
+ *  Copyright (c) 2003  Hitoshi Yamamoto
+ */
+
+#include <linux/config.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+#include <linux/mmzone.h>
+#include <linux/initrd.h>
+
+#include <asm/setup.h>
+
+extern char _end[];
+
+struct pglist_data *node_data[MAX_NUMNODES];
+static bootmem_data_t node_bdata[MAX_NUMNODES] __initdata;
+
+pg_data_t m32r_node_data[MAX_NUMNODES];
+
+/* Memory profile */
+typedef struct {
+	unsigned long start_pfn;
+	unsigned long pages;
+	unsigned long holes;
+	unsigned long free_pfn;
+} mem_prof_t;
+static mem_prof_t mem_prof[MAX_NUMNODES];
+
+static void __init mem_prof_init(void)
+{
+	unsigned long start_pfn, holes, free_pfn;
+	const unsigned long zone_alignment = 1UL << (MAX_ORDER - 1);
+	unsigned long ul;
+	mem_prof_t *mp;
+
+	/* Node#0 SDRAM */
+	mp = &mem_prof[0];
+	mp->start_pfn = PFN_UP(CONFIG_MEMORY_START);
+	mp->pages = PFN_DOWN(CONFIG_MEMORY_SIZE);
+	mp->holes = 0;
+	mp->free_pfn = PFN_UP(__pa(_end));
+
+	/* Node#1 internal SRAM */
+	mp = &mem_prof[1];
+	start_pfn = free_pfn = PFN_UP(CONFIG_IRAM_START);
+	holes = 0;
+	if (start_pfn & (zone_alignment - 1)) {
+		ul = zone_alignment;
+		while (start_pfn >= ul)
+			ul += zone_alignment;
+
+		start_pfn = ul - zone_alignment;
+		holes = free_pfn - start_pfn;
+	}
+
+	mp->start_pfn = start_pfn;
+	mp->pages = PFN_DOWN(CONFIG_IRAM_SIZE) + holes;
+	mp->holes = holes;
+	mp->free_pfn = PFN_UP(CONFIG_IRAM_START);
+}
+
+unsigned long __init setup_memory(void)
+{
+	unsigned long bootmap_size;
+	unsigned long min_pfn;
+	int nid;
+	mem_prof_t *mp;
+
+	max_low_pfn = 0;
+	min_low_pfn = -1;
+
+	mem_prof_init();
+
+	for (nid = 0 ; nid < numnodes ; nid++) {
+		mp = &mem_prof[nid];
+		NODE_DATA(nid)=(pg_data_t *)&m32r_node_data[nid];
+		NODE_DATA(nid)->bdata = &node_bdata[nid];
+		min_pfn = mp->start_pfn;
+		max_pfn = mp->start_pfn + mp->pages;
+		bootmap_size = init_bootmem_node(NODE_DATA(nid), mp->free_pfn, 
+			mp->start_pfn, max_pfn);
+
+		free_bootmem_node(NODE_DATA(nid), PFN_PHYS(mp->start_pfn), 
+			PFN_PHYS(mp->pages));
+
+		reserve_bootmem_node(NODE_DATA(nid), PFN_PHYS(mp->start_pfn), 
+			PFN_PHYS(mp->free_pfn - mp->start_pfn) + bootmap_size);
+
+		if (max_low_pfn < max_pfn)
+			max_low_pfn = max_pfn;
+
+		if (min_low_pfn > min_pfn)
+			min_low_pfn = min_pfn;
+	}
+
+#ifdef CONFIG_BLK_DEV_INITRD
+	if (LOADER_TYPE && INITRD_START) {
+		if (INITRD_START + INITRD_SIZE <= PFN_PHYS(max_low_pfn)) {
+			reserve_bootmem_node(NODE_DATA(0), INITRD_START, 
+				INITRD_SIZE);
+			initrd_start = INITRD_START ? 
+				INITRD_START + PAGE_OFFSET : 0;
+
+			initrd_end = initrd_start + INITRD_SIZE;
+			printk("initrd:start[%08lx],size[%08lx]\n", 
+				initrd_start, INITRD_SIZE);
+		} else {
+			printk("initrd extends beyond end of memory "
+				"(0x%08lx > 0x%08lx)\ndisabling initrd\n", 
+				INITRD_START + INITRD_SIZE, 
+				PFN_PHYS(max_low_pfn));
+
+			initrd_start = 0;
+		}
+	}
+#endif	/* CONFIG_BLK_DEV_INITRD */
+
+	return max_low_pfn;
+}
+
+#define START_PFN(nid)	\
+	(NODE_DATA(nid)->bdata->node_boot_start >> PAGE_SHIFT)
+#define MAX_LOW_PFN(nid)	(NODE_DATA(nid)->bdata->node_low_pfn)
+
+unsigned long __init zone_sizes_init(void)
+{
+	unsigned long zones_size[MAX_NR_ZONES], zholes_size[MAX_NR_ZONES];
+	unsigned long low, start_pfn;
+	unsigned long holes = 0;
+	int nid, i;
+	mem_prof_t *mp;
+
+	pgdat_list = NULL;
+	for (nid = numnodes - 1 ; nid >= 0 ; nid--) {
+		NODE_DATA(nid)->pgdat_next = pgdat_list;
+		pgdat_list = NODE_DATA(nid);
+	}
+
+	for (nid = 0 ; nid < numnodes ; nid++) {
+		mp = &mem_prof[nid];
+		for (i = 0 ; i < MAX_NR_ZONES ; i++) {
+			zones_size[i] = 0;
+			zholes_size[i] = 0;
+		}
+		start_pfn = START_PFN(nid);
+		low = MAX_LOW_PFN(nid);
+		zones_size[ZONE_DMA] = low - start_pfn;
+		zholes_size[ZONE_DMA] = mp->holes;
+		holes += zholes_size[ZONE_DMA];
+
+		free_area_init_node(nid, NODE_DATA(nid), NULL, zones_size, 
+			start_pfn, zholes_size);
+	}
+
+	/* 
+	 * For test
+	 *  Use all area of internal RAM.
+	 *  see __alloc_pages()
+	 */
+	NODE_DATA(1)->node_zones->pages_min = 0;
+	NODE_DATA(1)->node_zones->pages_low = 0;
+	NODE_DATA(1)->node_zones->pages_high = 0;
+
+	return holes;
+}
+
diff -ruN linux-2.6.7.org/arch/m32r/mm/extable.c linux-2.6.7/arch/m32r/mm/extable.c
--- linux-2.6.7.org/arch/m32r/mm/extable.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/mm/extable.c	2004-03-25 13:27:25.000000000 +0900
@@ -0,0 +1,22 @@
+/*
+ * linux/arch/i386/mm/extable.c
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <asm/uaccess.h>
+
+int fixup_exception(struct pt_regs *regs)
+{
+	const struct exception_table_entry *fixup;
+
+	fixup = search_exception_tables(regs->bpc);
+	if (fixup) {
+		regs->bpc = fixup->fixup;
+		return 1;
+	}
+
+	return 0;
+}
+
diff -ruN linux-2.6.7.org/arch/m32r/mm/fault-nommu.c linux-2.6.7/arch/m32r/mm/fault-nommu.c
--- linux-2.6.7.org/arch/m32r/mm/fault-nommu.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/mm/fault-nommu.c	2004-03-31 19:36:49.000000000 +0900
@@ -0,0 +1,164 @@
+/*
+ *  linux/arch/m32r/mm/fault.c
+ *
+ *  Copyright (c) 2001, 2002  Hitoshi Yamamoto, and H. Kondo
+ *  
+ *  Some code taken from i386 version.
+ *    Copyright (C) 1995  Linus Torvalds
+ */
+
+/* $Id: fault-nommu.c,v 1.1 2004/03/30 06:40:59 sakugawa Exp $ */
+
+#include <linux/config.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/ptrace.h>
+#include <linux/mman.h>
+#include <linux/mm.h>
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+
+#include <asm/m32r.h>
+#include <asm/system.h>
+#include <asm/uaccess.h>
+#include <asm/pgalloc.h>
+#include <asm/pgtable.h>
+#include <asm/hardirq.h>
+#include <asm/mmu_context.h>
+
+extern void die(const char *, struct pt_regs *, long);
+
+#ifndef CONFIG_SMP
+asmlinkage unsigned int tlb_entry_i_dat;
+asmlinkage unsigned int tlb_entry_d_dat;
+#define tlb_entry_i tlb_entry_i_dat
+#define tlb_entry_d tlb_entry_d_dat
+#else
+unsigned int tlb_entry_i_dat[NR_CPUS];
+unsigned int tlb_entry_d_dat[NR_CPUS];
+#define tlb_entry_i tlb_entry_i_dat[smp_processor_id()]
+#define tlb_entry_d tlb_entry_d_dat[smp_processor_id()]
+#endif
+
+/*
+ * Unlock any spinlocks which will prevent us from getting the
+ * message out
+ */
+void bust_spinlocks(int yes)
+{
+	int loglevel_save = console_loglevel;
+
+	if (yes) {
+		oops_in_progress = 1;
+		return;
+	}
+#ifdef CONFIG_VT
+	unblank_screen();
+#endif
+	oops_in_progress = 0;
+	/*
+	 * OK, the message is on the console.  Now we call printk()
+	 * without oops_in_progress set so that printk will give klogd
+	 * a poke.  Hold onto your hats...
+	 */
+	console_loglevel = 15;		/* NMI oopser may have shut the console up */
+	printk(" ");
+	console_loglevel = loglevel_save;
+}
+
+void do_BUG(const char *file, int line)
+{
+	bust_spinlocks(1);
+	printk("kernel BUG at %s:%d!\n", file, line);
+}
+
+/*======================================================================*
+ * do_page_fault()
+ *======================================================================*
+ * This routine handles page faults.  It determines the address,
+ * and the problem, and then passes it off to one of the appropriate
+ * routines.
+ * 
+ * ARGUMENT: 
+ *  regs       : M32R SP reg.
+ *  error_code : See below
+ *  address    : M32R MMU MDEVA reg. (Operand ACE)
+ *             : M32R BPC reg. (Instruction ACE)
+ * 
+ * error_code :
+ *  bit 0 == 0 means no page found, 1 means protection fault
+ *  bit 1 == 0 means read, 1 means write
+ *  bit 2 == 0 means kernel, 1 means user-mode
+ *======================================================================*/
+asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long error_code, 
+  unsigned long address)
+{
+
+/*
+ * Oops. The kernel tried to access some bad page. We'll have to
+ * terminate things with extreme prejudice.
+ */
+
+	bust_spinlocks(1);
+
+	if (address < PAGE_SIZE)
+		printk(KERN_ALERT "Unable to handle kernel NULL pointer dereference");
+	else
+		printk(KERN_ALERT "Unable to handle kernel paging request");
+	printk(" at virtual address %08lx\n",address);
+	printk(" printing bpc:\n");
+	printk(KERN_ALERT "bpc = %08lx\n", regs->bpc);
+
+	die("Oops", regs, error_code);
+	bust_spinlocks(0);
+	do_exit(SIGKILL);
+}
+
+/*======================================================================*
+ * update_mmu_cache()
+ *======================================================================*/
+void update_mmu_cache(struct vm_area_struct *vma, unsigned long addr, 
+	pte_t pte)
+{
+	BUG();
+}
+
+/*======================================================================*
+ * flush_tlb_page() : flushes one page
+ *======================================================================*/
+void local_flush_tlb_page(struct vm_area_struct *vma, unsigned long page)
+{
+	BUG();
+}
+
+/*======================================================================*
+ * flush_tlb_range() : flushes a range of pages
+ *======================================================================*/
+void local_flush_tlb_range(struct vm_area_struct *vma, unsigned long start, 
+	unsigned long end)
+{
+	BUG();
+}
+
+/*======================================================================*
+ * flush_tlb_mm() : flushes the specified mm context TLB's
+ *======================================================================*/
+void local_flush_tlb_mm(struct mm_struct *mm)
+{
+	BUG();
+}
+
+/*======================================================================*
+ * flush_tlb_all() : flushes all processes TLBs
+ *======================================================================*/
+void local_flush_tlb_all(void)
+{
+	BUG();
+}
+
diff -ruN linux-2.6.7.org/arch/m32r/mm/fault.c linux-2.6.7/arch/m32r/mm/fault.c
--- linux-2.6.7.org/arch/m32r/mm/fault.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/mm/fault.c	2004-07-27 15:54:20.000000000 +0900
@@ -0,0 +1,553 @@
+/*
+ *  linux/arch/m32r/mm/fault.c
+ *
+ *  Copyright (c) 2001, 2002  Hitoshi Yamamoto, and H. Kondo
+ *  
+ *  Some code taken from i386 version.
+ *    Copyright (C) 1995  Linus Torvalds
+ */
+
+/* $Id$ */
+
+#include <linux/config.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/ptrace.h>
+#include <linux/mman.h>
+#include <linux/mm.h>
+#include <linux/smp.h>
+#include <linux/smp_lock.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/tty.h>
+#include <linux/vt_kern.h>		/* For unblank_screen() */
+#include <linux/highmem.h>
+#include <linux/module.h>
+
+#include <asm/m32r.h>
+#include <asm/system.h>
+#include <asm/uaccess.h>
+#include <asm/pgalloc.h>
+#include <asm/hardirq.h>
+#include <asm/mmu_context.h>
+#include <asm/tlbflush.h>
+
+extern void die(const char *, struct pt_regs *, long);
+
+#ifndef CONFIG_SMP
+asmlinkage unsigned int tlb_entry_i_dat;
+asmlinkage unsigned int tlb_entry_d_dat;
+#define tlb_entry_i tlb_entry_i_dat
+#define tlb_entry_d tlb_entry_d_dat
+#else
+unsigned int tlb_entry_i_dat[NR_CPUS];
+unsigned int tlb_entry_d_dat[NR_CPUS];
+#define tlb_entry_i tlb_entry_i_dat[smp_processor_id()]
+#define tlb_entry_d tlb_entry_d_dat[smp_processor_id()]
+#endif
+
+extern void init_tlb(void);
+
+/*
+ * Unlock any spinlocks which will prevent us from getting the
+ * message out
+ */
+void bust_spinlocks(int yes)
+{
+	int loglevel_save = console_loglevel;
+
+	if (yes) {
+		oops_in_progress = 1;
+		return;
+	}
+#ifdef CONFIG_VT
+	unblank_screen();
+#endif
+	oops_in_progress = 0;
+	/*
+	 * OK, the message is on the console.  Now we call printk()
+	 * without oops_in_progress set so that printk will give klogd
+	 * a poke.  Hold onto your hats...
+	 */
+	console_loglevel = 15;		/* NMI oopser may have shut the console up */
+	printk(" ");
+	console_loglevel = loglevel_save;
+}
+
+/*======================================================================*
+ * do_page_fault()
+ *======================================================================*
+ * This routine handles page faults.  It determines the address,
+ * and the problem, and then passes it off to one of the appropriate
+ * routines.
+ * 
+ * ARGUMENT: 
+ *  regs       : M32R SP reg.
+ *  error_code : See below
+ *  address    : M32R MMU MDEVA reg. (Operand ACE)
+ *             : M32R BPC reg. (Instruction ACE)
+ * 
+ * error_code :
+ *  bit 0 == 0 means no page found, 1 means protection fault
+ *  bit 1 == 0 means read, 1 means write
+ *  bit 2 == 0 means kernel, 1 means user-mode
+ *  bit 3 == 0 means data, 1 means instruction
+ *======================================================================*/
+asmlinkage void do_page_fault(struct pt_regs *regs, unsigned long error_code, 
+  unsigned long address)
+{
+	struct task_struct *tsk;
+	struct mm_struct *mm;
+	struct vm_area_struct * vma;
+	unsigned long page, addr;
+	int write;
+	siginfo_t info;
+
+	/* 
+	 * If BPSW IE bit enable --> set PSW IE bit
+	 */
+	if (regs->psw & M32R_PSW_BIE)
+		local_irq_enable();
+
+	tsk = current;
+
+	info.si_code = SEGV_MAPERR;
+
+	/*
+	 * We fault-in kernel-space virtual memory on-demand. The
+	 * 'reference' page table is init_mm.pgd.
+	 *
+	 * NOTE! We MUST NOT take any locks for this case. We may
+	 * be in an interrupt or a critical region, and should
+	 * only copy the information from the master page table,
+	 * nothing more.
+	 *
+	 * This verifies that the fault happens in kernel space
+	 * (error_code & 4) == 0, and that the fault was not a
+	 * protection error (error_code & 1) == 0.
+	 */
+	if (address >= TASK_SIZE && !(error_code & 4))
+		goto vmalloc_fault;
+
+	mm = tsk->mm;
+
+	/*
+	 * If we're in an interrupt or have no user context or are running in an
+	 * atomic region then we must not take the fault..
+	 */
+	if (in_atomic() || !mm)
+		goto bad_area_nosemaphore;
+
+	down_read(&mm->mmap_sem);
+
+	vma = find_vma(mm, address);
+	if (!vma)
+		goto bad_area;
+	if (vma->vm_start <= address)
+		goto good_area;
+	if (!(vma->vm_flags & VM_GROWSDOWN))
+		goto bad_area;
+#if 0
+	if (error_code & 4) {
+		/*
+		 * accessing the stack below "spu" is always a bug.
+		 * The "+ 4" is there due to the push instruction
+		 * doing pre-decrement on the stack and that
+		 * doesn't show up until later..
+		 */
+		if (address + 4 < regs->spu) 
+			goto bad_area;
+	}
+#endif
+	if (expand_stack(vma, address))
+		goto bad_area;
+/*
+ * Ok, we have a good vm_area for this memory access, so
+ * we can handle it..
+ */
+good_area:
+	info.si_code = SEGV_ACCERR;
+	write = 0;
+	switch (error_code & 3) {
+		default:	/* 3: write, present */
+			/* fall through */
+		case 2:		/* write, not present */
+			if (!(vma->vm_flags & VM_WRITE))
+				goto bad_area;
+			write++;
+			break;
+		case 1:		/* read, present */
+		case 0:		/* read, not present */
+			if (!(vma->vm_flags & (VM_READ | VM_EXEC)))
+				goto bad_area;
+	}
+
+survive:
+	/*
+	 * If for any reason at all we couldn't handle the fault,
+	 * make sure we exit gracefully rather than endlessly redo
+	 * the fault.
+	 */
+	addr = (address & PAGE_MASK) | (error_code & 8);
+	switch (handle_mm_fault(mm, vma, addr, write)) {
+		case VM_FAULT_MINOR:
+			tsk->min_flt++;
+			break;
+		case VM_FAULT_MAJOR:
+			tsk->maj_flt++;
+			break;
+		case VM_FAULT_SIGBUS:
+			goto do_sigbus;
+		case VM_FAULT_OOM:
+			goto out_of_memory;
+		default:
+			BUG();
+	}
+
+	up_read(&mm->mmap_sem);
+	return;
+
+/*
+ * Something tried to access memory that isn't in our memory map..
+ * Fix it, but check if it's kernel or user first..
+ */
+bad_area:
+	up_read(&mm->mmap_sem);
+
+bad_area_nosemaphore:
+	/* User mode accesses just cause a SIGSEGV */
+	if (error_code & 4) {
+		tsk->thread.address = address;
+		tsk->thread.error_code = error_code | (address >= TASK_SIZE);
+		tsk->thread.trap_no = 14;
+		info.si_signo = SIGSEGV;
+		info.si_errno = 0;
+		/* info.si_code has been set above */
+		info.si_addr = (void *)address;
+		force_sig_info(SIGSEGV, &info, tsk);
+		return;
+	}
+
+no_context:
+	/* Are we prepared to handle this kernel fault?  */
+	if (fixup_exception(regs))
+		return;
+
+/*
+ * Oops. The kernel tried to access some bad page. We'll have to
+ * terminate things with extreme prejudice.
+ */
+
+	bust_spinlocks(1);
+
+	if (address < PAGE_SIZE)
+		printk(KERN_ALERT "Unable to handle kernel NULL pointer dereference");
+	else
+		printk(KERN_ALERT "Unable to handle kernel paging request");
+	printk(" at virtual address %08lx\n",address);
+	printk(KERN_ALERT " printing bpc:\n");
+	printk("%08lx\n", regs->bpc);
+	page = *(unsigned long *)MPTB;
+	page = ((unsigned long *) page)[address >> PGDIR_SHIFT];
+	printk(KERN_ALERT "*pde = %08lx\n", page);
+	if (page & _PAGE_PRESENT) {
+		page &= PAGE_MASK;
+		address &= 0x003ff000;
+		page = ((unsigned long *) __va(page))[address >> PAGE_SHIFT];
+		printk(KERN_ALERT "*pte = %08lx\n", page);
+	}
+	die("Oops", regs, error_code);
+	bust_spinlocks(0);
+	do_exit(SIGKILL);
+
+/*
+ * We ran out of memory, or some other thing happened to us that made
+ * us unable to handle the page fault gracefully.
+ */
+out_of_memory:
+	up_read(&mm->mmap_sem);
+	if (tsk->pid == 1) {
+		yield();
+		down_read(&mm->mmap_sem);
+		goto survive;
+	}
+	printk("VM: killing process %s\n", tsk->comm);
+	if (error_code & 4)
+		do_exit(SIGKILL);
+	goto no_context;
+
+do_sigbus:
+	up_read(&mm->mmap_sem);
+
+	/* Kernel mode? Handle exception or die */
+	if (!(error_code & 4))
+		goto no_context;
+
+	tsk->thread.address = address;
+	tsk->thread.error_code = error_code;
+	tsk->thread.trap_no = 14;
+	info.si_signo = SIGBUS;
+	info.si_errno = 0;
+	info.si_code = BUS_ADRERR;
+	info.si_addr = (void *)address;
+	force_sig_info(SIGBUS, &info, tsk);
+	return;
+
+vmalloc_fault:
+	{
+		/*
+		 * Synchronize this task's top level page-table
+		 * with the 'reference' page table.
+		 *
+		 * Do _not_ use "tsk" here. We might be inside
+		 * an interrupt in the middle of a task switch..
+		 */
+		int offset = pgd_index(address);
+		pgd_t *pgd, *pgd_k;
+		pmd_t *pmd, *pmd_k;
+		pte_t *pte_k;
+
+		pgd = (pgd_t *)*(unsigned long *)MPTB;
+		pgd = offset + (pgd_t *)pgd;
+		pgd_k = init_mm.pgd + offset;
+
+		if (!pgd_present(*pgd_k))
+			goto no_context;
+		
+		/*
+		 * set_pgd(pgd, *pgd_k); here would be useless on PAE
+		 * and redundant with the set_pmd() on non-PAE.
+		 */
+		
+		pmd = pmd_offset(pgd, address);
+		pmd_k = pmd_offset(pgd_k, address);
+		if (!pmd_present(*pmd_k))
+			goto no_context;
+		set_pmd(pmd, *pmd_k);
+
+		pte_k = pte_offset_kernel(pmd_k, address);
+		if (!pte_present(*pte_k))
+			goto no_context;
+
+		addr = (address & PAGE_MASK) | (error_code & 8);
+		update_mmu_cache(NULL, addr, *pte_k);
+		return;
+	}
+}
+
+/*======================================================================*
+ * update_mmu_cache()
+ *======================================================================*/
+#define TLB_MASK	(NR_TLB_ENTRIES - 1)
+#define ITLB_END	(unsigned long *)(ITLB_BASE + (NR_TLB_ENTRIES * 8))
+#define DTLB_END	(unsigned long *)(DTLB_BASE + (NR_TLB_ENTRIES * 8))
+void update_mmu_cache(struct vm_area_struct *vma, unsigned long vaddr,
+	pte_t pte)
+{
+	unsigned long *entry1, *entry2;
+	unsigned long pte_data, flags;
+	unsigned int *entry_dat;
+	int inst = vaddr & 8;
+	int i;
+
+	/* Ptrace may call this routine. */
+	if (vma && current->active_mm != vma->vm_mm)
+		return;
+
+	local_irq_save(flags);
+
+	vaddr = (vaddr & PAGE_MASK) | get_asid();
+
+#ifdef CONFIG_CHIP_OPSP
+	entry1 = (unsigned long *)ITLB_BASE;
+        for(i = 0 ; i < NR_TLB_ENTRIES; i++) {
+                if(*entry1++ == vaddr) {
+                        pte_data = pte_val(pte);
+                        set_tlb_data(entry1, pte_data);
+                        break;
+                }
+                entry1++;
+        }
+        entry2 = (unsigned long *)DTLB_BASE;
+        for(i = 0 ; i < NR_TLB_ENTRIES ; i++) {
+                if(*entry2++ == vaddr) {
+                        pte_data = pte_val(pte);
+                        set_tlb_data(entry2, pte_data);
+                        break;
+                }
+                entry2++;
+        }
+        local_irq_restore(flags);
+	return;
+#else
+	pte_data = pte_val(pte);
+
+	/*
+	 * Update TLB entries
+	 *  entry1: ITLB entry address
+	 *  entry2: DTLB entry address
+	 */
+	__asm__ __volatile__ (
+		"seth	%0, #high(%4)	\n\t"
+		"st	%2, @(%5, %0)	\n\t"
+		"ldi	%1, #1		\n\t"
+		"st	%1, @(%6, %0)	\n\t"
+		"add3	r4, %0, %7	\n\t"
+		".fillinsn		\n"
+		"1:			\n\t"
+		"ld	%1, @(%6, %0)	\n\t"
+		"bnez	%1, 1b		\n\t"
+		"ld	%0, @r4+	\n\t"
+		"ld	%1, @r4		\n\t"
+		"st	%3, @+%0	\n\t"
+		"st	%3, @+%1	\n\t"
+		: "=&r" (entry1), "=&r" (entry2)
+		: "r" (vaddr), "r" (pte_data), "i" (MMU_REG_BASE),
+		"i" (MSVA_offset), "i" (MTOP_offset), "i" (MIDXI_offset)
+		: "r4", "memory"
+	);
+
+	if ((!inst && entry2 >= DTLB_END) || (inst && entry1 >= ITLB_END))
+		goto notfound;
+
+found:
+	local_irq_restore(flags);
+
+	return;
+
+	/* Valid entry not found */
+notfound:
+	/*
+	 * Update ITLB or DTLB entry
+	 *  entry1: TLB entry address
+	 *  entry2: TLB base address
+	 */
+	if (!inst) {
+		entry2 = (unsigned long *)DTLB_BASE;
+		entry_dat = &tlb_entry_d;
+	} else {
+		entry2 = (unsigned long *)ITLB_BASE;
+		entry_dat = &tlb_entry_i;
+	}
+	entry1 = entry2 + (((*entry_dat - 1) & TLB_MASK) << 1);
+
+	for (i = 0 ; i < NR_TLB_ENTRIES ; i++) {
+		if (!(entry1[1] & 2))	/* Valid bit check */
+			break;
+
+		if (entry1 != entry2)
+			entry1 -= 2;
+		else
+			entry1 += TLB_MASK << 1;
+	}
+
+	if (i >= NR_TLB_ENTRIES) {	/* Empty entry not found */
+		entry1 = entry2 + (*entry_dat << 1);
+		*entry_dat = (*entry_dat + 1) & TLB_MASK;
+	}
+	*entry1++ = vaddr;	/* Set TLB tag */
+	set_tlb_data(entry1, pte_data);
+
+	goto found;
+#endif
+}
+
+/*======================================================================*
+ * flush_tlb_page() : flushes one page
+ *======================================================================*/
+void local_flush_tlb_page(struct vm_area_struct *vma, unsigned long page)
+{
+	if (vma->vm_mm && mm_context(vma->vm_mm) != NO_CONTEXT) {
+		unsigned long flags;
+
+		local_irq_save(flags);
+		page &= PAGE_MASK;
+		page |= (mm_context(vma->vm_mm) & MMU_CONTEXT_ASID_MASK);
+		__flush_tlb_page(page);
+		local_irq_restore(flags);
+	}
+}
+
+/*======================================================================*
+ * flush_tlb_range() : flushes a range of pages
+ *======================================================================*/
+void local_flush_tlb_range(struct vm_area_struct *vma, unsigned long start, 
+	unsigned long end)
+{
+	struct mm_struct *mm;
+
+	mm = vma->vm_mm;
+	if (mm_context(mm) != NO_CONTEXT) {
+		unsigned long flags;
+		int size;
+
+		local_irq_save(flags);
+		size = (end - start + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
+		if (size > (NR_TLB_ENTRIES / 4)) { /* Too many TLB to flush */
+			mm_context(mm) = NO_CONTEXT;
+			if (mm == current->mm)
+				activate_context(mm);
+		} else {
+			unsigned long asid;
+
+			asid = mm_context(mm) & MMU_CONTEXT_ASID_MASK;
+			start &= PAGE_MASK;
+			end += (PAGE_SIZE - 1);
+			end &= PAGE_MASK;
+
+			start |= asid;
+			end   |= asid;
+			while (start < end) {
+				__flush_tlb_page(start);
+				start += PAGE_SIZE;
+			}
+		}
+		local_irq_restore(flags);
+	}
+}
+
+/*======================================================================*
+ * flush_tlb_mm() : flushes the specified mm context TLB's
+ *======================================================================*/
+void local_flush_tlb_mm(struct mm_struct *mm)
+{
+	/* Invalidate all TLB of this process. */
+	/* Instead of invalidating each TLB, we get new MMU context. */
+	if (mm_context(mm) != NO_CONTEXT) {
+		unsigned long flags;
+
+		local_irq_save(flags);
+		mm_context(mm) = NO_CONTEXT;
+		if (mm == current->mm)
+			activate_context(mm);
+		local_irq_restore(flags);
+	}
+}
+
+/*======================================================================*
+ * flush_tlb_all() : flushes all processes TLBs
+ *======================================================================*/
+void local_flush_tlb_all(void)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	__flush_tlb_all();
+	local_irq_restore(flags);
+}
+
+/*======================================================================*
+ * init_mmu()
+ *======================================================================*/
+void __init init_mmu(void)
+{
+	tlb_entry_i = 0;
+	tlb_entry_d = 0;
+	mmu_context_cache = MMU_CONTEXT_FIRST_VERSION;
+	set_asid(mmu_context_cache & MMU_CONTEXT_ASID_MASK);
+	*(volatile unsigned long *)MPTB = (unsigned long)swapper_pg_dir;
+}
diff -ruN linux-2.6.7.org/arch/m32r/mm/init.c linux-2.6.7/arch/m32r/mm/init.c
--- linux-2.6.7.org/arch/m32r/mm/init.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/mm/init.c	2004-07-08 17:44:48.000000000 +0900
@@ -0,0 +1,251 @@
+/*  
+ *  linux/arch/m32r/mm/init.c
+ *  
+ *  Copyright (c) 2001, 2002  Hitoshi Yamamoto
+ *  
+ *  Some code taken from sh version.
+ *    Copyright (C) 1999  Niibe Yutaka
+ *    Based on linux/arch/i386/mm/init.c:
+ *      Copyright (C) 1995  Linus Torvalds
+ */
+
+/* $Id$ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/pagemap.h>
+#include <linux/bootmem.h>
+#include <linux/swap.h>
+#include <linux/highmem.h>
+#include <asm/types.h>
+#include <asm/processor.h>
+#include <asm/bitops.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/pgalloc.h>
+#include <asm/mmu_context.h>
+#include <asm/setup.h>
+#include <asm/tlb.h>
+
+/* References to section boundaries */
+extern char _text, _etext, _edata;
+extern char __init_begin, __init_end;
+
+pgd_t swapper_pg_dir[1024];
+
+DEFINE_PER_CPU(struct mmu_gather, mmu_gathers);
+
+void show_mem(void)
+{
+	int total = 0, reserved = 0;
+	int shared = 0, cached = 0;
+	int highmem = 0;
+	struct page *page;
+	pg_data_t *pgdat;
+	unsigned long i;
+
+	printk("Mem-info:\n");
+	show_free_areas();
+	printk("Free swap:       %6dkB\n",nr_swap_pages<<(PAGE_SHIFT-10));
+	for_each_pgdat(pgdat) {
+		for (i = 0; i < pgdat->node_spanned_pages; ++i) {
+			page = pgdat->node_mem_map + i;
+			total++;
+			if (PageHighMem(page))
+				highmem++;
+			if (PageReserved(page))
+				reserved++;
+			else if (PageSwapCache(page))
+				cached++;
+			else if (page_count(page))
+				shared += page_count(page) - 1;
+		}
+	}
+	printk("%d pages of RAM\n", total);
+	printk("%d pages of HIGHMEM\n",highmem);
+	printk("%d reserved pages\n",reserved);
+	printk("%d pages shared\n",shared);
+	printk("%d pages swap cached\n",cached);
+}
+
+/* 
+ * Cache of MMU context last used.
+ */
+#ifndef CONFIG_SMP
+unsigned long mmu_context_cache_dat;
+#else
+unsigned long mmu_context_cache_dat[NR_CPUS];
+#endif
+static unsigned long hole_pages;
+
+/* 
+ * function prototype
+ */
+void __init paging_init(void);
+void __init mem_init(void);
+void free_initmem(void);
+#ifdef CONFIG_BLK_DEV_INITRD
+void free_initrd_mem(unsigned long, unsigned long);
+#endif
+
+/* It'd be good if these lines were in the standard header file. */
+#define START_PFN(nid)	\
+	(NODE_DATA(nid)->bdata->node_boot_start >> PAGE_SHIFT)
+#define MAX_LOW_PFN(nid)	(NODE_DATA(nid)->bdata->node_low_pfn)
+
+#ifndef CONFIG_DISCONTIGMEM
+unsigned long __init zone_sizes_init(void)
+{
+	unsigned long  zones_size[MAX_NR_ZONES] = {0, 0, 0};
+	unsigned long  max_dma;
+	unsigned long  low;
+	unsigned long  start_pfn;
+
+#ifdef CONFIG_MMU
+	start_pfn = START_PFN(0);
+	max_dma = virt_to_phys((char *)MAX_DMA_ADDRESS) >> PAGE_SHIFT;
+	low = MAX_LOW_PFN(0);
+
+	if (low < max_dma){
+		zones_size[ZONE_DMA] = low - start_pfn;
+		zones_size[ZONE_NORMAL] = 0;
+	} else {
+		zones_size[ZONE_DMA] = low - start_pfn;
+		zones_size[ZONE_NORMAL] = low - max_dma;
+	}
+#else
+        zones_size[ZONE_DMA] = 0 >> PAGE_SHIFT;
+        zones_size[ZONE_NORMAL] = __MEMORY_SIZE >> PAGE_SHIFT;
+        start_pfn = __MEMORY_START >> PAGE_SHIFT;
+#endif /* CONFIG_MMU */
+
+	free_area_init_node(0, NODE_DATA(0), 0, zones_size, 
+		start_pfn, 0);
+
+	mem_map = contig_page_data.node_mem_map;
+
+	return 0;
+}
+#else	/* CONFIG_DISCONTIGMEM */
+extern unsigned long zone_sizes_init(void);
+#endif	/* CONFIG_DISCONTIGMEM */
+
+/*======================================================================*
+ * paging_init() : sets up the page tables
+ *======================================================================*/
+void __init paging_init(void)
+{
+#ifdef CONFIG_MMU
+	int  i;
+	pgd_t *pg_dir;
+
+	/* We don't need kernel mapping as hardware support that. */
+	pg_dir = swapper_pg_dir;
+
+	for (i = 0 ; i < USER_PTRS_PER_PGD * 2 ; i++)
+		pgd_val(pg_dir[i]) = 0;
+#endif /* CONFIG_MMU */
+	hole_pages = zone_sizes_init();
+}
+
+int __init reservedpages_count(void)
+{
+	int reservedpages, nid, i;
+
+	reservedpages = 0;
+	for (nid = 0 ; nid < numnodes ; nid++)
+		for (i = 0 ; i < MAX_LOW_PFN(nid) - START_PFN(nid) ; i++)
+			if (PageReserved(NODE_DATA(nid)->node_mem_map + i))
+				reservedpages++;
+
+	return reservedpages;
+}
+
+/*======================================================================*
+ * mem_init() : 
+ * orig : arch/sh/mm/init.c
+ *======================================================================*/
+void __init mem_init(void)
+{
+	int codesize, reservedpages, datasize, initsize;
+	int nid;
+#ifndef CONFIG_MMU
+        extern unsigned long memory_end;
+#endif
+
+	num_physpages = 0;
+	for (nid = 0 ; nid < numnodes ; nid++)
+		num_physpages += MAX_LOW_PFN(nid) - START_PFN(nid) + 1;
+
+	num_physpages -= hole_pages;
+
+#ifndef CONFIG_DISCONTIGMEM
+	max_mapnr = num_physpages;
+#endif	/* CONFIG_DISCONTIGMEM */
+
+#ifdef CONFIG_MMU
+	high_memory = (void *)__va(PFN_PHYS(MAX_LOW_PFN(0)));
+#else
+        high_memory = (void *)(memory_end & PAGE_MASK);
+#endif /* CONFIG_MMU */
+
+	/* clear the zero-page */
+	memset(empty_zero_page, 0, PAGE_SIZE);
+
+	/* this will put all low memory onto the freelists */
+	for (nid = 0 ; nid < numnodes ; nid++)
+		totalram_pages += free_all_bootmem_node(NODE_DATA(nid));
+
+	reservedpages = reservedpages_count() - hole_pages;
+	codesize = (unsigned long) &_etext - (unsigned long)&_text;
+	datasize = (unsigned long) &_edata - (unsigned long)&_etext;
+	initsize = (unsigned long) &__init_end - (unsigned long)&__init_begin;
+
+	printk(KERN_INFO "Memory: %luk/%luk available (%dk kernel code, "
+		"%dk reserved, %dk data, %dk init)\n",
+		(unsigned long) nr_free_pages() << (PAGE_SHIFT-10),
+		num_physpages << (PAGE_SHIFT-10),
+		codesize >> 10,
+		reservedpages << (PAGE_SHIFT-10),
+		datasize >> 10,
+		initsize >> 10);
+}
+
+/*======================================================================*
+ * free_initmem() : 
+ * orig : arch/sh/mm/init.c
+ *======================================================================*/
+void free_initmem(void)
+{
+	unsigned long addr;
+	
+	addr = (unsigned long)(&__init_begin);
+	for (; addr < (unsigned long)(&__init_end); addr += PAGE_SIZE) {
+		ClearPageReserved(virt_to_page(addr));
+		set_page_count(virt_to_page(addr), 1);
+		free_page(addr);
+		totalram_pages++;
+	}
+	printk (KERN_INFO "Freeing unused kernel memory: %dk freed\n", \
+	  (int)(&__init_end - &__init_begin) >> 10);
+}
+
+#ifdef CONFIG_BLK_DEV_INITRD
+/*======================================================================*
+ * free_initrd_mem() : 
+ * orig : arch/sh/mm/init.c
+ *======================================================================*/
+void free_initrd_mem(unsigned long start, unsigned long end)
+{
+	unsigned long p;
+	for (p = start; p < end; p += PAGE_SIZE) {
+		ClearPageReserved(virt_to_page(p));
+		set_page_count(virt_to_page(p), 1);
+		free_page(p);
+		totalram_pages++;
+	}
+	printk (KERN_INFO "Freeing initrd memory: %ldk freed\n", (end - start) >> 10);
+}
+#endif
+
diff -ruN linux-2.6.7.org/arch/m32r/mm/ioremap-nommu.c linux-2.6.7/arch/m32r/mm/ioremap-nommu.c
--- linux-2.6.7.org/arch/m32r/mm/ioremap-nommu.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/mm/ioremap-nommu.c	2004-03-30 15:40:59.000000000 +0900
@@ -0,0 +1,51 @@
+/*  
+ *  linux/arch/m32r/mm/io_remap.c
+ *  
+ *  Copyright (c) 2001, 2002  Hiroyuki Kondo
+ *  
+ *  Taken from mips version.
+ *    (C) Copyright 1995 1996 Linus Torvalds
+ *    (C) Copyright 2001 Ralf Baechle
+ */
+
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <asm/addrspace.h>
+#include <asm/byteorder.h>
+
+#include <linux/vmalloc.h>
+#include <asm/io.h>
+#include <asm/pgalloc.h>
+#include <asm/cacheflush.h>
+#include <asm/tlbflush.h>
+
+
+/*
+ * Remap an arbitrary physical address space into the kernel virtual
+ * address space. Needed when the kernel wants to access high addresses
+ * directly.
+ *
+ * NOTE! We need to allow non-page-aligned mappings too: we will obviously
+ * have to convert them into an offset in a page-aligned mapping, but the
+ * caller shouldn't need to know that small detail.
+ */
+
+#define IS_LOW512(addr) (!((unsigned long)(addr) & ~0x1fffffffUL))
+
+void * __ioremap(unsigned long phys_addr, unsigned long size, unsigned long flags)
+{
+	return (void *)phys_addr;
+}
+
+#define IS_KSEG1(addr) (((unsigned long)(addr) & ~0x1fffffffUL) == KSEG1)
+
+void iounmap(void *addr)
+{
+}
+
diff -ruN linux-2.6.7.org/arch/m32r/mm/ioremap.c linux-2.6.7/arch/m32r/mm/ioremap.c
--- linux-2.6.7.org/arch/m32r/mm/ioremap.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/mm/ioremap.c	2004-07-15 13:43:14.000000000 +0900
@@ -0,0 +1,188 @@
+/*  
+ *  linux/arch/m32r/mm/io_remap.c
+ *  
+ *  Copyright (c) 2001, 2002  Hiroyuki Kondo
+ *  
+ *  Taken from mips version.
+ *    (C) Copyright 1995 1996 Linus Torvalds
+ *    (C) Copyright 2001 Ralf Baechle
+ */
+
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <asm/addrspace.h>
+#include <asm/byteorder.h>
+
+#include <linux/vmalloc.h>
+#include <asm/io.h>
+#include <asm/pgalloc.h>
+#include <asm/cacheflush.h>
+#include <asm/tlbflush.h>
+
+static inline void remap_area_pte(pte_t * pte, unsigned long address, unsigned long size,
+	unsigned long phys_addr, unsigned long flags)
+{
+	unsigned long end;
+	unsigned long pfn;
+	pgprot_t pgprot = __pgprot(_PAGE_GLOBAL | _PAGE_PRESENT | _PAGE_READ
+	                           | _PAGE_WRITE | flags);
+
+	address &= ~PMD_MASK;
+	end = address + size;
+	if (end > PMD_SIZE)
+		end = PMD_SIZE;
+	if (address >= end)
+		BUG();
+	pfn = phys_addr >> PAGE_SHIFT;
+	do {
+		if (!pte_none(*pte)) {
+			printk("remap_area_pte: page already exists\n");
+			BUG();
+		}
+		set_pte(pte, pfn_pte(pfn, pgprot));
+		address += PAGE_SIZE;
+		pfn++;
+		pte++;
+	} while (address && (address < end));
+}
+
+static inline int remap_area_pmd(pmd_t * pmd, unsigned long address, unsigned long size,
+	unsigned long phys_addr, unsigned long flags)
+{
+	unsigned long end;
+
+	address &= ~PGDIR_MASK;
+	end = address + size;
+	if (end > PGDIR_SIZE)
+		end = PGDIR_SIZE;
+	phys_addr -= address;
+	if (address >= end)
+		BUG();
+	do {
+		pte_t * pte = pte_alloc_kernel(&init_mm, pmd, address);
+		if (!pte)
+			return -ENOMEM;
+		remap_area_pte(pte, address, end - address, address + phys_addr, flags);
+		address = (address + PMD_SIZE) & PMD_MASK;
+		pmd++;
+	} while (address && (address < end));
+	return 0;
+}
+
+static int remap_area_pages(unsigned long address, unsigned long phys_addr,
+				 unsigned long size, unsigned long flags)
+{
+	int error;
+	pgd_t * dir;
+	unsigned long end = address + size;
+
+	phys_addr -= address;
+	dir = pgd_offset(&init_mm, address);
+	flush_cache_all();
+	if (address >= end)
+		BUG();
+	spin_lock(&init_mm.page_table_lock);
+	do {
+		pmd_t *pmd;
+		pmd = pmd_alloc(&init_mm, dir, address);
+		error = -ENOMEM;
+		if (!pmd)
+			break;
+		if (remap_area_pmd(pmd, address, end - address,
+					 phys_addr + address, flags))
+			break;
+		error = 0;
+		address = (address + PGDIR_SIZE) & PGDIR_MASK;
+		dir++;
+	} while (address && (address < end));
+	spin_unlock(&init_mm.page_table_lock);
+	flush_tlb_all();
+	return error;
+}
+
+/*
+ * Generic mapping function (not visible outside):
+ */
+
+/*
+ * Remap an arbitrary physical address space into the kernel virtual
+ * address space. Needed when the kernel wants to access high addresses
+ * directly.
+ *
+ * NOTE! We need to allow non-page-aligned mappings too: we will obviously
+ * have to convert them into an offset in a page-aligned mapping, but the
+ * caller shouldn't need to know that small detail.
+ */
+
+#define IS_LOW512(addr) (!((unsigned long)(addr) & ~0x1fffffffUL))
+
+void * __ioremap(unsigned long phys_addr, unsigned long size, unsigned long flags)
+{
+	void * addr;
+	struct vm_struct * area;
+	unsigned long offset, last_addr;
+
+	/* Don't allow wraparound or zero size */
+	last_addr = phys_addr + size - 1;
+	if (!size || last_addr < phys_addr)
+		return NULL;
+
+	/*
+	 * Map objects in the low 512mb of address space using KSEG1, otherwise
+	 * map using page tables.
+	 */
+	if (IS_LOW512(phys_addr) && IS_LOW512(phys_addr + size - 1))
+		return (void *) KSEG1ADDR(phys_addr);
+
+	/*
+	 * Don't allow anybody to remap normal RAM that we're using..
+	 */
+	if (phys_addr < virt_to_phys(high_memory)) {
+		char *t_addr, *t_end;
+		struct page *page;
+
+		t_addr = __va(phys_addr);
+		t_end = t_addr + (size - 1);
+	   
+		for(page = virt_to_page(t_addr); page <= virt_to_page(t_end); page++)
+			if(!PageReserved(page))
+				return NULL;
+	}
+
+	/*
+	 * Mappings have to be page-aligned
+	 */
+	offset = phys_addr & ~PAGE_MASK;
+	phys_addr &= PAGE_MASK;
+	size = PAGE_ALIGN(last_addr + 1) - phys_addr;
+
+	/*
+	 * Ok, go for it..
+	 */
+	area = get_vm_area(size, VM_IOREMAP);
+	if (!area)
+		return NULL;
+	area->phys_addr = phys_addr;
+	addr = area->addr;
+	if (remap_area_pages((unsigned long)addr, phys_addr, size, flags)) {
+		vunmap(addr);
+		return NULL;
+	}
+
+	return (void *) (offset + (char *)addr);
+}
+
+#define IS_KSEG1(addr) (((unsigned long)(addr) & ~0x1fffffffUL) == KSEG1)
+
+void iounmap(void *addr)
+{
+	if (!IS_KSEG1(addr))
+		vfree((void *) (PAGE_MASK & (unsigned long) addr));
+}
+
diff -ruN linux-2.6.7.org/arch/m32r/mm/mmu.S linux-2.6.7/arch/m32r/mm/mmu.S
--- linux-2.6.7.org/arch/m32r/mm/mmu.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/mm/mmu.S	2004-03-31 19:37:43.000000000 +0900
@@ -0,0 +1,350 @@
+/*  
+ *  linux/arch/m32r/mm/mmu.S
+ *  
+ *  Copyright (C) 2001 by Hiroyuki Kondo
+ */
+
+/* $Id: mmu.S,v 1.15 2004/03/16 02:56:27 takata Exp $ */
+
+#include <linux/config.h>	/* CONFIG_MMU */
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+#include <asm/smp.h>
+
+	.text
+#ifdef CONFIG_MMU
+
+#include <asm/mmu_context.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/m32r.h>
+	
+/* 
+ * TLB Miss Exception handler
+ */
+	.balign	16
+ENTRY(tme_handler)
+	.global	tlb_entry_i_dat
+	.global	tlb_entry_d_dat
+
+	SWITCH_TO_KERNEL_STACK
+
+#if defined(CONFIG_ISA_M32R2) 
+	st	r0, @-sp
+	st	r1, @-sp
+	st	r2, @-sp
+	st	r3, @-sp
+
+	seth	r3, #high(MMU_REG_BASE)
+	ld	r1, @(MESTS_offset, r3)	; r1: status     (MESTS reg.)
+	ld	r0, @(MDEVP_offset, r3)	; r0: PFN + ASID (MDEVP reg.)
+	st	r1, @(MESTS_offset, r3)	; clear status   (MESTS reg.)
+	and3	r1, r1, #(MESTS_IT)
+	bnez	r1, 1f			; instruction TLB miss?
+
+;; data TLB miss 
+;;  input
+;;   r0: PFN + ASID (MDEVP reg.)
+;;   r1 - r3: free
+;;  output
+;;   r0: PFN + ASID
+;;   r1: TLB entry base address
+;;   r2: &tlb_entry_{i|d}_dat
+;;   r3: free
+
+#ifndef CONFIG_SMP
+	seth	r2, #high(tlb_entry_d_dat)
+	or3	r2, r2, #low(tlb_entry_d_dat)
+#else	/* CONFIG_SMP */
+	ldi	r1, #-8192
+	seth	r2, #high(tlb_entry_d_dat)
+	or3	r2, r2, #low(tlb_entry_d_dat)
+	and	r1, sp
+	ld	r1, @(16, r1)		; current_thread_info->cpu
+	slli	r1, #2
+	add	r2, r1
+#endif	/* !CONFIG_SMP */
+	seth	r1, #high(DTLB_BASE)
+	or3	r1, r1, #low(DTLB_BASE)
+	bra	2f 
+
+	.balign	16
+	.fillinsn
+1:
+;; instrucntion TLB miss
+;;  input
+;;   r0: MDEVP reg. (included ASID)
+;;   r1 - r3: free
+;;  output
+;;   r0: PFN + ASID
+;;   r1: TLB entry base address
+;;   r2: &tlb_entry_{i|d}_dat
+;;   r3: free
+	ldi	r3, #-4096
+	and3	r0, r0, #(MMU_CONTEXT_ASID_MASK)
+	mvfc	r1, bpc
+	and	r1, r3
+	or	r0, r1			; r0: PFN + ASID
+#ifndef CONFIG_SMP
+	seth	r2, #high(tlb_entry_i_dat)
+	or3	r2, r2, #low(tlb_entry_i_dat)
+#else	/* CONFIG_SMP */
+	ldi	r1, #-8192
+	seth	r2, #high(tlb_entry_i_dat)
+	or3	r2, r2, #low(tlb_entry_i_dat)
+	and	r1, sp
+	ld	r1, @(16, r1)		; current_thread_info->cpu
+	slli	r1, #2
+	add	r2, r1
+#endif	/* !CONFIG_SMP */
+	seth	r1, #high(ITLB_BASE)
+	or3	r1, r1, #low(ITLB_BASE)
+
+	.fillinsn
+2:
+;; select TLB entry
+;;  input
+;;   r0: PFN + ASID
+;;   r1: TLB entry base address
+;;   r2: &tlb_entry_{i|d}_dat
+;;   r3: free
+;;  output
+;;   r0: PFN + ASID
+;;   r1: TLB entry address
+;;   r2, r3: free
+#ifdef CONFIG_ISA_DUAL_ISSUE	
+	ld	r3, @r2		||	srli	r1, #3
+#else
+	ld	r3, @r2
+	srli	r1, #3
+#endif
+	add	r1, r3
+	; tlb_entry_{d|i}_dat++;
+	addi	r3, #1
+	and3	r3, r3, #(NR_TLB_ENTRIES - 1)
+#ifdef CONFIG_ISA_DUAL_ISSUE	
+	st	r3, @r2		||	slli	r1, #3
+#else
+	st	r3, @r2
+	slli	r1, #3
+#endif
+
+;; load pte
+;;  input
+;;   r0: PFN + ASID
+;;   r1: TLB entry address
+;;   r2, r3: free
+;;  output
+;;   r0: PFN + ASID
+;;   r1: TLB entry address
+;;   r2: pte_data
+;;   r3: free
+	; pgd = *(unsigned long *)MPTB;
+	ld24	r2, #(-MPTB - 1)
+	srl3	r3, r0, #22
+#ifdef CONFIG_ISA_DUAL_ISSUE
+	not	r2, r2		    ||	slli	r3, #2	; r3: pgd offset
+#else
+	not	r2, r2
+	slli	r3, #2
+#endif
+	ld	r2, @r2			; r2: pgd base addr (MPTB reg.)
+	or	r3, r2			; r3: pmd addr 
+
+	; pmd = pmd_offset(pgd, address);
+	ld	r3, @r3			; r3: pmd data
+	ldi	r2, #-4096
+	beqz	r3, 3f			; pmd_none(*pmd) ?
+
+	; pte = pte_offset(pmd, address);
+	and	r2, r3			; r2: pte base addr
+	srl3	r3, r0, #10
+	and3	r3, r3, #0xffc		; r3: pte offset
+	or	r3, r2
+	seth	r2, #0x8000
+	or	r3, r2			; r3: pte addr
+
+	; pte_data = (unsigned long)pte_val(*pte);
+	ld	r2, @r3			; r2: pte data
+	or3	r2, r2, #2		; _PAGE_PRESENT(=2)
+
+	.fillinsn
+5:
+;; set tlb
+;;  input
+;;   r0: PFN + ASID
+;;   r1: TLB entry address
+;;   r2: pte_data
+;;   r3: free
+	st	r0, @r1			; set_tlb_tag(entry++, address);
+	st	r2, @+r1		; set_tlb_data(entry, pte_data);
+
+	.fillinsn
+6:
+	ld	r3, @sp+
+	ld	r2, @sp+
+	ld	r1, @sp+
+	ld	r0, @sp+
+	rte
+
+	.fillinsn
+3:
+;; error
+;;  input
+;;   r0: PFN + ASID
+;;   r1: TLB entry address
+;;   r2, r3: free
+;;  output
+;;   r0: PFN + ASID
+;;   r1: TLB entry address
+;;   r2: pte_data
+;;   r3: free
+#ifdef CONFIG_ISA_DUAL_ISSUE	
+	bra	5b		    ||	ldi	r2, #2
+#else
+	ldi	r2, #2		; r2: pte_data = 0 | _PAGE_PRESENT(=2)
+	bra	5b
+#endif
+
+#elif defined (CONFIG_ISA_M32R)
+
+	st	sp, @-sp
+	st	r0, @-sp
+	st	r1, @-sp
+	st	r2, @-sp
+	st	r3, @-sp
+	st	r4, @-sp
+
+	seth	r3, #high(MMU_REG_BASE)
+	ld	r0, @(MDEVA_offset,r3)	; r0: address  (MDEVA reg.)
+	mvfc	r2, bpc			; r2: bpc
+	ld	r1, @(MESTS_offset,r3)	; r1: status   (MESTS reg.)
+	st	r1, @(MESTS_offset,r3)	; clear status (MESTS reg.)
+	and3	r1, r1, #(MESTS_IT)
+	beqz	r1, 1f			; data TLB miss?
+
+;; instrucntion TLB miss
+	mv	r0, r2			; address = bpc;
+	; entry = (unsigned long *)ITLB_BASE+tlb_entry_i*2;
+	seth	r3, #shigh(tlb_entry_i_dat)
+	ld	r4, @(low(tlb_entry_i_dat),r3)
+	sll3	r2, r4, #3
+	seth	r1, #high(ITLB_BASE)
+	or3	r1, r1, #low(ITLB_BASE)
+	add	r2, r1			; r2: entry
+	addi	r4, #1			; tlb_entry_i++;
+	and3	r4, r4, #(NR_TLB_ENTRIES-1)
+	st	r4, @(low(tlb_entry_i_dat),r3)
+	bra	2f
+	.fillinsn
+1:
+;; data TLB miss 
+	; entry = (unsigned long *)DTLB_BASE+tlb_entry_d*2;
+	seth	r3, #shigh(tlb_entry_d_dat)
+	ld	r4, @(low(tlb_entry_d_dat),r3)
+	sll3	r2, r4, #3
+	seth	r1, #high(DTLB_BASE)
+	or3	r1, r1, #low(DTLB_BASE)
+	add	r2, r1			; r2: entry
+	addi	r4, #1			; tlb_entry_d++;
+	and3	r4, r4, #(NR_TLB_ENTRIES-1)
+	st	r4, @(low(tlb_entry_d_dat),r3)
+	.fillinsn
+2:
+;; load pte
+; r0: address, r2: entry
+; r1,r3,r4: (free)
+	; pgd = *(unsigned long *)MPTB;
+	ld24	r1, #(-MPTB-1)
+	not	r1, r1
+	ld	r1, @r1
+	srl3	r4, r0, #22
+	sll3	r3, r4, #2
+	add	r3, r1			; r3: pgd
+	; pmd = pmd_offset(pgd, address);
+	ld	r1, @r3			; r1: pmd
+	beqz	r1, 3f			; pmd_none(*pmd) ?
+;
+	and3	r1, r1, #0xeff
+	ldi	r4, #611		; _KERNPG_TABLE(=611)
+	beq	r1, r4, 4f		; !pmd_bad(*pmd) ?
+	.fillinsn
+3:
+	ldi	r1, #0			; r1: pte_data = 0
+	bra	5f
+	.fillinsn
+4:
+	; pte = pte_offset(pmd, address);
+	ld	r4, @r3			; r4: pte
+	ldi	r3, #-4096
+	and	r4, r3
+	srl3	r3, r0, #10
+	and3	r3, r3, #0xffc
+	add	r4, r3
+	seth	r3, #0x8000
+	add	r4, r3			; r4: pte
+	; pte_data = (unsigned long)pte_val(*pte);
+	ld	r1, @r4			; r1: pte_data
+	.fillinsn
+
+;; set tlb
+; r0: address, r1: pte_data, r2: entry
+; r3,r4: (free)
+5:
+	ldi	r3, #-4096		; set_tlb_tag(entry++, address);
+	and	r3, r0
+	seth	r4, #shigh(MASID)
+	ld	r4, @(low(MASID),r4)	; r4: MASID
+	and3	r4, r4, #(MMU_CONTEXT_ASID_MASK)
+	or	r3, r4
+	st	r3, @r2
+	or3	r4, r1, #2		; _PAGE_PRESENT(=2)
+	st	r4, @(4,r2)		; set_tlb_data(entry, pte_data);
+
+	ld	r4, @sp+
+	ld	r3, @sp+
+	ld	r2, @sp+
+	ld	r1, @sp+
+	ld	r0, @sp+
+	ld	sp, @sp+
+	rte
+
+#else 
+#error unknown isa configuration
+#endif
+
+ENTRY(init_tlb)
+;; Set MMU Register
+	seth	r0, #high(MMU_REG_BASE)	 ; Set MMU_REG_BASE higher
+	or3	r0, r0, #low(MMU_REG_BASE)  ; Set MMU_REG_BASE lower
+	ldi	r1, #0
+	st	r1, @(MPSZ_offset,r0)	; Set MPSZ Reg(Page size 4KB:0 16KB:1 64KB:2)
+	ldi	r1, #0
+	st	r1, @(MASID_offset,r0)	; Set ASID Zero
+
+;; Set TLB
+	seth	r0, #high(ITLB_BASE)	; Set ITLB_BASE higher
+	or3	r0, r0, #low(ITLB_BASE)	; Set ITLB_BASE lower
+	seth	r1, #high(DTLB_BASE)	; Set DTLB_BASE higher
+	or3	r1, r1, #low(DTLB_BASE)	; Set DTLB_BASE lower
+	ldi	r2, #0
+	ldi	r3, #NR_TLB_ENTRIES
+	addi	r0, #-4
+	addi	r1, #-4
+clear_tlb:
+	st	r2, @+r0		; VPA <- 0
+	st	r2, @+r0		; PPA <- 0
+	st	r2, @+r1		; VPA <- 0
+	st	r2, @+r1		; PPA <- 0
+	addi	r3, #-1
+	bnez	r3, clear_tlb
+;;
+	jmp	r14
+
+ENTRY(m32r_itlb_entrys)
+ENTRY(m32r_otlb_entrys)
+
+#endif  /* CONFIG_MMU */
+
+.end
+
diff -ruN linux-2.6.7.org/arch/m32r/mm/page.S linux-2.6.7/arch/m32r/mm/page.S
--- linux-2.6.7.org/arch/m32r/mm/page.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/mm/page.S	2004-07-27 14:44:00.000000000 +0900
@@ -0,0 +1,82 @@
+/*  
+ *  linux/arch/m32r/mm/page.S
+ *  
+ *  Clear/Copy page with CPU
+ *  
+ *  Copyright (C) 2004  The Free Software Initiative of Japan
+ *
+ *  Written by Niibe Yutaka
+ *  
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ */
+	.text
+	.global	copy_page
+	/*
+	 * copy_page (to, from)
+	 *
+	 * PAGE_SIZE = 4096-byte
+	 * Cache line = 16-byte
+	 * 16 * 256
+	 */
+	.align	4
+copy_page:
+	ldi	r2, #255
+	ld	r3, @r0		/* cache line allocate */
+	ld	r4, @r1+
+	ld	r5, @r1+
+	ld	r6, @r1+
+	ld	r7, @r1+
+	.fillinsn
+0:
+	st	r4, @r0
+	st	r5, @+r0
+	st	r6, @+r0
+	st	r7, @+r0
+	ld	r4, @r1+
+	addi	r0, #4
+	ld	r5, @r1+
+	ld	r6, @r1+
+	ld	r7, @r1+
+	ld	r3, @r0		/* cache line allocate */
+	addi	r2, #-1
+	bnez	r2, 0b
+
+	st	r4, @r0
+	st	r5, @+r0
+	st	r6, @+r0
+	st	r7, @+r0
+	jmp	r14
+
+	.text
+	.global	clear_page
+	/*
+	 * clear_page (to)
+	 *
+	 * PAGE_SIZE = 4096-byte
+	 * Cache line = 16-byte
+	 * 16 * 256
+	 */
+	.align	4
+clear_page:
+	ldi	r2, #255
+	ldi	r4, #0
+	ld	r3, @r0		/* cache line allocate */
+	.fillinsn
+0:
+	st	r4, @r0
+	st	r4, @+r0
+	st	r4, @+r0
+	st	r4, @+r0
+	addi	r0, #4
+	ld	r3, @r0		/* cache line allocate */
+	addi	r2, #-1
+	bnez	r2, 0b
+
+	st	r4, @r0
+	st	r4, @+r0
+	st	r4, @+r0
+	st	r4, @+r0
+	jmp	r14
diff -ruN linux-2.6.7.org/arch/m32r/oaks32r/defconfig.nommu linux-2.6.7/arch/m32r/oaks32r/defconfig.nommu
--- linux-2.6.7.org/arch/m32r/oaks32r/defconfig.nommu	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/oaks32r/defconfig.nommu	2004-07-15 13:43:14.000000000 +0900
@@ -0,0 +1,514 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_M32R=y
+CONFIG_UID16=y
+CONFIG_GENERIC_ISA_DMA=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_STANDALONE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+# CONFIG_SYSVIPC is not set
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_HOTPLUG=y
+# CONFIG_IKCONFIG is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+# CONFIG_FUTEX is not set
+# CONFIG_EPOLL is not set
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+CONFIG_KMOD=y
+
+#
+# Processor type and features
+#
+# CONFIG_PLAT_MAPPI is not set
+# CONFIG_PLAT_USRV is not set
+# CONFIG_PLAT_M32700UT is not set
+CONFIG_PLAT_OAKS32R=y
+# CONFIG_PLAT_MAPPI2 is not set
+# CONFIG_CHIP_M32700 is not set
+CONFIG_CHIP_M32102=y
+# CONFIG_CHIP_VDEC2 is not set
+# CONFIG_CHIP_OPSP is not set
+CONFIG_ISA_M32R=y
+CONFIG_BUS_CLOCK=33333333
+CONFIG_TIMER_DIVIDE=128
+# CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_MEMORY_START=0x01000000
+CONFIG_MEMORY_SIZE=0x00800000
+CONFIG_NOHIGHMEM=y
+# CONFIG_DISCONTIGMEM is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+CONFIG_PREEMPT=y
+# CONFIG_HAVE_DEC_LOCK is not set
+# CONFIG_SMP is not set
+
+#
+# M32R drivers
+#
+CONFIG_M32R_NE2000=y
+
+#
+# Power management options (ACPI, APM)
+#
+# CONFIG_PM is not set
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+# CONFIG_PCI is not set
+# CONFIG_ISA is not set
+
+#
+# PCMCIA/CardBus support
+#
+# CONFIG_PCMCIA is not set
+
+#
+# PCI Hotplug Support
+#
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_FLAT=y
+# CONFIG_BINFMT_ZFLAT is not set
+# CONFIG_BINFMT_SHARED_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_FW_LOADER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+CONFIG_BLK_DEV_NBD=y
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_BLK_DEV_INITRD is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+# CONFIG_SCSI is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_NETDEVICES is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+# CONFIG_SERIO_I8042 is not set
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_CT82C710 is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+CONFIG_SERIAL_M32R_SIO=y
+CONFIG_SERIAL_M32R_SIO_CONSOLE=y
+# CONFIG_SERIAL_M32R_PLDSIO is not set
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_QIC02_TAPE is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_JBD is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+# CONFIG_FAT_FS is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+# CONFIG_DEVFS_FS is not set
+CONFIG_DEVPTS_FS_XATTR=y
+CONFIG_DEVPTS_FS_SECURITY=y
+# CONFIG_TMPFS is not set
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_DEBUG_KERNEL is not set
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_FRAME_POINTER is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
diff -ruN linux-2.6.7.org/arch/m32r/oaks32r/dot.gdbinit.nommu linux-2.6.7/arch/m32r/oaks32r/dot.gdbinit.nommu
--- linux-2.6.7.org/arch/m32r/oaks32r/dot.gdbinit.nommu	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/oaks32r/dot.gdbinit.nommu	2004-04-19 18:42:35.000000000 +0900
@@ -0,0 +1,155 @@
+# .gdbinit file
+# $Id: dot.gdbinit.oaks32r,v 1.2 2004/04/15 02:33:14 takata Exp $
+#-----
+# NOTE: this file is generated by a script, "gen_gdbinit.pl".
+# (Please type "gen_gdbinit.pl --help" and check the help message).
+# $ Id: gen_gdbinit.pl,v 1.10 2004/04/15 02:10:45 takata Exp $
+#-----
+# target platform: oaks32r
+
+# setting
+set width 0d70
+set radix 0d16
+
+# clk xin:cpu:bus=16:66:33
+define clock_init
+  set *(unsigned long *)0x00ef4008 = 1
+  shell sleep 0.1
+  set *(unsigned long *)0x00ef4000 = 0x00020100
+end
+
+# Initialize programmable ports
+define port_init
+  set *(unsigned long *)0x00ef1000 = 0x1
+  set *(unsigned long *)0x00ef1060 = 0x01400001
+  set *(unsigned long *)0x00ef1064 = 0x00015555
+  set *(unsigned long *)0x00ef1068 = 0x55555050
+  set *(unsigned long *)0x00ef106c = 0x05150040
+end
+
+# Initialize SDRAM controller
+define sdram_init
+  set *(unsigned long *)0x00ef6008 = 0x00000182
+  set *(unsigned long *)0x00ef600c = 0x00000001
+  shell sleep 0.1
+  set *(unsigned long *)0x00ef602c = 0x00000010
+  set *(unsigned long *)0x00ef6028 = 0x00000300
+  set *(unsigned long *)0x00ef6048 = 0x00000001
+  set *(unsigned long *)0x00ef6020 = 0x01000041
+  set *(unsigned long *)0x00ef6004 = 0x00010117
+  set *(unsigned long *)0x00ef6010 = 0x00000001
+  set *(unsigned long *)0x00ef6024 = 0x00000001
+end
+document sdram_init
+  SDRAM controller initialization
+  0x01000000 - 0x017fffff (8MB)
+end
+
+# Initialize LAN controller
+define lanc_init
+  set *(unsigned long *)0x00ef5008 = 0x03031303
+  #RST DRV (P64)
+  set *(unsigned char *)0x00ef1046 = 0x08
+  set *(unsigned char *)0x00ef1026 = 0xff
+  set *(unsigned char *)0x00ef1026 = 0x00
+  set *(unsigned short *)0x02000630 = 0xffff
+end
+
+# Show current task structure
+define show_current
+  set $current = $spi & 0xffffe000
+  printf "$current=0x%08lX\n",$current
+  print *(struct task_struct *)$current
+end
+
+# Show user assigned task structure
+define show_task
+  set  = $arg0 & 0xffffe000
+  printf "$task=0x%08lX\n",$task
+  print *(struct task_struct *)$task
+end
+document show_task
+  Show user assigned task structure
+  arg0 : task structure address
+end
+
+# Show M32R registers
+define show_regs
+  printf " R0[0x%08lX]   R1[0x%08lX]   R2[0x%08lX]   R3[0x%08lX]\n",$r0,$r1,$r2,$r3
+  printf " R4[0x%08lX]   R5[0x%08lX]   R6[0x%08lX]   R7[0x%08lX]\n",$r4,$r5,$r6,$r7
+  printf " R8[0x%08lX]   R9[0x%08lX]  R10[0x%08lX]  R11[0x%08lX]\n",$r8,$r9,$r10,$r11
+  printf "R12[0x%08lX]   FP[0x%08lX]   LR[0x%08lX]   SP[0x%08lX]\n",$r12,$fp,$lr,$sp
+  printf "PSW[0x%08lX]  CBR[0x%08lX]  SPI[0x%08lX]  SPU[0x%08lX]\n",$psw,$cbr,$spi,$spu
+  printf "BPC[0x%08lX]   PC[0x%08lX] ACCL[0x%08lX] ACCH[0x%08lX]\n",$bpc,$pc,$accl,$acch
+end
+
+# Setup all
+define setup
+  use_mon_code
+  set *(unsigned int)0xfffffffc=0x60
+  shell sleep 0.1
+  clock_init
+  shell sleep 0.1
+  port_init
+  sdram_init
+  lanc_init
+end
+
+# Load modules
+define load_modules
+  use_debug_dma
+  load
+end
+
+# Set kernel parameters
+define set_kernel_parameters
+  set $param = (void*)0x01002000
+  # INITRD_START
+  set *(unsigned long *)($param + 0x0010) = 0x00000000
+  # INITRD_SIZE
+  set *(unsigned long *)($param + 0x0014) = 0x00000000
+  # M32R_CPUCLK
+  set *(unsigned long *)($param + 0x0018) = 0d66666667
+  # M32R_BUSCLK
+  set *(unsigned long *)($param + 0x001c) = 0d33333333
+
+  # M32R_TIMER_DIVIDE
+  set *(unsigned long *)($param + 0x0020) = 0d128
+
+#  set {char[0x200]}($param + 0x100) = "console=ttyD0,115200n8x root=/dev/nfsroot nfsroot=192.168.0.1:/project/m32r-linux/export/rootfs nfsaddrs=192.168.0.101:192.168.0.1:192.168.0.1:255.255.255.0:mappi001 \0"
+  set {char[0x200]}($param + 0x100) = "console=ttyD0,115200n8x root=/dev/nfsroot nfsroot=192.168.0.1:/project/m32r-linux/export/root.busybox.flat nfsaddrs=192.168.0.101:192.168.0.1:192.168.0.1:255.255.255.0:mappi001 \0"
+end
+
+# Boot
+define boot
+  set_kernel_parameters
+  set $fp = 0
+  set $pc = 0x01001000
+  si
+  c
+end
+
+# Set breakpoints
+define set_breakpoints
+  b *0x00000020
+  b *0x00000030
+end
+
+# Restart
+define restart
+  sdireset
+  sdireset
+  setup
+  load_modules
+  boot
+end
+
+sdireset
+sdireset
+file vmlinux
+target m32rsdi
+setup
+#load_modules
+#set_breakpoints
+#boot
+
diff -ruN linux-2.6.7.org/arch/m32r/oprofile/Kconfig linux-2.6.7/arch/m32r/oprofile/Kconfig
--- linux-2.6.7.org/arch/m32r/oprofile/Kconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/oprofile/Kconfig	2004-04-23 16:09:38.000000000 +0900
@@ -0,0 +1,23 @@
+
+menu "Profiling support"
+	depends on EXPERIMENTAL
+
+config PROFILING
+	bool "Profiling support (EXPERIMENTAL)"
+	help
+	  Say Y here to enable the extended profiling support mechanisms used
+	  by profilers such as OProfile.
+	  
+
+config OPROFILE
+	tristate "OProfile system profiling (EXPERIMENTAL)"
+	depends on PROFILING
+	help
+	  OProfile is a profiling system capable of profiling the
+	  whole system, include the kernel, kernel modules, libraries,
+	  and applications.
+
+	  If unsure, say N.
+
+endmenu
+
diff -ruN linux-2.6.7.org/arch/m32r/oprofile/Makefile linux-2.6.7/arch/m32r/oprofile/Makefile
--- linux-2.6.7.org/arch/m32r/oprofile/Makefile	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/oprofile/Makefile	2004-04-23 16:09:38.000000000 +0900
@@ -0,0 +1,9 @@
+obj-$(CONFIG_OPROFILE) += oprofile.o
+
+DRIVER_OBJS := $(addprefix ../../../drivers/oprofile/, \
+		oprof.o cpu_buffer.o buffer_sync.o \
+		event_buffer.o oprofile_files.o \
+		oprofilefs.o oprofile_stats.o \
+		timer_int.o )
+
+oprofile-y := $(DRIVER_OBJS) init.o
diff -ruN linux-2.6.7.org/arch/m32r/oprofile/init.c linux-2.6.7/arch/m32r/oprofile/init.c
--- linux-2.6.7.org/arch/m32r/oprofile/init.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/oprofile/init.c	2004-04-23 16:09:38.000000000 +0900
@@ -0,0 +1,25 @@
+/**
+ * @file init.c
+ *
+ * @remark Copyright 2002 OProfile authors
+ * @remark Read the file COPYING
+ *
+ * @author John Levon <levon@movementarian.org>
+ */
+
+#include <linux/kernel.h>
+#include <linux/oprofile.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+ 
+extern void timer_init(struct oprofile_operations ** ops);
+
+int __init oprofile_arch_init(struct oprofile_operations ** ops)
+{
+	return -ENODEV;
+}
+
+
+void oprofile_arch_exit(void)
+{
+}
diff -ruN linux-2.6.7.org/arch/m32r/opsput/defconfig.opsput linux-2.6.7/arch/m32r/opsput/defconfig.opsput
--- linux-2.6.7.org/arch/m32r/opsput/defconfig.opsput	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/opsput/defconfig.opsput	2004-07-27 15:54:20.000000000 +0900
@@ -0,0 +1,588 @@
+#
+# Automatically generated make config: don't edit
+#
+CONFIG_M32R=y
+CONFIG_UID16=y
+CONFIG_GENERIC_ISA_DMA=y
+
+#
+# Code maturity level options
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_CLEAN_COMPILE=y
+CONFIG_STANDALONE=y
+CONFIG_BROKEN_ON_SMP=y
+
+#
+# General setup
+#
+CONFIG_SWAP=y
+CONFIG_SYSVIPC=y
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_SYSCTL=y
+# CONFIG_AUDIT is not set
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_HOTPLUG=y
+CONFIG_IKCONFIG=y
+# CONFIG_IKCONFIG_PROC is not set
+CONFIG_EMBEDDED=y
+# CONFIG_KALLSYMS is not set
+# CONFIG_FUTEX is not set
+# CONFIG_EPOLL is not set
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_AS is not set
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+
+#
+# Loadable module support
+#
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_MODULE_FORCE_UNLOAD is not set
+CONFIG_OBSOLETE_MODPARM=y
+# CONFIG_MODVERSIONS is not set
+CONFIG_KMOD=y
+
+#
+# Processor type and features
+#
+# CONFIG_PLAT_MAPPI is not set
+# CONFIG_PLAT_USRV is not set
+# CONFIG_PLAT_M32700UT is not set
+CONFIG_PLAT_OPSPUT=y
+# CONFIG_PLAT_OAKS32R is not set
+# CONFIG_PLAT_MAPPI2 is not set
+# CONFIG_CHIP_M32700 is not set
+# CONFIG_CHIP_M32102 is not set
+# CONFIG_CHIP_VDEC2 is not set
+CONFIG_CHIP_OPSP=y
+CONFIG_MMU=y
+CONFIG_TLB_ENTRIES=32
+CONFIG_ISA_M32R2=y
+CONFIG_ISA_DSP_LEVEL2=y
+CONFIG_ISA_DUAL_ISSUE=y
+CONFIG_BUS_CLOCK=50000000
+CONFIG_TIMER_DIVIDE=128
+# CONFIG_CPU_LITTLE_ENDIAN is not set
+CONFIG_MEMORY_START=0x08000000
+CONFIG_MEMORY_SIZE=0x01000000
+CONFIG_NOHIGHMEM=y
+# CONFIG_DISCONTIGMEM is not set
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+# CONFIG_RWSEM_XCHGADD_ALGORITHM is not set
+# CONFIG_PREEMPT is not set
+# CONFIG_SMP is not set
+
+#
+# M32R drivers
+#
+# CONFIG_M32R_CFC is not set
+CONFIG_M32R_SMC91111=y
+
+#
+# Power management options (ACPI, APM)
+#
+# CONFIG_PM is not set
+
+#
+# Bus options (PCI, PCMCIA, EISA, MCA, ISA)
+#
+# CONFIG_PCI is not set
+# CONFIG_ISA is not set
+
+#
+# PCMCIA/CardBus support
+#
+CONFIG_PCMCIA=y
+# CONFIG_PCMCIA_DEBUG is not set
+# CONFIG_TCIC is not set
+
+#
+# PCI Hotplug Support
+#
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+# CONFIG_FW_LOADER is not set
+# CONFIG_DEBUG_DRIVER is not set
+
+#
+# Memory Technology Devices (MTD)
+#
+# CONFIG_MTD is not set
+
+#
+# Parallel port support
+#
+# CONFIG_PARPORT is not set
+
+#
+# Plug and Play support
+#
+
+#
+# Block devices
+#
+# CONFIG_BLK_DEV_FD is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+# CONFIG_BLK_DEV_NBD is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_SIZE=4096
+# CONFIG_BLK_DEV_INITRD is not set
+
+#
+# ATA/ATAPI/MFM/RLL support
+#
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI=m
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=m
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+CONFIG_BLK_DEV_SR=m
+# CONFIG_BLK_DEV_SR_VENDOR is not set
+CONFIG_CHR_DEV_SG=m
+
+#
+# Some SCSI devices (e.g. CD jukebox) support multiple LUNs
+#
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+
+#
+# SCSI Transport Attributes
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+
+#
+# SCSI low-level drivers
+#
+# CONFIG_SCSI_AIC7XXX_OLD is not set
+# CONFIG_SCSI_SATA is not set
+# CONFIG_SCSI_EATA_PIO is not set
+# CONFIG_SCSI_DEBUG is not set
+
+#
+# PCMCIA SCSI adapter support
+#
+# CONFIG_PCMCIA_AHA152X is not set
+# CONFIG_PCMCIA_FDOMAIN is not set
+# CONFIG_PCMCIA_NINJA_SCSI is not set
+# CONFIG_PCMCIA_QLOGIC is not set
+# CONFIG_PCMCIA_SYM53C500 is not set
+
+#
+# Multi-device support (RAID and LVM)
+#
+# CONFIG_MD is not set
+
+#
+# Fusion MPT device support
+#
+
+#
+# IEEE 1394 (FireWire) support
+#
+# CONFIG_IEEE1394 is not set
+
+#
+# I2O device support
+#
+
+#
+# Networking support
+#
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+# CONFIG_PACKET_MMAP is not set
+# CONFIG_NETLINK_DEV is not set
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETFILTER is not set
+
+#
+# SCTP Configuration (EXPERIMENTAL)
+#
+# CONFIG_IP_SCTP is not set
+# CONFIG_ATM is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_NET_DIVERT is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_NET_FASTROUTE is not set
+# CONFIG_NET_HW_FLOWCONTROL is not set
+
+#
+# QoS and/or fair queueing
+#
+# CONFIG_NET_SCHED is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_NETDEVICES is not set
+
+#
+# ISDN subsystem
+#
+# CONFIG_ISDN is not set
+
+#
+# Telephony Support
+#
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
+# CONFIG_INPUT_TSDEV is not set
+# CONFIG_INPUT_EVDEV is not set
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input I/O drivers
+#
+# CONFIG_GAMEPORT is not set
+CONFIG_SOUND_GAMEPORT=y
+CONFIG_SERIO=y
+CONFIG_SERIO_I8042=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_CT82C710 is not set
+
+#
+# Input Device Drivers
+#
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TOUCHSCREEN is not set
+# CONFIG_INPUT_MISC is not set
+
+#
+# Character devices
+#
+# CONFIG_VT is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_M32R_SIO is not set
+CONFIG_SERIAL_M32R_PLDSIO=y
+CONFIG_SERIAL_M32R_PLDSIO_CONSOLE=y
+CONFIG_UNIX98_PTYS=y
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=256
+# CONFIG_QIC02_TAPE is not set
+
+#
+# IPMI
+#
+# CONFIG_IPMI_HANDLER is not set
+
+#
+# Watchdog Cards
+#
+# CONFIG_WATCHDOG is not set
+# CONFIG_RTC is not set
+# CONFIG_GEN_RTC is not set
+# CONFIG_DTLK is not set
+# CONFIG_R3964 is not set
+# CONFIG_APPLICOM is not set
+
+#
+# Ftape, the floppy tape device driver
+#
+# CONFIG_FTAPE is not set
+# CONFIG_AGP is not set
+# CONFIG_DRM is not set
+
+#
+# PCMCIA character devices
+#
+# CONFIG_SYNCLINK_CS is not set
+# CONFIG_RAW_DRIVER is not set
+
+#
+# I2C support
+#
+# CONFIG_I2C is not set
+
+#
+# Misc devices
+#
+
+#
+# Multimedia devices
+#
+# CONFIG_VIDEO_DEV is not set
+
+#
+# Digital Video Broadcasting Devices
+#
+# CONFIG_DVB is not set
+
+#
+# Graphics support
+#
+# CONFIG_FB is not set
+
+#
+# Sound
+#
+# CONFIG_SOUND is not set
+
+#
+# USB support
+#
+
+#
+# USB Gadget Support
+#
+# CONFIG_USB_GADGET is not set
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+CONFIG_EXT3_FS=m
+CONFIG_EXT3_FS_XATTR=y
+# CONFIG_EXT3_FS_POSIX_ACL is not set
+# CONFIG_EXT3_FS_SECURITY is not set
+CONFIG_JBD=m
+CONFIG_JBD_DEBUG=y
+CONFIG_FS_MBCACHE=y
+CONFIG_REISERFS_FS=m
+# CONFIG_REISERFS_CHECK is not set
+# CONFIG_REISERFS_PROC_INFO is not set
+# CONFIG_REISERFS_FS_XATTR is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+CONFIG_ISO9660_FS=m
+CONFIG_JOLIET=y
+# CONFIG_ZISOFS is not set
+CONFIG_UDF_FS=m
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=m
+CONFIG_MSDOS_FS=m
+CONFIG_VFAT_FS=m
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_KCORE=y
+CONFIG_SYSFS=y
+CONFIG_DEVFS_FS=y
+CONFIG_DEVFS_MOUNT=y
+# CONFIG_DEVFS_DEBUG is not set
+# CONFIG_DEVPTS_FS_XATTR is not set
+CONFIG_TMPFS=y
+# CONFIG_HUGETLB_PAGE is not set
+CONFIG_RAMFS=y
+
+#
+# Miscellaneous filesystems
+#
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+# CONFIG_CRAMFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+
+#
+# Network File Systems
+#
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+# CONFIG_NFS_V4 is not set
+# CONFIG_NFS_DIRECTIO is not set
+# CONFIG_NFSD is not set
+CONFIG_ROOT_NFS=y
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+# CONFIG_EXPORTFS is not set
+CONFIG_SUNRPC=y
+# CONFIG_RPCSEC_GSS_KRB5 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+
+#
+# Native Language Support
+#
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+# CONFIG_NLS_CODEPAGE_437 is not set
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ISO8859_1 is not set
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_UTF8 is not set
+
+#
+# Profiling support
+#
+# CONFIG_PROFILING is not set
+
+#
+# Kernel hacking
+#
+CONFIG_DEBUG_KERNEL=y
+# CONFIG_DEBUG_STACKOVERFLOW is not set
+# CONFIG_DEBUG_SLAB is not set
+# CONFIG_DEBUG_IOVIRT is not set
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_SPINLOCK_SLEEP is not set
+# CONFIG_FRAME_POINTER is not set
+
+#
+# Security options
+#
+# CONFIG_SECURITY is not set
+
+#
+# Cryptographic options
+#
+# CONFIG_CRYPTO is not set
+
+#
+# Library routines
+#
+CONFIG_CRC32=y
+# CONFIG_LIBCRC32C is not set
diff -ruN linux-2.6.7.org/arch/m32r/opsput/dot.gdbinit linux-2.6.7/arch/m32r/opsput/dot.gdbinit
--- linux-2.6.7.org/arch/m32r/opsput/dot.gdbinit	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/arch/m32r/opsput/dot.gdbinit	2004-07-27 15:54:20.000000000 +0900
@@ -0,0 +1,180 @@
+# .gdbinit file
+# $Id: dot.gdbinit,v 1.1 2004/07/27 06:54:20 sakugawa Exp $
+
+# setting
+set width 0d70
+set radix 0d16
+set height 0
+debug_chaos
+
+define tlb_init
+  set $tlbbase = 0xfe000000
+  set *(unsigned long *)($tlbbase + 0x04) = 0x0
+  set *(unsigned long *)($tlbbase + 0x0c) = 0x0
+  set *(unsigned long *)($tlbbase + 0x14) = 0x0
+  set *(unsigned long *)($tlbbase + 0x1c) = 0x0
+  set *(unsigned long *)($tlbbase + 0x24) = 0x0
+  set *(unsigned long *)($tlbbase + 0x2c) = 0x0
+  set *(unsigned long *)($tlbbase + 0x34) = 0x0
+  set *(unsigned long *)($tlbbase + 0x3c) = 0x0
+  set *(unsigned long *)($tlbbase + 0x44) = 0x0
+  set *(unsigned long *)($tlbbase + 0x4c) = 0x0
+  set *(unsigned long *)($tlbbase + 0x54) = 0x0
+  set *(unsigned long *)($tlbbase + 0x5c) = 0x0
+  set *(unsigned long *)($tlbbase + 0x64) = 0x0
+  set *(unsigned long *)($tlbbase + 0x6c) = 0x0
+  set *(unsigned long *)($tlbbase + 0x74) = 0x0
+  set *(unsigned long *)($tlbbase + 0x7c) = 0x0
+  set *(unsigned long *)($tlbbase + 0x84) = 0x0
+  set *(unsigned long *)($tlbbase + 0x8c) = 0x0
+  set *(unsigned long *)($tlbbase + 0x94) = 0x0
+  set *(unsigned long *)($tlbbase + 0x9c) = 0x0
+  set *(unsigned long *)($tlbbase + 0xa4) = 0x0
+  set *(unsigned long *)($tlbbase + 0xac) = 0x0
+  set *(unsigned long *)($tlbbase + 0xb4) = 0x0
+  set *(unsigned long *)($tlbbase + 0xbc) = 0x0
+  set *(unsigned long *)($tlbbase + 0xc4) = 0x0
+  set *(unsigned long *)($tlbbase + 0xcc) = 0x0
+  set *(unsigned long *)($tlbbase + 0xd4) = 0x0
+  set *(unsigned long *)($tlbbase + 0xdc) = 0x0
+  set *(unsigned long *)($tlbbase + 0xe4) = 0x0
+  set *(unsigned long *)($tlbbase + 0xec) = 0x0
+  set *(unsigned long *)($tlbbase + 0xf4) = 0x0
+  set *(unsigned long *)($tlbbase + 0xfc) = 0x0
+  set $tlbbase = 0xfe000800
+  set *(unsigned long *)($tlbbase + 0x04) = 0x0
+  set *(unsigned long *)($tlbbase + 0x0c) = 0x0
+  set *(unsigned long *)($tlbbase + 0x14) = 0x0
+  set *(unsigned long *)($tlbbase + 0x1c) = 0x0
+  set *(unsigned long *)($tlbbase + 0x24) = 0x0
+  set *(unsigned long *)($tlbbase + 0x2c) = 0x0
+  set *(unsigned long *)($tlbbase + 0x34) = 0x0
+  set *(unsigned long *)($tlbbase + 0x3c) = 0x0
+  set *(unsigned long *)($tlbbase + 0x44) = 0x0
+  set *(unsigned long *)($tlbbase + 0x4c) = 0x0
+  set *(unsigned long *)($tlbbase + 0x54) = 0x0
+  set *(unsigned long *)($tlbbase + 0x5c) = 0x0
+  set *(unsigned long *)($tlbbase + 0x64) = 0x0
+  set *(unsigned long *)($tlbbase + 0x6c) = 0x0
+  set *(unsigned long *)($tlbbase + 0x74) = 0x0
+  set *(unsigned long *)($tlbbase + 0x7c) = 0x0
+  set *(unsigned long *)($tlbbase + 0x84) = 0x0
+  set *(unsigned long *)($tlbbase + 0x8c) = 0x0
+  set *(unsigned long *)($tlbbase + 0x94) = 0x0
+  set *(unsigned long *)($tlbbase + 0x9c) = 0x0
+  set *(unsigned long *)($tlbbase + 0xa4) = 0x0
+  set *(unsigned long *)($tlbbase + 0xac) = 0x0
+  set *(unsigned long *)($tlbbase + 0xb4) = 0x0
+  set *(unsigned long *)($tlbbase + 0xbc) = 0x0
+  set *(unsigned long *)($tlbbase + 0xc4) = 0x0
+  set *(unsigned long *)($tlbbase + 0xcc) = 0x0
+  set *(unsigned long *)($tlbbase + 0xd4) = 0x0
+  set *(unsigned long *)($tlbbase + 0xdc) = 0x0
+  set *(unsigned long *)($tlbbase + 0xe4) = 0x0
+  set *(unsigned long *)($tlbbase + 0xec) = 0x0
+  set *(unsigned long *)($tlbbase + 0xf4) = 0x0
+  set *(unsigned long *)($tlbbase + 0xfc) = 0x0
+end
+
+define load_modules
+  use_debug_dma
+  load
+end
+
+# Set kernel parameters
+define set_kernel_parameters
+  set $param = (void*)0x88002000
+  # INITRD_START
+#  set *(unsigned long *)($param + 0x0010) = 0x08300000
+  # INITRD_SIZE
+#  set *(unsigned long *)($param + 0x0014) = 0x00400000
+  # M32R_CPUCLK
+  set *(unsigned long *)($param + 0x0018) = 0d200000000
+  # M32R_BUSCLK
+  set *(unsigned long *)($param + 0x001c) = 0d50000000
+#  set *(unsigned long *)($param + 0x001c) = 0d25000000
+
+  # M32R_TIMER_DIVIDE
+  set *(unsigned long *)($param + 0x0020) = 0d128
+
+  set {char[0x200]}($param + 0x100) = "console=ttyD0,115200n8x\
+  root=/dev/nfsroot \
+  nfsroot=192.168.0.1:/project/m32r-linux/export/root.2.6 \
+  nfsaddrs=192.168.0.101:192.168.0.1:192.168.0.1:255.255.255.0:mappi001 \
+  mem=16m \0"
+end
+
+define boot
+  set_kernel_parameters
+  set $pc=0x88001000
+  set $fp=0
+  set $evb=0x88000000
+  # I/D-Cache ON
+
+# IPI
+#  set *(long *)0x00eff2f8 = 0x2
+  set $fp=0
+#  set *(unsigned long *)0xa0ef4000 = 0x100
+  si
+end
+
+# Show TLB entries
+define show_tlb_entries
+  set $i = 0
+  set $addr = $arg0
+  use_mon_code
+  while ($i < 0d32 )
+    set $tlb_tag = *(unsigned long*)$addr
+    set $tlb_data = *(unsigned long*)($addr + 4)
+    printf " [%2d] 0x%08lx : 0x%08lx - 0x%08lx\n", $i, $addr, $tlb_tag, $tlb_data
+    set $i = $i + 1
+    set $addr = $addr + 8
+  end
+#  use_debug_dma
+end
+define itlb
+  set $itlb=0xfe000000
+  show_tlb_entries $itlb
+end
+define dtlb
+  set $dtlb=0xfe000800
+  show_tlb_entries $dtlb
+end
+
+define show_regs
+  printf " R0[%08lx]   R1[%08lx]   R2[%08lx]   R3[%08lx]\n",$r0,$r1,$r2,$r3 
+  printf " R4[%08lx]   R5[%08lx]   R6[%08lx]   R7[%08lx]\n",$r4,$r5,$r6,$r7 
+  printf " R8[%08lx]   R9[%08lx]  R10[%08lx]  R11[%08lx]\n",$r8,$r9,$r10,$r11 
+  printf "R12[%08lx]   FP[%08lx]   LR[%08lx]   SP[%08lx]\n",$r12,$fp,$lr,$sp
+  printf "PSW[%08lx]  CBR[%08lx]  SPI[%08lx]  SPU[%08lx]\n",$psw,$cbr,$spi,$spu
+  printf "BPC[%08lx]   PC[%08lx] ACCL[%08lx] ACCH[%08lx]\n",$bpc,$pc,$accl,$acch
+  printf "EVB[%08lx]\n",$evb
+end
+
+define setup
+  debug_chaos
+  set *(unsigned long *)0xa0ef6004 = 0x0001053f
+  set *(unsigned long *)0xa0ef6028 = 0x00031102
+#  set *(unsigned long *)0xa0ef400c = 0x2
+end
+
+sdireset
+sdireset
+file vmlinux
+target m32rsdi
+set $pc=0x0
+b *0x30000
+c
+setup
+tlb_init
+load_modules
+#set *(long *)0xa0ef4000=0x101
+#set *(long *)0xa0ef400c=0x002
+
+boot
+#b tme_handler
+b *0x88000020
+
+
+
+
diff -ruN linux-2.6.7.org/include/asm-m32r/a.out.h linux-2.6.7/include/asm-m32r/a.out.h
--- linux-2.6.7.org/include/asm-m32r/a.out.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/a.out.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,28 @@
+#ifndef _ASM_M32R_A_OUT_H
+#define _ASM_M32R_A_OUT_H
+
+/* orig : i386 2.4.18 */
+
+struct exec
+{
+  unsigned long a_info;		/* Use macros N_MAGIC, etc for access */
+  unsigned a_text;		/* length of text, in bytes */
+  unsigned a_data;		/* length of data, in bytes */
+  unsigned a_bss;		/* length of uninitialized data area for file, in bytes */
+  unsigned a_syms;		/* length of symbol table data in file, in bytes */
+  unsigned a_entry;		/* start address */
+  unsigned a_trsize;		/* length of relocation info for text, in bytes */
+  unsigned a_drsize;		/* length of relocation info for data, in bytes */
+};
+
+#define N_TRSIZE(a)	((a).a_trsize)
+#define N_DRSIZE(a)	((a).a_drsize)
+#define N_SYMSIZE(a)	((a).a_syms)
+
+#ifdef __KERNEL__
+
+#define STACK_TOP	TASK_SIZE
+
+#endif
+
+#endif /* _ASM_M32R_A_OUT_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/addrspace.h linux-2.6.7/include/asm-m32r/addrspace.h
--- linux-2.6.7.org/include/asm-m32r/addrspace.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/addrspace.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,58 @@
+/* $Id$ */
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001 by Hiroyuki Kondo
+ *
+ * Defitions for the address spaces of the M32R CPUs.
+ */
+#ifndef __ASM_M32R_ADDRSPACE_H
+#define __ASM_M32R_ADDRSPACE_H
+
+/*
+ * Memory segments (32bit kernel mode addresses)
+ */
+#define KUSEG                   0x00000000
+#define KSEG0                   0x80000000
+#define KSEG1                   0xa0000000
+#define KSEG2                   0xc0000000
+#define KSEG3                   0xe0000000
+
+#define K0BASE  KSEG0
+
+/*
+ * Returns the kernel segment base of a given address
+ */
+#ifndef __ASSEMBLY__
+#define KSEGX(a)                (((unsigned long)(a)) & 0xe0000000)
+#else
+#define KSEGX(a)                ((a) & 0xe0000000)
+#endif
+
+/*
+ * Returns the physical address of a KSEG0/KSEG1 address
+ */
+#ifndef __ASSEMBLY__
+#define PHYSADDR(a)		(((unsigned long)(a)) & 0x1fffffff)
+#else
+#define PHYSADDR(a)		((a) & 0x1fffffff)
+#endif
+
+/*
+ * Map an address to a certain kernel segment
+ */
+#ifndef __ASSEMBLY__
+#define KSEG0ADDR(a)		((__typeof__(a))(((unsigned long)(a) & 0x1fffffff) | KSEG0))
+#define KSEG1ADDR(a)		((__typeof__(a))(((unsigned long)(a) & 0x1fffffff) | KSEG1))
+#define KSEG2ADDR(a)		((__typeof__(a))(((unsigned long)(a) & 0x1fffffff) | KSEG2))
+#define KSEG3ADDR(a)		((__typeof__(a))(((unsigned long)(a) & 0x1fffffff) | KSEG3))
+#else
+#define KSEG0ADDR(a)		(((a) & 0x1fffffff) | KSEG0)
+#define KSEG1ADDR(a)		(((a) & 0x1fffffff) | KSEG1)
+#define KSEG2ADDR(a)		(((a) & 0x1fffffff) | KSEG2)
+#define KSEG3ADDR(a)		(((a) & 0x1fffffff) | KSEG3)
+#endif
+
+#endif /* __ASM_M32R_ADDRSPACE_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/assembler.h linux-2.6.7/include/asm-m32r/assembler.h
--- linux-2.6.7.org/include/asm-m32r/assembler.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/assembler.h	2004-08-24 20:41:30.000000000 +0900
@@ -0,0 +1,212 @@
+#ifndef _ASM_M32R_ASSEMBLER_H
+#define _ASM_M32R_ASSEMBLER_H
+
+/* $Id$ */
+
+/*
+ * linux/asm-m32r/assembler.h
+ *
+ * This file contains M32R architecture specific defines.
+ *
+ * Do not include any C declarations in this file - it is included by
+ * assembler source.
+ */
+
+#include <linux/config.h>
+
+
+#undef ENTRY
+#define ENTRY(name) ENTRY_M name
+	.macro  ENTRY_M name
+	.global \name
+	ALIGN
+\name:
+	.endm
+
+/*
+ * LDIMM: load immediate value
+ *
+ * STI: enable interruption
+ * CLI: disable interruption
+ */
+
+#ifdef __ASSEMBLY__
+
+#define LDIMM(reg,x) LDIMM reg x
+	.macro LDIMM reg x
+	seth	\reg, #high(\x)
+	or3	\reg, \reg, #low(\x)
+	.endm
+
+#if !defined(CONFIG_CHIP_M32102)
+#define STI(reg) STI_M reg
+	.macro STI_M reg
+	setpsw  #0x40	    ->	nop
+	; WORKAROUND: "-> nop" is a workaround for the M32700(TS1).
+	.endm
+
+#define CLI(reg) CLI_M reg
+	.macro CLI_M reg
+	clrpsw  #0x40	    ->	nop
+	; WORKAROUND: "-> nop" is a workaround for the M32700(TS1).
+	.endm
+#else	/* CONFIG_CHIP_M32102 */
+#define STI(reg) STI_M reg
+	.macro STI_M reg
+	mvfc	\reg, psw
+	or3	\reg, \reg, #0x0040
+	mvtc	\reg, psw
+	.endm
+
+#define CLI(reg) CLI_M reg
+	.macro CLI_M reg
+	mvfc	\reg, psw
+	and3	\reg, \reg, #0xffbf
+	mvtc	\reg, psw
+	.endm
+#endif	/* CONFIG_CHIP_M32102 */
+
+	.macro	SAVE_ALL
+	push	r0		; orig_r0
+	push	sp		; spi (r15)
+	push	lr		; r14
+	push	r13
+	mvfc	r13, cr3	; spu
+	push	r13
+	mvfc	r13, bbpc
+	push	r13
+	mvfc	r13, bbpsw
+	push	r13
+	mvfc	r13, bpc
+	push	r13
+	mvfc	r13, psw
+	push	r13
+#if defined(CONFIG_ISA_M32R2) && defined(CONFIG_ISA_DSP_LEVEL2)
+	mvfaclo	r13, a1
+	push	r13
+	mvfachi r13, a1
+	push	r13
+	mvfaclo	r13, a0
+	push	r13
+	mvfachi	r13, a0
+	push	r13
+#elif defined(CONFIG_ISA_M32R2) || defined(CONFIG_ISA_M32R)
+	mvfaclo	r13
+	push	r13
+	mvfachi	r13
+	push	r13
+#else
+#error unknown isa configuration 
+#endif
+	ldi	r13, #-1
+	push	r13		; syscall_nr (default: -1)
+	push	r12
+	push	r11
+	push	r10
+	push	r9
+	push	r8
+	push	r7
+	push	r3
+	push	r2
+	push	r1
+	push	r0
+	addi	sp, #-4		; room for implicit pt_regs parameter
+	push	r6
+	push	r5
+	push	r4
+	.endm
+
+	.macro	RESTORE_ALL
+	pop	r4
+	pop	r5
+	pop	r6
+	addi	sp, #4
+	pop	r0
+	pop	r1
+	pop	r2
+	pop	r3
+	pop	r7
+	pop	r8
+	pop	r9
+	pop	r10
+	pop	r11
+	pop	r12
+	addi	r15, #4		; Skip syscall number
+#if defined(CONFIG_ISA_M32R2) && defined(CONFIG_ISA_DSP_LEVEL2)
+	pop	r13
+	mvtachi	r13, a0
+	pop	r13
+	mvtaclo	r13, a0
+	pop	r13
+	mvtachi	r13, a1
+	pop	r13
+	mvtaclo	r13, a1
+#elif defined(CONFIG_ISA_M32R2) || defined(CONFIG_ISA_M32R)
+	pop	r13
+	mvtachi	r13
+	pop	r13
+	mvtaclo	r13
+#else
+#error unknown isa configuration 
+#endif
+	pop	r14
+	mvtc	r14, psw
+	pop	r14
+	mvtc	r14, bpc
+	addi	sp, #8		; Skip bbpsw, bbpc
+	pop	r14
+	mvtc	r14, cr3	; spu
+	pop	r13
+	pop	lr		; r14
+	pop	sp		; spi (r15)
+	addi	sp, #4		; Skip orig_r0
+	.fillinsn
+1:	rte
+	.section .fixup,"ax"
+2:	bl	do_exit
+	.previous
+	.section __ex_table,"a"
+	ALIGN
+	.long	1b, 2b
+	.previous
+	.endm
+
+#define GET_CURRENT(reg)  get_current reg
+	.macro get_current reg
+	ldi  \reg, #-8192
+	and  \reg, sp
+	.endm
+
+#if !defined(CONFIG_CHIP_M32102) 
+	.macro	SWITCH_TO_KERNEL_STACK
+	; switch to kernel stack (spi)
+	clrpsw	#0x80	    ->	nop
+	.endm
+#else	/* CONFIG_CHIP_M32102 */
+	.macro	SWITCH_TO_KERNEL_STACK
+	push	r0		; save r0 for working
+	mvfc	r0, psw
+	and3	r0, r0, #0x00ff7f
+	mvtc	r0, psw
+	slli	r0, #16
+	bltz	r0, 1f		; check BSM-bit
+;
+	;; called from kernel context: previous stack = spi
+	pop	r0		; retrieve r0
+	bra	2f
+	.fillinsn
+1:	
+	;; called from user context: previous stack = spu
+	mvfc	r0, cr3		; spu
+	addi	r0, #4
+	mvtc	r0, cr3		; spu
+	ld	r0, @(-4,r0)	; retrieve r0
+	.fillinsn
+2:	
+	.endm
+#endif	/* CONFIG_CHIP_M32102 */
+
+#endif	/* __ASSEMBLY__ */
+
+#endif	/* _ASM_M32R_ASSEMBLER_H */
+
diff -ruN linux-2.6.7.org/include/asm-m32r/atomic.h linux-2.6.7/include/asm-m32r/atomic.h
--- linux-2.6.7.org/include/asm-m32r/atomic.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/atomic.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,337 @@
+#ifndef _ASM_M32R_ATOMIC_H
+#define _ASM_M32R_ATOMIC_H
+
+/* $Id$ */
+
+/*  
+ *  linux/include/asm-m32r/atomic.h
+ *    orig : i386 2.4.10
+ *  
+ *  M32R version: 
+ *    Copyright (C) 2001, 2002  Hitoshi Yamamoto
+ */
+
+#include <linux/config.h>
+#include <asm/system.h>
+
+/*
+ * Atomic operations that C can't guarantee us.  Useful for
+ * resource counting etc..
+ */
+
+#undef LOAD
+#undef STORE
+#ifdef CONFIG_SMP
+#define LOAD	"lock"
+#define STORE	"unlock"
+#else
+#define LOAD	"ld"
+#define STORE	"st"
+#endif
+
+/*
+ * Make sure gcc doesn't try to be clever and move things around
+ * on us. We need to use _exactly_ the address the user gave us,
+ * not some alias that contains the same information.
+ */
+typedef struct { volatile int counter; } atomic_t;
+
+#define ATOMIC_INIT(i)	{ (i) }
+
+/**
+ * atomic_read - read atomic variable
+ * @v: pointer of type atomic_t
+ * 
+ * Atomically reads the value of @v.  Note that the guaranteed
+ * useful range of an atomic_t is only 24 bits.
+ */ 
+#define atomic_read(v)	((v)->counter)
+
+/**
+ * atomic_set - set atomic variable
+ * @v: pointer of type atomic_t
+ * @i: required value
+ * 
+ * Atomically sets the value of @v to @i.  Note that the guaranteed
+ * useful range of an atomic_t is only 24 bits.
+ */ 
+#define atomic_set(v,i)	(((v)->counter) = (i))
+
+/**
+ * atomic_add - add integer to atomic variable
+ * @i: integer value to add
+ * @v: pointer of type atomic_t
+ * 
+ * Atomically adds @i to @v.  Note that the guaranteed useful range
+ * of an atomic_t is only 24 bits.
+ */
+static __inline__ void atomic_add(int i, atomic_t *v)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		"# atomic_add			\n\t"
+		DCACHE_CLEAR("r4", "r5", "%0")
+		LOAD"	r4, @%0;		\n\t"
+		"add	r4, %1;			\n\t"
+		STORE"	r4, @%0;		\n\t"
+		: /* no outputs */ 
+		: "r" (&v->counter), "r" (i)
+		: "memory", "r4"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r5"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+	local_irq_restore(flags);
+}
+
+/**
+ * atomic_sub - subtract the atomic variable
+ * @i: integer value to subtract
+ * @v: pointer of type atomic_t
+ * 
+ * Atomically subtracts @i from @v.  Note that the guaranteed
+ * useful range of an atomic_t is only 24 bits.
+ */
+static __inline__ void atomic_sub(int i, atomic_t *v)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		"# atomic_sub			\n\t"
+		DCACHE_CLEAR("r4", "r5", "%0")
+		LOAD"	r4, @%0;		\n\t"
+		"sub	r4, %1;			\n\t"
+		STORE"	r4, @%0;		\n\t"
+		: /* no outputs */
+		: "r" (&v->counter), "r" (i)
+		: "memory", "r4"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r5"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+	local_irq_restore(flags);
+}
+
+/**
+ * atomic_sub_and_test - subtract value from variable and test result
+ * @i: integer value to subtract
+ * @v: pointer of type atomic_t
+ * 
+ * Atomically subtracts @i from @v and returns
+ * true if the result is zero, or false for all
+ * other cases.  Note that the guaranteed
+ * useful range of an atomic_t is only 24 bits.
+ */
+static __inline__ int atomic_sub_and_test(int i, atomic_t *v)
+{
+	unsigned long flags;
+	int result;
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		"# atomic_sub_and_test		\n\t"
+		DCACHE_CLEAR("%0", "r4", "%1")
+		LOAD"	%0, @%1;		\n\t"
+		"sub	%0, %2;			\n\t"
+		STORE"	%0, @%1;		\n\t"
+		: "=&r" (result)
+		: "r" (&v->counter), "r" (i)
+		: "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r4"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+	local_irq_restore(flags);
+	
+	return (result == 0);
+}
+
+/**
+ * atomic_inc - increment atomic variable
+ * @v: pointer of type atomic_t
+ * 
+ * Atomically increments @v by 1.  Note that the guaranteed
+ * useful range of an atomic_t is only 24 bits.
+ */ 
+static __inline__ void atomic_inc(atomic_t *v)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		"# atomic_inc			\n\t"
+		DCACHE_CLEAR("r4", "r5", "%0")
+		LOAD"	r4, @%0; 		\n\t"
+		"addi	r4, #1;			\n\t"
+		STORE"	r4, @%0;		\n\t"
+		: /* no outputs */
+		: "r" (&v->counter)
+		: "memory", "r4"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r5"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+	local_irq_restore(flags);
+}
+
+/**
+ * atomic_dec - decrement atomic variable
+ * @v: pointer of type atomic_t
+ * 
+ * Atomically decrements @v by 1.  Note that the guaranteed
+ * useful range of an atomic_t is only 24 bits.
+ */ 
+static __inline__ void atomic_dec(atomic_t *v)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		"# atomic_dec			\n\t"
+		DCACHE_CLEAR("r4", "r5", "%0")
+		LOAD"	r4, @%0;		\n\t"
+		"addi	r4, #-1;		\n\t"
+		STORE"	r4, @%0;		\n\t"
+		: /* no outputs */
+		: "r" (&v->counter)
+		: "memory", "r4"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r5"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+	local_irq_restore(flags);
+}
+
+/**
+ * atomic_dec_and_test - decrement and test
+ * @v: pointer of type atomic_t
+ * 
+ * Atomically decrements @v by 1 and
+ * returns true if the result is 0, or false for all other
+ * cases.  Note that the guaranteed
+ * useful range of an atomic_t is only 24 bits.
+ */ 
+static __inline__ int atomic_dec_and_test(atomic_t *v)
+{
+	unsigned long flags;
+	int result;
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		"# atomic_dec_and_test		\n\t"
+		DCACHE_CLEAR("%0", "r4", "%1")
+		LOAD"	%0, @%1;		\n\t"
+		"addi	%0, #-1;		\n\t"
+		STORE"	%0, @%1;		\n\t"
+		: "=&r" (result)
+		: "r" (&v->counter)
+		: "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r4"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+	local_irq_restore(flags);
+
+	return (result == 0);
+}
+
+/**
+ * atomic_inc_and_test - increment and test 
+ * @v: pointer of type atomic_t
+ * 
+ * Atomically increments @v by 1
+ * and returns true if the result is zero, or false for all
+ * other cases.  Note that the guaranteed
+ * useful range of an atomic_t is only 24 bits.
+ */ 
+static __inline__ int atomic_inc_and_test(atomic_t *v)
+{
+	unsigned long flags;
+	int result;
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		"# atomic_dec_and_test		\n\t"
+		DCACHE_CLEAR("%0", "r4", "%1")
+		LOAD"	%0, @%1;		\n\t"
+		"addi	%0, #1;			\n\t"
+		STORE"	%0, @%1;		\n\t"
+		: "=&r" (result)
+		: "r" (&v->counter)
+		: "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r4"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+	local_irq_restore(flags);
+
+	return (result == 0);
+}
+
+/**
+ * atomic_add_negative - add and test if negative
+ * @v: pointer of type atomic_t
+ * @i: integer value to add
+ * 
+ * Atomically adds @i to @v and returns true
+ * if the result is negative, or false when
+ * result is greater than or equal to zero.  Note that the guaranteed
+ * useful range of an atomic_t is only 24 bits.
+ */ 
+static __inline__ int atomic_add_negative(int i, atomic_t *v)
+{
+	unsigned long flags;
+	int result;
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		"# atomic_add_negative		\n\t"
+		DCACHE_CLEAR("%0", "r4", "%1")
+		LOAD"	%0, @%1;		\n\t"
+		"add	%0, %2;			\n\t"
+		STORE"	%0, @%1;		\n\t"
+		: "=&r" (result)
+		: "r" (&v->counter), "r" (i)
+		: "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r4"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+	local_irq_restore(flags);
+
+	return (result < 0);
+}
+
+/* These are x86-specific, used by some header files */
+static __inline__ void atomic_set_mask(unsigned long  mask, atomic_t *addr)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		"# atomic_set_mask		\n\t"
+		DCACHE_CLEAR("r4", "r5", "%0")
+		LOAD"	r4, @%0;		\n\t"
+		"or	r4, %1;			\n\t"
+		STORE"	r4, @%0;		\n\t"
+		: /* no outputs */
+		: "r" (addr), "r" (mask)
+		: "memory", "r4"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r5"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+	local_irq_restore(flags);
+}
+
+/* Atomic operations are already serializing on x86 */
+#define smp_mb__before_atomic_dec()	barrier()
+#define smp_mb__after_atomic_dec()	barrier()
+#define smp_mb__before_atomic_inc()	barrier()
+#define smp_mb__after_atomic_inc()	barrier()
+
+#endif	/* _ASM_M32R_ATOMIC_H */
+
diff -ruN linux-2.6.7.org/include/asm-m32r/bitops.h linux-2.6.7/include/asm-m32r/bitops.h
--- linux-2.6.7.org/include/asm-m32r/bitops.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/bitops.h	2004-05-19 18:53:48.000000000 +0900
@@ -0,0 +1,712 @@
+#ifndef _ASM_M32R_BITOPS_H
+#define _ASM_M32R_BITOPS_H
+
+/* $Id$ */
+
+/*  
+ *  linux/include/asm-m32r/bitops.h
+ *    orig : i386 2.4.10
+ *  
+ *  Copyright 1992, Linus Torvalds.
+ *  
+ *  M32R version: 
+ *    Copyright (C) 2001, 2002  Hitoshi Yamamoto
+ *    Copyright (C) 2004  Hirokazu Takata
+ */
+
+#include <linux/config.h>
+#include <linux/compiler.h>
+#include <asm/system.h>
+#include <asm/byteorder.h>
+#include <asm/types.h>
+
+/*
+ * These have to be done with inline assembly: that way the bit-setting
+ * is guaranteed to be atomic. All bit operations return 0 if the bit
+ * was cleared before the operation and != 0 if it was not.
+ *
+ * bit 0 is the LSB of addr; bit 32 is the LSB of (addr+1).
+ */
+
+#undef LOAD
+#undef STORE
+#ifdef CONFIG_SMP
+#define LOAD	"lock"
+#define STORE	"unlock"
+#else
+#define LOAD	"ld"
+#define STORE	"st"
+#endif
+
+/* #define ADDR (*(volatile long *) addr) */
+
+/**
+ * set_bit - Atomically set a bit in memory
+ * @nr: the bit to set
+ * @addr: the address to start counting from
+ *
+ * This function is atomic and may not be reordered.  See __set_bit()
+ * if you do not require the atomic guarantees.
+ * Note that @nr may be almost arbitrarily large; this function is not
+ * restricted to acting on a single-word quantity.
+ */
+static __inline__ void set_bit(int nr, volatile void * addr)
+{
+	__u32 mask;
+	volatile __u32 *a = addr;
+        unsigned long  flags;
+
+	a += (nr >> 5);
+	mask = (1 << (nr & 0x1F));
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		DCACHE_CLEAR("r4", "r6", "%0")
+		LOAD"	r4, @%0;		\n\t"
+		"or	r4, %1;			\n\t"
+		STORE"	r4, @%0;		\n\t"
+		: /* no outputs */
+		: "r" (a), "r" (mask)
+		: "memory", "r4"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r6"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+	local_irq_restore(flags);
+}
+
+/**
+ * __set_bit - Set a bit in memory
+ * @nr: the bit to set
+ * @addr: the address to start counting from
+ *
+ * Unlike set_bit(), this function is non-atomic and may be reordered.
+ * If it's called on the same region of memory simultaneously, the effect
+ * may be that only one operation succeeds.
+ */
+static __inline__ void __set_bit(int nr, volatile void * addr)
+{
+	__u32 mask;
+	volatile __u32 *a = addr;
+
+	a += (nr >> 5);
+	mask = (1 << (nr & 0x1F));
+	*a |= mask;
+}
+
+/**
+ * clear_bit - Clears a bit in memory
+ * @nr: Bit to clear
+ * @addr: Address to start counting from
+ *
+ * clear_bit() is atomic and may not be reordered.  However, it does
+ * not contain a memory barrier, so if it is used for locking purposes,
+ * you should call smp_mb__before_clear_bit() and/or smp_mb__after_clear_bit()
+ * in order to ensure changes are visible on other processors.
+ */
+static __inline__ void clear_bit(int nr, volatile void * addr)
+{
+	__u32 mask;
+	volatile __u32 *a = addr;
+        unsigned long  flags;
+
+	a += (nr >> 5);
+	mask = (1 << (nr & 0x1F));
+
+	local_irq_save(flags);
+
+	__asm__ __volatile__ (
+		DCACHE_CLEAR("r4", "r6", "%0")
+		LOAD"	r4, @%0;		\n\t"
+		"and	r4, %1;			\n\t"
+		STORE"	r4, @%0;		\n\t"
+		: /* no outputs */
+		: "r" (a), "r" (~mask)
+		: "memory", "r4"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r6"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+	local_irq_restore(flags);
+}
+
+static __inline__ void __clear_bit(int nr, volatile unsigned long * addr)
+{
+	unsigned long mask;
+	volatile unsigned long *a = addr;
+
+	a += (nr >> 5);
+	mask = (1 << (nr & 0x1F));
+	*a &= ~mask;
+}
+
+#define smp_mb__before_clear_bit()	barrier()
+#define smp_mb__after_clear_bit()	barrier()
+
+/**
+ * __change_bit - Toggle a bit in memory
+ * @nr: the bit to set
+ * @addr: the address to start counting from
+ *
+ * Unlike change_bit(), this function is non-atomic and may be reordered.
+ * If it's called on the same region of memory simultaneously, the effect
+ * may be that only one operation succeeds.
+ */
+static __inline__ void __change_bit(int nr, volatile void * addr)
+{
+	__u32 mask;
+	volatile __u32 *a = addr;
+
+	a += (nr >> 5);
+	mask = (1 << (nr & 0x1F));
+	*a ^= mask;
+}
+
+/**
+ * change_bit - Toggle a bit in memory
+ * @nr: Bit to clear
+ * @addr: Address to start counting from
+ *
+ * change_bit() is atomic and may not be reordered.
+ * Note that @nr may be almost arbitrarily large; this function is not
+ * restricted to acting on a single-word quantity.
+ */
+static __inline__ void change_bit(int nr, volatile void * addr)
+{
+	__u32  mask;
+	volatile __u32  *a = addr;
+        unsigned long  flags;
+	
+	a += (nr >> 5);
+	mask = (1 << (nr & 0x1F));
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		DCACHE_CLEAR("r4", "r6", "%0")
+		LOAD"	r4, @%0;		\n\t"
+		"xor	r4, %1;			\n\t"
+		STORE"	r4, @%0;		\n\t"
+		: /* no outputs */
+		: "r" (a), "r" (mask)
+		: "memory", "r4"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r6"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+	local_irq_restore(flags);
+}
+
+/**
+ * test_and_set_bit - Set a bit and return its old value
+ * @nr: Bit to set
+ * @addr: Address to count from
+ *
+ * This operation is atomic and cannot be reordered.  
+ * It also implies a memory barrier.
+ */
+static __inline__ int test_and_set_bit(int nr, volatile void * addr)
+{
+	__u32 mask, oldbit;
+	volatile __u32 *a = addr;
+        unsigned long  flags;
+
+	a += (nr >> 5);
+	mask = (1 << (nr & 0x1F));
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		DCACHE_CLEAR("%0", "r4", "%1")
+		LOAD"	%0, @%1;		\n\t"
+		"mv	r4, %0;			\n\t"
+		"and	%0, %2;			\n\t"
+		"or	r4, %2;			\n\t"
+		STORE"	r4, @%1;		\n\t"
+		: "=&r" (oldbit)
+		: "r" (a), "r" (mask)
+		: "memory", "r4"
+	);
+	local_irq_restore(flags);
+	return (oldbit != 0);
+}
+
+/**
+ * __test_and_set_bit - Set a bit and return its old value
+ * @nr: Bit to set
+ * @addr: Address to count from
+ *
+ * This operation is non-atomic and can be reordered.  
+ * If two examples of this operation race, one can appear to succeed
+ * but actually fail.  You must protect multiple accesses with a lock.
+ */
+static __inline__ int __test_and_set_bit(int nr, volatile void * addr)
+{
+	__u32 mask, oldbit;
+	volatile __u32 *a = addr;
+
+	a += (nr >> 5);
+	mask = (1 << (nr & 0x1F));
+	oldbit = (*a & mask);
+	*a |= mask;
+
+	return (oldbit != 0);
+}
+
+/**
+ * test_and_clear_bit - Clear a bit and return its old value
+ * @nr: Bit to set
+ * @addr: Address to count from
+ *
+ * This operation is atomic and cannot be reordered.  
+ * It also implies a memory barrier.
+ */
+static __inline__ int test_and_clear_bit(int nr, volatile void * addr)
+{
+	__u32 mask, oldbit;
+	volatile __u32 *a = addr;
+        unsigned long  flags;
+
+	a += (nr >> 5);
+	mask = (1 << (nr & 0x1F));
+
+	local_irq_save(flags);
+
+	__asm__ __volatile__ (
+		DCACHE_CLEAR("%0", "r4", "%2")
+		LOAD"	%0, @%2;		\n\t"
+                "mv      r4, %0; \n\t"
+                "and     %0, %1; \n\t"
+                "not     %1, %1; \n\t"
+                "and     r4, %1; \n\t"
+		STORE"	r4, @%2;		\n\t"
+		: "=&r" (oldbit), "+r" (mask)
+		: "r" (a)
+		: "memory", "r4"
+	);
+	local_irq_restore(flags);
+
+	return (oldbit != 0);
+}
+
+/**
+ * __test_and_clear_bit - Clear a bit and return its old value
+ * @nr: Bit to set
+ * @addr: Address to count from
+ *
+ * This operation is non-atomic and can be reordered.  
+ * If two examples of this operation race, one can appear to succeed
+ * but actually fail.  You must protect multiple accesses with a lock.
+ */
+static __inline__ int __test_and_clear_bit(int nr, volatile void * addr)
+{
+	__u32 mask, oldbit;
+	volatile __u32 *a = addr;
+
+	a += (nr >> 5);
+	mask = (1 << (nr & 0x1F));
+	oldbit = (*a & mask);
+	*a &= ~mask;
+
+	return (oldbit != 0);
+}
+
+/* WARNING: non atomic and it can be reordered! */
+static __inline__ int __test_and_change_bit(int nr, volatile void * addr)
+{
+	__u32 mask, oldbit;
+	volatile __u32 *a = addr;
+
+	a += (nr >> 5);
+	mask = (1 << (nr & 0x1F));
+	oldbit = (*a & mask);
+	*a ^= mask;
+
+	return (oldbit != 0);
+}
+
+/**
+ * test_and_change_bit - Change a bit and return its old value
+ * @nr: Bit to set
+ * @addr: Address to count from
+ *
+ * This operation is atomic and cannot be reordered.  
+ * It also implies a memory barrier.
+ */
+static __inline__ int test_and_change_bit(int nr, volatile void * addr)
+{
+	__u32 mask, oldbit;
+	volatile __u32 *a = addr;
+        unsigned long  flags;
+
+	a += (nr >> 5);
+	mask = (1 << (nr & 0x1F));
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		DCACHE_CLEAR("%0", "r4", "%1")
+		LOAD"	%0, @%1;		\n\t"
+		"mv	r4, %0;			\n\t"
+		"and	%0, %2;			\n\t"
+		"xor	r4, %2;			\n\t"
+		STORE"	r4, @%1;		\n\t"
+		: "=&r" (oldbit)
+		: "r" (a), "r" (mask)
+		: "memory", "r4"
+	);
+	local_irq_restore(flags);
+	return (oldbit != 0);
+}
+
+#if 0 /* Fool kernel-doc since it doesn't do macros yet */
+/**
+ * test_bit - Determine whether a bit is set
+ * @nr: bit number to test
+ * @addr: Address to start counting from
+ */
+static int test_bit(int nr, const volatile void * addr);
+#endif
+
+static __inline__ int test_bit(int nr, const volatile void * addr)
+{
+	__u32 mask;
+	const volatile __u32 *a = addr;
+
+	a += (nr >> 5);
+	mask = (1 << (nr & 0x1F));
+
+	return ((*a & mask) != 0);
+}
+
+/**
+ * ffz - find first zero in word.
+ * @word: The word to search
+ *
+ * Undefined if no zero exists, so code should check against ~0UL first.
+ */
+static __inline__ unsigned long ffz(unsigned long word)
+{
+	int k;
+
+	word = ~word;
+	k = 0;
+	if (!(word & 0x0000ffff)) { k += 16; word >>= 16; }
+	if (!(word & 0x000000ff)) { k += 8; word >>= 8; }
+	if (!(word & 0x0000000f)) { k += 4; word >>= 4; }
+	if (!(word & 0x00000003)) { k += 2; word >>= 2; }
+	if (!(word & 0x00000001)) { k += 1; }
+
+	return k;
+}
+
+/**
+ * find_first_zero_bit - find the first zero bit in a memory region
+ * @addr: The address to start the search at
+ * @size: The maximum size to search
+ *
+ * Returns the bit-number of the first zero bit, not the number of the byte
+ * containing a bit.
+ */
+
+#define find_first_zero_bit(addr, size) \
+        find_next_zero_bit((addr), (size), 0)
+
+/**
+ * find_next_zero_bit - find the first zero bit in a memory region
+ * @addr: The address to base the search on
+ * @offset: The bitnumber to start searching at
+ * @size: The maximum size to search
+ */
+static __inline__ int find_next_zero_bit(void *addr, int size, int offset)
+{
+	unsigned long *p = ((unsigned long *) addr) + (offset >> 5);
+	unsigned long result = offset & ~31UL;
+	unsigned long tmp;
+
+	if (offset >= size)
+		return size;
+	size -= result;
+	offset &= 31UL;
+	if (offset) {
+		tmp = *(p++);
+		tmp |= ~0UL >> (32-offset);
+		if (size < 32)
+			goto found_first;
+		if (~tmp)
+			goto found_middle;
+		size -= 32;
+		result += 32;
+	}
+	while (size & ~31UL) {
+		if (~(tmp = *(p++)))
+			goto found_middle;
+		result += 32;
+		size -= 32;
+	}
+	if (!size)
+		return result;
+	tmp = *p;
+
+found_first:
+	tmp |= ~0UL << size;
+found_middle:
+	return result + ffz(tmp);
+}
+
+/**
+ * __ffs - find first bit in word.
+ * @word: The word to search
+ *
+ * Undefined if no bit exists, so code should check against 0 first.
+ */
+static __inline__ unsigned long __ffs(unsigned long word)
+{
+	int k = 0;
+
+	if (!(word & 0x0000ffff)) { k += 16; word >>= 16; }
+	if (!(word & 0x000000ff)) { k += 8; word >>= 8; }
+	if (!(word & 0x0000000f)) { k += 4; word >>= 4; }
+	if (!(word & 0x00000003)) { k += 2; word >>= 2; }
+	if (!(word & 0x00000001)) { k += 1;}
+
+	return k;
+}
+
+/*
+ * fls: find last bit set.
+ */
+#define fls(x) generic_fls(x)
+
+#ifdef __KERNEL__
+
+/*
+ * Every architecture must define this function. It's the fastest
+ * way of searching a 140-bit bitmap where the first 100 bits are
+ * unlikely to be set. It's guaranteed that at least one of the 140
+ * bits is cleared.
+ */
+static __inline__ int sched_find_first_bit(unsigned long *b)
+{
+	if (unlikely(b[0]))
+		return __ffs(b[0]);
+	if (unlikely(b[1]))
+		return __ffs(b[1]) + 32;
+	if (unlikely(b[2]))
+		return __ffs(b[2]) + 64;
+	if (b[3])
+		return __ffs(b[3]) + 96;
+	return __ffs(b[4]) + 128;
+}
+
+/**
+ * find_next_bit - find the first set bit in a memory region
+ * @addr: The address to base the search on
+ * @offset: The bitnumber to start searching at
+ * @size: The maximum size to search
+ */
+static __inline__ unsigned long find_next_bit(unsigned long *addr,
+	unsigned long size, unsigned long offset)
+{
+	unsigned int *p = ((unsigned int *) addr) + (offset >> 5);
+	unsigned int result = offset & ~31UL;
+	unsigned int tmp;
+
+	if (offset >= size)
+		return size;
+	size -= result;
+	offset &= 31UL;
+	if (offset) {
+		tmp = *p++;
+		tmp &= ~0UL << offset;
+		if (size < 32)
+			goto found_first;
+		if (tmp)
+			goto found_middle;
+		size -= 32;
+		result += 32;
+	}
+	while (size >= 32) {
+		if ((tmp = *p++) != 0)
+			goto found_middle;
+		result += 32;
+		size -= 32;
+	}
+	if (!size)
+		return result;
+	tmp = *p;
+
+found_first:
+	tmp &= ~0UL >> (32 - size);
+	if (tmp == 0UL)        /* Are any bits set? */
+		return result + size; /* Nope. */
+found_middle:
+	return result + __ffs(tmp);
+}
+
+/**
+ * find_first_bit - find the first set bit in a memory region
+ * @addr: The address to start the search at
+ * @size: The maximum size to search
+ *
+ * Returns the bit-number of the first set bit, not the number of the byte
+ * containing a bit.
+ */
+#define find_first_bit(addr, size) \
+	find_next_bit((addr), (size), 0)
+
+/**
+ * ffs - find first bit set
+ * @x: the word to search
+ *
+ * This is defined the same way as
+ * the libc and compiler builtin ffs routines, therefore
+ * differs in spirit from the above ffz (man ffs).
+ */
+#define ffs(x)	generic_ffs(x)
+
+/**
+ * hweightN - returns the hamming weight of a N-bit word
+ * @x: the word to weigh
+ *
+ * The Hamming Weight of a number is the total number of bits set in it.
+ */
+
+#define hweight32(x)	generic_hweight32(x)
+#define hweight16(x)	generic_hweight16(x)
+#define hweight8(x)	generic_hweight8(x)
+
+#endif /* __KERNEL__ */
+
+#ifdef __KERNEL__
+
+/* 
+ * ext2_XXXX function
+ * orig: include/asm-sh/bitops.h
+ */
+
+#ifdef __LITTLE_ENDIAN__
+#define ext2_set_bit			test_and_set_bit
+#define ext2_clear_bit			__test_and_clear_bit
+#define ext2_test_bit			test_bit
+#define ext2_find_first_zero_bit	find_first_zero_bit
+#define ext2_find_next_zero_bit		find_next_zero_bit
+#else
+static __inline__ int ext2_set_bit(int nr, volatile void * addr)
+{
+	__u8 mask, oldbit;
+	volatile __u8 *a = addr;
+
+	a += (nr >> 3);
+	mask = (1 << (nr & 0x07));
+	oldbit = (*a & mask);
+	*a |= mask;
+
+	return (oldbit != 0);
+}
+
+static __inline__ int ext2_clear_bit(int nr, volatile void * addr)
+{
+	__u8 mask, oldbit;
+	volatile __u8 *a = addr;
+
+	a += (nr >> 3);
+	mask = (1 << (nr & 0x07));
+	oldbit = (*a & mask);
+	*a &= ~mask;
+
+	return (oldbit != 0);
+}
+
+static __inline__ int ext2_test_bit(int nr, const volatile void * addr)
+{
+	__u32 mask;
+	const volatile __u8 *a = addr;
+
+	a += (nr >> 3);
+	mask = (1 << (nr & 0x07));
+
+	return ((mask & *a) != 0);
+}
+
+#define ext2_find_first_zero_bit(addr, size) \
+	ext2_find_next_zero_bit((addr), (size), 0)
+
+static __inline__ unsigned long ext2_find_next_zero_bit(void *addr, 
+	unsigned long size, unsigned long offset)
+{
+	unsigned long *p = ((unsigned long *) addr) + (offset >> 5);
+	unsigned long result = offset & ~31UL;
+	unsigned long tmp;
+
+	if (offset >= size)
+		return size;
+	size -= result;
+	offset &= 31UL;
+	if(offset) {
+		/* We hold the little endian value in tmp, but then the
+		 * shift is illegal. So we could keep a big endian value
+		 * in tmp, like this:
+		 *
+		 * tmp = __swab32(*(p++));
+		 * tmp |= ~0UL >> (32-offset);
+		 *
+		 * but this would decrease preformance, so we change the
+		 * shift:
+		 */
+		tmp = *(p++);
+		tmp |= __swab32(~0UL >> (32-offset));
+		if(size < 32)
+			goto found_first;
+		if(~tmp)
+			goto found_middle;
+		size -= 32;
+		result += 32;
+	}
+	while(size & ~31UL) {
+		if(~(tmp = *(p++)))
+			goto found_middle;
+		result += 32;
+		size -= 32;
+	}
+	if(!size)
+		return result;
+	tmp = *p;
+
+found_first:
+	/* tmp is little endian, so we would have to swab the shift,
+	 * see above. But then we have to swab tmp below for ffz, so
+	 * we might as well do this here.
+	 */
+	return result + ffz(__swab32(tmp) | (~0UL << size));
+found_middle:
+	return result + ffz(__swab32(tmp));
+}
+#endif
+
+#define ext2_set_bit_atomic(lock, nr, addr)		\
+	({						\
+		int ret;				\
+		spin_lock(lock);			\
+		ret = ext2_set_bit((nr), (addr));	\
+		spin_unlock(lock);			\
+		ret;					\
+	})
+
+#define ext2_clear_bit_atomic(lock, nr, addr)		\
+	({						\
+		int ret;				\
+		spin_lock(lock);			\
+		ret = ext2_clear_bit((nr), (addr));	\
+		spin_unlock(lock);			\
+		ret;					\
+	})
+
+/* Bitmap functions for the minix filesystem.  */
+#define minix_test_and_set_bit(nr,addr)		__test_and_set_bit(nr,addr)
+#define minix_set_bit(nr,addr)			__set_bit(nr,addr)
+#define minix_test_and_clear_bit(nr,addr)	__test_and_clear_bit(nr,addr)
+#define minix_test_bit(nr,addr) test_bit(nr,addr)
+#define minix_find_first_zero_bit(addr,size)	find_first_zero_bit(addr,size)
+
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_M32R_BITOPS_H */
+
diff -ruN linux-2.6.7.org/include/asm-m32r/bug.h linux-2.6.7/include/asm-m32r/bug.h
--- linux-2.6.7.org/include/asm-m32r/bug.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/bug.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,22 @@
+#ifndef _M32R_BUG_H
+#define _M32R_BUG_H
+
+#define BUG()	do { \
+	printk("kernel BUG at %s:%d!\n", __FILE__, __LINE__); \
+} while (0)
+
+#define PAGE_BUG(page)	do { BUG(); } while (0)
+
+#define BUG_ON(condition) \
+	do { if (unlikely((condition)!=0)) BUG(); } while(0)
+
+#define WARN_ON(condition) do { \
+	if (unlikely((condition)!=0)) { \
+		printk("Badness in %s at %s:%d\n", __FUNCTION__, \
+		__FILE__, __LINE__); \
+		dump_stack(); \
+	} \
+} while (0)
+
+#endif /* _M32R_BUG_H */
+
diff -ruN linux-2.6.7.org/include/asm-m32r/bugs.h linux-2.6.7/include/asm-m32r/bugs.h
--- linux-2.6.7.org/include/asm-m32r/bugs.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/bugs.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,21 @@
+#ifndef _ASM_M32R_BUGS_H
+#define _ASM_M32R_BUGS_H
+
+/* $Id$ */
+
+/*
+ * This is included by init/main.c to check for architecture-dependent bugs.
+ *
+ * Needs:
+ *     void check_bugs(void);
+ */
+#include <asm/processor.h>
+  
+static void __init check_bugs(void)
+{
+	extern unsigned long loops_per_jiffy;
+ 
+	current_cpu_data.loops_per_jiffy = loops_per_jiffy;
+}
+  
+#endif  /* _ASM_M32R_BUGS_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/byteorder.h linux-2.6.7/include/asm-m32r/byteorder.h
--- linux-2.6.7.org/include/asm-m32r/byteorder.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/byteorder.h	2004-02-09 15:20:30.000000000 +0900
@@ -0,0 +1,19 @@
+#ifndef _ASM_M32R_BYTEORDER_H
+#define _ASM_M32R_BYTEORDER_H
+
+/* $Id$ */
+
+#include <asm/types.h>
+
+#if !defined(__STRICT_ANSI__) || defined(__KERNEL__)
+#  define __BYTEORDER_HAS_U64__
+#  define __SWAB_64_THRU_32__
+#endif
+
+#if defined(__LITTLE_ENDIAN__)
+#  include <linux/byteorder/little_endian.h>
+#else
+#  include <linux/byteorder/big_endian.h>
+#endif
+
+#endif /* _ASM_M32R_BYTEORDER_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/cache.h linux-2.6.7/include/asm-m32r/cache.h
--- linux-2.6.7.org/include/asm-m32r/cache.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/cache.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,12 @@
+#ifndef _ASM_M32R_CACHE_H
+#define _ASM_M32R_CACHE_H
+
+/* $Id$ */
+
+/* L1 cache line size */
+#define L1_CACHE_SHIFT		4
+#define L1_CACHE_BYTES		(1 << L1_CACHE_SHIFT)
+
+#define L1_CACHE_SHIFT_MAX	4
+
+#endif  /* _ASM_M32R_CACHE_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/cachectl.h linux-2.6.7/include/asm-m32r/cachectl.h
--- linux-2.6.7.org/include/asm-m32r/cachectl.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/cachectl.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,26 @@
+/*
+ * cachectl.h -- defines for M32R cache control system calls
+ *
+ * Copyright (C) 2003 by Kazuhiro Inaoka
+ */
+#ifndef	__ASM_M32R_CACHECTL
+#define	__ASM_M32R_CACHECTL
+
+/*
+ * Options for cacheflush system call
+ *
+ * cacheflush() is currently fluch_cache_all().
+ */
+#define	ICACHE	(1<<0)		/* flush instruction cache        */
+#define	DCACHE	(1<<1)		/* writeback and flush data cache */
+#define	BCACHE	(ICACHE|DCACHE)	/* flush both caches              */
+
+/*
+ * Caching modes for the cachectl(2) call
+ *
+ * cachectl(2) is currently not supported and returns ENOSYS.
+ */
+#define CACHEABLE	0	/* make pages cacheable */
+#define UNCACHEABLE	1	/* make pages uncacheable */
+
+#endif	/* __ASM_M32R_CACHECTL */
diff -ruN linux-2.6.7.org/include/asm-m32r/cacheflush.h linux-2.6.7/include/asm-m32r/cacheflush.h
--- linux-2.6.7.org/include/asm-m32r/cacheflush.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/cacheflush.h	2004-07-27 15:54:20.000000000 +0900
@@ -0,0 +1,68 @@
+#ifndef _ASM_M32R_CACHEFLUSH_H
+#define _ASM_M32R_CACHEFLUSH_H
+
+#include <linux/config.h>
+#include <linux/mm.h>
+
+extern void _flush_cache_all(void);
+extern void _flush_cache_copyback_all(void);
+
+#if defined(CONFIG_CHIP_M32700) || defined(CONFIG_CHIP_OPSP)
+#define flush_cache_all()			do { } while (0)
+#define flush_cache_mm(mm)			do { } while (0)
+#define flush_cache_range(vma, start, end)	do { } while (0)
+#define flush_cache_page(vma, vmaddr)		do { } while (0)
+#define flush_dcache_page(page)			do { } while (0)
+#define flush_dcache_mmap_lock(mapping)		do { } while (0)
+#define flush_dcache_mmap_unlock(mapping)	do { } while (0)
+#ifndef CONFIG_SMP
+#define flush_icache_range(start, end)		_flush_cache_copyback_all()
+#define flush_icache_page(vma,pg)		_flush_cache_copyback_all()
+#define flush_icache_user_range(vma,pg,adr,len)	_flush_cache_copyback_all()
+#define flush_cache_sigtramp(addr)		_flush_cache_copyback_all()
+#else	/* CONFIG_SMP */
+extern void smp_flush_cache_all(void);
+#define flush_icache_range(start, end)		smp_flush_cache_all()
+#define flush_icache_page(vma,pg)		smp_flush_cache_all()
+#define flush_icache_user_range(vma,pg,adr,len)	smp_flush_cache_all()
+#define flush_cache_sigtramp(addr)		_flush_cache_copyback_all()
+#endif	/* CONFIG_SMP */
+#elif defined(CONFIG_CHIP_M32102)
+#define flush_cache_all()			do { } while (0)
+#define flush_cache_mm(mm)			do { } while (0)
+#define flush_cache_range(vma, start, end)	do { } while (0)
+#define flush_cache_page(vma, vmaddr)		do { } while (0)
+#define flush_dcache_page(page)			do { } while (0)
+#define flush_dcache_mmap_lock(mapping)		do { } while (0)
+#define flush_dcache_mmap_unlock(mapping)	do { } while (0)
+#define flush_icache_range(start, end)		_flush_cache_all()
+#define flush_icache_page(vma,pg)		_flush_cache_all()
+#define flush_icache_user_range(vma,pg,adr,len)	_flush_cache_all()
+#define flush_cache_sigtramp(addr)		_flush_cache_all()
+#else
+#define flush_cache_all()			do { } while (0)
+#define flush_cache_mm(mm)			do { } while (0)
+#define flush_cache_range(vma, start, end)	do { } while (0)
+#define flush_cache_page(vma, vmaddr)		do { } while (0)
+#define flush_dcache_page(page)			do { } while (0)
+#define flush_dcache_mmap_lock(mapping)		do { } while (0)
+#define flush_dcache_mmap_unlock(mapping)	do { } while (0)
+#define flush_icache_range(start, end)		do { } while (0)
+#define flush_icache_page(vma,pg)		do { } while (0)
+#define flush_icache_user_range(vma,pg,adr,len)	do { } while (0)
+#define flush_cache_sigtramp(addr)		do { } while (0)
+#endif	/* CONFIG_CHIP_* */
+
+#define flush_cache_vmap(start, end)	do { } while (0)
+#define flush_cache_vunmap(start, end)	do { } while (0)
+
+#define copy_to_user_page(vma, page, vaddr, dst, src, len)	\
+do {								\
+	memcpy(dst, src, len);					\
+	flush_icache_user_range(vma, page, vaddr, len);		\
+} while (0)
+#define copy_from_user_page(vma, page, vaddr, dst, src, len)	\
+	memcpy(dst, src, len)
+
+#endif /* _ASM_M32R_CACHEFLUSH_H */
+
diff -ruN linux-2.6.7.org/include/asm-m32r/checksum.h linux-2.6.7/include/asm-m32r/checksum.h
--- linux-2.6.7.org/include/asm-m32r/checksum.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/checksum.h	2004-07-15 13:43:17.000000000 +0900
@@ -0,0 +1,256 @@
+#ifndef _ASM_M32R_CHECKSUM_H
+#define _ASM_M32R_CHECKSUM_H
+
+/* $Id$ */
+
+/*
+ *  linux/include/asm-m32r/atomic.h
+ *    orig : i386 2.4.10
+ *
+ *  M32R version:
+ *    Copyright (C) 2001, 2002  Hiroyuki Kondo, Hirokazu Takata
+ */
+
+/*
+ * computes the checksum of a memory block at buff, length len,
+ * and adds in "sum" (32-bit)
+ *
+ * returns a 32-bit number suitable for feeding into itself
+ * or csum_tcpudp_magic
+ *
+ * this function must be called with even lengths, except
+ * for the last fragment, which may be odd
+ *
+ * it's best to have buff aligned on a 32-bit boundary
+ */
+asmlinkage unsigned int csum_partial(const unsigned char * buff, int len, unsigned int sum);
+
+/*
+ * the same as csum_partial, but copies from src while it
+ * checksums, and handles user-space pointer exceptions correctly, when needed.
+ *
+ * here even more important to align src and dst on a 32-bit (or even
+ * better 64-bit) boundary
+ */
+
+asmlinkage unsigned int csum_partial_copy_generic(const char *src, char *dst, 
+		int len, int sum, int *src_err_ptr, int *dst_err_ptr);
+
+/*
+ *	Note: when you get a NULL pointer exception here this means someone
+ *	passed in an incorrect kernel address to one of these functions. 
+ *	
+ *	If you use these functions directly please don't forget the 
+ *	verify_area().
+ */
+
+extern unsigned int csum_partial_copy(const char *src, char *dst,
+		int len, int sum);
+extern unsigned int csum_partial_copy_generic_from(const char *src, 
+		char *dst, int len, unsigned int sum, int *err_ptr);
+extern unsigned int csum_partial_copy_generic_to (const char *src, 
+		char *dst, int len, unsigned int sum, int *err_ptr);
+
+extern __inline__
+unsigned int csum_partial_copy_nocheck ( const char *src, char *dst,
+					int len, int sum)
+{
+#if 0
+	return csum_partial_copy_generic ( src, dst, len, sum, NULL, NULL);
+#else
+	return  csum_partial_copy( src, dst, len, sum);
+#endif
+}
+
+extern __inline__
+unsigned int csum_partial_copy_from_user ( const char __user *src, char *dst,
+						int len, int sum, int *err_ptr)
+{
+#if 0
+	return csum_partial_copy_generic ( src, dst, len, sum, err_ptr, NULL);
+#else
+	return csum_partial_copy_generic_from ( src, dst, len, sum, err_ptr);
+#endif
+}
+
+/*
+ * These are the old (and unsafe) way of doing checksums, a warning message will be
+ * printed if they are used and an exeption occurs.
+ *
+ * these functions should go away after some time.
+ */
+
+#define csum_partial_copy_fromuser csum_partial_copy
+unsigned int csum_partial_copy( const char *src, char *dst, int len, int sum);
+
+/*
+ *	Fold a partial checksum
+ */
+
+static __inline__ unsigned int csum_fold(unsigned int sum)
+{
+	unsigned long tmpreg;
+	__asm__(
+		"	sll3	%1, %0, #16 \n"
+		"	cmp	%0, %0 \n"
+		"	addx	%0, %1 \n"
+		"	ldi	%1, #0 \n"
+		"	srli	%0, #16 \n"
+		"	addx	%0, %1 \n"
+		"	xor3	%0, %0, #0x0000ffff \n"
+		: "=r" (sum), "=&r" (tmpreg)
+		: "0"  (sum)
+		: "cbit"
+	);
+	return sum;
+}
+ 
+/*
+ *	This is a version of ip_compute_csum() optimized for IP headers,
+ *	which always checksum on 4 octet boundaries.
+ *
+ *	By Jorge Cwik <jorge@laser.satlink.net>, adapted for linux by
+ *	Arnt Gulbrandsen.
+ */
+static __inline__ unsigned short ip_fast_csum(unsigned char * iph,
+					  unsigned int ihl) {
+	unsigned long sum, tmpreg0, tmpreg1;
+
+	__asm__ __volatile__(
+		"	ld	%0, @%1+ \n"
+		"	addi	%2, #-4 \n"
+		"#	bgez	%2, 2f \n"
+		"	cmp	%0, %0 \n"
+		"	ld	%3, @%1+ \n"
+		"	ld	%4, @%1+ \n"
+		"	addx	%0, %3 \n"
+		"	ld	%3, @%1+ \n"
+		"	addx	%0, %4 \n"
+		"	addx	%0, %3 \n"
+		"	.fillinsn\n"
+		"1: \n"
+		"	ld	%4, @%1+ \n"
+		"	addi	%2, #-1 \n"
+		"	addx	%0, %4 \n"
+		"	bgtz	%2, 1b \n"
+		"\n"
+		"	ldi	%3, #0 \n"
+		"	addx	%0, %3 \n"
+		"	.fillinsn\n"
+		"2: \n"
+	/* Since the input registers which are loaded with iph and ipl
+	   are modified, we must also specify them as outputs, or gcc
+	   will assume they contain their original values. */
+	: "=&r" (sum), "=r" (iph), "=r" (ihl), "=&r" (tmpreg0), "=&r" (tmpreg1)
+	: "1" (iph), "2" (ihl)
+	: "cbit", "memory");
+
+	return csum_fold(sum);
+}
+
+static __inline__ unsigned long csum_tcpudp_nofold(unsigned long saddr,
+						   unsigned long daddr,
+						   unsigned short len,
+						   unsigned short proto,
+						   unsigned int sum) 
+{
+#if defined(__LITTLE_ENDIAN)
+	unsigned long len_proto = (ntohs(len)<<16)+proto*256;
+#else
+	unsigned long len_proto = (proto<<16)+len;
+#endif
+	unsigned long tmpreg;
+
+	__asm__(
+		"	cmp	%0, %0 \n"
+		"	addx	%0, %2 \n"
+		"	addx	%0, %3 \n"
+		"	addx	%0, %4 \n"
+		"	ldi	%1, #0 \n"
+		"	addx	%0, %1 \n"
+		: "=r" (sum), "=&r" (tmpreg)
+		: "r" (daddr), "r" (saddr), "r" (len_proto), "0" (sum)
+		: "cbit"
+	);
+
+	return sum;
+}
+
+/*
+ * computes the checksum of the TCP/UDP pseudo-header
+ * returns a 16-bit checksum, already complemented
+ */
+static __inline__ unsigned short int csum_tcpudp_magic(unsigned long saddr,
+						   unsigned long daddr,
+						   unsigned short len,
+						   unsigned short proto,
+						   unsigned int sum) 
+{
+	return csum_fold(csum_tcpudp_nofold(saddr,daddr,len,proto,sum));
+}
+
+/*
+ * this routine is used for miscellaneous IP-like checksums, mainly
+ * in icmp.c
+ */
+
+static __inline__ unsigned short ip_compute_csum(unsigned char * buff, int len) {
+	return csum_fold (csum_partial(buff, len, 0));
+}
+
+#define _HAVE_ARCH_IPV6_CSUM
+static __inline__ unsigned short int csum_ipv6_magic(struct in6_addr *saddr,
+						     struct in6_addr *daddr,
+						     __u16 len,
+						     unsigned short proto,
+						     unsigned int sum) 
+{
+	unsigned long tmpreg0, tmpreg1, tmpreg2, tmpreg3;
+	__asm__(
+		"	ld	%1, @(%5) \n"
+		"	ld	%2, @(4,%5) \n"
+		"	ld	%3, @(8,%5) \n"
+		"	ld	%4, @(12,%5) \n"
+		"	add	%0, %1 \n"
+		"	addx	%0, %2 \n"
+		"	addx	%0, %3 \n"
+		"	addx	%0, %4 \n"
+		"	ld	%1, @(%6) \n"
+		"	ld	%2, @(4,%6) \n"
+		"	ld	%3, @(8,%6) \n"
+		"	ld	%4, @(12,%6) \n"
+		"	addx	%0, %1 \n"
+		"	addx	%0, %2 \n"
+		"	addx	%0, %3 \n"
+		"	addx	%0, %4 \n"
+		"	addx	%0, %7 \n"
+		"	addx	%0, %8 \n"
+		"	ldi	%1, #0 \n"
+		"	addx	%0, %1 \n"
+		: "=&r" (sum), "=&r" (tmpreg0), "=&r" (tmpreg1),
+		  "=&r" (tmpreg2), "=&r" (tmpreg3)
+		: "r" (saddr), "r" (daddr), 
+		  "r" (htonl((__u32) (len))), "r" (htonl(proto)), "0" (sum)
+		: "cbit"
+        );
+
+	return csum_fold(sum);
+}
+
+/* 
+ *	Copy and checksum to user
+ */
+#define HAVE_CSUM_COPY_USER
+static __inline__ unsigned int csum_and_copy_to_user (const char *src, char *dst,
+				    int len, int sum, int *err_ptr)
+{
+	if (access_ok(VERIFY_WRITE, dst, len))
+		return csum_partial_copy_generic_to(src, dst, len, sum, err_ptr);
+
+	if (len)
+		*err_ptr = -EFAULT;
+
+	return -1; /* invalid checksum */
+}
+
+#endif /* _ASM_M32R_CHECKSUM_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/cpumask.h linux-2.6.7/include/asm-m32r/cpumask.h
--- linux-2.6.7.org/include/asm-m32r/cpumask.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/cpumask.h	2004-03-25 13:29:22.000000000 +0900
@@ -0,0 +1,7 @@
+#ifndef _ASM_M32R_CPUMASK_H
+#define _ASM_M32R_CPUMASK_H
+
+#include <asm-generic/cpumask.h>
+
+#endif /* _ASM_M32R_CPUMASK_H */
+
diff -ruN linux-2.6.7.org/include/asm-m32r/current.h linux-2.6.7/include/asm-m32r/current.h
--- linux-2.6.7.org/include/asm-m32r/current.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/current.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,18 @@
+#ifndef _ASM_M32R_CURRENT_H
+#define _ASM_M32R_CURRENT_H
+
+/* $Id$ */
+
+#include <linux/thread_info.h>
+
+struct task_struct;
+
+static __inline__ struct task_struct *get_current(void)
+{
+	return current_thread_info()->task;
+}
+
+#define current	(get_current())
+
+#endif	/* _ASM_M32R_CURRENT_H */
+
diff -ruN linux-2.6.7.org/include/asm-m32r/delay.h linux-2.6.7/include/asm-m32r/delay.h
--- linux-2.6.7.org/include/asm-m32r/delay.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/delay.h	2004-08-19 16:07:18.000000000 +0900
@@ -0,0 +1,22 @@
+#ifndef _ASM_M32R_DELAY_H
+#define _ASM_M32R_DELAY_H
+
+/* $Id$ */
+
+/*
+ * Copyright (C) 1993 Linus Torvalds
+ *
+ * Delay routines calling functions in arch/m32r/lib/delay.c
+ */
+
+extern void __bad_udelay(void);
+
+extern void __udelay(unsigned long usecs);
+extern void __const_udelay(unsigned long usecs);
+extern void __delay(unsigned long loops);
+
+#define udelay(n) (__builtin_constant_p(n) ? \
+	((n) > 20000 ? __bad_udelay() : __const_udelay((n) * 4294UL)) : \
+	__udelay(n))
+
+#endif /* _ASM_M32R_DELAY_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/div64.h linux-2.6.7/include/asm-m32r/div64.h
--- linux-2.6.7.org/include/asm-m32r/div64.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/div64.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,38 @@
+#ifndef _ASM_M32R_DIV64
+#define _ASM_M32R_DIV64
+
+/* $Id$ */
+
+/* unsigned long long division.
+ * Input:
+ *  unsigned long long  n
+ *  unsigned long  base
+ * Output:
+ *  n = n / base;
+ *  return value = n % base;
+ */
+#define do_div(n, base)						\
+({								\
+	unsigned long _res, _high, _mid, _low;			\
+								\
+	_low = (n) & 0xffffffffUL;				\
+	_high = (n) >> 32;					\
+	if (_high) {						\
+		_mid = (_high % (unsigned long)(base)) << 16;	\
+		_high = _high / (unsigned long)(base);		\
+		_mid += _low >> 16;				\
+		_low &= 0x0000ffffUL;				\
+		_low += (_mid % (unsigned long)(base)) << 16;	\
+		_mid = _mid / (unsigned long)(base);		\
+		_res = _low % (unsigned long)(base);		\
+		_low = _low / (unsigned long)(base);		\
+		n = _low + ((long long)_mid << 16) +		\
+			((long long)_high << 32);		\
+	} else {						\
+		_res = _low % (unsigned long)(base);		\
+		n = (_low / (unsigned long)(base));		\
+	}							\
+	_res;							\
+})
+
+#endif  /* _ASM_M32R_DIV64 */
diff -ruN linux-2.6.7.org/include/asm-m32r/dma-mapping.h linux-2.6.7/include/asm-m32r/dma-mapping.h
--- linux-2.6.7.org/include/asm-m32r/dma-mapping.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/dma-mapping.h	2004-03-25 13:29:22.000000000 +0900
@@ -0,0 +1,23 @@
+#ifndef _ASM_M32R_DMA_MAPPING_H
+#define _ASM_M32R_DMA_MAPPING_H
+
+/*
+ * NOTE: Do not include <asm-generic/dma-mapping.h> 
+ * Because it requires PCI stuffs, but current M32R don't provide these.
+ */
+
+static inline void *
+dma_alloc_coherent(struct device *dev, size_t size, dma_addr_t *dma_handle,
+		   int flag)
+{
+	return (void *)NULL;
+}
+
+static inline void
+dma_free_coherent(struct device *dev, size_t size, void *cpu_addr,
+		    dma_addr_t dma_handle)
+{
+	return;
+}
+
+#endif /* _ASM_M32R_DMA_MAPPING_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/dma.h linux-2.6.7/include/asm-m32r/dma.h
--- linux-2.6.7.org/include/asm-m32r/dma.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/dma.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,14 @@
+#ifndef _ASM_M32R_DMA_H
+#define _ASM_M32R_DMA_H
+
+/* $Id$ */
+
+#include <asm/io.h>
+
+/*
+ * The maximum address that we can perform a DMA transfer 
+ * to on this platform 
+ */
+#define MAX_DMA_ADDRESS      (PAGE_OFFSET+0x20000000)
+
+#endif /* _ASM_M32R_DMA_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/elf.h linux-2.6.7/include/asm-m32r/elf.h
--- linux-2.6.7.org/include/asm-m32r/elf.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/elf.h	2004-05-21 19:04:10.000000000 +0900
@@ -0,0 +1,177 @@
+#ifndef _ASM_M32R__ELF_H
+#define _ASM_M32R__ELF_H
+
+/* $Id$ */
+
+/*
+ * ELF register definitions..
+ */
+
+#include <asm/ptrace.h>
+#include <asm/user.h>
+
+#include <linux/utsname.h>
+
+/* M32R relocation types  */
+#define	R_M32R_NONE		0
+#define	R_M32R_16		1
+#define	R_M32R_32		2
+#define	R_M32R_24		3
+#define	R_M32R_10_PCREL		4
+#define	R_M32R_18_PCREL		5
+#define	R_M32R_26_PCREL		6
+#define	R_M32R_HI16_ULO		7
+#define	R_M32R_HI16_SLO		8
+#define	R_M32R_LO16		9
+#define	R_M32R_SDA16		10
+#ifdef OLD_TYPE
+#define	R_M32R_GOT24		11
+#define	R_M32R_26_PLTREL	12
+#define	R_M32R_GOT16_HI_ULO	13
+#define	R_M32R_GOT16_HI_SLO	14
+#define	R_M32R_GOT16_LO		15
+#define	R_M32R_GOTPC24		16
+#define	R_M32R_COPY		17
+#define	R_M32R_GLOB_DAT		18
+#define	R_M32R_JMP_SLOT		19
+#define	R_M32R_RELATIVE		20
+#define	R_M32R_GNU_VTINHERIT	21
+#define	R_M32R_GNU_VTENTRY	22
+
+#define R_M32R_16_RELA		R_M32R_16
+#define R_M32R_32_RELA		R_M32R_32
+#define R_M32R_24_RELA		R_M32R_24
+#define R_M32R_10_PCREL_RELA	R_M32R_10_PCREL
+#define R_M32R_18_PCREL_RELA	R_M32R_18_PCREL
+#define R_M32R_26_PCREL_RELA	R_M32R_26_PCREL
+#define R_M32R_HI16_ULO_RELA	R_M32R_HI16_ULO
+#define R_M32R_HI16_SLO_RELA	R_M32R_HI16_SLO
+#define R_M32R_LO16_RELA	R_M32R_LO16
+#define R_M32R_SDA16_RELA	R_M32R_SDA16
+#else /* OLD_TYPE */
+#define	R_M32R_GNU_VTINHERIT	11
+#define	R_M32R_GNU_VTENTRY	12
+
+#define	R_M32R_GOT24_SAMPLE		11 /* comflict */
+#define	R_M32R_26_PLTREL_SAMPLE	12 /* comflict */
+#define	R_M32R_GOT16_HI_ULO_SAMPLE	13
+#define	R_M32R_GOT16_HI_SLO_SAMPLE	14
+#define	R_M32R_GOT16_LO_SAMPLE		15
+#define	R_M32R_GOTPC24_SAMPLE		16
+#define	R_M32R_COPY_SAMPLE		17
+#define	R_M32R_GLOB_DAT_SAMPLE		18
+#define	R_M32R_JMP_SLOT_SAMPLE		19
+#define	R_M32R_RELATIVE_SAMPLE		20
+#define	R_M32R_GNU_VTINHERIT_SAMPLE	21
+#define	R_M32R_GNU_VTENTRY_SAMPLE	22
+
+#define R_M32R_16_RELA		33
+#define R_M32R_32_RELA		34
+#define R_M32R_24_RELA		35
+#define R_M32R_10_PCREL_RELA	36
+#define R_M32R_18_PCREL_RELA	37
+#define R_M32R_26_PCREL_RELA	38
+#define R_M32R_HI16_ULO_RELA	39
+#define R_M32R_HI16_SLO_RELA	40
+#define R_M32R_LO16_RELA	41
+#define R_M32R_SDA16_RELA	42
+#define	R_M32R_RELA_GNU_VTINHERIT	43
+#define	R_M32R_RELA_GNU_VTENTRY	44
+
+#define R_M32R_GOT24		48
+#define R_M32R_26_PLTREL	49
+#define R_M32R_COPY		50
+#define R_M32R_GLOB_DAT		51
+#define R_M32R_JMP_SLOT		52
+#define R_M32R_RELATIVE		53
+#define R_M32R_GOTOFF		54
+#define R_M32R_GOTPC24		55
+#define R_M32R_GOT16_HI_ULO	56
+#define R_M32R_GOT16_HI_SLO	57
+#define R_M32R_GOT16_LO		58
+#define R_M32R_GOTPC_HI_ULO	59
+#define R_M32R_GOTPC_HI_SLO	60
+#define R_M32R_GOTPC_LO		61
+
+#endif /* OLD_TYPE */
+
+#define R_M32R_NUM		256
+
+typedef unsigned long elf_greg_t;
+
+#define ELF_NGREG (sizeof (struct pt_regs) / sizeof(elf_greg_t))
+typedef elf_greg_t elf_gregset_t[ELF_NGREG];
+
+/* We have no FP mumumu.  */
+typedef double elf_fpreg_t;
+typedef elf_fpreg_t elf_fpregset_t;
+
+/*
+ * This is used to ensure we don't load something for the wrong architecture.
+ */
+#define elf_check_arch(x) \
+	(((x)->e_machine == EM_M32R) || ((x)->e_machine == EM_CYGNUS_M32R))
+
+/*
+ * These are used to set parameters in the core dumps.
+ */
+#define ELF_CLASS	ELFCLASS32
+#if defined(__LITTLE_ENDIAN)
+#define ELF_DATA	ELFDATA2LSB
+#elif defined(__BIG_ENDIAN)
+#define ELF_DATA	ELFDATA2MSB
+#else
+#error no endian defined
+#endif
+#define ELF_ARCH	EM_M32R
+
+/* SVR4/i386 ABI (pages 3-31, 3-32) says that when the program starts %edx
+   contains a pointer to a function which might be registered using `atexit'.
+   This provides a mean for the dynamic linker to call DT_FINI functions for
+   shared libraries that have been loaded before the code runs.
+
+   A value of 0 tells we have no such handler. 
+
+   We might as well make sure everything else is cleared too (except for %esp),
+   just to make things more deterministic.
+ */
+#define ELF_PLAT_INIT(_r, load_addr)	do { \
+	_r->r0 = 0; \
+} while (0)
+
+#define USE_ELF_CORE_DUMP
+#define ELF_EXEC_PAGESIZE	4096
+
+/* This is the location that an ET_DYN program is loaded if exec'ed.  Typical
+   use of this is to invoke "./ld.so someprog" to test out a new version of
+   the loader.  We need to make sure that it is out of the way of the program
+   that it will "exec", and that there is sufficient room for the brk.  */
+
+#define ELF_ET_DYN_BASE         (TASK_SIZE / 3 * 2)
+
+/* regs is struct pt_regs, pr_reg is elf_gregset_t (which is
+   now struct_user_regs, they are different) */
+
+#define ELF_CORE_COPY_REGS(pr_reg, regs)  \
+	memcpy((char *)&pr_reg, (char *)&regs, sizeof (struct pt_regs));
+
+/* This yields a mask that user programs can use to figure out what
+   instruction set this CPU supports.  This could be done in user space,
+   but it's not easy, and we've already done it here.  */
+
+#define ELF_HWCAP	(0)
+
+/* This yields a string that ld.so will use to load implementation
+   specific libraries for optimization.  This is more specific in
+   intent than poking at uname or /proc/cpuinfo.
+
+   For the moment, we have only optimizations for the Intel generations,
+   but that could change... */
+
+#define ELF_PLATFORM  (NULL)
+
+#ifdef __KERNEL__
+#define SET_PERSONALITY(ex, ibcs2) set_personality((ibcs2)?PER_SVR4:PER_LINUX)
+#endif
+
+#endif  /* _ASM_M32R__ELF_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/errno.h linux-2.6.7/include/asm-m32r/errno.h
--- linux-2.6.7.org/include/asm-m32r/errno.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/errno.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,9 @@
+#ifndef _ASM_M32R_ERRNO_H
+#define _ASM_M32R_ERRNO_H
+
+/* $Id$ */
+
+#include <asm-generic/errno.h>
+
+#endif /* _ASM_M32R_ERRNO_H */
+
diff -ruN linux-2.6.7.org/include/asm-m32r/fcntl.h linux-2.6.7/include/asm-m32r/fcntl.h
--- linux-2.6.7.org/include/asm-m32r/fcntl.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/fcntl.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,91 @@
+#ifndef _ASM_M32R_FCNTL_H
+#define _ASM_M32R_FCNTL_H
+
+/* $Id$ */
+
+/* orig : i386 2.4.18 */
+
+/* open/fcntl - O_SYNC is only implemented on blocks devices and on files
+   located on an ext2 file system */
+#define O_ACCMODE	   0003
+#define O_RDONLY	     00
+#define O_WRONLY	     01
+#define O_RDWR		     02
+#define O_CREAT		   0100	/* not fcntl */
+#define O_EXCL		   0200	/* not fcntl */
+#define O_NOCTTY	   0400	/* not fcntl */
+#define O_TRUNC		  01000	/* not fcntl */
+#define O_APPEND	  02000
+#define O_NONBLOCK	  04000
+#define O_NDELAY	O_NONBLOCK
+#define O_SYNC		 010000
+#define FASYNC		 020000	/* fcntl, for BSD compatibility */
+#define O_DIRECT	 040000	/* direct disk access hint */
+#define O_LARGEFILE	0100000
+#define O_DIRECTORY	0200000	/* must be a directory */
+#define O_NOFOLLOW	0400000 /* don't follow links */
+
+#define F_DUPFD		0	/* dup */
+#define F_GETFD		1	/* get close_on_exec */
+#define F_SETFD		2	/* set/clear close_on_exec */
+#define F_GETFL		3	/* get file->f_flags */
+#define F_SETFL		4	/* set file->f_flags */
+#define F_GETLK		5
+#define F_SETLK		6
+#define F_SETLKW	7
+
+#define F_SETOWN	8	/*  for sockets. */
+#define F_GETOWN	9	/*  for sockets. */
+#define F_SETSIG	10	/*  for sockets. */
+#define F_GETSIG	11	/*  for sockets. */
+
+#define F_GETLK64	12	/*  using 'struct flock64' */
+#define F_SETLK64	13
+#define F_SETLKW64	14
+
+/* for F_[GET|SET]FL */
+#define FD_CLOEXEC	1	/* actually anything with low bit set goes */
+
+/* for posix fcntl() and lockf() */
+#define F_RDLCK		0
+#define F_WRLCK		1
+#define F_UNLCK		2
+
+/* for old implementation of bsd flock () */
+#define F_EXLCK		4	/* or 3 */
+#define F_SHLCK		8	/* or 4 */
+
+/* for leases */
+#define F_INPROGRESS	16
+
+/* operations for bsd flock(), also used by the kernel implementation */
+#define LOCK_SH		1	/* shared lock */
+#define LOCK_EX		2	/* exclusive lock */
+#define LOCK_NB		4	/* or'd with one of the above to prevent
+				   blocking */
+#define LOCK_UN		8	/* remove lock */
+
+#define LOCK_MAND	32	/* This is a mandatory flock */
+#define LOCK_READ	64	/* ... Which allows concurrent read operations */
+#define LOCK_WRITE	128	/* ... Which allows concurrent write operations */
+#define LOCK_RW		192	/* ... Which allows concurrent read & write ops */
+
+struct flock {
+	short l_type;
+	short l_whence;
+	off_t l_start;
+	off_t l_len;
+	pid_t l_pid;
+};
+
+struct flock64 {
+	short  l_type;
+	short  l_whence;
+	loff_t l_start;
+	loff_t l_len;
+	pid_t  l_pid;
+};
+
+#define F_LINUX_SPECIFIC_BASE	1024
+
+#endif  /* _ASM_M32R_FCNTL_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/flat.h linux-2.6.7/include/asm-m32r/flat.h
--- linux-2.6.7.org/include/asm-m32r/flat.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/flat.h	2004-07-15 13:43:17.000000000 +0900
@@ -0,0 +1,145 @@
+/*
+ * include/asm-m32r/flat.h
+ *
+ * uClinux flat-format executables
+ *
+ * Copyright (C) 2004  Kazuhiro Inaoka
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive for
+ * more details.
+ */
+#ifndef __ASM_M32R_FLAT_H
+#define __ASM_M32R_FLAT_H
+
+#define	flat_stack_align(sp)		(*sp += (*sp & 3 ? (4 - (*sp & 3)): 0))
+#define	flat_argvp_envp_on_stack()		0
+#define	flat_old_ram_flag(flags)		(flags)
+#define	flat_reloc_valid(reloc, size)		\
+	(((reloc) - textlen_for_m32r_lo16_data) <= (size))
+#define flat_get_addr_from_rp(rp, relval, flags) \
+	m32r_flat_get_addr_from_rp(rp, relval, (text_len) )
+
+#define flat_put_addr_at_rp(rp, addr, relval) \
+	m32r_flat_put_addr_at_rp(rp, addr, relval)
+
+/* Convert a relocation entry into an address.  */
+static inline unsigned long
+flat_get_relocate_addr (unsigned long relval)
+{
+        return relval & 0x00ffffff; /* Mask out top 8-bits */
+}
+
+#define	flat_m32r_get_reloc_type(relval)	((relval) >> 24)
+
+#define M32R_SETH_OPCODE	0xd0c00000 /* SETH instruction code */
+
+#define FLAT_M32R_32		0x00	/* 32bits reloc */
+#define FLAT_M32R_24		0x01	/* unsigned 24bits reloc */
+#define FLAT_M32R_16		0x02	/* 16bits reloc */
+#define FLAT_M32R_LO16		0x03	/* signed low 16bits reloc (low()) */
+#define FLAT_M32R_LO16_DATA	0x04	/* signed low 16bits reloc (low()) 
+					   for a symbol in .data section */
+					/* High 16bits of an address used
+					   when the lower 16bbits are treated
+					   as unsigned.
+                                           To create SETH instruction only.
+					   0x1X: X means a number of register.
+					   0x10 - 0x3F are reserved. */
+#define FLAT_M32R_HI16_ULO	0x10	/* reloc for SETH Rn,#high(imm16) */
+					/* High 16bits of an address used
+					   when the lower 16bbits are treated
+					   as signed.
+                                           To create SETH instruction only.
+					   0x2X: X means a number of register.
+					   0x20 - 0x4F are reserved. */
+#define FLAT_M32R_HI16_SLO	0x20	/* reloc for SETH Rn,#shigh(imm16) */
+
+static unsigned long textlen_for_m32r_lo16_data = 0;
+
+static inline unsigned long m32r_flat_get_addr_from_rp (unsigned long *rp,
+                                                        unsigned long relval,
+						        unsigned long textlen)
+{
+        unsigned int reloc = flat_m32r_get_reloc_type (relval);
+	textlen_for_m32r_lo16_data = 0;
+	if (reloc & 0xf0) {
+		unsigned long addr = htonl(*rp);
+		switch (reloc & 0xf0)
+		{
+		case FLAT_M32R_HI16_ULO:
+		case FLAT_M32R_HI16_SLO:
+			if (addr == 0) {
+				/* put "seth Rn,#0x0" instead of 0 (addr). */
+				*rp = (M32R_SETH_OPCODE | ((reloc & 0x0f)<<24));
+			}
+			return addr;
+		default:
+			break;
+		}
+	} else {
+		switch (reloc)
+		{
+		case FLAT_M32R_LO16:
+			return htonl(*rp) & 0xFFFF;
+		case FLAT_M32R_LO16_DATA:
+                        /* FIXME: The return value will decrease by textlen 
+			   at m32r_flat_put_addr_at_rp () */
+			textlen_for_m32r_lo16_data = textlen;
+			return (htonl(*rp) & 0xFFFF) + textlen;
+		case FLAT_M32R_16:
+			return htons(*(unsigned short *)rp) & 0xFFFF;
+		case FLAT_M32R_24:
+			return htonl(*rp) & 0xFFFFFF;
+		case FLAT_M32R_32:
+			return htonl(*rp);
+		default:
+			break;
+		}	
+	}
+	return ~0;      /* bogus value */
+}
+
+static inline void m32r_flat_put_addr_at_rp (unsigned long *rp,
+					     unsigned long addr,
+                                             unsigned long relval)
+{
+        unsigned int reloc = flat_m32r_get_reloc_type (relval);
+	if (reloc & 0xf0) {
+		unsigned long Rn = reloc & 0x0f; /* get a number of register */
+		Rn <<= 24; /* 0x0R000000 */
+		reloc &= 0xf0;
+		switch (reloc)
+		{
+		case FLAT_M32R_HI16_ULO: /* To create SETH Rn,#high(imm16) */
+			*rp = (M32R_SETH_OPCODE | Rn
+			       | ((addr >> 16) & 0xFFFF));
+			break;
+		case FLAT_M32R_HI16_SLO: /* To create SETH Rn,#shigh(imm16) */
+			*rp = (M32R_SETH_OPCODE | Rn
+			       | (((addr >> 16) + ((addr & 0x8000) ? 1 : 0))
+				  & 0xFFFF));
+			break;
+		}
+	} else {
+		switch (reloc) {
+		case FLAT_M32R_LO16_DATA:
+			addr -= textlen_for_m32r_lo16_data;
+			textlen_for_m32r_lo16_data = 0;
+		case FLAT_M32R_LO16:
+			*rp = (htonl(*rp) & 0xFFFF0000) | (addr & 0xFFFF);
+			break;
+		case FLAT_M32R_16:
+			*(unsigned short *)rp = addr & 0xFFFF;
+			break;
+		case FLAT_M32R_24:
+			*rp = (htonl(*rp) & 0xFF000000) | (addr & 0xFFFFFF);
+			break;
+		case FLAT_M32R_32:
+			*rp = addr;
+			break;
+		}
+	}                                                                      
+}
+
+#endif /* __ASM_M32R_FLAT_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/hardirq.h linux-2.6.7/include/asm-m32r/hardirq.h
--- linux-2.6.7.org/include/asm-m32r/hardirq.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/hardirq.h	2004-06-11 17:08:30.000000000 +0900
@@ -0,0 +1,103 @@
+#ifndef __ASM_HARDIRQ_H
+#define __ASM_HARDIRQ_H
+
+/* $Id$ */
+
+/* orig : i386 2.5.67 */
+
+#include <linux/config.h>
+#include <linux/threads.h>
+#include <linux/irq.h>
+
+typedef struct {
+	unsigned int __softirq_pending;
+	unsigned int __syscall_count;
+	struct task_struct * __ksoftirqd_task; /* waitqueue is too large */
+} ____cacheline_aligned irq_cpustat_t;
+
+#include <linux/irq_cpustat.h>	/* Standard mappings for irq_cpustat_t above */
+
+/*
+ * We put the hardirq and softirq counter into the preemption
+ * counter. The bitmask has the following meaning:
+ *
+ * - bits 0-7 are the preemption count (max preemption depth: 256)
+ * - bits 8-15 are the softirq count (max # of softirqs: 256)
+ * - bits 16-23 are the hardirq count (max # of hardirqs: 256)
+ *
+ * - ( bit 26 is the PREEMPT_ACTIVE flag. )
+ *
+ * PREEMPT_MASK: 0x000000ff
+ * SOFTIRQ_MASK: 0x0000ff00
+ * HARDIRQ_MASK: 0x00ff0000
+ */
+
+#define PREEMPT_BITS	8
+#define SOFTIRQ_BITS	8
+#define HARDIRQ_BITS	8
+
+#define PREEMPT_SHIFT	0
+#define SOFTIRQ_SHIFT	(PREEMPT_SHIFT + PREEMPT_BITS)
+#define HARDIRQ_SHIFT	(SOFTIRQ_SHIFT + SOFTIRQ_BITS)
+
+#define __MASK(x)	((1UL << (x))-1)
+
+#define PREEMPT_MASK	(__MASK(PREEMPT_BITS) << PREEMPT_SHIFT)
+#define HARDIRQ_MASK	(__MASK(HARDIRQ_BITS) << HARDIRQ_SHIFT)
+#define SOFTIRQ_MASK	(__MASK(SOFTIRQ_BITS) << SOFTIRQ_SHIFT)
+
+#define hardirq_count()	(preempt_count() & HARDIRQ_MASK)
+#define softirq_count()	(preempt_count() & SOFTIRQ_MASK)
+#define irq_count()	(preempt_count() & (HARDIRQ_MASK | SOFTIRQ_MASK))
+
+#define PREEMPT_OFFSET	(1UL << PREEMPT_SHIFT)
+#define SOFTIRQ_OFFSET	(1UL << SOFTIRQ_SHIFT)
+#define HARDIRQ_OFFSET	(1UL << HARDIRQ_SHIFT)
+
+/*
+ * The hardirq mask has to be large enough to have
+ * space for potentially all IRQ sources in the system
+ * nesting on a single CPU:
+ */
+#if (1 << HARDIRQ_BITS) < NR_IRQS
+# error HARDIRQ_BITS is too low!
+#endif
+
+/*
+ * Are we doing bottom half or hardware interrupt processing?
+ * Are we in a softirq context? Interrupt context?
+ */
+#define in_irq()		(hardirq_count())
+#define in_softirq()		(softirq_count())
+#define in_interrupt()		(irq_count())
+
+
+#define hardirq_trylock()	(!in_interrupt())
+#define hardirq_endlock()	do { } while (0)
+
+#define irq_enter()		(preempt_count() += HARDIRQ_OFFSET)
+#define nmi_enter()		(irq_enter())
+#define nmi_exit()		(preempt_count() -= HARDIRQ_OFFSET)
+
+#ifdef CONFIG_PREEMPT
+# define in_atomic()	((preempt_count() & ~PREEMPT_ACTIVE) != kernel_locked())
+# define IRQ_EXIT_OFFSET (HARDIRQ_OFFSET-1)
+#else
+# define in_atomic()	(preempt_count() != 0)
+# define IRQ_EXIT_OFFSET HARDIRQ_OFFSET
+#endif
+#define irq_exit()							\
+do {									\
+		preempt_count() -= IRQ_EXIT_OFFSET;			\
+		if (!in_interrupt() && softirq_pending(smp_processor_id())) \
+			do_softirq();					\
+		preempt_enable_no_resched();				\
+} while (0)
+
+#ifndef CONFIG_SMP
+# define synchronize_irq(irq)	barrier()
+#else
+  extern void synchronize_irq(unsigned int irq);
+#endif /* CONFIG_SMP */
+
+#endif /* __ASM_HARDIRQ_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/hdreg.h linux-2.6.7/include/asm-m32r/hdreg.h
--- linux-2.6.7.org/include/asm-m32r/hdreg.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/hdreg.h	2004-05-19 18:53:48.000000000 +0900
@@ -0,0 +1 @@
+#include <asm-generic/hdreg.h>
diff -ruN linux-2.6.7.org/include/asm-m32r/hw_irq.h linux-2.6.7/include/asm-m32r/hw_irq.h
--- linux-2.6.7.org/include/asm-m32r/hw_irq.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/hw_irq.h	2004-05-10 20:01:43.000000000 +0900
@@ -0,0 +1,40 @@
+#ifndef _ASM_M32R_HW_IRQ_H
+#define _ASM_M32R_HW_IRQ_H
+
+/* $Id$ */
+
+#include <linux/profile.h>
+#include <linux/sched.h>
+#include <asm/sections.h>
+
+static __inline__ void hw_resend_irq(struct hw_interrupt_type *h, 
+				     unsigned int i) 
+{
+	/* Nothing to do */
+}
+
+static __inline__ void m32r_do_profile (struct pt_regs *regs)
+{
+        unsigned long pc = regs->bpc;
+
+        profile_hook(regs);
+
+        if (user_mode(regs))
+                return;
+
+        if (!prof_buffer)
+                return;
+
+        pc -= (unsigned long) &_stext;
+        pc >>= prof_shift;
+        /*
+         * Don't ignore out-of-bounds PC values silently,
+         * put them into the last histogram slot, so if
+         * present, they will show up as a sharp peak.
+         */
+        if (pc > prof_len - 1)
+                pc = prof_len - 1;
+        atomic_inc((atomic_t *)&prof_buffer[pc]);
+}
+
+#endif /* _ASM_M32R_HW_IRQ_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/ide.h linux-2.6.7/include/asm-m32r/ide.h
--- linux-2.6.7.org/include/asm-m32r/ide.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/ide.h	2004-07-15 13:43:17.000000000 +0900
@@ -0,0 +1,71 @@
+#ifndef _ASM_M32R_IDE_H
+#define _ASM_M32R_IDE_H
+
+/* $Id$ */
+
+/*
+ *  linux/include/asm-m32r/ide.h
+ *
+ *  Copyright (C) 1994-1996  Linus Torvalds & authors
+ */
+
+/*
+ *  This file contains the i386 architecture specific IDE code.
+ */
+
+#ifdef __KERNEL__
+
+#include <linux/config.h>
+
+#ifndef MAX_HWIFS
+# ifdef CONFIG_BLK_DEV_IDEPCI
+#define MAX_HWIFS	10
+# else
+#define MAX_HWIFS	2
+# endif
+#endif
+
+#define IDE_ARCH_OBSOLETE_DEFAULTS
+
+static __inline__ int ide_default_irq(unsigned long base)
+{
+	switch (base) {
+		case 0x1f0: return 14;
+		case 0x170: return 15;
+		case 0x1e8: return 11;
+		case 0x168: return 10;
+		case 0x1e0: return 8;
+		case 0x160: return 12;
+		default:
+			return 0;
+	}
+}
+
+static __inline__ unsigned long ide_default_io_base(int index)
+{
+	switch (index) {
+		case 0:	return 0x1f0;
+		case 1:	return 0x170;
+		case 2: return 0x1e8;
+		case 3: return 0x168;
+		case 4: return 0x1e0;
+		case 5: return 0x160;
+		default:
+			return 0;
+	}
+}
+
+#define IDE_ARCH_OBSOLETE_INIT
+#define ide_default_io_ctl(base)	((base) + 0x206) /* obsolete */
+
+#ifdef CONFIG_BLK_DEV_IDEPCI
+#define ide_init_default_irq(base)     (0)
+#else
+#define ide_init_default_irq(base)     ide_default_irq(base)
+#endif
+
+#include <asm-generic/ide_iops.h>
+
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_M32R_IDE_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/init.h linux-2.6.7/include/asm-m32r/init.h
--- linux-2.6.7.org/include/asm-m32r/init.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/init.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1 @@
+#error "<asm/init.h> should never be used - use <linux/init.h> instead"
diff -ruN linux-2.6.7.org/include/asm-m32r/io.h linux-2.6.7/include/asm-m32r/io.h
--- linux-2.6.7.org/include/asm-m32r/io.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/io.h	2004-06-22 18:42:09.000000000 +0900
@@ -0,0 +1,201 @@
+#ifndef _ASM_M32R_IO_H
+#define _ASM_M32R_IO_H
+
+/* $Id$ */
+
+#include <asm/page.h>  /* __va */
+
+#ifdef __KERNEL__
+
+#define IO_SPACE_LIMIT  0xFFFFFFFF
+
+/**
+ *	virt_to_phys	-	map virtual addresses to physical
+ *	@address: address to remap
+ *
+ *	The returned physical address is the physical (CPU) mapping for
+ *	the memory address given. It is only valid to use this function on
+ *	addresses directly mapped or allocated via kmalloc.
+ *
+ *	This function does not give bus mappings for DMA transfers. In
+ *	almost all conceivable cases a device driver should not be using
+ *	this function
+ */
+
+static __inline__ unsigned long virt_to_phys(volatile void * address)
+{
+	return __pa(address);
+}
+
+/**
+ *	phys_to_virt	-	map physical address to virtual
+ *	@address: address to remap
+ *
+ *	The returned virtual address is a current CPU mapping for
+ *	the memory address given. It is only valid to use this function on
+ *	addresses that have a kernel mapping
+ *
+ *	This function does not handle bus mappings for DMA transfers. In
+ *	almost all conceivable cases a device driver should not be using
+ *	this function
+ */
+
+static __inline__ void *phys_to_virt(unsigned long address)
+{
+	return __va(address);
+}
+
+extern void * __ioremap(unsigned long offset, unsigned long size, unsigned long flags);
+
+/**
+ *	ioremap		-	map bus memory into CPU space
+ *	@offset:	bus address of the memory
+ *	@size:		size of the resource to map
+ *
+ *	ioremap performs a platform specific sequence of operations to
+ *	make bus memory CPU accessible via the readb/readw/readl/writeb/
+ *	writew/writel functions and the other mmio helpers. The returned
+ *	address is not guaranteed to be usable directly as a virtual
+ *	address. 
+ */
+
+static __inline__ void * ioremap(unsigned long offset, unsigned long size)
+{
+	return __ioremap(offset, size, 0);
+}
+
+extern void iounmap(void *addr);
+#define ioremap_nocache(off,size) ioremap(off,size)
+
+/*
+ * IO bus memory addresses are also 1:1 with the physical address
+ */
+#define page_to_phys(page)	(page_to_pfn(page) << PAGE_SHIFT)
+#define page_to_bus	page_to_phys
+#define virt_to_bus	virt_to_phys
+
+extern unsigned char _inb(unsigned long);
+extern unsigned short _inw(unsigned long);
+extern unsigned long _inl(unsigned long);
+extern unsigned char _inb_p(unsigned long);
+extern unsigned short _inw_p(unsigned long);
+extern unsigned long _inl_p(unsigned long);
+extern void _outb(unsigned char, unsigned long);
+extern void _outw(unsigned short, unsigned long);
+extern void _outl(unsigned long, unsigned long);
+extern void _outb_p(unsigned char, unsigned long);
+extern void _outw_p(unsigned short, unsigned long);
+extern void _outl_p(unsigned long, unsigned long);
+extern void _insb(unsigned int, void *, unsigned long);
+extern void _insw(unsigned int, void *, unsigned long);
+extern void _insl(unsigned int, void *, unsigned long);
+extern void _outsb(unsigned int, const void *, unsigned long);
+extern void _outsw(unsigned int, const void *, unsigned long);
+extern void _outsl(unsigned int, const void *, unsigned long);
+
+static inline unsigned char _readb(unsigned long addr)
+{
+	return *(volatile unsigned char *)addr;
+}
+
+static inline unsigned short _readw(unsigned long addr)
+{
+	return *(volatile unsigned short *)addr;
+}
+
+static inline unsigned long _readl(unsigned long addr)
+{
+	return *(volatile unsigned long *)addr;
+}
+
+static inline void _writeb(unsigned char b, unsigned long addr)
+{
+	*(volatile unsigned char *)addr = b;
+}
+
+static inline void _writew(unsigned short w, unsigned long addr)
+{
+	*(volatile unsigned short *)addr = w;
+}
+
+static inline void _writel(unsigned long l, unsigned long addr)
+{
+	*(volatile unsigned long *)addr = l;
+}
+
+#define inb     _inb
+#define inw     _inw
+#define inl     _inl
+#define outb    _outb
+#define outw    _outw
+#define outl    _outl
+
+#define inb_p   _inb_p
+#define inw_p   _inw_p
+#define inl_p   _inl_p
+#define outb_p  _outb_p
+#define outw_p  _outw_p
+#define outl_p  _outl_p
+
+#define insb    _insb
+#define insw    _insw
+#define insl    _insl
+#define outsb   _outsb
+#define outsw   _outsw
+#define outsl   _outsl
+
+#define readb(addr)   _readb((unsigned long)(addr))
+#define readw(addr)   _readw((unsigned long)(addr))
+#define readl(addr)   _readl((unsigned long)(addr))
+#define __raw_readb readb
+#define __raw_readw readw
+#define __raw_readl readl
+
+#define writeb(val, addr)  _writeb((val), (unsigned long)(addr))
+#define writew(val, addr)  _writew((val), (unsigned long)(addr))
+#define writel(val, addr)  _writel((val), (unsigned long)(addr))
+#define __raw_writeb writeb
+#define __raw_writew writew
+#define __raw_writel writel
+
+#define flush_write_buffers() do { } while (0)  /* M32R_FIXME */
+
+/**
+ *	isa_check_signature		-	find BIOS signatures
+ *	@io_addr: mmio address to check 
+ *	@signature:  signature block
+ *	@length: length of signature
+ *
+ *	Perform a signature comparison with the ISA mmio address io_addr.
+ *	Returns 1 on a match.
+ *
+ *	This function is deprecated. New drivers should use ioremap and
+ *	check_signature.
+ */
+
+static inline int isa_check_signature(unsigned long io_addr,
+        const unsigned char *signature, int length)
+{
+        int retval = 0;
+#if 0
+printk("isa_check_signature\n");
+        do {
+                if (isa_readb(io_addr) != *signature)
+                        goto out;
+                io_addr++;
+                signature++;
+                length--;
+        } while (length);
+        retval = 1;
+out:
+#endif
+        return retval;
+}
+
+#define memset_io(a, b, c)	memset((void *)(a), (b), (c))
+#define memcpy_fromio(a, b, c)	memcpy((a), (void *)(b), (c))
+#define memcpy_toio(a, b, c)	memcpy((void *)(a), (b), (c))
+
+#endif  /* __KERNEL__ */
+
+#endif  /* _ASM_M32R_IO_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/ioctl.h linux-2.6.7/include/asm-m32r/ioctl.h
--- linux-2.6.7.org/include/asm-m32r/ioctl.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/ioctl.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,78 @@
+#ifndef _ASM_M32R_IOCTL_H
+#define _ASM_M32R_IOCTL_H
+
+/* $Id$ */
+
+/* orig : i386 2.4.18 */
+
+/* 
+ * linux/ioctl.h for Linux by H.H. Bergman.
+ */
+
+/* ioctl command encoding: 32 bits total, command in lower 16 bits,
+ * size of the parameter structure in the lower 14 bits of the
+ * upper 16 bits.
+ * Encoding the size of the parameter structure in the ioctl request
+ * is useful for catching programs compiled with old versions
+ * and to avoid overwriting user space outside the user buffer area.
+ * The highest 2 bits are reserved for indicating the ``access mode''.
+ * NOTE: This limits the max parameter size to 16kB -1 !
+ */
+
+/*
+ * The following is for compatibility across the various Linux
+ * platforms.  The i386 ioctl numbering scheme doesn't really enforce
+ * a type field.  De facto, however, the top 8 bits of the lower 16
+ * bits are indeed used as a type field, so we might just as well make
+ * this explicit here.  Please be sure to use the decoding macros
+ * below from now on.
+ */
+#define _IOC_NRBITS	8
+#define _IOC_TYPEBITS	8
+#define _IOC_SIZEBITS	14
+#define _IOC_DIRBITS	2
+
+#define _IOC_NRMASK	((1 << _IOC_NRBITS)-1)
+#define _IOC_TYPEMASK	((1 << _IOC_TYPEBITS)-1)
+#define _IOC_SIZEMASK	((1 << _IOC_SIZEBITS)-1)
+#define _IOC_DIRMASK	((1 << _IOC_DIRBITS)-1)
+
+#define _IOC_NRSHIFT	0
+#define _IOC_TYPESHIFT	(_IOC_NRSHIFT+_IOC_NRBITS)
+#define _IOC_SIZESHIFT	(_IOC_TYPESHIFT+_IOC_TYPEBITS)
+#define _IOC_DIRSHIFT	(_IOC_SIZESHIFT+_IOC_SIZEBITS)
+
+/*
+ * Direction bits.
+ */
+#define _IOC_NONE	0U
+#define _IOC_WRITE	1U
+#define _IOC_READ	2U
+
+#define _IOC(dir,type,nr,size) \
+	(((dir)  << _IOC_DIRSHIFT) | \
+	 ((type) << _IOC_TYPESHIFT) | \
+	 ((nr)   << _IOC_NRSHIFT) | \
+	 ((size) << _IOC_SIZESHIFT))
+
+/* used to create numbers */
+#define _IO(type,nr)		_IOC(_IOC_NONE,(type),(nr),0)
+#define _IOR(type,nr,size)	_IOC(_IOC_READ,(type),(nr),sizeof(size))
+#define _IOW(type,nr,size)	_IOC(_IOC_WRITE,(type),(nr),sizeof(size))
+#define _IOWR(type,nr,size)	_IOC(_IOC_READ|_IOC_WRITE,(type),(nr),sizeof(size))
+
+/* used to decode ioctl numbers.. */
+#define _IOC_DIR(nr)		(((nr) >> _IOC_DIRSHIFT) & _IOC_DIRMASK)
+#define _IOC_TYPE(nr)		(((nr) >> _IOC_TYPESHIFT) & _IOC_TYPEMASK)
+#define _IOC_NR(nr)		(((nr) >> _IOC_NRSHIFT) & _IOC_NRMASK)
+#define _IOC_SIZE(nr)		(((nr) >> _IOC_SIZESHIFT) & _IOC_SIZEMASK)
+
+/* ...and for the drivers/sound files... */
+
+#define IOC_IN		(_IOC_WRITE << _IOC_DIRSHIFT)
+#define IOC_OUT		(_IOC_READ << _IOC_DIRSHIFT)
+#define IOC_INOUT	((_IOC_WRITE|_IOC_READ) << _IOC_DIRSHIFT)
+#define IOCSIZE_MASK	(_IOC_SIZEMASK << _IOC_SIZESHIFT)
+#define IOCSIZE_SHIFT	(_IOC_SIZESHIFT)
+
+#endif /* _ASM_M32R_IOCTL_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/ioctls.h linux-2.6.7/include/asm-m32r/ioctls.h
--- linux-2.6.7.org/include/asm-m32r/ioctls.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/ioctls.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,88 @@
+#ifndef __ARCH_M32R_IOCTLS_H__
+#define __ARCH_M32R_IOCTLS_H__
+
+/* $Id$ */
+
+/* orig : i386 2.5.67 */
+
+#include <asm/ioctl.h>
+
+/* 0x54 is just a magic number to make these relatively unique ('T') */
+
+#define TCGETS		0x5401
+#define TCSETS		0x5402 /* Clashes with SNDCTL_TMR_START sound ioctl */
+#define TCSETSW		0x5403
+#define TCSETSF		0x5404
+#define TCGETA		0x5405
+#define TCSETA		0x5406
+#define TCSETAW		0x5407
+#define TCSETAF		0x5408
+#define TCSBRK		0x5409
+#define TCXONC		0x540A
+#define TCFLSH		0x540B
+#define TIOCEXCL	0x540C
+#define TIOCNXCL	0x540D
+#define TIOCSCTTY	0x540E
+#define TIOCGPGRP	0x540F
+#define TIOCSPGRP	0x5410
+#define TIOCOUTQ	0x5411
+#define TIOCSTI		0x5412
+#define TIOCGWINSZ	0x5413
+#define TIOCSWINSZ	0x5414
+#define TIOCMGET	0x5415
+#define TIOCMBIS	0x5416
+#define TIOCMBIC	0x5417
+#define TIOCMSET	0x5418
+#define TIOCGSOFTCAR	0x5419
+#define TIOCSSOFTCAR	0x541A
+#define FIONREAD	0x541B
+#define TIOCINQ		FIONREAD
+#define TIOCLINUX	0x541C
+#define TIOCCONS	0x541D
+#define TIOCGSERIAL	0x541E
+#define TIOCSSERIAL	0x541F
+#define TIOCPKT		0x5420
+#define FIONBIO		0x5421
+#define TIOCNOTTY	0x5422
+#define TIOCSETD	0x5423
+#define TIOCGETD	0x5424
+#define TCSBRKP		0x5425	/* Needed for POSIX tcsendbreak() */
+/* #define TIOCTTYGSTRUCT 0x5426 - Former debugging-only ioctl */
+#define TIOCSBRK	0x5427  /* BSD compatibility */
+#define TIOCCBRK	0x5428  /* BSD compatibility */
+#define TIOCGSID	0x5429  /* Return the session ID of FD */
+#define TIOCGPTN	_IOR('T',0x30, unsigned int) /* Get Pty Number (of pty-mux device) */
+#define TIOCSPTLCK	_IOW('T',0x31, int)  /* Lock/unlock Pty */
+
+#define FIONCLEX	0x5450
+#define FIOCLEX		0x5451
+#define FIOASYNC	0x5452
+#define TIOCSERCONFIG	0x5453
+#define TIOCSERGWILD	0x5454
+#define TIOCSERSWILD	0x5455
+#define TIOCGLCKTRMIOS	0x5456
+#define TIOCSLCKTRMIOS	0x5457
+#define TIOCSERGSTRUCT	0x5458 /* For debugging only */
+#define TIOCSERGETLSR   0x5459 /* Get line status register */
+#define TIOCSERGETMULTI 0x545A /* Get multiport config  */
+#define TIOCSERSETMULTI 0x545B /* Set multiport config */
+
+#define TIOCMIWAIT	0x545C	/* wait for a change on serial input line(s) */
+#define TIOCGICOUNT	0x545D	/* read serial port inline interrupt counts */
+#define TIOCGHAYESESP   0x545E  /* Get Hayes ESP configuration */
+#define TIOCSHAYESESP   0x545F  /* Set Hayes ESP configuration */
+#define FIOQSIZE	0x5460
+
+/* Used for packet mode */
+#define TIOCPKT_DATA		 0
+#define TIOCPKT_FLUSHREAD	 1
+#define TIOCPKT_FLUSHWRITE	 2
+#define TIOCPKT_STOP		 4
+#define TIOCPKT_START		 8
+#define TIOCPKT_NOSTOP		16
+#define TIOCPKT_DOSTOP		32
+
+#define TIOCSER_TEMT    0x01	/* Transmitter physically empty */
+
+#endif /* __ARCH_M32R_IOCTLS_H__ */
+
diff -ruN linux-2.6.7.org/include/asm-m32r/ipc.h linux-2.6.7/include/asm-m32r/ipc.h
--- linux-2.6.7.org/include/asm-m32r/ipc.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/ipc.h	2003-09-09 10:28:57.000000000 +0900
@@ -0,0 +1,35 @@
+#ifndef __M32R_IPC_H__
+#define __M32R_IPC_H__
+
+/* orig : i386/ipc.h 2.6.0-test3 */
+
+/* 
+ * These are used to wrap system calls on x86.
+ *
+ * See arch/i386/kernel/sys_i386.c for ugly details..
+ */
+struct ipc_kludge {
+	struct msgbuf __user *msgp;
+	long msgtyp;
+};
+
+#define SEMOP		 1
+#define SEMGET		 2
+#define SEMCTL		 3
+#define SEMTIMEDOP	 4
+#define MSGSND		11
+#define MSGRCV		12
+#define MSGGET		13
+#define MSGCTL		14
+#define SHMAT		21
+#define SHMDT		22
+#define SHMGET		23
+#define SHMCTL		24
+
+/* Used by the DIPC package, try and avoid reusing it */
+#define DIPC            25
+
+#define IPCCALL(version,op)	((version)<<16 | (op))
+
+#endif	/* __M32R_IPC_H__ */
+
diff -ruN linux-2.6.7.org/include/asm-m32r/ipcbuf.h linux-2.6.7/include/asm-m32r/ipcbuf.h
--- linux-2.6.7.org/include/asm-m32r/ipcbuf.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/ipcbuf.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,33 @@
+#ifndef _ASM_M32R_IPCBUF_H
+#define _ASM_M32R_IPCBUF_H
+
+/* $Id$ */
+
+/* orig : i386 2.4.18 */
+
+/*
+ * The ipc64_perm structure for m32r architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 32-bit mode_t and seq
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct ipc64_perm
+{
+	__kernel_key_t		key;
+	__kernel_uid32_t	uid;
+	__kernel_gid32_t	gid;
+	__kernel_uid32_t	cuid;
+	__kernel_gid32_t	cgid;
+	__kernel_mode_t		mode;
+	unsigned short		__pad1;
+	unsigned short		seq;
+	unsigned short		__pad2;
+	unsigned long		__unused1;
+	unsigned long		__unused2;
+};
+
+#endif /* _ASM_M32R_IPCBUF_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/irq.h linux-2.6.7/include/asm-m32r/irq.h
--- linux-2.6.7.org/include/asm-m32r/irq.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/irq.h	2004-07-27 15:54:20.000000000 +0900
@@ -0,0 +1,86 @@
+#ifndef _ASM_M32R_IRQ_H
+#define _ASM_M32R_IRQ_H
+
+/* $Id$ */
+
+#include <linux/config.h>
+
+#if defined(CONFIG_PLAT_M32700UT_Alpha) || defined(CONFIG_PLAT_USRV)
+/* 
+ * IRQ definitions for M32700UT
+ *  M32700 Chip: 64 interrupts
+ *  ICU of M32700UT-on-board PLD: 32 interrupts cascaded to INT1# chip pin
+ */ 
+#define	M32700UT_NUM_CPU_IRQ	(64)
+#define M32700UT_NUM_PLD_IRQ	(32)
+#define M32700UT_IRQ_BASE	0
+#define M32700UT_CPU_IRQ_BASE	M32700UT_IRQ_BASE
+#define M32700UT_PLD_IRQ_BASE	(M32700UT_CPU_IRQ_BASE + M32700UT_NUM_CPU_IRQ)
+
+#define NR_IRQS	(M32700UT_NUM_CPU_IRQ + M32700UT_NUM_PLD_IRQ)
+#elif defined(CONFIG_PLAT_M32700UT)
+/*
+ * IRQ definitions for M32700UT(Rev.C) + M32R-LAN
+ *  M32700 Chip: 64 interrupts
+ *  ICU of M32700UT-on-board PLD: 32 interrupts cascaded to INT1# chip pin
+ *  ICU of M32R-LCD-on-board PLD: 32 interrupts cascaded to INT2# chip pin
+ *  ICU of M32R-LAN-on-board PLD: 32 interrupts cascaded to INT0# chip pin
+ */
+#define M32700UT_NUM_CPU_IRQ		(64)
+#define M32700UT_NUM_PLD_IRQ		(32)
+#define M32700UT_NUM_LCD_PLD_IRQ	(32)
+#define M32700UT_NUM_LAN_PLD_IRQ	(32)
+#define M32700UT_IRQ_BASE		0
+#define M32700UT_CPU_IRQ_BASE		(M32700UT_IRQ_BASE)
+#define M32700UT_PLD_IRQ_BASE \
+	(M32700UT_CPU_IRQ_BASE + M32700UT_NUM_CPU_IRQ)
+#define M32700UT_LCD_PLD_IRQ_BASE \
+	(M32700UT_PLD_IRQ_BASE + M32700UT_NUM_PLD_IRQ)
+#define M32700UT_LAN_PLD_IRQ_BASE \
+	(M32700UT_LCD_PLD_IRQ_BASE + M32700UT_NUM_LCD_PLD_IRQ)
+
+#define NR_IRQS \
+	(M32700UT_NUM_CPU_IRQ + M32700UT_NUM_PLD_IRQ \
+	+ M32700UT_NUM_LCD_PLD_IRQ + M32700UT_NUM_LAN_PLD_IRQ)
+#elif defined(CONFIG_PLAT_OPSPUT)
+/*
+ * IRQ definitions for OPSPUT + M32R-LAN
+ *  OPSP Chip: 64 interrupts
+ *  ICU of OPSPUT-on-board PLD: 32 interrupts cascaded to INT1# chip pin
+ *  ICU of M32R-LCD-on-board PLD: 32 interrupts cascaded to INT2# chip pin
+ *  ICU of M32R-LAN-on-board PLD: 32 interrupts cascaded to INT0# chip pin
+ */
+#define OPSPUT_NUM_CPU_IRQ		(64)
+#define OPSPUT_NUM_PLD_IRQ		(32)
+#define OPSPUT_NUM_LCD_PLD_IRQ	(32)
+#define OPSPUT_NUM_LAN_PLD_IRQ	(32)
+#define OPSPUT_IRQ_BASE		0
+#define OPSPUT_CPU_IRQ_BASE		(OPSPUT_IRQ_BASE)
+#define OPSPUT_PLD_IRQ_BASE \
+	(OPSPUT_CPU_IRQ_BASE + OPSPUT_NUM_CPU_IRQ)
+#define OPSPUT_LCD_PLD_IRQ_BASE \
+	(OPSPUT_PLD_IRQ_BASE + OPSPUT_NUM_PLD_IRQ)
+#define OPSPUT_LAN_PLD_IRQ_BASE \
+	(OPSPUT_LCD_PLD_IRQ_BASE + OPSPUT_NUM_LCD_PLD_IRQ)
+
+#define NR_IRQS \
+	(OPSPUT_NUM_CPU_IRQ + OPSPUT_NUM_PLD_IRQ \
+	+ OPSPUT_NUM_LCD_PLD_IRQ + OPSPUT_NUM_LAN_PLD_IRQ)
+#else
+#define NR_IRQS	64
+#endif
+
+#define irq_canonicalize(irq)	(irq)
+
+#ifndef __ASSEMBLY__
+extern void disable_irq(unsigned int);
+extern void disable_irq_nosync(unsigned int);
+extern void enable_irq(unsigned int);
+
+struct irqaction;
+struct pt_regs;
+int handle_IRQ_event(unsigned int, struct pt_regs *, struct irqaction *);
+#endif
+
+#endif	/* _ASM_M32R_IRQ_H */
+
diff -ruN linux-2.6.7.org/include/asm-m32r/kmap_types.h linux-2.6.7/include/asm-m32r/kmap_types.h
--- linux-2.6.7.org/include/asm-m32r/kmap_types.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/kmap_types.h	2004-06-07 15:39:38.000000000 +0900
@@ -0,0 +1,34 @@
+#ifndef __M32R_KMAP_TYPES_H
+#define __M32R_KMAP_TYPES_H
+
+/* Dummy header just to define km_type. */
+
+#include <linux/config.h>
+
+#ifdef CONFIG_DEBUG_HIGHMEM
+# define D(n) __KM_FENCE_##n ,
+#else
+# define D(n)
+#endif
+
+enum km_type {
+D(0)	KM_BOUNCE_READ,
+D(1)	KM_SKB_SUNRPC_DATA,
+D(2)	KM_SKB_DATA_SOFTIRQ,
+D(3)	KM_USER0,
+D(4)	KM_USER1,
+D(5)	KM_BIO_SRC_IRQ,
+D(6)	KM_BIO_DST_IRQ,
+D(7)	KM_PTE0,
+D(8)	KM_PTE1,
+D(9)	KM_IRQ0,
+D(10)	KM_IRQ1,
+D(11)	KM_SOFTIRQ0,
+D(12)	KM_SOFTIRQ1,
+D(13)	KM_TYPE_NR
+};
+
+#undef D
+
+#endif /* __M32R_KMAP_TYPES_H */
+
diff -ruN linux-2.6.7.org/include/asm-m32r/linkage.h linux-2.6.7/include/asm-m32r/linkage.h
--- linux-2.6.7.org/include/asm-m32r/linkage.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/linkage.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,7 @@
+#ifndef __ASM_LINKAGE_H
+#define __ASM_LINKAGE_H
+
+#define __ALIGN		.balign 4
+#define __ALIGN_STR	".balign 4"
+
+#endif /* __ASM_LINKAGE_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/local.h linux-2.6.7/include/asm-m32r/local.h
--- linux-2.6.7.org/include/asm-m32r/local.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/local.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,6 @@
+#ifndef __M32R_LOCAL_H
+#define __M32R_LOCAL_H
+
+#include <asm-generic/local.h>
+
+#endif /* __M32R_LOCAL_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/m32102.h linux-2.6.7/include/asm-m32r/m32102.h
--- linux-2.6.7.org/include/asm-m32r/m32102.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/m32102.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,265 @@
+#ifndef _M32102_H_
+#define _M32102_H_
+
+/* 
+ * Mitsubishi M32R 32102 group
+ * Copyright (c) 2001 [Hitoshi Yamamoto] All rights reserved.
+ */
+/* $Id$ */
+
+/*======================================================================*
+ * Special Function Register
+ *======================================================================*/
+#define M32R_SFR_OFFSET  (0x00E00000)  /* 0x00E00000-0x00EFFFFF 1[MB] */
+
+/* 
+ * Clock and Power Management registers.
+ */
+#define M32R_CPM_OFFSET          (0x000F4000+M32R_SFR_OFFSET)
+
+#define M32R_CPM_CPUCLKCR_PORTL  (0x00+M32R_CPM_OFFSET)
+#define M32R_CPM_CLKMOD_PORTL    (0x04+M32R_CPM_OFFSET)
+#define M32R_CPM_PLLCR_PORTL     (0x08+M32R_CPM_OFFSET)
+
+/* 
+ * Multi Function Timer registers.
+ */
+#define M32R_MFT_OFFSET        (0x000FC000+M32R_SFR_OFFSET)
+
+#define M32R_MFTCR_PORTL       (0x000+M32R_MFT_OFFSET)  /* MFT control */
+#define M32R_MFTRPR_PORTL      (0x004+M32R_MFT_OFFSET)  /* MFT real port */
+
+#define M32R_MFT0_OFFSET       (0x100+M32R_MFT_OFFSET)
+#define M32R_MFT0MOD_PORTL     (0x00+M32R_MFT0_OFFSET)  /* MFT0 mode */
+#define M32R_MFT0BOS_PORTL     (0x04+M32R_MFT0_OFFSET)  /* MFT0 b-port output status */
+#define M32R_MFT0CUT_PORTL     (0x08+M32R_MFT0_OFFSET)  /* MFT0 count */
+#define M32R_MFT0RLD_PORTL     (0x0C+M32R_MFT0_OFFSET)  /* MFT0 reload */
+#define M32R_MFT0CMPRLD_PORTL  (0x10+M32R_MFT0_OFFSET)  /* MFT0 compare reload */
+
+#define M32R_MFT1_OFFSET       (0x200+M32R_MFT_OFFSET)
+#define M32R_MFT1MOD_PORTL     (0x00+M32R_MFT1_OFFSET)  /* MFT1 mode */
+#define M32R_MFT1BOS_PORTL     (0x04+M32R_MFT1_OFFSET)  /* MFT1 b-port output status */
+#define M32R_MFT1CUT_PORTL     (0x08+M32R_MFT1_OFFSET)  /* MFT1 count */
+#define M32R_MFT1RLD_PORTL     (0x0C+M32R_MFT1_OFFSET)  /* MFT1 reload */
+#define M32R_MFT1CMPRLD_PORTL  (0x10+M32R_MFT1_OFFSET)  /* MFT1 compare reload */
+
+#define M32R_MFT2_OFFSET       (0x300+M32R_MFT_OFFSET)
+#define M32R_MFT2MOD_PORTL     (0x00+M32R_MFT2_OFFSET)  /* MFT2 mode */
+#define M32R_MFT2BOS_PORTL     (0x04+M32R_MFT2_OFFSET)  /* MFT2 b-port output status */
+#define M32R_MFT2CUT_PORTL     (0x08+M32R_MFT2_OFFSET)  /* MFT2 count */
+#define M32R_MFT2RLD_PORTL     (0x0C+M32R_MFT2_OFFSET)  /* MFT2 reload */
+#define M32R_MFT2CMPRLD_PORTL  (0x10+M32R_MFT2_OFFSET)  /* MFT2 compare reload */
+
+#define M32R_MFT3_OFFSET       (0x400+M32R_MFT_OFFSET)
+#define M32R_MFT3MOD_PORTL     (0x00+M32R_MFT3_OFFSET)  /* MFT3 mode */
+#define M32R_MFT3BOS_PORTL     (0x04+M32R_MFT3_OFFSET)  /* MFT3 b-port output status */
+#define M32R_MFT3CUT_PORTL     (0x08+M32R_MFT3_OFFSET)  /* MFT3 count */
+#define M32R_MFT3RLD_PORTL     (0x0C+M32R_MFT3_OFFSET)  /* MFT3 reload */
+#define M32R_MFT3CMPRLD_PORTL  (0x10+M32R_MFT3_OFFSET)  /* MFT3 compare reload */
+
+#define M32R_MFT4_OFFSET       (0x500+M32R_MFT_OFFSET)
+#define M32R_MFT4MOD_PORTL     (0x00+M32R_MFT4_OFFSET)  /* MFT4 mode */
+#define M32R_MFT4BOS_PORTL     (0x04+M32R_MFT4_OFFSET)  /* MFT4 b-port output status */
+#define M32R_MFT4CUT_PORTL     (0x08+M32R_MFT4_OFFSET)  /* MFT4 count */
+#define M32R_MFT4RLD_PORTL     (0x0C+M32R_MFT4_OFFSET)  /* MFT4 reload */
+#define M32R_MFT4CMPRLD_PORTL  (0x10+M32R_MFT4_OFFSET)  /* MFT4 compare reload */
+
+#define M32R_MFT5_OFFSET       (0x600+M32R_MFT_OFFSET)
+#define M32R_MFT5MOD_PORTL     (0x00+M32R_MFT5_OFFSET)  /* MFT4 mode */
+#define M32R_MFT5BOS_PORTL     (0x04+M32R_MFT5_OFFSET)  /* MFT4 b-port output status */
+#define M32R_MFT5CUT_PORTL     (0x08+M32R_MFT5_OFFSET)  /* MFT4 count */
+#define M32R_MFT5RLD_PORTL     (0x0C+M32R_MFT5_OFFSET)  /* MFT4 reload */
+#define M32R_MFT5CMPRLD_PORTL  (0x10+M32R_MFT5_OFFSET)  /* MFT4 compare reload */
+
+#ifdef CONFIG_CHIP_M32700
+#define M32R_MFTCR_MFT0MSK  (1UL<<31)  /* b0 */
+#define M32R_MFTCR_MFT1MSK  (1UL<<30)  /* b1 */
+#define M32R_MFTCR_MFT2MSK  (1UL<<29)  /* b2 */
+#define M32R_MFTCR_MFT3MSK  (1UL<<28)  /* b3 */
+#define M32R_MFTCR_MFT4MSK  (1UL<<27)  /* b4 */
+#define M32R_MFTCR_MFT5MSK  (1UL<<26)  /* b5 */
+#define M32R_MFTCR_MFT0EN   (1UL<<23)  /* b8 */
+#define M32R_MFTCR_MFT1EN   (1UL<<22)  /* b9 */
+#define M32R_MFTCR_MFT2EN   (1UL<<21)  /* b10 */
+#define M32R_MFTCR_MFT3EN   (1UL<<20)  /* b11 */
+#define M32R_MFTCR_MFT4EN   (1UL<<19)  /* b12 */
+#define M32R_MFTCR_MFT5EN   (1UL<<18)  /* b13 */
+#else	/* not CONFIG_CHIP_M32700 */
+#define M32R_MFTCR_MFT0MSK  (1UL<<15)  /* b16 */
+#define M32R_MFTCR_MFT1MSK  (1UL<<14)  /* b17 */
+#define M32R_MFTCR_MFT2MSK  (1UL<<13)  /* b18 */
+#define M32R_MFTCR_MFT3MSK  (1UL<<12)  /* b19 */
+#define M32R_MFTCR_MFT4MSK  (1UL<<11)  /* b20 */
+#define M32R_MFTCR_MFT5MSK  (1UL<<10)  /* b21 */
+#define M32R_MFTCR_MFT0EN   (1UL<<7)   /* b24 */
+#define M32R_MFTCR_MFT1EN   (1UL<<6)   /* b25 */
+#define M32R_MFTCR_MFT2EN   (1UL<<5)   /* b26 */
+#define M32R_MFTCR_MFT3EN   (1UL<<4)   /* b27 */
+#define M32R_MFTCR_MFT4EN   (1UL<<3)   /* b28 */
+#define M32R_MFTCR_MFT5EN   (1UL<<2)   /* b29 */
+#endif	/* not CONFIG_CHIP_M32700 */
+
+#define M32R_MFTMOD_CC_MASK    (1UL<<15)  /* b16 */
+#define M32R_MFTMOD_TCCR       (1UL<<13)  /* b18 */
+#define M32R_MFTMOD_GTSEL000   (0UL<<8)   /* b21-23 : 000 */
+#define M32R_MFTMOD_GTSEL001   (1UL<<8)   /* b21-23 : 001 */
+#define M32R_MFTMOD_GTSEL010   (2UL<<8)   /* b21-23 : 010 */
+#define M32R_MFTMOD_GTSEL011   (3UL<<8)   /* b21-23 : 011 */
+#define M32R_MFTMOD_GTSEL110   (6UL<<8)   /* b21-23 : 110 */
+#define M32R_MFTMOD_GTSEL111   (7UL<<8)   /* b21-23 : 111 */
+#define M32R_MFTMOD_CMSEL      (1UL<<3)   /* b28 */
+#define M32R_MFTMOD_CSSEL000   (0UL<<0)   /* b29-b31 : 000 */
+#define M32R_MFTMOD_CSSEL001   (1UL<<0)   /* b29-b31 : 001 */
+#define M32R_MFTMOD_CSSEL010   (2UL<<0)   /* b29-b31 : 010 */
+#define M32R_MFTMOD_CSSEL011   (3UL<<0)   /* b29-b31 : 011 */
+#define M32R_MFTMOD_CSSEL100   (4UL<<0)   /* b29-b31 : 100 */
+#define M32R_MFTMOD_CSSEL110   (6UL<<0)   /* b29-b31 : 110 */
+
+/* 
+ * Serial I/O registers.
+ */
+#define M32R_SIO_OFFSET  (0x000FD000+M32R_SFR_OFFSET)
+
+#define M32R_SIO0_CR_PORTL     (0x000+M32R_SIO_OFFSET)
+#define M32R_SIO0_MOD0_PORTL   (0x004+M32R_SIO_OFFSET)
+#define M32R_SIO0_MOD1_PORTL   (0x008+M32R_SIO_OFFSET)
+#define M32R_SIO0_STS_PORTL    (0x00C+M32R_SIO_OFFSET)
+#define M32R_SIO0_TRCR_PORTL   (0x010+M32R_SIO_OFFSET)
+#define M32R_SIO0_BAUR_PORTL   (0x014+M32R_SIO_OFFSET)
+#define M32R_SIO0_RBAUR_PORTL  (0x018+M32R_SIO_OFFSET)
+#define M32R_SIO0_TXB_PORTL    (0x01C+M32R_SIO_OFFSET)
+#define M32R_SIO0_RXB_PORTL    (0x020+M32R_SIO_OFFSET)
+
+/* 
+ * Interrupt Control Unit registers.
+ */
+#define M32R_ICU_OFFSET       (0x000FF000+M32R_SFR_OFFSET)
+#define M32R_ICU_ISTS_PORTL   (0x004+M32R_ICU_OFFSET)
+#define M32R_ICU_IREQ0_PORTL  (0x008+M32R_ICU_OFFSET)
+#define M32R_ICU_IREQ1_PORTL  (0x00C+M32R_ICU_OFFSET)
+#define M32R_ICU_SBICR_PORTL  (0x018+M32R_ICU_OFFSET)
+#define M32R_ICU_IMASK_PORTL  (0x01C+M32R_ICU_OFFSET)
+#define M32R_ICU_CR1_PORTL    (0x200+M32R_ICU_OFFSET)  /* INT0 */
+#define M32R_ICU_CR2_PORTL    (0x204+M32R_ICU_OFFSET)  /* INT1 */
+#define M32R_ICU_CR3_PORTL    (0x208+M32R_ICU_OFFSET)  /* INT2 */
+#define M32R_ICU_CR4_PORTL    (0x20C+M32R_ICU_OFFSET)  /* INT3 */
+#define M32R_ICU_CR5_PORTL    (0x210+M32R_ICU_OFFSET)  /* INT4 */
+#define M32R_ICU_CR6_PORTL    (0x214+M32R_ICU_OFFSET)  /* INT5 */
+#define M32R_ICU_CR7_PORTL    (0x218+M32R_ICU_OFFSET)  /* INT6 */
+#define M32R_ICU_CR16_PORTL   (0x23C+M32R_ICU_OFFSET)  /* MFT0 */
+#define M32R_ICU_CR17_PORTL   (0x240+M32R_ICU_OFFSET)  /* MFT1 */
+#define M32R_ICU_CR18_PORTL   (0x244+M32R_ICU_OFFSET)  /* MFT2 */
+#define M32R_ICU_CR19_PORTL   (0x248+M32R_ICU_OFFSET)  /* MFT3 */
+#define M32R_ICU_CR20_PORTL   (0x24C+M32R_ICU_OFFSET)  /* MFT4 */
+#define M32R_ICU_CR21_PORTL   (0x250+M32R_ICU_OFFSET)  /* MFT5 */
+#define M32R_ICU_CR32_PORTL   (0x27C+M32R_ICU_OFFSET)  /* DMA0 */
+#define M32R_ICU_CR33_PORTL   (0x280+M32R_ICU_OFFSET)  /* DMA1 */
+#define M32R_ICU_CR48_PORTL   (0x2BC+M32R_ICU_OFFSET)  /* SIO0 */
+#define M32R_ICU_CR49_PORTL   (0x2C0+M32R_ICU_OFFSET)  /* SIO0 */
+#define M32R_ICU_CR50_PORTL   (0x2C4+M32R_ICU_OFFSET)  /* SIO1 */
+#define M32R_ICU_CR51_PORTL   (0x2C8+M32R_ICU_OFFSET)  /* SIO1 */
+#define M32R_ICU_CR52_PORTL   (0x2CC+M32R_ICU_OFFSET)  /* SIO2 */
+#define M32R_ICU_CR53_PORTL   (0x2D0+M32R_ICU_OFFSET)  /* SIO2 */
+#define M32R_ICU_CR54_PORTL   (0x2D4+M32R_ICU_OFFSET)  /* SIO3 */
+#define M32R_ICU_CR55_PORTL   (0x2D8+M32R_ICU_OFFSET)  /* SIO3 */
+#define M32R_ICU_CR56_PORTL   (0x2DC+M32R_ICU_OFFSET)  /* SIO4 */
+#define M32R_ICU_CR57_PORTL   (0x2E0+M32R_ICU_OFFSET)  /* SIO4 */
+
+#ifdef CONFIG_SMP
+#define M32R_ICU_IPICR0_PORTL (0x2dc+M32R_ICU_OFFSET)  /* IPI0 */
+#define M32R_ICU_IPICR1_PORTL (0x2e0+M32R_ICU_OFFSET)  /* IPI1 */
+#define M32R_ICU_IPICR2_PORTL (0x2e4+M32R_ICU_OFFSET)  /* IPI2 */
+#define M32R_ICU_IPICR3_PORTL (0x2e8+M32R_ICU_OFFSET)  /* IPI3 */
+#define M32R_ICU_IPICR4_PORTL (0x2ec+M32R_ICU_OFFSET)  /* IPI4 */
+#define M32R_ICU_IPICR5_PORTL (0x2f0+M32R_ICU_OFFSET)  /* IPI5 */
+#define M32R_ICU_IPICR6_PORTL (0x2f4+M32R_ICU_OFFSET)  /* IPI6 */
+#define M32R_ICU_IPICR7_PORTL (0x2f8+M32R_ICU_OFFSET)  /* IPI7 */
+#endif /* CONFIG_SMP */
+
+#define M32R_ICUIMASK_IMSK0  (0UL<<16)  /* b13-b15: Disable interrupt */
+#define M32R_ICUIMASK_IMSK1  (1UL<<16)  /* b13-b15: Enable level 0 interrupt */
+#define M32R_ICUIMASK_IMSK2  (2UL<<16)  /* b13-b15: Enable level 0,1 interrupt */
+#define M32R_ICUIMASK_IMSK3  (3UL<<16)  /* b13-b15: Enable level 0-2 interrupt */
+#define M32R_ICUIMASK_IMSK4  (4UL<<16)  /* b13-b15: Enable level 0-3 interrupt */
+#define M32R_ICUIMASK_IMSK5  (5UL<<16)  /* b13-b15: Enable level 0-4 interrupt */
+#define M32R_ICUIMASK_IMSK6  (6UL<<16)  /* b13-b15: Enable level 0-5 interrupt */
+#define M32R_ICUIMASK_IMSK7  (7UL<<16)  /* b13-b15: Enable level 0-6 interrupt */
+
+#define M32R_ICUCR_IEN      (1UL<<12)  /* b19: Interrupt enable */
+#define M32R_ICUCR_IRQ      (1UL<<8)   /* b23: Interrupt request */
+#define M32R_ICUCR_ISMOD00  (0UL<<4)   /* b26-b27: Interrupt sense mode Edge HtoL */
+#define M32R_ICUCR_ISMOD01  (1UL<<4)   /* b26-b27: Interrupt sense mode Level L */
+#define M32R_ICUCR_ISMOD10  (2UL<<4)   /* b26-b27: Interrupt sense mode Edge LtoH*/
+#define M32R_ICUCR_ISMOD11  (3UL<<4)   /* b26-b27: Interrupt sense mode Level H */
+#define M32R_ICUCR_ILEVEL0  (0UL<<0)   /* b29-b31: Interrupt priority level 0 */
+#define M32R_ICUCR_ILEVEL1  (1UL<<0)   /* b29-b31: Interrupt priority level 1 */
+#define M32R_ICUCR_ILEVEL2  (2UL<<0)   /* b29-b31: Interrupt priority level 2 */
+#define M32R_ICUCR_ILEVEL3  (3UL<<0)   /* b29-b31: Interrupt priority level 3 */
+#define M32R_ICUCR_ILEVEL4  (4UL<<0)   /* b29-b31: Interrupt priority level 4 */
+#define M32R_ICUCR_ILEVEL5  (5UL<<0)   /* b29-b31: Interrupt priority level 5 */
+#define M32R_ICUCR_ILEVEL6  (6UL<<0)   /* b29-b31: Interrupt priority level 6 */
+#define M32R_ICUCR_ILEVEL7  (7UL<<0)   /* b29-b31: Disable interrupt */
+
+#define  M32R_IRQ_INT0    (1)   /* INT0 */
+#define  M32R_IRQ_INT1    (2)   /* INT1 */
+#define  M32R_IRQ_INT2    (3)   /* INT2 */
+#define  M32R_IRQ_INT3    (4)   /* INT3 */
+#define  M32R_IRQ_INT4    (5)   /* INT4 */
+#define  M32R_IRQ_INT5    (6)   /* INT5 */
+#define  M32R_IRQ_INT6    (7)   /* INT6 */
+#define  M32R_IRQ_MFT0    (16)  /* MFT0 */
+#define  M32R_IRQ_MFT1    (17)  /* MFT1 */
+#define  M32R_IRQ_MFT2    (18)  /* MFT2 */
+#define  M32R_IRQ_MFT3    (19)  /* MFT3 */
+#define  M32R_IRQ_MFT4    (20)  /* MFT4 */
+#define  M32R_IRQ_MFT5    (21)  /* MFT5 */
+#define  M32R_IRQ_DMA0    (32)  /* DMA0 */
+#define  M32R_IRQ_DMA1    (33)  /* DMA1 */
+#define  M32R_IRQ_SIO0_R  (48)  /* SIO0 send    */
+#define  M32R_IRQ_SIO0_S  (49)  /* SIO0 receive */
+#define  M32R_IRQ_SIO1_R  (50)  /* SIO1 send    */
+#define  M32R_IRQ_SIO1_S  (51)  /* SIO1 receive */
+#define  M32R_IRQ_SIO2_R  (52)  /* SIO2 send    */
+#define  M32R_IRQ_SIO2_S  (53)  /* SIO2 receive */
+#define  M32R_IRQ_SIO3_R  (54)  /* SIO3 send    */
+#define  M32R_IRQ_SIO3_S  (55)  /* SIO3 receive */
+#define  M32R_IRQ_SIO4_R  (56)  /* SIO4 send    */
+#define  M32R_IRQ_SIO4_S  (57)  /* SIO4 receive */
+
+#ifdef CONFIG_SMP
+#define M32R_IRQ_IPI0 (56)
+#define M32R_IRQ_IPI1 (57)
+#define M32R_IRQ_IPI2 (58)
+#define M32R_IRQ_IPI3 (59)
+#define M32R_IRQ_IPI4 (60)
+#define M32R_IRQ_IPI5 (61)
+#define M32R_IRQ_IPI6 (62)
+#define M32R_IRQ_IPI7 (63)
+#define M32R_CPUID_PORTL (0xffffffe0)
+
+#define M32R_FPGA_TOP (0x000F0000+M32R_SFR_OFFSET)
+
+#define M32R_FPGA_NUM_OF_CPUS_PORTL (0x00+M32R_FPGA_TOP)
+#define M32R_FPGA_CPU_NAME0_PORTL   (0x10+M32R_FPGA_TOP)
+#define M32R_FPGA_CPU_NAME1_PORTL   (0x14+M32R_FPGA_TOP)
+#define M32R_FPGA_CPU_NAME2_PORTL   (0x18+M32R_FPGA_TOP)
+#define M32R_FPGA_CPU_NAME3_PORTL   (0x1c+M32R_FPGA_TOP)
+#define M32R_FPGA_MODEL_ID0_PORTL   (0x20+M32R_FPGA_TOP)
+#define M32R_FPGA_MODEL_ID1_PORTL   (0x24+M32R_FPGA_TOP)
+#define M32R_FPGA_MODEL_ID2_PORTL   (0x28+M32R_FPGA_TOP)
+#define M32R_FPGA_MODEL_ID3_PORTL   (0x2c+M32R_FPGA_TOP)
+#define M32R_FPGA_VERSION0_PORTL    (0x30+M32R_FPGA_TOP)
+#define M32R_FPGA_VERSION1_PORTL    (0x34+M32R_FPGA_TOP)
+
+#ifndef __ASSEMBLY__
+/* For NETDEV WATCHDOG */
+typedef struct {
+	unsigned long icucr;	/* ICU Control Register */
+} icu_data_t;
+
+extern icu_data_t icu_data[];
+#endif
+
+#endif /* CONFIG_SMP */
+
+#endif /* _M32102_H_ */
diff -ruN linux-2.6.7.org/include/asm-m32r/m32102peri.h linux-2.6.7/include/asm-m32r/m32102peri.h
--- linux-2.6.7.org/include/asm-m32r/m32102peri.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/m32102peri.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,468 @@
+/* $Id$
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000,2001 by Hiroyuki Kondo
+ */
+
+#ifndef __ASSEMBLY__
+
+typedef	void	V;
+typedef	char	B;
+typedef	short	S;
+typedef	int		W;
+typedef	long	L;
+typedef	float	F;
+typedef	double	D;
+typedef	unsigned char	UB;
+typedef	unsigned short	US;
+typedef	unsigned int	UW;
+typedef	unsigned long	UL;
+typedef	const unsigned int	CUW;
+
+/*********************************
+
+M32102 ICU
+
+*********************************/
+#define		ICUISTS		(UW *)0xa0EFF004
+#define		ICUIREQ0	(UW *)0xa0EFF008
+#define		ICUIREQ1	(UW *)0xa0EFF00C
+
+#define		ICUSBICR	(UW *)0xa0EFF018
+#define		ICUIMASK	(UW *)0xa0EFF01C
+
+#define		ICUCR1		(UW *)0xa0EFF200	/* INT0 */
+#define		ICUCR2		(UW *)0xa0EFF204	/* INT1 */
+#define		ICUCR3		(UW *)0xa0EFF208	/* INT2 */
+#define		ICUCR4		(UW *)0xa0EFF20C	/* INT3 */
+#define		ICUCR5		(UW *)0xa0EFF210	/* INT4 */
+#define		ICUCR6		(UW *)0xa0EFF214	/* INT5 */
+#define		ICUCR7		(UW *)0xa0EFF218	/* INT6 */
+
+#define		ICUCR16		(UW *)0xa0EFF23C	/* MFT0 */
+#define		ICUCR17		(UW *)0xa0EFF240	/* MFT1 */
+#define		ICUCR18		(UW *)0xa0EFF244	/* MFT2 */
+#define		ICUCR19		(UW *)0xa0EFF248	/* MFT3 */
+#define		ICUCR20		(UW *)0xa0EFF24C	/* MFT4 */
+#define		ICUCR21		(UW *)0xa0EFF250	/* MFT5 */
+
+#define		ICUCR32		(UW *)0xa0EFF27C	/* DMA0 */
+#define		ICUCR33		(UW *)0xa0EFF280	/* DMA1 */
+
+#define		ICUCR48		(UW *)0xa0EFF2BC	/* SIO0R */
+#define		ICUCR49		(UW *)0xa0EFF2C0	/* SIO0S */
+#define		ICUCR50		(UW *)0xa0EFF2C4	/* SIO1R */
+#define		ICUCR51		(UW *)0xa0EFF2C8	/* SIO1S */
+#define		ICUCR52		(UW *)0xa0EFF2CC	/* SIO2R */
+#define		ICUCR53		(UW *)0xa0EFF2D0	/* SIO2S */
+#define		ICUCR54		(UW *)0xa0EFF2D4	/* SIO3R */
+#define		ICUCR55		(UW *)0xa0EFF2D8	/* SIO3S */
+#define		ICUCR56		(UW *)0xa0EFF2DC	/* SIO4R */
+#define		ICUCR57		(UW *)0xa0EFF2E0	/* SIO4S */
+
+/*********************************
+
+M32102 MFT
+
+*********************************/
+#define		MFTCR		(US *)0xa0EFC002
+#define		MFTRPR		(UB *)0xa0EFC006
+
+#define		MFT0MOD		(US *)0xa0EFC102
+#define		MFT0BOS		(US *)0xa0EFC106
+#define		MFT0CUT		(US *)0xa0EFC10A
+#define		MFT0RLD		(US *)0xa0EFC10E
+#define		MFT0CRLD	(US *)0xa0EFC112
+
+#define		MFT1MOD		(US *)0xa0EFC202
+#define		MFT1BOS		(US *)0xa0EFC206
+#define		MFT1CUT		(US *)0xa0EFC20A
+#define		MFT1RLD		(US *)0xa0EFC20E
+#define		MFT1CRLD	(US *)0xa0EFC212
+
+#define		MFT2MOD		(US *)0xa0EFC302
+#define		MFT2BOS		(US *)0xa0EFC306
+#define		MFT2CUT		(US *)0xa0EFC30A
+#define		MFT2RLD		(US *)0xa0EFC30E
+#define		MFT2CRLD	(US *)0xa0EFC312
+
+#define		MFT3MOD		(US *)0xa0EFC402
+#define		MFT3CUT		(US *)0xa0EFC40A
+#define		MFT3RLD		(US *)0xa0EFC40E
+#define		MFT3CRLD	(US *)0xa0EFC412
+
+#define		MFT4MOD		(US *)0xa0EFC502
+#define		MFT4CUT		(US *)0xa0EFC50A
+#define		MFT4RLD		(US *)0xa0EFC50E
+#define		MFT4CRLD	(US *)0xa0EFC512
+
+#define		MFT5MOD		(US *)0xa0EFC602
+#define		MFT5CUT		(US *)0xa0EFC60A
+#define		MFT5RLD		(US *)0xa0EFC60E
+#define		MFT5CRLD	(US *)0xa0EFC612
+
+/*********************************
+
+M32102 SIO
+
+*********************************/
+
+#define SIO0CR     (volatile int *)0xa0efd000
+#define SIO0MOD0   (volatile int *)0xa0efd004
+#define SIO0MOD1   (volatile int *)0xa0efd008
+#define SIO0STS    (volatile int *)0xa0efd00c
+#define SIO0IMASK  (volatile int *)0xa0efd010
+#define SIO0BAUR   (volatile int *)0xa0efd014
+#define SIO0RBAUR  (volatile int *)0xa0efd018
+#define SIO0TXB    (volatile int *)0xa0efd01c
+#define SIO0RXB    (volatile int *)0xa0efd020
+
+#define SIO1CR     (volatile int *)0xa0efd100
+#define SIO1MOD0   (volatile int *)0xa0efd104
+#define SIO1MOD1   (volatile int *)0xa0efd108
+#define SIO1STS    (volatile int *)0xa0efd10c
+#define SIO1IMASK  (volatile int *)0xa0efd110
+#define SIO1BAUR   (volatile int *)0xa0efd114
+#define SIO1RBAUR  (volatile int *)0xa0efd118
+#define SIO1TXB    (volatile int *)0xa0efd11c
+#define SIO1RXB    (volatile int *)0xa0efd120
+/*********************************
+
+M32102 PORT
+
+*********************************/
+#define		PIEN		(UB *)0xa0EF1003	/* input enable */
+
+#define		P0DATA		(UB *)0xa0EF1020	/* data */
+#define		P1DATA		(UB *)0xa0EF1021
+#define		P2DATA		(UB *)0xa0EF1022
+#define		P3DATA		(UB *)0xa0EF1023
+#define		P4DATA		(UB *)0xa0EF1024
+#define		P5DATA		(UB *)0xa0EF1025
+#define		P6DATA		(UB *)0xa0EF1026
+#define		P7DATA		(UB *)0xa0EF1027
+
+#define		P0DIR		(UB *)0xa0EF1040	/* direction */
+#define		P1DIR		(UB *)0xa0EF1041
+#define		P2DIR		(UB *)0xa0EF1042
+#define		P3DIR		(UB *)0xa0EF1043
+#define		P4DIR		(UB *)0xa0EF1044
+#define		P5DIR		(UB *)0xa0EF1045
+#define		P6DIR		(UB *)0xa0EF1046
+#define		P7DIR		(UB *)0xa0EF1047
+
+#define		P0MOD		(US *)0xa0EF1060	/* mode control */
+#define		P1MOD		(US *)0xa0EF1062
+#define		P2MOD		(US *)0xa0EF1064
+#define		P3MOD		(US *)0xa0EF1066
+#define		P4MOD		(US *)0xa0EF1068
+#define		P5MOD		(US *)0xa0EF106A
+#define		P6MOD		(US *)0xa0EF106C
+#define		P7MOD		(US *)0xa0EF106E
+
+#define		P0ODCR		(UB *)0xa0EF1080	/* open-drain control */
+#define		P1ODCR		(UB *)0xa0EF1081
+#define		P2ODCR		(UB *)0xa0EF1082
+#define		P3ODCR		(UB *)0xa0EF1083
+#define		P4ODCR		(UB *)0xa0EF1084
+#define		P5ODCR		(UB *)0xa0EF1085
+#define		P6ODCR		(UB *)0xa0EF1086
+#define		P7ODCR		(UB *)0xa0EF1087
+
+/*********************************
+
+M32102 Cache
+
+********************************/
+                              
+#define		MCCR	(US *)0xFFFFFFFE
+ 
+
+#else  /* __ASSEMBLY__ */
+
+;;
+;; PIO     0x80ef1000
+;;
+
+#define PIEN          0xa0ef1000
+
+#define P0DATA        0xa0ef1020
+#define P1DATA        0xa0ef1021
+#define P2DATA        0xa0ef1022
+#define P3DATA        0xa0ef1023
+#define P4DATA        0xa0ef1024
+#define P5DATA        0xa0ef1025
+#define P6DATA        0xa0ef1026
+#define P7DATA        0xa0ef1027
+
+#define P0DIR         0xa0ef1040
+#define P1DIR         0xa0ef1041
+#define P2DIR         0xa0ef1042
+#define P3DIR         0xa0ef1043
+#define P4DIR         0xa0ef1044
+#define P5DIR         0xa0ef1045
+#define P6DIR         0xa0ef1046
+#define P7DIR         0xa0ef1047
+
+#define P0MOD         0xa0ef1060
+#define P1MOD         0xa0ef1062
+#define P2MOD         0xa0ef1064
+#define P3MOD         0xa0ef1066
+#define P4MOD         0xa0ef1068
+#define P5MOD         0xa0ef106a
+#define P6MOD         0xa0ef106c
+#define P7MOD         0xa0ef106e
+;
+#define P0ODCR        0xa0ef1080
+#define P1ODCR        0xa0ef1081
+#define P2ODCR        0xa0ef1082
+#define P3ODCR        0xa0ef1083
+#define P4ODCR        0xa0ef1084
+#define P5ODCR        0xa0ef1085
+#define P6ODCR        0xa0ef1086
+#define P7ODCR        0xa0ef1087
+
+;;
+;; WDT     0xa0ef2000
+;;
+
+#define WDTCR         0xa0ef2000
+
+
+;;
+;; CLK     0xa0ef4000
+;;
+
+#define CPUCLKCR      0xa0ef4000
+#define CLKMOD        0xa0ef4004
+#define PLLCR         0xa0ef4008
+
+
+;;
+;; BSEL    0xa0ef5000
+;;
+
+#define BSEL0CR       0xa0ef5000
+#define BSEL1CR       0xa0ef5004
+#define BSEL2CR       0xa0ef5008
+#define BSEL3CR       0xa0ef500c
+#define BSEL4CR       0xa0ef5010
+#define BSEL5CR       0xa0ef5014
+
+
+;;
+;; SDRAMC  0xa0ef6000
+;;
+
+#define SDRF0         0xa0ef6000
+#define SDRF1         0xa0ef6004
+#define SDIR0         0xa0ef6008
+#define SDIR1         0xa0ef600c
+#define SDBR          0xa0ef6010
+
+;; CH0
+#define SD0ADR        0xa0ef6020
+#define SD0SZ         0xa0ef6022
+#define SD0ER         0xa0ef6024
+#define SD0TR         0xa0ef6028
+#define SD0MOD        0xa0ef602c
+
+;; CH1
+#define SD1ADR        0xa0ef6040
+#define SD1SZ         0xa0ef6042
+#define SD1ER         0xa0ef6044
+#define SD1TR         0xa0ef6048
+#define SD1MOD        0xa0ef604c
+
+
+;;
+;; DMAC    0xa0ef8000
+;;
+
+#define DMAEN         0xa0ef8000
+#define DMAISTS       0xa0ef8004
+#define DMAEDET       0xa0ef8008
+#define DMAASTS       0xa0ef800c
+
+;; CH0
+#define DMA0CR0       0xa0ef8100
+#define DMA0CR1       0xa0ef8104
+#define DMA0CSA       0xa0ef8108
+#define DMA0RSA       0xa0ef810c
+#define DMA0CDA       0xa0ef8110
+#define DMA0RDA       0xa0ef8114
+#define DMA0CBCUT     0xa0ef8118
+#define DMA0RBCUT     0xa0ef811c
+
+;; CH1
+#define DMA1CR0       0xa0ef8200
+#define DMA1CR1       0xa0ef8204
+#define DMA1CSA       0xa0ef8208
+#define DMA1RSA       0xa0ef820c
+#define DMA1CDA       0xa0ef8210
+#define DMA1RDA       0xa0ef8214
+#define DMA1CBCUT     0xa0ef8218
+#define DMA1RBCUT     0xa0ef821c
+
+
+;;
+;; MFT     0xa0efc000
+;;
+
+#define MFTCR        0xa0efc000
+#define MFTRPR       0xa0efc004
+
+;; CH0
+#define MFT0MOD      0xa0efc100
+#define MFT0BOS      0xa0efc104
+#define MFT0CUT      0xa0efc108
+#define MFT0RLD      0xa0efc10c
+#define MFT0CMPRLD   0xa0efc110
+
+;; CH1
+#define MFT1MOD      0xa0efc200
+#define MFT1BOS      0xa0efc204
+#define MFT1CUT      0xa0efc208
+#define MFT1RLD      0xa0efc20c
+#define MFT1CMPRLD   0xa0efc210
+
+;; CH2
+#define MFT2MOD      0xa0efc300
+#define MFT2BOS      0xa0efc304
+#define MFT2CUT      0xa0efc308
+#define MFT2RLD      0xa0efc30c
+#define MFT2CMPRLD   0xa0efc310
+
+;; CH3
+#define MFT3MOD      0xa0efc400
+#define MFT3BOS      0xa0efc404
+#define MFT3CUT      0xa0efc408
+#define MFT3RLD      0xa0efc40c
+#define MFT3CMPRLD   0xa0efc410
+
+;; CH4
+#define MFT4MOD      0xa0efc500
+#define MFT4BOS      0xa0efc504
+#define MFT4CUT      0xa0efc508
+#define MFT4RLD      0xa0efc50c
+#define MFT4CMPRLD   0xa0efc510
+
+;; CH5
+#define MFT5MOD      0xa0efc600
+#define MFT5BOS      0xa0efc604
+#define MFT5CUT      0xa0efc608
+#define MFT5RLD      0xa0efc60c
+#define MFT5CMPRLD   0xa0efc610
+
+
+;;
+;; SIO     0xa0efd000
+;;
+
+;; CH0
+#define SIO0CR        0xa0efd000
+#define SIO0MOD0      0xa0efd004
+#define SIO0MOD1      0xa0efd008
+#define SIO0STS       0xa0efd00c
+#define SIO0IMASK     0xa0efd010
+#define SIO0BAUR      0xa0efd014
+#define SIO0RBAUR     0xa0efd018
+#define SIO0TXB       0xa0efd01c
+#define SIO0RXB       0xa0efd020
+
+;; CH1
+#define SIO1CR        0xa0efd100
+#define SIO1MOD0      0xa0efd104
+#define SIO1MOD1      0xa0efd108
+#define SIO1STS       0xa0efd10c
+#define SIO1IMASK     0xa0efd110
+#define SIO1BAUR      0xa0efd114
+#define SIO1RBAUR     0xa0efd118
+#define SIO1TXB       0xa0efd11c
+#define SIO1RXB       0xa0efd120
+
+;; CH2
+#define SIO2CR        0xa0efd200
+#define SIO2MOD0      0xa0efd204
+#define SIO2MOD1      0xa0efd208
+#define SIO2STS       0xa0efd20c
+#define SIO2IMASK     0xa0efd210
+#define SIO2BAUR      0xa0efd214
+#define SIO2RBAUR     0xa0efd218
+#define SIO2TXB       0xa0efd21c
+#define SIO2RXB       0xa0efd220
+
+;; CH3
+#define SIO3CR        0xa0efd300
+#define SIO3MOD0      0xa0efd304
+#define SIO3MOD1      0xa0efd308
+#define SIO3STS       0xa0efd30c
+#define SIO3IMASK     0xa0efd310
+#define SIO3BAUR      0xa0efd314
+#define SIO3RBAUR     0xa0efd318
+#define SIO3TXB       0xa0efd31c
+#define SIO3RXB       0xa0efd320
+
+;; CH4
+#define SIO4CR        0xa0efd400
+#define SIO4MOD0      0xa0efd404
+#define SIO4MOD1      0xa0efd408
+#define SIO4STS       0xa0efd40c
+#define SIO4IMASK     0xa0efd410
+#define SIO4BAUR      0xa0efd414
+#define SIO4RBAUR     0xa0efd418
+#define SIO4TXB       0xa0efd41c
+#define SIO4RXB       0xa0efd420
+
+
+;;
+;; ICU     0xa0eff000
+;;
+
+#define ICUISTS       0xa0eff004
+#define ICUIREQ0      0xa0eff008
+#define ICUIREQ1      0xa0eff00c
+
+#define ICUSBICR      0xa0eff018
+#define ICUIMASK      0xa0eff01c
+
+#define ICUCR1        0xa0eff200
+#define ICUCR2        0xa0eff204
+#define ICUCR3        0xa0eff208
+#define ICUCR4        0xa0eff20c
+#define ICUCR5        0xa0eff210
+#define ICUCR6        0xa0eff214
+#define ICUCR7        0xa0eff218
+
+#define ICUCR16       0xa0eff23c
+#define ICUCR17       0xa0eff240
+#define ICUCR18       0xa0eff244
+#define ICUCR19       0xa0eff248
+#define ICUCR20       0xa0eff24c
+#define ICUCR21       0xa0eff250
+
+#define ICUCR32       0xa0eff27c
+#define ICUCR33       0xa0eff280
+
+#define ICUCR48       0xa0eff2bc
+#define ICUCR49       0xa0eff2c0
+#define ICUCR50       0xa0eff2c4
+#define ICUCR51       0xa0eff2c8
+#define ICUCR52       0xa0eff2cc
+#define ICUCR53       0xa0eff2d0
+#define ICUCR54       0xa0eff2d4
+#define ICUCR55       0xa0eff2d8
+#define ICUCR56       0xa0eff2dc
+#define ICUCR57       0xa0eff2e0
+
+;;
+;; CACHE
+;;
+
+#define MCCR		  0xfffffffc
+
+
+#endif  /* __ASSEMBLY__ */
diff -ruN linux-2.6.7.org/include/asm-m32r/m32700ut/m32700ut_lan.h linux-2.6.7/include/asm-m32r/m32700ut/m32700ut_lan.h
--- linux-2.6.7.org/include/asm-m32r/m32700ut/m32700ut_lan.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/m32700ut/m32700ut_lan.h	2004-07-28 16:41:33.000000000 +0900
@@ -0,0 +1,107 @@
+/*
+ * include/asm/m32700ut_lan.h
+ *
+ * M32700UT-LAN board
+ *
+ * Copyright (c) 2002	Takeo Takahashi
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License.  See the file "COPYING" in the main directory of 
+ * this archive for more details.
+ *
+ * $Id$
+ */
+
+#ifndef _M32700UT_M32700UT_LAN_H
+#define _M32700UT_M32700UT_LAN_H
+
+#include <linux/config.h>
+
+#ifndef __ASSEMBLY__
+/*
+ * C functions use non-cache address.
+ */
+#define M32700UT_LAN_BASE	(0x10000000 /* + NONCACHE_OFFSET */)
+#else
+#define M32700UT_LAN_BASE	(0x10000000 + NONCACHE_OFFSET)
+#endif	/* __ASSEMBLY__ */
+
+/* ICU
+ *  ICUISTS:	status register
+ *  ICUIREQ0: 	request register
+ *  ICUIREQ1: 	request register
+ *  ICUCR3:	control register for CFIREQ# interrupt
+ *  ICUCR4:	control register for CFC Card insert interrupt
+ *  ICUCR5:	control register for CFC Card eject interrupt
+ *  ICUCR6:	control register for external interrupt
+ *  ICUCR11:	control register for MMC Card insert/eject interrupt
+ *  ICUCR13:	control register for SC error interrupt
+ *  ICUCR14:	control register for SC receive interrupt
+ *  ICUCR15:	control register for SC send interrupt
+ *  ICUCR16:	control register for SIO0 receive interrupt
+ *  ICUCR17:	control register for SIO0 send interrupt
+ */
+#define M32700UT_LAN_IRQ_LAN	(M32700UT_LAN_PLD_IRQ_BASE + 1)	/* LAN */
+#define M32700UT_LAN_IRQ_I2C	(M32700UT_LAN_PLD_IRQ_BASE + 3)	/* I2C */
+
+#define M32700UT_LAN_ICUISTS	__reg16(M32700UT_LAN_BASE + 0xc0002)
+#define M32700UT_LAN_ICUISTS_VECB_MASK	(0xf000)
+#define M32700UT_LAN_VECB(x)	((x) & M32700UT_LAN_ICUISTS_VECB_MASK)
+#define M32700UT_LAN_ICUISTS_ISN_MASK	(0x07c0)
+#define M32700UT_LAN_ICUISTS_ISN(x)	((x) & M32700UT_LAN_ICUISTS_ISN_MASK)
+#define M32700UT_LAN_ICUIREQ0	__reg16(M32700UT_LAN_BASE + 0xc0004)
+#define M32700UT_LAN_ICUCR1	__reg16(M32700UT_LAN_BASE + 0xc0010)
+#define M32700UT_LAN_ICUCR3	__reg16(M32700UT_LAN_BASE + 0xc0014)
+
+/*
+ * AR register on PLD
+ */
+#define ARVCR0		__reg32(M32700UT_LAN_BASE + 0x40000)
+#define ARVCR0_VDS		0x00080000
+#define ARVCR0_RST		0x00010000
+#define ARVCR1		__reg32(M32700UT_LAN_BASE + 0x40004)
+#define ARVCR1_QVGA		0x02000000
+#define ARVCR1_NORMAL		0x01000000
+#define ARVCR1_HIEN		0x00010000
+#define ARVHCOUNT	__reg32(M32700UT_LAN_BASE + 0x40008)
+#define ARDATA		__reg32(M32700UT_LAN_BASE + 0x40010)
+#define ARINTSEL	__reg32(M32700UT_LAN_BASE + 0x40014)
+#define ARINTSEL_INT3		0x10000000	/* CPU INT3 */
+#define ARDATA32	__reg32(M32700UT_LAN_BASE + 0x04040010)	// Block 5
+/* 
+#define ARINTSEL_SEL2		0x00002000
+#define ARINTSEL_SEL3		0x00001000
+#define ARINTSEL_SEL6		0x00000200
+#define ARINTSEL_SEL7		0x00000100
+#define ARINTSEL_SEL9		0x00000040
+#define ARINTSEL_SEL10		0x00000020
+#define ARINTSEL_SEL11		0x00000010
+#define ARINTSEL_SEL12		0x00000008
+*/
+
+/*
+ * I2C register on PLD
+ */
+#define PLDI2CCR	__reg32(M32700UT_LAN_BASE + 0x40040)
+#define	PLDI2CCR_ES0		0x00000001	/* enable I2C interface */  
+#define PLDI2CMOD	__reg32(M32700UT_LAN_BASE + 0x40044)
+#define PLDI2CMOD_ACKCLK	0x00000200
+#define PLDI2CMOD_DTWD		0x00000100
+#define PLDI2CMOD_10BT		0x00000004
+#define PLDI2CMOD_ATM_NORMAL	0x00000000
+#define PLDI2CMOD_ATM_AUTO	0x00000003
+#define PLDI2CACK	__reg32(M32700UT_LAN_BASE + 0x40048)
+#define PLDI2CACK_ACK		0x00000001
+#define PLDI2CFREQ	__reg32(M32700UT_LAN_BASE + 0x4004c)
+#define PLDI2CCND	__reg32(M32700UT_LAN_BASE + 0x40050)
+#define PLDI2CCND_START		0x00000001
+#define PLDI2CCND_STOP		0x00000002
+#define PLDI2CSTEN	__reg32(M32700UT_LAN_BASE + 0x40054)
+#define PLDI2CSTEN_STEN		0x00000001
+#define PLDI2CDATA	__reg32(M32700UT_LAN_BASE + 0x40060)
+#define PLDI2CSTS	__reg32(M32700UT_LAN_BASE + 0x40064)
+#define PLDI2CSTS_TRX		0x00000020
+#define PLDI2CSTS_BB		0x00000010
+#define PLDI2CSTS_NOACK		0x00000001	/* 0:ack, 1:noack */
+
+#endif	/* _M32700UT_M32700UT_LAN_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/m32700ut/m32700ut_lcd.h linux-2.6.7/include/asm-m32r/m32700ut/m32700ut_lcd.h
--- linux-2.6.7.org/include/asm-m32r/m32700ut/m32700ut_lcd.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/m32700ut/m32700ut_lcd.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,59 @@
+/*
+ * include/asm/m32700ut_lcd.h
+ *
+ * M32700UT-LCD board
+ *
+ * Copyright (c) 2002	Takeo Takahashi
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License.  See the file "COPYING" in the main directory of 
+ * this archive for more details.
+ *
+ * $Id$
+ */
+
+#ifndef _M32700UT_M32700UT_LCD_H
+#define _M32700UT_M32700UT_LCD_H
+
+#include <linux/config.h>
+
+#ifndef __ASSEMBLY__
+/*
+ * C functions use non-cache address.
+ */
+#define M32700UT_LCD_BASE	(0x10000000 /* + NONCACHE_OFFSET */)
+#else
+#define M32700UT_LCD_BASE	(0x10000000 + NONCACHE_OFFSET)
+#endif	/* __ASSEMBLY__ */
+
+/*
+ * ICU
+ */
+#define M32700UT_LCD_IRQ_BAT_INT	(M32700UT_LCD_PLD_IRQ_BASE + 1)
+#define M32700UT_LCD_IRQ_USB_INT1	(M32700UT_LCD_PLD_IRQ_BASE + 2)
+#define M32700UT_LCD_IRQ_AUDT0		(M32700UT_LCD_PLD_IRQ_BASE + 3)
+#define M32700UT_LCD_IRQ_AUDT2		(M32700UT_LCD_PLD_IRQ_BASE + 4)
+#define M32700UT_LCD_IRQ_BATSIO_RCV	(M32700UT_LCD_PLD_IRQ_BASE + 16)
+#define M32700UT_LCD_IRQ_BATSIO_SND	(M32700UT_LCD_PLD_IRQ_BASE + 17)
+#define M32700UT_LCD_IRQ_ASNDSIO_RCV	(M32700UT_LCD_PLD_IRQ_BASE + 18)
+#define M32700UT_LCD_IRQ_ASNDSIO_SND	(M32700UT_LCD_PLD_IRQ_BASE + 19)
+#define M32700UT_LCD_IRQ_ACNLSIO_SND	(M32700UT_LCD_PLD_IRQ_BASE + 21)
+
+#define M32700UT_LCD_ICUISTS	__reg16(M32700UT_LCD_BASE + 0x300002)
+#define M32700UT_LCD_ICUISTS_VECB_MASK	(0xf000)
+#define M32700UT_LCD_VECB(x)	((x) & M32700UT_LCD_ICUISTS_VECB_MASK)
+#define M32700UT_LCD_ICUISTS_ISN_MASK	(0x07c0)
+#define M32700UT_LCD_ICUISTS_ISN(x)	((x) & M32700UT_LCD_ICUISTS_ISN_MASK)
+#define M32700UT_LCD_ICUIREQ0	__reg16(M32700UT_LCD_BASE + 0x300004)
+#define M32700UT_LCD_ICUIREQ1	__reg16(M32700UT_LCD_BASE + 0x300006)
+#define M32700UT_LCD_ICUCR1	__reg16(M32700UT_LCD_BASE + 0x300020)
+#define M32700UT_LCD_ICUCR2	__reg16(M32700UT_LCD_BASE + 0x300022)
+#define M32700UT_LCD_ICUCR3	__reg16(M32700UT_LCD_BASE + 0x300024)
+#define M32700UT_LCD_ICUCR4	__reg16(M32700UT_LCD_BASE + 0x300026)
+#define M32700UT_LCD_ICUCR16	__reg16(M32700UT_LCD_BASE + 0x300030)
+#define M32700UT_LCD_ICUCR17	__reg16(M32700UT_LCD_BASE + 0x300032)
+#define M32700UT_LCD_ICUCR18	__reg16(M32700UT_LCD_BASE + 0x300034)
+#define M32700UT_LCD_ICUCR19	__reg16(M32700UT_LCD_BASE + 0x300036)
+#define M32700UT_LCD_ICUCR21	__reg16(M32700UT_LCD_BASE + 0x30003a)
+
+#endif	/* _M32700UT_M32700UT_LCD_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/m32700ut/m32700ut_pld.h linux-2.6.7/include/asm-m32r/m32700ut/m32700ut_pld.h
--- linux-2.6.7.org/include/asm-m32r/m32700ut/m32700ut_pld.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/m32700ut/m32700ut_pld.h	2003-12-15 15:50:38.000000000 +0900
@@ -0,0 +1,265 @@
+/*
+ * include/asm/m32700ut/m32700ut_pld.h
+ *
+ * Definitions for Programable Logic Device(PLD) on M32700UT board. 
+ *
+ * Copyright (c) 2002	Takeo Takahashi
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License.  See the file "COPYING" in the main directory of 
+ * this archive for more details.
+ *
+ * $Id$
+ */
+
+#ifndef _M32700UT_M32700UT_PLD_H
+#define _M32700UT_M32700UT_PLD_H
+
+#include <linux/config.h>
+
+#if defined(CONFIG_PLAT_M32700UT_Alpha)
+#define PLD_PLAT_BASE		0x08c00000
+#elif defined(CONFIG_PLAT_M32700UT) || defined(CONFIG_PLAT_USRV)
+#define PLD_PLAT_BASE		0x04c00000
+#else
+#error "no platform configuration"
+#endif
+
+#ifndef __ASSEMBLY__
+/*
+ * C functions use non-cache address.
+ */
+#define PLD_BASE		(PLD_PLAT_BASE /* + NONCACHE_OFFSET */)
+#define __reg8			(volatile unsigned char *)
+#define __reg16			(volatile unsigned short *)
+#define __reg32			(volatile unsigned int *)
+#else
+#define PLD_BASE		(PLD_PLAT_BASE + NONCACHE_OFFSET)
+#define __reg8
+#define __reg16
+#define __reg32
+#endif	/* __ASSEMBLY__ */
+
+/* CFC */
+#define	PLD_CFRSTCR		__reg16(PLD_BASE + 0x0000)
+#define PLD_CFSTS		__reg16(PLD_BASE + 0x0002)
+#define PLD_CFIMASK		__reg16(PLD_BASE + 0x0004)
+#define PLD_CFBUFCR		__reg16(PLD_BASE + 0x0006)
+#define PLD_CFVENCR		__reg16(PLD_BASE + 0x0008)
+#define PLD_CFCR0		__reg16(PLD_BASE + 0x000a)
+#define PLD_CFCR1		__reg16(PLD_BASE + 0x000c)
+#define PLD_IDERSTCR		__reg16(PLD_BASE + 0x0010)
+
+/* MMC */
+#define PLD_MMCCR		__reg16(PLD_BASE + 0x4000)
+#define PLD_MMCMOD		__reg16(PLD_BASE + 0x4002)
+#define PLD_MMCSTS		__reg16(PLD_BASE + 0x4006)
+#define PLD_MMCBAUR		__reg16(PLD_BASE + 0x400a)
+#define PLD_MMCCMDBCUT		__reg16(PLD_BASE + 0x400c)
+#define PLD_MMCCDTBCUT		__reg16(PLD_BASE + 0x400e)
+#define PLD_MMCDET		__reg16(PLD_BASE + 0x4010)
+#define PLD_MMCWP		__reg16(PLD_BASE + 0x4012)
+#define PLD_MMCWDATA		__reg16(PLD_BASE + 0x5000)
+#define PLD_MMCRDATA		__reg16(PLD_BASE + 0x6000)
+#define PLD_MMCCMDDATA		__reg16(PLD_BASE + 0x7000)
+#define PLD_MMCRSPDATA		__reg16(PLD_BASE + 0x7006)
+
+/* ICU
+ *  ICUISTS:	status register
+ *  ICUIREQ0: 	request register
+ *  ICUIREQ1: 	request register
+ *  ICUCR3:	control register for CFIREQ# interrupt
+ *  ICUCR4:	control register for CFC Card insert interrupt
+ *  ICUCR5:	control register for CFC Card eject interrupt
+ *  ICUCR6:	control register for external interrupt
+ *  ICUCR11:	control register for MMC Card insert/eject interrupt
+ *  ICUCR13:	control register for SC error interrupt
+ *  ICUCR14:	control register for SC receive interrupt
+ *  ICUCR15:	control register for SC send interrupt
+ *  ICUCR16:	control register for SIO0 receive interrupt
+ *  ICUCR17:	control register for SIO0 send interrupt
+ */
+#if !defined(CONFIG_PLAT_USRV)
+#define PLD_IRQ_INT0		(M32700UT_PLD_IRQ_BASE + 0)	/* None */
+#define PLD_IRQ_INT1		(M32700UT_PLD_IRQ_BASE + 1)	/* reserved */
+#define PLD_IRQ_INT2		(M32700UT_PLD_IRQ_BASE + 2)	/* reserved */
+#define PLD_IRQ_CFIREQ		(M32700UT_PLD_IRQ_BASE + 3)	/* CF IREQ */
+#define PLD_IRQ_CFC_INSERT	(M32700UT_PLD_IRQ_BASE + 4)	/* CF Insert */
+#define PLD_IRQ_CFC_EJECT	(M32700UT_PLD_IRQ_BASE + 5)	/* CF Eject */
+#define PLD_IRQ_EXINT		(M32700UT_PLD_IRQ_BASE + 6)	/* EXINT */
+#define PLD_IRQ_INT7		(M32700UT_PLD_IRQ_BASE + 7)	/* reserved */
+#define PLD_IRQ_INT8		(M32700UT_PLD_IRQ_BASE + 8)	/* reserved */
+#define PLD_IRQ_INT9		(M32700UT_PLD_IRQ_BASE + 9)	/* reserved */
+#define PLD_IRQ_INT10		(M32700UT_PLD_IRQ_BASE + 10)	/* reserved */
+#define PLD_IRQ_MMCCARD		(M32700UT_PLD_IRQ_BASE + 11)	/* MMC Insert/Eject */
+#define PLD_IRQ_INT12		(M32700UT_PLD_IRQ_BASE + 12)	/* reserved */
+#define PLD_IRQ_SC_ERROR	(M32700UT_PLD_IRQ_BASE + 13)	/* SC error */
+#define PLD_IRQ_SC_RCV		(M32700UT_PLD_IRQ_BASE + 14)	/* SC receive */
+#define PLD_IRQ_SC_SND		(M32700UT_PLD_IRQ_BASE + 15)	/* SC send */
+#define PLD_IRQ_SIO0_RCV	(M32700UT_PLD_IRQ_BASE + 16)	/* SIO receive */
+#define PLD_IRQ_SIO0_SND	(M32700UT_PLD_IRQ_BASE + 17)	/* SIO send */
+#define PLD_IRQ_INT18		(M32700UT_PLD_IRQ_BASE + 18)	/* reserved */
+#define PLD_IRQ_INT19		(M32700UT_PLD_IRQ_BASE + 19)	/* reserved */
+#define PLD_IRQ_INT20		(M32700UT_PLD_IRQ_BASE + 20)	/* reserved */
+#define PLD_IRQ_INT21		(M32700UT_PLD_IRQ_BASE + 21)	/* reserved */
+#define PLD_IRQ_INT22		(M32700UT_PLD_IRQ_BASE + 22)	/* reserved */
+#define PLD_IRQ_INT23		(M32700UT_PLD_IRQ_BASE + 23)	/* reserved */
+#define PLD_IRQ_INT24		(M32700UT_PLD_IRQ_BASE + 24)	/* reserved */
+#define PLD_IRQ_INT25		(M32700UT_PLD_IRQ_BASE + 25)	/* reserved */
+#define PLD_IRQ_INT26		(M32700UT_PLD_IRQ_BASE + 26)	/* reserved */
+#define PLD_IRQ_INT27		(M32700UT_PLD_IRQ_BASE + 27)	/* reserved */
+#define PLD_IRQ_INT28		(M32700UT_PLD_IRQ_BASE + 28)	/* reserved */
+#define PLD_IRQ_INT29		(M32700UT_PLD_IRQ_BASE + 29)	/* reserved */
+#define PLD_IRQ_INT30		(M32700UT_PLD_IRQ_BASE + 30)	/* reserved */
+#define PLD_IRQ_INT31		(M32700UT_PLD_IRQ_BASE + 31)	/* reserved */
+
+#else	/* CONFIG_PLAT_USRV */
+
+#define PLD_IRQ_INT0		(M32700UT_PLD_IRQ_BASE + 0)	/* None */
+#define PLD_IRQ_INT1		(M32700UT_PLD_IRQ_BASE + 1)	/* reserved */
+#define PLD_IRQ_INT2		(M32700UT_PLD_IRQ_BASE + 2)	/* reserved */
+#define PLD_IRQ_CF0		(M32700UT_PLD_IRQ_BASE + 3)	/* CF0# */
+#define PLD_IRQ_CF1		(M32700UT_PLD_IRQ_BASE + 4)	/* CF1# */
+#define PLD_IRQ_CF2		(M32700UT_PLD_IRQ_BASE + 5)	/* CF2# */
+#define PLD_IRQ_CF3		(M32700UT_PLD_IRQ_BASE + 6)	/* CF3# */
+#define PLD_IRQ_CF4		(M32700UT_PLD_IRQ_BASE + 7)	/* CF4# */
+#define PLD_IRQ_INT8		(M32700UT_PLD_IRQ_BASE + 8)	/* reserved */
+#define PLD_IRQ_INT9		(M32700UT_PLD_IRQ_BASE + 9)	/* reserved */
+#define PLD_IRQ_INT10		(M32700UT_PLD_IRQ_BASE + 10)	/* reserved */
+#define PLD_IRQ_INT11		(M32700UT_PLD_IRQ_BASE + 11)	/* reserved */
+#define PLD_IRQ_UART0		(M32700UT_PLD_IRQ_BASE + 12)	/* UARTIRQ0 */
+#define PLD_IRQ_UART1		(M32700UT_PLD_IRQ_BASE + 13)	/* UARTIRQ1 */
+#define PLD_IRQ_INT14		(M32700UT_PLD_IRQ_BASE + 14)	/* reserved */
+#define PLD_IRQ_INT15		(M32700UT_PLD_IRQ_BASE + 15)	/* reserved */
+#define PLD_IRQ_SNDINT		(M32700UT_PLD_IRQ_BASE + 16)	/* SNDINT# */
+#define PLD_IRQ_INT17		(M32700UT_PLD_IRQ_BASE + 17)	/* reserved */
+#define PLD_IRQ_INT18		(M32700UT_PLD_IRQ_BASE + 18)	/* reserved */
+#define PLD_IRQ_INT19		(M32700UT_PLD_IRQ_BASE + 19)	/* reserved */
+#define PLD_IRQ_INT20		(M32700UT_PLD_IRQ_BASE + 20)	/* reserved */
+#define PLD_IRQ_INT21		(M32700UT_PLD_IRQ_BASE + 21)	/* reserved */
+#define PLD_IRQ_INT22		(M32700UT_PLD_IRQ_BASE + 22)	/* reserved */
+#define PLD_IRQ_INT23		(M32700UT_PLD_IRQ_BASE + 23)	/* reserved */
+#define PLD_IRQ_INT24		(M32700UT_PLD_IRQ_BASE + 24)	/* reserved */
+#define PLD_IRQ_INT25		(M32700UT_PLD_IRQ_BASE + 25)	/* reserved */
+#define PLD_IRQ_INT26		(M32700UT_PLD_IRQ_BASE + 26)	/* reserved */
+#define PLD_IRQ_INT27		(M32700UT_PLD_IRQ_BASE + 27)	/* reserved */
+#define PLD_IRQ_INT28		(M32700UT_PLD_IRQ_BASE + 28)	/* reserved */
+#define PLD_IRQ_INT29		(M32700UT_PLD_IRQ_BASE + 29)	/* reserved */
+#define PLD_IRQ_INT30		(M32700UT_PLD_IRQ_BASE + 30)	/* reserved */
+
+#endif	/* CONFIG_PLAT_USRV */
+
+#define PLD_ICUISTS		__reg16(PLD_BASE + 0x8002)
+#define PLD_ICUISTS_VECB_MASK	(0xf000)
+#define PLD_ICUISTS_VECB(x)	((x) & PLD_ICUISTS_VECB_MASK)
+#define PLD_ICUISTS_ISN_MASK	(0x07c0)
+#define PLD_ICUISTS_ISN(x)	((x) & PLD_ICUISTS_ISN_MASK)
+#define PLD_ICUIREQ0		__reg16(PLD_BASE + 0x8004)
+#define PLD_ICUIREQ1		__reg16(PLD_BASE + 0x8006)
+#define PLD_ICUCR1		__reg16(PLD_BASE + 0x8100)
+#define PLD_ICUCR2		__reg16(PLD_BASE + 0x8102)
+#define PLD_ICUCR3		__reg16(PLD_BASE + 0x8104)
+#define PLD_ICUCR4		__reg16(PLD_BASE + 0x8106)
+#define PLD_ICUCR5		__reg16(PLD_BASE + 0x8108)
+#define PLD_ICUCR6		__reg16(PLD_BASE + 0x810a)
+#define PLD_ICUCR7		__reg16(PLD_BASE + 0x810c)
+#define PLD_ICUCR8		__reg16(PLD_BASE + 0x810e)
+#define PLD_ICUCR9		__reg16(PLD_BASE + 0x8110)
+#define PLD_ICUCR10		__reg16(PLD_BASE + 0x8112)
+#define PLD_ICUCR11		__reg16(PLD_BASE + 0x8114)
+#define PLD_ICUCR12		__reg16(PLD_BASE + 0x8116)
+#define PLD_ICUCR13		__reg16(PLD_BASE + 0x8118)
+#define PLD_ICUCR14		__reg16(PLD_BASE + 0x811a)
+#define PLD_ICUCR15		__reg16(PLD_BASE + 0x811c)
+#define PLD_ICUCR16		__reg16(PLD_BASE + 0x811e)
+#define PLD_ICUCR17		__reg16(PLD_BASE + 0x8120)
+#define PLD_ICUCR_IEN		(0x1000)
+#define PLD_ICUCR_IREQ		(0x0100)
+#define PLD_ICUCR_ISMOD00	(0x0000)	/* Low edge */
+#define PLD_ICUCR_ISMOD01	(0x0010)	/* Low level */
+#define PLD_ICUCR_ISMOD02	(0x0020)	/* High edge */
+#define PLD_ICUCR_ISMOD03	(0x0030)	/* High level */
+#define PLD_ICUCR_ILEVEL0	(0x0000)
+#define PLD_ICUCR_ILEVEL1	(0x0001)
+#define PLD_ICUCR_ILEVEL2	(0x0002)
+#define PLD_ICUCR_ILEVEL3	(0x0003)
+#define PLD_ICUCR_ILEVEL4	(0x0004)
+#define PLD_ICUCR_ILEVEL5	(0x0005)
+#define PLD_ICUCR_ILEVEL6	(0x0006)
+#define PLD_ICUCR_ILEVEL7	(0x0007)
+
+/* Power Control of MMC and CF */
+#define PLD_CPCR		__reg16(PLD_BASE + 0x14000)
+#define PLD_CPCR_CF		0x0001
+#define PLD_CPCR_MMC		0x0002
+
+/* LED Control
+ *
+ * 1: DIP swich side
+ * 2: Reset switch side
+ */
+#define PLD_IOLEDCR		__reg16(PLD_BASE + 0x14002)
+#define PLD_IOLED_1_ON		0x001
+#define PLD_IOLED_1_OFF		0x000
+#define PLD_IOLED_2_ON		0x002
+#define PLD_IOLED_2_OFF		0x000
+
+/* DIP Switch
+ *  0: Write-protect of Flash Memory (0:protected, 1:non-protected)
+ *  1: -
+ *  2: -
+ *  3: -
+ */
+#define PLD_IOSWSTS		__reg16(PLD_BASE + 0x14004)
+#define	PLD_IOSWSTS_IOSW2	0x0200
+#define	PLD_IOSWSTS_IOSW1	0x0100
+#define	PLD_IOSWSTS_IOWP0	0x0001
+
+/* CRC */
+#define PLD_CRC7DATA		__reg16(PLD_BASE + 0x18000)
+#define PLD_CRC7INDATA		__reg16(PLD_BASE + 0x18002)
+#define PLD_CRC16DATA		__reg16(PLD_BASE + 0x18004)
+#define PLD_CRC16INDATA		__reg16(PLD_BASE + 0x18006)
+#define PLD_CRC16ADATA		__reg16(PLD_BASE + 0x18008)
+#define PLD_CRC16AINDATA	__reg16(PLD_BASE + 0x1800a)
+
+/* RTC */
+#define PLD_RTCCR		__reg16(PLD_BASE + 0x1c000)
+#define PLD_RTCBAUR		__reg16(PLD_BASE + 0x1c002)
+#define PLD_RTCWRDATA		__reg16(PLD_BASE + 0x1c004)
+#define PLD_RTCRDDATA		__reg16(PLD_BASE + 0x1c006)
+#define PLD_RTCRSTODT		__reg16(PLD_BASE + 0x1c008)
+
+/* SIO0 */
+#define PLD_ESIO0CR		__reg16(PLD_BASE + 0x20000)
+#define	PLD_ESIO0CR_TXEN	0x0001
+#define	PLD_ESIO0CR_RXEN	0x0002
+#define PLD_ESIO0MOD0		__reg16(PLD_BASE + 0x20002)
+#define	PLD_ESIO0MOD0_CTSS	0x0040
+#define	PLD_ESIO0MOD0_RTSS	0x0080
+#define PLD_ESIO0MOD1		__reg16(PLD_BASE + 0x20004)
+#define	PLD_ESIO0MOD1_LMFS	0x0010
+#define PLD_ESIO0STS		__reg16(PLD_BASE + 0x20006)
+#define	PLD_ESIO0STS_TEMP	0x0001
+#define	PLD_ESIO0STS_TXCP	0x0002
+#define	PLD_ESIO0STS_RXCP	0x0004
+#define	PLD_ESIO0STS_TXSC	0x0100
+#define	PLD_ESIO0STS_RXSC	0x0200
+#define PLD_ESIO0STS_TXREADY	(PLD_ESIO0STS_TXCP | PLD_ESIO0STS_TEMP)
+#define PLD_ESIO0INTCR		__reg16(PLD_BASE + 0x20008)
+#define	PLD_ESIO0INTCR_TXIEN	0x0002
+#define	PLD_ESIO0INTCR_RXCEN	0x0004
+#define PLD_ESIO0BAUR		__reg16(PLD_BASE + 0x2000a)
+#define PLD_ESIO0TXB		__reg16(PLD_BASE + 0x2000c)
+#define PLD_ESIO0RXB		__reg16(PLD_BASE + 0x2000e)
+
+/* SIM Card */
+#define PLD_SCCR		__reg16(PLD_BASE + 0x38000)
+#define PLD_SCMOD		__reg16(PLD_BASE + 0x38004)
+#define PLD_SCSTS		__reg16(PLD_BASE + 0x38006)
+#define PLD_SCINTCR		__reg16(PLD_BASE + 0x38008)
+#define PLD_SCBAUR		__reg16(PLD_BASE + 0x3800a)
+#define PLD_SCTXB		__reg16(PLD_BASE + 0x3800c)
+#define PLD_SCRXB		__reg16(PLD_BASE + 0x3800e)
+
+#endif	/* _M32700UT_M32700UT_PLD.H */
diff -ruN linux-2.6.7.org/include/asm-m32r/m32r.h linux-2.6.7/include/asm-m32r/m32r.h
--- linux-2.6.7.org/include/asm-m32r/m32r.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/m32r.h	2004-07-27 15:54:20.000000000 +0900
@@ -0,0 +1,135 @@
+#ifndef _ASM_M32R_M32R_H_
+#define _ASM_M32R_M32R_H_
+
+/* 
+ * Mitsubishi M32R processor
+ * Copyright (C) 1997-2002, Mitsubishi Electric Corporation
+ */
+
+/* $Id$ */
+
+#include <linux/config.h>
+
+/* Chip type */
+#if defined(CONFIG_CHIP_XNUX_MP) || defined(CONFIG_CHIP_XNUX2_MP)
+#include <asm/m32r_mp_fpga.h>
+#elif defined(CONFIG_CHIP_VDEC2) || defined(CONFIG_CHIP_XNUX2) \
+	|| defined(CONFIG_CHIP_M32700) || defined(CONFIG_CHIP_M32102) \
+        || defined(CONFIG_CHIP_OPSP)
+#include <asm/m32102.h>
+#include <asm/m32102peri.h>
+#endif
+
+/* Platform type */
+#if defined(CONFIG_PLAT_M32700UT)
+#include <asm/m32700ut/m32700ut_pld.h>
+#include <asm/m32700ut/m32700ut_lan.h>
+#include <asm/m32700ut/m32700ut_lcd.h>
+#endif  /* CONFIG_PLAT_M32700UT */
+
+#if defined(CONFIG_PLAT_OPSPUT)
+#include <asm/opsput/opsput_pld.h>
+#include <asm/opsput/opsput_lan.h>
+#include <asm/opsput/opsput_lcd.h>
+#endif  /* CONFIG_PLAT_OPSPUT */
+
+#if defined(CONFIG_PLAT_MAPPI2)
+#include <asm/mappi2/mappi2_pld.h>
+#endif	/* CONFIG_PLAT_MAPPI2 */
+
+#if defined(CONFIG_PLAT_USRV)
+#include <asm/m32700ut/m32700ut_pld.h>
+#endif
+
+/* 
+ * M32R Register
+ */
+
+/* 
+ * MMU Register 
+ */
+
+#define MMU_REG_BASE	(0xffff0000)
+#define ITLB_BASE	(0xfe000000)
+#define DTLB_BASE	(0xfe000800)
+
+#define NR_TLB_ENTRIES	CONFIG_TLB_ENTRIES
+
+#define MATM	MMU_REG_BASE		/* MMU Address Translation Mode 
+					   Register */
+#define MPSZ	(0x04 + MMU_REG_BASE)	/* MMU Page Size Designation Register */
+#define MASID	(0x08 + MMU_REG_BASE)	/* MMU Address Space ID Register */
+#define MESTS	(0x0c + MMU_REG_BASE)	/* MMU Exception Status Register */
+#define MDEVA	(0x10 + MMU_REG_BASE)	/* MMU Operand Exception Virtual 
+					   Address Register */
+#define MDEVP	(0x14 + MMU_REG_BASE)	/* MMU Operand Exception Virtual Page 
+					   Number Register */
+#define MPTB	(0x18 + MMU_REG_BASE)	/* MMU Page Table Base Register */
+#define MSVA	(0x20 + MMU_REG_BASE)	/* MMU Search Virtual Address 
+					   Register */
+#define MTOP	(0x24 + MMU_REG_BASE)	/* MMU TLB Operation Register */
+#define MIDXI	(0x28 + MMU_REG_BASE)	/* MMU Index Register for 
+					   Instruciton */
+#define MIDXD	(0x2c + MMU_REG_BASE)	/* MMU Index Register for Operand */
+
+#define MATM_offset	(MATM - MMU_REG_BASE)
+#define MPSZ_offset	(MPSZ - MMU_REG_BASE)
+#define MASID_offset	(MASID - MMU_REG_BASE)
+#define MESTS_offset	(MESTS - MMU_REG_BASE)
+#define MDEVA_offset	(MDEVA - MMU_REG_BASE)
+#define MDEVP_offset	(MDEVP - MMU_REG_BASE)
+#define MPTB_offset	(MPTB - MMU_REG_BASE)
+#define MSVA_offset	(MSVA - MMU_REG_BASE)
+#define MTOP_offset	(MTOP - MMU_REG_BASE)
+#define MIDXI_offset	(MIDXI - MMU_REG_BASE)
+#define MIDXD_offset	(MIDXD - MMU_REG_BASE)
+
+#define MESTS_IT	(1 << 0)	/* Instruction TLB miss */
+#define MESTS_IA	(1 << 1)	/* Instruction Access Exception */
+#define MESTS_DT	(1 << 4)	/* Operand TLB miss */
+#define MESTS_DA	(1 << 5)	/* Operand Access Exception */
+#define MESTS_DRW	(1 << 6)	/* Operand Write Exception Flag */
+
+/*
+ * PSW (Processor Status Word)
+ */
+
+/* PSW bit */
+#define M32R_PSW_BIT_SM   (7)    /* Stack Mode */
+#define M32R_PSW_BIT_IE   (6)    /* Interrupt Enable */
+#define M32R_PSW_BIT_PM   (3)    /* Processor Mode [0:Supervisor,1:User] */
+#define M32R_PSW_BIT_C    (0)    /* Condition */
+#define M32R_PSW_BIT_BSM  (7+8)  /* Backup Stack Mode */
+#define M32R_PSW_BIT_BIE  (6+8)  /* Backup Interrupt Enable */
+#define M32R_PSW_BIT_BPM  (3+8)  /* Backup Processor Mode */
+#define M32R_PSW_BIT_BC   (0+8)  /* Backup Condition */
+
+/* PSW bit map */
+#define M32R_PSW_SM   (1UL<< M32R_PSW_BIT_SM)   /* Stack Mode */
+#define M32R_PSW_IE   (1UL<< M32R_PSW_BIT_IE)   /* Interrupt Enable */
+#define M32R_PSW_PM   (1UL<< M32R_PSW_BIT_PM)   /* Processor Mode */
+#define M32R_PSW_C    (1UL<< M32R_PSW_BIT_C)    /* Condition */
+#define M32R_PSW_BSM  (1UL<< M32R_PSW_BIT_BSM)  /* Backup Stack Mode */
+#define M32R_PSW_BIE  (1UL<< M32R_PSW_BIT_BIE)  /* Backup Interrupt Enable */
+#define M32R_PSW_BPM  (1UL<< M32R_PSW_BIT_BPM)  /* Backup Processor Mode */
+#define M32R_PSW_BC   (1UL<< M32R_PSW_BIT_BC)   /* Backup Condition */
+
+/* 
+ * Direct address to SFR
+ */
+
+#include <asm/page.h>
+#ifdef CONFIG_MMU
+#define NONCACHE_OFFSET  __PAGE_OFFSET+0x20000000
+#else
+#define NONCACHE_OFFSET  __PAGE_OFFSET
+#endif /* CONFIG_MMU */
+
+#define M32R_ICU_ISTS_ADDR  M32R_ICU_ISTS_PORTL+NONCACHE_OFFSET
+#define M32R_ICU_IPICR_ADDR  M32R_ICU_IPICR0_PORTL+NONCACHE_OFFSET
+#define M32R_ICU_IMASK_ADDR  M32R_ICU_IMASK_PORTL+NONCACHE_OFFSET
+#define M32R_FPGA_CPU_NAME_ADDR  M32R_FPGA_CPU_NAME0_PORTL+NONCACHE_OFFSET
+#define M32R_FPGA_MODEL_ID_ADDR  M32R_FPGA_MODEL_ID0_PORTL+NONCACHE_OFFSET
+#define M32R_FPGA_VERSION_ADDR   M32R_FPGA_VERSION0_PORTL+NONCACHE_OFFSET
+
+#endif /* _ASM_M32R_M32R_H_ */
diff -ruN linux-2.6.7.org/include/asm-m32r/m32r_mp_fpga.h linux-2.6.7/include/asm-m32r/m32r_mp_fpga.h
--- linux-2.6.7.org/include/asm-m32r/m32r_mp_fpga.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/m32r_mp_fpga.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,313 @@
+#ifndef _ASM_M32R_M32R_MP_FPGA_
+#define _ASM_M32R_M32R_MP_FPGA_
+
+/* 
+ * Mitsubishi M32R-MP-FPGA
+ * Copyright (c) 2002 [Hitoshi Yamamoto] All rights reserved.
+ */
+
+/* $Id$ */
+
+/* 
+ * ========================================================
+ * M32R-MP-FPGA Memory Map
+ * ========================================================
+ * 0x00000000 : Block#0 : 64[MB]
+ *              0x03E00000 : SFR
+ *                           0x03E00000 : reserved
+ *                           0x03EF0000 : FPGA
+ *                           0x03EF1000 : reserved
+ *                           0x03EF4000 : CKM
+ *                           0x03EF4000 : BSELC
+ *                           0x03EF5000 : reserved
+ *                           0x03EFC000 : MFT
+ *                           0x03EFD000 : SIO
+ *                           0x03EFE000 : reserved
+ *                           0x03EFF000 : ICU
+ *              0x03F00000 : Internal SRAM 64[KB]
+ *              0x03F10000 : reserved
+ * --------------------------------------------------------
+ * 0x04000000 : Block#1 : 64[MB]
+ *              0x04000000 : Debug board SRAM 4[MB]
+ *              0x04400000 : reserved
+ * --------------------------------------------------------
+ * 0x08000000 : Block#2 : 64[MB]
+ * --------------------------------------------------------
+ * 0x0C000000 : Block#3 : 64[MB]
+ * --------------------------------------------------------
+ * 0x10000000 : Block#4 : 64[MB]
+ * --------------------------------------------------------
+ * 0x14000000 : Block#5 : 64[MB]
+ * --------------------------------------------------------
+ * 0x18000000 : Block#6 : 64[MB]
+ * --------------------------------------------------------
+ * 0x1C000000 : Block#7 : 64[MB]
+ * --------------------------------------------------------
+ * 0xFE000000 : TLB
+ *              0xFE000000 : ITLB
+ *              0xFE000080 : reserved
+ *              0xFE000800 : DTLB
+ *              0xFE000880 : reserved
+ * --------------------------------------------------------
+ * 0xFF000000 : System area
+ *              0xFFFF0000 : MMU
+ *              0xFFFF0030 : reserved
+ *              0xFFFF8000 : Debug function
+ *              0xFFFFA000 : reserved
+ *              0xFFFFC000 : CPU control
+ * 0xFFFFFFFF
+ * ========================================================
+ */
+
+/*======================================================================*
+ * Special Function Register
+ *======================================================================*/
+#define M32R_SFR_OFFSET  (0x00E00000)  /* 0x03E00000-0x03EFFFFF 1[MB] */
+
+/* 
+ * FPGA registers.
+ */
+#define M32R_FPGA_TOP  (0x000F0000+M32R_SFR_OFFSET)
+
+#define M32R_FPGA_NUM_OF_CPUS_PORTL  (0x00+M32R_FPGA_TOP)
+#define M32R_FPGA_CPU_NAME0_PORTL    (0x10+M32R_FPGA_TOP)
+#define M32R_FPGA_CPU_NAME1_PORTL    (0x14+M32R_FPGA_TOP)
+#define M32R_FPGA_CPU_NAME2_PORTL    (0x18+M32R_FPGA_TOP)
+#define M32R_FPGA_CPU_NAME3_PORTL    (0x1C+M32R_FPGA_TOP)
+#define M32R_FPGA_MODEL_ID0_PORTL    (0x20+M32R_FPGA_TOP)
+#define M32R_FPGA_MODEL_ID1_PORTL    (0x24+M32R_FPGA_TOP)
+#define M32R_FPGA_MODEL_ID2_PORTL    (0x28+M32R_FPGA_TOP)
+#define M32R_FPGA_MODEL_ID3_PORTL    (0x2C+M32R_FPGA_TOP)
+#define M32R_FPGA_VERSION0_PORTL     (0x30+M32R_FPGA_TOP)
+#define M32R_FPGA_VERSION1_PORTL     (0x34+M32R_FPGA_TOP)
+
+/* 
+ * Clock and Power Manager registers.
+ */
+#define M32R_CPM_OFFSET  (0x000F4000+M32R_SFR_OFFSET)
+
+#define M32R_CPM_CPUCLKCR_PORTL  (0x00+M32R_CPM_OFFSET)
+#define M32R_CPM_CLKMOD_PORTL    (0x04+M32R_CPM_OFFSET)
+#define M32R_CPM_PLLCR_PORTL     (0x08+M32R_CPM_OFFSET)
+
+/* 
+ * Block SELect Controller registers.
+ */
+#define M32R_BSELC_OFFSET  (0x000F5000+M32R_SFR_OFFSET)
+
+#define M32R_BSEL0_CR0_PORTL  (0x000+M32R_BSELC_OFFSET)
+#define M32R_BSEL0_CR1_PORTL  (0x004+M32R_BSELC_OFFSET)
+#define M32R_BSEL1_CR0_PORTL  (0x100+M32R_BSELC_OFFSET)
+#define M32R_BSEL1_CR1_PORTL  (0x104+M32R_BSELC_OFFSET)
+#define M32R_BSEL2_CR0_PORTL  (0x200+M32R_BSELC_OFFSET)
+#define M32R_BSEL2_CR1_PORTL  (0x204+M32R_BSELC_OFFSET)
+#define M32R_BSEL3_CR0_PORTL  (0x300+M32R_BSELC_OFFSET)
+#define M32R_BSEL3_CR1_PORTL  (0x304+M32R_BSELC_OFFSET)
+#define M32R_BSEL4_CR0_PORTL  (0x400+M32R_BSELC_OFFSET)
+#define M32R_BSEL4_CR1_PORTL  (0x404+M32R_BSELC_OFFSET)
+#define M32R_BSEL5_CR0_PORTL  (0x500+M32R_BSELC_OFFSET)
+#define M32R_BSEL5_CR1_PORTL  (0x504+M32R_BSELC_OFFSET)
+#define M32R_BSEL6_CR0_PORTL  (0x600+M32R_BSELC_OFFSET)
+#define M32R_BSEL6_CR1_PORTL  (0x604+M32R_BSELC_OFFSET)
+#define M32R_BSEL7_CR0_PORTL  (0x700+M32R_BSELC_OFFSET)
+#define M32R_BSEL7_CR1_PORTL  (0x704+M32R_BSELC_OFFSET)
+
+/* 
+ * Multi Function Timer registers.
+ */
+#define M32R_MFT_OFFSET        (0x000FC000+M32R_SFR_OFFSET)
+
+#define M32R_MFTCR_PORTL       (0x000+M32R_MFT_OFFSET)  /* MFT control */
+#define M32R_MFTRPR_PORTL      (0x004+M32R_MFT_OFFSET)  /* MFT real port */
+
+#define M32R_MFT0_OFFSET       (0x100+M32R_MFT_OFFSET)
+#define M32R_MFT0MOD_PORTL     (0x00+M32R_MFT0_OFFSET)  /* MFT0 mode */
+#define M32R_MFT0BOS_PORTL     (0x04+M32R_MFT0_OFFSET)  /* MFT0 b-port output status */
+#define M32R_MFT0CUT_PORTL     (0x08+M32R_MFT0_OFFSET)  /* MFT0 count */
+#define M32R_MFT0RLD_PORTL     (0x0C+M32R_MFT0_OFFSET)  /* MFT0 reload */
+#define M32R_MFT0CMPRLD_PORTL  (0x10+M32R_MFT0_OFFSET)  /* MFT0 compare reload */
+
+#define M32R_MFT1_OFFSET       (0x200+M32R_MFT_OFFSET)
+#define M32R_MFT1MOD_PORTL     (0x00+M32R_MFT1_OFFSET)  /* MFT1 mode */
+#define M32R_MFT1BOS_PORTL     (0x04+M32R_MFT1_OFFSET)  /* MFT1 b-port output status */
+#define M32R_MFT1CUT_PORTL     (0x08+M32R_MFT1_OFFSET)  /* MFT1 count */
+#define M32R_MFT1RLD_PORTL     (0x0C+M32R_MFT1_OFFSET)  /* MFT1 reload */
+#define M32R_MFT1CMPRLD_PORTL  (0x10+M32R_MFT1_OFFSET)  /* MFT1 compare reload */
+
+#define M32R_MFT2_OFFSET       (0x300+M32R_MFT_OFFSET)
+#define M32R_MFT2MOD_PORTL     (0x00+M32R_MFT2_OFFSET)  /* MFT2 mode */
+#define M32R_MFT2BOS_PORTL     (0x04+M32R_MFT2_OFFSET)  /* MFT2 b-port output status */
+#define M32R_MFT2CUT_PORTL     (0x08+M32R_MFT2_OFFSET)  /* MFT2 count */
+#define M32R_MFT2RLD_PORTL     (0x0C+M32R_MFT2_OFFSET)  /* MFT2 reload */
+#define M32R_MFT2CMPRLD_PORTL  (0x10+M32R_MFT2_OFFSET)  /* MFT2 compare reload */
+
+#define M32R_MFT3_OFFSET       (0x400+M32R_MFT_OFFSET)
+#define M32R_MFT3MOD_PORTL     (0x00+M32R_MFT3_OFFSET)  /* MFT3 mode */
+#define M32R_MFT3BOS_PORTL     (0x04+M32R_MFT3_OFFSET)  /* MFT3 b-port output status */
+#define M32R_MFT3CUT_PORTL     (0x08+M32R_MFT3_OFFSET)  /* MFT3 count */
+#define M32R_MFT3RLD_PORTL     (0x0C+M32R_MFT3_OFFSET)  /* MFT3 reload */
+#define M32R_MFT3CMPRLD_PORTL  (0x10+M32R_MFT3_OFFSET)  /* MFT3 compare reload */
+
+#define M32R_MFT4_OFFSET       (0x500+M32R_MFT_OFFSET)
+#define M32R_MFT4MOD_PORTL     (0x00+M32R_MFT4_OFFSET)  /* MFT4 mode */
+#define M32R_MFT4BOS_PORTL     (0x04+M32R_MFT4_OFFSET)  /* MFT4 b-port output status */
+#define M32R_MFT4CUT_PORTL     (0x08+M32R_MFT4_OFFSET)  /* MFT4 count */
+#define M32R_MFT4RLD_PORTL     (0x0C+M32R_MFT4_OFFSET)  /* MFT4 reload */
+#define M32R_MFT4CMPRLD_PORTL  (0x10+M32R_MFT4_OFFSET)  /* MFT4 compare reload */
+
+#define M32R_MFT5_OFFSET       (0x600+M32R_MFT_OFFSET)
+#define M32R_MFT5MOD_PORTL     (0x00+M32R_MFT5_OFFSET)  /* MFT4 mode */
+#define M32R_MFT5BOS_PORTL     (0x04+M32R_MFT5_OFFSET)  /* MFT4 b-port output status */
+#define M32R_MFT5CUT_PORTL     (0x08+M32R_MFT5_OFFSET)  /* MFT4 count */
+#define M32R_MFT5RLD_PORTL     (0x0C+M32R_MFT5_OFFSET)  /* MFT4 reload */
+#define M32R_MFT5CMPRLD_PORTL  (0x10+M32R_MFT5_OFFSET)  /* MFT4 compare reload */
+
+#define M32R_MFTCR_MFT0MSK  (1UL<<15)  /* b16 */
+#define M32R_MFTCR_MFT1MSK  (1UL<<14)  /* b17 */
+#define M32R_MFTCR_MFT2MSK  (1UL<<13)  /* b18 */
+#define M32R_MFTCR_MFT3MSK  (1UL<<12)  /* b19 */
+#define M32R_MFTCR_MFT4MSK  (1UL<<11)  /* b20 */
+#define M32R_MFTCR_MFT5MSK  (1UL<<10)  /* b21 */
+#define M32R_MFTCR_MFT0EN   (1UL<<7)   /* b24 */
+#define M32R_MFTCR_MFT1EN   (1UL<<6)   /* b25 */
+#define M32R_MFTCR_MFT2EN   (1UL<<5)   /* b26 */
+#define M32R_MFTCR_MFT3EN   (1UL<<4)   /* b27 */
+#define M32R_MFTCR_MFT4EN   (1UL<<3)   /* b28 */
+#define M32R_MFTCR_MFT5EN   (1UL<<2)   /* b29 */
+
+#define M32R_MFTMOD_CC_MASK    (1UL<<15)  /* b16 */
+#define M32R_MFTMOD_TCCR       (1UL<<13)  /* b18 */
+#define M32R_MFTMOD_GTSEL000   (0UL<<8)   /* b21-23 : 000 */
+#define M32R_MFTMOD_GTSEL001   (1UL<<8)   /* b21-23 : 001 */
+#define M32R_MFTMOD_GTSEL010   (2UL<<8)   /* b21-23 : 010 */
+#define M32R_MFTMOD_GTSEL011   (3UL<<8)   /* b21-23 : 011 */
+#define M32R_MFTMOD_GTSEL110   (6UL<<8)   /* b21-23 : 110 */
+#define M32R_MFTMOD_GTSEL111   (7UL<<8)   /* b21-23 : 111 */
+#define M32R_MFTMOD_CMSEL      (1UL<<3)   /* b28 */
+#define M32R_MFTMOD_CSSEL000   (0UL<<0)   /* b29-b31 : 000 */
+#define M32R_MFTMOD_CSSEL001   (1UL<<0)   /* b29-b31 : 001 */
+#define M32R_MFTMOD_CSSEL010   (2UL<<0)   /* b29-b31 : 010 */
+#define M32R_MFTMOD_CSSEL011   (3UL<<0)   /* b29-b31 : 011 */
+#define M32R_MFTMOD_CSSEL100   (4UL<<0)   /* b29-b31 : 100 */
+#define M32R_MFTMOD_CSSEL110   (6UL<<0)   /* b29-b31 : 110 */
+
+/* 
+ * Serial I/O registers.
+ */
+#define M32R_SIO_OFFSET  (0x000FD000+M32R_SFR_OFFSET)
+
+#define M32R_SIO0_CR_PORTL     (0x000+M32R_SIO_OFFSET)
+#define M32R_SIO0_MOD0_PORTL   (0x004+M32R_SIO_OFFSET)
+#define M32R_SIO0_MOD1_PORTL   (0x008+M32R_SIO_OFFSET)
+#define M32R_SIO0_STS_PORTL    (0x00C+M32R_SIO_OFFSET)
+#define M32R_SIO0_TRCR_PORTL   (0x010+M32R_SIO_OFFSET)
+#define M32R_SIO0_BAUR_PORTL   (0x014+M32R_SIO_OFFSET)
+#define M32R_SIO0_RBAUR_PORTL  (0x018+M32R_SIO_OFFSET)
+#define M32R_SIO0_TXB_PORTL    (0x01C+M32R_SIO_OFFSET)
+#define M32R_SIO0_RXB_PORTL    (0x020+M32R_SIO_OFFSET)
+
+/* 
+ * Interrupt Control Unit registers.
+ */
+#define M32R_ICU_OFFSET  (0x000FF000+M32R_SFR_OFFSET)
+
+#define M32R_ICU_ISTS_PORTL     (0x004+M32R_ICU_OFFSET)
+#define M32R_ICU_IREQ0_PORTL    (0x008+M32R_ICU_OFFSET)
+#define M32R_ICU_IREQ1_PORTL    (0x00C+M32R_ICU_OFFSET)
+#define M32R_ICU_SBICR_PORTL    (0x018+M32R_ICU_OFFSET)
+#define M32R_ICU_IMASK_PORTL    (0x01C+M32R_ICU_OFFSET)
+#define M32R_ICU_CR1_PORTL      (0x200+M32R_ICU_OFFSET)  /* INT0 */
+#define M32R_ICU_CR2_PORTL      (0x204+M32R_ICU_OFFSET)  /* INT1 */
+#define M32R_ICU_CR3_PORTL      (0x208+M32R_ICU_OFFSET)  /* INT2 */
+#define M32R_ICU_CR4_PORTL      (0x20C+M32R_ICU_OFFSET)  /* INT3 */
+#define M32R_ICU_CR5_PORTL      (0x210+M32R_ICU_OFFSET)  /* INT4 */
+#define M32R_ICU_CR6_PORTL      (0x214+M32R_ICU_OFFSET)  /* INT5 */
+#define M32R_ICU_CR7_PORTL      (0x218+M32R_ICU_OFFSET)  /* INT6 */
+#define M32R_ICU_CR8_PORTL      (0x218+M32R_ICU_OFFSET)  /* INT7 */
+#define M32R_ICU_CR32_PORTL     (0x27C+M32R_ICU_OFFSET)  /* SIO0 RX */
+#define M32R_ICU_CR33_PORTL     (0x280+M32R_ICU_OFFSET)  /* SIO0 TX */
+#define M32R_ICU_CR40_PORTL     (0x29C+M32R_ICU_OFFSET)  /* DMAC0 */
+#define M32R_ICU_CR41_PORTL     (0x2A0+M32R_ICU_OFFSET)  /* DMAC1 */
+#define M32R_ICU_CR48_PORTL     (0x2BC+M32R_ICU_OFFSET)  /* MFT0 */
+#define M32R_ICU_CR49_PORTL     (0x2C0+M32R_ICU_OFFSET)  /* MFT1 */
+#define M32R_ICU_CR50_PORTL     (0x2C4+M32R_ICU_OFFSET)  /* MFT2 */
+#define M32R_ICU_CR51_PORTL     (0x2C8+M32R_ICU_OFFSET)  /* MFT3 */
+#define M32R_ICU_CR52_PORTL     (0x2CC+M32R_ICU_OFFSET)  /* MFT4 */
+#define M32R_ICU_CR53_PORTL     (0x2D0+M32R_ICU_OFFSET)  /* MFT5 */
+#define M32R_ICU_IPICR0_PORTL   (0x2DC+M32R_ICU_OFFSET)  /* IPI0 */
+#define M32R_ICU_IPICR1_PORTL   (0x2E0+M32R_ICU_OFFSET)  /* IPI1 */
+#define M32R_ICU_IPICR2_PORTL   (0x2E4+M32R_ICU_OFFSET)  /* IPI2 */
+#define M32R_ICU_IPICR3_PORTL   (0x2E8+M32R_ICU_OFFSET)  /* IPI3 */
+#define M32R_ICU_IPICR4_PORTL   (0x2EC+M32R_ICU_OFFSET)  /* IPI4 */
+#define M32R_ICU_IPICR5_PORTL   (0x2F0+M32R_ICU_OFFSET)  /* IPI5 */
+#define M32R_ICU_IPICR6_PORTL   (0x2F4+M32R_ICU_OFFSET)  /* IPI6 */
+#define M32R_ICU_IPICR7_PORTL   (0x2FC+M32R_ICU_OFFSET)  /* IPI7 */
+
+#define M32R_ICUISTS_VECB(val)  ((val>>28) & 0xF)
+#define M32R_ICUISTS_ISN(val)   ((val>>22) & 0x3F)
+#define M32R_ICUISTS_PIML(val)  ((val>>16) & 0x7)
+
+#define M32R_ICUIMASK_IMSK0  (0UL<<16)  /* b13-b15: Disable interrupt */
+#define M32R_ICUIMASK_IMSK1  (1UL<<16)  /* b13-b15: Enable level 0 interrupt */
+#define M32R_ICUIMASK_IMSK2  (2UL<<16)  /* b13-b15: Enable level 0,1 interrupt */
+#define M32R_ICUIMASK_IMSK3  (3UL<<16)  /* b13-b15: Enable level 0-2 interrupt */
+#define M32R_ICUIMASK_IMSK4  (4UL<<16)  /* b13-b15: Enable level 0-3 interrupt */
+#define M32R_ICUIMASK_IMSK5  (5UL<<16)  /* b13-b15: Enable level 0-4 interrupt */
+#define M32R_ICUIMASK_IMSK6  (6UL<<16)  /* b13-b15: Enable level 0-5 interrupt */
+#define M32R_ICUIMASK_IMSK7  (7UL<<16)  /* b13-b15: Enable level 0-6 interrupt */
+
+#define M32R_ICUCR_IEN      (1UL<<12)  /* b19: Interrupt enable */
+#define M32R_ICUCR_IRQ      (1UL<<8)   /* b23: Interrupt request */
+#define M32R_ICUCR_ISMOD00  (0UL<<4)   /* b26-b27: Interrupt sense mode Edge HtoL */
+#define M32R_ICUCR_ISMOD01  (1UL<<4)   /* b26-b27: Interrupt sense mode Level L */
+#define M32R_ICUCR_ISMOD10  (2UL<<4)   /* b26-b27: Interrupt sense mode Edge LtoH*/
+#define M32R_ICUCR_ISMOD11  (3UL<<4)   /* b26-b27: Interrupt sense mode Level H */
+#define M32R_ICUCR_ILEVEL0  (0UL<<0)   /* b29-b31: Interrupt priority level 0 */
+#define M32R_ICUCR_ILEVEL1  (1UL<<0)   /* b29-b31: Interrupt priority level 1 */
+#define M32R_ICUCR_ILEVEL2  (2UL<<0)   /* b29-b31: Interrupt priority level 2 */
+#define M32R_ICUCR_ILEVEL3  (3UL<<0)   /* b29-b31: Interrupt priority level 3 */
+#define M32R_ICUCR_ILEVEL4  (4UL<<0)   /* b29-b31: Interrupt priority level 4 */
+#define M32R_ICUCR_ILEVEL5  (5UL<<0)   /* b29-b31: Interrupt priority level 5 */
+#define M32R_ICUCR_ILEVEL6  (6UL<<0)   /* b29-b31: Interrupt priority level 6 */
+#define M32R_ICUCR_ILEVEL7  (7UL<<0)   /* b29-b31: Disable interrupt */
+#define M32R_ICUCR_ILEVEL_MASK  (7UL)
+
+#define M32R_IRQ_INT0    (1)   /* INT0 */
+#define M32R_IRQ_INT1    (2)   /* INT1 */
+#define M32R_IRQ_INT2    (3)   /* INT2 */
+#define M32R_IRQ_INT3    (4)   /* INT3 */
+#define M32R_IRQ_INT4    (5)   /* INT4 */
+#define M32R_IRQ_INT5    (6)   /* INT5 */
+#define M32R_IRQ_INT6    (7)   /* INT6 */
+#define M32R_IRQ_INT7    (8)   /* INT7 */
+#define M32R_IRQ_MFT0    (16)  /* MFT0 */
+#define M32R_IRQ_MFT1    (17)  /* MFT1 */
+#define M32R_IRQ_MFT2    (18)  /* MFT2 */
+#define M32R_IRQ_MFT3    (19)  /* MFT3 */
+#define M32R_IRQ_MFT4    (20)  /* MFT4 */
+#define M32R_IRQ_MFT5    (21)  /* MFT5 */
+#define M32R_IRQ_DMAC0   (32)  /* DMAC0 */
+#define M32R_IRQ_DMAC1   (33)  /* DMAC1 */
+#define M32R_IRQ_SIO0_R  (48)  /* SIO0 receive */
+#define M32R_IRQ_SIO0_S  (49)  /* SIO0 send    */
+#define M32R_IRQ_SIO1_R  (50)  /* SIO1 send    */
+#define M32R_IRQ_SIO1_S  (51)  /* SIO1 receive */
+#define M32R_IRQ_IPI0    (56)  /* IPI0 */
+#define M32R_IRQ_IPI1    (57)  /* IPI1 */
+#define M32R_IRQ_IPI2    (58)  /* IPI2 */
+#define M32R_IRQ_IPI3    (59)  /* IPI3 */
+#define M32R_IRQ_IPI4    (60)  /* IPI4 */
+#define M32R_IRQ_IPI5    (61)  /* IPI5 */
+#define M32R_IRQ_IPI6    (62)  /* IPI6 */
+#define M32R_IRQ_IPI7    (63)  /* IPI7 */
+
+/*======================================================================*
+ * CPU
+ *======================================================================*/
+
+#define M32R_CPUID_PORTL   (0xFFFFFFE0)
+#define M32R_MCICAR_PORTL  (0xFFFFFFF0)
+#define M32R_MCDCAR_PORTL  (0xFFFFFFF4)
+#define M32R_MCCR_PORTL    (0xFFFFFFFC)
+
+#endif  /* _ASM_M32R_M32R_MP_FPGA_ */
diff -ruN linux-2.6.7.org/include/asm-m32r/mappi2/mappi2_pld.h linux-2.6.7/include/asm-m32r/mappi2/mappi2_pld.h
--- linux-2.6.7.org/include/asm-m32r/mappi2/mappi2_pld.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/mappi2/mappi2_pld.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,151 @@
+/*
+ * include/asm/mappi2/mappi2_pld.h
+ *
+ * Definitions for Extended IO Logic on MAPPI2 board. 
+ *  based on m32700ut_pld.h by 
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License.  See the file "COPYING" in the main directory of 
+ * this archive for more details.
+ *
+ */
+
+#ifndef _MAPPI2_PLD_H
+#define _MAPPI2_PLD_H
+
+#ifndef __ASSEMBLY__
+/* FIXME:
+ * Some C functions use non-cache address, so can't define non-cache address.
+ */
+#define PLD_BASE		(0x10c00000 /* + NONCACHE_OFFSET */)
+#define __reg8			(volatile unsigned char *)
+#define __reg16			(volatile unsigned short *)
+#define __reg32			(volatile unsigned int *)
+#else
+#define PLD_BASE		(0x10c00000 + NONCACHE_OFFSET)
+#define __reg8
+#define __reg16
+#define __reg32
+#endif	/* __ASSEMBLY__ */
+
+/* CFC */
+#define	PLD_CFRSTCR		__reg16(PLD_BASE + 0x0000)
+#define PLD_CFSTS		__reg16(PLD_BASE + 0x0002)
+#define PLD_CFIMASK		__reg16(PLD_BASE + 0x0004)
+#define PLD_CFBUFCR		__reg16(PLD_BASE + 0x0006)
+#define PLD_CFCR0		__reg16(PLD_BASE + 0x000a)
+#define PLD_CFCR1		__reg16(PLD_BASE + 0x000c)
+
+/* MMC */
+#define PLD_MMCCR		__reg16(PLD_BASE + 0x4000)
+#define PLD_MMCMOD		__reg16(PLD_BASE + 0x4002)
+#define PLD_MMCSTS		__reg16(PLD_BASE + 0x4006)
+#define PLD_MMCBAUR		__reg16(PLD_BASE + 0x400a)
+#define PLD_MMCCMDBCUT		__reg16(PLD_BASE + 0x400c)
+#define PLD_MMCCDTBCUT		__reg16(PLD_BASE + 0x400e)
+#define PLD_MMCDET		__reg16(PLD_BASE + 0x4010)
+#define PLD_MMCWP		__reg16(PLD_BASE + 0x4012)
+#define PLD_MMCWDATA		__reg16(PLD_BASE + 0x5000)
+#define PLD_MMCRDATA		__reg16(PLD_BASE + 0x6000)
+#define PLD_MMCCMDDATA		__reg16(PLD_BASE + 0x7000)
+#define PLD_MMCRSPDATA		__reg16(PLD_BASE + 0x7006)
+
+/* Power Control of MMC and CF */
+#define PLD_CPCR		__reg16(PLD_BASE + 0x14000)
+
+
+/*==== ICU ====*/
+#define  M32R_IRQ_PC104        (5)   /* INT4(PC/104) */
+#define  M32R_IRQ_I2C          (28)  /* I2C-BUS     */
+#if 1
+#define  PLD_IRQ_CFIREQ       (40)  /* CFC Card Interrupt */
+#define  PLD_IRQ_CFC_INSERT   (41)  /* CFC Card Insert */
+#define  PLD_IRQ_CFC_EJECT    (42)  /* CFC Card Eject */
+#define  PLD_IRQ_MMCCARD      (43)  /* MMC Card Insert */
+#define  PLD_IRQ_MMCIRQ       (44)  /* MMC Transfer Done */
+#else
+#define  PLD_IRQ_CFIREQ       (34)  /* CFC Card Interrupt */
+#define  PLD_IRQ_CFC_INSERT   (35)  /* CFC Card Insert */
+#define  PLD_IRQ_CFC_EJECT    (36)  /* CFC Card Eject */
+#define  PLD_IRQ_MMCCARD      (37)  /* MMC Card Insert */
+#define  PLD_IRQ_MMCIRQ       (38)  /* MMC Transfer Done */
+#endif
+
+
+#if 0
+/* LED Control
+ *
+ * 1: DIP swich side
+ * 2: Reset switch side
+ */
+#define PLD_IOLEDCR		__reg16(PLD_BASE + 0x14002)
+#define PLD_IOLED_1_ON		0x001
+#define PLD_IOLED_1_OFF		0x000
+#define PLD_IOLED_2_ON		0x002
+#define PLD_IOLED_2_OFF		0x000
+
+/* DIP Switch
+ *  0: Write-protect of Flash Memory (0:protected, 1:non-protected)
+ *  1: -
+ *  2: -
+ *  3: -
+ */
+#define PLD_IOSWSTS		__reg16(PLD_BASE + 0x14004)
+#define	PLD_IOSWSTS_IOSW2	0x0200
+#define	PLD_IOSWSTS_IOSW1	0x0100
+#define	PLD_IOSWSTS_IOWP0	0x0001
+
+#endif
+
+/* CRC */
+#define PLD_CRC7DATA		__reg16(PLD_BASE + 0x18000)
+#define PLD_CRC7INDATA		__reg16(PLD_BASE + 0x18002)
+#define PLD_CRC16DATA		__reg16(PLD_BASE + 0x18004)
+#define PLD_CRC16INDATA		__reg16(PLD_BASE + 0x18006)
+#define PLD_CRC16ADATA		__reg16(PLD_BASE + 0x18008)
+#define PLD_CRC16AINDATA	__reg16(PLD_BASE + 0x1800a)
+
+
+#if 0
+/* RTC */
+#define PLD_RTCCR		__reg16(PLD_BASE + 0x1c000)
+#define PLD_RTCBAUR		__reg16(PLD_BASE + 0x1c002)
+#define PLD_RTCWRDATA		__reg16(PLD_BASE + 0x1c004)
+#define PLD_RTCRDDATA		__reg16(PLD_BASE + 0x1c006)
+#define PLD_RTCRSTODT		__reg16(PLD_BASE + 0x1c008)
+
+/* SIO0 */
+#define PLD_ESIO0CR		__reg16(PLD_BASE + 0x20000)
+#define	PLD_ESIO0CR_TXEN	0x0001
+#define	PLD_ESIO0CR_RXEN	0x0002
+#define PLD_ESIO0MOD0		__reg16(PLD_BASE + 0x20002)
+#define	PLD_ESIO0MOD0_CTSS	0x0040
+#define	PLD_ESIO0MOD0_RTSS	0x0080
+#define PLD_ESIO0MOD1		__reg16(PLD_BASE + 0x20004)
+#define	PLD_ESIO0MOD1_LMFS	0x0010
+#define PLD_ESIO0STS		__reg16(PLD_BASE + 0x20006)
+#define	PLD_ESIO0STS_TEMP	0x0001
+#define	PLD_ESIO0STS_TXCP	0x0002
+#define	PLD_ESIO0STS_RXCP	0x0004
+#define	PLD_ESIO0STS_TXSC	0x0100
+#define	PLD_ESIO0STS_RXSC	0x0200
+#define PLD_ESIO0STS_TXREADY	(PLD_ESIO0STS_TXCP | PLD_ESIO0STS_TEMP)
+#define PLD_ESIO0INTCR		__reg16(PLD_BASE + 0x20008)
+#define	PLD_ESIO0INTCR_TXIEN	0x0002
+#define	PLD_ESIO0INTCR_RXCEN	0x0004
+#define PLD_ESIO0BAUR		__reg16(PLD_BASE + 0x2000a)
+#define PLD_ESIO0TXB		__reg16(PLD_BASE + 0x2000c)
+#define PLD_ESIO0RXB		__reg16(PLD_BASE + 0x2000e)
+
+/* SIM Card */
+#define PLD_SCCR		__reg16(PLD_BASE + 0x38000)
+#define PLD_SCMOD		__reg16(PLD_BASE + 0x38004)
+#define PLD_SCSTS		__reg16(PLD_BASE + 0x38006)
+#define PLD_SCINTCR		__reg16(PLD_BASE + 0x38008)
+#define PLD_SCBAUR		__reg16(PLD_BASE + 0x3800a)
+#define PLD_SCTXB		__reg16(PLD_BASE + 0x3800c)
+#define PLD_SCRXB		__reg16(PLD_BASE + 0x3800e)
+
+#endif
+
+#endif	/* _MAPPI2_PLD.H */
diff -ruN linux-2.6.7.org/include/asm-m32r/mc146818rtc.h linux-2.6.7/include/asm-m32r/mc146818rtc.h
--- linux-2.6.7.org/include/asm-m32r/mc146818rtc.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/mc146818rtc.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,32 @@
+/*
+ * Machine dependent access functions for RTC registers.
+ */
+#ifndef _ASM_MC146818RTC_H
+#define _ASM_MC146818RTC_H
+
+#include <asm/io.h>
+
+#ifndef RTC_PORT
+// #define RTC_PORT(x)	(0x70 + (x))
+#define RTC_PORT(x)	((x))
+#define RTC_ALWAYS_BCD	1	/* RTC operates in binary mode */
+#endif
+
+/*
+ * The yet supported machines all access the RTC index register via
+ * an ISA port access but the way to access the date register differs ...
+ */
+#define CMOS_READ(addr) ({ \
+outb_p((addr),RTC_PORT(0)); \
+inb_p(RTC_PORT(1)); \
+})
+#define CMOS_WRITE(val, addr) ({ \
+outb_p((addr),RTC_PORT(0)); \
+outb_p((val),RTC_PORT(1)); \
+})
+
+#define RTC_IRQ 8
+#if 0
+#endif
+
+#endif /* _ASM_MC146818RTC_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/mman.h linux-2.6.7/include/asm-m32r/mman.h
--- linux-2.6.7.org/include/asm-m32r/mman.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/mman.h	2003-10-09 14:01:34.000000000 +0900
@@ -0,0 +1,45 @@
+#ifndef __M32R_MMAN_H__
+#define __M32R_MMAN_H__
+
+/* orig : i386 2.6.0-test6 */
+
+#define PROT_READ	0x1		/* page can be read */
+#define PROT_WRITE	0x2		/* page can be written */
+#define PROT_EXEC	0x4		/* page can be executed */
+#define PROT_SEM	0x8		/* page may be used for atomic ops */
+#define PROT_NONE	0x0		/* page can not be accessed */
+#define PROT_GROWSDOWN	0x01000000	/* mprotect flag: extend change to start of growsdown vma */
+#define PROT_GROWSUP	0x02000000	/* mprotect flag: extend change to end of growsup vma */
+
+#define MAP_SHARED	0x01		/* Share changes */
+#define MAP_PRIVATE	0x02		/* Changes are private */
+#define MAP_TYPE	0x0f		/* Mask for type of mapping */
+#define MAP_FIXED	0x10		/* Interpret addr exactly */
+#define MAP_ANONYMOUS	0x20		/* don't use a file */
+
+#define MAP_GROWSDOWN	0x0100		/* stack-like segment */
+#define MAP_DENYWRITE	0x0800		/* ETXTBSY */
+#define MAP_EXECUTABLE	0x1000		/* mark it as an executable */
+#define MAP_LOCKED	0x2000		/* pages are locked */
+#define MAP_NORESERVE	0x4000		/* don't check for reservations */
+#define MAP_POPULATE	0x8000		/* populate (prefault) pagetables */
+#define MAP_NONBLOCK	0x10000		/* do not block on IO */
+
+#define MS_ASYNC	1		/* sync memory asynchronously */
+#define MS_INVALIDATE	2		/* invalidate the caches */
+#define MS_SYNC		4		/* synchronous memory sync */
+
+#define MCL_CURRENT	1		/* lock all current mappings */
+#define MCL_FUTURE	2		/* lock all future mappings */
+
+#define MADV_NORMAL	0x0		/* default page-in behavior */
+#define MADV_RANDOM	0x1		/* page-in minimum required */
+#define MADV_SEQUENTIAL	0x2		/* read-ahead aggressively */
+#define MADV_WILLNEED	0x3		/* pre-fault pages */
+#define MADV_DONTNEED	0x4		/* discard these pages */
+
+/* compatibility flags */
+#define MAP_ANON	MAP_ANONYMOUS
+#define MAP_FILE	0
+
+#endif /* __M32R_MMAN_H__ */
diff -ruN linux-2.6.7.org/include/asm-m32r/mmu.h linux-2.6.7/include/asm-m32r/mmu.h
--- linux-2.6.7.org/include/asm-m32r/mmu.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/mmu.h	2004-03-30 15:40:59.000000000 +0900
@@ -0,0 +1,35 @@
+#ifndef _ASM_M32R_MMU_H
+#define _ASM_M32R_MMU_H
+
+/* $Id$ */
+
+#include <linux/config.h>
+
+#if !defined(CONFIG_MMU)
+struct mm_rblock_struct {
+  int     size;
+  int     refcount;
+  void    *kblock;
+};
+
+struct mm_tblock_struct {
+  struct mm_rblock_struct *rblock;
+  struct mm_tblock_struct *next;
+};
+
+typedef struct {
+  struct mm_tblock_struct tblock;
+  unsigned long           end_brk;
+} mm_context_t;
+#else
+
+/* Default "unsigned long" context */
+#ifndef CONFIG_SMP
+typedef unsigned long mm_context_t;
+#else
+typedef unsigned long mm_context_t[NR_CPUS];
+#endif 
+
+#endif  /* CONFIG_MMU */
+#endif  /* _ASM_M32R_MMU_H */
+
diff -ruN linux-2.6.7.org/include/asm-m32r/mmu_context.h linux-2.6.7/include/asm-m32r/mmu_context.h
--- linux-2.6.7.org/include/asm-m32r/mmu_context.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/mmu_context.h	2004-03-31 19:37:43.000000000 +0900
@@ -0,0 +1,169 @@
+#ifndef _ASM_M32R_MMU_CONTEXT_H
+#define _ASM_M32R_MMU_CONTEXT_H
+
+/* $Id */
+
+#include <linux/config.h>
+
+#include <asm/m32r.h>
+
+#define MMU_CONTEXT_ASID_MASK      (0x000000FF)
+#define MMU_CONTEXT_VERSION_MASK   (0xFFFFFF00)
+#define MMU_CONTEXT_FIRST_VERSION  (0x00000100)
+#define NO_CONTEXT                 (0x00000000)
+
+
+#ifndef __ASSEMBLY__
+
+#include <linux/config.h>
+#include <asm/atomic.h>
+#include <asm/pgalloc.h>
+#include <asm/mmu.h>
+#include <asm/tlbflush.h>
+
+/*
+ * Cache of MMU context last used.
+ */
+#ifndef CONFIG_SMP
+extern unsigned long mmu_context_cache_dat;
+#define mmu_context_cache	mmu_context_cache_dat
+#define mm_context(mm)		mm->context
+#else /* not CONFIG_SMP */
+extern unsigned long mmu_context_cache_dat[];
+#define mmu_context_cache	mmu_context_cache_dat[smp_processor_id()]
+#define mm_context(mm)		mm->context[smp_processor_id()]
+#endif /* not CONFIG_SMP */
+
+#define set_tlb_tag(entry, tag)	(*entry = (tag & PAGE_MASK)|get_asid())
+#define set_tlb_data(entry, data)	(*entry = (data | _PAGE_PRESENT))
+
+#ifdef CONFIG_MMU
+#define enter_lazy_tlb(mm, tsk)	do { } while (0)
+
+static __inline__ void get_new_mmu_context(struct mm_struct *mm)
+{
+	unsigned long mc = ++mmu_context_cache;
+	
+	if (!(mc & MMU_CONTEXT_ASID_MASK)) {
+		/* We exhaust ASID of this version.
+		   Flush all TLB and start new cycle. */
+		local_flush_tlb_all();
+		/* Fix version if needed.
+		   Note that we avoid version #0 to distingush NO_CONTEXT. */
+		if (!mc)
+			mmu_context_cache = mc = MMU_CONTEXT_FIRST_VERSION;
+	}
+	mm_context(mm) = mc;
+}
+
+/*
+ * Get MMU context if needed.
+ */
+static __inline__ void get_mmu_context(struct mm_struct *mm)
+{
+	if (mm) {
+		unsigned long mc = mmu_context_cache;
+
+		/* Check if we have old version of context.
+		   If it's old, we need to get new context with new version. */
+		if ((mm_context(mm) ^ mc) & MMU_CONTEXT_VERSION_MASK)
+			get_new_mmu_context(mm);
+	}
+}
+
+/*
+ * Initialize the context related info for a new mm_struct
+ * instance.
+ */
+static __inline__ int init_new_context(struct task_struct *tsk, 
+	struct mm_struct *mm)
+{
+#ifndef CONFIG_SMP
+	mm->context = NO_CONTEXT;
+#else /* CONFIG_SMP */
+	int num_cpus = num_online_cpus();
+	int i;
+
+	for (i = 0 ; i < num_cpus ; i++)
+		mm->context[i] = NO_CONTEXT;
+#endif /* CONFIG_SMP */
+
+	return 0;
+}
+
+/*
+ * Destroy context related info for an mm_struct that is about
+ * to be put to rest.
+ */
+#define destroy_context(mm)	do { } while (0)
+
+static __inline__ void set_asid(unsigned long asid)
+{
+	*(volatile unsigned long *)MASID = (asid & MMU_CONTEXT_ASID_MASK);
+}
+
+static __inline__ unsigned long get_asid(void)
+{
+	unsigned long asid;
+
+	asid = *(volatile long *)MASID;
+	asid &= MMU_CONTEXT_ASID_MASK;
+
+	return asid;
+}
+
+/*
+ * After we have set current->mm to a new value, this activates
+ * the context for the new mm so we see the new mappings.
+ */
+static __inline__ void activate_context(struct mm_struct *mm)
+{
+	get_mmu_context(mm);
+	set_asid(mm_context(mm) & MMU_CONTEXT_ASID_MASK);
+}
+
+static __inline__ void switch_mm(struct mm_struct *prev, 
+	struct mm_struct *next, struct task_struct *tsk)
+{
+#ifdef CONFIG_SMP
+	int cpu = smp_processor_id();
+#endif	/* CONFIG_SMP */
+
+	if (prev != next) {
+#ifdef CONFIG_SMP
+		cpu_set(cpu, next->cpu_vm_mask);
+#endif /* CONFIG_SMP */
+		/* Set MPTB = next->pgd */
+		*(volatile unsigned long *)MPTB = (unsigned long)next->pgd;
+		activate_context(next);
+	}
+#ifdef CONFIG_SMP
+	else
+		if (!cpu_test_and_set(cpu, next->cpu_vm_mask))
+			activate_context(next);
+#endif /* CONFIG_SMP */
+}
+
+#define deactivate_mm(tsk, mm)	do { } while (0)
+
+#define activate_mm(prev, next)	\
+	switch_mm((prev), (next), NULL)
+
+#else
+#define get_mmu_context(mm)             do { } while (0)
+#define init_new_context(tsk,mm)        (0)
+#define destroy_context(mm)             do { } while (0)
+#define set_asid(asid)                  do { } while (0)
+#define get_asid()                      (0)
+#define activate_context(mm)            do { } while (0)
+#define switch_mm(prev,next,tsk)        do { } while (0)
+#define deactivate_mm(mm,tsk)           do { } while (0)
+#define activate_mm(prev,next)          do { } while (0)
+#define enter_lazy_tlb(mm,tsk)          do { } while (0)
+#endif /* CONFIG_MMU */
+
+
+#endif /* not __ASSEMBLY__ */
+
+#endif /* _ASM_M32R_MMU_CONTEXT_H */
+
diff -ruN linux-2.6.7.org/include/asm-m32r/mmzone.h linux-2.6.7/include/asm-m32r/mmzone.h
--- linux-2.6.7.org/include/asm-m32r/mmzone.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/mmzone.h	2004-07-15 13:43:17.000000000 +0900
@@ -0,0 +1,80 @@
+/*
+ * Written by Pat Gaughen (gone@us.ibm.com) Mar 2002
+ *
+ */
+
+#ifndef _ASM_MMZONE_H_
+#define _ASM_MMZONE_H_
+
+#include <asm/smp.h>
+
+#ifdef CONFIG_DISCONTIGMEM
+
+extern struct pglist_data *node_data[];
+#define NODE_DATA(nid)		(node_data[nid])
+
+#define node_localnr(pfn, nid)	((pfn) - NODE_DATA(nid)->node_start_pfn)
+#define node_mem_map(nid)	(NODE_DATA(nid)->node_mem_map)
+#define node_start_pfn(nid)	(NODE_DATA(nid)->node_start_pfn)
+#define node_end_pfn(nid)						\
+({									\
+	pg_data_t *__pgdat = NODE_DATA(nid);				\
+	__pgdat->node_start_pfn + __pgdat->node_spanned_pages - 1;	\
+})
+
+#define local_mapnr(kvaddr)						\
+({									\
+	unsigned long __pfn = __pa(kvaddr) >> PAGE_SHIFT;		\
+	(__pfn - node_start_pfn(pfn_to_nid(__pfn)));			\
+})
+
+#define pfn_to_page(pfn)						\
+({									\
+	unsigned long __pfn = pfn;					\
+	int __node  = pfn_to_nid(__pfn);				\
+	&node_mem_map(__node)[node_localnr(__pfn,__node)];		\
+})
+
+#define page_to_pfn(pg)							\
+({									\
+	struct page *__page = pg;					\
+	struct zone *__zone = page_zone(__page);			\
+	(unsigned long)(__page - __zone->zone_mem_map)			\
+		+ __zone->zone_start_pfn;				\
+})
+#define pmd_page(pmd)		(pfn_to_page(pmd_val(pmd) >> PAGE_SHIFT))
+/*
+ * pfn_valid should be made as fast as possible, and the current definition 
+ * is valid for machines that are NUMA, but still contiguous, which is what
+ * is currently supported. A more generalised, but slower definition would
+ * be something like this - mbligh:
+ * ( pfn_to_pgdat(pfn) && ((pfn) < node_end_pfn(pfn_to_nid(pfn))) ) 
+ */ 
+#if 1	/* M32R_FIXME */
+#define pfn_valid(pfn)	(1)
+#else
+#define pfn_valid(pfn)	((pfn) < num_physpages)
+#endif
+
+/*
+ * generic node memory support, the following assumptions apply:
+ */
+
+static __inline__ int pfn_to_nid(unsigned long pfn)
+{
+	int node;
+
+	for (node = 0 ; node < MAX_NUMNODES ; node++)
+		if (pfn >= node_start_pfn(node) && pfn <= node_end_pfn(node))
+			break;
+
+	return node;
+}
+
+static __inline__ struct pglist_data *pfn_to_pgdat(unsigned long pfn)
+{
+	return(NODE_DATA(pfn_to_nid(pfn)));
+}
+
+#endif /* CONFIG_DISCONTIGMEM */
+#endif /* _ASM_MMZONE_H_ */
diff -ruN linux-2.6.7.org/include/asm-m32r/module.h linux-2.6.7/include/asm-m32r/module.h
--- linux-2.6.7.org/include/asm-m32r/module.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/module.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,13 @@
+#ifndef _ASM_M32R_MODULE_H
+#define _ASM_M32R_MODULE_H
+
+/* $Id$ */
+
+struct mod_arch_specific { };
+
+#define Elf_Shdr	Elf32_Shdr
+#define Elf_Sym		Elf32_Sym
+#define Elf_Ehdr	Elf32_Ehdr
+
+#endif /* _ASM_M32R_MODULE_H */
+
diff -ruN linux-2.6.7.org/include/asm-m32r/msgbuf.h linux-2.6.7/include/asm-m32r/msgbuf.h
--- linux-2.6.7.org/include/asm-m32r/msgbuf.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/msgbuf.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,35 @@
+#ifndef _ASM_M32R_MSGBUF_H
+#define _ASM_M32R_MSGBUF_H
+
+/* $Id$ */
+
+/* orig : i386 2.4.18 */
+
+/* 
+ * The msqid64_ds structure for m32r architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 64-bit time_t to solve y2038 problem
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct msqid64_ds {
+	struct ipc64_perm msg_perm;
+	__kernel_time_t msg_stime;	/* last msgsnd time */
+	unsigned long	__unused1;
+	__kernel_time_t msg_rtime;	/* last msgrcv time */
+	unsigned long	__unused2;
+	__kernel_time_t msg_ctime;	/* last change time */
+	unsigned long	__unused3;
+	unsigned long  msg_cbytes;	/* current number of bytes on queue */
+	unsigned long  msg_qnum;	/* number of messages in queue */
+	unsigned long  msg_qbytes;	/* max number of bytes on queue */
+	__kernel_pid_t msg_lspid;	/* pid of last msgsnd */
+	__kernel_pid_t msg_lrpid;	/* last receive pid */
+	unsigned long  __unused4;
+	unsigned long  __unused5;
+};
+
+#endif /* _ASM_M32R_MSGBUF_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/namei.h linux-2.6.7/include/asm-m32r/namei.h
--- linux-2.6.7.org/include/asm-m32r/namei.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/namei.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,21 @@
+#ifndef _ASM_M32R_NAMEI_H
+#define _ASM_M32R_NAMEI_H
+
+/* $Id$ */
+
+/* orig : i386 2.4.18 */
+
+/* 
+ * linux/include/asm-m32r/namei.h
+ *
+ * Included from linux/fs/namei.c
+ */
+
+/* This dummy routine maybe changed to something useful
+ * for /usr/gnemul/ emulation stuff.
+ * Look at asm-sparc/namei.h for details.
+ */
+
+#define __emul_prefix() NULL
+
+#endif /* _ASM_M32R_NAMEI_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/numnodes.h linux-2.6.7/include/asm-m32r/numnodes.h
--- linux-2.6.7.org/include/asm-m32r/numnodes.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/numnodes.h	2004-03-31 19:37:43.000000000 +0900
@@ -0,0 +1,15 @@
+#ifndef _ASM_NUMNODES_H_
+#define _ASM_NUMNODES_H_
+
+#include <linux/config.h>
+
+#ifdef CONFIG_DISCONTIGMEM
+
+#if defined(CONFIG_CHIP_M32700)
+#define	NODES_SHIFT	1	/* Max 2 Nodes */
+#endif	/* CONFIG_CHIP_M32700 */
+
+#endif	/* CONFIG_DISCONTIGMEM */
+
+#endif	/* _ASM_NUMNODES_H_ */
+
diff -ruN linux-2.6.7.org/include/asm-m32r/opsput/opsput_lan.h linux-2.6.7/include/asm-m32r/opsput/opsput_lan.h
--- linux-2.6.7.org/include/asm-m32r/opsput/opsput_lan.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/opsput/opsput_lan.h	2004-07-27 15:54:20.000000000 +0900
@@ -0,0 +1,56 @@
+/*
+ * include/asm/opsput_lan.h
+ *
+ * OPSPUT-LAN board
+ *
+ * Copyright (c) 2002-2004	Takeo Takahashi, Mamoru Sakugawa
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License.  See the file "COPYING" in the main directory of 
+ * this archive for more details.
+ *
+ * $Id: opsput_lan.h,v 1.1 2004/07/27 06:54:20 sakugawa Exp $
+ */
+
+#ifndef _OPSPUT_OPSPUT_LAN_H
+#define _OPSPUT_OPSPUT_LAN_H
+
+#include <linux/config.h>
+
+#ifndef __ASSEMBLY__
+/*
+ * C functions use non-cache address.
+ */
+#define OPSPUT_LAN_BASE	(0x10000000 /* + NONCACHE_OFFSET */)
+#else
+#define OPSPUT_LAN_BASE	(0x10000000 + NONCACHE_OFFSET)
+#endif	/* __ASSEMBLY__ */
+
+/* ICU
+ *  ICUISTS:	status register
+ *  ICUIREQ0: 	request register
+ *  ICUIREQ1: 	request register
+ *  ICUCR3:	control register for CFIREQ# interrupt
+ *  ICUCR4:	control register for CFC Card insert interrupt
+ *  ICUCR5:	control register for CFC Card eject interrupt
+ *  ICUCR6:	control register for external interrupt
+ *  ICUCR11:	control register for MMC Card insert/eject interrupt
+ *  ICUCR13:	control register for SC error interrupt
+ *  ICUCR14:	control register for SC receive interrupt
+ *  ICUCR15:	control register for SC send interrupt
+ *  ICUCR16:	control register for SIO0 receive interrupt
+ *  ICUCR17:	control register for SIO0 send interrupt
+ */
+#define OPSPUT_LAN_IRQ_LAN	(OPSPUT_LAN_PLD_IRQ_BASE + 1)	/* LAN */
+#define OPSPUT_LAN_IRQ_I2C	(OPSPUT_LAN_PLD_IRQ_BASE + 3)	/* I2C */
+
+#define OPSPUT_LAN_ICUISTS	__reg16(OPSPUT_LAN_BASE + 0xc0002)
+#define OPSPUT_LAN_ICUISTS_VECB_MASK	(0xf000)
+#define OPSPUT_LAN_VECB(x)	((x) & OPSPUT_LAN_ICUISTS_VECB_MASK)
+#define OPSPUT_LAN_ICUISTS_ISN_MASK	(0x07c0)
+#define OPSPUT_LAN_ICUISTS_ISN(x)	((x) & OPSPUT_LAN_ICUISTS_ISN_MASK)
+#define OPSPUT_LAN_ICUIREQ0	__reg16(OPSPUT_LAN_BASE + 0xc0004)
+#define OPSPUT_LAN_ICUCR1	__reg16(OPSPUT_LAN_BASE + 0xc0010)
+#define OPSPUT_LAN_ICUCR3	__reg16(OPSPUT_LAN_BASE + 0xc0014)
+
+#endif	/* _OPSPUT_OPSPUT_LAN_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/opsput/opsput_lcd.h linux-2.6.7/include/asm-m32r/opsput/opsput_lcd.h
--- linux-2.6.7.org/include/asm-m32r/opsput/opsput_lcd.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/opsput/opsput_lcd.h	2004-07-27 15:54:20.000000000 +0900
@@ -0,0 +1,59 @@
+/*
+ * include/asm/opsput_lcd.h
+ *
+ * OPSPUT-LCD board
+ *
+ * Copyright (c) 2002	Takeo Takahashi
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License.  See the file "COPYING" in the main directory of 
+ * this archive for more details.
+ *
+ * $Id: opsput_lcd.h,v 1.1 2004/07/27 06:54:20 sakugawa Exp $
+ */
+
+#ifndef _OPSPUT_OPSPUT_LCD_H
+#define _OPSPUT_OPSPUT_LCD_H
+
+#include <linux/config.h>
+
+#ifndef __ASSEMBLY__
+/*
+ * C functions use non-cache address.
+ */
+#define OPSPUT_LCD_BASE	(0x10000000 /* + NONCACHE_OFFSET */)
+#else
+#define OPSPUT_LCD_BASE	(0x10000000 + NONCACHE_OFFSET)
+#endif	/* __ASSEMBLY__ */
+
+/*
+ * ICU
+ */
+#define OPSPUT_LCD_IRQ_BAT_INT	(OPSPUT_LCD_PLD_IRQ_BASE + 1)
+#define OPSPUT_LCD_IRQ_USB_INT1	(OPSPUT_LCD_PLD_IRQ_BASE + 2)
+#define OPSPUT_LCD_IRQ_AUDT0		(OPSPUT_LCD_PLD_IRQ_BASE + 3)
+#define OPSPUT_LCD_IRQ_AUDT2		(OPSPUT_LCD_PLD_IRQ_BASE + 4)
+#define OPSPUT_LCD_IRQ_BATSIO_RCV	(OPSPUT_LCD_PLD_IRQ_BASE + 16)
+#define OPSPUT_LCD_IRQ_BATSIO_SND	(OPSPUT_LCD_PLD_IRQ_BASE + 17)
+#define OPSPUT_LCD_IRQ_ASNDSIO_RCV	(OPSPUT_LCD_PLD_IRQ_BASE + 18)
+#define OPSPUT_LCD_IRQ_ASNDSIO_SND	(OPSPUT_LCD_PLD_IRQ_BASE + 19)
+#define OPSPUT_LCD_IRQ_ACNLSIO_SND	(OPSPUT_LCD_PLD_IRQ_BASE + 21)
+
+#define OPSPUT_LCD_ICUISTS	__reg16(OPSPUT_LCD_BASE + 0x300002)
+#define OPSPUT_LCD_ICUISTS_VECB_MASK	(0xf000)
+#define OPSPUT_LCD_VECB(x)	((x) & OPSPUT_LCD_ICUISTS_VECB_MASK)
+#define OPSPUT_LCD_ICUISTS_ISN_MASK	(0x07c0)
+#define OPSPUT_LCD_ICUISTS_ISN(x)	((x) & OPSPUT_LCD_ICUISTS_ISN_MASK)
+#define OPSPUT_LCD_ICUIREQ0	__reg16(OPSPUT_LCD_BASE + 0x300004)
+#define OPSPUT_LCD_ICUIREQ1	__reg16(OPSPUT_LCD_BASE + 0x300006)
+#define OPSPUT_LCD_ICUCR1	__reg16(OPSPUT_LCD_BASE + 0x300020)
+#define OPSPUT_LCD_ICUCR2	__reg16(OPSPUT_LCD_BASE + 0x300022)
+#define OPSPUT_LCD_ICUCR3	__reg16(OPSPUT_LCD_BASE + 0x300024)
+#define OPSPUT_LCD_ICUCR4	__reg16(OPSPUT_LCD_BASE + 0x300026)
+#define OPSPUT_LCD_ICUCR16	__reg16(OPSPUT_LCD_BASE + 0x300030)
+#define OPSPUT_LCD_ICUCR17	__reg16(OPSPUT_LCD_BASE + 0x300032)
+#define OPSPUT_LCD_ICUCR18	__reg16(OPSPUT_LCD_BASE + 0x300034)
+#define OPSPUT_LCD_ICUCR19	__reg16(OPSPUT_LCD_BASE + 0x300036)
+#define OPSPUT_LCD_ICUCR21	__reg16(OPSPUT_LCD_BASE + 0x30003a)
+
+#endif	/* _OPSPUT_OPSPUT_LCD_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/opsput/opsput_pld.h linux-2.6.7/include/asm-m32r/opsput/opsput_pld.h
--- linux-2.6.7.org/include/asm-m32r/opsput/opsput_pld.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/opsput/opsput_pld.h	2004-07-27 15:54:20.000000000 +0900
@@ -0,0 +1,259 @@
+/*
+ * include/asm/opsput/opsput_pld.h
+ *
+ * Definitions for Programable Logic Device(PLD) on OPSPUT board. 
+ *
+ * Copyright (c) 2002	Takeo Takahashi
+ *
+ * This file is subject to the terms and conditions of the GNU General
+ * Public License.  See the file "COPYING" in the main directory of 
+ * this archive for more details.
+ *
+ * $Id: opsput_pld.h,v 1.1 2004/07/27 06:54:20 sakugawa Exp $
+ */
+
+#ifndef _OPSPUT_OPSPUT_PLD_H
+#define _OPSPUT_OPSPUT_PLD_H
+
+#include <linux/config.h>
+
+#define PLD_PLAT_BASE		0x1cc00000
+
+#ifndef __ASSEMBLY__
+/*
+ * C functions use non-cache address.
+ */
+#define PLD_BASE		(PLD_PLAT_BASE /* + NONCACHE_OFFSET */)
+#define __reg8			(volatile unsigned char *)
+#define __reg16			(volatile unsigned short *)
+#define __reg32			(volatile unsigned int *)
+#else
+#define PLD_BASE		(PLD_PLAT_BASE + NONCACHE_OFFSET)
+#define __reg8
+#define __reg16
+#define __reg32
+#endif	/* __ASSEMBLY__ */
+
+/* CFC */
+#define	PLD_CFRSTCR		__reg16(PLD_BASE + 0x0000)
+#define PLD_CFSTS		__reg16(PLD_BASE + 0x0002)
+#define PLD_CFIMASK		__reg16(PLD_BASE + 0x0004)
+#define PLD_CFBUFCR		__reg16(PLD_BASE + 0x0006)
+#define PLD_CFVENCR		__reg16(PLD_BASE + 0x0008)
+#define PLD_CFCR0		__reg16(PLD_BASE + 0x000a)
+#define PLD_CFCR1		__reg16(PLD_BASE + 0x000c)
+#define PLD_IDERSTCR		__reg16(PLD_BASE + 0x0010)
+
+/* MMC */
+#define PLD_MMCCR		__reg16(PLD_BASE + 0x4000)
+#define PLD_MMCMOD		__reg16(PLD_BASE + 0x4002)
+#define PLD_MMCSTS		__reg16(PLD_BASE + 0x4006)
+#define PLD_MMCBAUR		__reg16(PLD_BASE + 0x400a)
+#define PLD_MMCCMDBCUT		__reg16(PLD_BASE + 0x400c)
+#define PLD_MMCCDTBCUT		__reg16(PLD_BASE + 0x400e)
+#define PLD_MMCDET		__reg16(PLD_BASE + 0x4010)
+#define PLD_MMCWP		__reg16(PLD_BASE + 0x4012)
+#define PLD_MMCWDATA		__reg16(PLD_BASE + 0x5000)
+#define PLD_MMCRDATA		__reg16(PLD_BASE + 0x6000)
+#define PLD_MMCCMDDATA		__reg16(PLD_BASE + 0x7000)
+#define PLD_MMCRSPDATA		__reg16(PLD_BASE + 0x7006)
+
+/* ICU
+ *  ICUISTS:	status register
+ *  ICUIREQ0: 	request register
+ *  ICUIREQ1: 	request register
+ *  ICUCR3:	control register for CFIREQ# interrupt
+ *  ICUCR4:	control register for CFC Card insert interrupt
+ *  ICUCR5:	control register for CFC Card eject interrupt
+ *  ICUCR6:	control register for external interrupt
+ *  ICUCR11:	control register for MMC Card insert/eject interrupt
+ *  ICUCR13:	control register for SC error interrupt
+ *  ICUCR14:	control register for SC receive interrupt
+ *  ICUCR15:	control register for SC send interrupt
+ *  ICUCR16:	control register for SIO0 receive interrupt
+ *  ICUCR17:	control register for SIO0 send interrupt
+ */
+#if !defined(CONFIG_PLAT_USRV)
+#define PLD_IRQ_INT0		(OPSPUT_PLD_IRQ_BASE + 0)	/* None */
+#define PLD_IRQ_INT1		(OPSPUT_PLD_IRQ_BASE + 1)	/* reserved */
+#define PLD_IRQ_INT2		(OPSPUT_PLD_IRQ_BASE + 2)	/* reserved */
+#define PLD_IRQ_CFIREQ		(OPSPUT_PLD_IRQ_BASE + 3)	/* CF IREQ */
+#define PLD_IRQ_CFC_INSERT	(OPSPUT_PLD_IRQ_BASE + 4)	/* CF Insert */
+#define PLD_IRQ_CFC_EJECT	(OPSPUT_PLD_IRQ_BASE + 5)	/* CF Eject */
+#define PLD_IRQ_EXINT		(OPSPUT_PLD_IRQ_BASE + 6)	/* EXINT */
+#define PLD_IRQ_INT7		(OPSPUT_PLD_IRQ_BASE + 7)	/* reserved */
+#define PLD_IRQ_INT8		(OPSPUT_PLD_IRQ_BASE + 8)	/* reserved */
+#define PLD_IRQ_INT9		(OPSPUT_PLD_IRQ_BASE + 9)	/* reserved */
+#define PLD_IRQ_INT10		(OPSPUT_PLD_IRQ_BASE + 10)	/* reserved */
+#define PLD_IRQ_MMCCARD		(OPSPUT_PLD_IRQ_BASE + 11)	/* MMC Insert/Eject */
+#define PLD_IRQ_INT12		(OPSPUT_PLD_IRQ_BASE + 12)	/* reserved */
+#define PLD_IRQ_SC_ERROR	(OPSPUT_PLD_IRQ_BASE + 13)	/* SC error */
+#define PLD_IRQ_SC_RCV		(OPSPUT_PLD_IRQ_BASE + 14)	/* SC receive */
+#define PLD_IRQ_SC_SND		(OPSPUT_PLD_IRQ_BASE + 15)	/* SC send */
+#define PLD_IRQ_SIO0_RCV	(OPSPUT_PLD_IRQ_BASE + 16)	/* SIO receive */
+#define PLD_IRQ_SIO0_SND	(OPSPUT_PLD_IRQ_BASE + 17)	/* SIO send */
+#define PLD_IRQ_INT18		(OPSPUT_PLD_IRQ_BASE + 18)	/* reserved */
+#define PLD_IRQ_INT19		(OPSPUT_PLD_IRQ_BASE + 19)	/* reserved */
+#define PLD_IRQ_INT20		(OPSPUT_PLD_IRQ_BASE + 20)	/* reserved */
+#define PLD_IRQ_INT21		(OPSPUT_PLD_IRQ_BASE + 21)	/* reserved */
+#define PLD_IRQ_INT22		(OPSPUT_PLD_IRQ_BASE + 22)	/* reserved */
+#define PLD_IRQ_INT23		(OPSPUT_PLD_IRQ_BASE + 23)	/* reserved */
+#define PLD_IRQ_INT24		(OPSPUT_PLD_IRQ_BASE + 24)	/* reserved */
+#define PLD_IRQ_INT25		(OPSPUT_PLD_IRQ_BASE + 25)	/* reserved */
+#define PLD_IRQ_INT26		(OPSPUT_PLD_IRQ_BASE + 26)	/* reserved */
+#define PLD_IRQ_INT27		(OPSPUT_PLD_IRQ_BASE + 27)	/* reserved */
+#define PLD_IRQ_INT28		(OPSPUT_PLD_IRQ_BASE + 28)	/* reserved */
+#define PLD_IRQ_INT29		(OPSPUT_PLD_IRQ_BASE + 29)	/* reserved */
+#define PLD_IRQ_INT30		(OPSPUT_PLD_IRQ_BASE + 30)	/* reserved */
+#define PLD_IRQ_INT31		(OPSPUT_PLD_IRQ_BASE + 31)	/* reserved */
+
+#else	/* CONFIG_PLAT_USRV */
+
+#define PLD_IRQ_INT0		(OPSPUT_PLD_IRQ_BASE + 0)	/* None */
+#define PLD_IRQ_INT1		(OPSPUT_PLD_IRQ_BASE + 1)	/* reserved */
+#define PLD_IRQ_INT2		(OPSPUT_PLD_IRQ_BASE + 2)	/* reserved */
+#define PLD_IRQ_CF0		(OPSPUT_PLD_IRQ_BASE + 3)	/* CF0# */
+#define PLD_IRQ_CF1		(OPSPUT_PLD_IRQ_BASE + 4)	/* CF1# */
+#define PLD_IRQ_CF2		(OPSPUT_PLD_IRQ_BASE + 5)	/* CF2# */
+#define PLD_IRQ_CF3		(OPSPUT_PLD_IRQ_BASE + 6)	/* CF3# */
+#define PLD_IRQ_CF4		(OPSPUT_PLD_IRQ_BASE + 7)	/* CF4# */
+#define PLD_IRQ_INT8		(OPSPUT_PLD_IRQ_BASE + 8)	/* reserved */
+#define PLD_IRQ_INT9		(OPSPUT_PLD_IRQ_BASE + 9)	/* reserved */
+#define PLD_IRQ_INT10		(OPSPUT_PLD_IRQ_BASE + 10)	/* reserved */
+#define PLD_IRQ_INT11		(OPSPUT_PLD_IRQ_BASE + 11)	/* reserved */
+#define PLD_IRQ_UART0		(OPSPUT_PLD_IRQ_BASE + 12)	/* UARTIRQ0 */
+#define PLD_IRQ_UART1		(OPSPUT_PLD_IRQ_BASE + 13)	/* UARTIRQ1 */
+#define PLD_IRQ_INT14		(OPSPUT_PLD_IRQ_BASE + 14)	/* reserved */
+#define PLD_IRQ_INT15		(OPSPUT_PLD_IRQ_BASE + 15)	/* reserved */
+#define PLD_IRQ_SNDINT		(OPSPUT_PLD_IRQ_BASE + 16)	/* SNDINT# */
+#define PLD_IRQ_INT17		(OPSPUT_PLD_IRQ_BASE + 17)	/* reserved */
+#define PLD_IRQ_INT18		(OPSPUT_PLD_IRQ_BASE + 18)	/* reserved */
+#define PLD_IRQ_INT19		(OPSPUT_PLD_IRQ_BASE + 19)	/* reserved */
+#define PLD_IRQ_INT20		(OPSPUT_PLD_IRQ_BASE + 20)	/* reserved */
+#define PLD_IRQ_INT21		(OPSPUT_PLD_IRQ_BASE + 21)	/* reserved */
+#define PLD_IRQ_INT22		(OPSPUT_PLD_IRQ_BASE + 22)	/* reserved */
+#define PLD_IRQ_INT23		(OPSPUT_PLD_IRQ_BASE + 23)	/* reserved */
+#define PLD_IRQ_INT24		(OPSPUT_PLD_IRQ_BASE + 24)	/* reserved */
+#define PLD_IRQ_INT25		(OPSPUT_PLD_IRQ_BASE + 25)	/* reserved */
+#define PLD_IRQ_INT26		(OPSPUT_PLD_IRQ_BASE + 26)	/* reserved */
+#define PLD_IRQ_INT27		(OPSPUT_PLD_IRQ_BASE + 27)	/* reserved */
+#define PLD_IRQ_INT28		(OPSPUT_PLD_IRQ_BASE + 28)	/* reserved */
+#define PLD_IRQ_INT29		(OPSPUT_PLD_IRQ_BASE + 29)	/* reserved */
+#define PLD_IRQ_INT30		(OPSPUT_PLD_IRQ_BASE + 30)	/* reserved */
+
+#endif	/* CONFIG_PLAT_USRV */
+
+#define PLD_ICUISTS		__reg16(PLD_BASE + 0x8002)
+#define PLD_ICUISTS_VECB_MASK	(0xf000)
+#define PLD_ICUISTS_VECB(x)	((x) & PLD_ICUISTS_VECB_MASK)
+#define PLD_ICUISTS_ISN_MASK	(0x07c0)
+#define PLD_ICUISTS_ISN(x)	((x) & PLD_ICUISTS_ISN_MASK)
+#define PLD_ICUIREQ0		__reg16(PLD_BASE + 0x8004)
+#define PLD_ICUIREQ1		__reg16(PLD_BASE + 0x8006)
+#define PLD_ICUCR1		__reg16(PLD_BASE + 0x8100)
+#define PLD_ICUCR2		__reg16(PLD_BASE + 0x8102)
+#define PLD_ICUCR3		__reg16(PLD_BASE + 0x8104)
+#define PLD_ICUCR4		__reg16(PLD_BASE + 0x8106)
+#define PLD_ICUCR5		__reg16(PLD_BASE + 0x8108)
+#define PLD_ICUCR6		__reg16(PLD_BASE + 0x810a)
+#define PLD_ICUCR7		__reg16(PLD_BASE + 0x810c)
+#define PLD_ICUCR8		__reg16(PLD_BASE + 0x810e)
+#define PLD_ICUCR9		__reg16(PLD_BASE + 0x8110)
+#define PLD_ICUCR10		__reg16(PLD_BASE + 0x8112)
+#define PLD_ICUCR11		__reg16(PLD_BASE + 0x8114)
+#define PLD_ICUCR12		__reg16(PLD_BASE + 0x8116)
+#define PLD_ICUCR13		__reg16(PLD_BASE + 0x8118)
+#define PLD_ICUCR14		__reg16(PLD_BASE + 0x811a)
+#define PLD_ICUCR15		__reg16(PLD_BASE + 0x811c)
+#define PLD_ICUCR16		__reg16(PLD_BASE + 0x811e)
+#define PLD_ICUCR17		__reg16(PLD_BASE + 0x8120)
+#define PLD_ICUCR_IEN		(0x1000)
+#define PLD_ICUCR_IREQ		(0x0100)
+#define PLD_ICUCR_ISMOD00	(0x0000)	/* Low edge */
+#define PLD_ICUCR_ISMOD01	(0x0010)	/* Low level */
+#define PLD_ICUCR_ISMOD02	(0x0020)	/* High edge */
+#define PLD_ICUCR_ISMOD03	(0x0030)	/* High level */
+#define PLD_ICUCR_ILEVEL0	(0x0000)
+#define PLD_ICUCR_ILEVEL1	(0x0001)
+#define PLD_ICUCR_ILEVEL2	(0x0002)
+#define PLD_ICUCR_ILEVEL3	(0x0003)
+#define PLD_ICUCR_ILEVEL4	(0x0004)
+#define PLD_ICUCR_ILEVEL5	(0x0005)
+#define PLD_ICUCR_ILEVEL6	(0x0006)
+#define PLD_ICUCR_ILEVEL7	(0x0007)
+
+/* Power Control of MMC and CF */
+#define PLD_CPCR		__reg16(PLD_BASE + 0x14000)
+#define PLD_CPCR_CF		0x0001
+#define PLD_CPCR_MMC		0x0002
+
+/* LED Control
+ *
+ * 1: DIP swich side
+ * 2: Reset switch side
+ */
+#define PLD_IOLEDCR		__reg16(PLD_BASE + 0x14002)
+#define PLD_IOLED_1_ON		0x001
+#define PLD_IOLED_1_OFF		0x000
+#define PLD_IOLED_2_ON		0x002
+#define PLD_IOLED_2_OFF		0x000
+
+/* DIP Switch
+ *  0: Write-protect of Flash Memory (0:protected, 1:non-protected)
+ *  1: -
+ *  2: -
+ *  3: -
+ */
+#define PLD_IOSWSTS		__reg16(PLD_BASE + 0x14004)
+#define	PLD_IOSWSTS_IOSW2	0x0200
+#define	PLD_IOSWSTS_IOSW1	0x0100
+#define	PLD_IOSWSTS_IOWP0	0x0001
+
+/* CRC */
+#define PLD_CRC7DATA		__reg16(PLD_BASE + 0x18000)
+#define PLD_CRC7INDATA		__reg16(PLD_BASE + 0x18002)
+#define PLD_CRC16DATA		__reg16(PLD_BASE + 0x18004)
+#define PLD_CRC16INDATA		__reg16(PLD_BASE + 0x18006)
+#define PLD_CRC16ADATA		__reg16(PLD_BASE + 0x18008)
+#define PLD_CRC16AINDATA	__reg16(PLD_BASE + 0x1800a)
+
+/* RTC */
+#define PLD_RTCCR		__reg16(PLD_BASE + 0x1c000)
+#define PLD_RTCBAUR		__reg16(PLD_BASE + 0x1c002)
+#define PLD_RTCWRDATA		__reg16(PLD_BASE + 0x1c004)
+#define PLD_RTCRDDATA		__reg16(PLD_BASE + 0x1c006)
+#define PLD_RTCRSTODT		__reg16(PLD_BASE + 0x1c008)
+
+/* SIO0 */
+#define PLD_ESIO0CR		__reg16(PLD_BASE + 0x20000)
+#define	PLD_ESIO0CR_TXEN	0x0001
+#define	PLD_ESIO0CR_RXEN	0x0002
+#define PLD_ESIO0MOD0		__reg16(PLD_BASE + 0x20002)
+#define	PLD_ESIO0MOD0_CTSS	0x0040
+#define	PLD_ESIO0MOD0_RTSS	0x0080
+#define PLD_ESIO0MOD1		__reg16(PLD_BASE + 0x20004)
+#define	PLD_ESIO0MOD1_LMFS	0x0010
+#define PLD_ESIO0STS		__reg16(PLD_BASE + 0x20006)
+#define	PLD_ESIO0STS_TEMP	0x0001
+#define	PLD_ESIO0STS_TXCP	0x0002
+#define	PLD_ESIO0STS_RXCP	0x0004
+#define	PLD_ESIO0STS_TXSC	0x0100
+#define	PLD_ESIO0STS_RXSC	0x0200
+#define PLD_ESIO0STS_TXREADY	(PLD_ESIO0STS_TXCP | PLD_ESIO0STS_TEMP)
+#define PLD_ESIO0INTCR		__reg16(PLD_BASE + 0x20008)
+#define	PLD_ESIO0INTCR_TXIEN	0x0002
+#define	PLD_ESIO0INTCR_RXCEN	0x0004
+#define PLD_ESIO0BAUR		__reg16(PLD_BASE + 0x2000a)
+#define PLD_ESIO0TXB		__reg16(PLD_BASE + 0x2000c)
+#define PLD_ESIO0RXB		__reg16(PLD_BASE + 0x2000e)
+
+/* SIM Card */
+#define PLD_SCCR		__reg16(PLD_BASE + 0x38000)
+#define PLD_SCMOD		__reg16(PLD_BASE + 0x38004)
+#define PLD_SCSTS		__reg16(PLD_BASE + 0x38006)
+#define PLD_SCINTCR		__reg16(PLD_BASE + 0x38008)
+#define PLD_SCBAUR		__reg16(PLD_BASE + 0x3800a)
+#define PLD_SCTXB		__reg16(PLD_BASE + 0x3800c)
+#define PLD_SCRXB		__reg16(PLD_BASE + 0x3800e)
+
+#endif	/* _OPSPUT_OPSPUT_PLD.H */
diff -ruN linux-2.6.7.org/include/asm-m32r/page.h linux-2.6.7/include/asm-m32r/page.h
--- linux-2.6.7.org/include/asm-m32r/page.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/page.h	2004-07-27 14:44:00.000000000 +0900
@@ -0,0 +1,112 @@
+#ifndef _ASM_M32R_PAGE_H
+#define _ASM_M32R_PAGE_H
+
+/* $Id$ */
+
+#include <linux/config.h>
+
+/* PAGE_SHIFT determines the page size */
+#define PAGE_SHIFT	12
+#define PAGE_SIZE	(1UL << PAGE_SHIFT)
+#define PAGE_MASK	(~(PAGE_SIZE-1))
+
+#ifdef __KERNEL__
+#ifndef __ASSEMBLY__
+
+extern void clear_page(void *to);
+extern void copy_page(void *to, void *from);
+
+#define clear_user_page(page, vaddr, pg)	clear_page(page)
+#define copy_user_page(to, from, vaddr, pg)	copy_page(to, from)
+
+/*
+ * These are used to make use of C type-checking..
+ */
+typedef struct { unsigned long pte; } pte_t;
+typedef struct { unsigned long pmd; } pmd_t;
+typedef struct { unsigned long pgd; } pgd_t;
+#define pte_val(x)	((x).pte)
+#define PTE_MASK	PAGE_MASK
+
+typedef struct { unsigned long pgprot; } pgprot_t;
+
+#define pmd_val(x)	((x).pmd)
+#define pgd_val(x)	((x).pgd)
+#define pgprot_val(x)	((x).pgprot)
+
+#define __pte(x) ((pte_t) { (x) } )
+#define __pmd(x) ((pmd_t) { (x) } )
+#define __pgd(x) ((pgd_t) { (x) } )
+#define __pgprot(x)	((pgprot_t) { (x) } )
+
+#endif /* !__ASSEMBLY__ */
+
+/* to align the pointer to the (next) page boundary */
+#define PAGE_ALIGN(addr)	(((addr) + PAGE_SIZE - 1) & PAGE_MASK)
+
+/*
+ * This handles the memory map.. We could make this a config
+ * option, but too many people screw it up, and too few need
+ * it.
+ *
+ * A __PAGE_OFFSET of 0xC0000000 means that the kernel has
+ * a virtual address space of one gigabyte, which limits the
+ * amount of physical memory you can use to about 950MB. 
+ *
+ * If you want more physical memory than this then see the CONFIG_HIGHMEM4G
+ * and CONFIG_HIGHMEM64G options in the kernel configuration.
+ */
+
+
+/* This handles the memory map.. */
+
+#ifndef __ASSEMBLY__
+
+/* Pure 2^n version of get_order */
+static __inline__ int get_order(unsigned long size)
+{
+	int order;
+
+	size = (size - 1) >> (PAGE_SHIFT - 1);
+	order = -1;
+	do {
+		size >>= 1;
+		order++;
+	} while (size);
+
+	return order;
+}
+
+#endif /* __ASSEMBLY__ */
+
+#define __MEMORY_START  CONFIG_MEMORY_START
+#define __MEMORY_SIZE   CONFIG_MEMORY_SIZE
+
+#ifdef CONFIG_MMU
+#define __PAGE_OFFSET  (0x80000000)
+#else
+#define __PAGE_OFFSET  (0x00000000)
+#endif
+
+#define PAGE_OFFSET		((unsigned long)__PAGE_OFFSET)
+#define __pa(x)			((unsigned long)(x) - PAGE_OFFSET)
+#define __va(x)			((void *)((unsigned long)(x) + PAGE_OFFSET))
+
+#ifndef CONFIG_DISCONTIGMEM
+#define PFN_BASE		(CONFIG_MEMORY_START >> PAGE_SHIFT)
+#define pfn_to_page(pfn)	(mem_map + ((pfn) - PFN_BASE))
+#define page_to_pfn(page)	\
+	((unsigned long)((page) - mem_map) + PFN_BASE)
+#define pfn_valid(pfn)		(((pfn) - PFN_BASE) < max_mapnr)
+#endif  /* !CONFIG_DISCONTIGMEM */
+
+#define virt_to_page(kaddr)	pfn_to_page(__pa(kaddr) >> PAGE_SHIFT)
+#define virt_addr_valid(kaddr)	pfn_valid(__pa(kaddr) >> PAGE_SHIFT)
+
+#define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \
+				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC )
+
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_M32R_PAGE_H */
+
diff -ruN linux-2.6.7.org/include/asm-m32r/param.h linux-2.6.7/include/asm-m32r/param.h
--- linux-2.6.7.org/include/asm-m32r/param.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/param.h	2004-03-25 13:29:22.000000000 +0900
@@ -0,0 +1,27 @@
+#ifndef _ASM_M32R_PARAM_H
+#define _ASM_M32R_PARAM_H
+
+/* $Id$ */
+
+/* orig : i386 2.5.67 */
+
+#ifdef __KERNEL__
+# define HZ		100		/* Internal kernel timer frequency */
+# define USER_HZ	100		/* .. some user interfaces are in "ticks" */
+# define CLOCKS_PER_SEC	(USER_HZ)	/* like times() */
+#endif
+
+#ifndef HZ
+#define HZ 100
+#endif
+
+#define EXEC_PAGESIZE	4096
+
+#ifndef NOGROUP
+#define NOGROUP		(-1)
+#endif
+
+#define MAXHOSTNAMELEN	64	/* max length of hostname */
+
+#endif /* _ASM_M32R_PARAM_H */
+
diff -ruN linux-2.6.7.org/include/asm-m32r/pci.h linux-2.6.7/include/asm-m32r/pci.h
--- linux-2.6.7.org/include/asm-m32r/pci.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/pci.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,10 @@
+#ifndef _ASM_M32R_PCI_H
+#define _ASM_M32R_PCI_H
+
+/* $Id$ */
+
+#include <asm-generic/pci.h>
+
+#define PCI_DMA_BUS_IS_PHYS	(1)
+
+#endif /* _ASM_M32R_PCI_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/percpu.h linux-2.6.7/include/asm-m32r/percpu.h
--- linux-2.6.7.org/include/asm-m32r/percpu.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/percpu.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,6 @@
+#ifndef __ARCH_M32R_PERCPU__
+#define __ARCH_M32R_PERCPU__
+
+#include <asm-generic/percpu.h>
+
+#endif /* __ARCH_M32R_PERCPU__ */
diff -ruN linux-2.6.7.org/include/asm-m32r/pgalloc.h linux-2.6.7/include/asm-m32r/pgalloc.h
--- linux-2.6.7.org/include/asm-m32r/pgalloc.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/pgalloc.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,87 @@
+#ifndef _ASM_M32R_PGALLOC_H
+#define _ASM_M32R_PGALLOC_H
+
+/* $Id$ */
+
+#include <linux/config.h>
+#include <linux/mm.h>
+
+#include <asm/io.h>
+#include <asm/pgtable.h>
+
+#define pmd_populate_kernel(mm, pmd, pte)	\
+	set_pmd(pmd, __pmd(_PAGE_TABLE + __pa(pte)))
+
+static __inline__ void pmd_populate(struct mm_struct *mm, pmd_t *pmd, 
+	struct page *pte)
+{
+	set_pmd(pmd, __pmd(_PAGE_TABLE + page_to_phys(pte)));
+}
+
+/*
+ * Allocate and free page tables.
+ */
+static __inline__ pgd_t *pgd_alloc(struct mm_struct *mm)
+{
+	pgd_t *pgd = (pgd_t *)__get_free_page(GFP_KERNEL);
+
+	if (pgd) 
+		clear_page(pgd);
+
+	return pgd;
+}
+
+static __inline__ void pgd_free(pgd_t *pgd)
+{
+	free_page((unsigned long)pgd);
+}
+
+static __inline__ pte_t *pte_alloc_one_kernel(struct mm_struct *mm, 
+	unsigned long address)
+{
+	pte_t *pte = (pte_t *)__get_free_page(GFP_KERNEL);
+
+	if (pte)
+		clear_page(pte);
+
+	return pte;
+}
+
+static __inline__ struct page *pte_alloc_one(struct mm_struct *mm, 
+	unsigned long address)
+{
+	struct page *pte = alloc_page(GFP_KERNEL);
+
+	if (pte)
+		clear_page(page_address(pte));
+
+	return pte;
+}
+
+static __inline__ void pte_free_kernel(pte_t *pte)
+{
+	free_page((unsigned long)pte);
+}
+
+static __inline__ void pte_free(struct page *pte)
+{
+	__free_page(pte);
+}
+
+#define __pte_free_tlb(tlb, pte)	pte_free((pte))
+
+/*
+ * allocating and freeing a pmd is trivial: the 1-entry pmd is
+ * inside the pgd, so has no extra memory associated with it.
+ * (In the PAE case we free the pmds as part of the pgd.)
+ */
+
+#define pmd_alloc_one(mm, addr)		({ BUG(); ((pmd_t *)2); })
+#define pmd_free(x)			do { } while (0)
+#define __pmd_free_tlb(tlb, x)		do { } while (0)
+#define pgd_populate(mm, pmd, pte)	BUG()
+
+#define check_pgt_cache()	do { } while (0)
+
+#endif /* _ASM_M32R_PGALLOC_H */
+
diff -ruN linux-2.6.7.org/include/asm-m32r/pgtable-2level.h linux-2.6.7/include/asm-m32r/pgtable-2level.h
--- linux-2.6.7.org/include/asm-m32r/pgtable-2level.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/pgtable-2level.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,77 @@
+#ifndef _ASM_M32R_PGTABLE_2LEVEL_H
+#define _ASM_M32R_PGTABLE_2LEVEL_H
+
+/* $Id$ */
+
+#include <linux/config.h>
+
+/*
+ * traditional M32R two-level paging structure:
+ */
+
+#define PGDIR_SHIFT	22
+#define PTRS_PER_PGD	1024
+
+/*
+ * the M32R is two-level, so we don't really have any
+ * PMD directory physically.
+ */
+#define PMD_SHIFT	22
+#define PTRS_PER_PMD	1
+
+#define PTRS_PER_PTE	1024
+
+#define pte_ERROR(e) \
+	printk("%s:%d: bad pte %08lx.\n", __FILE__, __LINE__, pte_val(e))
+#define pmd_ERROR(e) \
+	printk("%s:%d: bad pmd %08lx.\n", __FILE__, __LINE__, pmd_val(e))
+#define pgd_ERROR(e) \
+	printk("%s:%d: bad pgd %08lx.\n", __FILE__, __LINE__, pgd_val(e))
+
+/*
+ * The "pgd_xxx()" functions here are trivial for a folded two-level
+ * setup: the pgd is never bad, and a pmd always exists (as it's folded
+ * into the pgd entry)
+ */
+static __inline__ int pgd_none(pgd_t pgd)	{ return 0; }
+static __inline__ int pgd_bad(pgd_t pgd)	{ return 0; }
+static __inline__ int pgd_present(pgd_t pgd)	{ return 1; }
+#define pgd_clear(xp)				do { } while (0)
+
+/*
+ * Certain architectures need to do special things when PTEs
+ * within a page table are directly modified.  Thus, the following
+ * hook is made available.
+ */
+#define set_pte(pteptr, pteval) (*(pteptr) = pteval)
+#define set_pte_atomic(pteptr, pteval)	set_pte(pteptr, pteval)
+/*
+ * (pmds are folded into pgds so this doesnt get actually called,
+ * but the define is needed for a generic inline function.)
+ */
+#define set_pmd(pmdptr, pmdval) (*(pmdptr) = pmdval)
+#define set_pgd(pgdptr, pgdval) (*(pgdptr) = pgdval)
+
+#define pgd_page(pgd) \
+((unsigned long) __va(pgd_val(pgd) & PAGE_MASK))
+
+static __inline__ pmd_t *pmd_offset(pgd_t * dir, unsigned long address)
+{
+	return (pmd_t *) dir;
+}
+
+#define ptep_get_and_clear(xp)	__pte(xchg(&(xp)->pte, 0))
+#define pte_same(a, b)		(pte_val(a) == pte_val(b))
+#define pte_page(x)		pfn_to_page(pte_pfn(x))
+#define pte_none(x)		(!pte_val(x))
+#define pte_pfn(x)		(pte_val(x) >> PAGE_SHIFT)
+#define pfn_pte(pfn, prot)	__pte(((pfn) << PAGE_SHIFT) | pgprot_val(prot))
+#define pfn_pmd(pfn, prot)	__pmd(((pfn) << PAGE_SHIFT) | pgprot_val(prot))
+
+/* M32R_FIXME : PTE_FILE_MAX_BITS, pte_to_pgoff, pgoff_to_pte */
+#define PTE_FILE_MAX_BITS	31
+#define pte_to_pgoff(pte)	(pte_val(pte) >> 1)
+#define pgoff_to_pte(off)	((pte_t) { ((off) << 1) | _PAGE_FILE })
+
+#endif /* _ASM_M32R_PGTABLE_2LEVEL_H */
+
diff -ruN linux-2.6.7.org/include/asm-m32r/pgtable.h linux-2.6.7/include/asm-m32r/pgtable.h
--- linux-2.6.7.org/include/asm-m32r/pgtable.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/pgtable.h	2004-07-15 13:43:17.000000000 +0900
@@ -0,0 +1,422 @@
+#ifndef _ASM_M32R_PGTABLE_H
+#define _ASM_M32R_PGTABLE_H
+
+/* $Id$ */
+
+/*
+ * The Linux memory management assumes a three-level page table setup. On
+ * the M32R, we use that, but "fold" the mid level into the top-level page
+ * table, so that we physically have the same two-level page table as the
+ * M32R mmu expects.
+ *
+ * This file contains the functions and defines necessary to modify and use
+ * the M32R page table tree.
+ */
+
+/* CAUTION!: If you change macro definitions in this file, you might have to 
+ * change arch/m32r/mmu.S manually.
+ */
+
+#ifndef __ASSEMBLY__
+
+#include <linux/config.h>
+#include <linux/threads.h>
+#include <asm/processor.h>
+#include <asm/addrspace.h>
+#include <asm/bitops.h>
+#include <asm/page.h>
+
+extern pgd_t swapper_pg_dir[1024];
+extern void paging_init(void);
+
+/*
+ * ZERO_PAGE is a global shared page that is always zero: used
+ * for zero-mapped memory areas etc..
+ */
+extern unsigned long empty_zero_page[1024];
+#define ZERO_PAGE(vaddr)	(virt_to_page(empty_zero_page))
+
+#endif /* !__ASSEMBLY__ */
+
+/*
+ * The Linux x86 paging architecture is 'compile-time dual-mode', it
+ * implements both the traditional 2-level x86 page tables and the
+ * newer 3-level PAE-mode page tables.
+ */
+#ifndef __ASSEMBLY__
+#include <asm/pgtable-2level.h>
+#endif
+
+#define pgtable_cache_init()	do { } while (0)
+
+#define PMD_SIZE	(1UL << PMD_SHIFT)
+#define PMD_MASK	(~(PMD_SIZE - 1))
+#define PGDIR_SIZE	(1UL << PGDIR_SHIFT)
+#define PGDIR_MASK	(~(PGDIR_SIZE - 1))
+
+#define USER_PTRS_PER_PGD	(TASK_SIZE / PGDIR_SIZE)
+#define FIRST_USER_PGD_NR	0
+
+#ifndef __ASSEMBLY__
+/* Just any arbitrary offset to the start of the vmalloc VM area: the
+ * current 8MB value just means that there will be a 8MB "hole" after the
+ * physical memory until the kernel virtual memory starts.  That means that
+ * any out-of-bounds memory accesses will hopefully be caught.
+ * The vmalloc() routines leaves a hole of 4kB between each vmalloced
+ * area for the same reason. ;)
+ */
+#define VMALLOC_START		KSEG2
+#define VMALLOC_END		KSEG3
+
+/*
+ * The 4MB page is guessing..  Detailed in the infamous "Chapter H"
+ * of the Pentium details, but assuming intel did the straightforward
+ * thing, this bit set in the page directory entry just means that
+ * the page directory entry points directly to a 4MB-aligned block of
+ * memory. 
+ */
+
+/*
+ *     M32R TLB format
+ *
+ *     [0]    [1:19]           [20:23]       [24:31]
+ *     +-----------------------+----+-------------+
+ *     |          VPN          |0000|    ASID     |    
+ *     +-----------------------+----+-------------+
+ *     +-+---------------------+----+-+---+-+-+-+-+
+ *     |0         PPN          |0000|N|AC |L|G|V| |    
+ *     +-+---------------------+----+-+---+-+-+-+-+
+ *                                     RWX
+ */
+
+#define _PAGE_BIT_DIRTY		0	/* software */
+#define _PAGE_BIT_FILE		0	/* when !present: nonlinear file 
+					   mapping */
+#define _PAGE_BIT_PRESENT	1	/* Valid */
+#define _PAGE_BIT_GLOBAL	2	/* Global */
+#define _PAGE_BIT_LARGE		3	/* Large */
+#define _PAGE_BIT_EXEC		4	/* Execute */
+#define _PAGE_BIT_WRITE		5	/* Write */
+#define _PAGE_BIT_READ		6	/* Read */
+#define _PAGE_BIT_NONCACHABLE	7	/* Non cachable */
+#define _PAGE_BIT_USER		8	/* software */
+#define _PAGE_BIT_ACCESSED	9	/* software */
+
+#define _PAGE_DIRTY	\
+	(1UL << _PAGE_BIT_DIRTY)	/* software : page changed */
+#define _PAGE_FILE	\
+	(1UL << _PAGE_BIT_FILE)		/* when !present: nonlinear file 
+					   mapping */
+#define _PAGE_PRESENT	\
+	(1UL << _PAGE_BIT_PRESENT)	/* Valid : Page is Valid */
+#define _PAGE_GLOBAL	\
+	(1UL << _PAGE_BIT_GLOBAL)	/* Global */
+#define _PAGE_LARGE	\
+	(1UL << _PAGE_BIT_LARGE)	/* Large */
+#define _PAGE_EXEC	\
+	(1UL << _PAGE_BIT_EXEC)		/* Execute */
+#define _PAGE_WRITE	\
+	(1UL << _PAGE_BIT_WRITE)	/* Write */
+#define _PAGE_READ	\
+	(1UL << _PAGE_BIT_READ)		/* Read */
+#define _PAGE_NONCACHABLE	\
+	(1UL<<_PAGE_BIT_NONCACHABLE)	/* Non cachable */
+#define _PAGE_USER	\
+	(1UL << _PAGE_BIT_USER)		/* software : user space access 
+					   allowed */
+#define _PAGE_ACCESSED	\
+	(1UL << _PAGE_BIT_ACCESSED)	/* software : page referenced */
+
+#define _PAGE_TABLE	\
+	( _PAGE_PRESENT | _PAGE_WRITE | _PAGE_READ | _PAGE_USER \
+	| _PAGE_ACCESSED | _PAGE_DIRTY )
+#define _KERNPG_TABLE	\
+	( _PAGE_PRESENT | _PAGE_WRITE | _PAGE_READ | _PAGE_ACCESSED \
+	| _PAGE_DIRTY )
+#define _PAGE_CHG_MASK	\
+	( PTE_MASK | _PAGE_ACCESSED | _PAGE_DIRTY )
+
+#ifdef CONFIG_MMU
+#define PAGE_NONE	\
+	__pgprot(_PAGE_PRESENT | _PAGE_ACCESSED)
+#define PAGE_SHARED	\
+	__pgprot(_PAGE_PRESENT | _PAGE_WRITE | _PAGE_READ | _PAGE_USER \
+		| _PAGE_ACCESSED)
+#define PAGE_SHARED_X	\
+	__pgprot(_PAGE_PRESENT | _PAGE_EXEC | _PAGE_WRITE | _PAGE_READ \
+		| _PAGE_USER | _PAGE_ACCESSED)
+#define PAGE_COPY	\
+	__pgprot(_PAGE_PRESENT | _PAGE_EXEC | _PAGE_READ | _PAGE_USER \
+		| _PAGE_ACCESSED)
+#define PAGE_COPY_X	\
+	__pgprot(_PAGE_PRESENT | _PAGE_EXEC | _PAGE_READ | _PAGE_USER \
+		| _PAGE_ACCESSED)
+#define PAGE_READONLY	\
+	__pgprot(_PAGE_PRESENT | _PAGE_READ | _PAGE_USER | _PAGE_ACCESSED)
+#define PAGE_READONLY_X	\
+	__pgprot(_PAGE_PRESENT | _PAGE_EXEC | _PAGE_READ | _PAGE_USER \
+		| _PAGE_ACCESSED)
+
+#define __PAGE_KERNEL	\
+	( _PAGE_PRESENT | _PAGE_EXEC | _PAGE_WRITE | _PAGE_READ | _PAGE_DIRTY \
+	| _PAGE_ACCESSED )
+#define __PAGE_KERNEL_RO	( __PAGE_KERNEL & ~_PAGE_WRITE )
+#define __PAGE_KERNEL_NOCACHE	( __PAGE_KERNEL | _PAGE_NONCACHABLE)
+
+#define MAKE_GLOBAL(x)	__pgprot((x) | _PAGE_GLOBAL)
+
+#define PAGE_KERNEL		MAKE_GLOBAL(__PAGE_KERNEL)
+#define PAGE_KERNEL_RO		MAKE_GLOBAL(__PAGE_KERNEL_RO)
+#define PAGE_KERNEL_NOCACHE	MAKE_GLOBAL(__PAGE_KERNEL_NOCACHE)
+
+#else
+#define PAGE_NONE               __pgprot(0)
+#define PAGE_SHARED             __pgprot(0)
+#define PAGE_SHARED_X           __pgprot(0)
+#define PAGE_COPY               __pgprot(0)
+#define PAGE_COPY_X             __pgprot(0)
+#define PAGE_READONLY           __pgprot(0)
+#define PAGE_READONLY_X         __pgprot(0)
+
+#define PAGE_KERNEL             __pgprot(0)
+#define PAGE_KERNEL_RO          __pgprot(0)
+#define PAGE_KERNEL_NOCACHE     __pgprot(0)
+#endif /* CONFIG_MMU */
+
+/*
+ * The i386 can't do page protection for execute, and considers that
+ * the same are read. Also, write permissions imply read permissions.
+ * This is the closest we can get..
+ */
+	/* rwx */
+#define __P000	PAGE_NONE
+#define __P001	PAGE_READONLY_X
+#define __P010	PAGE_COPY_X
+#define __P011	PAGE_COPY_X
+#define __P100	PAGE_READONLY
+#define __P101	PAGE_READONLY_X
+#define __P110	PAGE_COPY_X
+#define __P111	PAGE_COPY_X
+
+#define __S000	PAGE_NONE
+#define __S001	PAGE_READONLY_X
+#define __S010	PAGE_SHARED
+#define __S011	PAGE_SHARED_X
+#define __S100	PAGE_READONLY
+#define __S101	PAGE_READONLY_X
+#define __S110	PAGE_SHARED
+#define __S111	PAGE_SHARED_X
+
+/* page table for 0-4MB for everybody */
+
+#define pte_present(x)	(pte_val(x) & _PAGE_PRESENT)
+#define pte_clear(xp)	do { set_pte(xp, __pte(0)); } while (0)
+
+#define pmd_none(x)	(!pmd_val(x))
+#define pmd_present(x)	(pmd_val(x) & _PAGE_PRESENT)
+#define pmd_clear(xp)	do { set_pmd(xp, __pmd(0)); } while (0)
+#define	pmd_bad(x)	((pmd_val(x) & (~PAGE_MASK & ~_PAGE_USER)) \
+	!= _KERNPG_TABLE)
+
+#define pages_to_mb(x)	((x) >> (20 - PAGE_SHIFT))
+
+/*
+ * The following only work if pte_present() is true.
+ * Undefined behaviour if not..
+ */
+static __inline__ int pte_user(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_USER;
+}
+
+static __inline__ int pte_read(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_READ;
+}
+
+static __inline__ int pte_exec(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_EXEC;
+}
+
+static __inline__ int pte_dirty(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_DIRTY;
+}
+
+static __inline__ int pte_young(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_ACCESSED;
+}
+
+static __inline__ int pte_write(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_WRITE;
+}
+
+/*
+ * The following only works if pte_present() is not true.
+ */
+static __inline__ int pte_file(pte_t pte)
+{
+	return pte_val(pte) & _PAGE_FILE;
+}
+
+static __inline__ pte_t pte_rdprotect(pte_t pte)
+{
+	pte_val(pte) &= ~_PAGE_READ;
+	return pte;
+}
+
+static __inline__ pte_t pte_exprotect(pte_t pte)
+{
+	pte_val(pte) &= ~_PAGE_EXEC;
+	return pte;
+}
+
+static __inline__ pte_t pte_mkclean(pte_t pte)
+{
+	pte_val(pte) &= ~_PAGE_DIRTY;
+	return pte;
+}
+
+static __inline__ pte_t pte_mkold(pte_t pte)
+{
+	pte_val(pte) &= ~_PAGE_ACCESSED;return pte;}
+
+static __inline__ pte_t pte_wrprotect(pte_t pte)
+{
+	pte_val(pte) &= ~_PAGE_WRITE;
+	return pte;
+}
+
+static __inline__ pte_t pte_mkread(pte_t pte)
+{
+	pte_val(pte) |= _PAGE_READ;
+	return pte;
+}
+
+static __inline__ pte_t pte_mkexec(pte_t pte)
+{
+	pte_val(pte) |= _PAGE_EXEC;
+	return pte;
+}
+
+static __inline__ pte_t pte_mkdirty(pte_t pte)
+{
+	pte_val(pte) |= _PAGE_DIRTY;
+	return pte;
+}
+
+static __inline__ pte_t pte_mkyoung(pte_t pte)
+{
+	pte_val(pte) |= _PAGE_ACCESSED;
+	return pte;
+}
+
+static __inline__ pte_t pte_mkwrite(pte_t pte)
+{
+	pte_val(pte) |= _PAGE_WRITE;
+	return pte;
+}
+
+static __inline__  int ptep_test_and_clear_dirty(pte_t *ptep)
+{
+	return test_and_clear_bit(_PAGE_BIT_DIRTY, ptep);
+}
+
+static __inline__  int ptep_test_and_clear_young(pte_t *ptep)
+{
+	return test_and_clear_bit(_PAGE_BIT_ACCESSED, ptep);
+}
+
+static __inline__ void ptep_set_wrprotect(pte_t *ptep)
+{
+	clear_bit(_PAGE_BIT_WRITE, ptep);
+}
+
+static __inline__ void ptep_mkdirty(pte_t *ptep)
+{
+	set_bit(_PAGE_BIT_DIRTY, ptep);
+}
+
+/*
+ * Conversion functions: convert a page and protection to a page entry,
+ * and a page entry and page directory to the page they refer to.
+ */
+#define mk_pte(page, pgprot)	pfn_pte(page_to_pfn(page), pgprot)
+
+static __inline__ pte_t pte_modify(pte_t pte, pgprot_t newprot)
+{
+	set_pte(&pte, __pte((pte_val(pte) & _PAGE_CHG_MASK) \
+		| pgprot_val(newprot)));
+
+	return pte;
+}
+
+#define page_pte(page)	page_pte_prot(page, __pgprot(0))
+
+/*
+ * Conversion functions: convert a page and protection to a page entry,
+ * and a page entry and page directory to the page they refer to.
+ */
+
+static __inline__ void pmd_set(pmd_t * pmdp, pte_t * ptep)
+{
+	pmd_val(*pmdp) = (((unsigned long) ptep) & PAGE_MASK);
+}
+
+#define pmd_page_kernel(pmd)	\
+	((unsigned long) __va(pmd_val(pmd) & PAGE_MASK))
+
+#ifndef CONFIG_DISCONTIGMEM
+#define pmd_page(pmd)	(mem_map + ((pmd_val(pmd) >> PAGE_SHIFT) - PFN_BASE))
+#endif /* !CONFIG_DISCONTIGMEM */
+
+/* to find an entry in a page-table-directory. */
+#define pgd_index(address)	\
+	(((address) >> PGDIR_SHIFT) & (PTRS_PER_PGD - 1))
+
+#define pgd_offset(mm, address)	((mm)->pgd + pgd_index(address))
+
+/* to find an entry in a kernel page-table-directory */
+#define pgd_offset_k(address)	pgd_offset(&init_mm, address)
+
+#define pmd_index(address)	\
+	(((address) >> PMD_SHIFT) & (PTRS_PER_PMD - 1))
+
+#define pte_index(address)	\
+	(((address) >> PAGE_SHIFT) & (PTRS_PER_PTE - 1))
+#define pte_offset_kernel(dir, address)	\
+	((pte_t *)pmd_page_kernel(*(dir)) + pte_index(address))
+#define pte_offset_map(dir, address)	\
+	((pte_t *)page_address(pmd_page(*(dir))) + pte_index(address))
+#define pte_offset_map_nested(dir, address)	pte_offset_map(dir, address)
+#define pte_unmap(pte)		do { } while (0)
+#define pte_unmap_nested(pte)	do { } while (0)
+
+/* Encode and de-code a swap entry */
+#define __swp_type(x)			(((x).val >> 1) & 0x3f)
+#define __swp_offset(x)			((x).val >> 8)
+#define __swp_entry(type, offset)	\
+	((swp_entry_t) { ((type) << 1) | ((offset) << 8) })
+#define __pte_to_swp_entry(pte)		((swp_entry_t) { pte_val(pte) })
+#define __swp_entry_to_pte(x)		((pte_t) { (x).val })
+
+#endif /* !__ASSEMBLY__ */
+
+/* Needs to be defined here and not in linux/mm.h, as it is arch dependent */
+#define kern_addr_valid(addr)	(1)
+
+#define io_remap_page_range	remap_page_range
+
+#define __HAVE_ARCH_PTEP_TEST_AND_CLEAR_YOUNG
+#define __HAVE_ARCH_PTEP_TEST_AND_CLEAR_DIRTY
+#define __HAVE_ARCH_PTEP_GET_AND_CLEAR
+#define __HAVE_ARCH_PTEP_SET_WRPROTECT
+#define __HAVE_ARCH_PTEP_MKDIRTY
+#define __HAVE_ARCH_PTE_SAME
+#include <asm-generic/pgtable.h>
+
+#endif /* _ASM_M32R_PGTABLE_H */
+
diff -ruN linux-2.6.7.org/include/asm-m32r/poll.h linux-2.6.7/include/asm-m32r/poll.h
--- linux-2.6.7.org/include/asm-m32r/poll.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/poll.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,29 @@
+#ifndef _ASM_M32R_POLL_H
+#define _ASM_M32R_POLL_H
+
+/* $Id$ */
+
+/* orig : i386 2.4.18 */
+
+/* These are specified by iBCS2 */
+#define POLLIN		0x0001
+#define POLLPRI		0x0002
+#define POLLOUT		0x0004
+#define POLLERR		0x0008
+#define POLLHUP		0x0010
+#define POLLNVAL	0x0020
+
+/* The rest seem to be more-or-less nonstandard. Check them! */
+#define POLLRDNORM	0x0040
+#define POLLRDBAND	0x0080
+#define POLLWRNORM	0x0100
+#define POLLWRBAND	0x0200
+#define POLLMSG		0x0400
+
+struct pollfd {
+	int fd;
+	short events;
+	short revents;
+};
+
+#endif  /* _ASM_M32R_POLL_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/posix_types.h linux-2.6.7/include/asm-m32r/posix_types.h
--- linux-2.6.7.org/include/asm-m32r/posix_types.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/posix_types.h	2003-10-01 11:48:18.000000000 +0900
@@ -0,0 +1,126 @@
+#ifndef _ASM_M32R_POSIX_TYPES_H
+#define _ASM_M32R_POSIX_TYPES_H
+
+/* $Id$ */
+
+/* orig : i386, sh 2.4.18 */
+
+/*
+ * This file is generally used by user-level software, so you need to
+ * be a little careful about namespace pollution etc.  Also, we cannot
+ * assume GCC is being used.
+ */
+
+typedef unsigned long	__kernel_ino_t;
+typedef unsigned short	__kernel_mode_t;
+typedef unsigned short	__kernel_nlink_t;
+typedef long		__kernel_off_t;
+typedef int		__kernel_pid_t;
+typedef unsigned short	__kernel_ipc_pid_t;
+typedef unsigned short	__kernel_uid_t;
+typedef unsigned short	__kernel_gid_t;
+typedef unsigned int	__kernel_size_t;
+typedef int		__kernel_ssize_t;
+typedef int		__kernel_ptrdiff_t;
+typedef long		__kernel_time_t;
+typedef long		__kernel_suseconds_t;
+typedef long		__kernel_clock_t;
+typedef int		__kernel_timer_t;
+typedef int		__kernel_clockid_t;
+typedef int		__kernel_daddr_t;
+typedef char *		__kernel_caddr_t;
+typedef unsigned short	__kernel_uid16_t;
+typedef unsigned short	__kernel_gid16_t;
+typedef unsigned int	__kernel_uid32_t;
+typedef unsigned int	__kernel_gid32_t;
+
+typedef unsigned short	__kernel_old_uid_t;
+typedef unsigned short	__kernel_old_gid_t;
+typedef unsigned short	__kernel_old_dev_t;
+
+#ifdef __GNUC__
+typedef long long	__kernel_loff_t;
+#endif
+
+typedef struct {
+#if defined(__KERNEL__) || defined(__USE_ALL)
+	int	val[2];
+#else /* !defined(__KERNEL__) && !defined(__USE_ALL) */
+	int	__val[2];
+#endif /* !defined(__KERNEL__) && !defined(__USE_ALL) */
+} __kernel_fsid_t;
+
+#if defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2)
+
+#undef	__FD_SET
+static __inline__ void __FD_SET(unsigned long __fd, __kernel_fd_set *__fdsetp)
+{
+	unsigned long __tmp = __fd / __NFDBITS;
+	unsigned long __rem = __fd % __NFDBITS;
+	__fdsetp->fds_bits[__tmp] |= (1UL<<__rem);
+}
+
+#undef	__FD_CLR
+static __inline__ void __FD_CLR(unsigned long __fd, __kernel_fd_set *__fdsetp)
+{
+	unsigned long __tmp = __fd / __NFDBITS;
+	unsigned long __rem = __fd % __NFDBITS;
+	__fdsetp->fds_bits[__tmp] &= ~(1UL<<__rem);
+}
+
+
+#undef	__FD_ISSET
+static __inline__ int __FD_ISSET(unsigned long __fd, const __kernel_fd_set *__p)
+{ 
+	unsigned long __tmp = __fd / __NFDBITS;
+	unsigned long __rem = __fd % __NFDBITS;
+	return (__p->fds_bits[__tmp] & (1UL<<__rem)) != 0;
+}
+
+/*
+ * This will unroll the loop for the normal constant case (8 ints,
+ * for a 256-bit fd_set)
+ */
+#undef	__FD_ZERO
+static __inline__ void __FD_ZERO(__kernel_fd_set *__p)
+{
+	unsigned long *__tmp = __p->fds_bits;
+	int __i;
+
+	if (__builtin_constant_p(__FDSET_LONGS)) {
+		switch (__FDSET_LONGS) {
+		case 16:
+			__tmp[ 0] = 0; __tmp[ 1] = 0;
+			__tmp[ 2] = 0; __tmp[ 3] = 0;
+			__tmp[ 4] = 0; __tmp[ 5] = 0;
+			__tmp[ 6] = 0; __tmp[ 7] = 0;
+			__tmp[ 8] = 0; __tmp[ 9] = 0;
+			__tmp[10] = 0; __tmp[11] = 0;
+			__tmp[12] = 0; __tmp[13] = 0;
+			__tmp[14] = 0; __tmp[15] = 0;
+			return;
+
+		case 8:
+			__tmp[ 0] = 0; __tmp[ 1] = 0;
+			__tmp[ 2] = 0; __tmp[ 3] = 0;
+			__tmp[ 4] = 0; __tmp[ 5] = 0;
+			__tmp[ 6] = 0; __tmp[ 7] = 0;
+			return;
+
+		case 4:
+			__tmp[ 0] = 0; __tmp[ 1] = 0;
+			__tmp[ 2] = 0; __tmp[ 3] = 0;
+			return;
+		}
+	}
+	__i = __FDSET_LONGS;
+	while (__i) {
+		__i--;
+		*__tmp = 0;
+		__tmp++;
+	}
+}
+
+#endif /* defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2) */
+
+#endif  /* _ASM_M32R_POSIX_TYPES_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/processor.h linux-2.6.7/include/asm-m32r/processor.h
--- linux-2.6.7.org/include/asm-m32r/processor.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/processor.h	2004-05-13 11:16:30.000000000 +0900
@@ -0,0 +1,157 @@
+#ifndef _ASM_M32R_PROCESSOR_H
+#define _ASM_M32R_PROCESSOR_H
+
+/* $Id$ */
+
+/* 
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001  by Hiroyuki Kondo, Hirokazu Takata, and Hitoshi Yamamoto
+ */
+
+/*
+ * include/asm-m32r/processor.h
+ *
+ * Copyright (C) 1994 Linus Torvalds
+ */
+#include <linux/kernel.h>
+#include <linux/config.h>
+#include <asm/cache.h>
+#include <asm/ptrace.h>  /* pt_regs */
+
+#include <asm/cachectl.h>
+
+/*
+ * Default implementation of macro that returns current
+ * instruction pointer ("program counter").
+ */
+#define current_text_addr() ({ __label__ _l; _l: &&_l; })
+
+/*
+ *  CPU type and hardware bug flags. Kept separately for each CPU.
+ *  Members of this structure are referenced in head.S, so think twice
+ *  before touching them. [mj]
+ */
+
+struct cpuinfo_m32r {
+	unsigned long pgtable_cache_sz;
+	unsigned long cpu_clock;
+	unsigned long bus_clock;
+	unsigned long timer_divide;
+	unsigned long loops_per_jiffy;
+};
+
+/*
+ * capabilities of CPUs
+ */
+
+extern struct cpuinfo_m32r boot_cpu_data;
+
+#ifdef CONFIG_SMP
+extern struct cpuinfo_m32r cpu_data[];
+#define current_cpu_data cpu_data[smp_processor_id()]
+#else
+#define cpu_data &boot_cpu_data
+#define current_cpu_data boot_cpu_data
+#endif
+
+/*
+ * User space process size: 2GB (default).
+ */
+#ifdef CONFIG_MMU
+#define TASK_SIZE  (0x80000000UL)
+#else
+#define TASK_SIZE  (0x00400000UL)
+#endif
+
+/* This decides where the kernel will search for a free chunk of vm
+ * space during mmap's.
+ */
+#define TASK_UNMAPPED_BASE	PAGE_ALIGN(TASK_SIZE / 3)
+
+typedef struct {
+	unsigned long seg;
+} mm_segment_t;
+
+struct debug_trap {
+	int nr_trap;
+	unsigned long	addr;
+	unsigned long	insn;
+};
+
+struct thread_struct {
+	unsigned long address; 
+	unsigned long trap_no;		/* Trap number  */
+	unsigned long error_code;	/* Error code of trap */
+	unsigned long lr;		/* saved pc */
+	unsigned long sp;		/* user stack pointer */
+	struct debug_trap debug_trap;
+};
+
+#define INIT_SP	(sizeof(init_stack) + (unsigned long) &init_stack)
+
+#define INIT_THREAD	{	\
+	.sp = INIT_SP,		\
+}
+
+/*
+ * Do necessary setup to start up a newly executed thread.
+ */
+
+/* User process Backup PSW */
+#define USERPS_BPSW (M32R_PSW_BSM|M32R_PSW_BIE|M32R_PSW_BPM)
+
+#define start_thread(regs, new_pc, new_spu) 				\
+	do {								\
+		set_fs(USER_DS); 					\
+		regs->psw = (regs->psw | USERPS_BPSW) & 0x0000FFFFUL;	\
+		regs->bpc = new_pc;					\
+		regs->spu = new_spu;					\
+	} while (0)
+
+/* Forward declaration, a strange C thing */
+struct task_struct;
+struct mm_struct;
+
+/* Free all resources held by a thread. */
+extern void release_thread(struct task_struct *);
+
+#define prepare_to_copy(tsk)	do { } while (0)
+
+/*
+ * create a kernel thread without removing it from tasklists
+ */
+extern int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags);
+
+/* Copy and release all segment info associated with a VM */
+extern void copy_segments(struct task_struct *p, struct mm_struct * mm);
+extern void release_segments(struct mm_struct * mm);
+
+extern unsigned long thread_saved_pc(struct task_struct *);
+
+/* Copy and release all segment info associated with a VM */
+#define copy_segments(p, mm)  do { } while (0)
+#define release_segments(mm)  do { } while (0)
+
+unsigned long get_wchan(struct task_struct *p);
+#define KSTK_EIP(tsk)  ((tsk)->thread.lr)
+#define KSTK_ESP(tsk)  ((tsk)->thread.sp)
+
+#define THREAD_SIZE (2*PAGE_SIZE)
+
+/* REP NOP (PAUSE) is a good thing to insert into busy-wait loops. */
+static __inline__ void rep_nop(void)
+{
+	__asm__ __volatile__(
+		"nop \n\t"
+		"nop \n\t"
+		:
+		:
+		: "memory");
+}
+
+#define cpu_relax()     rep_nop()
+
+#endif /* _ASM_M32R_PROCESSOR_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/ptrace.h linux-2.6.7/include/asm-m32r/ptrace.h
--- linux-2.6.7.org/include/asm-m32r/ptrace.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/ptrace.h	2004-05-11 13:53:04.000000000 +0900
@@ -0,0 +1,163 @@
+#ifndef _M32R_PTRACE_H
+#define _M32R_PTRACE_H
+
+/* $Id$ */
+
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2001, 2002, 2004  Hirokazu Takata
+ */
+
+#include <linux/config.h>
+#include <asm/m32r.h>		/* M32R_PSW_BSM, M32R_PSW_BPM */
+
+/* 0 - 13 are integer registers (general purpose registers).  */
+#define PT_R4		0
+#define PT_R5		1
+#define PT_R6		2
+#define PT_REGS 	3
+#define PT_R0		4
+#define PT_R1		5
+#define PT_R2		6
+#define PT_R3		7
+#define PT_R7		8
+#define PT_R8		9
+#define PT_R9		10
+#define PT_R10		11
+#define PT_R11		12
+#define PT_R12		13
+#define PT_SYSCNR	14
+#define PT_R13		PT_FP
+#define PT_R14		PT_LR
+#define PT_R15		PT_SP
+
+/* processor status and miscellaneous context registers.  */
+#if defined(CONFIG_ISA_M32R2) && defined(CONFIG_ISA_DSP_LEVEL2)
+#define PT_ACC0H	15
+#define PT_ACC0L	16
+#define PT_ACC1H	17
+#define PT_ACC1L	18
+#define PT_ACCH		PT_ACC0H
+#define PT_ACCL		PT_ACC0L
+#define PT_PSW		19
+#define PT_BPC		20
+#define PT_BBPSW	21
+#define PT_BBPC		22
+#define PT_SPU		23
+#define PT_FP		24
+#define PT_LR		25
+#define PT_SPI		26
+#define PT_ORIGR0	27
+#elif defined(CONFIG_ISA_M32R2) || defined(CONFIG_ISA_M32R)
+#define PT_ACCH		15
+#define PT_ACCL		16
+#define PT_PSW		17
+#define PT_BPC		18
+#define PT_BBPSW	19
+#define PT_BBPC		20
+#define PT_SPU		21
+#define PT_FP		22
+#define PT_LR		23
+#define PT_SPI		24
+#define PT_ORIGR0	25
+#else
+#error unknown isa conifiguration
+#endif
+
+/* virtual pt_reg entry for gdb */
+#define PT_PC		30
+#define PT_CBR		31
+#define PT_EVB		32
+
+
+/* Control registers.  */
+#define SPR_CR0 PT_PSW
+#define SPR_CR1 PT_CBR		/* read only */
+#define SPR_CR2 PT_SPI
+#define SPR_CR3 PT_SPU
+#define SPR_CR4 
+#define SPR_CR5 PT_EVB		/* part of M32R/E, M32R/I core only */
+#define SPR_CR6 PT_BPC
+#define SPR_CR7 
+#define SPR_CR8 PT_BBPSW
+#define SPR_CR9 
+#define SPR_CR10 
+#define SPR_CR11 
+#define SPR_CR12 
+#define SPR_CR13 PT_WR
+#define SPR_CR14 PT_BBPC
+#define SPR_CR15 
+
+/* this struct defines the way the registers are stored on the 
+   stack during a system call. */
+struct pt_regs {
+	/* Saved main processor registers. */ 
+	unsigned long r4;
+	unsigned long r5;
+	unsigned long r6;
+	struct pt_regs *pt_regs;
+	unsigned long r0;
+	unsigned long r1;
+	unsigned long r2;
+	unsigned long r3;
+	unsigned long r7;
+	unsigned long r8;
+	unsigned long r9;
+	unsigned long r10;
+	unsigned long r11;
+	unsigned long r12;
+	long syscall_nr;
+
+	/* Saved main processor status and miscellaneous context registers. */ 
+#if defined(CONFIG_ISA_M32R2) && defined(CONFIG_ISA_DSP_LEVEL2)
+	unsigned long acc0h;
+	unsigned long acc0l;
+	unsigned long acc1h;
+	unsigned long acc1l;
+#elif defined(CONFIG_ISA_M32R2) || defined(CONFIG_ISA_M32R)
+	unsigned long acch;
+	unsigned long accl;
+#else
+#error unknown isa configuration
+#endif
+	unsigned long psw;
+	unsigned long bpc;		/* saved PC for TRAP syscalls */
+	unsigned long bbpsw;
+	unsigned long bbpc;
+	unsigned long spu;		/* saved user stack */
+	unsigned long fp;
+	unsigned long lr;		/* saved PC for JL syscalls */
+	unsigned long spi;		/* saved kernel stack */
+	unsigned long orig_r0;
+};
+
+/* Arbitrarily choose the same ptrace numbers as used by the Sparc code. */
+#define PTRACE_GETREGS		12
+#define PTRACE_SETREGS		13
+
+#define PTRACE_OLDSETOPTIONS	21
+
+/* options set using PTRACE_SETOPTIONS */
+#define PTRACE_O_TRACESYSGOOD	0x00000001
+
+#ifdef __KERNEL__
+#if defined(CONFIG_ISA_M32R2) || defined(CONFIG_CHIP_VDEC2)
+#define user_mode(regs) ((M32R_PSW_BPM & (regs)->psw) != 0)
+#elif defined(CONFIG_ISA_M32R)
+#define user_mode(regs) ((M32R_PSW_BSM & (regs)->psw) != 0) 
+#else
+#error unknown isa configuration
+#endif
+
+#define instruction_pointer(regs) ((regs)->bpc)
+
+extern void show_regs(struct pt_regs *);
+
+extern void withdraw_debug_trap(struct pt_regs *regs);
+
+#endif /* __KERNEL */
+
+#endif /* _M32R_PTRACE_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/resource.h linux-2.6.7/include/asm-m32r/resource.h
--- linux-2.6.7.org/include/asm-m32r/resource.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/resource.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,51 @@
+#ifndef _ASM_M32R_RESOURCE_H
+#define _ASM_M32R_RESOURCE_H
+
+/* $Id$ */
+
+/* orig : i386 2.4.18 */
+
+/*
+ * Resource limits
+ */
+
+#define RLIMIT_CPU	0		/* CPU time in ms */
+#define RLIMIT_FSIZE	1		/* Maximum filesize */
+#define RLIMIT_DATA	2		/* max data size */
+#define RLIMIT_STACK	3		/* max stack size */
+#define RLIMIT_CORE	4		/* max core file size */
+#define RLIMIT_RSS	5		/* max resident set size */
+#define RLIMIT_NPROC	6		/* max number of processes */
+#define RLIMIT_NOFILE	7		/* max number of open files */
+#define RLIMIT_MEMLOCK	8		/* max locked-in-memory address space */
+#define RLIMIT_AS	9		/* address space limit */
+#define RLIMIT_LOCKS	10		/* maximum file locks held */
+
+#define RLIM_NLIMITS	11
+
+/*
+ * SuS says limits have to be unsigned.
+ * Which makes a ton more sense anyway.
+ */
+#define RLIM_INFINITY	(~0UL)
+
+#ifdef __KERNEL__
+
+#define INIT_RLIMITS					\
+{							\
+	{ RLIM_INFINITY, RLIM_INFINITY },		\
+	{ RLIM_INFINITY, RLIM_INFINITY },		\
+	{ RLIM_INFINITY, RLIM_INFINITY },		\
+	{      _STK_LIM, RLIM_INFINITY },		\
+	{             0, RLIM_INFINITY },		\
+	{ RLIM_INFINITY, RLIM_INFINITY },		\
+	{             0,             0 },		\
+	{      INR_OPEN,     INR_OPEN  },		\
+	{ RLIM_INFINITY, RLIM_INFINITY },		\
+	{ RLIM_INFINITY, RLIM_INFINITY },		\
+        { RLIM_INFINITY, RLIM_INFINITY },		\
+}
+
+#endif /* __KERNEL__ */
+
+#endif  /* _ASM_M32R_RESOURCE_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/rtc.h linux-2.6.7/include/asm-m32r/rtc.h
--- linux-2.6.7.org/include/asm-m32r/rtc.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/rtc.h	2004-03-25 13:51:37.000000000 +0900
@@ -0,0 +1,70 @@
+/* $Id: rtc.h,v 1.1.1.1 2004/03/25 04:29:22 hitoshiy Exp $ */
+
+#ifndef __RTC_H__
+#define __RTC_H__
+
+
+#include <linux/config.h>
+
+   /* Dallas DS1302 clock/calendar register numbers. */
+#  define RTC_SECONDS      0
+#  define RTC_MINUTES      1
+#  define RTC_HOURS        2
+#  define RTC_DAY_OF_MONTH 3
+#  define RTC_MONTH        4
+#  define RTC_WEEKDAY      5
+#  define RTC_YEAR         6
+#  define RTC_CONTROL      7
+
+   /* Bits in CONTROL register. */
+#  define RTC_CONTROL_WRITEPROTECT 	0x80
+#  define RTC_TRICKLECHARGER 		8
+  
+  /* Bits in TRICKLECHARGER register TCS TCS TCS TCS DS DS RS RS. */
+#  define RTC_TCR_PATTERN 	0xA0	/* 1010xxxx */
+#  define RTC_TCR_1DIOD 	0x04	/* xxxx01xx */
+#  define RTC_TCR_2DIOD 	0x08	/* xxxx10xx */
+#  define RTC_TCR_DISABLED 	0x00	/* xxxxxx00 Disabled */
+#  define RTC_TCR_2KOHM 	0x01	/* xxxxxx01 2KOhm */
+#  define RTC_TCR_4KOHM 	0x02	/* xxxxxx10 4kOhm */
+#  define RTC_TCR_8KOHM 	0x03	/* xxxxxx11 8kOhm */
+
+#ifdef CONFIG_M32700UT_DS1302
+extern unsigned char ds1302_readreg(int reg);
+extern void ds1302_writereg(int reg, unsigned char val);
+extern int ds1302_init(void);
+#  define CMOS_READ(x) ds1302_readreg(x)
+#  define CMOS_WRITE(val,reg) ds1302_writereg(reg,val)
+#  define RTC_INIT() ds1302_init()
+#else
+  /* No RTC configured so we shouldn't try to access any. */
+#  define CMOS_READ(x) 42
+#  define CMOS_WRITE(x,y)
+#  define RTC_INIT() (-1)
+#endif
+
+/*
+ * The struct used to pass data via the following ioctl. Similar to the
+ * struct tm in <time.h>, but it needs to be here so that the kernel 
+ * source is self contained, allowing cross-compiles, etc. etc.
+ */
+struct rtc_time {
+	int tm_sec;
+	int tm_min;
+	int tm_hour;
+	int tm_mday;
+	int tm_mon;
+	int tm_year;
+	int tm_wday;
+	int tm_yday;
+	int tm_isdst;
+};
+
+/* ioctl() calls that are permitted to the /dev/rtc interface. */
+#define RTC_MAGIC 'p'
+#define RTC_RD_TIME		_IOR(RTC_MAGIC, 0x09, struct rtc_time)	/* Read RTC time. */
+#define RTC_SET_TIME		_IOW(RTC_MAGIC, 0x0a, struct rtc_time)	/* Set RTC time. */
+#define RTC_SET_CHARGE  	_IOW(RTC_MAGIC, 0x0b, int) 		
+#define RTC_MAX_IOCTL 0x0b
+
+#endif /* __RTC_H__ */
diff -ruN linux-2.6.7.org/include/asm-m32r/scatterlist.h linux-2.6.7/include/asm-m32r/scatterlist.h
--- linux-2.6.7.org/include/asm-m32r/scatterlist.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/scatterlist.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,18 @@
+#ifndef _ASM_M32R_SCATTERLIST_H
+#define _ASM_M32R_SCATTERLIST_H
+
+/* $Id$ */
+
+struct scatterlist {
+    char *  address;    /* Location data is to be transferred to, NULL for
+                         * highmem page */
+    struct page * page; /* Location for highmem page, if any */
+    unsigned int offset;/* for highmem, page offset */
+	    
+    dma_addr_t dma_address;
+    unsigned int length;
+};
+
+#define ISA_DMA_THRESHOLD (0x1fffffff)
+
+#endif /* _ASM_M32R_SCATTERLIST_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/sections.h linux-2.6.7/include/asm-m32r/sections.h
--- linux-2.6.7.org/include/asm-m32r/sections.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/sections.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,8 @@
+#ifndef _M32R_SECTIONS_H
+#define _M32R_SECTIONS_H
+
+/* nothing to see, move along */
+#include <asm-generic/sections.h>
+
+#endif	/* _M32R_SECTIONS_H */
+
diff -ruN linux-2.6.7.org/include/asm-m32r/segment.h linux-2.6.7/include/asm-m32r/segment.h
--- linux-2.6.7.org/include/asm-m32r/segment.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/segment.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,14 @@
+#ifndef _ASM_M32R_SEGMENT_H
+#define _ASM_M32R_SEGMENT_H
+
+/* $Id$ */
+
+/* orig : i386 (2.4.18) */
+
+#define __KERNEL_CS	0x10
+#define __KERNEL_DS	0x18
+
+#define __USER_CS	0x23
+#define __USER_DS	0x2B
+
+#endif  /* _ASM_M32R_SEGMENT_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/semaphore.h linux-2.6.7/include/asm-m32r/semaphore.h
--- linux-2.6.7.org/include/asm-m32r/semaphore.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/semaphore.h	2004-07-15 13:43:17.000000000 +0900
@@ -0,0 +1,266 @@
+#ifndef _ASM_M32R_SEMAPHORE_H
+#define _ASM_M32R_SEMAPHORE_H
+
+/* $Id$ */
+
+#include <linux/linkage.h>
+
+#ifdef __KERNEL__
+
+/*
+ * SMP- and interrupt-safe semaphores..
+ *
+ * (C) Copyright 1996 Linus Torvalds
+ *
+ * Modified 1996-12-23 by Dave Grothe <dave@gcom.com> to fix bugs in
+ *                     the original code and to make semaphore waits
+ *                     interruptible so that processes waiting on
+ *                     semaphores can be killed.
+ * Modified 1999-02-14 by Andrea Arcangeli, split the sched.c helper
+ *		       functions in asm/sempahore-helper.h while fixing a
+ *		       potential and subtle race discovered by Ulrich Schmid
+ *		       in down_interruptible(). Since I started to play here I
+ *		       also implemented the `trylock' semaphore operation.
+ *          1999-07-02 Artur Skawina <skawina@geocities.com>
+ *                     Optimized "0(ecx)" -> "(ecx)" (the assembler does not
+ *                     do this). Changed calling sequences from push/jmp to
+ *                     traditional call/ret.
+ * Modified 2001-01-01 Andreas Franck <afranck@gmx.de>
+ *		       Some hacks to ensure compatibility with recent
+ *		       GCC snapshots, to avoid stack corruption when compiling
+ *		       with -fomit-frame-pointer. It's not sure if this will
+ *		       be fixed in GCC, as our previous implementation was a
+ *		       bit dubious.
+ *
+ * If you would like to see an analysis of this implementation, please
+ * ftp to gcom.com and download the file
+ * /pub/linux/src/semaphore/semaphore-2.0.24.tar.gz.
+ *
+ */
+
+#include <linux/config.h>
+#include <asm/system.h>
+#include <asm/atomic.h>
+#include <linux/wait.h>
+#include <linux/rwsem.h>
+
+#undef LOAD
+#undef STORE
+#ifdef CONFIG_SMP
+#define LOAD	"lock"
+#define STORE	"unlock"
+#else
+#define LOAD	"ld"
+#define STORE	"st"
+#endif
+
+struct semaphore {
+	atomic_t count;
+	int sleepers;
+	wait_queue_head_t wait;
+#ifdef WAITQUEUE_DEBUG
+	long __magic;
+#endif
+};
+
+#ifdef WAITQUEUE_DEBUG
+# define __SEM_DEBUG_INIT(name) \
+		, (int)&(name).__magic
+#else
+# define __SEM_DEBUG_INIT(name)
+#endif
+
+#define __SEMAPHORE_INITIALIZER(name,count) \
+{ ATOMIC_INIT(count), 0, __WAIT_QUEUE_HEAD_INITIALIZER((name).wait) \
+	__SEM_DEBUG_INIT(name) }
+
+#define __MUTEX_INITIALIZER(name) \
+	__SEMAPHORE_INITIALIZER(name,1)
+
+#define __DECLARE_SEMAPHORE_GENERIC(name,count) \
+	struct semaphore name = __SEMAPHORE_INITIALIZER(name,count)
+
+#define DECLARE_MUTEX(name) __DECLARE_SEMAPHORE_GENERIC(name,1)
+#define DECLARE_MUTEX_LOCKED(name) __DECLARE_SEMAPHORE_GENERIC(name,0)
+
+static __inline__ void sema_init (struct semaphore *sem, int val)
+{
+/*
+ *	*sem = (struct semaphore)__SEMAPHORE_INITIALIZER((*sem),val);
+ *
+ * i'd rather use the more flexible initialization above, but sadly
+ * GCC 2.7.2.3 emits a bogus warning. EGCS doesnt. Oh well.
+ */
+	atomic_set(&sem->count, val);
+	sem->sleepers = 0;
+	init_waitqueue_head(&sem->wait);
+#ifdef WAITQUEUE_DEBUG
+	sem->__magic = (int)&sem->__magic;
+#endif
+}
+
+static __inline__ void init_MUTEX (struct semaphore *sem)
+{
+	sema_init(sem, 1);
+}
+
+static __inline__ void init_MUTEX_LOCKED (struct semaphore *sem)
+{
+	sema_init(sem, 0);
+}
+
+asmlinkage void __down_failed(void /* special register calling convention */);
+asmlinkage int  __down_failed_interruptible(void  /* params in registers */);
+asmlinkage int  __down_failed_trylock(void  /* params in registers */);
+asmlinkage void __up_wakeup(void /* special register calling convention */);
+
+asmlinkage void __down(struct semaphore * sem);
+asmlinkage int  __down_interruptible(struct semaphore * sem);
+asmlinkage int  __down_trylock(struct semaphore * sem);
+asmlinkage void __up(struct semaphore * sem);
+
+/*
+ * This is ugly, but we want the default case to fall through.
+ * "__down_failed" is a special asm handler that calls the C
+ * routine that actually waits. See arch/i386/kernel/semaphore.c
+ */
+static __inline__ void down(struct semaphore * sem)
+{
+	unsigned long flags;
+	int temp;
+
+#ifdef WAITQUEUE_DEBUG
+	CHECK_MAGIC(sem->__magic);
+#endif
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		"# down				\n\t"
+		DCACHE_CLEAR("%0", "r4", "%1")
+		LOAD"	%0, @%1;		\n\t"
+		"addi	%0, #-1;		\n\t"
+		STORE"	%0, @%1;		\n\t"
+		: "=&r" (temp)
+		: "r" (&sem->count)
+		: "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r4"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+	local_irq_restore(flags);
+
+	if (temp < 0)
+		__down(sem);
+}
+
+/*
+ * Interruptible try to acquire a semaphore.  If we obtained
+ * it, return zero.  If we were interrupted, returns -EINTR
+ */
+static __inline__ int down_interruptible(struct semaphore * sem)
+{
+	unsigned long flags;
+	int temp;
+	int result = 0;
+
+#ifdef WAITQUEUE_DEBUG
+	CHECK_MAGIC(sem->__magic);
+#endif
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		"# down_interruptible		\n\t"
+		DCACHE_CLEAR("%0", "r4", "%1")
+		LOAD"	%0, @%1;		\n\t"
+		"addi	%0, #-1;		\n\t"
+		STORE"	%0, @%1;		\n\t"
+		: "=&r" (temp)
+		: "r" (&sem->count)
+		: "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r4"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+	local_irq_restore(flags);
+
+	if (temp < 0)
+		result = __down_interruptible(sem);
+
+	return result;
+}
+
+/*
+ * Non-blockingly attempt to down() a semaphore.
+ * Returns zero if we acquired it
+ */
+static __inline__ int down_trylock(struct semaphore * sem)
+{
+	unsigned long flags;
+	int temp;
+	int result = 0;
+
+#ifdef WAITQUEUE_DEBUG
+	CHECK_MAGIC(sem->__magic);
+#endif
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		"# down_trylock			\n\t"
+		DCACHE_CLEAR("%0", "r4", "%1")
+		LOAD"	%0, @%1;		\n\t"
+		"addi	%0, #-1;		\n\t"
+		STORE"	%0, @%1;		\n\t"
+		: "=&r" (temp)
+		: "r" (&sem->count)
+		: "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r4"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+	local_irq_restore(flags);
+
+	if (temp < 0)
+		result = __down_trylock(sem);
+
+	return result;
+}
+
+/*
+ * Note! This is subtle. We jump to wake people up only if
+ * the semaphore was negative (== somebody was waiting on it).
+ * The default case (no contention) will result in NO
+ * jumps for both down() and up().
+ */
+static __inline__ void up(struct semaphore * sem)
+{
+	unsigned long flags;
+	int temp;
+
+#ifdef WAITQUEUE_DEBUG
+	CHECK_MAGIC(sem->__magic);
+#endif
+
+	local_irq_save(flags);
+	__asm__ __volatile__ (
+		"# up				\n\t"
+		DCACHE_CLEAR("%0", "r4", "%1")
+		LOAD"	%0, @%1;		\n\t"
+		"addi	%0, #1;			\n\t"
+		STORE"	%0, @%1;		\n\t"
+		: "=&r" (temp)
+		: "r" (&sem->count)
+		: "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r4"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+	local_irq_restore(flags);
+
+	if (temp <= 0)
+		__up(sem);
+}
+
+#endif  /* __KERNEL__ */
+
+#endif  /* _ASM_M32R_SEMAPHORE_H */
+
diff -ruN linux-2.6.7.org/include/asm-m32r/sembuf.h linux-2.6.7/include/asm-m32r/sembuf.h
--- linux-2.6.7.org/include/asm-m32r/sembuf.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/sembuf.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,29 @@
+#ifndef _ASM_M32R_SEMBUF_H
+#define _ASM_M32R_SEMBUF_H
+
+/* $Id$ */
+
+/* orig : i386 2.4.18 */
+
+/* 
+ * The semid64_ds structure for m32r architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 64-bit time_t to solve y2038 problem
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct semid64_ds {
+	struct ipc64_perm sem_perm;		/* permissions .. see ipc.h */
+	__kernel_time_t	sem_otime;		/* last semop time */
+	unsigned long	__unused1;
+	__kernel_time_t	sem_ctime;		/* last change time */
+	unsigned long	__unused2;
+	unsigned long	sem_nsems;		/* no. of semaphores in array */
+	unsigned long	__unused3;
+	unsigned long	__unused4;
+};
+
+#endif /* _ASM_M32R_SEMBUF_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/serial.h linux-2.6.7/include/asm-m32r/serial.h
--- linux-2.6.7.org/include/asm-m32r/serial.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/serial.h	2003-12-15 15:50:38.000000000 +0900
@@ -0,0 +1,151 @@
+#ifndef _ASM_M32R_SERIAL_H
+#define _ASM_M32R_SERIAL_H
+
+/* $Id$ */
+
+/* orig : i386 2.4.18 */
+
+/*
+ * include/asm-m32r/serial.h
+ */
+
+#include <linux/config.h>
+#include <asm/m32r.h>
+
+/*
+ * This assumes you have a 1.8432 MHz clock for your UART.
+ *
+ * It'd be nice if someone built a serial card with a 24.576 MHz
+ * clock, since the 16550A is capable of handling a top speed of 1.5
+ * megabits/second; but this requires the faster clock.
+ */
+#define BASE_BAUD ( 1843200 / 16 )
+
+/* Standard COM flags (except for COM4, because of the 8514 problem) */
+#ifdef CONFIG_SERIAL_DETECT_IRQ
+#define STD_COM_FLAGS (ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST | ASYNC_AUTO_IRQ)
+#define STD_COM4_FLAGS (ASYNC_BOOT_AUTOCONF | ASYNC_AUTO_IRQ)
+#else
+#define STD_COM_FLAGS (ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST)
+#define STD_COM4_FLAGS ASYNC_BOOT_AUTOCONF
+#endif
+
+#ifdef CONFIG_SERIAL_MANY_PORTS
+#define FOURPORT_FLAGS ASYNC_FOURPORT
+#define ACCENT_FLAGS 0
+#define BOCA_FLAGS 0
+#define HUB6_FLAGS 0
+#define RS_TABLE_SIZE	64
+#else
+#define RS_TABLE_SIZE
+#endif
+
+#define MCA_COM_FLAGS	(STD_COM_FLAGS|ASYNC_BOOT_ONLYMCA)
+
+/*
+ * The following define the access methods for the HUB6 card. All
+ * access is through two ports for all 24 possible chips. The card is
+ * selected through the high 2 bits, the port on that card with the
+ * "middle" 3 bits, and the register on that port with the bottom
+ * 3 bits.
+ *
+ * While the access port and interrupt is configurable, the default
+ * port locations are 0x302 for the port control register, and 0x303
+ * for the data read/write register. Normally, the interrupt is at irq3
+ * but can be anything from 3 to 7 inclusive. Note that using 3 will
+ * require disabling com2.
+ */
+
+#define C_P(card,port) (((card)<<6|(port)<<3) + 1)
+
+#define STD_SERIAL_PORT_DEFNS			\
+	/* UART CLK   PORT IRQ     FLAGS        */			\
+	{ 0, BASE_BAUD, 0x3F8, 4, STD_COM_FLAGS },	/* ttyS0 */	\
+	{ 0, BASE_BAUD, 0x2F8, 3, STD_COM_FLAGS },	/* ttyS1 */	\
+	{ 0, BASE_BAUD, 0x3E8, 4, STD_COM_FLAGS },	/* ttyS2 */	\
+	{ 0, BASE_BAUD, 0x2E8, 3, STD_COM4_FLAGS },	/* ttyS3 */
+
+
+#ifdef CONFIG_SERIAL_MANY_PORTS
+#define EXTRA_SERIAL_PORT_DEFNS			\
+	{ 0, BASE_BAUD, 0x1A0, 9, FOURPORT_FLAGS }, 	/* ttyS4 */	\
+	{ 0, BASE_BAUD, 0x1A8, 9, FOURPORT_FLAGS },	/* ttyS5 */	\
+	{ 0, BASE_BAUD, 0x1B0, 9, FOURPORT_FLAGS },	/* ttyS6 */	\
+	{ 0, BASE_BAUD, 0x1B8, 9, FOURPORT_FLAGS },	/* ttyS7 */	\
+	{ 0, BASE_BAUD, 0x2A0, 5, FOURPORT_FLAGS },	/* ttyS8 */	\
+	{ 0, BASE_BAUD, 0x2A8, 5, FOURPORT_FLAGS },	/* ttyS9 */	\
+	{ 0, BASE_BAUD, 0x2B0, 5, FOURPORT_FLAGS },	/* ttyS10 */	\
+	{ 0, BASE_BAUD, 0x2B8, 5, FOURPORT_FLAGS },	/* ttyS11 */	\
+	{ 0, BASE_BAUD, 0x330, 4, ACCENT_FLAGS },	/* ttyS12 */	\
+	{ 0, BASE_BAUD, 0x338, 4, ACCENT_FLAGS },	/* ttyS13 */	\
+	{ 0, BASE_BAUD, 0x000, 0, 0 },	/* ttyS14 (spare) */		\
+	{ 0, BASE_BAUD, 0x000, 0, 0 },	/* ttyS15 (spare) */		\
+	{ 0, BASE_BAUD, 0x100, 12, BOCA_FLAGS },	/* ttyS16 */	\
+	{ 0, BASE_BAUD, 0x108, 12, BOCA_FLAGS },	/* ttyS17 */	\
+	{ 0, BASE_BAUD, 0x110, 12, BOCA_FLAGS },	/* ttyS18 */	\
+	{ 0, BASE_BAUD, 0x118, 12, BOCA_FLAGS },	/* ttyS19 */	\
+	{ 0, BASE_BAUD, 0x120, 12, BOCA_FLAGS },	/* ttyS20 */	\
+	{ 0, BASE_BAUD, 0x128, 12, BOCA_FLAGS },	/* ttyS21 */	\
+	{ 0, BASE_BAUD, 0x130, 12, BOCA_FLAGS },	/* ttyS22 */	\
+	{ 0, BASE_BAUD, 0x138, 12, BOCA_FLAGS },	/* ttyS23 */	\
+	{ 0, BASE_BAUD, 0x140, 12, BOCA_FLAGS },	/* ttyS24 */	\
+	{ 0, BASE_BAUD, 0x148, 12, BOCA_FLAGS },	/* ttyS25 */	\
+	{ 0, BASE_BAUD, 0x150, 12, BOCA_FLAGS },	/* ttyS26 */	\
+	{ 0, BASE_BAUD, 0x158, 12, BOCA_FLAGS },	/* ttyS27 */	\
+	{ 0, BASE_BAUD, 0x160, 12, BOCA_FLAGS },	/* ttyS28 */	\
+	{ 0, BASE_BAUD, 0x168, 12, BOCA_FLAGS },	/* ttyS29 */	\
+	{ 0, BASE_BAUD, 0x170, 12, BOCA_FLAGS },	/* ttyS30 */	\
+	{ 0, BASE_BAUD, 0x178, 12, BOCA_FLAGS },	/* ttyS31 */
+#else
+#define EXTRA_SERIAL_PORT_DEFNS
+#endif
+
+/* You can have up to four HUB6's in the system, but I've only
+ * included two cards here for a total of twelve ports.
+ */
+#if (defined(CONFIG_HUB6) && defined(CONFIG_SERIAL_MANY_PORTS))
+#define HUB6_SERIAL_PORT_DFNS		\
+	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(0,0) },  /* ttyS32 */	\
+	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(0,1) },  /* ttyS33 */	\
+	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(0,2) },  /* ttyS34 */	\
+	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(0,3) },  /* ttyS35 */	\
+	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(0,4) },  /* ttyS36 */	\
+	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(0,5) },  /* ttyS37 */	\
+	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(1,0) },  /* ttyS38 */	\
+	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(1,1) },  /* ttyS39 */	\
+	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(1,2) },  /* ttyS40 */	\
+	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(1,3) },  /* ttyS41 */	\
+	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(1,4) },  /* ttyS42 */	\
+	{ 0, BASE_BAUD, 0x302, 3, HUB6_FLAGS, C_P(1,5) },  /* ttyS43 */
+#else
+#define HUB6_SERIAL_PORT_DFNS
+#endif
+
+#ifdef CONFIG_MCA
+#define MCA_SERIAL_PORT_DFNS			\
+	{ 0, BASE_BAUD, 0x3220, 3, MCA_COM_FLAGS },	\
+	{ 0, BASE_BAUD, 0x3228, 3, MCA_COM_FLAGS },	\
+	{ 0, BASE_BAUD, 0x4220, 3, MCA_COM_FLAGS },	\
+	{ 0, BASE_BAUD, 0x4228, 3, MCA_COM_FLAGS },	\
+	{ 0, BASE_BAUD, 0x5220, 3, MCA_COM_FLAGS },	\
+	{ 0, BASE_BAUD, 0x5228, 3, MCA_COM_FLAGS },
+#else
+#define MCA_SERIAL_PORT_DFNS
+#endif
+
+#ifndef CONFIG_PLAT_USRV
+#define SERIAL_PORT_DFNS		\
+	STD_SERIAL_PORT_DEFNS		\
+	EXTRA_SERIAL_PORT_DEFNS		\
+	HUB6_SERIAL_PORT_DFNS		\
+	MCA_SERIAL_PORT_DFNS
+
+#else	/* CONFIG_PLAT_USRV */
+
+#define SERIAL_PORT_DFNS		\
+	/* UART CLK   PORT IRQ     FLAGS        */			\
+	{ 0, BASE_BAUD, 0x3F8, PLD_IRQ_UART0, STD_COM_FLAGS },	/* ttyS0 */	\
+	{ 0, BASE_BAUD, 0x2F8, PLD_IRQ_UART1, STD_COM_FLAGS },	/* ttyS1 */
+#endif	/* CONFIG_PLAT_USRV */
+
+#endif  /* _ASM_M32R_SERIAL_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/setup.h linux-2.6.7/include/asm-m32r/setup.h
--- linux-2.6.7.org/include/asm-m32r/setup.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/setup.h	2003-09-09 10:28:57.000000000 +0900
@@ -0,0 +1,33 @@
+/*
+ * This is set up by the setup-routine at boot-time
+ */
+#define PARAM			((unsigned char *)empty_zero_page)
+
+#define MOUNT_ROOT_RDONLY	(*(unsigned long *) (PARAM+0x000))
+#define RAMDISK_FLAGS		(*(unsigned long *) (PARAM+0x004))
+#define ORIG_ROOT_DEV		(*(unsigned long *) (PARAM+0x008))
+#define LOADER_TYPE		(*(unsigned long *) (PARAM+0x00c))
+#define INITRD_START		(*(unsigned long *) (PARAM+0x010))
+#define INITRD_SIZE		(*(unsigned long *) (PARAM+0x014))
+
+#define M32R_CPUCLK		(*(unsigned long *) (PARAM+0x018))
+#define M32R_BUSCLK		(*(unsigned long *) (PARAM+0x01c))
+#define M32R_TIMER_DIVIDE	(*(unsigned long *) (PARAM+0x020))
+
+#define COMMAND_LINE		((char *) (PARAM+0x100))
+
+#define SCREEN_INFO		(*(struct screen_info *) (PARAM+0x200))
+
+#define COMMAND_LINE_SIZE	(256)
+
+#define RAMDISK_IMAGE_START_MASK	(0x07FF)
+#define RAMDISK_PROMPT_FLAG		(0x8000)
+#define RAMDISK_LOAD_FLAG		(0x4000)
+
+#define PFN_UP(x)	(((x) + PAGE_SIZE-1) >> PAGE_SHIFT)
+#define PFN_DOWN(x)	((x) >> PAGE_SHIFT)
+#define PFN_PHYS(x)	((x) << PAGE_SHIFT)
+
+extern unsigned long memory_start;
+extern unsigned long memory_end;
+
diff -ruN linux-2.6.7.org/include/asm-m32r/shmbuf.h linux-2.6.7/include/asm-m32r/shmbuf.h
--- linux-2.6.7.org/include/asm-m32r/shmbuf.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/shmbuf.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,46 @@
+#ifndef _ASM_M32R_SHMBUF_H
+#define _ASM_M32R_SHMBUF_H
+
+/* $Id$ */
+
+/* orig : i386 2.4.18 */
+
+/* 
+ * The shmid64_ds structure for M32R architecture.
+ * Note extra padding because this structure is passed back and forth
+ * between kernel and user space.
+ *
+ * Pad space is left for:
+ * - 64-bit time_t to solve y2038 problem
+ * - 2 miscellaneous 32-bit values
+ */
+
+struct shmid64_ds {
+	struct ipc64_perm	shm_perm;	/* operation perms */
+	size_t			shm_segsz;	/* size of segment (bytes) */
+	__kernel_time_t		shm_atime;	/* last attach time */
+	unsigned long		__unused1;
+	__kernel_time_t		shm_dtime;	/* last detach time */
+	unsigned long		__unused2;
+	__kernel_time_t		shm_ctime;	/* last change time */
+	unsigned long		__unused3;
+	__kernel_pid_t		shm_cpid;	/* pid of creator */
+	__kernel_pid_t		shm_lpid;	/* pid of last operator */
+	unsigned long		shm_nattch;	/* no. of current attaches */
+	unsigned long		__unused4;
+	unsigned long		__unused5;
+};
+
+struct shminfo64 {
+	unsigned long	shmmax;
+	unsigned long	shmmin;
+	unsigned long	shmmni;
+	unsigned long	shmseg;
+	unsigned long	shmall;
+	unsigned long	__unused1;
+	unsigned long	__unused2;
+	unsigned long	__unused3;
+	unsigned long	__unused4;
+};
+
+#endif /* _ASM_M32R_SHMBUF_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/shmparam.h linux-2.6.7/include/asm-m32r/shmparam.h
--- linux-2.6.7.org/include/asm-m32r/shmparam.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/shmparam.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,8 @@
+#ifndef _ASM_M32R_SHMPARAM_H
+#define _ASM_M32R_SHMPARAM_H
+
+/* $Id$ */
+
+#define	SHMLBA PAGE_SIZE		 /* attach addr a multiple of this */
+
+#endif /* _ASM_M32R_SHMPARAM_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/sigcontext.h linux-2.6.7/include/asm-m32r/sigcontext.h
--- linux-2.6.7.org/include/asm-m32r/sigcontext.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/sigcontext.h	2004-03-16 19:34:57.000000000 +0900
@@ -0,0 +1,50 @@
+#ifndef _ASM_M32R_SIGCONTEXT_H
+#define _ASM_M32R_SIGCONTEXT_H
+
+/* $Id$ */
+
+#include <linux/config.h>
+
+struct sigcontext {
+	/* CPU registers */
+	/* Saved main processor registers. */ 
+	unsigned long sc_r4;
+	unsigned long sc_r5;
+	unsigned long sc_r6;
+	struct pt_regs *sc_pt_regs;
+	unsigned long sc_r0;
+	unsigned long sc_r1;
+	unsigned long sc_r2;
+	unsigned long sc_r3;
+	unsigned long sc_r7;
+	unsigned long sc_r8;
+	unsigned long sc_r9;
+	unsigned long sc_r10;
+	unsigned long sc_r11;
+	unsigned long sc_r12;
+
+	/* Saved main processor status and miscellaneous context registers. */ 
+#if defined(CONFIG_ISA_M32R2) && defined(CONFIG_ISA_DSP_LEVEL2)
+	unsigned long sc_acc0h;
+	unsigned long sc_acc0l;
+	unsigned long sc_acc1h;
+	unsigned long sc_acc1l;
+#elif defined(CONFIG_ISA_M32R2) || defined(CONFIG_ISA_M32R)
+	unsigned long sc_acch;
+	unsigned long sc_accl;
+#else
+#error unknown isa configuration
+#endif
+	unsigned long sc_psw;
+	unsigned long sc_bpc;		/* saved PC for TRAP syscalls */
+	unsigned long sc_bbpsw;
+	unsigned long sc_bbpc;
+	unsigned long sc_spu;		/* saved user stack */
+	unsigned long sc_fp;
+	unsigned long sc_lr;		/* saved PC for JL syscalls */
+	unsigned long sc_spi;		/* saved kernel stack */
+	
+	unsigned long	oldmask;
+};
+
+#endif  /* _ASM_M32R_SIGCONTEXT_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/siginfo.h linux-2.6.7/include/asm-m32r/siginfo.h
--- linux-2.6.7.org/include/asm-m32r/siginfo.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/siginfo.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,8 @@
+#ifndef _M32R_SIGINFO_H
+#define _M32R_SIGINFO_H
+
+/* $Id$ */
+
+#include <asm-generic/siginfo.h>
+
+#endif /* _M32R_SIGINFO_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/signal.h linux-2.6.7/include/asm-m32r/signal.h
--- linux-2.6.7.org/include/asm-m32r/signal.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/signal.h	2003-10-01 11:48:18.000000000 +0900
@@ -0,0 +1,194 @@
+#ifndef _ASM_M32R_SIGNAL_H
+#define _ASM_M32R_SIGNAL_H
+
+/* $Id$ */
+
+/* orig : i386 2.4.18 */
+
+#include <linux/linkage.h>
+#include <linux/types.h>
+
+/* Avoid too many header ordering problems.  */
+struct siginfo;
+
+#ifdef __KERNEL__
+/* Most things should be clean enough to redefine this at will, if care
+   is taken to make libc match.  */
+
+#define _NSIG		64
+#define _NSIG_BPW	32
+#define _NSIG_WORDS	(_NSIG / _NSIG_BPW)
+
+typedef unsigned long old_sigset_t;		/* at least 32 bits */
+
+typedef struct {
+	unsigned long sig[_NSIG_WORDS];
+} sigset_t;
+
+#else
+/* Here we must cater to libcs that poke about in kernel headers.  */
+
+#define NSIG		32
+typedef unsigned long sigset_t;
+
+#endif /* __KERNEL__ */
+
+#define SIGHUP		 1
+#define SIGINT		 2
+#define SIGQUIT		 3
+#define SIGILL		 4
+#define SIGTRAP		 5
+#define SIGABRT		 6
+#define SIGIOT		 6
+#define SIGBUS		 7
+#define SIGFPE		 8
+#define SIGKILL		 9
+#define SIGUSR1		10
+#define SIGSEGV		11
+#define SIGUSR2		12
+#define SIGPIPE		13
+#define SIGALRM		14
+#define SIGTERM		15
+#define SIGSTKFLT	16
+#define SIGCHLD		17
+#define SIGCONT		18
+#define SIGSTOP		19
+#define SIGTSTP		20
+#define SIGTTIN		21
+#define SIGTTOU		22
+#define SIGURG		23
+#define SIGXCPU		24
+#define SIGXFSZ		25
+#define SIGVTALRM	26
+#define SIGPROF		27
+#define SIGWINCH	28
+#define SIGIO		29
+#define SIGPOLL		SIGIO
+/*
+#define SIGLOST		29
+*/
+#define SIGPWR		30
+#define SIGSYS		31
+#define	SIGUNUSED	31
+
+/* These should not be considered constants from userland.  */
+#define SIGRTMIN	32
+#define SIGRTMAX	_NSIG
+
+/*
+ * SA_FLAGS values:
+ *
+ * SA_ONSTACK indicates that a registered stack_t will be used.
+ * SA_INTERRUPT is a no-op, but left due to historical reasons. Use the
+ * SA_RESTART flag to get restarting signals (which were the default long ago)
+ * SA_NOCLDSTOP flag to turn off SIGCHLD when children stop.
+ * SA_RESETHAND clears the handler when the signal is delivered.
+ * SA_NOCLDWAIT flag on SIGCHLD to inhibit zombies.
+ * SA_NODEFER prevents the current signal from being masked in the handler.
+ *
+ * SA_ONESHOT and SA_NOMASK are the historical Linux names for the Single
+ * Unix names RESETHAND and NODEFER respectively.
+ */
+#define SA_NOCLDSTOP	0x00000001u
+#define SA_NOCLDWAIT	0x00000002u
+#define SA_SIGINFO	0x00000004u
+#define SA_ONSTACK	0x08000000u
+#define SA_RESTART	0x10000000u
+#define SA_NODEFER	0x40000000u
+#define SA_RESETHAND	0x80000000u
+
+#define SA_NOMASK	SA_NODEFER
+#define SA_ONESHOT	SA_RESETHAND
+#define SA_INTERRUPT	0x20000000 /* dummy -- ignored */
+
+#define SA_RESTORER	0x04000000
+
+/* 
+ * sigaltstack controls
+ */
+#define SS_ONSTACK	1
+#define SS_DISABLE	2
+
+#define MINSIGSTKSZ	2048
+#define SIGSTKSZ	8192
+
+#ifdef __KERNEL__
+
+/*
+ * These values of sa_flags are used only by the kernel as part of the
+ * irq handling routines.
+ *
+ * SA_INTERRUPT is also used by the irq handling routines.
+ * SA_SHIRQ is for shared interrupt support on PCI and EISA.
+ */
+#define SA_PROBE		SA_ONESHOT
+#define SA_SAMPLE_RANDOM	SA_RESTART
+#define SA_SHIRQ		0x04000000
+#endif
+
+#define SIG_BLOCK          0	/* for blocking signals */
+#define SIG_UNBLOCK        1	/* for unblocking signals */
+#define SIG_SETMASK        2	/* for setting the signal mask */
+
+/* Type of a signal handler.  */
+typedef void (*__sighandler_t)(int);
+
+#define SIG_DFL	((__sighandler_t)0)	/* default signal handling */
+#define SIG_IGN	((__sighandler_t)1)	/* ignore signal */
+#define SIG_ERR	((__sighandler_t)-1)	/* error return from signal */
+
+#ifdef __KERNEL__
+struct old_sigaction {
+	__sighandler_t sa_handler;
+	old_sigset_t sa_mask;
+	unsigned long sa_flags;
+	void (*sa_restorer)(void);
+};
+
+struct sigaction {
+	__sighandler_t sa_handler;
+	unsigned long sa_flags;
+	void (*sa_restorer)(void);
+	sigset_t sa_mask;		/* mask last for extensibility */
+};
+
+struct k_sigaction {
+	struct sigaction sa;
+};
+#else
+/* Here we must cater to libcs that poke about in kernel headers.  */
+
+struct sigaction {
+	union {
+	  __sighandler_t _sa_handler;
+	  void (*_sa_sigaction)(int, struct siginfo *, void *);
+	} _u;
+	sigset_t sa_mask;
+	unsigned long sa_flags;
+	void (*sa_restorer)(void);
+};
+
+#define sa_handler	_u._sa_handler
+#define sa_sigaction	_u._sa_sigaction
+
+#endif /* __KERNEL__ */
+
+typedef struct sigaltstack {
+	void *ss_sp;
+	int ss_flags;
+	size_t ss_size;
+} stack_t;
+
+#ifdef __KERNEL__
+#include <asm/sigcontext.h>
+
+#undef __HAVE_ARCH_SIG_BITOPS
+
+struct pt_regs;
+extern int FASTCALL(do_signal(struct pt_regs *regs, sigset_t *oldset));
+
+#define ptrace_signal_deliver(regs, cookie)	do { } while (0)
+
+#endif /* __KERNEL__ */
+
+#endif  /* _ASM_M32R_SIGNAL_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/smp.h linux-2.6.7/include/asm-m32r/smp.h
--- linux-2.6.7.org/include/asm-m32r/smp.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/smp.h	2004-04-05 11:34:33.000000000 +0900
@@ -0,0 +1,78 @@
+#ifndef _ASM_M32R_SMP_H
+#define _ASM_M32R_SMP_H
+
+/* $Id$ */
+
+#include <linux/config.h>
+
+#ifdef CONFIG_SMP
+#ifndef __ASSEMBLY__
+
+#include <linux/cpumask.h>
+#include <linux/spinlock.h>
+#include <linux/threads.h>
+#include <asm/m32r.h>
+
+extern cpumask_t phys_cpu_present_map;
+
+/*
+ * Some lowlevel functions might want to know about
+ * the real CPU ID <-> CPU # mapping.
+ */
+extern volatile int physid_2_cpu[NR_CPUS];
+extern volatile int cpu_2_physid[NR_CPUS];
+#define physid_to_cpu(physid)	physid_2_cpu[physid]
+#define cpu_to_physid(cpu_id)	cpu_2_physid[cpu_id]
+
+#define smp_processor_id()	(current_thread_info()->cpu)
+
+extern cpumask_t cpu_callout_map;
+#define cpu_possible_map cpu_callout_map
+
+static __inline__ int hard_smp_processor_id(void)
+{
+	return (int)*(volatile long *)M32R_CPUID_PORTL;
+}
+
+static __inline__ int cpu_logical_map(int cpu)
+{
+	return cpu;
+}
+
+static __inline__ int cpu_number_map(int cpu)
+{
+	return cpu;
+}
+
+static __inline__ unsigned int num_booting_cpus(void)
+{
+	return cpus_weight(cpu_callout_map);
+}
+
+extern void smp_send_timer(void);
+extern void calibrate_delay(void);
+extern unsigned long send_IPI_mask_phys(unsigned long, int, int);
+
+#endif	/* not __ASSEMBLY__ */
+
+#define NO_PROC_ID (0xff)	/* No processor magic marker */
+
+#define PROC_CHANGE_PENALTY	(15)	/* Schedule penalty */
+
+/* 
+ * M32R-mp IPI
+ */
+#define RESCHEDULE_IPI		(M32R_IRQ_IPI0-M32R_IRQ_IPI0)
+#define INVALIDATE_TLB_IPI	(M32R_IRQ_IPI1-M32R_IRQ_IPI0)
+#define CALL_FUNCTION_IPI	(M32R_IRQ_IPI2-M32R_IRQ_IPI0)
+#define LOCAL_TIMER_IPI		(M32R_IRQ_IPI3-M32R_IRQ_IPI0)
+#define INVALIDATE_CACHE_IPI	(M32R_IRQ_IPI4-M32R_IRQ_IPI0)
+#define CPU_BOOT_IPI		(M32R_IRQ_IPI5-M32R_IRQ_IPI0)
+
+#define IPI_SHIFT	(0)
+#define NR_IPIS		(8)
+
+#endif	/* CONFIG_SMP */
+
+#endif	/* _ASM_M32R_SMP_H */
+
diff -ruN linux-2.6.7.org/include/asm-m32r/socket.h linux-2.6.7/include/asm-m32r/socket.h
--- linux-2.6.7.org/include/asm-m32r/socket.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/socket.h	2004-03-25 13:29:22.000000000 +0900
@@ -0,0 +1,70 @@
+#ifndef _ASM_M32R_SOCKET_H
+#define _ASM_M32R_SOCKET_H
+
+/* $Id$ */
+
+/* orig : i386 2.4.18 */
+
+#include <asm/sockios.h>
+
+/* For setsockoptions(2) */
+#define SOL_SOCKET	1
+
+#define SO_DEBUG	1
+#define SO_REUSEADDR	2
+#define SO_TYPE		3
+#define SO_ERROR	4
+#define SO_DONTROUTE	5
+#define SO_BROADCAST	6
+#define SO_SNDBUF	7
+#define SO_RCVBUF	8
+#define SO_KEEPALIVE	9
+#define SO_OOBINLINE	10
+#define SO_NO_CHECK	11
+#define SO_PRIORITY	12
+#define SO_LINGER	13
+#define SO_BSDCOMPAT	14
+/* To add :#define SO_REUSEPORT 15 */
+#define SO_PASSCRED	16
+#define SO_PEERCRED	17
+#define SO_RCVLOWAT	18
+#define SO_SNDLOWAT	19
+#define SO_RCVTIMEO	20
+#define SO_SNDTIMEO	21
+
+/* Security levels - as per NRL IPv6 - don't actually do anything */
+#define SO_SECURITY_AUTHENTICATION		22
+#define SO_SECURITY_ENCRYPTION_TRANSPORT	23
+#define SO_SECURITY_ENCRYPTION_NETWORK		24
+
+#define SO_BINDTODEVICE	25
+
+/* Socket filtering */
+#define SO_ATTACH_FILTER        26
+#define SO_DETACH_FILTER        27
+
+#define SO_PEERNAME		28
+#define SO_TIMESTAMP		29
+#define SCM_TIMESTAMP		SO_TIMESTAMP
+
+#define SO_ACCEPTCONN		30
+
+#define SO_PEERSEC		31
+
+/* Nasty libc5 fixup - bletch */
+#if defined(__KERNEL__) || !defined(__GLIBC__) || (__GLIBC__ < 2)
+/* Socket types. */
+#define SOCK_STREAM	1		/* stream (connection) socket	*/
+#define SOCK_DGRAM	2		/* datagram (conn.less) socket	*/
+#define SOCK_RAW	3		/* raw socket			*/
+#define SOCK_RDM	4		/* reliably-delivered message	*/
+#define SOCK_SEQPACKET	5		/* sequential packet socket	*/
+#define SOCK_PACKET	10		/* linux specific way of	*/
+					/* getting packets at the dev	*/
+					/* level.  For writing rarp and	*/
+					/* other similar things on the	*/
+					/* user level.			*/
+#define	SOCK_MAX	(SOCK_PACKET+1)
+#endif
+
+#endif /* _ASM_M32R_SOCKET_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/sockios.h linux-2.6.7/include/asm-m32r/sockios.h
--- linux-2.6.7.org/include/asm-m32r/sockios.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/sockios.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,14 @@
+#ifndef _ASM_M32R_SOCKIOS_H
+#define _ASM_M32R_SOCKIOS_H
+
+/* $Id$ */
+
+/* Socket-level I/O control calls. */
+#define FIOSETOWN 	0x8901
+#define SIOCSPGRP	0x8902
+#define FIOGETOWN	0x8903
+#define SIOCGPGRP	0x8904
+#define SIOCATMARK	0x8905
+#define SIOCGSTAMP	0x8906		/* Get stamp */
+
+#endif  /* _ASM_M32R_SOCKIOS_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/spinlock.h linux-2.6.7/include/asm-m32r/spinlock.h
--- linux-2.6.7.org/include/asm-m32r/spinlock.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/spinlock.h	2004-07-15 13:43:17.000000000 +0900
@@ -0,0 +1,371 @@
+#ifndef _ASM_M32R_SPINLOCK_H
+#define _ASM_M32R_SPINLOCK_H
+
+/* $Id$ */
+
+/*  
+ *  linux/include/asm-m32r/spinlock.h
+ *    orig : i386 2.4.10
+ *  
+ *  M32R version: 
+ *    Copyright (C) 2001, 2002  Hitoshi Yamamoto
+ */
+
+#include <linux/config.h>	/* CONFIG_DEBUG_SPINLOCK, CONFIG_SMP */
+#include <linux/compiler.h>
+#include <asm/atomic.h>
+#include <asm/page.h>
+
+extern int printk(const char * fmt, ...)
+	__attribute__ ((format (printf, 1, 2)));
+
+#define RW_LOCK_BIAS		 0x01000000
+#define RW_LOCK_BIAS_STR	"0x01000000"
+
+/* It seems that people are forgetting to
+ * initialize their spinlocks properly, tsk tsk.
+ * Remember to turn this off in 2.4. -ben
+ */
+#if defined(CONFIG_DEBUG_SPINLOCK)
+#define SPINLOCK_DEBUG	1
+#else
+#define SPINLOCK_DEBUG	0
+#endif
+
+/*
+ * Your basic SMP spinlocks, allowing only a single CPU anywhere
+ */
+
+typedef struct {
+	volatile int lock;
+#if SPINLOCK_DEBUG
+	unsigned magic;
+#endif
+} spinlock_t;
+
+#define SPINLOCK_MAGIC	0xdead4ead
+
+#if SPINLOCK_DEBUG
+#define SPINLOCK_MAGIC_INIT	, SPINLOCK_MAGIC
+#else
+#define SPINLOCK_MAGIC_INIT	/* */
+#endif
+
+#define SPIN_LOCK_UNLOCKED (spinlock_t) { 1 SPINLOCK_MAGIC_INIT }
+
+#define spin_lock_init(x)	do { *(x) = SPIN_LOCK_UNLOCKED; } while(0)
+
+/*
+ * Simple spin lock operations.  There are two variants, one clears IRQ's
+ * on the local processor, one does not.
+ *
+ * We make no fairness assumptions. They have a cost.
+ */
+
+#define spin_is_locked(x)	(*(volatile int *)(&(x)->lock) <= 0)
+#define spin_unlock_wait(x)	do { barrier(); } while(spin_is_locked(x))
+#define _raw_spin_lock_flags(lock, flags) _raw_spin_lock(lock)
+
+/*
+ * This works. Despite all the confusion.
+ */
+
+/*======================================================================*
+ * Try spin lock
+ *======================================================================*
+ * Argument: 
+ *   arg0: lock
+ * Return value: 
+ *   =1: Success
+ *   =0: Failure
+ *======================================================================*/
+static __inline__ int _raw_spin_trylock(spinlock_t *lock)
+{
+	int oldval;
+
+	/* 
+	 * lock->lock :  =1 : unlock
+	 *            : <=0 : lock
+	 * {
+	 *   oldval = lock->lock; <--+ need atomic operation
+	 *   lock->lock = 0;      <--+
+	 * }
+	 */
+	__asm__ __volatile__ (
+		"# spin_trylock			\n\t"
+		"ldi	r4, #0;			\n\t"
+		"mvfc	r5, psw;		\n\t"
+		"clrpsw	#0x40 -> nop;		\n\t"
+		DCACHE_CLEAR("%0", "r6", "%1")
+		"lock	%0, @%1;		\n\t"
+		"unlock	r4, @%1;		\n\t"
+		"mvtc	r5, psw;		\n\t"
+		: "=&r" (oldval)
+		: "r" (&lock->lock)
+		: "memory", "r4", "r5"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r6"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+
+	return (oldval > 0);
+}
+
+static __inline__ void _raw_spin_lock(spinlock_t *lock)
+{
+#if SPINLOCK_DEBUG
+	__label__ here;
+here:
+	if (lock->magic != SPINLOCK_MAGIC) {
+		printk("eip: %p\n", &&here);
+		BUG();
+	}
+#endif
+	/* 
+	 * lock->lock :  =1 : unlock
+	 *            : <=0 : lock
+	 * 
+	 * for ( ; ; ) {
+	 *   lock->lock -= 1;  <-- need atomic operation
+	 *   if (lock->lock == 0) break;
+	 *   for ( ; lock->lock <= 0 ; );
+	 * }
+	 */
+	__asm__ __volatile__ (
+		"# spin_lock			\n\t"
+		".fillinsn			\n"
+		"1:				\n\t"
+		"mvfc	r5, psw;		\n\t"
+		"clrpsw	#0x40 -> nop;		\n\t"
+		DCACHE_CLEAR("r4", "r6", "%0")
+		"lock	r4, @%0;		\n\t"
+		"addi	r4, #-1;		\n\t"
+		"unlock	r4, @%0;		\n\t"
+		"mvtc	r5, psw;		\n\t"
+		"bltz	r4, 2f;			\n\t"
+		LOCK_SECTION_START(".balign 4 \n\t")
+		".fillinsn			\n"
+		"2:				\n\t"
+		"ld	r4, @%0;		\n\t"
+		"bgtz	r4, 1b;			\n\t"
+		"bra	2b;			\n\t"
+		LOCK_SECTION_END
+		: /* no outputs */
+		: "r" (&lock->lock)
+		: "memory", "r4", "r5"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r6"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+}
+
+static __inline__ void _raw_spin_unlock(spinlock_t *lock)
+{
+#if SPINLOCK_DEBUG
+	BUG_ON(lock->magic != SPINLOCK_MAGIC);
+	BUG_ON(!spin_is_locked(lock));
+#endif
+	mb();
+	lock->lock = 1;
+}
+
+/*
+ * Read-write spinlocks, allowing multiple readers
+ * but only one writer.
+ *
+ * NOTE! it is quite common to have readers in interrupts
+ * but no interrupt writers. For those circumstances we
+ * can "mix" irq-safe locks - any writer needs to get a
+ * irq-safe write-lock, but readers can get non-irqsafe
+ * read-locks.
+ */
+typedef struct {
+	volatile int lock;
+#if SPINLOCK_DEBUG
+	unsigned magic;
+#endif
+} rwlock_t;
+
+#define RWLOCK_MAGIC	0xdeaf1eed
+
+#if SPINLOCK_DEBUG
+#define RWLOCK_MAGIC_INIT	, RWLOCK_MAGIC
+#else
+#define RWLOCK_MAGIC_INIT	/* */
+#endif
+
+#define RW_LOCK_UNLOCKED (rwlock_t) { RW_LOCK_BIAS RWLOCK_MAGIC_INIT }
+
+#define rwlock_init(x)	do { *(x) = RW_LOCK_UNLOCKED; } while(0)
+
+#define rwlock_is_locked(x)	((x)->lock != RW_LOCK_BIAS)
+
+/*
+ * On x86, we implement read-write locks as a 32-bit counter
+ * with the high bit (sign) being the "contended" bit.
+ *
+ * The inline assembly is non-obvious. Think about it.
+ *
+ * Changed to use the same technique as rw semaphores.  See
+ * semaphore.h for details.  -ben
+ */
+/* the spinlock helpers are in arch/i386/kernel/semaphore.c */
+
+static __inline__ void _raw_read_lock(rwlock_t *rw)
+{
+#if SPINLOCK_DEBUG
+	BUG_ON(rw->magic != RWLOCK_MAGIC);
+#endif
+	/* 
+	 * rw->lock :  >0 : unlock
+	 *          : <=0 : lock
+	 * 
+	 * for ( ; ; ) {
+	 *   rw->lock -= 1;  <-- need atomic operation
+	 *   if (rw->lock >= 0) break;
+	 *   rw->lock += 1;  <-- need atomic operation
+	 *   for ( ; rw->lock <= 0 ; );
+	 * }
+	 */
+	__asm__ __volatile__ (
+		"# read_lock			\n\t"
+		".fillinsn			\n"
+		"1:				\n\t"
+		"mvfc	r5, psw;		\n\t"
+		"clrpsw	#0x40 -> nop;		\n\t"
+		DCACHE_CLEAR("r4", "r6", "%0")
+		"lock	r4, @%0;		\n\t"
+		"addi	r4, #-1;		\n\t"
+		"unlock	r4, @%0;		\n\t"
+		"mvtc	r5, psw;		\n\t"
+		"bltz	r4, 2f;			\n\t"
+		LOCK_SECTION_START(".balign 4 \n\t")
+		".fillinsn			\n"
+		"2:				\n\t"
+		"clrpsw	#0x40 -> nop;		\n\t"
+		DCACHE_CLEAR("r4", "r6", "%0")
+		"lock	r4, @%0;		\n\t"
+		"addi	r4, #1;			\n\t"
+		"unlock	r4, @%0;		\n\t"
+		"mvtc	r5, psw;		\n\t"
+		".fillinsn			\n"
+		"3:				\n\t"
+		"ld	r4, @%0;		\n\t"
+		"bgtz	r4, 1b;			\n\t"
+		"bra	3b;			\n\t"
+		LOCK_SECTION_END
+		: /* no outputs */
+		: "r" (&rw->lock)
+		: "memory", "r4", "r5"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r6"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+}
+
+static __inline__ void _raw_write_lock(rwlock_t *rw)
+{
+#if SPINLOCK_DEBUG
+	BUG_ON(rw->magic != RWLOCK_MAGIC);
+#endif
+	/* 
+	 * rw->lock :  =RW_LOCK_BIAS_STR : unlock
+	 *          : !=RW_LOCK_BIAS_STR : lock
+	 * 
+	 * for ( ; ; ) {
+	 *   rw->lock -= RW_LOCK_BIAS_STR;  <-- need atomic operation
+	 *   if (rw->lock == 0) break;
+	 *   rw->lock += RW_LOCK_BIAS_STR;  <-- need atomic operation
+	 *   for ( ; rw->lock != RW_LOCK_BIAS_STR ; ) ;
+	 * }
+	 */
+	__asm__ __volatile__ (
+		"# write_lock					\n\t"
+		"seth	r5, #high(" RW_LOCK_BIAS_STR ");	\n\t"
+		"or3	r5, r5, #low(" RW_LOCK_BIAS_STR ");	\n\t"
+		".fillinsn					\n"
+		"1:						\n\t"
+		"mvfc	r6, psw;				\n\t"
+		"clrpsw	#0x40 -> nop;				\n\t"
+		DCACHE_CLEAR("r4", "r7", "%0")
+		"lock	r4, @%0;				\n\t"
+		"sub	r4, r5;					\n\t"
+		"unlock	r4, @%0;				\n\t"
+		"mvtc	r6, psw;				\n\t"
+		"bnez	r4, 2f;					\n\t"
+		LOCK_SECTION_START(".balign 4 \n\t")
+		".fillinsn					\n"
+		"2:						\n\t"
+		"clrpsw	#0x40 -> nop;				\n\t"
+		DCACHE_CLEAR("r4", "r7", "%0")
+		"lock	r4, @%0;				\n\t"
+		"add	r4, r5;					\n\t"
+		"unlock	r4, @%0;				\n\t"
+		"mvtc	r6, psw;				\n\t"
+		".fillinsn					\n"
+		"3:						\n\t"
+		"ld	r4, @%0;				\n\t"
+		"beq	r4, r5, 1b;				\n\t"
+		"bra	3b;					\n\t"
+		LOCK_SECTION_END
+		: /* no outputs */
+		: "r" (&rw->lock)
+		: "memory", "r4", "r5", "r6"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r7"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+}
+
+static __inline__ void _raw_read_unlock(rwlock_t *rw)
+{
+	__asm__ __volatile__ (
+		"# read_unlock			\n\t"
+		"mvfc	r5, psw;		\n\t"
+		"clrpsw	#0x40 -> nop;		\n\t"
+		DCACHE_CLEAR("r4", "r6", "%0")
+		"lock	r4, @%0;		\n\t"
+		"addi	r4, #1;			\n\t"
+		"unlock	r4, @%0;		\n\t"
+		"mvtc	r5, psw;		\n\t"
+		: /* no outputs */
+		: "r" (&rw->lock)
+		: "memory", "r4", "r5"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r6"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+}
+
+static __inline__ void _raw_write_unlock(rwlock_t *rw)
+{
+	__asm__ __volatile__ (
+		"# write_unlock					\n\t"
+		"seth	r5, #high(" RW_LOCK_BIAS_STR ");	\n\t"
+		"or3	r5, r5, #low(" RW_LOCK_BIAS_STR ");	\n\t"
+		"mvfc	r6, psw;				\n\t"
+		"clrpsw	#0x40 -> nop;				\n\t"
+		DCACHE_CLEAR("r4", "r7", "%0")
+		"lock	r4, @%0;				\n\t"
+		"add	r4, r5;					\n\t"
+		"unlock	r4, @%0;				\n\t"
+		"mvtc	r6, psw;				\n\t"
+		: /* no outputs */
+		: "r" (&rw->lock)
+		: "memory", "r4", "r5", "r6"
+#ifdef CONFIG_CHIP_M32700_TS1
+		, "r7"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+	);
+}
+
+static __inline__ int _raw_write_trylock(rwlock_t *lock)
+{
+	atomic_t *count = (atomic_t *)lock;
+	if (atomic_sub_and_test(RW_LOCK_BIAS, count))
+		return 1;
+	atomic_add(RW_LOCK_BIAS, count);
+	return 0;
+}
+
+#endif	/* _ASM_M32R_SPINLOCK_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/stat.h linux-2.6.7/include/asm-m32r/stat.h
--- linux-2.6.7.org/include/asm-m32r/stat.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/stat.h	2003-09-09 10:28:57.000000000 +0900
@@ -0,0 +1,91 @@
+#ifndef _ASM_M32R_STAT_H
+#define _ASM_M32R_STAT_H
+
+/* $Id$ */
+
+/* orig : i386 2.4.18 */
+
+#include <asm/byteorder.h>
+
+struct __old_kernel_stat {
+	unsigned short st_dev;
+	unsigned short st_ino;
+	unsigned short st_mode;
+	unsigned short st_nlink;
+	unsigned short st_uid;
+	unsigned short st_gid;
+	unsigned short st_rdev;
+	unsigned long  st_size;
+	unsigned long  st_atime;
+	unsigned long  st_mtime;
+	unsigned long  st_ctime;
+};
+
+#define STAT_HAVE_NSEC	1
+
+struct stat {
+	unsigned short st_dev;
+	unsigned short __pad1;
+	unsigned long  st_ino;
+	unsigned short st_mode;
+	unsigned short st_nlink;
+	unsigned short st_uid;
+	unsigned short st_gid;
+	unsigned short st_rdev;
+	unsigned short __pad2;
+	unsigned long  st_size;
+	unsigned long  st_blksize;
+	unsigned long  st_blocks;
+	unsigned long  st_atime;
+	unsigned long  st_atime_nsec;
+	unsigned long  st_mtime;
+	unsigned long  st_mtime_nsec;
+	unsigned long  st_ctime;
+	unsigned long  st_ctime_nsec;
+	unsigned long  __unused4;
+	unsigned long  __unused5;
+};
+
+/* This matches struct stat64 in glibc2.1, hence the absolutely
+ * insane amounts of padding around dev_t's.
+ */
+struct stat64 {
+	unsigned long long	st_dev;
+	unsigned char	__pad0[4];
+#define STAT64_HAS_BROKEN_ST_INO
+	unsigned long	__st_ino;
+
+	unsigned int	st_mode;
+	unsigned int	st_nlink;
+
+	unsigned long	st_uid;
+	unsigned long	st_gid;
+
+	unsigned long long	st_rdev;
+	unsigned char	__pad3[4];
+
+	long long	st_size;
+	unsigned long	st_blksize;
+
+#if defined(__BIG_ENDIAN) 
+	unsigned long	__pad4;		/* future possible st_blocks high bits */
+	unsigned long	st_blocks;	/* Number 512-byte blocks allocated. */
+#elif defined(__LITTLE_ENDIAN)
+	unsigned long	st_blocks;	/* Number 512-byte blocks allocated. */
+	unsigned long	__pad4;		/* future possible st_blocks high bits */
+#else
+#error no endian defined
+#endif
+	unsigned long	st_atime;
+	unsigned long	st_atime_nsec;
+
+	unsigned long	st_mtime;
+	unsigned long	st_mtime_nsec;
+
+	unsigned long	st_ctime;
+	unsigned long	st_ctime_nsec;
+
+	unsigned long long	st_ino;
+};
+
+#endif  /* _ASM_M32R_STAT_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/statfs.h linux-2.6.7/include/asm-m32r/statfs.h
--- linux-2.6.7.org/include/asm-m32r/statfs.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/statfs.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,6 @@
+#ifndef _ASM_M32R_STATFS_H
+#define _ASM_M32R_STATFS_H
+
+#include <asm-generic/statfs.h>
+
+#endif  /* _ASM_M32R_STATFS_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/string.h linux-2.6.7/include/asm-m32r/string.h
--- linux-2.6.7.org/include/asm-m32r/string.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/string.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,15 @@
+#ifndef _ASM_M32R_STRING_H
+#define _ASM_M32R_STRING_H
+
+/* $Id$ */
+
+#define  __HAVE_ARCH_STRLEN
+extern size_t strlen(const char * s);
+
+#define  __HAVE_ARCH_MEMCPY
+extern void *memcpy(void *__to, __const__ void *__from, size_t __n);
+
+#define  __HAVE_ARCH_MEMSET
+extern void *memset(void *__s, int __c, size_t __count);
+
+#endif  /* _ASM_M32R_STRING_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/syscall.h linux-2.6.7/include/asm-m32r/syscall.h
--- linux-2.6.7.org/include/asm-m32r/syscall.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/syscall.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,11 @@
+#ifndef _ASM_M32R_SYSCALL_H
+#define _ASM_M32R_SYSCALL_H
+
+/* $Id$ */
+
+/* Definitions for the system call vector.  */
+#define SYSCALL_VECTOR          "2"
+#define SYSCALL_VECTOR_ADDRESS  "0xa0"
+
+#endif /* _ASM_M32R_SYSCALL_H */
+
diff -ruN linux-2.6.7.org/include/asm-m32r/system.h linux-2.6.7/include/asm-m32r/system.h
--- linux-2.6.7.org/include/asm-m32r/system.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/system.h	2004-05-21 19:04:10.000000000 +0900
@@ -0,0 +1,301 @@
+#ifndef _ASM_M32R_SYSTEM_H
+#define _ASM_M32R_SYSTEM_H
+
+/* 
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ * 
+ * Copyright (C) 2001  by Hiroyuki Kondo, Hirokazu Takata, and Hitoshi Yamamoto
+ */
+
+#include <linux/config.h>
+
+#ifdef __KERNEL__
+
+/*
+ * switch_to(prev, next) should switch from task `prev' to `next'
+ * `prev' will never be the same as `next'.
+ *
+ * `next' and `prev' should be struct task_struct, but it isn't always defined
+ */
+
+#ifndef CONFIG_SMP
+#define prepare_to_switch()  do { } while(0)
+#endif	/* not CONFIG_SMP */
+
+#define switch_to(prev, next, last)  do { \
+	register unsigned long  arg0 __asm__ ("r0") = (unsigned long)prev; \
+	register unsigned long  arg1 __asm__ ("r1") = (unsigned long)next; \
+	register unsigned long  *oldsp __asm__ ("r2") = &(prev->thread.sp); \
+	register unsigned long  *newsp __asm__ ("r3") = &(next->thread.sp); \
+	register unsigned long  *oldlr __asm__ ("r4") = &(prev->thread.lr); \
+	register unsigned long  *newlr __asm__ ("r5") = &(next->thread.lr); \
+	register struct task_struct  *__last __asm__ ("r6"); \
+	__asm__ __volatile__ ( \
+		"st     r8, @-r15                                 \n\t" \
+		"st     r9, @-r15                                 \n\t" \
+		"st    r10, @-r15                                 \n\t" \
+		"st    r11, @-r15                                 \n\t" \
+		"st    r12, @-r15                                 \n\t" \
+		"st    r13, @-r15                                 \n\t" \
+		"st    r14, @-r15                                 \n\t" \
+		"seth  r14, #high(1f)                             \n\t" \
+		"or3   r14, r14, #low(1f)                         \n\t" \
+		"st    r14, @r4    ; store old LR                 \n\t" \
+		"st    r15, @r2    ; store old SP                 \n\t" \
+		"ld    r15, @r3    ; load new SP                  \n\t" \
+		"st     r0, @-r15  ; store 'prev' onto new stack  \n\t" \
+		"ld    r14, @r5    ; load new LR                  \n\t" \
+		"jmp   r14                                        \n\t" \
+		".fillinsn                                        \n  " \
+		"1:                                               \n\t" \
+		"ld     r6, @r15+  ; load 'prev' from new stack   \n\t" \
+		"ld    r14, @r15+                                 \n\t" \
+		"ld    r13, @r15+                                 \n\t" \
+		"ld    r12, @r15+                                 \n\t" \
+		"ld    r11, @r15+                                 \n\t" \
+		"ld    r10, @r15+                                 \n\t" \
+		"ld     r9, @r15+                                 \n\t" \
+		"ld     r8, @r15+                                 \n\t" \
+		: "=&r" (__last) \
+		: "r" (arg0), "r" (arg1), "r" (oldsp), "r" (newsp), \
+		  "r" (oldlr), "r" (newlr) \
+		: "memory" \
+	); \
+	last = __last; \
+} while(0)
+
+/* Interrupt Control */
+#if !defined(CONFIG_CHIP_M32102)
+#define local_irq_enable() \
+	__asm__ __volatile__ ("setpsw #0x40 -> nop": : :"memory")
+#define local_irq_disable() \
+	__asm__ __volatile__ ("clrpsw #0x40 -> nop": : :"memory")
+#else	/* CONFIG_CHIP_M32102 */
+static __inline__ void local_irq_enable(void)
+{
+	unsigned long tmpreg;
+	__asm__ __volatile__(
+		"mvfc	%0, psw;		\n\t"
+		"or3	%0, %0, #0x0040;	\n\t"
+		"mvtc	%0, psw;		\n\t"
+	: "=&r" (tmpreg) : : "cbit", "memory");
+}
+
+static __inline__ void local_irq_disable(void)
+{
+	unsigned long tmpreg0, tmpreg1;
+	__asm__ __volatile__(
+		"ld24	%0, #0	; Use 32-bit insn. \n\t"
+		"mvfc	%1, psw	; No interrupt can be accepted here. \n\t"
+		"mvtc	%0, psw	\n\t"
+		"and3	%0, %1, #0xffbf	\n\t"
+		"mvtc	%0, psw	\n\t"
+	: "=&r" (tmpreg0), "=&r" (tmpreg1) : : "cbit", "memory");
+}
+#endif	/* CONFIG_CHIP_M32102 */
+
+#define local_save_flags(x) \
+	__asm__ __volatile__("mvfc %0,psw" : "=r"(x) : /* no input */)
+
+#define local_irq_restore(x) \
+	__asm__ __volatile__("mvtc %0,psw" : /* no outputs */ \
+		: "r" (x) : "cbit", "memory")
+
+#if !defined(CONFIG_CHIP_M32102)
+#define local_irq_save(x)				\
+	__asm__ __volatile__(				\
+  		"mvfc	%0, psw;		\n\t"	\
+	  	"clrpsw	#0x40 -> nop;		\n\t"	\
+  		: "=r" (x) : /* no input */ : "memory")
+#else	/* CONFIG_CHIP_M32102 */
+#define local_irq_save(x) 				\
+	({						\
+		unsigned long tmpreg;			\
+		__asm__ __volatile__( 			\
+			"ld24	%1, #0 \n\t" 		\
+			"mvfc	%0, psw \n\t"		\
+			"mvtc	%1, psw \n\t"		\
+			"and3	%1, %0, #0xffbf \n\t"	\
+			"mvtc	%1, psw \n\t" 		\
+			: "=r" (x), "=&r" (tmpreg)	\
+			: : "cbit", "memory");		\
+	})
+#endif	/* CONFIG_CHIP_M32102 */
+
+#define irqs_disabled()					\
+	({						\
+		unsigned long flags;			\
+		local_save_flags(flags);		\
+		!(flags & 0x40);			\
+	})
+
+#endif  /* __KERNEL__ */
+
+#define nop()	__asm__ __volatile__ ("nop" : : )
+
+#define xchg(ptr,x) \
+	((__typeof__(*(ptr)))__xchg((unsigned long)(x),(ptr),sizeof(*(ptr))))
+
+#define tas(ptr)	(xchg((ptr),1))
+
+#ifdef CONFIG_SMP
+extern void  __xchg_called_with_bad_pointer(void);
+#endif
+
+#ifdef CONFIG_CHIP_M32700_TS1
+#define DCACHE_CLEAR(reg0, reg1, addr)				\
+	"seth	"reg1", #high(dcache_dummy);		\n\t"	\
+	"or3	"reg1", "reg1", #low(dcache_dummy);	\n\t"	\
+	"lock	"reg0", @"reg1";			\n\t"	\
+	"add3	"reg0", "addr", #0x1000;		\n\t"	\
+	"ld	"reg0", @"reg0";			\n\t"	\
+	"add3	"reg0", "addr", #0x2000;		\n\t"	\
+	"ld	"reg0", @"reg0";			\n\t"	\
+	"unlock	"reg0", @"reg1";			\n\t"
+	/* FIXME: This workaround code cannot handle kenrel modules 
+	 * correctly under SMP environment.
+	 */
+#else	/* CONFIG_CHIP_M32700_TS1 */
+#define DCACHE_CLEAR(reg0, reg1, addr)
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+
+static __inline__ unsigned long __xchg(unsigned long x, volatile void * ptr, 
+	int size)
+{
+	unsigned long flags;
+	unsigned long tmp = 0;
+
+	local_irq_save(flags);
+
+	switch (size) {
+#ifndef CONFIG_SMP
+	case 1:
+		__asm__ __volatile__ (
+			"ldb	%0, @%2 \n\t"
+			"stb	%1, @%2 \n\t"
+			: "=&r" (tmp) : "r" (x), "r" (ptr) : "memory");
+		break;
+	case 2:
+		__asm__ __volatile__ (
+			"ldh	%0, @%2 \n\t"
+			"sth	%1, @%2 \n\t"
+			: "=&r" (tmp) : "r" (x), "r" (ptr) : "memory");
+		break;
+	case 4:
+		__asm__ __volatile__ (
+			"ld	%0, @%2 \n\t"
+			"st	%1, @%2 \n\t"
+			: "=&r" (tmp) : "r" (x), "r" (ptr) : "memory");
+		break;
+#else  /* CONFIG_SMP */
+	case 4:
+		__asm__ __volatile__ (
+			DCACHE_CLEAR("%0", "r4", "%2")
+			"lock	%0, @%2;	\n\t"
+			"unlock	%1, @%2;	\n\t"
+			: "=&r" (tmp) : "r" (x), "r" (ptr)
+			: "memory"
+#ifdef CONFIG_CHIP_M32700_TS1
+			, "r4"
+#endif	/* CONFIG_CHIP_M32700_TS1 */
+		);
+		break;
+	default:
+		__xchg_called_with_bad_pointer();
+#endif  /* CONFIG_SMP */
+	}
+
+	local_irq_restore(flags);
+
+	return (tmp);
+}
+
+/*
+ * Memory barrier.
+ *
+ * mb() prevents loads and stores being reordered across this point.
+ * rmb() prevents loads being reordered across this point.
+ * wmb() prevents stores being reordered across this point.
+ */
+#if 0
+#define mb()   __asm__ __volatile__ ("push r0; \n\t pop r0;" : : : "memory")
+#else
+#define mb()   __asm__ __volatile__ ("" : : : "memory")
+#endif
+#define rmb()  mb()
+#define wmb()  mb()
+
+/**
+ * read_barrier_depends - Flush all pending reads that subsequents reads
+ * depend on.
+ *
+ * No data-dependent reads from memory-like regions are ever reordered
+ * over this barrier.  All reads preceding this primitive are guaranteed
+ * to access memory (but not necessarily other CPUs' caches) before any
+ * reads following this primitive that depend on the data return by
+ * any of the preceding reads.  This primitive is much lighter weight than
+ * rmb() on most CPUs, and is never heavier weight than is
+ * rmb().
+ *
+ * These ordering constraints are respected by both the local CPU
+ * and the compiler.
+ *
+ * Ordering is not guaranteed by anything other than these primitives,
+ * not even by data dependencies.  See the documentation for
+ * memory_barrier() for examples and URLs to more information.
+ *
+ * For example, the following code would force ordering (the initial
+ * value of "a" is zero, "b" is one, and "p" is "&a"):
+ *
+ * <programlisting>
+ *      CPU 0                           CPU 1
+ *
+ *      b = 2;
+ *      memory_barrier();
+ *      p = &b;                         q = p;
+ *                                      read_barrier_depends();
+ *                                      d = *q;
+ * </programlisting>
+ *
+ *
+ * because the read of "*q" depends on the read of "p" and these
+ * two reads are separated by a read_barrier_depends().  However,
+ * the following code, with the same initial values for "a" and "b":
+ *
+ * <programlisting>
+ *      CPU 0                           CPU 1
+ *
+ *      a = 2;
+ *      memory_barrier();
+ *      b = 3;                          y = b;
+ *                                      read_barrier_depends();
+ *                                      x = a;
+ * </programlisting>
+ *
+ * does not enforce ordering, since there is no data dependency between
+ * the read of "a" and the read of "b".  Therefore, on some CPUs, such
+ * as Alpha, "y" could be set to 3 and "x" to 0.  Use rmb()
+ * in cases like thiswhere there are no data dependencies.
+ **/
+
+#define read_barrier_depends()	do { } while (0)
+
+#ifdef CONFIG_SMP
+#define smp_mb()	mb()
+#define smp_rmb()	rmb()
+#define smp_wmb()	wmb()
+#define smp_read_barrier_depends()	read_barrier_depends()
+#else
+#define smp_mb()	barrier()
+#define smp_rmb()	barrier()
+#define smp_wmb()	barrier()
+#define smp_read_barrier_depends()	do { } while (0)
+#endif
+
+#define set_mb(var, value) do { xchg(&var, value); } while (0)
+#define set_wmb(var, value) do { var = value; wmb(); } while (0)
+
+#endif  /* _ASM_M32R_SYSTEM_H */
+
diff -ruN linux-2.6.7.org/include/asm-m32r/termbits.h linux-2.6.7/include/asm-m32r/termbits.h
--- linux-2.6.7.org/include/asm-m32r/termbits.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/termbits.h	2004-03-25 13:29:22.000000000 +0900
@@ -0,0 +1,175 @@
+#ifndef _ASM_M32R_TERMBITS_H
+#define _ASM_M32R_TERMBITS_H
+
+/* $Id$ */
+
+#include <linux/posix_types.h>
+
+typedef unsigned char	cc_t;
+typedef unsigned int	speed_t;
+typedef unsigned int	tcflag_t;
+
+#define NCCS 19
+struct termios {
+	tcflag_t c_iflag;		/* input mode flags */
+	tcflag_t c_oflag;		/* output mode flags */
+	tcflag_t c_cflag;		/* control mode flags */
+	tcflag_t c_lflag;		/* local mode flags */
+	cc_t c_line;			/* line discipline */
+	cc_t c_cc[NCCS];		/* control characters */
+};
+
+/* c_cc characters */
+#define VINTR 0
+#define VQUIT 1
+#define VERASE 2
+#define VKILL 3
+#define VEOF 4
+#define VTIME 5
+#define VMIN 6
+#define VSWTC 7
+#define VSTART 8
+#define VSTOP 9
+#define VSUSP 10
+#define VEOL 11
+#define VREPRINT 12
+#define VDISCARD 13
+#define VWERASE 14
+#define VLNEXT 15
+#define VEOL2 16
+
+/* c_iflag bits */
+#define IGNBRK	0000001
+#define BRKINT	0000002
+#define IGNPAR	0000004
+#define PARMRK	0000010
+#define INPCK	0000020
+#define ISTRIP	0000040
+#define INLCR	0000100
+#define IGNCR	0000200
+#define ICRNL	0000400
+#define IUCLC	0001000
+#define IXON	0002000
+#define IXANY	0004000
+#define IXOFF	0010000
+#define IMAXBEL	0020000
+#define IUTF8   0040000
+
+/* c_oflag bits */
+#define OPOST	0000001
+#define OLCUC	0000002
+#define ONLCR	0000004
+#define OCRNL	0000010
+#define ONOCR	0000020
+#define ONLRET	0000040
+#define OFILL	0000100
+#define OFDEL	0000200
+#define NLDLY	0000400
+#define   NL0	0000000
+#define   NL1	0000400
+#define CRDLY	0003000
+#define   CR0	0000000
+#define   CR1	0001000
+#define   CR2	0002000
+#define   CR3	0003000
+#define TABDLY	0014000
+#define   TAB0	0000000
+#define   TAB1	0004000
+#define   TAB2	0010000
+#define   TAB3	0014000
+#define   XTABS	0014000
+#define BSDLY	0020000
+#define   BS0	0000000
+#define   BS1	0020000
+#define VTDLY	0040000
+#define   VT0	0000000
+#define   VT1	0040000
+#define FFDLY	0100000
+#define   FF0	0000000
+#define   FF1	0100000
+
+/* c_cflag bit meaning */
+#define CBAUD	0010017
+#define  B0	0000000		/* hang up */
+#define  B50	0000001
+#define  B75	0000002
+#define  B110	0000003
+#define  B134	0000004
+#define  B150	0000005
+#define  B200	0000006
+#define  B300	0000007
+#define  B600	0000010
+#define  B1200	0000011
+#define  B1800	0000012
+#define  B2400	0000013
+#define  B4800	0000014
+#define  B9600	0000015
+#define  B19200	0000016
+#define  B38400	0000017
+#define EXTA B19200
+#define EXTB B38400
+#define CSIZE	0000060
+#define   CS5	0000000
+#define   CS6	0000020
+#define   CS7	0000040
+#define   CS8	0000060
+#define CSTOPB	0000100
+#define CREAD	0000200
+#define PARENB	0000400
+#define PARODD	0001000
+#define HUPCL	0002000
+#define CLOCAL	0004000
+#define CBAUDEX 0010000
+#define    B57600 0010001
+#define   B115200 0010002
+#define   B230400 0010003
+#define   B460800 0010004
+#define   B500000 0010005
+#define   B576000 0010006
+#define   B921600 0010007
+#define  B1000000 0010010
+#define  B1152000 0010011
+#define  B1500000 0010012
+#define  B2000000 0010013
+#define  B2500000 0010014
+#define  B3000000 0010015
+#define  B3500000 0010016
+#define  B4000000 0010017
+#define CIBAUD	  002003600000	/* input baud rate (not used) */
+#define CMSPAR	  010000000000		/* mark or space (stick) parity */
+#define CRTSCTS	  020000000000		/* flow control */
+
+/* c_lflag bits */
+#define ISIG	0000001
+#define ICANON	0000002
+#define XCASE	0000004
+#define ECHO	0000010
+#define ECHOE	0000020
+#define ECHOK	0000040
+#define ECHONL	0000100
+#define NOFLSH	0000200
+#define TOSTOP	0000400
+#define ECHOCTL	0001000
+#define ECHOPRT	0002000
+#define ECHOKE	0004000
+#define FLUSHO	0010000
+#define PENDIN	0040000
+#define IEXTEN	0100000
+
+/* tcflow() and TCXONC use these */
+#define	TCOOFF		0
+#define	TCOON		1
+#define	TCIOFF		2
+#define	TCION		3
+
+/* tcflush() and TCFLSH use these */
+#define	TCIFLUSH	0
+#define	TCOFLUSH	1
+#define	TCIOFLUSH	2
+
+/* tcsetattr uses these */
+#define	TCSANOW		0
+#define	TCSADRAIN	1
+#define	TCSAFLUSH	2
+
+#endif  /* _ASM_M32R_TERMBITS_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/termios.h linux-2.6.7/include/asm-m32r/termios.h
--- linux-2.6.7.org/include/asm-m32r/termios.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/termios.h	2003-09-09 15:05:33.000000000 +0900
@@ -0,0 +1,109 @@
+#ifndef _M32R_TERMIOS_H
+#define _M32R_TERMIOS_H
+
+/* orig : i386 2.6.0-test5 */
+
+#include <asm/termbits.h>
+#include <asm/ioctls.h>
+
+struct winsize {
+	unsigned short ws_row;
+	unsigned short ws_col;
+	unsigned short ws_xpixel;
+	unsigned short ws_ypixel;
+};
+
+#define NCC 8
+struct termio {
+	unsigned short c_iflag;		/* input mode flags */
+	unsigned short c_oflag;		/* output mode flags */
+	unsigned short c_cflag;		/* control mode flags */
+	unsigned short c_lflag;		/* local mode flags */
+	unsigned char c_line;		/* line discipline */
+	unsigned char c_cc[NCC];	/* control characters */
+};
+
+/* modem lines */
+#define TIOCM_LE	0x001
+#define TIOCM_DTR	0x002
+#define TIOCM_RTS	0x004
+#define TIOCM_ST	0x008
+#define TIOCM_SR	0x010
+#define TIOCM_CTS	0x020
+#define TIOCM_CAR	0x040
+#define TIOCM_RNG	0x080
+#define TIOCM_DSR	0x100
+#define TIOCM_CD	TIOCM_CAR
+#define TIOCM_RI	TIOCM_RNG
+#define TIOCM_OUT1	0x2000
+#define TIOCM_OUT2	0x4000
+#define TIOCM_LOOP	0x8000
+
+/* ioctl (fd, TIOCSERGETLSR, &result) where result may be as below */
+
+/* line disciplines */
+#define N_TTY		0
+#define N_SLIP		1
+#define N_MOUSE		2
+#define N_PPP		3
+#define N_STRIP		4
+#define N_AX25		5
+#define N_X25		6	/* X.25 async */
+#define N_6PACK		7
+#define N_MASC		8	/* Reserved for Mobitex module <kaz@cafe.net> */
+#define N_R3964		9	/* Reserved for Simatic R3964 module */
+#define N_PROFIBUS_FDL	10	/* Reserved for Profibus <Dave@mvhi.com> */
+#define N_IRDA		11	/* Linux IR - http://irda.sourceforge.net/ */
+#define N_SMSBLOCK	12	/* SMS block mode - for talking to GSM data cards about SMS messages */
+#define N_HDLC		13	/* synchronous HDLC */
+#define N_SYNC_PPP	14	/* synchronous PPP */
+#define N_HCI		15  /* Bluetooth HCI UART */
+
+#ifdef __KERNEL__
+#include <linux/module.h>
+
+/*	intr=^C		quit=^\		erase=del	kill=^U
+	eof=^D		vtime=\0	vmin=\1		sxtc=\0
+	start=^Q	stop=^S		susp=^Z		eol=\0
+	reprint=^R	discard=^U	werase=^W	lnext=^V
+	eol2=\0
+*/
+#define INIT_C_CC "\003\034\177\025\004\0\1\0\021\023\032\0\022\017\027\026\0"
+
+/*
+ * Translate a "termio" structure into a "termios". Ugh.
+ */
+#define SET_LOW_TERMIOS_BITS(termios, termio, x) { \
+	unsigned short __tmp; \
+	get_user(__tmp,&(termio)->x); \
+	*(unsigned short *) &(termios)->x = __tmp; \
+}
+
+#define user_termio_to_kernel_termios(termios, termio) \
+({ \
+	SET_LOW_TERMIOS_BITS(termios, termio, c_iflag); \
+	SET_LOW_TERMIOS_BITS(termios, termio, c_oflag); \
+	SET_LOW_TERMIOS_BITS(termios, termio, c_cflag); \
+	SET_LOW_TERMIOS_BITS(termios, termio, c_lflag); \
+	copy_from_user((termios)->c_cc, (termio)->c_cc, NCC); \
+})
+
+/*
+ * Translate a "termios" structure into a "termio". Ugh.
+ */
+#define kernel_termios_to_user_termio(termio, termios) \
+({ \
+	put_user((termios)->c_iflag, &(termio)->c_iflag); \
+	put_user((termios)->c_oflag, &(termio)->c_oflag); \
+	put_user((termios)->c_cflag, &(termio)->c_cflag); \
+	put_user((termios)->c_lflag, &(termio)->c_lflag); \
+	put_user((termios)->c_line,  &(termio)->c_line); \
+	copy_to_user((termio)->c_cc, (termios)->c_cc, NCC); \
+})
+
+#define user_termios_to_kernel_termios(k, u) copy_from_user(k, u, sizeof(struct termios))
+#define kernel_termios_to_user_termios(u, k) copy_to_user(u, k, sizeof(struct termios))
+
+#endif	/* __KERNEL__ */
+
+#endif	/* _M32R_TERMIOS_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/thread_info.h linux-2.6.7/include/asm-m32r/thread_info.h
--- linux-2.6.7.org/include/asm-m32r/thread_info.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/thread_info.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,149 @@
+/* thread_info.h: i386 low-level thread information
+ *
+ * Copyright (C) 2002  David Howells (dhowells@redhat.com)
+ * - Incorporating suggestions made by Linus Torvalds and Dave Miller
+ */
+
+#ifndef _ASM_THREAD_INFO_H
+#define _ASM_THREAD_INFO_H
+
+#ifdef __KERNEL__
+
+#ifndef __ASSEMBLY__
+#include <asm/processor.h>
+#endif
+
+/*
+ * low level task data that entry.S needs immediate access to
+ * - this struct should fit entirely inside of one cache line
+ * - this struct shares the supervisor stack pages
+ * - if the contents of this structure are changed, the assembly constants must also be changed
+ */
+#ifndef __ASSEMBLY__
+
+struct thread_info {
+	struct task_struct	*task;		/* main task structure */
+	struct exec_domain	*exec_domain;	/* execution domain */
+	unsigned long		flags;		/* low level flags */
+	unsigned long		status;		/* thread-synchronous flags */
+	__u32			cpu;		/* current CPU */
+	__s32			preempt_count; /* 0 => preemptable, <0 => BUG */
+
+	mm_segment_t		addr_limit;	/* thread address space:
+					 	   0-0xBFFFFFFF for user-thead
+						   0-0xFFFFFFFF for kernel-thread
+						*/
+	struct restart_block    restart_block;
+
+	__u8			supervisor_stack[0];
+};
+
+#else /* !__ASSEMBLY__ */
+
+/* offsets into the thread_info struct for assembly code access */
+#define TI_TASK		0x00000000
+#define TI_EXEC_DOMAIN	0x00000004
+#define TI_FLAGS	0x00000008
+#define TI_STATUS	0x0000000C
+#define TI_CPU		0x00000010
+#define TI_PRE_COUNT	0x00000014
+#define TI_ADDR_LIMIT	0x00000018
+#define TI_RESTART_BLOCK 0x000001C
+
+#endif
+
+#define PREEMPT_ACTIVE		0x4000000
+
+/*
+ * macros/functions for gaining access to the thread information structure
+ *
+ * preempt_count needs to be 1 initially, until the scheduler is functional.
+ */
+#ifndef __ASSEMBLY__
+
+#define INIT_THREAD_INFO(tsk)			\
+{						\
+	.task		= &tsk,			\
+	.exec_domain	= &default_exec_domain,	\
+	.flags		= 0,			\
+	.cpu		= 0,			\
+	.preempt_count	= 1,			\
+	.addr_limit	= KERNEL_DS,		\
+	.restart_block = {			\
+		.fn = do_no_restart_syscall,	\
+	},					\
+}
+
+#define init_thread_info	(init_thread_union.thread_info)
+#define init_stack		(init_thread_union.stack)
+
+/* how to get the thread information struct from C */
+static inline struct thread_info *current_thread_info(void)
+{
+	struct thread_info *ti;
+
+	__asm__ __volatile__ (
+		"ldi	%0, #0xffffe000;	\n\t"
+		"and	%0, sp;			\n\t"
+		: "=r" (ti)
+	);
+
+	return ti;
+}
+
+/* thread information allocation */
+#define THREAD_SIZE (2*PAGE_SIZE)
+#define alloc_thread_info(task) \
+	((struct thread_info *) __get_free_pages(GFP_KERNEL,1))
+#define free_thread_info(ti) free_pages((unsigned long) (ti), 1)
+#define get_thread_info(ti) get_task_struct((ti)->task)
+#define put_thread_info(ti) put_task_struct((ti)->task)
+
+#else /* !__ASSEMBLY__ */
+
+/* how to get the thread information struct from ASM */
+#define GET_THREAD_INFO(reg)	GET_THREAD_INFO reg
+	.macro GET_THREAD_INFO reg
+	ldi	\reg, #0xffffe000
+	and	\reg, sp
+	.endm
+
+#endif
+
+/*
+ * thread information flags
+ * - these are process state flags that various assembly files may need to access
+ * - pending work-to-be-done flags are in LSW
+ * - other flags in MSW
+ */
+#define TIF_SYSCALL_TRACE	0	/* syscall trace active */
+#define TIF_NOTIFY_RESUME	1	/* resumption notification requested */
+#define TIF_SIGPENDING		2	/* signal pending */
+#define TIF_NEED_RESCHED	3	/* rescheduling necessary */
+#define TIF_SINGLESTEP		4	/* restore singlestep on return to user mode */
+#define TIF_IRET		5	/* return with iret */
+#define TIF_POLLING_NRFLAG	16	/* true if poll_idle() is polling TIF_NEED_RESCHED */
+
+#define _TIF_SYSCALL_TRACE	(1<<TIF_SYSCALL_TRACE)
+#define _TIF_NOTIFY_RESUME	(1<<TIF_NOTIFY_RESUME)
+#define _TIF_SIGPENDING		(1<<TIF_SIGPENDING)
+#define _TIF_NEED_RESCHED	(1<<TIF_NEED_RESCHED)
+#define _TIF_SINGLESTEP		(1<<TIF_SINGLESTEP)
+#define _TIF_IRET		(1<<TIF_IRET)
+#define _TIF_POLLING_NRFLAG	(1<<TIF_POLLING_NRFLAG)
+
+#define _TIF_WORK_MASK		0x0000FFFE	/* work to do on interrupt/exception return */
+#define _TIF_ALLWORK_MASK	0x0000FFFF	/* work to do on any return to u-space */
+
+/*
+ * Thread-synchronous status.
+ *
+ * This is different from the flags in that nobody else
+ * ever touches our thread-synchronous status, so we don't
+ * have to worry about atomic accesses.
+ */
+#define TS_USEDFPU		0x0001	/* FPU was used by this task this quantum (SMP) */
+
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_THREAD_INFO_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/timex.h linux-2.6.7/include/asm-m32r/timex.h
--- linux-2.6.7.org/include/asm-m32r/timex.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/timex.h	2003-09-09 10:28:57.000000000 +0900
@@ -0,0 +1,36 @@
+#ifndef _ASM_M32R_TIMEX_H
+#define _ASM_M32R_TIMEX_H
+
+/* $Id$ */
+
+/*
+ * linux/include/asm-m32r/timex.h
+ *
+ * m32r architecture timex specifications
+ */
+
+#include <linux/config.h>
+
+#define CLOCK_TICK_RATE	(CONFIG_BUS_CLOCK / CONFIG_TIMER_DIVIDE)
+#define CLOCK_TICK_FACTOR	20	/* Factor of both 1000000 and CLOCK_TICK_RATE */
+#define FINETUNE ((((((long)LATCH * HZ - CLOCK_TICK_RATE) << SHIFT_HZ) * \
+	(1000000/CLOCK_TICK_FACTOR) / (CLOCK_TICK_RATE/CLOCK_TICK_FACTOR)) \
+		<< (SHIFT_SCALE-SHIFT_HZ)) / HZ)
+
+#ifdef __KERNEL__
+/*
+ * Standard way to access the cycle counter.
+ * Currently only used on SMP.
+ */
+
+typedef unsigned long long cycles_t;
+
+extern cycles_t cacheflush_time;
+
+static __inline__ cycles_t get_cycles (void)
+{
+	return 0;
+}
+#endif  /* __KERNEL__ */
+
+#endif  /* _ASM_M32R_TIMEX_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/tlb.h linux-2.6.7/include/asm-m32r/tlb.h
--- linux-2.6.7.org/include/asm-m32r/tlb.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/tlb.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,20 @@
+#ifndef _M32R_TLB_H
+#define _M32R_TLB_H
+
+/*
+ * x86 doesn't need any special per-pte or
+ * per-vma handling..
+ */
+#define tlb_start_vma(tlb, vma) do { } while (0)
+#define tlb_end_vma(tlb, vma) do { } while (0)
+#define __tlb_remove_tlb_entry(tlb, pte, address) do { } while (0)
+
+/*
+ * .. because we flush the whole mm when it
+ * fills up.
+ */
+#define tlb_flush(tlb) flush_tlb_mm((tlb)->mm)
+
+#include <asm-generic/tlb.h>
+
+#endif /* _M32R_TLB_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/tlbflush.h linux-2.6.7/include/asm-m32r/tlbflush.h
--- linux-2.6.7.org/include/asm-m32r/tlbflush.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/tlbflush.h	2004-05-21 19:04:10.000000000 +0900
@@ -0,0 +1,102 @@
+#ifndef _ASM_M32R_TLBFLUSH_H
+#define _ASM_M32R_TLBFLUSH_H
+
+#include <linux/config.h>
+#include <asm/m32r.h>
+
+/*
+ * TLB flushing:
+ *
+ *  - flush_tlb() flushes the current mm struct TLBs
+ *  - flush_tlb_all() flushes all processes TLBs
+ *  - flush_tlb_mm(mm) flushes the specified mm context TLB's
+ *  - flush_tlb_page(vma, vmaddr) flushes one page
+ *  - flush_tlb_range(vma, start, end) flushes a range of pages
+ *  - flush_tlb_kernel_range(start, end) flushes a range of kernel pages
+ *  - flush_tlb_pgtables(mm, start, end) flushes a range of page tables
+ */
+
+extern void local_flush_tlb_all(void);
+extern void local_flush_tlb_mm(struct mm_struct *);
+extern void local_flush_tlb_page(struct vm_area_struct *, unsigned long);
+extern void local_flush_tlb_range(struct vm_area_struct *, unsigned long, 
+	unsigned long);
+
+#ifndef CONFIG_SMP
+#ifdef CONFIG_MMU
+#define flush_tlb_all()			local_flush_tlb_all()
+#define flush_tlb_mm(mm)		local_flush_tlb_mm(mm)
+#define flush_tlb_page(vma, page)	local_flush_tlb_page(vma, page)
+#define flush_tlb_range(vma, start, end)	\
+	local_flush_tlb_range(vma, start, end)
+#define flush_tlb_kernel_range(start, end)	local_flush_tlb_all()
+#else	/* CONFIG_MMU */
+#define flush_tlb_all()			do { } while (0)
+#define flush_tlb_mm(mm)		do { } while (0)
+#define flush_tlb_page(vma, vmaddr)	do { } while (0)
+#define flush_tlb_range(vma, start, end)	do { } while (0)
+#endif	/* CONFIG_MMU */
+#else	/* CONFIG_SMP */
+extern void smp_flush_tlb_all(void);
+extern void smp_flush_tlb_mm(struct mm_struct *);
+extern void smp_flush_tlb_page(struct vm_area_struct *, unsigned long);
+extern void smp_flush_tlb_range(struct vm_area_struct *, unsigned long, 
+	unsigned long);
+
+#define flush_tlb_all()			smp_flush_tlb_all()
+#define flush_tlb_mm(mm)		smp_flush_tlb_mm(mm)
+#define flush_tlb_page(vma, page)	smp_flush_tlb_page(vma, page)
+#define flush_tlb_range(vma, start, end)	\
+	smp_flush_tlb_range(vma, start, end)
+#define flush_tlb_kernel_range(start, end)	smp_flush_tlb_all()
+#endif	/* CONFIG_SMP */
+
+static __inline__ void __flush_tlb_page(unsigned long page)
+{
+	unsigned int tmpreg0, tmpreg1, tmpreg2;
+
+	__asm__ __volatile__ (
+		"seth	%0, #high(%4)	\n\t"
+		"st	%3, @(%5, %0)	\n\t"
+		"ldi	%1, #1		\n\t"
+		"st	%1, @(%6, %0)	\n\t"
+		"add3	%1, %0, %7	\n\t"
+		".fillinsn		\n"
+		"1:			\n\t"
+		"ld	%2, @(%6, %0)	\n\t"
+		"bnez	%2, 1b		\n\t"
+		"ld	%0, @%1+	\n\t"
+		"ld	%1, @%1		\n\t"
+		"st	%2, @+%0	\n\t"
+		"st	%2, @+%1	\n\t"
+		: "=&r" (tmpreg0), "=&r" (tmpreg1), "=&r" (tmpreg2)
+		: "r" (page), "i" (MMU_REG_BASE), "i" (MSVA_offset),
+		"i" (MTOP_offset), "i" (MIDXI_offset)
+		: "memory"
+	);
+}
+
+static __inline__ void __flush_tlb_all(void)
+{
+	unsigned int tmpreg0, tmpreg1;
+
+	__asm__ __volatile__ (
+		"seth	%0, #high(%2)		\n\t"
+		"or3	%0, %0, #low(%2)	\n\t"
+		"ldi	%1, #0xc		\n\t"
+		"st	%1, @%0			\n\t"
+		".fillinsn			\n"
+		"1:				\n\t"
+		"ld	%1, @%0			\n\t"
+		"bnez	%1, 1b			\n\t"
+		: "=&r" (tmpreg0), "=&r" (tmpreg1)
+		: "i" (MTOP) : "memory"
+	);
+}
+
+#define flush_tlb_pgtables(mm, start, end)	do { } while (0)
+
+extern void update_mmu_cache(struct vm_area_struct *, unsigned long, pte_t);
+
+#endif	/* _ASM_M32R_TLBFLUSH_H */
+
diff -ruN linux-2.6.7.org/include/asm-m32r/topology.h linux-2.6.7/include/asm-m32r/topology.h
--- linux-2.6.7.org/include/asm-m32r/topology.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/topology.h	2004-03-25 13:29:22.000000000 +0900
@@ -0,0 +1,53 @@
+/*
+ * linux/include/asm-generic/topology.h
+ *
+ * Written by: Matthew Dobson, IBM Corporation
+ *
+ * Copyright (C) 2002, IBM Corp.
+ *
+ * All rights reserved.          
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+ * NON INFRINGEMENT.  See the GNU General Public License for more
+ * details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ * Send feedback to <colpatch@us.ibm.com>
+ */
+#ifndef _ASM_M32R_TOPOLOGY_H
+#define _ASM_M32R_TOPOLOGY_H
+
+/* Other architectures wishing to use this simple topology API should fill
+   in the below functions as appropriate in their own <asm/topology.h> file. */
+
+#define cpu_to_node(cpu)	(0)
+
+#ifndef parent_node
+#define parent_node(node)	(0)
+#endif
+#ifndef node_to_cpumask
+#define node_to_cpumask(node)	(cpu_online_map)
+#endif
+#ifndef node_to_first_cpu
+#define node_to_first_cpu(node)	(0)
+#endif
+#ifndef pcibus_to_cpumask
+#define pcibus_to_cpumask(bus)	(cpu_online_map)
+#endif
+
+/* Cross-node load balancing interval. */
+#ifndef NODE_BALANCE_RATE
+#define NODE_BALANCE_RATE 10
+#endif
+
+#endif /* _ASM_M32R_TOPOLOGY_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/types.h linux-2.6.7/include/asm-m32r/types.h
--- linux-2.6.7.org/include/asm-m32r/types.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/types.h	2004-07-15 13:43:17.000000000 +0900
@@ -0,0 +1,57 @@
+#ifndef _ASM_M32R_TYPES_H
+#define _ASM_M32R_TYPES_H
+
+/* $Id$ */
+
+/* orig : i386 2.4.18 */
+
+typedef unsigned short umode_t;
+
+/*
+ * __xx is ok: it doesn't pollute the POSIX namespace. Use these in the
+ * header files exported to user space
+ */
+
+typedef __signed__ char __s8;
+typedef unsigned char __u8;
+
+typedef __signed__ short __s16;
+typedef unsigned short __u16;
+
+typedef __signed__ int __s32;
+typedef unsigned int __u32;
+
+#if defined(__GNUC__) && !defined(__STRICT_ANSI__)
+typedef __signed__ long long __s64;
+typedef unsigned long long __u64;
+#endif
+
+/*
+ * These aren't exported outside the kernel to avoid name space clashes
+ */
+#ifdef __KERNEL__
+
+typedef signed char s8;
+typedef unsigned char u8;
+
+typedef signed short s16;
+typedef unsigned short u16;
+
+typedef signed int s32;
+typedef unsigned int u32;
+
+typedef signed long long s64;
+typedef unsigned long long u64;
+
+#define BITS_PER_LONG 32
+
+/* DMA addresses are 32-bits wide.  */
+
+typedef u32 dma_addr_t;
+typedef u64 dma64_addr_t;
+
+typedef unsigned short kmem_bufctl_t;
+
+#endif /* __KERNEL__ */
+
+#endif  /* _ASM_M32R_TYPES_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/uaccess.h linux-2.6.7/include/asm-m32r/uaccess.h
--- linux-2.6.7.org/include/asm-m32r/uaccess.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/uaccess.h	2004-07-15 13:43:17.000000000 +0900
@@ -0,0 +1,525 @@
+#ifndef _ASM_M32R_UACCESS_H
+#define _ASM_M32R_UACCESS_H
+
+/* $Id$ */
+
+#undef UACCESS_DEBUG
+
+#ifdef UACCESS_DEBUG
+#define UAPRINTK(args...) printk(args)
+#else
+#define UAPRINTK(args...)
+#endif /* UACCESS_DEBUG */
+
+/*
+ * User space memory access functions
+ */
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/thread_info.h>
+#include <asm/page.h>
+
+#define VERIFY_READ 0
+#define VERIFY_WRITE 1
+
+/*
+ * The fs value determines whether argument validity checking should be
+ * performed or not.  If get_fs() == USER_DS, checking is performed, with
+ * get_fs() == KERNEL_DS, checking is bypassed.
+ *
+ * For historical reasons, these macros are grossly misnamed.
+ */
+
+#define MAKE_MM_SEG(s)	((mm_segment_t) { (s) })
+
+#ifdef CONFIG_MMU
+#define KERNEL_DS	MAKE_MM_SEG(0xFFFFFFFF)
+#define USER_DS		MAKE_MM_SEG(PAGE_OFFSET)
+#else
+#define KERNEL_DS	MAKE_MM_SEG(0xFFFFFFFF)
+#define USER_DS		MAKE_MM_SEG(0xFFFFFFFF)
+#endif /* CONFIG_MMU */
+
+#define get_ds()	(KERNEL_DS)
+#ifdef CONFIG_MMU
+#define get_fs()	(current_thread_info()->addr_limit)
+#define set_fs(x)	(current_thread_info()->addr_limit = (x))
+#else
+static inline mm_segment_t get_fs(void)
+{
+  return USER_DS;
+}
+
+static inline void set_fs(mm_segment_t s)
+{
+}
+#endif /* CONFIG_MMU */
+
+#define segment_eq(a,b)	((a).seg == (b).seg)
+
+#define __addr_ok(addr) \
+	((unsigned long)(addr) < (current_thread_info()->addr_limit.seg))
+
+/*
+ * Uhhuh, this needs 33-bit arithmetic. We have a carry..
+ */
+#define __range_ok(addr,size) ({					\
+	unsigned long flag, sum; 					\
+	__chk_user_ptr(addr);						\
+	asm ( 								\
+		"	cmpu	%1, %1    ; clear cbit\n"		\
+		"	addx	%1, %3    ; set cbit if overflow\n"	\
+		"	subx	%0, %0\n"				\
+		"	cmpu	%4, %1\n"				\
+		"	subx	%0, %5\n"				\
+		: "=&r"(flag), "=r"(sum)				\
+		: "1"(addr), "r"((int)(size)), 				\
+		  "r"(current_thread_info()->addr_limit.seg), "r"(0)	\
+		: "cbit" );						\
+	flag; })
+
+#ifdef CONFIG_MMU
+#define access_ok(type,addr,size) (__range_ok(addr,size) == 0)
+#else
+static inline int access_ok(int type, const void *addr, unsigned long size)
+{
+  extern unsigned long memory_start, memory_end;
+  unsigned long val = (unsigned long)addr;
+
+  return ((val >= memory_start) && ((val + size) < memory_end));
+}
+#endif /* CONFIG_MMU */
+
+static __inline__ int verify_area(int type, const void __user *addr, 
+	unsigned long size)
+{
+	return access_ok(type, addr, size) ? 0 : -EFAULT;
+}
+
+
+/*
+ * The exception table consists of pairs of addresses: the first is the
+ * address of an instruction that is allowed to fault, and the second is
+ * the address at which the program should continue.  No registers are
+ * modified, so it is entirely up to the continuation code to figure out
+ * what to do.
+ *
+ * All the routines below use bits of fixup code that are out of line
+ * with the main instruction path.  This means when everything is well,
+ * we don't even have to jump over them.  Further, they do not intrude
+ * on our cache or tlb entries.
+ */
+
+struct exception_table_entry
+{
+	unsigned long insn, fixup;
+};
+
+extern int fixup_exception(struct pt_regs *regs);
+
+/*
+ * These are the main single-value transfer routines.  They automatically
+ * use the right size if we just have the right pointer type.
+ *
+ * This gets kind of ugly. We want to return _two_ values in "get_user()"
+ * and yet we don't want to do any pointers, because that is too much
+ * of a performance impact. Thus we have a few rather ugly macros here,
+ * and hide all the uglyness from the user.
+ *
+ * The "__xxx" versions of the user access functions are versions that
+ * do not verify the address space, that must have been done previously
+ * with a separate "access_ok()" call (this is used when we do multiple
+ * accesses to the same area of user memory).
+ */
+
+extern void __get_user_1(void);
+extern void __get_user_2(void);
+extern void __get_user_4(void);
+
+#ifndef MODULE
+#define __get_user_x(size,ret,x,ptr) 					\
+	__asm__ __volatile__(						\
+		"	mv	r0, %0\n"				\
+		"	mv	r1, %1\n" 				\
+		"	bl __get_user_" #size "\n"			\
+		"	mv	%0, r0\n"				\
+		"	mv	%1, r1\n" 				\
+		: "=r"(ret), "=r"(x) 					\
+		: "0"(ptr)						\
+		: "r0", "r1", "r14" )
+#else /* MODULE */
+/*
+ * Use "jl" instead of "bl" for MODULE
+ */
+#define __get_user_x(size,ret,x,ptr) 					\
+	__asm__ __volatile__(						\
+		"	mv	r0, %0\n"				\
+		"	mv	r1, %1\n" 				\
+		"	seth	lr, #high(__get_user_" #size ")\n"	\
+		"	or3	lr, lr, #low(__get_user_" #size ")\n"	\
+		"	jl 	lr\n"					\
+		"	mv	%0, r0\n"				\
+		"	mv	%1, r1\n" 				\
+		: "=r"(ret), "=r"(x) 					\
+		: "0"(ptr)						\
+		: "r0", "r1", "r14" )
+#endif
+
+/* Careful: we have to cast the result to the type of the pointer for sign 
+   reasons */
+#define get_user(x,ptr)							\
+({	int __ret_gu,__val_gu;						\
+	__chk_user_ptr(ptr);						\
+	switch(sizeof (*(ptr))) {					\
+	case 1:  __get_user_x(1,__ret_gu,__val_gu,ptr); break;		\
+	case 2:  __get_user_x(2,__ret_gu,__val_gu,ptr); break;		\
+	case 4:  __get_user_x(4,__ret_gu,__val_gu,ptr); break;		\
+	default: __get_user_x(X,__ret_gu,__val_gu,ptr); break;		\
+	}								\
+	(x) = (__typeof__(*(ptr)))__val_gu;				\
+	__ret_gu;							\
+})
+
+extern void __put_user_bad(void);
+
+#define put_user(x,ptr)							\
+  __put_user_check((__typeof__(*(ptr)))(x),(ptr),sizeof(*(ptr)))
+
+#define __get_user(x,ptr) \
+  __get_user_nocheck((x),(ptr),sizeof(*(ptr)))
+#define __put_user(x,ptr) \
+  __put_user_nocheck((__typeof__(*(ptr)))(x),(ptr),sizeof(*(ptr)))
+
+#define __put_user_nocheck(x,ptr,size)					\
+({									\
+	long __pu_err;							\
+	__put_user_size((x),(ptr),(size),__pu_err);			\
+	__pu_err;							\
+})
+
+
+#define __put_user_check(x,ptr,size)					\
+({									\
+	long __pu_err = -EFAULT;					\
+	__typeof__(*(ptr)) *__pu_addr = (ptr);				\
+	might_sleep();							\
+	if (access_ok(VERIFY_WRITE,__pu_addr,size))			\
+		__put_user_size((x),__pu_addr,(size),__pu_err);		\
+	__pu_err;							\
+})							
+
+#define __put_user_size(x,ptr,size,retval)				\
+do {									\
+	retval = 0;							\
+	__chk_user_ptr(ptr);						\
+	switch (size) {							\
+	  case 1: __put_user_asm(x,ptr,retval,"b"); break;		\
+	  case 2: __put_user_asm(x,ptr,retval,"h"); break;		\
+	  case 4: __put_user_asm(x,ptr,retval,""); break;		\
+	  case 8: __put_user_u64((__typeof__(*ptr))(x),ptr,retval); break;\
+	  default: __put_user_bad();					\
+	}								\
+} while (0)
+
+struct __large_struct { unsigned long buf[100]; };
+#define __m(x) (*(struct __large_struct *)(x))
+
+/*
+ * Tell gcc we read from memory instead of writing: this is because
+ * we do not write to any memory gcc knows about, so there are no
+ * aliasing issues.
+ */
+#define __put_user_asm(x, addr, err, itype)				\
+	__asm__ __volatile__(						\
+		"	.fillinsn\n"					\
+		"1:	st"itype" %1,@%2\n"				\
+		"	.fillinsn\n"					\
+		"2:\n"							\
+		".section .fixup,\"ax\"\n"				\
+		"	.balign 4\n"					\
+		"3:	ldi %0,%3\n"					\
+		"	seth r14,#high(2b)\n"				\
+		"	or3 r14,r14,#low(2b)\n"				\
+		"	jmp r14\n"					\
+		".previous\n"						\
+		".section __ex_table,\"a\"\n"				\
+		"	.balign 4\n"					\
+		"	.long 1b,3b\n"					\
+		".previous"						\
+		: "=r"(err)						\
+		: "r"(x), "r"(addr), "i"(-EFAULT), "0"(err)		\
+		: "r14", "memory")
+
+#if defined(__LITTLE_ENDIAN__)
+#define __put_user_u64(x, addr, err)                                    \
+        __asm__ __volatile__(                                           \
+                "       .fillinsn\n"                                    \
+                "1:     st %2,@%3\n"                                    \
+                "       .fillinsn\n"                                    \
+                "2:     st %1,@(4,%3)\n"                                \
+                "       .fillinsn\n"                                    \
+                "3:\n"                                                  \
+                ".section .fixup,\"ax\"\n"                              \
+                "       .balign 4\n"                                    \
+                "4:     ldi %0,%4\n"                                    \
+                "       seth r14,#high(3b)\n"                           \
+                "       or3 r14,r14,#low(3b)\n"                         \
+                "       jmp r14\n"                                      \
+                ".previous\n"                                           \
+                ".section __ex_table,\"a\"\n"                           \
+                "       .balign 4\n"                                    \
+                "       .long 1b,4b\n"                                  \
+                "       .long 2b,4b\n"                                  \
+                ".previous"                                             \
+                : "=r"(err)                                             \
+                : "r"((unsigned long)((unsigned long long)x >> 32)),    \
+                  "r"((unsigned long)x ),                               \
+                  "r"(addr), "i"(-EFAULT), "0"(err)                     \
+                : "r14", "memory")
+
+#elif defined(__BIG_ENDIAN__)
+#define __put_user_u64(x, addr, err)					\
+	__asm__ __volatile__(						\
+		"	.fillinsn\n"					\
+		"1:	st %1,@%3\n"					\
+		"	.fillinsn\n"					\
+		"2:	st %2,@(4,%3)\n"				\
+		"	.fillinsn\n"					\
+		"3:\n"							\
+		".section .fixup,\"ax\"\n"				\
+		"	.balign 4\n"					\
+		"4:	ldi %0,%4\n"					\
+		"	seth r14,#high(3b)\n"				\
+		"	or3 r14,r14,#low(3b)\n"				\
+		"	jmp r14\n"					\
+		".previous\n"						\
+		".section __ex_table,\"a\"\n"				\
+		"	.balign 4\n"					\
+		"	.long 1b,4b\n"					\
+		"	.long 2b,4b\n"					\
+		".previous"						\
+		: "=r"(err)						\
+		: "r"((unsigned long)((unsigned long long)x >> 32)),	\
+		  "r"((unsigned long)x ),				\
+		  "r"(addr), "i"(-EFAULT), "0"(err)			\
+		: "r14", "memory")
+#else
+#error no endian defined
+#endif
+
+#define __get_user_nocheck(x,ptr,size)					\
+({									\
+	long __gu_err, __gu_val;					\
+	__get_user_size(__gu_val,(ptr),(size),__gu_err);		\
+	(x) = (__typeof__(*(ptr)))__gu_val;				\
+	__gu_err;							\
+})
+
+extern long __get_user_bad(void);
+
+#define __get_user_size(x,ptr,size,retval)				\
+do {									\
+	retval = 0;							\
+	__chk_user_ptr(ptr);						\
+	switch (size) {							\
+	  case 1: __get_user_asm(x,ptr,retval,"ub"); break;		\
+	  case 2: __get_user_asm(x,ptr,retval,"uh"); break;		\
+	  case 4: __get_user_asm(x,ptr,retval,""); break;		\
+	  default: (x) = __get_user_bad();				\
+	}								\
+} while (0)
+
+#define __get_user_asm(x, addr, err, itype)				\
+	__asm__ __volatile__(						\
+		"	.fillinsn\n"					\
+		"1:	ld"itype" %1,@%2\n"				\
+		"	.fillinsn\n"					\
+		"2:\n"							\
+		".section .fixup,\"ax\"\n"				\
+		"	.balign 4\n"					\
+		"3:	ldi %0,%3\n"					\
+		"	seth r14,#high(2b)\n"				\
+		"	or3 r14,r14,#low(2b)\n"				\
+		"	jmp r14\n"					\
+		".previous\n"						\
+		".section __ex_table,\"a\"\n"				\
+		"	.balign 4\n"					\
+		"	.long 1b,3b\n"					\
+		".previous"						\
+		: "=r"(err), "=&r"(x)					\
+		: "r"(addr), "i"(-EFAULT), "0"(err)			\
+		: "r14", "memory")
+
+
+/*
+ * Copy To/From Userspace
+ */
+
+/* Generic arbitrary sized copy.  */
+/* Return the number of bytes NOT copied.  */
+#define __copy_user(to,from,size)					\
+do {									\
+	unsigned long __dst, __src, __c;				\
+	__asm__ __volatile__ (						\
+		"	mv	r14, %0\n"				\
+		"	or	r14, %1\n"				\
+		"	beq	%0, %1, 9f\n"				\
+		"	beqz	%2, 9f\n"				\
+		"	and3	r14, r14, #3\n"				\
+		"	bnez	r14, 2f\n"				\
+		"	and3	%2, %2, #3\n"				\
+		"	beqz	%3, 2f\n"				\
+		"	addi	%0, #-4		; word_copy \n"		\
+		"	.fillinsn\n"					\
+		"0:	ld	r14, @%1+\n"				\
+		"	addi	%3, #-1\n"				\
+		"	.fillinsn\n"					\
+		"1:	st	r14, @+%0\n"				\
+		"	bnez	%3, 0b\n"				\
+		"	beqz	%2, 9f\n"				\
+		"	addi	%0, #4\n"				\
+		"	.fillinsn\n"					\
+		"2:	ldb	r14, @%1	; byte_copy \n"		\
+		"	.fillinsn\n"					\
+		"3:	stb	r14, @%0\n"				\
+		"	addi	%1, #1\n"				\
+		"	addi	%2, #-1\n"				\
+		"	addi	%0, #1\n"				\
+		"	bnez	%2, 2b\n"				\
+		"	.fillinsn\n"					\
+		"9:\n"							\
+		".section .fixup,\"ax\"\n"				\
+		"	.balign 4\n"					\
+		"5:	addi	%3, #1\n"				\
+		"	addi	%1, #-4\n"				\
+		"	.fillinsn\n"					\
+		"6:	slli	%3, #2\n"				\
+		"	add	%2, %3\n"				\
+		"	addi	%0, #4\n"				\
+		"	.fillinsn\n"					\
+		"7:	seth	r14, #high(9b)\n"			\
+		"	or3	r14, r14, #low(9b)\n"			\
+		"	jmp	r14\n"					\
+		".previous\n"						\
+		".section __ex_table,\"a\"\n"				\
+		"	.balign 4\n"					\
+		"	.long 0b,6b\n"					\
+		"	.long 1b,5b\n"					\
+		"	.long 2b,9b\n"					\
+		"	.long 3b,9b\n"					\
+		".previous\n"						\
+		: "=&r"(__dst), "=&r"(__src), "=&r"(size), "=&r"(__c)	\
+		: "0"(to), "1"(from), "2"(size), "3"(size / 4)		\
+		: "r14", "memory");					\
+} while (0)
+
+#define __copy_user_zeroing(to,from,size)				\
+do {									\
+	unsigned long __dst, __src, __c;				\
+	__asm__ __volatile__ (						\
+		"	mv	r14, %0\n"				\
+		"	or	r14, %1\n"				\
+		"	beq	%0, %1, 9f\n"				\
+		"	beqz	%2, 9f\n"				\
+		"	and3	r14, r14, #3\n"				\
+		"	bnez	r14, 2f\n"				\
+		"	and3	%2, %2, #3\n"				\
+		"	beqz	%3, 2f\n"				\
+		"	addi	%0, #-4		; word_copy \n"		\
+		"	.fillinsn\n"					\
+		"0:	ld	r14, @%1+\n"				\
+		"	addi	%3, #-1\n"				\
+		"	.fillinsn\n"					\
+		"1:	st	r14, @+%0\n"				\
+		"	bnez	%3, 0b\n"				\
+		"	beqz	%2, 9f\n"				\
+		"	addi	%0, #4\n"				\
+		"	.fillinsn\n"					\
+		"2:	ldb	r14, @%1	; byte_copy \n"		\
+		"	.fillinsn\n"					\
+		"3:	stb	r14, @%0\n"				\
+		"	addi	%1, #1\n"				\
+		"	addi	%2, #-1\n"				\
+		"	addi	%0, #1\n"				\
+		"	bnez	%2, 2b\n"				\
+		"	.fillinsn\n"					\
+		"9:\n"							\
+		".section .fixup,\"ax\"\n"				\
+		"	.balign 4\n"					\
+		"5:	addi	%3, #1\n"				\
+		"	addi	%1, #-4\n"				\
+		"	.fillinsn\n"					\
+		"6:	slli	%3, #2\n"				\
+		"	add	%2, %3\n"				\
+		"	addi	%0, #4\n"				\
+		"	.fillinsn\n"					\
+		"7:	ldi	r14, #0		; store zero \n"	\
+		"	.fillinsn\n"					\
+		"8:	addi	%2, #-1\n"				\
+		"	stb	r14, @%0	; ACE? \n"		\
+		"	addi	%0, #1\n"				\
+		"	bnez	%2, 8b\n"				\
+		"	seth	r14, #high(9b)\n"			\
+		"	or3	r14, r14, #low(9b)\n"			\
+		"	jmp	r14\n"					\
+		".previous\n"						\
+		".section __ex_table,\"a\"\n"				\
+		"	.balign 4\n"					\
+		"	.long 0b,6b\n"					\
+		"	.long 1b,5b\n"					\
+		"	.long 2b,7b\n"					\
+		"	.long 3b,7b\n"					\
+		".previous\n"						\
+		: "=&r"(__dst), "=&r"(__src), "=&r"(size), "=&r"(__c)	\
+		: "0"(to), "1"(from), "2"(size), "3"(size / 4)		\
+		: "r14", "memory");					\
+} while (0)
+
+
+/* We let the __ versions of copy_from/to_user inline, because they're often
+ * used in fast paths and have only a small space overhead.
+ */
+static __inline__ unsigned long __generic_copy_from_user_nocheck(void *to, 
+	const void __user *from, unsigned long n)
+{
+	__copy_user_zeroing(to,from,n);
+	return n;
+}
+
+static __inline__ unsigned long __generic_copy_to_user_nocheck(void __user *to,
+	const void *from, unsigned long n)
+{
+	__copy_user(to,from,n);
+	return n;
+}
+
+unsigned long __generic_copy_to_user(void *, const void *, unsigned long);
+unsigned long __generic_copy_from_user(void *, const void *, unsigned long);
+
+#define copy_to_user(to,from,n)				\
+({							\
+	might_sleep();					\
+	__generic_copy_to_user((to),(from),(n));	\
+})
+
+#define copy_from_user(to,from,n)			\
+({							\
+	might_sleep();					\
+	__generic_copy_from_user((to),(from),(n));	\
+})
+
+#define __copy_to_user(to,from,n)			\
+	__generic_copy_to_user_nocheck((to),(from),(n))
+
+#define __copy_from_user(to,from,n)			\
+	__generic_copy_from_user_nocheck((to),(from),(n))
+
+long strncpy_from_user(char *dst, const char __user *src, long count);
+long __strncpy_from_user(char *dst, const char __user *src, long count);
+#define strlen_user(str) strnlen_user(str, ~0UL >> 1)
+long strnlen_user(const char __user *str, long n);
+unsigned long clear_user(void __user *mem, unsigned long len);
+unsigned long __clear_user(void __user *mem, unsigned long len);
+
+#endif /* _ASM_M32R_UACCESS_H */
+
diff -ruN linux-2.6.7.org/include/asm-m32r/ucontext.h linux-2.6.7/include/asm-m32r/ucontext.h
--- linux-2.6.7.org/include/asm-m32r/ucontext.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/ucontext.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,14 @@
+#ifndef _ASM_M32R_UCONTEXT_H
+#define _ASM_M32R_UCONTEXT_H
+
+/* orig : i386 2.4.18 */
+
+struct ucontext {
+	unsigned long	  uc_flags;
+	struct ucontext  *uc_link;
+	stack_t		  uc_stack;
+	struct sigcontext uc_mcontext;
+	sigset_t	  uc_sigmask;	/* mask last for extensibility */
+};
+
+#endif /* _ASM_M32R_UCONTEXT_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/unaligned.h linux-2.6.7/include/asm-m32r/unaligned.h
--- linux-2.6.7.org/include/asm-m32r/unaligned.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/unaligned.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,25 @@
+#ifndef _ASM_M32R_UNALIGNED_H
+#define _ASM_M32R_UNALIGNED_H
+
+/* $Id$ */
+
+/* orig : generic 2.4.18 */
+
+/*
+ * For the benefit of those who are trying to port Linux to another
+ * architecture, here are some C-language equivalents. 
+ */
+
+#include <asm/string.h>
+
+
+#define get_unaligned(ptr) \
+  ({ __typeof__(*(ptr)) __tmp; memmove(&__tmp, (ptr), sizeof(*(ptr))); __tmp; })
+
+#define put_unaligned(val, ptr)				\
+  ({ __typeof__(*(ptr)) __tmp = (val);			\
+     memmove((ptr), &__tmp, sizeof(*(ptr)));		\
+     (void)0; })
+
+
+#endif  /* _ASM_M32R_UNALIGNED_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/unistd.h linux-2.6.7/include/asm-m32r/unistd.h
--- linux-2.6.7.org/include/asm-m32r/unistd.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/unistd.h	2004-07-15 13:43:17.000000000 +0900
@@ -0,0 +1,488 @@
+#ifndef _ASM_M32R_UNISTD_H
+#define _ASM_M32R_UNISTD_H
+
+/* $Id$ */
+
+#include <asm/syscall.h>	/* SYSCALL_* */
+
+/*
+ * This file contains the system call numbers.
+ */
+
+#define __NR_restart_syscall	  0
+#define __NR_exit		  1
+#define __NR_fork		  2
+#define __NR_read		  3
+#define __NR_write		  4
+#define __NR_open		  5
+#define __NR_close		  6
+#define __NR_waitpid		  7
+#define __NR_creat		  8
+#define __NR_link		  9
+#define __NR_unlink		 10
+#define __NR_execve		 11
+#define __NR_chdir		 12
+#define __NR_time		 13
+#define __NR_mknod		 14
+#define __NR_chmod		 15
+#define __NR_lchown		 16
+#define __NR_break		 17
+#define __NR_oldstat		 18
+#define __NR_lseek		 19
+#define __NR_getpid		 20
+#define __NR_mount		 21
+#define __NR_umount		 22
+#define __NR_setuid		 23
+#define __NR_getuid		 24
+#define __NR_stime		 25
+#define __NR_ptrace		 26
+#define __NR_alarm		 27
+#define __NR_oldfstat		 28
+#define __NR_pause		 29
+#define __NR_utime		 30
+#define __NR_cacheflush		 31 /* old #define __NR_stty		 31*/
+#define __NR_cachectl		 32 /* old #define __NR_gtty		 32*/
+#define __NR_access		 33
+#define __NR_nice		 34
+#define __NR_ftime		 35
+#define __NR_sync		 36
+#define __NR_kill		 37
+#define __NR_rename		 38
+#define __NR_mkdir		 39
+#define __NR_rmdir		 40
+#define __NR_dup		 41
+#define __NR_pipe		 42
+#define __NR_times		 43
+#define __NR_prof		 44
+#define __NR_brk		 45
+#define __NR_setgid		 46
+#define __NR_getgid		 47
+#define __NR_signal		 48
+#define __NR_geteuid		 49
+#define __NR_getegid		 50
+#define __NR_acct		 51
+#define __NR_umount2		 52
+#define __NR_lock		 53
+#define __NR_ioctl		 54
+#define __NR_fcntl		 55
+#define __NR_mpx		 56
+#define __NR_setpgid		 57
+#define __NR_ulimit		 58
+#define __NR_oldolduname	 59
+#define __NR_umask		 60
+#define __NR_chroot		 61
+#define __NR_ustat		 62
+#define __NR_dup2		 63
+#define __NR_getppid		 64
+#define __NR_getpgrp		 65
+#define __NR_setsid		 66
+#define __NR_sigaction		 67
+#define __NR_sgetmask		 68
+#define __NR_ssetmask		 69
+#define __NR_setreuid		 70
+#define __NR_setregid		 71
+#define __NR_sigsuspend		 72
+#define __NR_sigpending		 73
+#define __NR_sethostname	 74
+#define __NR_setrlimit		 75
+#define __NR_getrlimit		 76	/* Back compatible 2Gig limited rlimit */
+#define __NR_getrusage		 77
+#define __NR_gettimeofday	 78
+#define __NR_settimeofday	 79
+#define __NR_getgroups		 80
+#define __NR_setgroups		 81
+#define __NR_select		 82
+#define __NR_symlink		 83
+#define __NR_oldlstat		 84
+#define __NR_readlink		 85
+#define __NR_uselib		 86
+#define __NR_swapon		 87
+#define __NR_reboot		 88
+#define __NR_readdir		 89
+#define __NR_mmap		 90
+#define __NR_munmap		 91
+#define __NR_truncate		 92
+#define __NR_ftruncate		 93
+#define __NR_fchmod		 94
+#define __NR_fchown		 95
+#define __NR_getpriority	 96
+#define __NR_setpriority	 97
+#define __NR_profil		 98
+#define __NR_statfs		 99
+#define __NR_fstatfs		100
+#define __NR_ioperm		101
+#define __NR_socketcall		102
+#define __NR_syslog		103
+#define __NR_setitimer		104
+#define __NR_getitimer		105
+#define __NR_stat		106
+#define __NR_lstat		107
+#define __NR_fstat		108
+#define __NR_olduname		109
+#define __NR_iopl		110
+#define __NR_vhangup		111
+#define __NR_idle		112
+#define __NR_vm86old		113
+#define __NR_wait4		114
+#define __NR_swapoff		115
+#define __NR_sysinfo		116
+#define __NR_ipc		117
+#define __NR_fsync		118
+#define __NR_sigreturn		119
+#define __NR_clone		120
+#define __NR_setdomainname	121
+#define __NR_uname		122
+#define __NR_modify_ldt		123
+#define __NR_adjtimex		124
+#define __NR_mprotect		125
+#define __NR_sigprocmask	126
+#define __NR_create_module	127
+#define __NR_init_module	128
+#define __NR_delete_module	129
+#define __NR_get_kernel_syms	130
+#define __NR_quotactl		131
+#define __NR_getpgid		132
+#define __NR_fchdir		133
+#define __NR_bdflush		134
+#define __NR_sysfs		135
+#define __NR_personality	136
+#define __NR_afs_syscall	137 /* Syscall for Andrew File System */
+#define __NR_setfsuid		138
+#define __NR_setfsgid		139
+#define __NR__llseek		140
+#define __NR_getdents		141
+#define __NR__newselect		142
+#define __NR_flock		143
+#define __NR_msync		144
+#define __NR_readv		145
+#define __NR_writev		146
+#define __NR_getsid		147
+#define __NR_fdatasync		148
+#define __NR__sysctl		149
+#define __NR_mlock		150
+#define __NR_munlock		151
+#define __NR_mlockall		152
+#define __NR_munlockall		153
+#define __NR_sched_setparam		154
+#define __NR_sched_getparam		155
+#define __NR_sched_setscheduler		156
+#define __NR_sched_getscheduler		157
+#define __NR_sched_yield		158
+#define __NR_sched_get_priority_max	159
+#define __NR_sched_get_priority_min	160
+#define __NR_sched_rr_get_interval	161
+#define __NR_nanosleep		162
+#define __NR_mremap		163
+#define __NR_setresuid		164
+#define __NR_getresuid		165
+#define __NR_tas		166
+#define __NR_query_module	167
+#define __NR_poll		168
+#define __NR_nfsservctl		169
+#define __NR_setresgid		170
+#define __NR_getresgid		171
+#define __NR_prctl              172
+#define __NR_rt_sigreturn	173
+#define __NR_rt_sigaction	174
+#define __NR_rt_sigprocmask	175
+#define __NR_rt_sigpending	176
+#define __NR_rt_sigtimedwait	177
+#define __NR_rt_sigqueueinfo	178
+#define __NR_rt_sigsuspend	179
+#define __NR_pread64		180
+#define __NR_pwrite64		181
+#define __NR_chown		182
+#define __NR_getcwd		183
+#define __NR_capget		184
+#define __NR_capset		185
+#define __NR_sigaltstack	186
+#define __NR_sendfile		187
+#define __NR_getpmsg		188	/* some people actually want streams */
+#define __NR_putpmsg		189	/* some people actually want streams */
+#define __NR_vfork		190
+#define __NR_ugetrlimit		191	/* SuS compliant getrlimit */
+#define __NR_mmap2		192
+#define __NR_truncate64		193
+#define __NR_ftruncate64	194
+#define __NR_stat64		195
+#define __NR_lstat64		196
+#define __NR_fstat64		197
+#define __NR_lchown32		198
+#define __NR_getuid32		199
+#define __NR_getgid32		200
+#define __NR_geteuid32		201
+#define __NR_getegid32		202
+#define __NR_setreuid32		203
+#define __NR_setregid32		204
+#define __NR_getgroups32	205
+#define __NR_setgroups32	206
+#define __NR_fchown32		207
+#define __NR_setresuid32	208
+#define __NR_getresuid32	209
+#define __NR_setresgid32	210
+#define __NR_getresgid32	211
+#define __NR_chown32		212
+#define __NR_setuid32		213
+#define __NR_setgid32		214
+#define __NR_setfsuid32		215
+#define __NR_setfsgid32		216
+#define __NR_pivot_root		217
+#define __NR_mincore		218
+#define __NR_madvise		219
+#define __NR_madvise1		219	/* delete when C lib stub is removed */
+#define __NR_getdents64		220
+#define __NR_fcntl64		221
+#define __NR_security           223     /* syscall for security modules */
+#define __NR_gettid             224
+#define __NR_readahead          225
+#define __NR_setxattr           226
+#define __NR_lsetxattr          227
+#define __NR_fsetxattr          228
+#define __NR_getxattr           229
+#define __NR_lgetxattr          230
+#define __NR_fgetxattr          231
+#define __NR_listxattr          232
+#define __NR_llistxattr         233
+#define __NR_flistxattr         234
+#define __NR_removexattr        235
+#define __NR_lremovexattr       236
+#define __NR_fremovexattr       237
+#define __NR_tkill		238
+#define __NR_sendfile64		239
+#define __NR_futex		240
+#define __NR_sched_setaffinity	241
+#define __NR_sched_getaffinity	242
+#define __NR_set_thread_area    243
+#define __NR_get_thread_area    244
+#define __NR_io_setup           245
+#define __NR_io_destroy         246
+#define __NR_io_getevents       247
+#define __NR_io_submit          248
+#define __NR_io_cancel          249
+#define __NR_fadvise64          250
+
+#define __NR_exit_group         252
+#define __NR_lookup_dcookie     253
+#define __NR_epoll_create       254
+#define __NR_epoll_ctl          255
+#define __NR_epoll_wait         256
+#define __NR_remap_file_pages   257
+#define __NR_set_tid_address    258
+#define __NR_timer_create       259
+#define __NR_timer_settime      (__NR_timer_create+1)
+#define __NR_timer_gettime      (__NR_timer_create+2)
+#define __NR_timer_getoverrun   (__NR_timer_create+3)
+#define __NR_timer_delete       (__NR_timer_create+4)
+#define __NR_clock_settime      (__NR_timer_create+5)
+#define __NR_clock_gettime      (__NR_timer_create+6)
+#define __NR_clock_getres       (__NR_timer_create+7)
+#define __NR_clock_nanosleep    (__NR_timer_create+8)
+#define __NR_statfs64           268
+#define __NR_fstatfs64          269
+#define __NR_tgkill             270
+#define __NR_utimes             271
+#define __NR_fadvise64_64       272
+#define __NR_vserver            273
+#define __NR_mbind              274
+#define __NR_get_mempolicy      275
+#define __NR_set_mempolicy      276
+#define __NR_mq_open            277
+#define __NR_mq_unlink          (__NR_mq_open+1)
+#define __NR_mq_timedsend       (__NR_mq_open+2)
+#define __NR_mq_timedreceive    (__NR_mq_open+3)
+#define __NR_mq_notify          (__NR_mq_open+4)
+#define __NR_mq_getsetattr      (__NR_mq_open+5)
+#define __NR_kexec_load		283
+ 
+#define NR_syscalls     284
+
+/* user-visible error numbers are in the range -1 - -124: see <asm-m32r/errno.h> */
+
+#define __syscall_return(type, res) \
+do { \
+	if ((unsigned long)(res) >= (unsigned long)(-125)) { \
+	/* Avoid using "res" which is declared to be in register r0; \
+           errno might expand to a function call and clobber it.  */ \
+                int __err = -(res); \
+                errno = __err; \
+                res = -1; \
+	} \
+	return (type) (res); \
+} while (0)
+
+#define _syscall0(type,name) \
+type name(void) \
+{ \
+register long __scno __asm__ ("r7") = __NR_##name; \
+register long __res __asm__("r0"); \
+__asm__ __volatile__ (\
+	"trap #" SYSCALL_VECTOR \
+	: "=r" (__res) \
+	: "r" (__scno) \
+	: "memory"); \
+__syscall_return(type,__res); \
+}
+
+#define _syscall1(type,name,type1,arg1) \
+type name(type1 arg1) \
+{ \
+register long __scno __asm__ ("r7") = __NR_##name; \
+register long __res __asm__ ("r0") = (long)(arg1); \
+__asm__ __volatile__ (\
+	"trap #" SYSCALL_VECTOR \
+	: "=r" (__res) \
+	: "r" (__scno), "0" (__res) \
+	: "memory"); \
+__syscall_return(type,__res); \
+}
+
+#define _syscall2(type,name,type1,arg1,type2,arg2) \
+type name(type1 arg1,type2 arg2) \
+{ \
+register long __scno __asm__ ("r7") = __NR_##name; \
+register long __arg2 __asm__ ("r1") = (long)(arg2); \
+register long __res __asm__ ("r0") = (long)(arg1); \
+__asm__ __volatile__ (\
+	"trap #" SYSCALL_VECTOR \
+	: "=r" (__res) \
+	: "r" (__scno), "0" (__res), "r" (__arg2) \
+	: "memory"); \
+__syscall_return(type,__res); \
+}
+
+#define _syscall3(type,name,type1,arg1,type2,arg2,type3,arg3) \
+type name(type1 arg1,type2 arg2,type3 arg3) \
+{ \
+register long __scno __asm__ ("r7") = __NR_##name; \
+register long __arg3 __asm__ ("r2") = (long)(arg3); \
+register long __arg2 __asm__ ("r1") = (long)(arg2); \
+register long __res __asm__ ("r0") = (long)(arg1); \
+__asm__ __volatile__ (\
+	"trap #" SYSCALL_VECTOR \
+	: "=r" (__res) \
+	: "r" (__scno), "0" (__res), "r" (__arg2), \
+		"r" (__arg3) \
+	: "memory"); \
+__syscall_return(type,__res); \
+}
+
+#define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4) \
+type name(type1 arg1,type2 arg2,type3 arg3,type4 arg4) \
+{ \
+register long __scno __asm__ ("r7") = __NR_##name; \
+register long __arg4 __asm__ ("r3") = (long)(arg4); \
+register long __arg3 __asm__ ("r2") = (long)(arg3); \
+register long __arg2 __asm__ ("r1") = (long)(arg2); \
+register long __res __asm__ ("r0") = (long)(arg1); \
+__asm__ __volatile__ (\
+	"trap #" SYSCALL_VECTOR \
+	: "=r" (__res) \
+	: "r" (__scno), "0" (__res), "r" (__arg2), \
+		"r" (__arg3), "r" (__arg4) \
+	: "memory"); \
+__syscall_return(type,__res); \
+}
+
+#define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4, \
+          type5,arg5) \
+type name(type1 arg1,type2 arg2,type3 arg3,type4 arg4,type5 arg5) \
+{ \
+register long __scno __asm__ ("r7") = __NR_##name; \
+register long __arg5 __asm__ ("r4") = (long)(arg5); \
+register long __arg4 __asm__ ("r3") = (long)(arg4); \
+register long __arg3 __asm__ ("r2") = (long)(arg3); \
+register long __arg2 __asm__ ("r1") = (long)(arg2); \
+register long __res __asm__ ("r0") = (long)(arg1); \
+__asm__ __volatile__ (\
+	"trap #" SYSCALL_VECTOR \
+	: "=r" (__res) \
+	: "r" (__scno), "0" (__res), "r" (__arg2), \
+		"r" (__arg3), "r" (__arg4), "r" (__arg5) \
+	: "memory"); \
+__syscall_return(type,__res); \
+}
+
+#ifdef __KERNEL__
+#define __ARCH_WANT_IPC_PARSE_VERSION
+#define __ARCH_WANT_OLD_READDIR
+#define __ARCH_WANT_OLD_STAT
+#define __ARCH_WANT_STAT64
+#define __ARCH_WANT_SYS_ALARM
+#define __ARCH_WANT_SYS_GETHOSTNAME
+#define __ARCH_WANT_SYS_PAUSE
+#define __ARCH_WANT_SYS_SGETMASK
+#define __ARCH_WANT_SYS_SIGNAL
+#define __ARCH_WANT_SYS_TIME
+#define __ARCH_WANT_SYS_UTIME
+#define __ARCH_WANT_SYS_WAITPID
+#define __ARCH_WANT_SYS_SOCKETCALL
+#define __ARCH_WANT_SYS_FADVISE64
+#define __ARCH_WANT_SYS_GETPGRP
+#define __ARCH_WANT_SYS_LLSEEK
+#define __ARCH_WANT_SYS_NICE
+#define __ARCH_WANT_SYS_OLD_GETRLIMIT
+#define __ARCH_WANT_SYS_OLDUMOUNT
+#define __ARCH_WANT_SYS_SIGPENDING
+#define __ARCH_WANT_SYS_SIGPROCMASK
+#define __ARCH_WANT_SYS_RT_SIGACTION
+#endif
+
+#ifdef __KERNEL_SYSCALLS__
+
+#include <linux/compiler.h>
+#include <linux/types.h>
+#include <linux/linkage.h>
+#include <asm/ptrace.h>
+
+/*
+ * we need this inline - forking from kernel space will result
+ * in NO COPY ON WRITE (!!!), until an execve is executed. This
+ * is no problem, but for the stack. This is handled by not letting
+ * main() use the stack at all after fork(). Thus, no function
+ * calls - which means inline code for fork too, as otherwise we
+ * would use the stack upon exit from 'fork()'.
+ *
+ * Actually only pause and fork are needed inline, so that there
+ * won't be any messing with the stack from main(), but we define
+ * some others too.
+ */
+static __inline__ _syscall0(pid_t,setsid)
+static __inline__ _syscall3(int,write,int,fd,const char *,buf,off_t,count)
+static __inline__ _syscall3(int,read,int,fd,char *,buf,off_t,count)
+static __inline__ _syscall3(off_t,lseek,int,fd,off_t,offset,int,count)
+static __inline__ _syscall1(int,dup,int,fd)
+static __inline__ _syscall3(int,execve,const char *,file,char **,argv,char **,envp)
+static __inline__ _syscall3(int,open,const char *,file,int,flag,int,mode)
+static __inline__ _syscall1(int,close,int,fd)
+static __inline__ _syscall3(pid_t,waitpid,pid_t,pid,int *,wait_stat,int,options)
+
+asmlinkage int sys_modify_ldt(int func, void __user *ptr, unsigned long bytecount);
+asmlinkage long sys_mmap2(unsigned long addr, unsigned long len,
+			  unsigned long prot, unsigned long flags,
+			  unsigned long fd, unsigned long pgoff);
+asmlinkage int sys_execve(struct pt_regs regs);
+asmlinkage int sys_clone(struct pt_regs regs);
+asmlinkage int sys_fork(struct pt_regs regs);
+asmlinkage int sys_vfork(struct pt_regs regs);
+asmlinkage int sys_pipe(unsigned long __user *fildes);
+asmlinkage int sys_ptrace(long request, long pid, long addr, long data);
+asmlinkage long sys_iopl(unsigned long unused);
+struct sigaction;
+asmlinkage long sys_rt_sigaction(int sig,
+				 const struct sigaction __user *act,
+				 struct sigaction __user *oact,
+				 size_t sigsetsize);
+
+#endif /* __KERNEL_SYSCALLS__ */
+
+/*
+ * "Conditional" syscalls
+ *
+ * What we want is __attribute__((weak,alias("sys_ni_syscall"))),
+ * but it doesn't work on all toolchains, so we just do it by hand
+ */
+#ifndef cond_syscall
+#define cond_syscall(x) asm(".weak\t" #x "\n\t.set\t" #x ",sys_ni_syscall");
+#endif
+
+#endif /* _ASM_M32R_UNISTD_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/user.h linux-2.6.7/include/asm-m32r/user.h
--- linux-2.6.7.org/include/asm-m32r/user.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/user.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,59 @@
+#ifndef _ASM_M32R_USER_H
+#define _ASM_M32R_USER_H
+
+/* $Id$ */
+
+/* orig : sh 2.4.18
+ * mod  : remove fpu registers 
+ */
+
+#include <linux/types.h>
+#include <asm/processor.h>
+#include <asm/ptrace.h>
+#include <asm/page.h>
+
+/*
+ * Core file format: The core file is written in such a way that gdb
+ * can understand it and provide useful information to the user (under
+ * linux we use the `trad-core' bfd).
+ *
+ * The actual file contents are as follows:
+ * UPAGE: 1 page consisting of a user struct that tells gdb
+ *	what is present in the file.  Directly after this is a
+ *	copy of the task_struct, which is currently not used by gdb,
+ *	but it may come in handy at some point.  All of the registers
+ *	are stored as part of the upage.  The upage should always be
+ *	only one page.
+ * DATA: The data area is stored.  We use current->end_text to
+ *	current->brk to pick up all of the user variables, plus any memory
+ *	that may have been sbrk'ed.  No attempt is made to determine if a
+ *	page is demand-zero or if a page is totally unused, we just cover
+ *	the entire range.  All of the addresses are rounded in such a way
+ *	that an integral number of pages is written.
+ * STACK: We need the stack information in order to get a meaningful
+ *	backtrace.  We need to write the data from usp to
+ *	current->start_stack, so we round each of these off in order to be 
+ *	able to write an integer number of pages.
+ */
+
+struct user {
+	struct pt_regs	regs;			/* entire machine state */
+	size_t		u_tsize;		/* text size (pages) */
+	size_t		u_dsize;		/* data size (pages) */
+	size_t		u_ssize;		/* stack size (pages) */
+	unsigned long	start_code;		/* text starting address */
+	unsigned long	start_data;		/* data starting address */
+	unsigned long	start_stack;		/* stack starting address */
+	long int	signal;			/* signal causing core dump */
+	struct regs *	u_ar0;			/* help gdb find registers */
+	unsigned long	magic;			/* identifies a core file */
+	char		u_comm[32];		/* user command name */
+};
+
+#define NBPG			PAGE_SIZE
+#define UPAGES			1
+#define HOST_TEXT_START_ADDR	(u.start_code)
+#define HOST_DATA_START_ADDR	(u.start_data)
+#define HOST_STACK_END_ADDR	(u.start_stack + u.u_ssize * NBPG)
+
+#endif /* _ASM_M32R_USER_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/vga.h linux-2.6.7/include/asm-m32r/vga.h
--- linux-2.6.7.org/include/asm-m32r/vga.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/vga.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,22 @@
+#ifndef _ASM_M32R_VGA_H
+#define _ASM_M32R_VGA_H
+
+/* $Id$ */
+
+/*
+ *	Access to VGA videoram
+ *
+ *	(c) 1998 Martin Mares <mj@ucw.cz>
+ */
+
+/*
+ *	On the PC, we can just recalculate addresses and then
+ *	access the videoram directly without any black magic.
+ */
+
+#define VGA_MAP_MEM(x) (unsigned long)phys_to_virt(x)
+
+#define vga_readb(x) (*(x))
+#define vga_writeb(x,y) (*(y) = (x))
+
+#endif  /* _ASM_M32R_VGA_H */
diff -ruN linux-2.6.7.org/include/asm-m32r/xor.h linux-2.6.7/include/asm-m32r/xor.h
--- linux-2.6.7.org/include/asm-m32r/xor.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-2.6.7/include/asm-m32r/xor.h	2003-09-09 10:16:45.000000000 +0900
@@ -0,0 +1,8 @@
+#ifndef _ASM_M32R_XOR_H
+#define _ASM_M32R_XOR_H
+
+/* $Id$ */
+
+#include <asm-generic/xor.h>
+
+#endif  /* _ASM_M32R_XOR_H */
