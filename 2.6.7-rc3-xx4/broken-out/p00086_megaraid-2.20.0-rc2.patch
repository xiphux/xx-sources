diff -Naur linux-2.6.6.orig/drivers/scsi/Kconfig linux-2.6.6/drivers/scsi/Kconfig
--- linux-2.6.6.orig/drivers/scsi/Kconfig	Sun May  9 22:33:19 2004
+++ linux-2.6.6/drivers/scsi/Kconfig	Sat May 15 13:36:16 2004
@@ -395,15 +395,7 @@
 	  To compile this driver as a module, choose M here: the
 	  module will be called in2000.
 
-config SCSI_MEGARAID
-	tristate "AMI MegaRAID support"
-	depends on PCI && SCSI
-	help
-	  This driver supports the AMI MegaRAID 418, 428, 438, 466, 762, 490
-	  and 467 SCSI host adapters.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called megaraid.
+source "drivers/scsi/megaraid/Kconfig.megaraid"
 
 config SCSI_SATA
 	bool "Serial ATA (SATA) support"
diff -Naur linux-2.6.6.orig/drivers/scsi/megaraid/Kconfig.megaraid linux-2.6.6/drivers/scsi/megaraid/Kconfig.megaraid
--- linux-2.6.6.orig/drivers/scsi/megaraid/Kconfig.megaraid	Wed Dec 31 19:00:00 1969
+++ linux-2.6.6/drivers/scsi/megaraid/Kconfig.megaraid	Sat May 15 13:35:04 2004
@@ -0,0 +1,73 @@
+config MEGARAID_NEWGEN
+	bool "LSI Logic New Generation RAID Device Drivers"
+	depends on PCI && SCSI
+	default y
+	help
+	LSI Logic RAID Device Drivers
+
+config MEGARAID_MM
+	tristate "LSI Logic Management Module (New Driver)"
+	depends on PCI && SCSI && MEGARAID_NEWGEN
+	default m
+	help
+	Management Module provides ioctl, sysfs support for LSI Logic
+	RAID controllers.
+	To compile this driver as a module, choose M here: the
+	module will be called megaraid_mm
+
+
+config MEGARAID_MAILBOX
+	tristate "LSI Logic MegaRAID Driver (New Driver)"
+	depends on PCI && SCSI && MEGARAID_MM
+	default $MEGARAID_MM
+	help
+	List of supported controllers
+
+	OEM	Product Name		Ser	VID :DID :SVID:SSID
+	---	------------		---	---- ---- ---- ----
+	Dell	PERC3/Di		N/A	1028:000E:1028:0123
+	Dell	PERC4/SC		520	1000:1960:1028:0520
+	Dell	PERC4/DC		518	1000:1960:1028:0518
+	Dell	PERC4/QC		531	1000:0407:1028:0531
+	Dell	PERC4/Di		N/A	1028:000F:1028:014A
+	Dell	PERC 4e/Si		N/A	1028:0013:1028:016c
+	Dell	PERC 4e/Di		N/A	1028:0013:1028:016d
+	Dell	PERC 4e/Di		N/A	1028:0013:1028:016e
+	Dell	PERC 4e/Di		N/A	1028:0013:1028:016f
+	Dell	PERC 4e/Di		N/A	1028:0013:1028:0170
+	Dell	PERC 4e/DC		N/A	1000:0408:1028:0002
+	Dell	PERC 4e/SC		N/A	1000:0408:1028:0001
+
+	LSI	MegaRAID SCSI 320-0	520-0	1000:1960:1000:A520
+	LSI	MegaRAID SCSI 320-1	520	1000:1960:1000:0520
+	LSI	MegaRAID SCSI 320-2	518	1000:1960:1000:0518
+	LSI	MegaRAID SCSI 320-0X	EP055	1000:0407:1000:0530
+	LSI	MegaRAID SCSI 320-2X	532	1000:0407:1000:0532
+	LSI	MegaRAID SCSI 320-4X	531	1000:0407:1000:0531
+
+	LSI	MegaRAID SCSI 320-1E	N/A	1000:0408:1000:0001
+	LSI	MegaRAID SCSI 320-2E	EP078	1000:0408:1000:0002
+	LSI	MegaRAID SCSI 320-4E
+
+	LSI	MegaRAID SATA 150-2	534	1095:3112:1000:0534
+	LSI	MegaRAID SATA 150-4	523	1000:1960:1000:4523
+	LSI	MegaRAID SATA 150-6	523	1000:1960:1000:0523
+	LSI	MegaRAID SATA 150-4X		1000:0409:1000:1504
+	LSI	MegaRAID SATA 150-8X		1000:0409:1000:1508
+
+	To compile this driver as a module, choose M here: the
+	module will be called megaraid
+
+if MEGARAID_NEWGEN=n
+config MEGARAID_LEGACY
+	tristate "LSI Logic Legacy MegaRAID Driver"
+	depends on PCI && SCSI
+	default m
+	help
+	This driver supports the AMI MegaRAID 418, 428, 438, 466, 762, 490
+	and 467 SCSI host adapters. This driver also support the all U320
+	RAID controllers
+
+	To compile this driver as a module, choose M here: the
+	module will be called megaraid
+endif
diff -Naur linux-2.6.6.orig/drivers/scsi/megaraid/Makefile linux-2.6.6/drivers/scsi/megaraid/Makefile
--- linux-2.6.6.orig/drivers/scsi/megaraid/Makefile	Wed Dec 31 19:00:00 1969
+++ linux-2.6.6/drivers/scsi/megaraid/Makefile	Sat May 15 13:35:04 2004
@@ -0,0 +1,4 @@
+megaraid-objs			:= megaraid_mbox.o megaraid_clib.o
+
+obj-$(CONFIG_MEGARAID_MAILBOX)	+= megaraid.o
+obj-$(CONFIG_MEGARAID_MM)	+= megaraid_mm.o
diff -Naur linux-2.6.6.orig/drivers/scsi/megaraid/kdep.h linux-2.6.6/drivers/scsi/megaraid/kdep.h
--- linux-2.6.6.orig/drivers/scsi/megaraid/kdep.h	Wed Dec 31 19:00:00 1969
+++ linux-2.6.6/drivers/scsi/megaraid/kdep.h	Sat May 15 13:35:04 2004
@@ -0,0 +1,47 @@
+/*
+ *
+ *			Linux MegaRAID device driver
+ *
+ * Copyright (c) 2003-2004  LSI Logic Corporation.
+ *
+ *	   This program is free software; you can redistribute it and/or
+ *	   modify it under the terms of the GNU General Public License
+ *	   as published by the Free Software Foundation; either version
+ *	   2 of the License, or (at your option) any later version.
+ *
+ * FILE		: kdep.h
+ */
+
+#include <linux/mm.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/delay.h>
+#include <linux/version.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/proc_fs.h>
+#include <linux/pci.h>
+#include <linux/list.h>
+#include <linux/moduleparam.h>
+#include <linux/blkdev.h>
+#include "../scsi.h"
+#include <scsi/scsi_host.h>
+#include <scsi/scsicam.h>
+
+#ifndef _KDEP_H_
+#define _KDEP_H_
+
+// conversion from scsi command
+#define SCP2HOST(scp)			(scp)->device->host	// to host
+#define SCP2HOSTDATA(scp)		SCP2HOST(scp)->hostdata	// to soft state
+#define SCP2CHANNEL(scp)		(scp)->device->channel	// to channel
+#define SCP2TARGET(scp)			(scp)->device->id	// to target
+#define SCP2LUN(scp)			(scp)->device->lun	// to LUN
+
+// generic macro to convert scsi command and host to controller's soft state
+#define SCSIHOST2ADAP(host)	(((caddr_t *)(host->hostdata))[0])
+#define SCP2ADAPTER(scp)	(adapter_t *)SCSIHOST2ADAP(SCP2HOST(scp))
+
+#endif	// _KDEP_H_
+
+/* vim: set ts=8 sw=8 tw=78 ai si: */
diff -Naur linux-2.6.6.orig/drivers/scsi/megaraid/lsi_defs.h linux-2.6.6/drivers/scsi/megaraid/lsi_defs.h
--- linux-2.6.6.orig/drivers/scsi/megaraid/lsi_defs.h	Wed Dec 31 19:00:00 1969
+++ linux-2.6.6/drivers/scsi/megaraid/lsi_defs.h	Sat May 15 13:35:04 2004
@@ -0,0 +1,252 @@
+/*
+ * lsi_defs.h	: Information common to all LSI's intelligent controllers
+ */
+
+#ifndef LSI_COMMON_DEFS
+#define LSI_COMMON_DEFS
+
+/*
+ * Definitions common for all LSI modules
+ */
+
+#define MAX_CDB_LEN	  		   	10
+#define MAX_EXT_CDB_LEN				16
+#define MAX_REQ_SENSE_LEN			0x20
+
+#define	LSI_MAX_LOGICAL_DRIVES_64LD		(64+1)
+#define LSI_MAX_PHYSICAL_DEVICES		60
+#define LSI_MAX_CHANNELS			16
+#define LSI_MAX_DEVICES_PER_CHANNEL		16
+
+typedef enum { MRAID_FALSE, MRAID_TRUE } bool_t;
+typedef enum { MRAID_SUCCESS, MRAID_FAILURE, MRAID_BUSY } status_t;
+
+/**
+ * con_log() - console log routine
+ * @param level		: indicates the severity of the message.
+ * @fparam mt		: format string
+ *
+ * con_log displays the error messages on the console based on the current
+ * debug level. Also it attaches the appropriate kernel severity level with
+ * the message.
+ *
+ *
+ * consolge messages debug levels
+ */
+#define	CL_ANN		0	/* print unconditionally, announcements */
+#define CL_DLEVEL1	1	/* debug level 1, informative */
+#define CL_DLEVEL2	2	/* debug level 2, verbose */
+#define CL_DLEVEL3	3	/* debug level 3, very verbose */
+
+#define	con_log(level, fmt) if (LSI_DBGLVL >= level) printk fmt;
+
+/*
+ * Definitions & Declarations needed to use common management module
+ */
+
+#define MEGAIOC_MAGIC		'm'
+#define MEGAIOCCMD		_IOWR(MEGAIOC_MAGIC, 0, mimd_t)
+
+#define MEGAIOC_QNADAP		'm'	/* Query # of adapters		*/
+#define MEGAIOC_QDRVRVER	'e'	/* Query driver version		*/
+#define MEGAIOC_QADAPINFO   	'g'	/* Query adapter information	*/
+
+#define USCSICMD		0x80
+#define VENDOR_SPECIFIC_CMDS	0xE0
+#define MEGA_INTERNAL_CMD	(VENDOR_SPECIFIC_CMDS + 0x01)
+
+#define UIOC_RD			0x00001
+#define UIOC_WR			0x00002
+
+#define MBOX_CMD		0x00000
+#define GET_DRIVER_VER		0x10000
+#define GET_N_ADAP		0x20000
+#define GET_ADAP_INFO		0x30000
+#define GET_CAP			0x40000
+#define GET_STATS		0x50000
+#define GET_IOCTL_VERSION	0x01
+
+#define MAX_LSI_CMN_ADAPS	16
+
+#define EXT_IOCTL_SIGN_SZ	16
+#define EXT_IOCTL_SIGN		"$$_EXTD_IOCTL_$$"
+
+#define	MBOX_LEGACY		0x00		/* ioctl has legacy mbox*/
+#define MBOX_HPE		0x01		/* ioctl has hpe mbox	*/
+
+#define	APPTYPE_MIMD		0x00		/* old existing apps	*/
+#define APPTYPE_UIOC		0x01		/* new apps using uioc	*/
+
+#define IOCTL_ISSUE		0x00000001	/* Issue ioctl		*/
+#define IOCTL_ABORT		0x00000002	/* Abort previous ioctl	*/
+
+#define DRVRTYPE_MBOX		0x00000001	/* regular mbox driver	*/
+#define DRVRTYPE_HPE		0x00000002	/* new hpe driver	*/
+
+#define LC_SUCCESS		0x00000000	/* Generic success code	*/
+#define	LC_EFULL		0x00000001	/* Exceeded max capacity*/
+#define LC_EINVAL		0x00000002	/* Invalid argument	*/
+#define LC_EEXISTS		0x00000004	/* Already exists	*/
+#define LC_ENOADP		0x00000008	/* Adp not found	*/
+#define LC_ENOTSUPP		0x00000010	/* Op not supported	*/
+#define LC_ETIME		0x00000020	/* Op timedout		*/
+#define LC_PENDING		0x00000040	/* ioctl pending @ lld	*/
+#define LC_UNKNOWN		0x00000080	/* Unknown err frm lld	*/
+#define LC_ENOMEM		0x00000100	/* Mem alloc failed	*/
+
+#define MKADAP(adapno)	(MEGAIOC_MAGIC << 8 | (adapno) )
+#define GETADAP(mkadap)	((mkadap) ^ MEGAIOC_MAGIC << 8)
+
+/**
+ * struct uioc_t - the common ioctl packet structure
+ *
+ * @signature	: Must be "$$_EXTD_IOCTL_$$"
+ * @mb_type	: Type of the mail box (MB_LEGACY or MB_HPE)
+ * @app_type	: Type of the issuing application (existing or new)
+ * @opcode	: Opcode of the command
+ * @adapno	: Adapter number
+ * @cmdbuf	: Pointer to buffer - can point to mbox or plain data buffer
+ * @xferlen	: xferlen for DCMD and non mailbox commands
+ * @data_dir	: Direction of the data transfer
+ * @status	: Status from the driver
+ *
+ * Note		: All LSI drivers understand only this packet. Any other
+ *		: format sent by applications would be converted to this.
+ *		: All addresses are 64 bits (even on 32-bit platforms).
+ */
+
+typedef void(*DONE)(void);
+
+#define EXT_IOCTL_PACKET_SZ		128
+#define IOC_VALID_FIELDS_SZ		(46+sizeof(DONE))
+
+/*
+ * FIXME: reserve 32 bytes for driver at the bottom
+ */
+typedef struct uioc {
+
+/* User Apps: */
+
+	uint8_t		signature[EXT_IOCTL_SIGN_SZ];
+	uint8_t		mb_type;
+	uint8_t		app_type;
+	uint32_t	opcode;
+	uint32_t	adapno;
+	uint64_t	cmdbuf;
+	uint32_t	xferlen;
+	uint32_t	data_dir;
+	uint32_t	status;
+
+/* Driver Data: */
+	void (*done)(struct uioc*);
+
+	uint8_t		reserved[EXT_IOCTL_PACKET_SZ - IOC_VALID_FIELDS_SZ];
+
+} __attribute__ ((packed)) uioc_t;
+
+/**
+ * struct mraid_hba_info - information about the controller
+ *
+ * @param pci_vendor_id		: PCI vendor id
+ * @param pci_device_id		: PCI device id
+ * @param subsystem_vendor_id	: PCI subsystem vendor id
+ * @param subsystem_device_id	: PCI subsystem device id
+ * @param baseport		: base port of hba memory
+ * @param pci_bus		: PCI bus
+ * @param pci_dev_fn		: PCI device/function values
+ * @param irq			: interrupt vector for the device
+ * @param reserved1		: filler to align a even boundary
+ * @param reserved		: reserved space
+ *
+ * Extended information of 256 bytes about the controller. Align on the single
+ * byte boundary so that 32-bit applications can be run on 64-bit platform
+ * drivers withoug re-compilation.
+ * NOTE: reduce the number of reserved bytes whenever new field are added, so
+ * that total size of the structure remains 256 bytes.
+ */
+typedef struct mraid_hba_info {
+
+	uint16_t	pci_vendor_id;
+	uint16_t	pci_device_id;
+	uint16_t	subsys_vendor_id;
+	uint16_t	subsys_device_id;
+
+	uint64_t	baseport;
+	uint8_t		pci_bus;
+	uint8_t		pci_dev_fn;
+	uint8_t		pci_slot;
+	uint8_t		irq;
+
+	uint8_t		reserved1;
+	uint32_t	unique_id;
+	uint32_t	host_no;
+
+	uint8_t		num_ldrv;
+
+	uint8_t		reserved[256 - 30];
+
+} __attribute__ ((packed)) mraid_hba_info_t;
+
+typedef struct mcontroller {
+
+	uint64_t	base;
+	uint8_t		irq;
+	uint8_t		numldrv;
+	uint8_t		pcibus;
+	uint16_t	pcidev;
+	uint8_t		pcifun;
+	uint16_t	pciid;
+	uint16_t	pcivendor;
+	uint8_t		pcislot;
+	uint32_t	uid;
+
+} __attribute__ ((packed)) mcontroller_t;
+
+/**
+ * mraid_mmadp_t: Structure that drivers pass during (un)registration
+ *
+ * @unique_id	: Any unique id (usually PCI bus+dev+fn)
+ * @drvr_type	: megaraid or hpe (DRVRTYPE_MBOX or DRVRTYPE_HPE)
+ * @drv_data	: Driver specific; not touched by the common module
+ * @dev		: pci dev; used for allocating dma'ble memory
+ * @issue_uioc	: Driver supplied routine to issue uioc_t commands
+ *		: issue_uioc(drvr_data, kioc, ISSUE/ABORT, uioc_done)
+ */
+
+typedef struct mraid_mmadp {
+
+/* Filled by driver */
+
+	uint32_t		unique_id;
+	uint32_t		drvr_type;
+	unsigned long		drvr_data;
+	uint8_t			timeout;
+
+	struct pci_dev*		pdev;
+
+	int(*issue_uioc)(unsigned long, uioc_t*, uint32_t);
+
+/* Maintained by common module */
+
+	uioc_t			kioc;
+	struct semaphore	kioc_mtx;
+
+	caddr_t			memblk;
+	dma_addr_t		memblk_dmah;
+
+	caddr_t			int_data;
+	uint32_t		int_data_len;
+	dma_addr_t		int_data_dmah;
+	caddr_t			int_data_user;
+
+	caddr_t			int_pthru;
+	uint32_t		int_pthru_len;
+	dma_addr_t		int_pthru_dmah;
+	caddr_t			int_pthru_user;
+
+} mraid_mmadp_t;
+
+uint32_t mraid_mm_register_adp( mraid_mmadp_t* );
+uint32_t mraid_mm_unregister_adp( uint32_t );
+
+#endif /*LSI_COMMON_DEFS*/
diff -Naur linux-2.6.6.orig/drivers/scsi/megaraid/mbox_defs.h linux-2.6.6/drivers/scsi/megaraid/mbox_defs.h
--- linux-2.6.6.orig/drivers/scsi/megaraid/mbox_defs.h	Wed Dec 31 19:00:00 1969
+++ linux-2.6.6/drivers/scsi/megaraid/mbox_defs.h	Sat May 15 13:35:04 2004
@@ -0,0 +1,788 @@
+/*
+ *
+ *			Linux MegaRAID Unified device driver
+ *
+ * Copyright (c) 2003-2004  LSI Logic Corporation.
+ *
+ *	   This program is free software; you can redistribute it and/or
+ *	   modify it under the terms of the GNU General Public License
+ *	   as published by the Free Software Foundation; either version
+ *	   2 of the License, or (at your option) any later version.
+ *
+ * FILE		: mbox_defs.h
+ *
+ */
+#ifndef _MRAID_UNIFIED_MBOX_DEFS_H_
+#define _MRAID_UNIFIED_MBOX_DEFS_H_
+
+#include "lsi_defs.h"
+
+/*
+ * Commands and states for mailbox based controllers
+ */
+
+#define MBOXCMD_LREAD		0x01
+#define MBOXCMD_LWRITE		0x02
+#define MBOXCMD_PASSTHRU	0x03
+#define MBOXCMD_ADPEXTINQ	0x04
+#define MBOXCMD_ADAPTERINQ	0x05
+#define MBOXCMD_LREAD64		0xA7
+#define MBOXCMD_LWRITE64	0xA8
+#define MBOXCMD_PASSTHRU64	0xC3
+#define MBOXCMD_EXTPTHRU	0xE3
+
+#define MAIN_MISC_OPCODE	0xA4
+#define GET_MAX_SG_SUPPORT	0x01
+#define SUPPORT_EXT_CDB		0x16
+
+#define FC_NEW_CONFIG		0xA1
+#define NC_SUBOP_PRODUCT_INFO	0x0E
+#define NC_SUBOP_ENQUIRY3	0x0F
+#define ENQ3_GET_SOLICITED_FULL	0x02
+#define OP_DCMD_READ_CONFIG	0x04
+#define NEW_READ_CONFIG_8LD	0x67
+#define READ_CONFIG_8LD		0x07
+#define FLUSH_ADAPTER		0x0A
+#define FLUSH_SYSTEM		0xFE
+
+/*
+ * Command for random deletion of logical drives
+ */
+#define	FC_DEL_LOGDRV		0xA4
+#define	OP_SUP_DEL_LOGDRV	0x2A
+#define OP_GET_LDID_MAP		0x18
+#define OP_DEL_LOGDRV		0x1C
+
+/*
+ * BIOS commands
+ */
+#define IS_BIOS_ENABLED		0x62
+#define GET_BIOS		0x01
+#define CHNL_CLASS		0xA9
+#define GET_CHNL_CLASS		0x00
+#define SET_CHNL_CLASS		0x01
+#define CH_RAID			0x01
+#define CH_SCSI			0x00
+#define BIOS_PVT_DATA		0x40
+#define GET_BIOS_PVT_DATA	0x00
+
+
+/*
+ * Commands to support clustering
+ */
+#define GET_TARGET_ID		0x7D
+#define CLUSTER_OP		0x70
+#define GET_CLUSTER_MODE	0x02
+#define CLUSTER_CMD		0x6E
+#define RESERVE_LD		0x01
+#define RELEASE_LD		0x02
+#define RESET_RESERVATIONS	0x03
+#define RESERVATION_STATUS	0x04
+#define RESERVE_PD		0x05
+#define RELEASE_PD		0x06
+
+
+/*
+ * Module battery status
+ */
+#define BATTERY_MODULE_MISSING		0x01
+#define BATTERY_LOW_VOLTAGE		0x02
+#define BATTERY_TEMP_HIGH		0x04
+#define BATTERY_PACK_MISSING		0x08
+#define BATTERY_CHARGE_MASK		0x30
+#define BATTERY_CHARGE_DONE		0x00
+#define BATTERY_CHARGE_INPROG		0x10
+#define BATTERY_CHARGE_FAIL		0x20
+#define BATTERY_CYCLES_EXCEEDED		0x40
+
+/*
+ * Physical drive states.
+ */
+#define PDRV_UNCNF	0
+#define PDRV_ONLINE	3
+#define PDRV_FAILED	4
+#define PDRV_RBLD	5
+#define PDRV_HOTSPARE	6
+
+
+/*
+ * Raid logical drive states.
+ */
+#define RDRV_OFFLINE	0
+#define RDRV_DEGRADED	1
+#define RDRV_OPTIMAL	2
+#define RDRV_DELETED	3
+
+/*
+ * Read, write and cache policies
+ */
+#define NO_READ_AHEAD		0
+#define READ_AHEAD		1
+#define ADAP_READ_AHEAD		2
+#define WRMODE_WRITE_THRU	0
+#define WRMODE_WRITE_BACK	1
+#define CACHED_IO		0
+#define DIRECT_IO		1
+
+#define MAX_LOGICAL_DRIVES_8LD		8
+#define MAX_LOGICAL_DRIVES_40LD		40
+#define FC_MAX_PHYSICAL_DEVICES		256
+#define MAX_MBOX_CHANNELS		5
+#define MAX_MBOX_TARGET			15
+#define MBOX_MAX_PHYSICAL_DRIVES	MAX_MBOX_CHANNELS*MAX_MBOX_TARGET
+#define MAX_ROW_SIZE_40LD		32
+#define MAX_ROW_SIZE_8LD		8
+#define SPAN_DEPTH_8_SPANS		8
+#define SPAN_DEPTH_4_SPANS		4
+
+
+/**
+ * struct mbox_t - Driver and f/w handshake structure.
+ * @cmd		: firmware command
+ * @cmdid	: command id
+ * @numsectors	: number of sectors to be transferred
+ * @lba		: Logical Block Address on LD
+ * @xferaddr	: DMA address for data transfer
+ * @logdrv	: logical drive number
+ * @numsge	: number of scatter gather elements in sg list
+ * @resvd	: reserved
+ * @busy	: f/w busy, must wait to issue more commands.
+ * @numstatus	: number of commands completed.
+ * @status	: status of the commands completed
+ * @completed	: array of completed command ids.
+ * @poll	: poll and ack sequence
+ * @ack		: poll and ack sequence
+ *
+ * The central handshake structure between the driver and the firmware. This
+ * structure must be allocated by the driver and aligned at 8-byte boundary.
+ */
+#define MBOX_MAX_FIRMWARE_STATUS	46
+typedef struct {
+	uint8_t		cmd;
+	uint8_t		cmdid;
+	uint16_t	numsectors;
+	uint32_t	lba;
+	uint32_t	xferaddr;
+	uint8_t		logdrv;
+	uint8_t		numsge;
+	uint8_t		resvd;
+	uint8_t		busy;
+	uint8_t		numstatus;
+	uint8_t		status;
+	uint8_t		completed[MBOX_MAX_FIRMWARE_STATUS];
+	uint8_t		poll;
+	uint8_t		ack;
+} __attribute__ ((packed)) mbox_t;
+
+
+/**
+ * mbox64_t - 64-bit extension for the mailbox
+ * @segment_lo	: the low 32-bits of the address of the scatter-gather list
+ * @segment_hi	: the upper 32-bits of the address of the scatter-gather list
+ * @mbox	: 32-bit mailbox, whose xferadder field must be set to
+ *		0xFFFFFFFF
+ *
+ * This is the extension of the 32-bit mailbox to be able to perform DMA
+ * beyond 4GB address range.
+ */
+typedef struct {
+	uint32_t	xferaddr_lo;
+	uint32_t	xferaddr_hi;
+	mbox_t		mbox32;
+} __attribute__ ((packed)) mbox64_t;
+
+/*
+ * mailbox structure used for internal commands
+ */
+typedef struct {
+	u8	cmd;
+	u8	cmdid;
+	u8	opcode;
+	u8	subopcode;
+	u32	lba;
+	u32	xferaddr;
+	u8	logdrv;
+	u8	rsvd[3];
+	u8	numstatus;
+	u8	status;
+} __attribute__ ((packed)) int_mbox_t;
+
+/**
+ * mraid_passthru_t - passthru structure to issue commands to physical devices
+ * @timeout		: command timeout, 0=6sec, 1=60sec, 2=10min, 3=3hr
+ * @ars			: set if ARS required after check condition
+ * @islogical		: set if command meant for logical devices
+ * @logdrv		: logical drive number if command for LD
+ * @channel		: Channel on which physical device is located
+ * @target		: SCSI target of the device
+ * @queuetag		: unused
+ * @queueaction		: unused
+ * @cdb			: SCSI CDB
+ * @cdblen		: length of the CDB
+ * @reqsenselen		: amount of request sense data to be returned
+ * @reqsensearea	: Sense information buffer
+ * @numsge		: number of scatter-gather elements in the sg list
+ * @scsistatus		: SCSI status of the command completed.
+ * @dataxferaddr	: DMA data transfer address
+ * @dataxferlen		: amount of the data to be transferred.
+ */
+typedef struct {
+	uint8_t		timeout		:3;
+	uint8_t		ars		:1;
+	uint8_t		reserved	:3;
+	uint8_t		islogical	:1;
+	uint8_t		logdrv;
+	uint8_t		channel;
+	uint8_t		target;
+	uint8_t		queuetag;
+	uint8_t		queueaction;
+	uint8_t		cdb[MAX_CDB_LEN];
+	uint8_t		cdblen;
+	uint8_t		reqsenselen;
+	uint8_t		reqsensearea[MAX_REQ_SENSE_LEN];
+	uint8_t		numsge;
+	uint8_t		scsistatus;
+	uint32_t	dataxferaddr;
+	uint32_t	dataxferlen;
+} __attribute__ ((packed)) mraid_passthru_t;
+
+typedef struct {
+
+	uint32_t		dataxferaddr_lo;
+	uint32_t		dataxferaddr_hi;
+	mraid_passthru_t	pthru32;
+
+} __attribute__ ((packed)) mega_passthru64_t;
+
+/**
+ * mraid_epassthru_t - passthru structure to issue commands to physical devices
+ * @timeout		: command timeout, 0=6sec, 1=60sec, 2=10min, 3=3hr
+ * @ars			: set if ARS required after check condition
+ * @rsvd1		: reserved field
+ * @cd_rom		: (?)
+ * @rsvd2		: reserved field
+ * @islogical		: set if command meant for logical devices
+ * @logdrv		: logical drive number if command for LD
+ * @channel		: Channel on which physical device is located
+ * @target		: SCSI target of the device
+ * @queuetag		: unused
+ * @queueaction		: unused
+ * @cdblen		: length of the CDB
+ * @rsvd3		: reserved field
+ * @cdb			: SCSI CDB
+ * @numsge		: number of scatter-gather elements in the sg list
+ * @status		: SCSI status of the command completed.
+ * @reqsenselen		: amount of request sense data to be returned
+ * @reqsensearea	: Sense information buffer
+ * @rsvd4		: reserved field
+ * @dataxferaddr	: DMA data transfer address
+ * @dataxferlen		: amount of the data to be transferred.
+ */
+typedef struct {
+	uint8_t		timeout		:3;
+	uint8_t		ars		:1;
+	uint8_t		rsvd1		:1;
+	uint8_t		cd_rom		:1;
+	uint8_t		rsvd2		:1;
+	uint8_t		islogical	:1;
+	uint8_t		logdrv;
+	uint8_t		channel;
+	uint8_t		target;
+	uint8_t		queuetag;
+	uint8_t		queueaction;
+	uint8_t		cdblen;
+	uint8_t		rsvd3;
+	uint8_t		cdb[MAX_EXT_CDB_LEN];
+	uint8_t		numsge;
+	uint8_t		status;
+	uint8_t		reqsenselen;
+	uint8_t		reqsensearea[MAX_REQ_SENSE_LEN];
+	uint8_t		rsvd4;
+	uint32_t	dataxferaddr;
+	uint32_t	dataxferlen;
+} __attribute__ ((packed)) mraid_epassthru_t;
+
+
+/**
+ * mraid_pinfo_t - product info, static information about the controller
+ * @data_size		: current size in bytes (not including resvd)
+ * @config_signature	: Current value is 0x00282008
+ * @fw_version		: Firmware version
+ * @bios_version	: version of the BIOS
+ * @product_name	: Name given to the controller
+ * @max_commands	: Maximum concurrent commands supported
+ * @nchannels		: Number of SCSI Channels detected
+ * @fc_loop_present	: Number of Fibre Loops detected
+ * @mem_type		: EDO, FPM, SDRAM etc
+ * @signature		:
+ * @dram_size		: In terms of MB
+ * @subsysid		: device PCI subsystem ID
+ * @subsysvid		: device PCI subsystem vendor ID
+ * @notify_counters	:
+ * @pad1k		: 135 + 889 resvd = 1024 total size
+ *
+ * This structures holds the information about the controller which is not
+ * expected to change dynamically.
+ *
+ * The current value of config signature is 0x00282008:
+ * 0x28 = MAX_LOGICAL_DRIVES,
+ * 0x20 = Number of stripes and
+ * 0x08 = Number of spans
+ */
+typedef struct {
+	uint32_t	data_size;
+	uint32_t	config_signature;
+	uint8_t		fw_version[16];
+	uint8_t		bios_version[16];
+	uint8_t		product_name[80];
+	uint8_t		max_commands;
+	uint8_t		nchannels;
+	uint8_t		fc_loop_present;
+	uint8_t		mem_type;
+	uint32_t	signature;
+	uint16_t	dram_size;
+	uint16_t	subsysid;
+	uint16_t	subsysvid;
+	uint8_t		notify_counters;
+	uint8_t		pad1k[889];
+} __attribute__ ((packed)) mraid_pinfo_t;
+
+
+/**
+ * mraid_notify_t - the notification structure
+ * @global_counter		: Any change increments this counter
+ * @param_counter		: Indicates any params changed
+ * @param_id			: Param modified - defined below
+ * @param_val			: New val of last param modified
+ * @write_config_counter	: write config occurred
+ * @write_config_rsvd		:
+ * @ldrv_op_counter		: Indicates ldrv op started/completed
+ * @ldrv_opid			: ldrv num
+ * @ldrv_opcmd			: ldrv operation - defined below
+ * @ldrv_opstatus		: status of the operation
+ * @ldrv_state_counter		: Indicates change of ldrv state
+ * @ldrv_state_id		: ldrv num
+ * @ldrv_state_new		: New state
+ * @ldrv_state_old		: old state
+ * @pdrv_state_counter		: Indicates change of ldrv state
+ * @pdrv_state_id		: pdrv id
+ * @pdrv_state_new		: New state
+ * @pdrv_state_old		: old state
+ * @pdrv_fmt_counter		: Indicates pdrv format started/over
+ * @pdrv_fmt_id			: pdrv id
+ * @pdrv_fmt_val		: format started/over
+ * @pdrv_fmt_rsvd		:
+ * @targ_xfer_counter		: Indicates SCSI-2 Xfer rate change
+ * @targ_xfer_id		: pdrv Id
+ * @targ_xfer_val		: new Xfer params of last pdrv
+ * @targ_xfer_rsvd		:
+ * @fcloop_id_chg_counter	: Indicates loopid changed
+ * @fcloopid_pdrvid		: pdrv id
+ * @fcloop_id0			: loopid on fc loop 0
+ * @fcloop_id1			: loopid on fc loop 1
+ * @fcloop_state_counter	: Indicates loop state changed
+ * @fcloop_state0		: state of fc loop 0
+ * @fcloop_state1		: state of fc loop 1
+ * @fcloop_state_rsvd		:
+ */
+typedef struct {
+	uint32_t	global_counter;
+	uint8_t		param_counter;
+	uint8_t		param_id;
+	uint16_t	param_val;
+	uint8_t		write_config_counter;
+	uint8_t		write_config_rsvd[3];
+	uint8_t		ldrv_op_counter;
+	uint8_t		ldrv_opid;
+	uint8_t		ldrv_opcmd;
+	uint8_t		ldrv_opstatus;
+	uint8_t		ldrv_state_counter;
+	uint8_t		ldrv_state_id;
+	uint8_t		ldrv_state_new;
+	uint8_t		ldrv_state_old;
+	uint8_t		pdrv_state_counter;
+	uint8_t		pdrv_state_id;
+	uint8_t		pdrv_state_new;
+	uint8_t		pdrv_state_old;
+	uint8_t		pdrv_fmt_counter;
+	uint8_t		pdrv_fmt_id;
+	uint8_t		pdrv_fmt_val;
+	uint8_t		pdrv_fmt_rsvd;
+	uint8_t		targ_xfer_counter;
+	uint8_t		targ_xfer_id;
+	uint8_t		targ_xfer_val;
+	uint8_t		targ_xfer_rsvd;
+	uint8_t		fcloop_id_chg_counter;
+	uint8_t		fcloopid_pdrvid;
+	uint8_t		fcloop_id0;
+	uint8_t		fcloop_id1;
+	uint8_t		fcloop_state_counter;
+	uint8_t		fcloop_state0;
+	uint8_t		fcloop_state1;
+	uint8_t		fcloop_state_rsvd;
+} __attribute__ ((packed)) mraid_notify_t;
+
+
+/**
+ * mraid_inquiry3_t - enquiry for device information
+ *
+ * @data_size		: current size in bytes (not including resvd)
+ * @notify		:
+ * @notify_rsvd		:
+ * @rebuild_rate	: rebuild rate (0% - 100%)
+ * @cache_flush_int	: cache flush interval in seconds
+ * @sense_alert		:
+ * @drive_insert_count	: drive insertion count
+ * @battery_status	:
+ * @num_ldrv		: no. of Log Drives configured
+ * @recon_state		: state of reconstruct
+ * @ldrv_op_status	: logdrv Status
+ * @ldrv_size		: size of each log drv
+ * @ldrv_prop		:
+ * @ldrv_state		: state of log drives
+ * @pdrv_state		: state of phys drvs.
+ * @pdrv_format		:
+ * @targ_xfer		: phys device transfer rate
+ * @pad1k		: 761 + 263reserved = 1024 bytes total size
+ */
+#define MAX_NOTIFY_SIZE		0x80
+#define CUR_NOTIFY_SIZE		sizeof(mraid_notify_t)
+
+typedef struct {
+	uint32_t	data_size;
+
+	mraid_notify_t	notify;
+
+	uint8_t		notify_rsvd[MAX_NOTIFY_SIZE - CUR_NOTIFY_SIZE];
+
+	uint8_t		rebuild_rate;
+	uint8_t		cache_flush_int;
+	uint8_t		sense_alert;
+	uint8_t		drive_insert_count;
+
+	uint8_t		battery_status;
+	uint8_t		num_ldrv;
+	uint8_t		recon_state[MAX_LOGICAL_DRIVES_40LD / 8];
+	uint16_t	ldrv_op_status[MAX_LOGICAL_DRIVES_40LD / 8];
+
+	uint32_t	ldrv_size[MAX_LOGICAL_DRIVES_40LD];
+	uint8_t		ldrv_prop[MAX_LOGICAL_DRIVES_40LD];
+	uint8_t		ldrv_state[MAX_LOGICAL_DRIVES_40LD];
+	uint8_t		pdrv_state[FC_MAX_PHYSICAL_DEVICES];
+	uint16_t	pdrv_format[FC_MAX_PHYSICAL_DEVICES / 16];
+
+	uint8_t		targ_xfer[80];
+	uint8_t		pad1k[263];
+} __attribute__ ((packed)) mraid_inquiry3_t;
+
+
+/**
+ * mraid_adapinfo_t - information about the adapter
+ * @max_commands		: max concurrent commands supported
+ * @rebuild_rate		: rebuild rate - 0% thru 100%
+ * @max_targ_per_chan		: max targ per channel
+ * @nchannels			: number of channels on HBA
+ * @fw_version			: firmware version
+ * @age_of_flash		: number of times FW has been flashed
+ * @chip_set_value		: contents of 0xC0000832
+ * @dram_size			: in MB
+ * @cache_flush_interval	: in seconds
+ * @bios_version		:
+ * @board_type			:
+ * @sense_alert			:
+ * @write_config_count		: increase with every configuration change
+ * @drive_inserted_count	: increase with every drive inserted
+ * @inserted_drive		: channel:Id of inserted drive
+ * @battery_status		: bit 0: battery module missing
+ *				bit 1: VBAD
+ *				bit 2: temprature high
+ *				bit 3: battery pack missing
+ *				bit 4,5:
+ *					00 - charge complete
+ *					01 - fast charge in progress
+ *					10 - fast charge fail
+ *					11 - undefined
+ *				bit 6: counter > 1000
+ *				bit 7: Undefined
+ * @dec_fault_bus_info		:
+ */
+typedef struct {
+	uint8_t		max_commands;
+	uint8_t		rebuild_rate;
+	uint8_t		max_targ_per_chan;
+	uint8_t		nchannels;
+	uint8_t		fw_version[4];
+	uint16_t	age_of_flash;
+	uint8_t		chip_set_value;
+	uint8_t		dram_size;
+	uint8_t		cache_flush_interval;
+	uint8_t		bios_version[4];
+	uint8_t		board_type;
+	uint8_t		sense_alert;
+	uint8_t		write_config_count;
+	uint8_t		battery_status;
+	uint8_t		dec_fault_bus_info;
+} __attribute__ ((packed)) mraid_adapinfo_t;
+
+
+/**
+ * mraid_ldrv_info_t - information about the logical drives
+ * @nldrv	: Number of logical drives configured
+ * @rsvd	:
+ * @size	: size of each logical drive
+ * @prop	:
+ * @state	: state of each logical drive
+ */
+typedef struct {
+	uint8_t		nldrv;
+	uint8_t		rsvd[3];
+	uint32_t	size[MAX_LOGICAL_DRIVES_8LD];
+	uint8_t		prop[MAX_LOGICAL_DRIVES_8LD];
+	uint8_t		state[MAX_LOGICAL_DRIVES_8LD];
+} __attribute__ ((packed)) mraid_ldrv_info_t;
+
+
+/**
+ * mraid_pdrv_info_t - information about the physical drives
+ * @pdrv_state	: state of each physical drive
+ */
+typedef struct {
+	uint8_t		pdrv_state[MBOX_MAX_PHYSICAL_DRIVES];
+	uint8_t		rsvd;
+} __attribute__ ((packed)) mraid_pdrv_info_t;
+
+
+/**
+ * mraid_inquiry_t - RAID inquiry, mailbox command 0x05
+ * @mraid_adapinfo_t	: adapter information
+ * @mraid_ldrv_info_t	: logical drives information
+ * @mraid_pdrv_info_t	: physical drives information
+ */
+typedef struct {
+	mraid_adapinfo_t	adapter_info;
+	mraid_ldrv_info_t	logdrv_info;
+	mraid_pdrv_info_t	pdrv_info;
+} __attribute__ ((packed)) mraid_inquiry_t;
+
+
+/**
+ * mraid_extinq_t - RAID extended inquiry, mailbox command 0x04
+ *
+ * @raid_inq		: raid inquiry
+ * @phys_drv_format	:
+ * @stack_attn		:
+ * @modem_status	:
+ * @rsvd		:
+ */
+typedef struct {
+	mraid_inquiry_t	raid_inq;
+	uint16_t	phys_drv_format[MAX_MBOX_CHANNELS];
+	uint8_t		stack_attn;
+	uint8_t		modem_status;
+	uint8_t		rsvd[2];
+} __attribute__ ((packed)) mraid_extinq_t;
+
+
+/**
+ * adap_device_t - device information
+ * @channel	: channel fpor the device
+ * @target	: target ID of the device
+ */
+typedef struct {
+	uint8_t		channel;
+	uint8_t		target;
+}__attribute__ ((packed)) adap_device_t;
+
+
+/**
+ * adap_span_40ld_t - 40LD span
+ * @start_blk	: starting block
+ * @num_blks	: number of blocks
+ */
+typedef struct {
+	uint32_t	start_blk;
+	uint32_t	num_blks;
+	adap_device_t	device[MAX_ROW_SIZE_40LD];
+}__attribute__ ((packed)) adap_span_40ld_t;
+
+
+/**
+ * adap_span_8ld_t - 8LD span
+ * @start_blk	: starting block
+ * @num_blks	: number of blocks
+ */
+typedef struct {
+	uint32_t	start_blk;
+	uint32_t	num_blks;
+	adap_device_t	device[MAX_ROW_SIZE_8LD];
+}__attribute__ ((packed)) adap_span_8ld_t;
+
+
+/**
+ * logdrv_param_t - logical drives parameters
+ *
+ * @span_depth	: total number of spans
+ * @level	: RAID level
+ * @read_ahead	: read ahead, no read ahead, adaptive read ahead
+ * @stripe_sz	: encoded stripe size
+ * @status	: status of the logical drive
+ * @write_mode	: write mode, write_through/write_back
+ * @direct_io	: direct io or through cache
+ * @row_size	: number of stripes in a row
+ */
+typedef struct {
+	uint8_t		span_depth;
+	uint8_t		level;
+	uint8_t		read_ahead;
+	uint8_t		stripe_sz;
+	uint8_t		status;
+	uint8_t		write_mode;
+	uint8_t		direct_io;
+	uint8_t		row_size;
+} __attribute__ ((packed)) logdrv_param_t;
+
+
+/**
+ * logdrv_40ld_t - logical drive definition for 40LD controllers
+ * @lparam	: logical drives parameters
+ * @span	: span
+ */
+typedef struct {
+	logdrv_param_t		lparam;
+	adap_span_40ld_t	span[SPAN_DEPTH_8_SPANS];
+}__attribute__ ((packed)) logdrv_40ld_t;
+
+
+/**
+ * logdrv_8ld_span8_t - logical drive definition for 8LD controllers
+ * @lparam	: logical drives parameters
+ * @span	: span
+ *
+ * 8-LD logical drive with upto 8 spans
+ */
+typedef struct {
+	logdrv_param_t	lparam;
+	adap_span_8ld_t	span[SPAN_DEPTH_8_SPANS];
+}__attribute__ ((packed)) logdrv_8ld_span8_t;
+
+
+/**
+ * logdrv_8ld_span4_t - logical drive definition for 8LD controllers
+ * @lparam	: logical drives parameters
+ * @span	: span
+ *
+ * 8-LD logical drive with upto 4 spans
+ */
+typedef struct {
+	logdrv_param_t	lparam;
+	adap_span_8ld_t	span[SPAN_DEPTH_4_SPANS];
+}__attribute__ ((packed)) logdrv_8ld_span4_t;
+
+
+/**
+ * phys_drive_t - physical device information
+ * @type	: Type of the device
+ * @cur_status	: current status of the device
+ * @tag_depth	: Level of tagging
+ * @sync_neg	: sync negotiation - ENABLE or DISBALE
+ * @size	: configurable size in terms of 512 byte
+ */
+typedef struct {
+	uint8_t		type;
+	uint8_t		cur_status;
+	uint8_t		tag_depth;
+	uint8_t		sync_neg;
+	uint32_t	size;
+}__attribute__ ((packed)) phys_drive_t;
+
+
+/**
+ * disk_array_40ld_t - disk array for 40LD controllers
+ * @numldrv	: number of logical drives
+ * @resvd	:
+ * @ldrv	: logical drives information
+ * @pdrv	: physical drives information
+ */
+typedef struct {
+	uint8_t		numldrv;
+	uint8_t		resvd[3];
+	logdrv_40ld_t	ldrv[MAX_LOGICAL_DRIVES_40LD];
+	phys_drive_t	pdrv[MBOX_MAX_PHYSICAL_DRIVES];
+}__attribute__ ((packed)) disk_array_40ld_t;
+
+
+/**
+ * disk_array_8ld_span8_t - disk array for 8LD controllers
+ * @numldrv	: number of logical drives
+ * @resvd	:
+ * @ldrv	: logical drives information
+ * @pdrv	: physical drives information
+ *
+ * Disk array for 8LD logical drives with upto 8 spans
+ */
+typedef struct {
+	uint8_t			numldrv;
+	uint8_t			resvd[3];
+	logdrv_8ld_span8_t	ldrv[MAX_LOGICAL_DRIVES_8LD];
+	phys_drive_t		pdrv[MBOX_MAX_PHYSICAL_DRIVES];
+}__attribute__ ((packed)) disk_array_8ld_span8_t;
+
+
+/**
+ * disk_array_8ld_span4_t - disk array for 8LD controllers
+ * @numldrv	: number of logical drives
+ * @resvd	:
+ * @ldrv	: logical drives information
+ * @pdrv	: physical drives information
+ *
+ * Disk array for 8LD logical drives with upto 4 spans
+ */
+typedef struct {
+	uint8_t			numldrv;
+	uint8_t			resvd[3];
+	logdrv_8ld_span4_t	ldrv[MAX_LOGICAL_DRIVES_8LD];
+	phys_drive_t		pdrv[MBOX_MAX_PHYSICAL_DRIVES];
+}__attribute__ ((packed)) disk_array_8ld_span4_t;
+
+
+/**
+ * private_bios_data - bios private data for boot devices
+ * @geometry	: bits 0-3 - BIOS geometry, 0x0001 - 1GB, 0x0010 - 2GB,
+ *		0x1000 - 8GB, Others values are invalid
+ * @unused	: bits 4-7 are unused
+ * @boot_drv	: logical drive set as boot drive, 0..7 - for 8LD cards,
+ * 		0..39 - for 40LD cards
+ * @cksum	: 0-(sum of first 13 bytes of this structure)
+ */
+struct private_bios_data {
+	uint8_t		geometry	:4;
+	uint8_t		unused		:4;
+	uint8_t		boot_drv;
+	uint8_t		rsvd[12];
+	uint16_t	cksum;
+} __attribute__ ((packed));
+
+
+/**
+ * mbox_sgl64 - 64-bit scatter list for mailbox based controllers
+ * @address	: address of the buffer
+ * @length	: data transfer length
+ */
+typedef struct {
+	uint64_t	address;
+	uint32_t	length;
+} __attribute__ ((packed)) mbox_sgl64;
+
+/**
+ * mbox_sgl32 - 32-bit scatter list for mailbox based controllers
+ * @address	: address of the buffer
+ * @length	: data transfer length
+ */
+typedef struct {
+	uint32_t	address;
+	uint32_t	length;
+} __attribute__ ((packed)) mbox_sgl32;
+
+#endif		/* _MRAID_UNIFIED_MBOX_DEFS_H_ */
+
+/* vim: set ts=8 sw=8 tw=78: */
diff -Naur linux-2.6.6.orig/drivers/scsi/megaraid/mega_common.h linux-2.6.6/drivers/scsi/megaraid/mega_common.h
--- linux-2.6.6.orig/drivers/scsi/megaraid/mega_common.h	Wed Dec 31 19:00:00 1969
+++ linux-2.6.6/drivers/scsi/megaraid/mega_common.h	Sat May 15 13:35:04 2004
@@ -0,0 +1,356 @@
+/*
+ *
+ *			Linux MegaRAID device driver
+ *
+ * Copyright (c) 2003-2004  LSI Logic Corporation.
+ *
+ *	   This program is free software; you can redistribute it and/or
+ *	   modify it under the terms of the GNU General Public License
+ *	   as published by the Free Software Foundation; either version
+ *	   2 of the License, or (at your option) any later version.
+ *
+ * FILE		: mega_common.h
+ * Version	: v2.20.0 (Apr 14 2004)
+ *
+ * Libaray of common routine used by all megaraid drivers.
+ */
+
+#ifndef _MEGA_COMMON_H_
+#define _MEGA_COMMON_H_
+
+#include "lsi_defs.h"
+
+#define PCI_DIR(scp)		scsi_to_pci_dma_dir(scp->sc_data_direction)
+
+#define VENDOR_SPECIFIC_COMMAND	0xE0
+
+/*
+ * lockscope definitions, callers can specify the lock scope with this data
+ * type. LOCK_INT would mean the caller has not acquired the lock before
+ * making the call and LOCK_EXT would mean otherwise.
+ */
+typedef enum { LOCK_INT, LOCK_EXT } lockscope_t;
+
+/**
+ * scb_t - scsi command control block
+ * @param ccb		: command control block for individual driver
+ * @param list		: list of control blocks
+ * @param gp		: general purpose field for LLDs
+ * @param sno		: all SCBs have a serial number
+ * @param scp		: associated scsi command
+ * @param state		: current state of scb
+ * @param dma_dir	: direction of data transfer
+ * @param dma_type	: transfer with sg list, buffer, or no data transfer
+ * @param dev_channel	: actual channel on the device
+ * @param dev_target	: actual target on the device
+ * @param status	: completion status
+ * @param entry_time	: command entry time
+ * @param exit_time	: command exit time
+ *
+ * This is our central data structure to issue commands the each driver.
+ * Driver specific data structures are maintained in the ccb field.
+ * scb provides a field 'gp', which can be used by LLD for its own purposes
+ *
+ * dev_channel and dev_target must be initialized with the actual channel and
+ * target on the controller.
+ */
+typedef struct {
+	caddr_t			ccb;
+	struct list_head	list;
+	unsigned long		gp;
+	unsigned int		sno;
+	Scsi_Cmnd		*scp;
+	uint32_t		state;
+	uint32_t		dma_direction;
+	uint32_t		dma_type;
+	uint16_t		dev_channel;
+	uint16_t		dev_target;
+	uint32_t		status;
+	unsigned long		entry_time;
+	unsigned long		exit_time;
+} scb_t;
+
+/*
+ * SCB states as it transitions from one state to another
+ */
+#define SCB_FREE	0x0000	/* on the free list */
+#define SCB_ACTIVE	0x0001	/* off the free list */
+#define SCB_PENDQ	0x0002	/* on the pending queue */
+#define SCB_ISSUED	0x0004	/* issued - owner f/w */
+#define SCB_ABORT	0x0008	/* Got an abort for this one */
+#define SCB_RESET	0x0010	/* Got a reset for this one */
+
+/*
+ * DMA types for scb
+ */
+#define MRAID_DMA_NONE	0x0000	/* no data transfer for this command */
+#define MRAID_DMA_WSG	0x0001	/* data transfer using a sg list */
+#define MRAID_DMA_WBUF	0x0002	/* data transfer using a contiguous buffer */
+
+
+/**
+ * struct adapter_t - driver's initialization structure
+ * @param list			: list of megaraid host structures
+ * @param dpc_h			: tasklet handle
+ * @param id			: PCI device identifier
+ * @param host			: pointer to host structure of mid-layer
+ * @param init_id		: initiator ID, the default value should be 7
+ * @param boot_enabled		: set if this device is boot capable
+ * @param bd_channel		: the physical channel number with boot device
+ * @param bd_target		: the target of the boot device
+ * @param virtual_ch		: the channel number to export logical drives on
+ * @param max_channel		: maximum channel number supported - inclusive
+ * @param max_target		: max target supported - inclusive
+ * @param max_lun		: max lun supported - inclusive
+ * @param device_ids		: to convert kernel device addr to our devices.
+ * @param max_cdb_sz		: biggest CDB size supported.
+ * @param max_cmds		: max outstanding commands
+ * @param ha			: is high availability present - clustering
+ * @param sglen			: max sg elements supported
+ * @param max_sectors		: max sectors per request
+ * @param cmd_per_lun		: max outstanding commands per LUN
+ * @param fw_version		: firmware version
+ * @param bios_version		: bios version
+ * @param ibuf			: buffer to issue internal commands
+ * @param ibuf_dma_h		: dma handle for the above buffer
+ * @param unique_id		: unique identifier for each adapter
+ * @param irq			: IRQ for this adapter
+ * @param mdevice		: each contoller's device data
+ * @param pdev			: pci configuration pointer for kernel
+ * @param lock			: synchronization lock for mid-layer and driver
+ * @param host_lock		: pointer to appropriate lock
+ * @param scb_list		: pointer to the bulk of SCBs memory area
+ * @param scb_pool		: pool of free scbs.
+ * @param scb_pool_lock		: lock for pool of free scbs.
+ * @param pend_list		: pending commands list
+ * @param pend_list_lock	: exlusion lock for pending commands list
+ * @param completed_list	: list of completed commands
+ * @param completed_list_lock	: exclusion lock for list of completed commands
+ * @param quiescent		: driver is quiescent for now.
+ * @param outstanding_cmds	: number of commands pending in the driver
+ * @param iscb			: control block for command issued internally
+ * @param isc			: associated SCSI command for generality
+ * @param imtx			: allow only one internal pending command
+ * @param ito			: internal timeout value, (-1) means no timeout
+ * @param icmd_recovery		: internal command path timed out
+ * @param stats			: IO stastics about the controller
+ * @param raid_device		: raid adapter specific pointer
+ *
+ * The fields init_id, boot_enabled, bd_channel, bd_target, virtual_ch,
+ * max_channel, max_target, max_lun, and device_ids are part of a subsytem
+ * called the device map.
+ * If LLDs want to have a flexbile booting order for their devices (boot from
+ * any logical or physical device) - they should make use of the framework
+ * APIs mraid_setup_device_map(adapter_t *) and
+ * MRAID_GET_DEVICE_MAP(adp, scp, channel, target, islogical).
+ *
+ * mraid_setup_device_map() can be called anytime after the device map is
+ * available and MRAID_GET_DEVICE_MAP() can be called whenever the mapping is
+ * required, usually from LLD's queue entry point. The formar API sets up the
+ * fields 'device_ids' with appropriate value. Make sure before calling this
+ * routine - all fields in device map are filled in otherwise unexpected
+ * behavior will result. The later uses this information to return information
+ * about the device in question. LLDs can use the macro
+ * MRAID_IS_LOGICAL(adapter_t *, struct scsi_cmnd *) to find out if the
+ * device in question is a logical drive.
+ *
+ * quiescent flag should be set by the driver if it is not accepting more
+ * commands
+ *
+ * If any internal command is timed out, icmd flag_recovery should be set and
+ * further internal commands will return error until the command is actually
+ * completed if ever.
+ */
+
+/*
+ * amount of space required to store the bios and firmware version strings
+ */
+#define VERSION_SIZE	16
+
+typedef struct {
+	struct list_head		list;
+	struct tasklet_struct		dpc_h;
+
+	const struct pci_device_id	*pci_id;
+	struct pci_dev			*pdev;
+	uint32_t			unique_id;
+	uint8_t				irq;
+
+	spinlock_t			*host_lock;
+	spinlock_t			lock;
+	scb_t				iscb;
+	Scsi_Cmnd			isc;
+	struct scsi_device		isdev;
+	struct semaphore		imtx;
+#define MRAID_STATE_SLEEP		0
+#define MRAID_WAKEUP_NORM		1
+#define MRAID_WAKEUP_TIMEOUT		2
+#define MRAID_INTERNAL_COMMAND		VENDOR_SPECIFIC_COMMAND
+
+	bool_t				quiescent;
+	int				outstanding_cmds;
+	uint8_t				ito;
+	uint8_t				icmd_recovery;
+	caddr_t				ibuf;
+	dma_addr_t			ibuf_dma_h;
+
+	scb_t				*scb_list;
+	struct list_head		scb_pool;
+	spinlock_t			scb_pool_lock;
+
+	struct list_head		pend_list;
+	spinlock_t			pend_list_lock;
+
+	struct list_head		completed_list;
+	spinlock_t			completed_list_lock;
+
+	uint8_t				max_channel;
+	uint16_t			max_target;
+	uint8_t				max_lun;
+	int				max_cmds;
+	uint8_t				fw_version[VERSION_SIZE];
+	uint8_t				bios_version[VERSION_SIZE];
+	uint8_t				max_cdb_sz;
+	bool_t				ha;
+	uint16_t			init_id;
+
+	bool_t				boot_enabled;
+	uint8_t				bd_channel;
+	uint16_t			bd_target;
+	uint8_t				virtual_ch;
+	int	device_ids[LSI_MAX_CHANNELS][LSI_MAX_LOGICAL_DRIVES_64LD];
+
+	struct Scsi_Host		*host;
+
+	uint16_t			sglen;
+	uint16_t			max_sectors;
+	uint16_t			cmd_per_lun;
+
+	caddr_t				raid_device;
+
+	atomic_t			being_detached;
+} adapter_t;
+
+#define FREE_LIST_LOCK(adapter)		(&adapter->scb_pool_lock)
+#define PENDING_LIST_LOCK(adapter)	(&adapter->pend_list_lock)
+#define COMPLETED_LIST_LOCK(adapter)	(&adapter->completed_list_lock)
+
+/**
+ * MRAID_GET_DEVICE_MAP - device ids
+ * @param adp		- Adapter's soft state
+ * @param scp		- mid-layer scsi command pointer
+ * @param p_chan	- physical channel on the controller
+ * @param target	- target id of the device or logical drive number
+ * @param islogical	- set if the command is for the logical drive
+ *
+ * Macro to retrieve information about device class, logical or physical and
+ * the corresponding physical channel and target or logical drive number
+ **/
+#define MRAID_GET_DEVICE_MAP(adp, scp, p_chan, target, islogical)	\
+	/*								\
+	 * Is the request coming for the virtual channel		\
+	 */								\
+	islogical = (SCP2CHANNEL(scp) == (adp)->virtual_ch) ? 1 : 0;	\
+									\
+	/*								\
+	 * Get an index into our table of drive ids mapping		\
+	 */								\
+	if (islogical) {						\
+		p_chan = 0xFF;						\
+		target =						\
+		(adp)->device_ids[(adp)->virtual_ch][SCP2TARGET(scp)];	\
+	}								\
+	else {								\
+		p_chan = ((adp)->device_ids[SCP2CHANNEL(scp)][SCP2TARGET(scp)] >> 8) & 0xFF;	\
+		target = ((adp)->device_ids[SCP2CHANNEL(scp)][SCP2TARGET(scp)] & 0xFF);	\
+	}
+
+#define MRAID_IS_LOGICAL(adp, scp)	\
+	(SCP2CHANNEL(scp) == (adp)->virtual_ch) ? 1 : 0;
+
+/**
+ * struct mraid_driver_t - global driver data
+ * @param is_pvt_intf		: Is intrface available for private interfaces
+ * @param driver_version	: driver version
+ * @param device_list		: list of adapter_t structures
+ * @param attach_count		: number of controllers detected by the driver
+ * @param raid_device		: array of attached raid controllers
+ *
+ * mraid_driver_t contains information which is global to the driver.
+ */
+typedef struct _mraid_driver_t {
+	uint8_t			driver_version[8];
+	struct list_head	device_list;
+	uint8_t			attach_count;
+} mraid_driver_t;
+
+
+/*
+ * ### Helper routines ###
+ */
+extern int debug_level;
+#define LSI_DBGLVL debug_level
+
+#ifdef DEBUG
+#if defined (_ASSERT_PANIC)
+#define ASSERT_ACTION	panic
+#else
+#define ASSERT_ACTION	printk
+#endif
+
+#define ASSERT(expression)						\
+	if (!(expression)) {						\
+	ASSERT_ACTION("assertion failed:(%s), file: %s, line: %d:%s\n",	\
+			#expression, __FILE__, __LINE__, __FUNCTION__);	\
+	}
+#else
+#define ASSERT(expression)
+#endif
+
+/*
+ * Library to allocate memory regions which are DMA'able
+ */
+/*
+ * struct mraid_pci_blk_pool - structure holds DMA memory pool info
+ * @param dev			: pci device that will be doing the DMA
+ * @param dmah_arr		: dma handle for allocated pages
+ * @param page_arr		: virtual addresses for all allocated pages
+ * @param page_count		: actual number of pages allocated
+ *
+ * Pool allocator, wraps the pci_alloc_consistent page allocator, so
+ * small blocks are easily used by drivers for bus mastering controllers.
+ *
+ * Limit number of pages to max MEMLIB_MAX_PAGES
+ */
+#define	MEMLIB_MAX_PAGES	64
+
+struct mraid_pci_blk_pool {
+	struct pci_dev	*dev;
+	dma_addr_t	dmah_arr[MEMLIB_MAX_PAGES];
+	caddr_t		page_arr[MEMLIB_MAX_PAGES];
+	int		page_count;
+};
+
+/*
+ * struct mraid_pci_blk - structure holds DMA memory block info
+ * @param vaddr		: virtual address to a memory block
+ * @param dma_addr	: DMA handle to a memory block
+ *
+ * This structure is filled up for the caller. It is the responsibilty of the
+ * caller to allocate this array big enough to store addresses for all
+ * requested elements
+ */
+struct mraid_pci_blk {
+	caddr_t		vaddr;
+	dma_addr_t	dma_addr;
+};
+
+void mraid_sleep(int);
+void mraid_setup_device_map(adapter_t *);
+struct mraid_pci_blk_pool *mraid_pci_blk_pool_create(struct pci_dev *,
+	size_t, size_t, size_t, struct mraid_pci_blk[]);
+void mraid_pci_blk_pool_destroy(struct mraid_pci_blk_pool *);
+
+#endif /* _MEGA_COMMON_H_ */
+
+/* vim: set ts=8 sw=8 tw=78: */
diff -Naur linux-2.6.6.orig/drivers/scsi/megaraid/megaraid_clib.c linux-2.6.6/drivers/scsi/megaraid/megaraid_clib.c
--- linux-2.6.6.orig/drivers/scsi/megaraid/megaraid_clib.c	Wed Dec 31 19:00:00 1969
+++ linux-2.6.6/drivers/scsi/megaraid/megaraid_clib.c	Sat May 15 13:35:04 2004
@@ -0,0 +1,276 @@
+/*
+ *
+ *			Linux MegaRAID device driver
+ *
+ * Copyright (c) 2003-2004  LSI Logic Corporation.
+ *
+ *	   This program is free software; you can redistribute it and/or
+ *	   modify it under the terms of the GNU General Public License
+ *	   as published by the Free Software Foundation; either version
+ *	   2 of the License, or (at your option) any later version.
+ *
+ * FILE		: megaraid_clib.c
+ * Version	: v2.20.0 (Apr 14 2004)
+ *
+ * Libaray of common routine used by all megaraid drivers.
+ */
+
+#include "kdep.h"
+#include "mega_common.h"
+
+static void __mraid_wakeup(unsigned long);
+
+/*
+ * debug level - threshold for amount of information to be displayed by the
+ * driver. This level can be changed through modules parameters, ioctl or
+ * sysfs/proc interface. By default, print the announcement messages only.
+ */
+int debug_level = CL_ANN;
+MODULE_PARM(debug_level, "i");
+MODULE_PARM_DESC(debug_level, "Debug level for driver (default=0)");
+
+/**
+ * mraid_setup_device_map - manage device ids
+ * @adapter	: Driver's soft state
+ *
+ * Manange the device ids to have an appropraite mapping between the kernel
+ * scsi addresses and megaraid scsi and logical drive addresses. We export
+ * scsi devices on their actual addresses, whereas the logical drives are
+ * exported on a virtual scsi channel.
+ **/
+void
+mraid_setup_device_map(adapter_t *adapter)
+{
+	uint8_t		c;
+	uint8_t		t;
+
+	/*
+	 * First fill the values on the logical drive channel
+	 */
+	for (t = 0; t < LSI_MAX_LOGICAL_DRIVES_64LD; t++)
+		adapter->device_ids[adapter->max_channel][t] =
+			(t < adapter->init_id) ?  t : t - 1;
+
+	adapter->device_ids[adapter->max_channel][adapter->init_id] = 0xFF;
+
+	/*
+	 * Fill the values on the physical devices channels
+	 */
+	for (c = 0; c < adapter->max_channel; c++)
+		for (t = 0; t < LSI_MAX_LOGICAL_DRIVES_64LD; t++)
+			adapter->device_ids[c][t] = (c << 8) | t;
+}
+
+
+/*
+ * Library to allocate memory regions which are DMA'able
+ */
+
+/**
+ * mraid_pci_blk_pool_create - Creates a pool of pci consistent memory
+ * blocks for DMA.
+ * @dev		: pci device that will be doing the DMA
+ * @blk_count	: number of memory blocks to be created.
+ * @blk_size	: size of each blocks to be created.
+ * @blk_align	: alignment requirement for blocks; must be a power of two
+ * @blk		: array of DMA block pointers where each block information
+ * returned.
+ *
+ * Returns a pci allocation pool handle with the requested characteristics,
+ * or null if one can't be created.  mraid_pci_blk_pool_create()
+ * may be used to allocate memory.  Such memory will all have "consistent"
+ * DMA mappings, accessible by the device and its driver without using
+ * cache flushing primitives.  The actual size of blocks allocated may be
+ * larger than requested because of alignment.
+ *
+ * NOTE: This library must be used for requests less than PAGE_SIZE
+ */
+struct mraid_pci_blk_pool *
+mraid_pci_blk_pool_create(struct pci_dev *dev, size_t blk_count, size_t
+	blk_size, size_t blk_align, struct mraid_pci_blk blk[])
+{
+	struct mraid_pci_blk_pool	*pool;
+	size_t				each_blk_size = blk_size;
+	int				blks_per_page;
+	int				num_pages;
+	int				pg_idx;
+	caddr_t				page_addr;
+	dma_addr_t			tmp_dmah;
+	int				i;
+
+	if (blk_align == 0) blk_align = 1;
+
+	if (blk_count == 0 || each_blk_size == 0) return NULL;
+
+	if (each_blk_size < blk_align) {
+		each_blk_size = blk_align;
+	}
+	else if ((each_blk_size % blk_align) != 0) {
+		each_blk_size += blk_align + 1;
+		each_blk_size &= ~(blk_align - 1);
+	}
+
+	/*
+	 * each_blk_size is the actual size that we apportion for each block.
+	 * Note that each_blk_size >= blk_size
+	 *
+	 * Next task is to find the number of blocks (each_blk_size) that we
+	 * can fit in a single page.
+	 */
+	blks_per_page = PAGE_SIZE / each_blk_size;
+
+	if (!blks_per_page) {
+		con_log(CL_ANN, (KERN_WARNING
+		"megaraid: memlib request more than PAGE_SIZE buffer.\n"));
+
+		return NULL;
+	}
+
+	/*
+	 * If the number of blocks that we cat fit in a page is blks_per_page,
+	 * then the total number of pages required to accommodate "blk_count"
+	 * number of blocks is ...
+	 */
+	num_pages = ( (blk_count - 1) / blks_per_page ) + 1;
+
+	if (num_pages > MEMLIB_MAX_PAGES) {
+		con_log(CL_ANN, (KERN_WARNING
+		"megaraid: not allocating %#x pages\n", num_pages));
+
+		return NULL;
+	}
+
+	/*
+	 * Let us allocate the mraid_pci_blk_pool first. This is akin to the
+	 * handle that the client must pass back to us to deallocate memory
+	 */
+	pool = kmalloc(sizeof (struct mraid_pci_blk_pool), GFP_KERNEL);
+	if (pool == NULL) return NULL;
+
+	/*
+	 * Initialize the pool
+	 */
+	memset(pool, 0, sizeof(struct mraid_pci_blk_pool));
+	pool->page_count = num_pages;
+	pool->dev = dev;
+
+	/*
+	 * Allocate all pages in a loop
+	 */
+	for (i = 0; i < num_pages; i++) {
+
+		pool->page_arr[i] = pci_alloc_consistent( dev, PAGE_SIZE-1,
+							&pool->dmah_arr[i] );
+		if (pool->page_arr[i] == NULL) {
+			con_log(CL_ANN, (KERN_WARNING
+				"megaraid: Failed to alloc page # %d\n", i ));
+			goto memlib_fail_alloc;
+		}
+	}
+
+
+	/*
+	 * Now we have required number of pages. All we have to do is to divy
+	 * up each page into blks_per_page number of blocks
+	 */
+	pg_idx		= -1;
+	page_addr	= NULL;
+	tmp_dmah	= 0;
+
+	for (i = 0; i < blk_count; i++) {
+
+		if ((i % blks_per_page) == 0) {
+			pg_idx++;
+			page_addr	= pool->page_arr[ pg_idx ];
+			tmp_dmah	= pool->dmah_arr[ pg_idx ];
+		}
+
+		blk[i].vaddr	= page_addr;
+		blk[i].dma_addr	= tmp_dmah;
+
+		page_addr	+= each_blk_size;
+		tmp_dmah	+= each_blk_size;
+	}
+
+	return pool;
+
+memlib_fail_alloc:
+
+	mraid_pci_blk_pool_destroy( pool );
+	return NULL;
+}
+
+
+/**
+ * mraid_pci_pool_destroy - destroys a pool of pci memory blocks.
+ * @blk_pool	: pci block pool that will be destroyed
+ *
+ * Caller guarantees that no more memory from the pool is in use.
+ */
+void
+mraid_pci_blk_pool_destroy(struct mraid_pci_blk_pool *blk_pool)
+{
+	int i;
+
+	if (!blk_pool) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid critical: null pointer for pool destroy\n"));
+		return;
+	}
+
+	for (i = 0; i < blk_pool->page_count; i++) {
+
+		if (blk_pool->page_arr[i]) {
+			pci_free_consistent( blk_pool->dev, PAGE_SIZE-1,
+						blk_pool->page_arr[i],
+						blk_pool->dmah_arr[i] );
+			blk_pool->dmah_arr[i] = 0;
+			blk_pool->page_arr[i] = NULL;
+		}
+	}
+
+	kfree( blk_pool );
+}
+
+
+/**
+ * mraid_sleep - induces sleep for specified number of seconds
+ * @param seconds	: number of seconds to sleep for
+ */
+void
+mraid_sleep(int seconds)
+{
+	struct timer_list	timer;
+	struct __sleep_obj {
+		wait_queue_head_t       wq;
+		int			sem;
+	} sleep_obj;
+
+
+	init_waitqueue_head(&sleep_obj.wq);
+	sleep_obj.sem = 0;
+
+	init_timer(&timer);
+	timer.function	= __mraid_wakeup;
+	timer.data	= (unsigned long)&sleep_obj;
+	timer.expires	= jiffies + seconds*HZ;
+	add_timer(&timer);
+
+	wait_event(sleep_obj.wq, sleep_obj.sem);
+
+}
+
+static void
+__mraid_wakeup(unsigned long ptr)
+{
+	struct __sleep_obj {
+		wait_queue_head_t       wq;
+		int			sem;
+	} *sleep_objp;
+
+	sleep_objp = (struct __sleep_obj *)ptr;
+
+	wake_up(&sleep_objp->wq);
+}
+
+/* vim: set ts=8 sw=8 tw=78 ai si: */
diff -Naur linux-2.6.6.orig/drivers/scsi/megaraid/megaraid_mbox.c linux-2.6.6/drivers/scsi/megaraid/megaraid_mbox.c
--- linux-2.6.6.orig/drivers/scsi/megaraid/megaraid_mbox.c	Wed Dec 31 19:00:00 1969
+++ linux-2.6.6/drivers/scsi/megaraid/megaraid_mbox.c	Sat May 15 13:35:04 2004
@@ -0,0 +1,3966 @@
+/*
+ *
+ *			Linux MegaRAID device driver
+ *
+ * Copyright (c) 2003-2004  LSI Logic Corporation.
+ *
+ *	   This program is free software; you can redistribute it and/or
+ *	   modify it under the terms of the GNU General Public License
+ *	   as published by the Free Software Foundation; either version
+ *	   2 of the License, or (at your option) any later version.
+ *
+ * FILE		: megaraid.c
+ * Version	: v2.20.0.rc2 (May 21 2004)
+ *
+ * Authors:
+ * 	Atul Mukker		<Atul.Mukker@lsil.com>
+ * 	Sreenivas Bagalkote	<Sreenivas.Bagalkote@lsil.com>
+ * 	Manoj Jose		<Manoj.Jose@lsil.com>
+ *
+ * List of supported controllers
+ *
+ * OEM	Product Name	NickName	Ser	VID	DID	SSVID	SSID
+ * ---	------------	-------		---	---	---	----	----
+ * Dell	PERC3/Di 	Discovery	N/A	1028	000E	1028	0123
+ * Dell	PERC4/SC			520	1000	1960	1028	0520
+ * Dell	PERC4/DC			518	1000	1960	1028	0518
+ * Dell	PERC4/QC			531	1000	0407	1028	0531
+ * Dell	PERC4/Di	Everglades	N/A	1028	000F	1028	014A
+ * Dell	PERC 4e/Si	Big Bend	N/A	1028	0013	1028	016c
+ * Dell	PERC 4e/Di	Kobuk		N/A	1028	0013	1028	016d
+ * Dell	PERC 4e/Di	Corvette	N/A	1028	0013	1028	016e
+ * Dell	PERC 4e/Di	Expedition	N/A	1028	0013	1028	016f
+ * Dell	PERC 4e/Di	Guadalupe	N/A	1028	0013	1028	0170
+ * Dell	PERC 4e/DC	320-2E		N/A	1000	0408	1028	0002
+ * Dell	PERC 4e/SC	320-1E		N/A	1000	0408	1028	0001
+ *
+ *
+ * LSI	MegaRAID SCSI 320-2XR		EP033	1000	0040	1000	0033
+ * 	Baracuda
+ * LSI	MegaRAID SCSI 320-2XRWS		EP066	1000	0040	1000	0066
+ * 	Low Profile
+ * LSI	MegaRAID SCSI 320-1XR
+ * 	Trinidad
+ * LSI	MegaRAID SCSI 320-0		520-0	1000	1960	1000	A520
+ * LSI	MegaRAID SCSI 320-1		520	1000	1960	1000	0520
+ * LSI	MegaRAID SCSI 320-2		518	1000	1960	1000	0518
+ * LSI	MegaRAID SCSI 320-0X	ZCR	EP055	1000	0407	1000	0530
+ * LSI	MegaRAID SCSI 320-2X		532	1000	0407	1000	0532
+ * LSI	MegaRAID SCSI 320-4X		531	1000	0407	1000	0531
+ *
+ *
+ * LSI	MegaRAID SCSI 320-1E	Aruba	N/A	1000	0408	1000	0001
+ * LSI	MegaRAID SCSI 320-2E	Cayman	EP078	1000	0408	1000	0002
+ * LSI	MegaRAID SCSI 320-4E	Bermuda
+ *
+ *
+ * LSI	MegaRAID SATA 150-2		534	1095	3112	1000	0534
+ * LSI	MegaRAID SATA 150-4		523	1000	1960	1000	4523
+ * LSI	MegaRAID SATA 150-6		523	1000	1960	1000	0523
+ * LSI	MegaRAID SATA 150-4X			1000	0409	1000	1504
+ * LSI	MegaRAID SATA 150-8X			1000	0409	1000	1508
+ *
+ * For history of changes, see changelog.megaraid
+ */
+
+#include "megaraid_mbox.h"
+
+static int megaraid_init(void);
+static void megaraid_exit(void);
+
+static int megaraid_probe_one(struct pci_dev*, const struct pci_device_id*);
+static void megaraid_detach_one(struct pci_dev *);
+static void megaraid_mbox_shutdown(struct device *);
+
+static status_t megaraid_io_attach(adapter_t *);
+static void megaraid_io_detach(adapter_t *);
+
+static status_t megaraid_alloc_cmd_packets(adapter_t *);
+static void megaraid_free_cmd_packets(adapter_t *);
+
+static status_t megaraid_init_mbox(adapter_t *);
+static void megaraid_fini_mbox(adapter_t *);
+
+static int megaraid_abort_handler(struct scsi_cmnd *);
+static int megaraid_reset_handler(struct scsi_cmnd *);
+static int mbox_post_sync_cmd(adapter_t *, uint8_t []);
+static int mbox_post_sync_cmd_fast(adapter_t *, uint8_t []);
+
+static status_t megaraid_mbox_product_info(adapter_t *);
+static status_t megaraid_mbox_extended_cdb(adapter_t *);
+static int megaraid_mbox_support_random_del(adapter_t *);
+static status_t megaraid_mbox_support_ha(adapter_t *, uint16_t *);
+static int megaraid_mbox_get_max_sg(adapter_t *);
+static void megaraid_mbox_enum_raid_scsi(adapter_t *);
+static void megaraid_mbox_flush_cache(adapter_t *);
+
+static void megaraid_mbox_display_scb(adapter_t *, scb_t *, int);
+
+static int megaraid_queue_command(struct scsi_cmnd *,
+		void (*)(struct scsi_cmnd *));
+
+static const char *megaraid_info(struct Scsi_Host *);
+
+static inline scb_t *megaraid_mbox_build_cmd(adapter_t *, Scsi_Cmnd *, int *);
+static inline scb_t *megaraid_alloc_scb(adapter_t *, struct scsi_cmnd *);
+static inline void megaraid_dealloc_scb(adapter_t *, scb_t *);
+static inline void megaraid_mbox_prepare_pthru(adapter_t *, scb_t *,
+		Scsi_Cmnd *);
+static inline void megaraid_mbox_prepare_epthru(adapter_t *, scb_t *,
+		Scsi_Cmnd *);
+static inline int megaraid_mbox_mksgl(adapter_t *, scb_t *, uint32_t *,
+		uint32_t *);
+
+static inline void megaraid_mbox_runpendq(adapter_t *);
+static inline status_t mbox_post_cmd(adapter_t *, scb_t *);
+
+static void megaraid_mbox_dpc(unsigned long);
+static inline void megaraid_mbox_sync_scb(adapter_t *, scb_t *);
+
+static irqreturn_t megaraid_isr(int, void *, struct pt_regs *);
+static inline int megaraid_ack_sequence(adapter_t *);
+
+static inline status_t megaraid_busywait_mbox(mraid_device_t *);
+static inline status_t __megaraid_busywait_mbox(mraid_device_t *);
+
+static status_t megaraid_cmm_register(adapter_t *);
+static status_t megaraid_cmm_unregister(adapter_t *);
+static int megaraid_mbox_mm_cmd(unsigned long, uioc_t*, uint32_t);
+static int megaraid_mbox_internal_command(adapter_t *, uioc_t *);
+static void megaraid_mbox_internal_done(Scsi_Cmnd *);
+static int gather_hbainfo(adapter_t *, mraid_hba_info_t *);
+static int wait_till_fw_empty(adapter_t*);
+
+
+
+MODULE_AUTHOR("LSI Logic Corporation");
+MODULE_DESCRIPTION("LSI Logic MegaRAID unified driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(MEGARAID_VERSION);
+
+/*
+ * ### modules parameters for driver ###
+ */
+
+/*
+ * Set to enable driver to expose unconfigured disk to kernel
+ */
+static int megaraid_expose_unconf_disks = 0;
+module_param(megaraid_expose_unconf_disks, int, 0);
+MODULE_PARM_DESC(megaraid_expose_unconf_disks,
+	"Set to expose unconfigured disks to kernel (default=0)");
+
+/**
+ * driver wait time if the adapter's mailbox is busy
+ */
+static unsigned int max_mbox_busy_wait = MBOX_BUSY_WAIT;
+module_param(max_mbox_busy_wait, int, 0);
+MODULE_PARM_DESC(max_mbox_busy_wait,
+	"Max wait for mailbox in microseconds if busy (default=10)");
+
+/**
+ * number of sectors per IO command
+ */
+static unsigned int megaraid_max_sectors = MBOX_MAX_SECTORS;
+module_param(megaraid_max_sectors, int, 0);
+MODULE_PARM_DESC(megaraid_max_sectors,
+	"Maximum number of sectors per IO command (default=128)");
+
+/**
+ * number of commands per logical unit
+ */
+static unsigned int megaraid_cmd_per_lun = MBOX_DEF_CMD_PER_LUN;
+module_param(megaraid_cmd_per_lun, int, 0);
+MODULE_PARM_DESC(megaraid_cmd_per_lun,
+	"Maximum number of commands per logical unit (default=256)");
+
+
+/**
+ * Fast driver load option, skip scanning for physical devices during load.
+ * This would result in non-disk devices being skipped during driver load
+ * time. These can be later added though, using /proc/scsi/scsi
+ */
+static unsigned int megaraid_fast_load = 0;
+module_param(megaraid_fast_load, int, 0);
+MODULE_PARM_DESC(megaraid_fast_load,
+	"Faster loading of the driver, skips physical devices! (default=0)");
+
+
+/*
+ * ### global data ###
+ */
+mraid_driver_t mraid_driver_g = {
+	.driver_version	= { 0x02, 0x20, 0x00, 0xB3, 5, 12, 20, 4},
+};
+
+
+/*
+ * PCI table for all supported controllers.
+ */
+static struct pci_device_id pci_id_table_g[] =  {
+	{
+		.vendor		= PCI_VENDOR_ID_DELL,
+		.device		= PCI_DEVICE_ID_PERC4_DI_DISCOVERY,
+		.subvendor	= PCI_VENDOR_ID_DELL,
+		.subdevice	= PCI_SUBSYS_ID_PERC4_DI_DISCOVERY,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_LSI_LOGIC,
+		.device		= PCI_DEVICE_ID_PERC4_SC,
+		.subvendor	= PCI_VENDOR_ID_DELL,
+		.subdevice	= PCI_SUBSYS_ID_PERC4_SC,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_LSI_LOGIC,
+		.device		= PCI_DEVICE_ID_PERC4_DC,
+		.subvendor	= PCI_VENDOR_ID_DELL,
+		.subdevice	= PCI_SUBSYS_ID_PERC4_DC,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_LSI_LOGIC,
+		.device		= PCI_DEVICE_ID_PERC4_QC,
+		.subvendor	= PCI_VENDOR_ID_DELL,
+		.subdevice	= PCI_SUBSYS_ID_PERC4_QC,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_DELL,
+		.device		= PCI_DEVICE_ID_PERC4_DI_EVERGLADES,
+		.subvendor	= PCI_VENDOR_ID_DELL,
+		.subdevice	= PCI_SUBSYS_ID_PERC4_DI_EVERGLADES,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_DELL,
+		.device		= PCI_DEVICE_ID_PERC4E_SI_BIGBEND,
+		.subvendor	= PCI_VENDOR_ID_DELL,
+		.subdevice	= PCI_SUBSYS_ID_PERC4E_SI_BIGBEND,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_DELL,
+		.device		= PCI_DEVICE_ID_PERC4E_DI_KOBUK,
+		.subvendor	= PCI_VENDOR_ID_DELL,
+		.subdevice	= PCI_SUBSYS_ID_PERC4E_DI_KOBUK,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_DELL,
+		.device		= PCI_DEVICE_ID_PERC4E_DI_CORVETTE,
+		.subvendor	= PCI_VENDOR_ID_DELL,
+		.subdevice	= PCI_SUBSYS_ID_PERC4E_DI_CORVETTE,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_DELL,
+		.device		= PCI_DEVICE_ID_PERC4E_DI_EXPEDITION,
+		.subvendor	= PCI_VENDOR_ID_DELL,
+		.subdevice	= PCI_SUBSYS_ID_PERC4E_DI_EXPEDITION,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_DELL,
+		.device		= PCI_DEVICE_ID_PERC4E_DI_GUADALUPE,
+		.subvendor	= PCI_VENDOR_ID_DELL,
+		.subdevice	= PCI_SUBSYS_ID_PERC4E_DI_GUADALUPE,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_LSI_LOGIC,
+		.device		= PCI_DEVICE_ID_PERC4E_DC_320_2E,
+		.subvendor	= PCI_VENDOR_ID_DELL,
+		.subdevice	= PCI_SUBSYS_ID_PERC4E_DC_320_2E,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_LSI_LOGIC,
+		.device		= PCI_DEVICE_ID_PERC4E_SC_320_1E,
+		.subvendor	= PCI_VENDOR_ID_DELL,
+		.subdevice	= PCI_SUBSYS_ID_PERC4E_SC_320_1E,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_AMI,
+		.device		= PCI_DEVICE_ID_AMI_MEGARAID3,
+		.subvendor	= PCI_VENDOR_ID_DELL,
+		.subdevice	= PCI_SUBSYS_ID_PERC3_DC,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_LSI_LOGIC,
+		.device		= PCI_DEVICE_ID_MEGARAID_SCSI_320_0,
+		.subvendor	= PCI_VENDOR_ID_LSI_LOGIC,
+		.subdevice	= PCI_SUBSYS_ID_MEGARAID_SCSI_320_0,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_LSI_LOGIC,
+		.device		= PCI_DEVICE_ID_MEGARAID_SCSI_320_1,
+		.subvendor	= PCI_VENDOR_ID_LSI_LOGIC,
+		.subdevice	= PCI_SUBSYS_ID_MEGARAID_SCSI_320_1,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_LSI_LOGIC,
+		.device		= PCI_DEVICE_ID_MEGARAID_SCSI_320_2,
+		.subvendor	= PCI_VENDOR_ID_LSI_LOGIC,
+		.subdevice	= PCI_SUBSYS_ID_MEGARAID_SCSI_320_2,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_LSI_LOGIC,
+		.device		= PCI_DEVICE_ID_MEGARAID_SCSI_320_0x,
+		.subvendor	= PCI_VENDOR_ID_LSI_LOGIC,
+		.subdevice	= PCI_SUBSYS_ID_MEGARAID_SCSI_320_0x,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_LSI_LOGIC,
+		.device		= PCI_DEVICE_ID_MEGARAID_SCSI_320_2x,
+		.subvendor	= PCI_VENDOR_ID_LSI_LOGIC,
+		.subdevice	= PCI_SUBSYS_ID_MEGARAID_SCSI_320_2x,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_LSI_LOGIC,
+		.device		= PCI_DEVICE_ID_MEGARAID_SCSI_320_4x,
+		.subvendor	= PCI_VENDOR_ID_LSI_LOGIC,
+		.subdevice	= PCI_SUBSYS_ID_MEGARAID_SCSI_320_4x,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_LSI_LOGIC,
+		.device		= PCI_DEVICE_ID_MEGARAID_SCSI_320_1E,
+		.subvendor	= PCI_VENDOR_ID_LSI_LOGIC,
+		.subdevice	= PCI_SUBSYS_ID_MEGARAID_SCSI_320_1E,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_LSI_LOGIC,
+		.device		= PCI_DEVICE_ID_MEGARAID_SCSI_320_2E,
+		.subvendor	= PCI_VENDOR_ID_LSI_LOGIC,
+		.subdevice	= PCI_SUBSYS_ID_MEGARAID_SCSI_320_2E,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_LSI_LOGIC,
+		.device		= PCI_DEVICE_ID_MEGARAID_SATA_150_4,
+		.subvendor	= PCI_VENDOR_ID_LSI_LOGIC,
+		.subdevice	= PCI_SUBSYS_ID_MEGARAID_SATA_150_4,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_LSI_LOGIC,
+		.device		= PCI_DEVICE_ID_MEGARAID_SATA_150_6,
+		.subvendor	= PCI_VENDOR_ID_LSI_LOGIC,
+		.subdevice	= PCI_SUBSYS_ID_MEGARAID_SATA_150_6,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_LSI_LOGIC,
+		.device		= PCI_DEVICE_ID_MEGARAID_SATA_300_4x,
+		.subvendor	= PCI_VENDOR_ID_LSI_LOGIC,
+		.subdevice	= PCI_SUBSYS_ID_MEGARAID_SATA_300_4x,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_LSI_LOGIC,
+		.device		= PCI_DEVICE_ID_MEGARAID_SATA_300_8x,
+		.subvendor	= PCI_VENDOR_ID_LSI_LOGIC,
+		.subdevice	= PCI_SUBSYS_ID_MEGARAID_SATA_300_8x,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_LSI_LOGIC,
+		.device		= PCI_DEVICE_ID_INTEL_RAID_SRCU42X,
+		.subvendor	= PCI_VENDOR_ID_INTEL,
+		.subdevice	= PCI_SUBSYS_ID_INTEL_RAID_SRCU42X,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_LSI_LOGIC,
+		.device		= PCI_DEVICE_ID_INTEL_RAID_SRCS16,
+		.subvendor	= PCI_VENDOR_ID_INTEL,
+		.subdevice	= PCI_SUBSYS_ID_INTEL_RAID_SRCS16,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_LSI_LOGIC,
+		.device		= PCI_DEVICE_ID_INTEL_RAID_SRCU42E,
+		.subvendor	= PCI_VENDOR_ID_INTEL,
+		.subdevice	= PCI_SUBSYS_ID_INTEL_RAID_SRCU42E,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_LSI_LOGIC,
+		.device		= PCI_DEVICE_ID_INTEL_RAID_SRCZCRX,
+		.subvendor	= PCI_VENDOR_ID_INTEL,
+		.subdevice	= PCI_SUBSYS_ID_INTEL_RAID_SRCZCRX,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_LSI_LOGIC,
+		.device		= PCI_DEVICE_ID_INTEL_RAID_SRCS28X,
+		.subvendor	= PCI_VENDOR_ID_INTEL,
+		.subdevice	= PCI_SUBSYS_ID_INTEL_RAID_SRCS28X,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_LSI_LOGIC,
+		.device		= PCI_DEVICE_ID_INTEL_RAID_SROMBU42E_ALIEF,
+		.subvendor	= PCI_VENDOR_ID_INTEL,
+		.subdevice	= PCI_SUBSYS_ID_INTEL_RAID_SROMBU42E_ALIEF,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_LSI_LOGIC,
+		.device		= PCI_DEVICE_ID_INTEL_RAID_SROMBU42E_HARWICH,
+		.subvendor	= PCI_VENDOR_ID_INTEL,
+		.subdevice	= PCI_SUBSYS_ID_INTEL_RAID_SROMBU42E_HARWICH,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{
+		.vendor		= PCI_VENDOR_ID_LSI_LOGIC,
+		.device		= PCI_DEVICE_ID_FSC_MEGARAID_PCI_EXPRESS_ROMB,
+		.subvendor	= PCI_SUBSYS_ID_FSC,
+		.subdevice	= PCI_SUBSYS_ID_FSC_MEGARAID_PCI_EXPRESS_ROMB,
+		.class		= PCI_CLASS_STORAGE_RAID << 8,
+		.class_mask	= 0xFFFF00,
+		.driver_data	= 0
+	},
+	{0}	/* Terminating entry */
+};
+MODULE_DEVICE_TABLE(pci, pci_id_table_g);
+
+
+static struct pci_driver megaraid_pci_driver_g = {
+	.name		= "megaraid",
+	.id_table	= pci_id_table_g,
+	.probe		= megaraid_probe_one,
+	.remove		= __devexit_p(megaraid_detach_one),
+	.driver		= {
+		.shutdown	= megaraid_mbox_shutdown,
+	}
+};
+
+
+/*
+ * Scsi host template for megaraid unified driver
+ */
+#define MRAID_TEMPLATE							\
+{									\
+	.module				= THIS_MODULE,			\
+	.name				= "MegaRAID",			\
+	.proc_name			= "megaraid",			\
+	.info				= megaraid_info,		\
+	.queuecommand			= megaraid_queue_command,	\
+	.eh_abort_handler		= megaraid_abort_handler,	\
+	.eh_device_reset_handler	= megaraid_reset_handler,	\
+	.eh_bus_reset_handler		= megaraid_reset_handler,	\
+	.eh_host_reset_handler		= megaraid_reset_handler,	\
+	.use_clustering			= ENABLE_CLUSTERING,		\
+}
+
+static Scsi_Host_Template megaraid_template_g = MRAID_TEMPLATE;
+static Scsi_Host_Template *megaraid_template_gp = &megaraid_template_g;
+
+
+/**
+ * megaraid_init - module load hook
+ *
+ * We register ourselves as hotplug enabled module and let PCI subsystem
+ * discover our adaters
+ **/
+static int __init
+megaraid_init(void)
+{
+	int			rval;
+
+	// Announce the driver version
+	con_log(CL_ANN, (KERN_INFO "megaraid: %s %s\n", MEGARAID_VERSION,
+		MEGARAID_EXT_VERSION));
+
+	// check validity of module parameters
+	if (megaraid_cmd_per_lun > MBOX_MAX_DRIVER_CMDS) {
+
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid mailbox: max commands per lun reset to %d\n",
+			MBOX_MAX_DRIVER_CMDS));
+
+		megaraid_cmd_per_lun = MBOX_MAX_DRIVER_CMDS;
+	}
+
+
+	/*
+	 * Setup the driver global data structures
+	 */
+	INIT_LIST_HEAD(&mraid_driver_g.device_list);
+
+	// register as a PCI hot-plug driver module
+	if ((rval = pci_module_init(&megaraid_pci_driver_g))) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: could not register hotplug support.\n"));
+	}
+
+	return rval;
+}
+
+
+/**
+ * megaraid_exit - driver unload entry point
+ *
+ * We simply unwrap the megaraid_init routine here
+ */
+static void __exit
+megaraid_exit(void)
+{
+	con_log(CL_DLEVEL1, (KERN_NOTICE "megaraid: unloading framework\n"));
+
+	// unregister as PCI hotplug driver
+	pci_unregister_driver(&megaraid_pci_driver_g);
+
+	// All adapters must be detached by now
+	ASSERT(list_empty(&mraid_driver_g.device_list));
+
+	return;
+}
+
+
+/**
+ * megaraid_probe_one - PCI hotplug entry point
+ * @param pdev	: handle to this controller's PCI configuration space
+ * @param id	: pci device id of the class of controllers
+ *
+ * This routine should be called whenever a new adapter is detected by the
+ * PCI hotplug susbsytem.
+ **/
+static int __devinit
+megaraid_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
+{
+	adapter_t		*adapter;
+	uint32_t		unique_id;
+	struct list_head	*next;
+	int			alloc_adapter_f	= 0;
+	int			init_mbox_f	= 0;
+
+
+	// Make sure this adapter is not already setup
+	unique_id	= pdev->bus->number << 8 | pdev->devfn;
+
+	list_for_each(next, &mraid_driver_g.device_list) {
+		adapter = list_entry(next, adapter_t, list);
+
+		if (adapter->unique_id == unique_id) {
+
+			con_log(CL_ANN, (KERN_WARNING
+				"megaraid: reject re-init request for dev: "));
+
+			con_log(CL_ANN, ("%#4.04x:%#4.04x:%#4.04x:%#4.04x:",
+				pdev->vendor, pdev->device,
+				pdev->subsystem_vendor,
+				pdev->subsystem_device));
+
+			con_log(CL_ANN, ("bus %d:slot %d:func %d\n",
+				pdev->bus->number, PCI_SLOT(pdev->devfn),
+				PCI_FUNC(pdev->devfn)));
+
+			return -ENODEV;	// already initialized
+		}
+	}
+
+
+	// detected a new controller
+	con_log(CL_ANN, (KERN_INFO
+		"megaraid: probe new device %#4.04x:%#4.04x:%#4.04x:%#4.04x: ",
+		pdev->vendor, pdev->device, pdev->subsystem_vendor,
+		pdev->subsystem_device));
+
+	con_log(CL_ANN, ("bus %d:slot %d:func %d\n", pdev->bus->number,
+		PCI_SLOT(pdev->devfn), PCI_FUNC(pdev->devfn)));
+
+	if (pci_enable_device(pdev)) {
+		con_log(CL_ANN, (KERN_WARNING
+				"megaraid: pci_enable_device failed\n"));
+		return -ENODEV;
+	}
+
+	// Enable bus-mastering on this controller
+	pci_set_master(pdev);
+
+	// Allocate the per driver initialization structure
+	adapter = kmalloc(sizeof(adapter_t), GFP_KERNEL);
+
+	if (adapter == NULL) {
+		con_log(CL_ANN, (KERN_WARNING
+		"megaraid: out of memory, %s %d.\n", __FUNCTION__, __LINE__));
+
+		goto fail_probe;
+	}
+	alloc_adapter_f = 1;
+	memset(adapter, 0, sizeof(adapter_t));
+
+
+	// set up PCI related soft state and other pre-known parameters
+	adapter->unique_id	= unique_id;
+	adapter->irq		= pdev->irq;
+	adapter->pci_id		= id;
+	adapter->pdev		= pdev;
+
+	atomic_set(&adapter->being_detached, 0);
+
+	// Setup the default DMA mask. This would be changed later on
+	// depending on hardware capabilities
+	if (pci_set_dma_mask(adapter->pdev, 0xFFFFFFFF) != 0) {
+
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: pci_set_dma_mask failed:%d\n", __LINE__));
+
+		goto fail_probe;
+	}
+
+
+	// Initialize the synchronization lock for kernel and LLD
+	spin_lock_init(&adapter->lock);
+	adapter->host_lock = &adapter->lock;
+
+
+	// Setup resources to issue internal commands with interrupts availble
+	init_MUTEX(&adapter->imtx);
+
+
+	// Initialize the command queues: the list of free SCBs and the list
+	// of pending SCBs.
+	INIT_LIST_HEAD(&adapter->scb_pool);
+	spin_lock_init(FREE_LIST_LOCK(adapter));
+
+	INIT_LIST_HEAD(&adapter->pend_list);
+	spin_lock_init(PENDING_LIST_LOCK(adapter));
+
+	INIT_LIST_HEAD(&adapter->completed_list);
+	spin_lock_init(COMPLETED_LIST_LOCK(adapter));
+
+
+	// Start the mailbox based controller
+	if (megaraid_init_mbox(adapter) != MRAID_SUCCESS) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: maibox adapter did not initialize\n"));
+
+		goto fail_probe;
+	}
+	init_mbox_f = 1;
+
+	// attach with scsi mid-layer
+	if (megaraid_io_attach(adapter) != MRAID_SUCCESS) {
+		con_log(CL_ANN, (KERN_WARNING "megaraid: io attach failed\n"));
+		goto fail_probe;
+	}
+
+	/*
+	 * Register with LSI Common Management Module
+	 */
+	if (megaraid_cmm_register(adapter) != MRAID_SUCCESS) {
+		con_log(CL_ANN, (KERN_WARNING
+		"megaraid: could not register with management module\n"));
+		// continue loading
+	}
+
+	/*
+	 * successfully attached this driver. Increment the device counter and
+	 * display interesting facts about the driver.
+	 */
+	mraid_driver_g.attach_count++;
+
+	// setup adapter handle in PCI soft state
+	pci_set_drvdata(pdev, adapter);
+
+	// put the adapter in the global list of our controllers
+	list_add_tail(&adapter->list, &mraid_driver_g.device_list);
+
+	con_log(CL_ANN, (KERN_NOTICE
+		"megaraid: fw version:[%s] bios version:[%s]\n",
+		adapter->fw_version, adapter->bios_version));
+
+	return 0;
+
+fail_probe:
+	if (init_mbox_f) {
+		megaraid_fini_mbox(adapter);
+	}
+
+	if (alloc_adapter_f) {
+		kfree(adapter);
+	}
+
+	pci_disable_device(pdev);
+
+	return -ENODEV;
+}
+
+
+/**
+ * megaraid_detach_one - release the framework resources and call LLD release
+ * routine
+ * @param pdev	: handle for our PCI cofiguration space
+ *
+ * This routine is called during driver unload. We free all the allocated
+ * resources and call the corresponding LLD so that it can also release all
+ * its resources.
+ *
+ * This routine is also called from the PCI hotplug system
+ **/
+static void
+megaraid_detach_one(struct pci_dev *pdev)
+{
+	adapter_t	*adapter;
+
+
+	// Start a rollback on this adapter
+	adapter = pci_get_drvdata(pdev);
+
+
+	// Make sure we don't break for multiple detach(?) for a controller
+	if (!adapter) {
+		con_log(CL_DLEVEL1, (KERN_CRIT
+		"megaraid: Invalid detach on %#4.04x:%#4.04x:%#4.04x:%#4.04x\n",
+			pdev->vendor, pdev->device, pdev->subsystem_vendor,
+			pdev->subsystem_device));
+
+		return;
+	}
+	else {
+		con_log(CL_ANN, (KERN_NOTICE
+		"megaraid: detaching device %#4.04x:%#4.04x:%#4.04x:%#4.04x\n",
+			pdev->vendor, pdev->device, pdev->subsystem_vendor,
+			pdev->subsystem_device));
+	}
+
+
+	// do not allow any more requests from the management module for this
+	// adapter.
+	// FIXME: How do we account for the request which might still be
+	// pending with us?
+	atomic_set(&adapter->being_detached, 1);
+
+	// remove the adapter from the global list of our controllers
+	list_del_init(&adapter->list);
+
+	// reset the device state in the PCI structure. We check this
+	// condition when we enter here. If the device state is NULL,
+	// that would mean the device has already been removed
+	pci_set_drvdata(pdev, NULL);
+
+	mraid_driver_g.attach_count--;
+
+	/*
+	 * Unregister from common management module
+	 *
+	 * FIXME: this must return success or failure for conditions if there
+	 * is a command pending with LLD or not.
+	 */
+	megaraid_cmm_unregister(adapter);
+
+	megaraid_io_detach(adapter);
+
+	// finalize the mailbox based controller
+	megaraid_fini_mbox(adapter);
+
+	kfree(adapter);
+
+	pci_disable_device(pdev);
+
+	return;
+}
+
+
+/**
+ * megaraid_mbox_shutdown - PCI shutdown for megaraid HBA
+ * @param device	: generice driver model device
+ *
+ * Find out if this device is still attached. If found, perform flush cache
+ */
+static void
+megaraid_mbox_shutdown(struct device *device)
+{
+	adapter_t		*adapter = pci_get_drvdata(to_pci_dev(device));
+	adapter_t		*ta;
+	struct list_head	*next;
+	static int		counter;
+
+	if (!adapter) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: null device in shutdown\n"));
+		return;
+	}
+
+	// make sure this adapter is still attached
+	ta = NULL;
+	list_for_each(next, &mraid_driver_g.device_list) {
+		ta = list_entry(next, adapter_t, list);
+		if (ta == adapter) break;
+		ta = NULL;
+	}
+
+	if (!ta) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: invalid device in shutdown\n"));
+		return;
+	}
+
+	// flush caches now
+	con_log(CL_ANN, (KERN_INFO "megaraid: flushing adapter %d...",
+		counter++));
+
+	megaraid_mbox_flush_cache(adapter);
+
+	con_log(CL_ANN, ("done\n"));
+}
+
+
+/**
+ * megaraid_io_attach - attach a device with the IO subsystem
+ * @param adapter	: controller's soft state
+ *
+ * Attach this device with the IO subsystem
+ **/
+static status_t
+megaraid_io_attach(adapter_t *adapter)
+{
+	struct Scsi_Host	*host;
+
+	// Initialize SCSI Host structure
+	host = scsi_host_alloc(megaraid_template_gp, 8);
+	if (!host) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: scsi_register failed.\n"));
+
+		return MRAID_FAILURE;
+	}
+
+	SCSIHOST2ADAP(host)	= (caddr_t )adapter;
+	adapter->host		= host;
+
+	// export the parameters required by the mid-layer
+	scsi_assign_lock(host, adapter->host_lock);
+	scsi_set_device(host, &adapter->pdev->dev);
+
+	host->irq		= adapter->irq;
+	host->unique_id		= adapter->unique_id;
+	host->can_queue		= adapter->max_cmds;
+	host->this_id		= adapter->init_id;
+	host->sg_tablesize	= adapter->sglen;
+	host->max_sectors	= adapter->max_sectors;
+	host->cmd_per_lun	= adapter->cmd_per_lun;
+	host->max_channel	= adapter->max_channel;
+	host->max_id		= adapter->max_target;
+	host->max_lun		= adapter->max_lun;
+
+
+	// notify mid-layer about the new controller
+	if (scsi_add_host(host, &adapter->pdev->dev)) {
+
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: scsi_add_host failed.\n"));
+
+		scsi_host_put(host);
+
+		return MRAID_FAILURE;
+	}
+
+	scsi_scan_host(host);
+
+	return MRAID_SUCCESS;
+}
+
+
+/**
+ * megaraid_io_detach - detach a device from the IO subsystem
+ * @param adapter	: controller's soft state
+ *
+ * Detach this device from the IO subsystem
+ **/
+static void
+megaraid_io_detach(adapter_t *adapter)
+{
+	struct Scsi_Host	*host;
+
+	con_log(CL_DLEVEL1, (KERN_INFO "megaraid: io detach\n"));
+
+	host = adapter->host;
+
+	scsi_remove_host(host);
+
+	scsi_host_put(host);
+
+	return;
+}
+
+
+/**
+ * megaraid_info - information string about the driver
+ * @host	: megaraid host
+ *
+ * returns a descriptive string about the driver
+ **/
+static const char *
+megaraid_info(struct Scsi_Host *host)
+{
+	return "LSI Logic Corporation MegaRAID driver";
+}
+
+
+/*
+ * START: Mailbox Low Level Driver
+ *
+ * This is section specific to the single mailbox based controllers
+ */
+
+/**
+ * megaraid_init_mbox - initialize controller
+ * @param adapter	- our soft state
+ *
+ * . Allocate 16-byte aligned mailbox memory for firmware handshake
+ * . Allocate controller's memory resources
+ * . Find out all initialization data
+ * . Allocate memory required for all the commands
+ * . Use internal library of FW routines, build up complete soft state
+ */
+static status_t __init
+megaraid_init_mbox(adapter_t *adapter)
+{
+	struct pci_dev		*pdev;
+	mraid_device_t		*raid_dev;
+	bool_t			mem_region_f	= MRAID_FALSE;
+	bool_t			alloc_cmds_f	= MRAID_FALSE;
+	bool_t			irq_f		= MRAID_FALSE;
+	int			i;
+
+
+	adapter->quiescent	= MRAID_FALSE;
+	adapter->ito		= MBOX_TIMEOUT;
+	pdev			= adapter->pdev;
+
+	/*
+	 * Allocate and initialize the init data structure for mailbox
+	 * controllers
+	 */
+	raid_dev = kmalloc(sizeof(mraid_device_t), GFP_KERNEL);
+	if (raid_dev == NULL) return MRAID_FAILURE;
+
+	memset(raid_dev, 0, sizeof(mraid_device_t));
+
+	/*
+	 * Attach the adapter soft state is raid device soft state
+	 */
+	adapter->raid_device	= (caddr_t)raid_dev;
+	raid_dev->fast_load	= megaraid_fast_load;
+
+
+	// our baseport
+	raid_dev->baseport = pci_resource_start(pdev, 0);
+
+	if (pci_request_regions(pdev, "MegaRAID: LSI Logic Corporation") != 0) {
+
+		con_log(CL_ANN, (KERN_WARNING
+				"megaraid: mem region busy\n"));
+
+		goto fail_init;
+	}
+
+	raid_dev->baseaddr = (unsigned long)
+			ioremap_nocache(raid_dev->baseport, 128);
+
+	if (!raid_dev->baseaddr) {
+
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: could not map hba memory\n") );
+
+		pci_release_regions(pdev);
+
+		goto fail_init;
+	}
+	mem_region_f = MRAID_TRUE;
+
+	//
+	// Setup the rest of the soft state using the library of FW routines
+	//
+
+	// request IRQ and register the interrupt service routine
+	if (request_irq(adapter->irq, megaraid_isr, SA_SHIRQ, "megaraid",
+		adapter)) {
+
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: Couldn't register IRQ %d!\n", adapter->irq));
+
+		goto fail_init;
+	}
+
+	irq_f = MRAID_TRUE;
+
+
+	// initialize the mutual exclusion lock for the mailbox
+	spin_lock_init(&raid_dev->mailbox_lock);
+
+	// allocate memory required for commands
+	if (megaraid_alloc_cmd_packets(adapter) != MRAID_SUCCESS) {
+		goto fail_init;
+	}
+	alloc_cmds_f = MRAID_TRUE;
+
+	// Product info
+	if (megaraid_mbox_product_info(adapter) != MRAID_SUCCESS) {
+		goto fail_init;
+	}
+
+	// Do we support extended CDBs
+	adapter->max_cdb_sz = 10;
+	if (megaraid_mbox_extended_cdb(adapter) == MRAID_SUCCESS) {
+		adapter->max_cdb_sz = 16;
+	}
+
+	/*
+	 * Do we support cluster environment, if we do, what is the initiator
+	 * id.
+	 * NOTE: In a non-cluster aware firmware environment, the LLD should
+	 * return 7 as initiator id.
+	 */
+	adapter->ha		= MRAID_FALSE;
+	adapter->init_id	= -1;
+	if (megaraid_mbox_support_ha(adapter, &adapter->init_id) ==
+			MRAID_SUCCESS) {
+		adapter->ha = MRAID_TRUE;
+	}
+
+	/*
+	 * Prepare the device ids array to have the mapping between the kernel
+	 * device address and megaraid device address.
+	 * We export the physical devices on their actual addresses. The
+	 * logical drives are exported on a virtual SCSI channel
+	 */
+	adapter->virtual_ch = adapter->max_channel;
+
+	mraid_setup_device_map(adapter);
+
+	// If the firmware supports random deletion, update the device id map
+	if (megaraid_mbox_support_random_del(adapter)) {
+
+		// Change the logical drives numbers in device_ids array one
+		// slot in device_ids is reserved for target id, that's why
+		// "<=" below
+		for (i = 0; i <= MAX_LOGICAL_DRIVES_40LD; i++) {
+			adapter->device_ids[adapter->virtual_ch][i] += 0x80;
+		}
+		adapter->device_ids[adapter->virtual_ch][adapter->init_id] =
+			0xFF;
+	}
+
+	/*
+	 * find out the maximum number of scatter-gather elements supported by
+	 * this firmware
+	 */
+	adapter->sglen = megaraid_mbox_get_max_sg(adapter);
+
+	// enumerate RAID and SCSI channels so that all devices on SCSI
+	// channels can later be exported, including disk devices
+	megaraid_mbox_enum_raid_scsi(adapter);
+
+	/*
+	 * Other parameters required by upper layer
+	 *
+	 * maximum number of sectors per IO command
+	 */
+	adapter->max_sectors = megaraid_max_sectors;
+
+	/*
+	 * number of queued commands per LUN.
+	 */
+	adapter->cmd_per_lun = megaraid_cmd_per_lun;
+
+	// Set the DMA mask to 64-bit. All supported controllers as capable of
+	// DMA in this range
+	if (pci_set_dma_mask(adapter->pdev, 0xFFFFFFFFFFFFFFFFULL) != 0) {
+
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: could not set DMA mask for 64-bit.\n"));
+
+		goto fail_init;
+	}
+
+	// setup tasklet for DPC
+	tasklet_init(&adapter->dpc_h, megaraid_mbox_dpc,
+			(unsigned long)adapter);
+
+	con_log(CL_DLEVEL1, (KERN_INFO
+		"megaraid mbox hba successfully initialized\n"));
+
+	return MRAID_SUCCESS;
+
+fail_init:
+	if (alloc_cmds_f) {
+		megaraid_free_cmd_packets(adapter);
+	}
+	if (irq_f == MRAID_TRUE) {
+		free_irq(adapter->irq, adapter);
+	}
+	if (mem_region_f) {
+		iounmap((caddr_t)raid_dev->baseaddr);
+		pci_release_regions(adapter->pdev);
+	}
+
+	kfree(raid_dev);
+
+	return MRAID_FAILURE;
+}
+
+
+/**
+ * megaraid_fini_mbox - undo controller initialization
+ * @param adapter	- our soft state
+ */
+static void
+megaraid_fini_mbox(adapter_t *adapter)
+{
+	mraid_device_t *raid_dev = ADAP2RAIDDEV(adapter);
+
+	// flush all caches
+	megaraid_mbox_flush_cache(adapter);
+
+	megaraid_free_cmd_packets(adapter);
+
+	free_irq(adapter->irq, adapter);
+
+	iounmap((caddr_t)raid_dev->baseaddr);
+
+	pci_release_regions(adapter->pdev);
+
+	kfree(raid_dev);
+
+	return;
+}
+
+
+/**
+ * megaraid_alloc_cmd_packets - allocate shared mailbox
+ * @param adapter	: soft state of the raid controller
+ *
+ * Allocate and align the shared mailbox. This maibox is used to issue
+ * all the commands. For IO based controllers, the mailbox is also regsitered
+ * with the FW. Allocate memory for all commands as well.
+ * This is our big allocator
+ */
+static status_t
+megaraid_alloc_cmd_packets(adapter_t *adapter)
+{
+	mraid_device_t		*raid_dev = ADAP2RAIDDEV(adapter);
+	struct pci_dev		*pdev;
+	unsigned long		align;
+	scb_t			*scb;
+	mbox_ccb_t		*ccb;
+	mbox_t			*una_mbox;
+	dma_addr_t		una_mbox_dma_h;
+	struct mraid_pci_blk	*epthru_pci_blk;
+	struct mraid_pci_blk	*sg_pci_blk;
+	struct mraid_pci_blk	*mbox_pci_blk;
+	bool_t			alloc_ibuf_f 		= MRAID_FALSE;
+	bool_t			alloc_common_mbox_f 	= MRAID_FALSE;
+	bool_t			alloc_int_ccb_f 	= MRAID_FALSE;
+	bool_t			alloc_int_ccb_pthru_f	= MRAID_FALSE;
+	bool_t			alloc_scb_f		= MRAID_FALSE;
+	bool_t			alloc_mbox_f		= MRAID_FALSE;
+	bool_t			alloc_epthru_f		= MRAID_FALSE;
+	bool_t			alloc_sg_pool_f		= MRAID_FALSE;
+	int			i;
+
+	pdev = adapter->pdev;
+
+	/*
+	 * Setup the mailbox
+	 * Allocate the common 16-byte aligned memory for the handshake
+	 * mailbox.
+	 */
+	raid_dev->una_mbox64 = pci_alloc_consistent(adapter->pdev,
+			sizeof(mbox64_t), &raid_dev->una_mbox64_dma);
+
+	if (!raid_dev->una_mbox64) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: out of memory, %s %d\n", __FUNCTION__,
+			__LINE__));
+		return MRAID_FAILURE;
+	}
+	memset(raid_dev->una_mbox64, 0, sizeof(mbox64_t));
+	alloc_common_mbox_f = MRAID_TRUE;
+
+	/*
+	 * Align the mailbox at 16-byte boundary
+	 */
+	raid_dev->mbox	= &raid_dev->una_mbox64->mbox32;
+
+	raid_dev->mbox	= (mbox_t *)((((unsigned long)raid_dev->mbox) + 15) &
+				(~0UL ^ 0xFUL));
+
+	raid_dev->mbox64 = (mbox64_t *)(((unsigned long)raid_dev->mbox) - 8);
+
+	align = ((void *)raid_dev->mbox -
+			((void *)&raid_dev->una_mbox64->mbox32));
+
+	raid_dev->mbox_dma = (unsigned long)raid_dev->una_mbox64_dma + 8 +
+			align;
+
+	/*
+	 * Allocate memory for commands issued internally, through ioctl and
+	 * /proc
+	 */
+	adapter->ibuf = pci_alloc_consistent(pdev, MBOX_IBUF_SIZE,
+				&adapter->ibuf_dma_h);
+	if (!adapter->ibuf) {
+
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: out of memory, %s %d\n", __FUNCTION__,
+			__LINE__));
+
+		goto fail_alloc_cmds;
+	}
+	alloc_ibuf_f = MRAID_TRUE;
+	memset(adapter->ibuf, 0, MBOX_IBUF_SIZE);
+
+	/*
+	 * Attach mailbox drivers specific data structure with the scb for
+	 * internal commands.
+	 * NOTE: for internal command, we use the direct mailbox commands and
+	 * passthru command without scatter-gather list. Therefore, memory
+	 * allocation for scatter-gather list is not required. The data
+	 * transfer address would be the internal buffer and it's dma address.
+	 */
+	ccb = kmalloc(sizeof(mbox_ccb_t), GFP_KERNEL);
+	if (ccb == NULL) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: out of memory, %s %d\n", __FUNCTION__,
+			__LINE__));
+
+		goto fail_alloc_cmds;
+	}
+	memset(ccb, 0, sizeof(mbox_ccb_t));
+	alloc_int_ccb_f = MRAID_TRUE;
+
+
+	/*
+	 * Allocate passthru structure for internal commands.
+	 * NOTE: for internal commands, we never use extended and 64-bit
+	 * passthru mailbox commands.
+	 *
+	 * HACK: piggyback the mailbox on the 'extra' memory allocated below
+	 * so that we do not need to track additional memory handles for
+	 * mailbox for internal commands. Put a buffer of about 1k bytes
+	 * between these two structures, just to separate them.
+	 */
+	ccb->pthru = pci_alloc_consistent(adapter->pdev, 2048,
+		&ccb->pthru_dma_h);
+
+	if (ccb->pthru == NULL) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: out of memory, %s %d\n", __FUNCTION__,
+			__LINE__));
+
+		goto fail_alloc_cmds;
+	}
+	memset(ccb->pthru, 0, sizeof(mraid_passthru_t));
+	alloc_int_ccb_pthru_f = MRAID_TRUE;
+
+	una_mbox	= (mbox_t *)((unsigned long)ccb->pthru + 1024);
+	una_mbox_dma_h	= (dma_addr_t)((unsigned long)ccb->pthru_dma_h + 1024);
+
+	ccb->mbox	= (mbox_t *)((((unsigned long)una_mbox) + 15) &
+				(~0UL ^ 0xFUL));
+
+	align		= ((caddr_t)ccb->mbox) - ((caddr_t)una_mbox);
+	ccb->mbox_dma_h	= (dma_addr_t)((unsigned long)una_mbox_dma_h + align);
+	ccb->mbox64	= (mbox64_t *)((unsigned long)ccb->mbox - 8);
+	ccb->raw_mbox	= (uint8_t *)ccb->mbox;
+
+	// Attach with framework
+	adapter->iscb.ccb = (caddr_t)ccb;
+
+
+	// Allocate memory for our SCSI Command Blocks and their associated
+	// memory
+
+	/*
+	 * Allocate memory for the base list of scb. Later allocate memory for
+	 * CCBs and embedded components of each CCB and point the pointers in
+	 * scb to the allocated components
+	 * NOTE: The code to allocate SCB will be duplicated in all the LLD
+	 * since the calling routine does not yet know the number of available
+	 * commands.
+	 */
+	adapter->scb_list = kmalloc(sizeof(scb_t) * MBOX_MAX_DRIVER_CMDS,
+			GFP_KERNEL);
+
+	if (adapter->scb_list == NULL) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: out of memory, %s %d\n", __FUNCTION__,
+			__LINE__));
+		goto fail_alloc_cmds;
+	}
+	alloc_scb_f = MRAID_TRUE;
+	memset(adapter->scb_list, 0, sizeof(scb_t) * MBOX_MAX_DRIVER_CMDS);
+
+	// Allocate memory for 16-bytes aligned mailboxes
+	raid_dev->mbox_pool_handle = mraid_pci_blk_pool_create(adapter->pdev,
+			MBOX_MAX_DRIVER_CMDS, sizeof(mbox64_t) + 16, 16,
+			raid_dev->mbox_pool);
+
+	if (raid_dev->mbox_pool_handle == NULL) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: out of memory, %s %d\n", __FUNCTION__,
+			__LINE__));
+		goto fail_alloc_cmds;
+	}
+	alloc_mbox_f = MRAID_TRUE;
+
+	/*
+	 * Allocate memory for each embedded passthru strucuture pointer
+	 * Request for a 128 bytes aligned structure for each passthru command
+	 * structure
+	 * Since passthru and extended passthru commands are exclusive, they
+	 * share common memory pool. Passthru structures piggyback on memory
+	 * allocted to extended passthru since passthru is smaller of the two
+	 */
+	raid_dev->epthru_pool_handle = mraid_pci_blk_pool_create(adapter->pdev,
+			MBOX_MAX_DRIVER_CMDS, sizeof(mraid_epassthru_t), 128,
+			raid_dev->epthru_pool);
+
+	if (raid_dev->epthru_pool_handle == NULL) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: out of memory, %s %d\n", __FUNCTION__,
+			__LINE__));
+		goto fail_alloc_cmds;
+	}
+	alloc_epthru_f = MRAID_TRUE;
+
+	// Allocate memory for each scatter-gather list. Request for 512 bytes
+	// alignment for each sg list
+	raid_dev->sg_pool_handle = mraid_pci_blk_pool_create(adapter->pdev,
+		MBOX_MAX_DRIVER_CMDS, sizeof(mbox_sgl64) * MBOX_MAX_SG_SIZE,
+		512, raid_dev->sg_pool);
+
+	if (raid_dev->sg_pool_handle == NULL) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: out of memory, %s %d\n", __FUNCTION__,
+			__LINE__));
+		goto fail_alloc_cmds;
+	}
+	alloc_sg_pool_f = MRAID_TRUE;
+
+	// Adjust the scb pointers and link in the free pool
+	epthru_pci_blk	= raid_dev->epthru_pool;
+	sg_pci_blk	= raid_dev->sg_pool;
+	mbox_pci_blk	= raid_dev->mbox_pool;
+
+	for (i = 0; i < MBOX_MAX_DRIVER_CMDS; i++) {
+		scb			= adapter->scb_list + i;
+		ccb			= raid_dev->ccb_list + i;
+
+		ccb->mbox	= (mbox_t *)(mbox_pci_blk[i].vaddr + 16);
+		ccb->raw_mbox	= (uint8_t *)ccb->mbox;
+		ccb->mbox64	= (mbox64_t *)(mbox_pci_blk[i].vaddr + 8);
+		ccb->mbox_dma_h	= mbox_pci_blk[i].dma_addr + 16;
+
+		// make sure the mailbox is aligned properly
+		if (ccb->mbox_dma_h & 0x0F) {
+			con_log(CL_ANN, (KERN_CRIT
+				"megaraid mbox: not aligned on 16-bytes\n"));
+
+			goto fail_alloc_cmds;
+		}
+
+		ccb->epthru	= (mraid_epassthru_t *)epthru_pci_blk[i].vaddr;
+		ccb->epthru_dma_h	= epthru_pci_blk[i].dma_addr;
+		ccb->pthru		= (mraid_passthru_t *)ccb->epthru;
+		ccb->pthru_dma_h	= ccb->epthru_dma_h;
+
+
+		ccb->sgl64		= (mbox_sgl64 *)sg_pci_blk[i].vaddr;
+		ccb->sgl_dma_h		= sg_pci_blk[i].dma_addr;
+		ccb->sgl32		= (mbox_sgl32 *)ccb->sgl64;
+
+		scb->ccb		= (caddr_t)ccb;
+		scb->gp			= 0;
+
+		// COMMAND ID 0 IS RESERVED FOR INTERNAL COMMANDS
+		scb->sno		= i+1;
+
+		scb->scp		= NULL;
+		scb->state		= SCB_FREE;
+		scb->dma_direction	= PCI_DMA_NONE;
+		scb->dma_type		= MRAID_DMA_NONE;
+		scb->dev_channel	= -1;
+		scb->dev_target		= -1;
+
+		// put scb in the free pool
+		list_add(&scb->list, &adapter->scb_pool);
+	}
+
+	return MRAID_SUCCESS;
+
+fail_alloc_cmds:
+	if (alloc_sg_pool_f == MRAID_TRUE) {
+		mraid_pci_blk_pool_destroy(raid_dev->sg_pool_handle);
+	}
+	if (alloc_epthru_f == MRAID_TRUE) {
+		mraid_pci_blk_pool_destroy(raid_dev->epthru_pool_handle);
+	}
+	if (alloc_mbox_f == MRAID_TRUE) {
+		mraid_pci_blk_pool_destroy(raid_dev->mbox_pool_handle);
+	}
+	if (alloc_scb_f == MRAID_TRUE ) kfree(adapter->scb_list);
+
+	if (alloc_int_ccb_pthru_f) {
+		pci_free_consistent(pdev, 2048,
+			((mbox_ccb_t *)(adapter->iscb.ccb))->pthru,
+			((mbox_ccb_t *)(adapter->iscb.ccb))->pthru_dma_h);
+	}
+	if (alloc_int_ccb_f) {
+		kfree(adapter->iscb.ccb);
+	}
+	if (alloc_ibuf_f) {
+		pci_free_consistent(pdev, MBOX_IBUF_SIZE,
+			(void *)adapter->ibuf, adapter->ibuf_dma_h);
+	}
+	if (alloc_common_mbox_f == MRAID_TRUE) {
+		pci_free_consistent(adapter->pdev, sizeof(mbox64_t),
+			(caddr_t)raid_dev->una_mbox64,
+			raid_dev->una_mbox64_dma);
+	}
+
+	return MRAID_FAILURE;
+}
+
+
+/**
+ * megaraid_free_common_mailbox - free shared mailbox
+ * @param adapter	: soft state of the raid controller
+ *
+ * Release memory resources allocated for commands
+ */
+static void
+megaraid_free_cmd_packets(adapter_t *adapter)
+{
+	mraid_device_t *raid_dev = ADAP2RAIDDEV(adapter);
+
+	mraid_pci_blk_pool_destroy(raid_dev->sg_pool_handle);
+	mraid_pci_blk_pool_destroy(raid_dev->epthru_pool_handle);
+	mraid_pci_blk_pool_destroy(raid_dev->mbox_pool_handle);
+	kfree(adapter->scb_list);
+
+	pci_free_consistent(adapter->pdev, 2048,
+		((mbox_ccb_t *)(adapter->iscb.ccb))->pthru,
+		((mbox_ccb_t *)(adapter->iscb.ccb))->pthru_dma_h);
+
+	kfree(adapter->iscb.ccb);
+
+	pci_free_consistent(adapter->pdev, MBOX_IBUF_SIZE,
+		(void *)adapter->ibuf, adapter->ibuf_dma_h);
+
+	pci_free_consistent(adapter->pdev, sizeof(mbox64_t),
+		(caddr_t)raid_dev->una_mbox64, raid_dev->una_mbox64_dma);
+	return;
+}
+
+
+/**
+ * megaraid_queue_command - generic queue entry point for all LLDs
+ * @scp		: pointer to the scsi command to be executed
+ * @done	: callback routine to be called after the cmd has be completed
+ *
+ * Queue entry point for mailbox based controllers. This entry point is common
+ * for memory and IO based controllers
+ */
+static int
+megaraid_queue_command(struct scsi_cmnd *scp, void (* done)(struct scsi_cmnd *))
+{
+	adapter_t	*adapter;
+	scb_t		*scb;
+	int		if_busy;
+	unsigned long	flags;
+
+	adapter		= SCP2ADAPTER(scp);
+	scp->scsi_done	= done;
+	scp->result	= 0;
+
+	ASSERT(spin_is_locked(adapter->host_lock));
+
+	spin_unlock(adapter->host_lock);
+
+	/*
+	 * Allocate and build a SCB request
+	 * if_busy flag will be set if megaraid_mbox_build_cmd() command could
+	 * not allocate scb. We will return non-zero status in that case.
+	 * NOTE: scb can be null even though certain commands completed
+	 * successfully, e.g., MODE_SENSE and TEST_UNIT_READY, it would
+	 * return 0 in that case, and we would do the callback right away.
+	 */
+	if_busy	= 0;
+	scb	= megaraid_mbox_build_cmd(adapter, scp, &if_busy);
+
+	if (scb) {
+		scb->state = SCB_PENDQ;
+
+		spin_lock_irqsave(PENDING_LIST_LOCK(adapter), flags);
+
+		list_add_tail(&scb->list, &adapter->pend_list);
+
+		spin_unlock_irqrestore(PENDING_LIST_LOCK(adapter), flags);
+
+		/*
+		 * Check if the HBA is in quiescent state, e.g., during a
+		 * delete logical drive opertion. If it is, don't run the
+		 * pending list.
+		 */
+		if (adapter->quiescent == MRAID_FALSE) {
+			megaraid_mbox_runpendq(adapter);
+		}
+
+		spin_lock(adapter->host_lock);
+
+		return 0;
+	}
+
+	spin_lock(adapter->host_lock);
+
+	done(scp);
+
+	return if_busy;
+}
+
+
+/**
+ * megaraid_mbox_build_cmd - transform the mid-layer scsi command to megaraid
+ * firmware lingua
+ * @adapter	- controller's soft state
+ * @scp		- mid-layer scsi command pointer
+ * @busy	- set if request could not be completed because of lack of
+ *		resources
+ *
+ * convert the command issued by mid-layer to format understood by megaraid
+ * firmware. We also complete certain command without sending them to firmware
+ */
+static inline scb_t *
+megaraid_mbox_build_cmd(adapter_t *adapter, Scsi_Cmnd *scp, int *busy)
+{
+	mraid_device_t		*rdev = ADAP2RAIDDEV(adapter);
+	int			channel;
+	int			target;
+	int			islogical;
+	mbox_ccb_t		*ccb;
+	mraid_passthru_t	*pthru;
+	mbox64_t		*mbox64;
+	mbox_t			*mbox;
+	scb_t			*scb;
+	uint32_t		xferlen;
+	char			skip[] = "skipping";
+	char			scan[] = "scanning";
+	char			*ss;
+
+
+	/*
+	 * If the command is already prepared, i.e., internal commands, return
+	 * immediately.
+	 */
+	if (scp->cmnd[0] == MRAID_INTERNAL_COMMAND) {
+		return &adapter->iscb;
+	}
+
+	/*
+	 * Get the appropriate device map for the device this command is
+	 * intended for
+	 */
+	MRAID_GET_DEVICE_MAP(adapter, scp, channel, target, islogical);
+
+	/*
+	 * Logical drive commands
+	 */
+	if (islogical) {
+		switch (scp->cmnd[0]) {
+		case TEST_UNIT_READY:
+			/*
+			 * Do we support clustering and is the support enabled
+			 * If no, return success always
+			 */
+			if (adapter->ha != MRAID_TRUE) {
+				scp->result = (DID_OK << 16);
+				return NULL;
+			}
+
+			if (!(scb = megaraid_alloc_scb(adapter, scp))) {
+				scp->result = (DID_ERROR << 16);
+				*busy = 1;
+				return NULL;
+			}
+
+			scb->dma_direction	= PCI_DIR(scp);
+			scb->dev_target		= 0xFF;
+			scb->dev_target		= target;
+			ccb			= (mbox_ccb_t *)scb->ccb;
+
+			/*
+			 * The command id will be provided by the command
+			 * issuance routine
+			 */
+			ccb->raw_mbox[0]	= CLUSTER_CMD;
+			ccb->raw_mbox[2]	= RESERVATION_STATUS;
+			ccb->raw_mbox[3]	= target;
+
+			return scb;
+
+		case MODE_SENSE:
+			if (scp->use_sg) {
+				struct scatterlist	*sgl;
+				caddr_t			vaddr;
+
+				sgl = (struct scatterlist *)scp->request_buffer;
+				if (sgl->page) {
+					vaddr = (caddr_t)
+						(page_address((&sgl[0])->page)
+						+ (&sgl[0])->offset);
+
+					memset(vaddr, 0, scp->cmnd[4]);
+				}
+				else {
+					con_log(CL_ANN, (KERN_WARNING
+					"megaraid mailbox: invalid sg:%d\n",
+					__LINE__));
+				}
+			}
+			else {
+				memset(scp->request_buffer, 0, scp->cmnd[4]);
+			}
+			scp->result = (DID_OK << 16);
+			return NULL;
+
+		case INQUIRY:
+			/*
+			 * Display the channel scan for logical drives
+			 * Do not display scan for a channel if already done.
+			 */
+			if (!(rdev->last_disp & (1L << SCP2CHANNEL(scp)))) {
+
+				con_log(CL_ANN, (KERN_INFO
+					"scsi[%d]: scanning scsi channel %d",
+					adapter->host->host_no,
+					SCP2CHANNEL(scp)));
+
+				con_log(CL_ANN, (
+					" [virtual] for logical drives\n"));
+
+				rdev->last_disp |= (1L << SCP2CHANNEL(scp));
+			}
+
+			/* Fall through */
+
+		case READ_CAPACITY:
+			/*
+			 * Do not allow LUN > 0 for logical drives and
+			 * requests for more than 40 logical drives
+			 */
+			if (SCP2LUN(scp)) {
+				scp->result = (DID_BAD_TARGET << 16);
+				return NULL;
+			}
+			if ((target % 0x80) >= MAX_LOGICAL_DRIVES_40LD) {
+				scp->result = (DID_BAD_TARGET << 16);
+				return NULL;
+			}
+
+
+			/* Allocate a SCB and initialize passthru */
+			if (!(scb = megaraid_alloc_scb(adapter, scp))) {
+				scp->result = (DID_ERROR << 16);
+				*busy = 1;
+				return NULL;
+			}
+
+			ccb			= (mbox_ccb_t *)scb->ccb;
+			scb->dev_channel	= 0xFF;
+			scb->dev_target		= target;
+			pthru			= ccb->pthru;
+			mbox			= ccb->mbox;
+			mbox64			= ccb->mbox64;
+
+			pthru->timeout		= 0;
+			pthru->ars		= 1;
+			pthru->reqsenselen	= 14;
+			pthru->islogical	= 1;
+			pthru->logdrv		= target;
+			pthru->cdblen		= scp->cmd_len;
+			memcpy(pthru->cdb, scp->cmnd, scp->cmd_len);
+
+			mbox->cmd		= MBOXCMD_PASSTHRU64;
+			scb->dma_direction	= PCI_DIR(scp);
+
+			pthru->numsge = megaraid_mbox_mksgl(adapter, scb,
+				&pthru->dataxferaddr, &pthru->dataxferlen);
+
+			mbox->xferaddr		= 0xFFFFFFFF;
+			mbox64->xferaddr_lo	= ccb->pthru_dma_h;
+			mbox64->xferaddr_hi	= 0;
+
+			return scb;
+
+		case READ_6:
+		case WRITE_6:
+		case READ_10:
+		case WRITE_10:
+		case READ_12:
+		case WRITE_12:
+
+			/*
+			 * Allocate a SCB and initialize mailbox
+			 */
+			if (!(scb = megaraid_alloc_scb(adapter, scp))) {
+				scp->result = (DID_ERROR << 16);
+				*busy = 1;
+				return NULL;
+			}
+			ccb			= (mbox_ccb_t *)scb->ccb;
+			scb->dev_channel	= 0xFF;
+			scb->dev_target		= target;
+			mbox			= ccb->mbox;
+			mbox64			= ccb->mbox64;
+			mbox->logdrv		= target;
+
+			/*
+			 * A little HACK: 2nd bit is zero for all scsi read
+			 * commands and is set for all scsi write commands
+			 */
+			mbox->cmd = (scp->cmnd[0] & 0x02) ?  MBOXCMD_LWRITE64:
+					MBOXCMD_LREAD64 ;
+
+			/*
+			 * 6-byte READ(0x08) or WRITE(0x0A) cdb
+			 */
+			if (scp->cmd_len == 6) {
+				mbox->numsectors = (uint32_t)scp->cmnd[4];
+				mbox->lba =
+					((uint32_t)scp->cmnd[1] << 16)	|
+					((uint32_t)scp->cmnd[2] << 8)	|
+					(uint32_t)scp->cmnd[3];
+
+				mbox->lba &= 0x1FFFFF;
+			}
+
+			/*
+			 * 10-byte READ(0x28) or WRITE(0x2A) cdb
+			 */
+			else if (scp->cmd_len == 10) {
+				mbox->numsectors =
+					(uint32_t)scp->cmnd[8] |
+					((uint32_t)scp->cmnd[7] << 8);
+				mbox->lba =
+					((uint32_t)scp->cmnd[2] << 24) |
+					((uint32_t)scp->cmnd[3] << 16) |
+					((uint32_t)scp->cmnd[4] << 8) |
+					(uint32_t)scp->cmnd[5];
+			}
+
+			/*
+			 * 12-byte READ(0xA8) or WRITE(0xAA) cdb
+			 */
+			else if (scp->cmd_len == 12) {
+				mbox->lba =
+					((uint32_t)scp->cmnd[2] << 24) |
+					((uint32_t)scp->cmnd[3] << 16) |
+					((uint32_t)scp->cmnd[4] << 8) |
+					(uint32_t)scp->cmnd[5];
+
+				mbox->numsectors =
+					((uint32_t)scp->cmnd[6] << 24) |
+					((uint32_t)scp->cmnd[7] << 16) |
+					((uint32_t)scp->cmnd[8] << 8) |
+					(uint32_t)scp->cmnd[9];
+			}
+			else {
+				con_log(CL_ANN, (KERN_WARNING
+					"megaraid: unsupported CDB length\n"));
+
+				megaraid_dealloc_scb(adapter, scb);
+
+				scp->result = (DID_ERROR << 16);
+				return NULL;
+			}
+
+
+
+			scb->dma_direction = PCI_DIR(scp);
+
+			/*
+			 * Calculate Scatter-Gather info
+			 */
+			mbox->numsge = megaraid_mbox_mksgl(adapter, scb,
+					(uint32_t *)&mbox64->xferaddr_lo,
+					&xferlen);
+			mbox->xferaddr		= 0xFFFFFFFF;
+			mbox64->xferaddr_hi	= 0;
+
+			return scb;
+
+		case RESERVE:
+		case RELEASE:
+			/*
+			 * Do we support clustering and is the support enabled
+			 */
+			if (!adapter->ha) {
+				scp->result = (DID_BAD_TARGET << 16);
+				return NULL;
+			}
+
+			/*
+			 * Allocate a SCB and initialize mailbox
+			 */
+			if (!(scb = megaraid_alloc_scb(adapter, scp))) {
+				scp->result = (DID_ERROR << 16);
+				*busy = 1;
+				return NULL;
+			}
+
+			ccb			= (mbox_ccb_t *)scb->ccb;
+			scb->dev_channel	= 0xFF;
+			scb->dev_target		= target;
+			ccb->raw_mbox[0]	= CLUSTER_CMD;
+			/*
+			 * The command id will be provided by the command
+			 * issuance routine
+			 */
+			ccb->raw_mbox[2]	=  (scp->cmnd[0] == RESERVE) ?
+						RESERVE_LD : RELEASE_LD;
+
+			ccb->raw_mbox[3]	= target;
+			scb->dma_direction	= PCI_DIR(scp);
+
+			return scb;
+
+		default:
+			scp->result = (DID_BAD_TARGET << 16);
+			return NULL;
+		}
+	}
+	else { // Passthru device commands
+
+		// Do not allow access to target id > 15 or LUN > 7
+		if (target > 15 || SCP2LUN(scp) > 7) {
+			scp->result = (DID_BAD_TARGET << 16);
+			return NULL;
+		}
+
+		// if fast load option was set and scan for last device is
+		// over, reset the fast_load flag so that during a possible
+		// next scan, devices can be made available
+		if (rdev->fast_load && (target == 15) &&
+			(SCP2CHANNEL(scp) == adapter->max_channel -1)) {
+
+			con_log(CL_ANN, (KERN_INFO
+			"megaraid[%d]: physical device scan re-enabled\n",
+				adapter->host->host_no));
+			rdev->fast_load = 0;
+		}
+
+		/*
+		 * Display the channel scan for physical devices
+		 */
+		if (!(rdev->last_disp & (1L << SCP2CHANNEL(scp)))) {
+
+			ss = rdev->fast_load ? skip : scan;
+
+			con_log(CL_ANN, (KERN_INFO
+				"scsi[%d]: %s scsi channel %d [Phy %d]",
+				adapter->host->host_no, ss, SCP2CHANNEL(scp),
+				channel));
+
+			con_log(CL_ANN, (
+				" for non-raid devices\n"));
+
+			rdev->last_disp |= (1L << SCP2CHANNEL(scp));
+		}
+
+		// disable channel sweep if fast load option given
+		if (rdev->fast_load) {
+			scp->result = (DID_BAD_TARGET << 16);
+			return NULL;
+		}
+
+		/*
+		 * Allocate a SCB and initialize passthru
+		 */
+		if (!(scb = megaraid_alloc_scb(adapter, scp))) {
+			scp->result = (DID_ERROR << 16);
+			*busy = 1;
+			return NULL;
+		}
+
+		ccb			= (mbox_ccb_t *)scb->ccb;
+		scb->dev_channel	= channel;
+		scb->dev_target		= target;
+		scb->dma_direction	= PCI_DIR(scp);
+		mbox			= ccb->mbox;
+		mbox64			= ccb->mbox64;
+
+		// Does this firmware support extended CDBs
+		if (adapter->max_cdb_sz == 16) {
+			mbox->cmd		= MBOXCMD_EXTPTHRU;
+
+			megaraid_mbox_prepare_epthru(adapter, scb, scp);
+
+			mbox64->xferaddr_lo	= (uint32_t)ccb->epthru_dma_h;
+			mbox64->xferaddr_hi	= 0;
+			mbox->xferaddr		= 0xFFFFFFFF;
+		}
+		else {
+			mbox->cmd = MBOXCMD_PASSTHRU64;
+
+			megaraid_mbox_prepare_pthru(adapter, scb, scp);
+
+			mbox64->xferaddr_lo	= (uint32_t)ccb->pthru_dma_h;
+			mbox64->xferaddr_hi	= 0;
+			mbox->xferaddr		= 0xFFFFFFFF;
+		}
+		return scb;
+	}
+}
+
+
+/**
+ * megaraid_alloc_scb - detach and return a scb from the free list
+ * @adapter	: controller's soft state
+ *
+ * return the scb from the head of the free list. NULL if there are none
+ * available
+ **/
+static inline scb_t *
+megaraid_alloc_scb(adapter_t *adapter, struct scsi_cmnd *scp)
+{
+	struct list_head	*head = &adapter->scb_pool;
+	scb_t			*scb = NULL;
+	unsigned long		flags;
+
+	// detach scb from free pool
+	spin_lock_irqsave(FREE_LIST_LOCK(adapter), flags);
+
+	if (list_empty(head)) {
+		spin_unlock_irqrestore(FREE_LIST_LOCK(adapter), flags);
+		return NULL;
+	}
+
+	scb = list_entry(head->next, scb_t, list);
+	list_del_init(&scb->list);
+
+	spin_unlock_irqrestore(FREE_LIST_LOCK(adapter), flags);
+
+	scb->state	= SCB_ACTIVE;
+	scb->scp	= scp;
+	scb->dma_type	= MRAID_DMA_NONE;
+
+	return scb;
+}
+
+
+/**
+ * megaraid_dealloc_scb - return the scb to the free pool
+ * @adapter	: controller's soft state
+ * @scb		: scb to be freed
+ *
+ * return the scb back to the free list of scbs. The caller must 'flush' the
+ * SCB before calling us. E.g., performing pci_unamp and/or pci_sync etc.
+ * NOTE NOTE: Make sure the scb is not on any list before calling this
+ * routine.
+ **/
+static inline void
+megaraid_dealloc_scb(adapter_t *adapter, scb_t *scb)
+{
+	unsigned long		flags;
+
+	// put scb in the free pool
+	scb->state	= SCB_FREE;
+	scb->scp	= NULL;
+	spin_lock_irqsave(FREE_LIST_LOCK(adapter), flags);
+
+	list_add(&scb->list, &adapter->scb_pool);
+
+	spin_unlock_irqrestore(FREE_LIST_LOCK(adapter), flags);
+
+	return;
+}
+
+
+/**
+ * megaraid_mbox_prepare_pthru - prepare a command for physical devices
+ * @adapter	- pointer to controller's soft state
+ * @scb		- scsi control block
+ * @scp		- scsi command from the mid-layer
+ *
+ * prepare a command for the scsi physical devices
+ */
+static inline void
+megaraid_mbox_prepare_pthru(adapter_t *adapter, scb_t *scb, Scsi_Cmnd *scp)
+{
+	mbox_ccb_t		*ccb;
+	mraid_passthru_t	*pthru;
+	uint8_t			channel;
+	uint8_t			target;
+
+	ccb	= (mbox_ccb_t *)scb->ccb;
+	pthru	= ccb->pthru;
+	channel	= scb->dev_channel;
+	target	= scb->dev_target;
+
+	pthru->timeout		= 2;	/* 0=6sec,1=60sec,2=10min,3=3hrs */
+	pthru->ars		= 1;
+	pthru->islogical	= 0;
+	pthru->channel		= 0;
+	pthru->target		= (channel << 4) | target;
+	pthru->logdrv		= SCP2LUN(scp);
+	pthru->reqsenselen	= 14;
+	pthru->cdblen		= scp->cmd_len;
+
+	memcpy(pthru->cdb, scp->cmnd, scp->cmd_len);
+
+	if (scp->request_bufflen) {
+		pthru->numsge = megaraid_mbox_mksgl(adapter, scb,
+				&pthru->dataxferaddr, &pthru->dataxferlen);
+	}
+	else {
+		pthru->dataxferaddr	= 0;
+		pthru->dataxferlen	= 0;
+	}
+	return;
+}
+
+
+/**
+ * megaraid_mbox_prepare_epthru - prepare a command for physical devices
+ * @adapter	- pointer to controller's soft state
+ * @scb		- scsi control block
+ * @scp		- scsi command from the mid-layer
+ *
+ * prepare a command for the scsi physical devices. This rountine prepares
+ * commands for devices which can take extended CDBs (>10 bytes)
+ */
+static inline void
+megaraid_mbox_prepare_epthru(adapter_t *adapter, scb_t *scb, Scsi_Cmnd *scp)
+{
+	mbox_ccb_t		*ccb;
+	mraid_epassthru_t	*epthru;
+	uint8_t			channel;
+	uint8_t			target;
+
+	ccb	= (mbox_ccb_t *)scb->ccb;
+	epthru	= ccb->epthru;
+	channel	= scb->dev_channel;
+	target	= scb->dev_target;
+
+	epthru->timeout		= 2;	/* 0=6sec,1=60sec,2=10min,3=3hrs */
+	epthru->ars		= 1;
+	epthru->islogical	= 0;
+	epthru->channel		= 0;
+	epthru->target		= (channel << 4) | target;
+	epthru->logdrv		= SCP2LUN(scp);
+	epthru->reqsenselen	= 14;
+	epthru->cdblen		= scp->cmd_len;
+
+	memcpy(epthru->cdb, scp->cmnd, scp->cmd_len);
+
+	if (scp->request_bufflen) {
+		epthru->numsge = megaraid_mbox_mksgl(adapter, scb,
+				&epthru->dataxferaddr, &epthru->dataxferlen);
+	}
+	else {
+		epthru->dataxferaddr	= 0;
+		epthru->dataxferlen	= 0;
+	}
+	return;
+}
+
+
+/**
+ * megaraid_mbox_mksgl - make the scatter-gather list
+ * @adapter	- controller's soft state
+ * @scb		- scsi control block
+ * @xferaddr	- start of data transfer address (block/sg list)
+ * @xferlen	- total amount of data to be transferred
+ *
+ * prepare the scatter-gather list
+ */
+static inline int
+megaraid_mbox_mksgl(adapter_t *adapter, scb_t *scb, uint32_t *xferaddr,
+		uint32_t *xferlen)
+{
+	struct scatterlist	*sgl;
+	mbox_ccb_t		*ccb;
+	struct page		*page;
+	unsigned long		offset;
+	Scsi_Cmnd		*scp;
+	int			sgcnt;
+	int			i;
+
+
+	scp	= scb->scp;
+	ccb	= (mbox_ccb_t *)scb->ccb;
+
+	if (!scp->use_sg) {	/* scatter-gather list not used */
+
+		page = virt_to_page(scp->request_buffer);
+
+		offset = ((unsigned long)scp->request_buffer & ~PAGE_MASK);
+
+		ccb->buf_dma_h = pci_map_page(adapter->pdev, page, offset,
+						  scp->request_bufflen,
+						  scb->dma_direction);
+		scb->dma_type = MRAID_DMA_WBUF;
+
+		/*
+		 * We need to handle special 64-bit commands that need a
+		 * minimum of 1 SG
+		 */
+		sgcnt = 1;
+		ccb->sgl64[0].address	= ccb->buf_dma_h;
+		ccb->sgl64[0].length	= scp->request_bufflen;
+		*xferaddr		= (uint32_t)ccb->sgl_dma_h;
+		*xferlen		= (uint32_t)scp->request_bufflen;
+
+		return sgcnt;
+	}
+
+	sgl = (struct scatterlist *)scp->request_buffer;
+
+	// The number of sg elements returned must not exceed our limit
+	sgcnt = pci_map_sg(adapter->pdev, sgl, scp->use_sg,
+			scb->dma_direction);
+
+	if (sgcnt > adapter->sglen) {
+		con_log(CL_ANN, (KERN_CRIT
+			"megaraid critical: too many sg elements:%d\n",
+			sgcnt));
+		BUG();
+	}
+
+	scb->dma_type = MRAID_DMA_WSG;
+
+	for (i = 0; i < sgcnt; i++, sgl++) {
+		ccb->sgl64[i].address	= sg_dma_address(sgl);
+		ccb->sgl64[i].length	= sg_dma_len(sgl);
+	}
+
+	// dataxferlen must be set, even for commands with a sg list
+	*xferaddr = ccb->sgl_dma_h;
+	*xferlen = (uint32_t)scp->request_bufflen;
+
+	// Return count of SG nodes
+	return sgcnt;
+}
+
+
+/**
+ * megaraid_mbox_runpendq - execute commands queued in the pending queue
+ * @adapter	- controller's soft state
+ *
+ * scan the pending list for commands which are not yet issued and try to
+ * post to the controller.
+ *
+ * NOTE: We do not actually traverse the pending list. The SCBs are plucked
+ * out from the head of the pending list. If it is successfully issued, the
+ * next SCB is at the head now.
+ */
+static inline void
+megaraid_mbox_runpendq(adapter_t *adapter)
+{
+	scb_t			*scb;
+	unsigned long		flags;
+
+	spin_lock_irqsave(PENDING_LIST_LOCK(adapter), flags);
+
+	while (!list_empty(&adapter->pend_list)) {
+
+		ASSERT(spin_is_locked(PENDING_LIST_LOCK(adapter)));
+
+		scb = list_entry(adapter->pend_list.next, scb_t, list);
+
+		// remove the scb from the pending list and try to
+		// issue. If we are unable to issue it, put back in
+		// the pending list and return
+
+		list_del_init(&scb->list);
+
+		spin_unlock_irqrestore(PENDING_LIST_LOCK(adapter), flags);
+
+		// if mailbox was busy, return SCB back to pending
+		// list. Make sure to add at the head, since that's
+		// where it would have been removed from
+
+		scb->state = SCB_ISSUED;
+
+		if (mbox_post_cmd(adapter, scb) != MRAID_SUCCESS) {
+
+			spin_lock_irqsave(PENDING_LIST_LOCK(adapter), flags);
+
+			scb->state = SCB_PENDQ;
+
+			list_add(&scb->list, &adapter->pend_list);
+
+			spin_unlock_irqrestore(PENDING_LIST_LOCK(adapter),
+				flags);
+
+			return;
+		}
+
+		spin_lock_irqsave(PENDING_LIST_LOCK(adapter), flags);
+	}
+
+	spin_unlock_irqrestore(PENDING_LIST_LOCK(adapter), flags);
+
+
+	return;
+}
+
+
+/**
+ * mbox_post_cmd - issue a mailbox command
+ * @adapter	- controller's soft state
+ * @scb		- command to be issued
+ *
+ * post the command to the controller if mailbox is availble.
+ */
+static inline status_t
+mbox_post_cmd(adapter_t *adapter, scb_t *scb)
+{
+	mraid_device_t	*raid_dev = ADAP2RAIDDEV(adapter);
+	mbox64_t	*mbox64;
+	mbox_t		*mbox;
+	mbox_ccb_t	*ccb;
+	unsigned long	flags;
+	unsigned int	i = 0;
+
+
+	ccb	= (mbox_ccb_t *)scb->ccb;
+	mbox	= raid_dev->mbox;
+	mbox64	= raid_dev->mbox64;
+
+	/*
+	 * Check for busy mailbox. If it is, return failure - the caller
+	 * should retry later.
+	 */
+	spin_lock_irqsave(MAILBOX_LOCK(raid_dev), flags);
+
+	if (unlikely(mbox->busy)) {
+		do {
+			udelay(1);
+			i++;
+			rmb();
+		} while(mbox->busy && (i < max_mbox_busy_wait));
+
+		if (mbox->busy) {
+
+			spin_unlock_irqrestore(MAILBOX_LOCK(raid_dev), flags);
+
+			return MRAID_FAILURE;
+		}
+	}
+
+
+	// Copy this command's mailbox data into "adapter's" mailbox
+	memcpy((caddr_t)mbox64, (caddr_t)ccb->mbox64, 24);
+	mbox->cmdid = scb->sno;
+
+	adapter->outstanding_cmds++;
+
+	if (scb->dma_direction == PCI_DMA_TODEVICE) {
+		if (!scb->scp->use_sg) {	// sg list not used
+			pci_dma_sync_single(adapter->pdev, ccb->buf_dma_h,
+					scb->scp->request_bufflen,
+					PCI_DMA_TODEVICE);
+		}
+		else {
+			pci_dma_sync_sg(adapter->pdev, scb->scp->request_buffer,
+				scb->scp->use_sg, PCI_DMA_TODEVICE);
+		}
+	}
+
+	mbox->busy	= 1;	// Set busy
+	mbox->poll	= 0;
+	mbox->ack	= 0;
+	wmb();
+
+	WRINDOOR(raid_dev, raid_dev->mbox_dma | 0x1);
+
+	spin_unlock_irqrestore(MAILBOX_LOCK(raid_dev), flags);
+
+	return MRAID_SUCCESS;
+}
+
+
+/**
+ * megaraid_isr - isr for memory based mailbox based controllers
+ * @irq		- irq
+ * @devp	- pointer to our soft state
+ * @regs	- unused
+ *
+ * Interrupt service routine for memory-mapped mailbox controllers.
+ */
+static irqreturn_t
+megaraid_isr(int irq, void *devp, struct pt_regs *regs)
+{
+	adapter_t	*adapter = devp;
+	int		handled;
+
+
+	handled = megaraid_ack_sequence(adapter);
+
+	/* Loop through any pending requests */
+	if (adapter->quiescent == MRAID_FALSE) {
+		megaraid_mbox_runpendq(adapter);
+	}
+
+	return IRQ_RETVAL(handled);
+}
+
+
+/**
+ * megaraid_ack_sequence - interrupt ack sequence for memory mapped HBAs
+ * @adapter	- controller's soft state
+ *
+ * Interrupt ackrowledgement sequence for memory mapped HBAs. Find out the
+ * completed command and put them on the completed list for later processing.
+ *
+ * Returns:	1 if the interrupt is valid, 0 otherwise
+ */
+static inline int
+megaraid_ack_sequence(adapter_t *adapter)
+{
+	mraid_device_t		*raid_dev = ADAP2RAIDDEV(adapter);
+	mbox_t			*mbox;
+	scb_t			*scb;
+	uint8_t			nstatus;
+	uint8_t			completed[MBOX_MAX_FIRMWARE_STATUS];
+	struct list_head	clist;
+	int			handled;
+	uint32_t		dword;
+	unsigned long		flags;
+	int			i, j;
+
+
+	mbox	= raid_dev->mbox;
+
+	// we move the SCBs from the firmware completed array to our local list
+	INIT_LIST_HEAD(&clist);
+
+	// loop till F/W has more commands for us to complete
+	handled = 0;
+	spin_lock_irqsave(MAILBOX_LOCK(raid_dev), flags);
+	do {
+		/*
+		 * Check if a valid interrupt is pending. If found, force the
+		 * interrupt line low.
+		 */
+		dword = RDOUTDOOR(raid_dev);
+		if (dword != 0x10001234) break;
+
+		handled = 1;
+
+		WROUTDOOR(raid_dev, 0x10001234);
+
+		nstatus = 0;
+		// wait for valid numstatus to post
+		for (i = 0; i < 0xFFFFF; i++) {
+			if (mbox->numstatus != 0xFF) {
+				nstatus = mbox->numstatus;
+				break;
+			}
+			rmb();
+		}
+		mbox->numstatus = 0xFF;
+
+		adapter->outstanding_cmds -= nstatus;
+
+		for (i = 0; i < nstatus; i++) {
+
+			// wait for valid command index to post
+			for (j = 0; j < 0xFFFFF; j++) {
+				if (mbox->completed[i] != 0xFF) break;
+				rmb();
+			}
+			completed[i]		= mbox->completed[i];
+			mbox->completed[i]	= 0xFF;
+
+			if (completed[i] == 0xFF) {
+				con_log(CL_ANN, (KERN_CRIT
+				"megaraid: command posting timed out\n"));
+
+				BUG();
+				continue;
+			}
+
+			// Free the command id if this was not an internal
+			// command
+			if (completed[i] == 0) {
+				scb = &adapter->iscb;
+			}
+			else {
+				// Get SCB associated with this command id
+				// Command ID 0 is reserved for internal
+				// commands
+				scb = adapter->scb_list + (completed[i] - 1);
+			}
+
+			scb->status = mbox->status;
+			list_add_tail(&scb->list, &clist);
+		}
+
+		// Acknowledge interrupt
+		WRINDOOR(raid_dev, 0x02);
+
+	} while(1);
+
+	spin_unlock_irqrestore(MAILBOX_LOCK(raid_dev), flags);
+
+
+	// put the completed commands in the completed list. DPC would
+	// complete these commands later
+	spin_lock_irqsave(COMPLETED_LIST_LOCK(adapter), flags);
+
+	list_splice(&clist, &adapter->completed_list);
+
+	spin_unlock_irqrestore(COMPLETED_LIST_LOCK(adapter), flags);
+
+
+	// schedule the DPC if there is some work for it
+	if (handled)
+		tasklet_schedule(&adapter->dpc_h);
+
+	return handled;
+}
+
+
+
+/**
+ * megaraid_mbox_dpc - the tasklet to complete the commands from completed list
+ * @devp	: pointer to HBA soft state
+ *
+ * Pick up the commands from the completed list and send back to the owners.
+ * This is a reentrant function and does not assume any locks are held while
+ * it is being called.
+ */
+static void
+megaraid_mbox_dpc(unsigned long devp)
+{
+	adapter_t		*adapter = (adapter_t *)devp;
+	mraid_device_t		*raid_dev = ADAP2RAIDDEV(adapter);
+	struct list_head	*pos, *next;
+	struct list_head	clist;
+	struct scatterlist	*sgl;
+	scb_t			*scb;
+	Scsi_Cmnd		*scp;
+	mraid_passthru_t	*pthru;
+	mraid_epassthru_t	*epthru;
+	mbox_ccb_t		*ccb;
+	int			islogical;
+	int			pdev_index;
+	int			pdev_state;
+	mbox_t			*mbox;
+	unsigned long		flags;
+	uint8_t			c;
+	int			status;
+
+	// move the SCBs from the completed list to our local list
+	INIT_LIST_HEAD(&clist);
+
+	spin_lock_irqsave(COMPLETED_LIST_LOCK(adapter), flags);
+
+	list_splice_init(&adapter->completed_list, &clist);
+
+	spin_unlock_irqrestore(COMPLETED_LIST_LOCK(adapter), flags);
+
+	list_for_each_safe(pos, next, &clist) {
+		scb = list_entry(pos, scb_t, list);
+
+		status		= scb->status;
+		scp		= scb->scp;
+		ccb		= (mbox_ccb_t *)scb->ccb;
+		pthru		= ccb->pthru;
+		epthru		= ccb->epthru;
+		mbox		= ccb->mbox;
+		islogical	= MRAID_IS_LOGICAL(adapter, scp);
+
+		/*
+		 * Make sure f/w has completed a valid command
+		 */
+		if (!(scb->state & SCB_ISSUED)) {
+			con_log(CL_ANN, (KERN_CRIT
+			"megaraid critical err: invalid command %d:%d:%p\n",
+				scb->sno, scb->state, scp));
+			BUG();
+			continue;	// Must never happen!
+		}
+
+		// check for the internal command and complete it right away
+		if (scb->sno == 0) {
+			scb->state	= SCB_FREE;
+			scp->result	= status;
+
+			spin_lock(adapter->host_lock);
+
+			scp->scsi_done(scp);
+
+			spin_unlock(adapter->host_lock);
+
+			continue;
+		}
+
+		// Was an abort issued for this command earlier
+		if (scb->state & SCB_ABORT) {
+			con_log(CL_ANN, (KERN_NOTICE
+			"megaraid: aborted cmd %lx[%x] completed\n",
+				scp->serial_number, scb->sno));
+		}
+
+		/*
+		 * If the inquiry came of a disk drive which is not part of
+		 * any RAID array, expose it to the kernel. For this to be
+		 * enabled, user must set the "megaraid_expose_unconf_disks"
+		 * flag to 1 by specifying it on module parameter list.
+		 * This would enable data migration off drives from other
+		 * configurations.
+		 */
+		if (scp->cmnd[0] == INQUIRY && status == 0 && islogical == 0
+				&& IS_RAID_CH(raid_dev, scb->dev_channel)) {
+
+			if (scp->use_sg) {
+				sgl = (struct scatterlist *)
+					scp->request_buffer;
+
+				if (sgl->page) {
+					c = *(unsigned char *)
+					(page_address((&sgl[0])->page) +
+						(&sgl[0])->offset);
+				}
+				else {
+					con_log(CL_ANN, (KERN_WARNING
+					"megaraid mailbox: invalid sg:%d\n",
+					__LINE__));
+					c = 0;
+				}
+			}
+			else {
+				c = *(uint8_t *)scp->request_buffer;
+			}
+
+			if ((c & 0x1F ) == TYPE_DISK) {
+				pdev_index = (scb->dev_channel * 16) +
+					scb->dev_target;
+				pdev_state =
+					raid_dev->pdrv_state[pdev_index] & 0x0F;
+
+				if (pdev_state == PDRV_ONLINE		||
+					pdev_state == PDRV_FAILED	||
+					pdev_state == PDRV_RBLD		||
+					pdev_state == PDRV_HOTSPARE	||
+					megaraid_expose_unconf_disks == 0) {
+
+					status = 0xF0;
+				}
+			}
+		}
+
+		// Convert MegaRAID status to Linux error code
+		switch (status) {
+
+		case 0x00:
+
+			scp->result = (DID_OK << 16);
+			break;
+
+		case 0x02:
+
+			/* set sense_buffer and result fields */
+			if (mbox->cmd == MBOXCMD_PASSTHRU ||
+				mbox->cmd == MBOXCMD_PASSTHRU64) {
+
+				memcpy(scp->sense_buffer, pthru->reqsensearea,
+						14);
+
+				scp->result = DRIVER_SENSE << 24 |
+					DID_OK << 16 | CHECK_CONDITION << 1;
+			}
+			else {
+				if (mbox->cmd == MBOXCMD_EXTPTHRU) {
+
+					memcpy(scp->sense_buffer,
+						epthru->reqsensearea, 14);
+
+					scp->result = DRIVER_SENSE << 24 |
+						DID_OK << 16 |
+						CHECK_CONDITION << 1;
+				} else {
+					scp->sense_buffer[0] = 0x70;
+					scp->sense_buffer[2] = ABORTED_COMMAND;
+					scp->result = CHECK_CONDITION << 1;
+				}
+			}
+			break;
+
+		case 0x08:
+
+			scp->result = DID_BUS_BUSY << 16 | status;
+			break;
+
+		default:
+
+			/*
+			 * If TEST_UNIT_READY fails, we know RESERVATION_STATUS
+			 * failed
+			 */
+			if (scp->cmnd[0] == TEST_UNIT_READY) {
+				scp->result = DID_ERROR << 16 |
+					RESERVATION_CONFLICT << 1;
+			}
+			else
+			/*
+			 * Error code returned is 1 if Reserve or Release
+			 * failed or the input parameter is invalid
+			 */
+			if (status == 1 && (scp->cmnd[0] == RESERVE ||
+					 scp->cmnd[0] == RELEASE)) {
+
+				scp->result = DID_ERROR << 16 |
+					RESERVATION_CONFLICT << 1;
+			}
+			else {
+				scp->result = DID_BAD_TARGET << 16 | status;
+			}
+		}
+
+		// print a level 3 debug message for all failed commands
+		if (status) {
+			megaraid_mbox_display_scb(adapter, scb, CL_DLEVEL3);
+		}
+
+		/*
+		 * Free our internal resources and call the mid-layer callback
+		 * routine
+		 */
+		megaraid_mbox_sync_scb(adapter, scb);
+
+		// remove from local clist
+		list_del_init(&scb->list);
+
+		// put back in free list
+		megaraid_dealloc_scb(adapter, scb);
+
+		// send the scsi packet back to kernel
+		spin_lock(adapter->host_lock);
+		scp->scsi_done(scp);
+		spin_unlock(adapter->host_lock);
+	}
+
+	return;
+}
+
+
+/**
+ * megaraid_mbox_sync_scb - sync kernel buffers
+ * @adapter	- controller's soft state
+ * @scb		- pointer to the resource packet
+ *
+ * DMA sync if required.
+ */
+static inline void
+megaraid_mbox_sync_scb(adapter_t *adapter, scb_t *scb)
+{
+	mbox_ccb_t	*ccb;
+
+	ccb	= (mbox_ccb_t *)scb->ccb;
+
+	switch (scb->dma_type) {
+
+	case MRAID_DMA_WBUF:
+		if (scb->dma_direction == PCI_DMA_FROMDEVICE) {
+			pci_dma_sync_single(adapter->pdev,
+					ccb->buf_dma_h,
+					scb->scp->request_bufflen,
+					PCI_DMA_FROMDEVICE);
+		}
+
+		pci_unmap_page(adapter->pdev, ccb->buf_dma_h,
+			scb->scp->request_bufflen, scb->dma_direction);
+
+		break;
+
+	case MRAID_DMA_WSG:
+		if (scb->dma_direction == PCI_DMA_FROMDEVICE) {
+			pci_dma_sync_sg(adapter->pdev,
+					scb->scp->request_buffer,
+					scb->scp->use_sg, PCI_DMA_FROMDEVICE);
+		}
+
+		pci_unmap_sg(adapter->pdev, scb->scp->request_buffer,
+			scb->scp->use_sg, scb->dma_direction);
+
+		break;
+
+	default:
+		break;
+	}
+
+	return;
+}
+
+
+/**
+ * megaraid_abort_handler - abort the scsi command
+ * @scp		: command to be aborted
+ *
+ * Abort a previous SCSI request. Only commands on the pending list can be
+ * aborted. All the commands issued to the F/W must complete.
+ **/
+static int
+megaraid_abort_handler(struct scsi_cmnd *scp)
+{
+	adapter_t		*adapter;
+	mraid_device_t		*raid_dev;
+	scb_t			*scb;
+	struct list_head	*pos, *next;
+	int			found;
+	unsigned long		flags;
+	int			i;
+
+
+	adapter		= SCP2ADAPTER(scp);
+	raid_dev	= ADAP2RAIDDEV(adapter);
+
+	ASSERT(spin_is_locked(adapter->host_lock));
+
+	con_log(CL_ANN, (KERN_WARNING
+		"megaraid: aborting-%ld cmd=%x <c=%d t=%d l=%d>\n",
+		scp->serial_number, scp->cmnd[0], SCP2CHANNEL(scp),
+		SCP2TARGET(scp), SCP2LUN(scp)));
+
+	// If FW has stopped responding, simply return failure
+	if (raid_dev->hw_error) {
+		con_log(CL_ANN, (KERN_NOTICE
+			"megaraid: hw error, not aborting\n"));
+		return FAILED;
+	}
+
+	// There might a race here, where the command was completed by the
+	// firmware and now it is on the completed list. Before we could
+	// complete the command to the kernel in dpc, the abort came.
+	// Find out if this is the case to avoid the race.
+	scb = NULL;
+	spin_lock_irqsave(COMPLETED_LIST_LOCK(adapter), flags);
+	list_for_each_safe(pos, next, &adapter->completed_list) {
+
+		scb = list_entry(pos, scb_t, list);
+
+		if (scb->scp == scp) {	// Found command
+
+			list_del_init(&scb->list);	// from completed list
+
+			con_log(CL_ANN, (KERN_WARNING
+			"megaraid: %ld:%d[%d:%d], abort from completed list\n",
+				scp->serial_number, scb->sno,
+				scb->dev_channel, scb->dev_target));
+
+			scp->result = (DID_ABORT << 16);
+			scp->scsi_done(scp);
+
+			megaraid_dealloc_scb(adapter, scb);
+
+			spin_unlock_irqrestore(COMPLETED_LIST_LOCK(adapter),
+				flags);
+
+			return SUCCESS;
+		}
+	}
+	spin_unlock_irqrestore(COMPLETED_LIST_LOCK(adapter), flags);
+
+
+	// Find out if this command is still on the pending list. If it is and
+	// was never issued, abort and return success. If the command is owned
+	// by the firmware, we must wait for it to complete by the FW.
+	spin_lock_irqsave(PENDING_LIST_LOCK(adapter), flags);
+	list_for_each_safe(pos, next, &adapter->pend_list) {
+
+		scb = list_entry(pos, scb_t, list);
+
+		if (scb->scp == scp) {	// Found command
+
+			list_del_init(&scb->list);	// from pending list
+
+			ASSERT(!(scb->state & SCB_ISSUED));
+
+			con_log(CL_ANN, (KERN_WARNING
+				"megaraid abort: %ld[%d:%d], driver owner\n",
+				scp->serial_number, scb->dev_channel,
+				scb->dev_target));
+
+			scp->result = (DID_ABORT << 16);
+			scp->scsi_done(scp);
+
+			megaraid_dealloc_scb(adapter, scb);
+
+			spin_unlock_irqrestore(PENDING_LIST_LOCK(adapter),
+				flags);
+
+			return SUCCESS;
+		}
+	}
+	spin_unlock_irqrestore(PENDING_LIST_LOCK(adapter), flags);
+
+
+	// Check do we even own this command, in which case this would be
+	// owned by the firmware. The only way to locate the FW scb is to
+	// traverse through the list of all SCB, since driver does not
+	// maintain these SCBs on any list
+	found = 0;
+	for (i = 0; i < MBOX_MAX_DRIVER_CMDS; i++) {
+		scb = adapter->scb_list + i;
+
+		if (scb->scp == scp) {
+
+			found = 1;
+
+			if (!(scb->state & SCB_ISSUED)) {
+				con_log(CL_ANN, (KERN_WARNING
+				"megaraid abort: %ld%d[%d:%d], invalid state\n",
+				scp->serial_number, scb->sno, scb->dev_channel,
+				scb->dev_target));
+				BUG();
+			}
+			else {
+				con_log(CL_ANN, (KERN_WARNING
+				"megaraid abort: %ld:%d[%d:%d], fw owner\n",
+				scp->serial_number, scb->sno, scb->dev_channel,
+				scb->dev_target));
+			}
+		}
+	}
+
+	if (!found) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid abort: %ld:%d[%d:%d], do now own\n",
+			scp->serial_number, scb->sno, scb->dev_channel,
+			scb->dev_target));
+
+		return SUCCESS;
+	}
+
+	// We cannot actually abort a command owned by firmware, return
+	// failure and wait for reset. In host reset handler, we will find out
+	// if the HBA is still live
+	return FAILED;
+}
+
+
+/**
+ * megaraid_reset_handler - device reset hadler for mailbox based driver
+ * @scp		: reference command
+ *
+ * Reset handler for the mailbox based controller. First try to find out if
+ * the FW is still live, in which case the outstanding commands counter mut go
+ * down to 0. If that happens, also issue the reservation reset command to
+ * relinquish (possible) reservations on the logical drives connected to this
+ * host
+ **/
+static int
+megaraid_reset_handler(struct scsi_cmnd *scp)
+{
+	adapter_t		*adapter;
+	scb_t			*scb;
+	mbox_ccb_t		*ccb;
+	mraid_device_t		*raid_dev;
+	struct list_head	*pos, *next;
+	unsigned long		flags;
+	int			rval;
+	int			i;
+
+	adapter		= SCP2ADAPTER(scp);
+	raid_dev	= ADAP2RAIDDEV(adapter);
+
+	ASSERT(spin_is_locked(adapter->host_lock));
+
+	con_log(CL_ANN, (KERN_WARNING "megaraid: reseting the host...\n"));
+
+	// return failure if adapter is not responding
+	if (raid_dev->hw_error) {
+		con_log(CL_ANN, (KERN_NOTICE
+			"megaraid: hw error, cannot reset\n"));
+		return FAILED;
+	}
+
+
+	// Under exceptional conditions, FW can take up to 3 minutes to
+	// complete command processing. Wait for additional 3 minutes for the
+	// pending commands counter to go down to 0. If it doesn't, mark the
+	// controller offline
+	// Also, reset all the commands currently owned by the driver
+	spin_lock_irqsave(PENDING_LIST_LOCK(adapter), flags);
+	list_for_each_safe(pos, next, &adapter->pend_list) {
+
+		scb = list_entry(pos, scb_t, list);
+
+		list_del_init(&scb->list);	// from pending list
+
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: %ld:%d[%d:%d], reset from pending list\n",
+				scp->serial_number, scb->sno,
+				scb->dev_channel, scb->dev_target));
+
+		scp->result = (DID_RESET << 16);
+		scp->scsi_done(scp);
+
+		megaraid_dealloc_scb(adapter, scb);
+	}
+	spin_unlock_irqrestore(PENDING_LIST_LOCK(adapter), flags);
+
+	if (adapter->outstanding_cmds) {
+		con_log(CL_ANN, (KERN_NOTICE
+			"megaraid: %d outstanding commands. Max wait %d sec\n",
+			adapter->outstanding_cmds, MBOX_RESET_WAIT));
+	}
+
+	for (i = 0; i < MBOX_RESET_WAIT && adapter->outstanding_cmds; i++) {
+
+		ASSERT(spin_is_locked(adapter->host_lock));
+
+		megaraid_ack_sequence(adapter);
+
+		spin_lock_irqsave(COMPLETED_LIST_LOCK(adapter), flags);
+		while (!list_empty(&adapter->completed_list)) {
+
+			scb = list_entry(adapter->completed_list.next, scb_t,
+				list);
+
+			list_del_init(&scb->list);	// from completed list
+
+			con_log(CL_ANN, (KERN_WARNING
+			"megaraid: %ld:%d[%d:%d], reset from completed list\n",
+				scp->serial_number, scb->sno,
+				scb->dev_channel, scb->dev_target));
+
+			scp->result = (DID_RESET << 16);
+			scp->scsi_done(scp);
+
+			megaraid_dealloc_scb(adapter, scb);
+		}
+		spin_unlock_irqrestore(COMPLETED_LIST_LOCK(adapter), flags);
+
+		spin_unlock(adapter->host_lock);
+
+		// print a message once every 5 second only
+		if (!(i % 5)) {
+			con_log(CL_ANN, (
+			"megaraid: Wait for %d commands to complete:%d\n",
+				adapter->outstanding_cmds,
+				MBOX_RESET_WAIT - i));
+		}
+
+		mdelay(1000);
+
+		spin_lock(adapter->host_lock);
+	}
+
+	// If still outstanding commands, bail out
+	if (adapter->outstanding_cmds) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: critical hardware error!\n"));
+
+		raid_dev->hw_error = 1;
+
+		return FAILED;
+	}
+
+
+	// If the controller supports clustering, reset reservations
+	if (!adapter->ha) return SUCCESS;
+
+	// clear reservations if any
+	scb	= &adapter->iscb;
+	ccb	= (mbox_ccb_t *)scb->ccb;
+
+	ccb->raw_mbox[0] = CLUSTER_CMD;
+	ccb->raw_mbox[2] = RESET_RESERVATIONS;
+
+	rval = SUCCESS;
+	if (mbox_post_sync_cmd_fast(adapter, ccb->raw_mbox) == 0) {
+		con_log(CL_ANN,
+			(KERN_INFO "megaraid: reservation reset\n"));
+	}
+	else {
+		rval = FAILED;
+		con_log(CL_ANN, (KERN_WARNING
+				"megaraid: reservation reset failed\n"));
+	}
+
+	return rval;
+}
+
+
+/*
+ * START: internal commands library
+ *
+ * This section of the driver has the common routine used by the driver and
+ * also has all the FW routines
+ */
+
+/**
+ * mbox_post_sync_cmd() - blocking command to the mailbox based controllers
+ * @adapter	- controller's soft state
+ * @raw_mbox	- the mailbox
+ *
+ * Issue a scb in synchronous and non-interrupt mode for mailbox based
+ * controllers
+ */
+static int
+mbox_post_sync_cmd(adapter_t *adapter, uint8_t raw_mbox[])
+{
+	mraid_device_t	*raid_dev = ADAP2RAIDDEV(adapter);
+	mbox64_t	*mbox64;
+	mbox_t		*mbox;
+	uint8_t		status;
+	long		i;
+
+
+	mbox64	= raid_dev->mbox64;
+	mbox	= raid_dev->mbox;
+
+	/*
+	 * Wait until mailbox is free
+	 */
+	if (megaraid_busywait_mbox(raid_dev) == MRAID_FAILURE)
+		goto blocked_mailbox;
+
+	/*
+	 * Copy mailbox data into host structure
+	 */
+	memcpy((caddr_t)mbox, (caddr_t)raw_mbox, 16);
+	mbox->cmdid		= 0xFE;
+	mbox->busy		= 1;
+	mbox->poll		= 0;
+	mbox->ack		= 0;
+	mbox->numstatus		= 0xFF;
+	mbox->status		= 0xFF;
+
+	wmb();
+	WRINDOOR(raid_dev, raid_dev->mbox_dma | 0x1);
+
+	// wait for maximum 1 second for status to post
+	for (i = 0; i < 40000; i++) {
+		if (mbox->numstatus != 0xFF) break;
+		udelay(25); yield();
+	}
+	if (i == 40000) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid mailbox: status not available\n"));
+		return -1;
+	}
+
+	// wait for maximum 1 second for poll semaphore
+	for (i = 0; i < 40000; i++) {
+		if (mbox->poll == 0x77) break;
+		udelay(25); yield();
+	}
+	if (i == 40000) {
+		con_log(CL_ANN, (KERN_WARNING
+		"megaraid mailbox: could not get poll semaphore\n"));
+		return -1;
+	}
+
+	WRINDOOR(raid_dev, raid_dev->mbox_dma | 0x2);
+	wmb();
+
+	// wait for maximum 1 second for acknowledgement
+	for (i = 0; i < 40000; i++) {
+		if ((RDINDOOR(raid_dev) & 0x2) == 0) {
+			mbox->poll	= 0;
+			mbox->ack	= 0x77;
+			break;
+		}
+		udelay(25); yield();
+	}
+	if (i == 40000) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid mailbox: could not acknowledge\n"));
+		return -1;
+	}
+
+	status = mbox->status;
+
+	// invalidate the completed command id array. After command
+	// completion, firmware would write the valid id.
+	mbox->numstatus	= 0xFF;
+	mbox->status	= 0xFF;
+	for (i = 0; i < MBOX_MAX_FIRMWARE_STATUS; i++) {
+		mbox->completed[i] = 0xFF;
+	}
+
+	return status;
+
+blocked_mailbox:
+
+	con_log(CL_ANN, (KERN_WARNING "megaraid: blocked mailbox\n") );
+	return -1;
+}
+
+
+/**
+ * mbox_post_sync_cmd_fast - blocking command to the mailbox based controllers
+ * @adapter	- controller's soft state
+ * @raw_mbox	- the mailbox
+ *
+ * Issue a scb in synchronous and non-interrupt mode for mailbox based
+ * controllers. This is a faster version of the synchronous command and
+ * therefore can be called in interrupt-context as well
+ */
+static int
+mbox_post_sync_cmd_fast(adapter_t *adapter, uint8_t raw_mbox[])
+{
+	mraid_device_t	*raid_dev = ADAP2RAIDDEV(adapter);
+	mbox_t		*mbox;
+	long		i;
+
+
+	mbox	= raid_dev->mbox;
+
+	// return immediately if the mailbox is busy
+	if (mbox->busy) return MRAID_FAILURE;
+
+	// Copy mailbox data into host structure
+	memcpy((caddr_t)mbox, (caddr_t)raw_mbox, 16);
+	mbox->cmdid		= 0xFE;
+	mbox->busy		= 1;
+	mbox->poll		= 0;
+	mbox->ack		= 0;
+	mbox->numstatus		= 0xFF;
+	mbox->status		= 0xFF;
+
+	wmb();
+	WRINDOOR(raid_dev, raid_dev->mbox_dma | 0x1);
+
+	for (i = 0; i < 0xFFFFF; i++) {
+		if (mbox->numstatus != 0xFF) break;
+	}
+
+	if (i == 0xFFFFF) {
+		// We may need to re-calibrate the counter
+		con_log(CL_ANN, (KERN_CRIT
+			"megaraid: fast sync command timed out\n"));
+	}
+
+	WRINDOOR(raid_dev, raid_dev->mbox_dma | 0x2);
+	wmb();
+
+	return mbox->status;
+}
+
+
+/**
+ * megaraid_busywait_mbox() - Wait until the controller's mailbox is available
+ * @raid_dev	- RAID device (HBA) soft state
+ *
+ * wait until the controller's mailbox is available to accept more commands.
+ */
+static inline status_t
+megaraid_busywait_mbox(mraid_device_t *raid_dev)
+{
+	mbox_t	*mbox = raid_dev->mbox;
+
+	if (mbox->busy)
+		return __megaraid_busywait_mbox(raid_dev);
+
+	return MRAID_SUCCESS;
+}
+
+
+/**
+ * __megaraid_busywait_mbox() - Wait until controller's mailbox is available
+ * @raid_dev	- mailbox data structures
+ *
+ * wait until the controller's mailbox is available to accept more commands.
+ */
+static inline status_t
+__megaraid_busywait_mbox(mraid_device_t *raid_dev)
+{
+	mbox_t		*mbox = raid_dev->mbox;
+	unsigned long	counter;
+
+
+	for (counter = 0; counter < 10000; counter++) {
+
+		if (!mbox->busy) return MRAID_SUCCESS;
+
+		udelay(100); yield();
+	}
+	return MRAID_FAILURE;	/* give up after 1 second */
+}
+
+
+
+/**
+ * megaraid_mbox_product_info - some static information about the controller
+ * @adapter	- our soft state
+ *
+ * issue commands to the controller to grab some parameters required by our
+ * caller.
+ */
+static status_t
+megaraid_mbox_product_info(adapter_t *adapter)
+{
+	mraid_device_t		*raid_dev = ADAP2RAIDDEV(adapter);
+	mbox_ccb_t		*ccb;
+	mbox_t			*mbox;
+	mraid_pinfo_t		*pinfo;
+	dma_addr_t		pinfo_dma_h;
+	mraid_inquiry3_t	*mraid_inq3;
+	scb_t			*scb;
+	int			i;
+
+
+	scb	= &adapter->iscb;
+	ccb	= (mbox_ccb_t *)scb->ccb;
+
+	/*
+	 * Issue an ENQUIRY3 command to find out certain adapter parameters,
+	 * e.g., max channels, max commands etc.
+	 */
+	pinfo = pci_alloc_consistent(adapter->pdev, sizeof(mraid_pinfo_t),
+			&pinfo_dma_h);
+
+	if (pinfo == NULL) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: out of memory, %s %d\n", __FUNCTION__,
+			__LINE__));
+
+		return MRAID_FAILURE;
+	}
+	memset(pinfo, 0, sizeof(mraid_pinfo_t));
+
+	mbox = ccb->mbox;
+
+	mbox->xferaddr = (uint32_t)adapter->ibuf_dma_h;
+	memset((void *)adapter->ibuf, 0, MBOX_IBUF_SIZE);
+
+	// NOTE: ccb->raw_mbox and ccb->mbox are same memory location
+	ccb->raw_mbox[0] = FC_NEW_CONFIG;
+	ccb->raw_mbox[2] = NC_SUBOP_ENQUIRY3;
+	ccb->raw_mbox[3] = ENQ3_GET_SOLICITED_FULL;
+
+	// Issue the command
+	if (mbox_post_sync_cmd(adapter, ccb->raw_mbox) != 0) {
+
+		con_log(CL_ANN, (KERN_WARNING "megaraid: Inquiry3 failed\n"));
+
+		pci_free_consistent(adapter->pdev, sizeof(mraid_pinfo_t),
+			pinfo, pinfo_dma_h);
+
+		return MRAID_FAILURE;
+	}
+
+	/*
+	 * Collect information about state of each physical drive
+	 * attached to the controller. We will expose all the disks
+	 * which are not part of RAID
+	 */
+	mraid_inq3 = (mraid_inquiry3_t *)adapter->ibuf;
+	for (i = 0; i < MBOX_MAX_PHYSICAL_DRIVES; i++) {
+		raid_dev->pdrv_state[i] = mraid_inq3->pdrv_state[i];
+	}
+
+	/*
+	 * Get product info for information like number of channels,
+	 * maximum commands supported.
+	 */
+	memset((caddr_t)ccb->raw_mbox, 0, sizeof(ccb->raw_mbox));
+	mbox->xferaddr = (uint32_t)pinfo_dma_h;
+
+	ccb->raw_mbox[0] = FC_NEW_CONFIG;
+	ccb->raw_mbox[2] = NC_SUBOP_PRODUCT_INFO;
+
+	if (mbox_post_sync_cmd(adapter, ccb->raw_mbox) != 0) {
+
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: product info failed\n"));
+
+		pci_free_consistent(adapter->pdev, sizeof(mraid_pinfo_t),
+			pinfo, pinfo_dma_h);
+
+		return MRAID_FAILURE;
+	}
+
+	/*
+	 * Setup some parameters for host, as required by our caller
+	 */
+	adapter->max_channel = pinfo->nchannels;
+
+	/*
+	 * we will export all the logical drives on a single channel.
+	 * Add 1 since inquires do not come for inititor ID
+	 */
+	adapter->max_target	= MAX_LOGICAL_DRIVES_40LD + 1;
+	adapter->max_lun	= 8;	// up to 8 LUNs for non-disk devices
+
+	/*
+	 * Reserve one ID for internal commands. For commands issued
+	 * internally, always use command ID 0.
+	 */
+	adapter->iscb.sno	= 0;
+
+
+	/*
+	 * Set the number of supported commands equal to that supported by the
+	 * driver
+	 */
+	adapter->max_cmds	= MBOX_MAX_DRIVER_CMDS;
+
+	memset(adapter->fw_version, 0, VERSION_SIZE);
+	memset(adapter->bios_version, 0, VERSION_SIZE);
+
+	memcpy(adapter->fw_version, pinfo->fw_version, 4);
+	adapter->fw_version[4] = 0;
+
+	memcpy(adapter->bios_version, pinfo->bios_version, 4);
+	adapter->bios_version[4] = 0;
+
+	pci_free_consistent(adapter->pdev, sizeof(mraid_pinfo_t), pinfo,
+			pinfo_dma_h);
+
+	return MRAID_SUCCESS;
+}
+
+
+
+/**
+ * megaraid_mbox_extended_cdb - check for support for extended CDBs
+ * @adapter	- soft state for the controller
+ *
+ * this routine check whether the controller in question supports extended
+ * ( > 10 bytes ) CDBs
+ */
+static status_t
+megaraid_mbox_extended_cdb(adapter_t *adapter)
+{
+	mbox_ccb_t	*ccb;
+	mbox_t		*mbox;
+	scb_t		*scb;
+	status_t	rval;
+
+	scb		= &adapter->iscb;
+	ccb		= (mbox_ccb_t *)scb->ccb;
+	mbox		= ccb->mbox;
+
+	memset((caddr_t)ccb->raw_mbox, 0, sizeof(mbox_t));
+	mbox->xferaddr	= (uint32_t)adapter->ibuf_dma_h;
+
+	memset((void *)adapter->ibuf, 0, MBOX_IBUF_SIZE);
+
+	ccb->raw_mbox[0] = MAIN_MISC_OPCODE;
+	ccb->raw_mbox[2] = SUPPORT_EXT_CDB;
+
+	/*
+	 * Issue the command
+	 */
+	rval = MRAID_SUCCESS;
+	if (mbox_post_sync_cmd(adapter, ccb->raw_mbox) != 0) {
+		rval = MRAID_FAILURE;
+	}
+
+	return rval;
+}
+
+
+/**
+ * megaraid_mbox_support_ha - Do we support clustering
+ * @adapter	- soft state for the controller
+ * @init_id	- ID of the initiator
+ *
+ * Determine if the firmware supports clustering and the ID of the initiator.
+ */
+static status_t
+megaraid_mbox_support_ha(adapter_t *adapter, uint16_t *init_id)
+{
+	mbox_ccb_t	*ccb;
+	mbox_t		*mbox;
+	scb_t		*scb;
+	status_t	rval;
+
+
+	scb	= &adapter->iscb;
+	ccb	= (mbox_ccb_t *)scb->ccb;
+	mbox	= ccb->mbox;
+	memset((caddr_t)ccb->raw_mbox, 0, sizeof(mbox_t));
+	mbox->xferaddr = (uint32_t)adapter->ibuf_dma_h;
+
+	memset((void *)adapter->ibuf, 0, MBOX_IBUF_SIZE);
+
+	ccb->raw_mbox[0] = GET_TARGET_ID;
+
+	// Issue the command
+	*init_id = 7;
+	rval =  MRAID_FAILURE;
+	if (mbox_post_sync_cmd(adapter, ccb->raw_mbox) == 0) {
+
+		*init_id = *(uint8_t *)adapter->ibuf;
+
+		con_log(CL_ANN, (KERN_INFO
+			"megaraid: cluster firmware, initiator ID: %d\n",
+			*init_id));
+
+		rval =  MRAID_SUCCESS;
+	}
+
+	return rval;
+}
+
+
+/**
+ * megaraid_mbox_support_random_del - Do we support random deletion
+ * @adapter	- soft state for the controller
+ *
+ * Determine if the firmware supports random deletion
+ * Return:	1 is operation supported, 0 otherwise
+ */
+static int
+megaraid_mbox_support_random_del(adapter_t *adapter)
+{
+	mbox_ccb_t	*ccb;
+	mbox_t		*mbox;
+	scb_t		*scb;
+	int		rval;
+
+
+	scb	= &adapter->iscb;
+	ccb	= (mbox_ccb_t *)scb->ccb;
+	mbox	= ccb->mbox;
+	memset((caddr_t)ccb->raw_mbox, 0, sizeof(mbox_t));
+
+	ccb->raw_mbox[0] = FC_DEL_LOGDRV;
+	ccb->raw_mbox[0] = OP_SUP_DEL_LOGDRV;
+
+	// Issue the command
+	rval = 0;
+	if (mbox_post_sync_cmd(adapter, ccb->raw_mbox) == 0) {
+
+		con_log(CL_DLEVEL1, ("megaraid: supports random deletion\n"));
+
+		rval =  1;
+	}
+
+	return rval;
+}
+
+
+/**
+ * megaraid_mbox_get_max_sg - maximum sg elements supported by the firmware
+ * @adapter	- soft state for the controller
+ *
+ * Find out the maximum number of scatter-gather elements supported by the
+ * firmware
+ */
+static int
+megaraid_mbox_get_max_sg(adapter_t *adapter)
+{
+	mbox_ccb_t	*ccb;
+	mbox_t		*mbox;
+	scb_t		*scb;
+	int		nsg;
+
+
+	scb	= &adapter->iscb;
+	ccb	= (mbox_ccb_t *)scb->ccb;
+	mbox	= ccb->mbox;
+	memset((caddr_t)ccb->raw_mbox, 0, sizeof(mbox_t));
+	mbox->xferaddr = (uint32_t)adapter->ibuf_dma_h;
+
+	memset((void *)adapter->ibuf, 0, MBOX_IBUF_SIZE);
+
+	ccb->raw_mbox[0] = MAIN_MISC_OPCODE;
+	ccb->raw_mbox[2] = GET_MAX_SG_SUPPORT;
+
+	// Issue the command
+	if (mbox_post_sync_cmd(adapter, ccb->raw_mbox) == 0) {
+		nsg =  *(uint8_t *)adapter->ibuf;
+	}
+	else {
+		nsg =  MBOX_DEFAULT_SG_SIZE;
+	}
+
+	if (nsg > MBOX_MAX_SG_SIZE) nsg = MBOX_MAX_SG_SIZE;
+
+	return nsg;
+}
+
+
+/**
+ * megaraid_mbox_enum_raid_scsi - enumerate the RAID and SCSI channels
+ * @adapter	- soft state for the controller
+ *
+ * Enumerate the RAID and SCSI channels for ROMB platoforms so that channels
+ * can be exported as regular SCSI channels
+ */
+static void
+megaraid_mbox_enum_raid_scsi(adapter_t *adapter)
+{
+	mraid_device_t		*raid_dev = ADAP2RAIDDEV(adapter);
+	mbox_ccb_t		*ccb;
+	mbox_t			*mbox;
+	scb_t			*scb;
+
+
+	scb	= &adapter->iscb;
+	ccb	= (mbox_ccb_t *)scb->ccb;
+	mbox	= ccb->mbox;
+	memset((caddr_t)ccb->raw_mbox, 0, sizeof(mbox_t));
+	mbox->xferaddr = (uint32_t)adapter->ibuf_dma_h;
+
+	memset((void *)adapter->ibuf, 0, MBOX_IBUF_SIZE);
+
+	ccb->raw_mbox[0] = CHNL_CLASS;
+	ccb->raw_mbox[2] = GET_CHNL_CLASS;
+
+	// Issue the command. If the command fails, all channels are RAID
+	// channels
+	raid_dev->channel_class = 0xFF;
+	if (mbox_post_sync_cmd(adapter, ccb->raw_mbox) == 0) {
+		raid_dev->channel_class =  *(uint8_t *)adapter->ibuf;
+	}
+
+	return;
+}
+
+
+/**
+ * megaraid_mbox_flush_cache - flush adapter and disks cache
+ * @param adapter	: soft state for the controller
+ *
+ * Flush adapter cache followed by disks cache
+ */
+static void
+megaraid_mbox_flush_cache(adapter_t *adapter)
+{
+	mbox_ccb_t	*ccb;
+	mbox_t		*mbox;
+	scb_t		*scb;
+
+
+	scb	= &adapter->iscb;
+	ccb	= (mbox_ccb_t *)scb->ccb;
+	mbox	= ccb->mbox;
+	memset((caddr_t)ccb->raw_mbox, 0, sizeof(mbox_t));
+
+	ccb->raw_mbox[0] = FLUSH_ADAPTER;
+
+	if (mbox_post_sync_cmd(adapter, ccb->raw_mbox) != 0) {
+		con_log(CL_ANN, ("megaraid: flush adapter failed\n"));
+	}
+
+	ccb->raw_mbox[0] = FLUSH_SYSTEM;
+
+	if (mbox_post_sync_cmd(adapter, ccb->raw_mbox) != 0) {
+		con_log(CL_ANN, ("megaraid: flush disks cache failed\n"));
+	}
+
+	return;
+}
+
+
+/**
+ * megaraid_mbox_display_scb - display SCB information, mostly debug purposes
+ * @param adapter	: controllers' soft state
+ * @param scb		: SCB to be displayed
+ * @param level	: debug level for console print
+ */
+static void
+megaraid_mbox_display_scb(adapter_t *adapter, scb_t *scb, int level)
+{
+	mbox_ccb_t		*ccb;
+	struct scsi_cmnd	*scp;
+	mbox_t			*mbox;
+	int			i;
+
+
+	ccb	= (mbox_ccb_t *)scb->ccb;
+	scp	= scb->scp;
+	mbox	= ccb->mbox;
+
+	con_log(level, (KERN_NOTICE
+		"megaraid mailbox: status:%#x cmd:%#x id:%#x ", scb->status,
+		mbox->cmd, scb->sno));
+
+	con_log(level, ("sec:%#x lba:%#x addr:%#x ld:%d sg:%d\n",
+		mbox->numsectors, mbox->lba, mbox->xferaddr, mbox->logdrv,
+		mbox->numsge));
+
+	if (!scp) return;
+
+	con_log(level, (KERN_NOTICE "scsi cmnd: "));
+
+	for (i = 0; i < scp->cmd_len; i++) {
+		con_log(level, ("%#2.02x ", scp->cmnd[i]));
+	}
+
+	con_log(level, ("\n"));
+
+	return;
+}
+
+
+/*
+ * END: internal commands library
+ */
+
+/*
+ * START: Interface for the common management module
+ *
+ * This is the module, which interfaces with the common mangement module to
+ * provide support for ioctl and sysfs
+ */
+
+/**
+ * megaraid_cmm_register - register with the mangement module
+ * @param adapter	: HBA soft state
+ *
+ * Register with the management module, which allows applications to issue
+ * ioctl calls to the drivers. This interface is used by the management module
+ * to setup sysfs support as well.
+ */
+static status_t
+megaraid_cmm_register(adapter_t *adapter)
+{
+	mraid_mmadp_t	adp;
+
+	adp.unique_id		= adapter->unique_id;
+	adp.drvr_type		= DRVRTYPE_MBOX;
+	adp.drvr_data		= (unsigned long)adapter;
+	adp.pdev		= adapter->pdev;
+	adp.issue_uioc		= megaraid_mbox_mm_cmd;
+	adp.timeout		= 30;
+
+	mraid_mm_register_adp(&adp); //FIXME: Check for error messages
+
+	return MRAID_SUCCESS;
+}
+
+
+/**
+ * megaraid_cmm_unregister - un-register with the mangement module
+ * @param adapter	: HBA soft state
+ *
+ * Un-register with the management module.
+ * FIXME: mgmt module must return failure for unregister if it has pending
+ * commands in LLD
+ */
+static status_t
+megaraid_cmm_unregister(adapter_t *adapter)
+{
+	mraid_mm_unregister_adp(adapter->unique_id);
+	return MRAID_SUCCESS;
+}
+
+
+/**
+ * megaraid_mbox_mm_cmd - interface for CMM to issue commands to LLD
+ * @param drvr_data	: LLD specific data
+ * @param kioc		: CMM interface packet
+ * @param action	: command action
+ *
+ * This routine is invoked whenever the Common Mangement Module (CMM) has a
+ * command for us. The 'action' parameter specifies if this is a new command
+ * or otherwise.
+ */
+static int
+megaraid_mbox_mm_cmd(unsigned long drvr_data, uioc_t *kioc, uint32_t action)
+{
+	adapter_t	*adp;
+
+	if (!kioc || !drvr_data)
+		return (-EINVAL);
+
+	if (action != IOCTL_ISSUE) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: unsupported management action:%#2x\n",
+			action));
+		return LC_ENOTSUPP;
+	}
+
+	/*
+	 * Check if drvr_data points to a valid adapter
+	 */
+	adp = (adapter_t *)drvr_data;
+
+	// make sure this adapter is not being detached right now.
+	if (atomic_read(&adp->being_detached)) {
+		con_log(CL_ANN, (KERN_WARNING
+			"megaraid: reject management request, detaching\n"));
+		return (-ENODEV);
+	}
+
+	switch (kioc->opcode) {
+
+	case GET_ADAP_INFO:
+
+		kioc->status =  gather_hbainfo(adp, (mraid_hba_info_t *)
+					(unsigned long)kioc->cmdbuf);
+
+		kioc->done(kioc);
+
+		return kioc->status;
+
+	case MBOX_CMD:
+
+		return megaraid_mbox_internal_command(adp, kioc);
+
+	default:
+		return (-EINVAL);
+	}
+
+	return 0;
+}
+
+/**
+ * megaraid_mbox_internal_command - issues commands routed through CMM
+ * @param adapter	: HBA soft state
+ * @param kioc		: management command packet
+ *
+ * Issues commands, which are routed through the management module.
+ */
+static int
+megaraid_mbox_internal_command(adapter_t *adapter, uioc_t *kioc)
+{
+	mbox64_t		*mbox64;
+	scb_t			*scb;
+	mbox_ccb_t		*ccb;
+	Scsi_Cmnd		*scmd;
+	uint8_t*		raw_mbox;
+	unsigned long		flags = 0;
+
+	/*
+	 * The internal commands share one command id and hence are serialized.
+	 * This is so because we want to reserve maximum number of available
+	 * command ids for the I/O commands.
+	 * The mutex is released when the command is completed by the
+	 * firmware.
+	 */
+	down(&adapter->imtx);
+
+	mbox64		= (mbox64_t *)(unsigned long)kioc->cmdbuf;
+	raw_mbox	= (uint8_t*) &mbox64->mbox32;
+	scb		= &adapter->iscb;
+	ccb		= (mbox_ccb_t *)scb->ccb;
+	scmd		= &adapter->isc;
+
+	memset(scmd, 0, sizeof(Scsi_Cmnd));
+
+	scmd->device	= &adapter->isdev;
+	SCP2HOST(scmd)	= adapter->host;
+	scmd->buffer	= (void *)scb;
+	scmd->cmnd[0]	= MRAID_INTERNAL_COMMAND;
+
+	scb->state	= SCB_ACTIVE;
+	scb->scp	= scmd;
+
+	memcpy(ccb->mbox64, mbox64, sizeof(mbox64_t));
+
+	scb->gp		= (unsigned long)kioc;
+	scmd->state	= 0;
+	scb->sno	= 0;
+
+	/*
+	 * If it is a logdrv random delete operation, we have to wait till
+	 * there are no outstanding cmds at the fw and then issue it directly
+	 */
+	if (raw_mbox[0] == FC_DEL_LOGDRV && raw_mbox[2] == OP_DEL_LOGDRV) {
+
+		if (wait_till_fw_empty(adapter))
+			return (-ETIME);
+
+		INIT_LIST_HEAD(&scb->list);
+		scmd->scsi_done	= megaraid_mbox_internal_done;
+
+		if (mbox_post_cmd(adapter, scb) != MRAID_SUCCESS)
+			return (-EBUSY);
+
+		return 0;
+	}
+
+	spin_lock_irqsave(adapter->host_lock, flags);
+	megaraid_queue_command(scmd, megaraid_mbox_internal_done);
+	spin_unlock_irqrestore(adapter->host_lock, flags);
+
+	return 0;
+}
+
+static int
+wait_till_fw_empty(adapter_t *adapter)
+{
+	unsigned long	flags = 0;
+	int		i;
+
+	DECLARE_WAIT_QUEUE_HEAD(wq);
+
+	/*
+	 * Set the quiescent flag to stop issuing cmds to FW.
+	 */
+	spin_lock_irqsave(adapter->host_lock, flags);
+	adapter->quiescent = MRAID_TRUE;
+	spin_unlock_irqrestore(adapter->host_lock, flags);
+
+	/*
+	 * Wait till there are no more cmds outstanding at FW. Try for at most
+	 * 60 seconds
+	 */
+	for (i = 0; i < 60 && adapter->outstanding_cmds; i++) {
+		con_log(CL_DLEVEL1, (KERN_INFO
+			"megaraid: FW has %d pending commands\n",
+			adapter->outstanding_cmds));
+		mraid_sleep(1);
+	}
+
+	return adapter->outstanding_cmds;
+}
+
+
+/**
+ * megaraid_mbox_internal_done()
+ * @scmd - internal scsi command
+ *
+ * Callback routine for internal commands originated from the management
+ * module. Also, release the adapter mutex used to serialize access to
+ * internal command index.
+ *
+ * NOTES: This is called with host_lock held
+ */
+static void
+megaraid_mbox_internal_done(Scsi_Cmnd *scmd)
+{
+	adapter_t		*adapter = SCP2ADAPTER(scmd);
+	scb_t			*scb;
+	uioc_t			*kioc;
+	mbox64_t		*mbox64;
+	uint8_t			*raw_mbox;
+
+	scb			= (scb_t *)scmd->buffer;
+	kioc			= (uioc_t *)scb->gp;
+	kioc->status		= LC_SUCCESS;
+	mbox64			= (mbox64_t *)(unsigned long)kioc->cmdbuf;
+	mbox64->mbox32.status	= scmd->result;
+	raw_mbox		= (uint8_t*) &mbox64->mbox32;
+
+
+	if (raw_mbox[0] == FC_DEL_LOGDRV && raw_mbox[2] == OP_DEL_LOGDRV
+							&& !scmd->result) {
+		/*
+		 * It was a del logdrv command and it succeeded
+		 */
+		adapter->quiescent = MRAID_FALSE;
+		megaraid_mbox_runpendq( adapter );
+	}
+
+	up(&adapter->imtx);	// ready for the next command
+
+	kioc->done(kioc);
+
+	return;
+}
+
+
+/**
+ * gather_hbainfo - HBA characteristics for the applications
+ * @param adapter	: HBA soft state
+ * @param hinfo		: pointer to the caller's host info strucuture
+ */
+static int
+gather_hbainfo(adapter_t *adapter, mraid_hba_info_t *hinfo)
+{
+	hinfo->pci_vendor_id	= adapter->pdev->vendor;
+	hinfo->pci_device_id	= adapter->pdev->device;
+	hinfo->subsys_vendor_id	= adapter->pdev->subsystem_vendor;
+	hinfo->subsys_device_id	= adapter->pdev->subsystem_device;
+
+	hinfo->pci_bus		= adapter->pdev->bus->number;
+	hinfo->pci_dev_fn	= adapter->pdev->devfn;
+	hinfo->pci_slot		= PCI_SLOT(adapter->pdev->devfn);
+	hinfo->irq		= adapter->host->irq;
+	hinfo->baseport		= ADAP2RAIDDEV(adapter)->baseport;
+
+	hinfo->unique_id	= (hinfo->pci_bus << 8) | adapter->pdev->devfn;
+	hinfo->host_no		= adapter->host->host_no;
+
+	return 0;
+}
+
+/*
+ * END: Interface for the common management module
+ */
+
+
+/*
+ * END: Mailbox Low Level Driver
+ */
+module_init(megaraid_init);
+module_exit(megaraid_exit);
+
+/* vim: set ts=8 sw=8 tw=78 ai si: */
diff -Naur linux-2.6.6.orig/drivers/scsi/megaraid/megaraid_mbox.h linux-2.6.6/drivers/scsi/megaraid/megaraid_mbox.h
--- linux-2.6.6.orig/drivers/scsi/megaraid/megaraid_mbox.h	Wed Dec 31 19:00:00 1969
+++ linux-2.6.6/drivers/scsi/megaraid/megaraid_mbox.h	Sat May 15 13:35:04 2004
@@ -0,0 +1,276 @@
+/*
+ *
+ *			Linux MegaRAID device driver
+ *
+ * Copyright (c) 2003-2004  LSI Logic Corporation.
+ *
+ *	   This program is free software; you can redistribute it and/or
+ *	   modify it under the terms of the GNU General Public License
+ *	   as published by the Free Software Foundation; either version
+ *	   2 of the License, or (at your option) any later version.
+ *
+ * FILE		: megaraid.h
+ * Version	: v2.20.0.rc2 (May 21 2004)
+ */
+
+#ifndef _MEGARAID_H_
+#define _MEGARAID_H_
+
+#include "kdep.h"
+#include "mbox_defs.h"
+#include "mega_common.h"
+
+
+#define MEGARAID_VERSION	"2.20.0.rc2"
+#define MEGARAID_EXT_VERSION	"(Release Date: Fri May 21 18:11:01 EDT 2004)"
+
+
+/*
+ * Define some PCI values here until they are put in the kernel
+ */
+#define PCI_DEVICE_ID_PERC4_DI_DISCOVERY		0x000E
+#define PCI_SUBSYS_ID_PERC4_DI_DISCOVERY		0x0123
+
+#define PCI_DEVICE_ID_PERC4_SC				0x1960
+#define PCI_SUBSYS_ID_PERC4_SC				0x0520
+
+#define PCI_DEVICE_ID_PERC4_DC				0x1960
+#define PCI_SUBSYS_ID_PERC4_DC				0x0518
+
+#define PCI_DEVICE_ID_PERC4_QC				0x0407
+#define PCI_SUBSYS_ID_PERC4_QC				0x0531
+
+#define PCI_DEVICE_ID_PERC4_DI_EVERGLADES		0x000F
+#define PCI_SUBSYS_ID_PERC4_DI_EVERGLADES		0x014A
+
+#define PCI_DEVICE_ID_PERC4E_SI_BIGBEND			0x0013
+#define PCI_SUBSYS_ID_PERC4E_SI_BIGBEND			0x016c
+
+#define PCI_DEVICE_ID_PERC4E_DI_KOBUK			0x0013
+#define PCI_SUBSYS_ID_PERC4E_DI_KOBUK			0x016d
+
+#define PCI_DEVICE_ID_PERC4E_DI_CORVETTE		0x0013
+#define PCI_SUBSYS_ID_PERC4E_DI_CORVETTE		0x016e
+
+#define PCI_DEVICE_ID_PERC4E_DI_EXPEDITION		0x0013
+#define PCI_SUBSYS_ID_PERC4E_DI_EXPEDITION		0x016f
+
+#define PCI_DEVICE_ID_PERC4E_DI_GUADALUPE		0x0013
+#define PCI_SUBSYS_ID_PERC4E_DI_GUADALUPE		0x0170
+
+#define PCI_DEVICE_ID_PERC4E_DC_320_2E			0x0408
+#define PCI_SUBSYS_ID_PERC4E_DC_320_2E			0x0002
+
+#define PCI_DEVICE_ID_PERC4E_SC_320_1E			0x0408
+#define PCI_SUBSYS_ID_PERC4E_SC_320_1E			0x0001
+
+#define PCI_DEVICE_ID_MEGARAID_SCSI_320_0		0x1960
+#define PCI_SUBSYS_ID_MEGARAID_SCSI_320_0		0xA520
+
+#define PCI_DEVICE_ID_MEGARAID_SCSI_320_1		0x1960
+#define PCI_SUBSYS_ID_MEGARAID_SCSI_320_1		0x0520
+
+#define PCI_DEVICE_ID_MEGARAID_SCSI_320_2		0x1960
+#define PCI_SUBSYS_ID_MEGARAID_SCSI_320_2		0x0518
+
+#define PCI_DEVICE_ID_MEGARAID_SCSI_320_0x		0x0407
+#define PCI_SUBSYS_ID_MEGARAID_SCSI_320_0x		0x0530
+
+#define PCI_DEVICE_ID_MEGARAID_SCSI_320_2x		0x0407
+#define PCI_SUBSYS_ID_MEGARAID_SCSI_320_2x		0x0532
+
+#define PCI_DEVICE_ID_MEGARAID_SCSI_320_4x		0x0407
+#define PCI_SUBSYS_ID_MEGARAID_SCSI_320_4x		0x0531
+
+#define PCI_DEVICE_ID_MEGARAID_SCSI_320_1E		0x0408
+#define PCI_SUBSYS_ID_MEGARAID_SCSI_320_1E		0x0001
+
+#define PCI_DEVICE_ID_MEGARAID_SCSI_320_2E		0x0408
+#define PCI_SUBSYS_ID_MEGARAID_SCSI_320_2E		0x0002
+
+#define PCI_DEVICE_ID_MEGARAID_SATA_150_4		0x1960
+#define PCI_SUBSYS_ID_MEGARAID_SATA_150_4		0x4523
+
+#define PCI_DEVICE_ID_MEGARAID_SATA_150_6		0x1960
+#define PCI_SUBSYS_ID_MEGARAID_SATA_150_6		0x0523
+
+#define PCI_DEVICE_ID_MEGARAID_SATA_300_4x		0x0409
+#define PCI_SUBSYS_ID_MEGARAID_SATA_300_4x		0x1504
+
+#define PCI_DEVICE_ID_MEGARAID_SATA_300_8x		0x0409
+#define PCI_SUBSYS_ID_MEGARAID_SATA_300_8x		0x1508
+
+#define PCI_DEVICE_ID_INTEL_RAID_SRCU42X		0x0407
+#define PCI_SUBSYS_ID_INTEL_RAID_SRCU42X		0x0532
+
+#define PCI_DEVICE_ID_INTEL_RAID_SRCS16			0x1960
+#define PCI_SUBSYS_ID_INTEL_RAID_SRCS16			0x0523
+
+#define PCI_DEVICE_ID_INTEL_RAID_SRCU42E		0x0408
+#define PCI_SUBSYS_ID_INTEL_RAID_SRCU42E		0x0002
+
+#define PCI_DEVICE_ID_INTEL_RAID_SRCZCRX		0x0407
+#define PCI_SUBSYS_ID_INTEL_RAID_SRCZCRX		0x0530
+
+#define PCI_DEVICE_ID_INTEL_RAID_SRCS28X		0x0409
+#define PCI_SUBSYS_ID_INTEL_RAID_SRCS28X		0x1508
+
+#define PCI_DEVICE_ID_INTEL_RAID_SROMBU42E_ALIEF	0x0408
+#define PCI_SUBSYS_ID_INTEL_RAID_SROMBU42E_ALIEF	0x3431
+
+#define PCI_DEVICE_ID_INTEL_RAID_SROMBU42E_HARWICH	0x0408
+#define PCI_SUBSYS_ID_INTEL_RAID_SROMBU42E_HARWICH	0x3499
+
+#define PCI_DEVICE_ID_FSC_MEGARAID_PCI_EXPRESS_ROMB	0x0408
+#define PCI_SUBSYS_ID_FSC_MEGARAID_PCI_EXPRESS_ROMB	0x1065
+
+#define PCI_SUBSYS_ID_PERC3_DC				0x493
+
+#ifndef PCI_SUBSYS_ID_FSC
+#define PCI_SUBSYS_ID_FSC			0x1734
+#endif
+
+#define MBOX_MAX_DRIVER_CMDS	126	// number of cmds supported by driver
+#define MBOX_DEF_CMD_PER_LUN	63	// default commands per lun
+#define MBOX_DEFAULT_SG_SIZE	26	// default sg size supported by all fw
+#define MBOX_MAX_SG_SIZE	32	// maximum scatter-gather list size
+#define MBOX_MAX_SECTORS	128
+#define MBOX_TIMEOUT		30	// timeout value for internal cmds
+#define MBOX_BUSY_WAIT		10	// max usec to wait for busy mailbox
+#define MBOX_RESET_WAIT		180	// wait these many seconds in reset
+
+/*
+ * maximum transfer that can happen through the firmware commands issued
+ * internnaly from the driver.
+ */
+#define MBOX_IBUF_SIZE		4096
+
+
+/**
+ * mbox_ccb_t - command control block specific to mailbox based controllers
+ * @raw_mbox		: raw mailbox pointer
+ * @mbox		: mailbox
+ * @mbox64		: extended mailbox
+ * @mbox_dma_h		: maibox dma address
+ * @sgl64		: 64-bit scatter-gather list
+ * @sgl32		: 32-bit scatter-gather list
+ * @sgl_dma_h		: dma handle for the scatter-gather list
+ * @pthru		: passthru structure
+ * @pthru_dma_h		: dma handle for the passthru structure
+ * @epthru		: extended passthru structure
+ * @epthru_dma_h	: dma handle for extended passthru structure
+ * @buf_dma_h		: dma handle for buffers w/o sg list
+ *
+ * command control block specific to the mailbox based controllers
+ */
+typedef struct {
+	uint8_t			*raw_mbox;
+	mbox_t			*mbox;
+	mbox64_t		*mbox64;
+	dma_addr_t		mbox_dma_h;
+	mbox_sgl64		*sgl64;
+	mbox_sgl32		*sgl32;
+	dma_addr_t		sgl_dma_h;
+	mraid_passthru_t	*pthru;
+	dma_addr_t		pthru_dma_h;
+	mraid_epassthru_t	*epthru;
+	dma_addr_t		epthru_dma_h;
+	dma_addr_t		buf_dma_h;
+} mbox_ccb_t;
+
+
+/**
+ * mraid_device_t - adapter soft state structure for mailbox controllers
+ * @param baseport		: base port of hba memory
+ * @param baseaddr		: mapped addr of hba memory
+ * @param una_mbox64		: 64-bit mbox - unaligned
+ * @param una_mbox64_dma	: mbox dma addr - unaligned
+ * @param mbox64		: 64-bit mbox - aligned
+ * @param mbox			: 32-bit mbox - aligned
+ * @param mbox_dma		: mbox dma addr - aligned
+ * @param mailbox_lock		: exclusion lock for the mailbox
+ * @param ccb_list		: list of our command control blocks
+ * @param mbox_pool		: pool of mailboxes
+ * @param mbox_pool_handle	: handle for the mailbox pool memory
+ * @param sg_pool		: pool of scatter-gather lists for this driver
+ * @param sg_pool_handle	: handle to the pool above
+ * @param epthru_pool		: a pool for extended passthru commands
+ * @param epthru_pool_handle	: handle to the pool above
+ * @param int_cmdid		: command id for internal commands
+ * @param pdrv_state		: array for state of each physical drive.
+ * @param flags			: mailbox hba specific flags
+ * @param proc_read		: /proc configuration read
+ * @param proc_stat		: /proc information for statistics
+ * @param proc_mbox		: /proc information for current mailbox
+ * @param proc_rr		: /proc information for rebuild rate
+ * @param proc_battery		: /proc information for battery status
+ * @param proc_pdrvstat		: /proc information for physical drives state
+ * @param proc_rdrvstat		: /proc information for logical drives status
+ * @param last_disp		: flag used to show device scanning
+ * @param hw_error		: set if FW not responding
+ * @fast_load			: If set, skip physical device scanning
+ * @channel_class		: channel class, RAID or SCSI
+ *
+ * Initialization structure for mailbox controllers: memory based and IO based
+ * All the fields in this structure are LLD specific and may be discovered at
+ * init() or start() time.
+ */
+typedef struct {
+	mbox64_t			*una_mbox64;
+	dma_addr_t			una_mbox64_dma;
+	mbox_t				*mbox;
+	mbox64_t			*mbox64;
+	dma_addr_t			mbox_dma;
+	spinlock_t			mailbox_lock;
+
+	unsigned long			baseport;
+	unsigned long			baseaddr;
+
+	struct mraid_pci_blk		mbox_pool[MBOX_MAX_DRIVER_CMDS];
+	struct mraid_pci_blk_pool	*mbox_pool_handle;
+	struct mraid_pci_blk		epthru_pool[MBOX_MAX_DRIVER_CMDS];
+	struct mraid_pci_blk_pool	*epthru_pool_handle;
+	struct mraid_pci_blk		sg_pool[MBOX_MAX_DRIVER_CMDS];
+	struct mraid_pci_blk_pool	*sg_pool_handle;
+
+	mbox_ccb_t			ccb_list[MBOX_MAX_DRIVER_CMDS];
+
+	struct tasklet_struct		dpc_h;
+
+	uint8_t				int_cmdid;
+	uint8_t				pdrv_state[MBOX_MAX_PHYSICAL_DRIVES];
+	uint32_t			flags;
+
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry		*proc_root;
+	struct proc_dir_entry		*proc_read;
+	struct proc_dir_entry		*proc_stat;
+	struct proc_dir_entry		*proc_rr;
+	struct proc_dir_entry		*proc_battery;
+#define MBOX_MAX_PROC_CHANNELS		4
+	struct proc_dir_entry		*proc_pdrvstat[MBOX_MAX_PROC_CHANNELS];
+	struct proc_dir_entry		*proc_rdrvstat[MBOX_MAX_PROC_CHANNELS];
+#endif
+	uint32_t			last_disp;
+	int				hw_error;
+	int				fast_load;
+	uint8_t				channel_class;
+} mraid_device_t;
+
+// route to raid device from adapter
+#define ADAP2RAIDDEV(adp)	((mraid_device_t *)((adp)->raid_device))
+
+#define MAILBOX_LOCK(rdev)	(&rdev->mailbox_lock)
+
+// Find out if this channel is a RAID or SCSI
+#define IS_RAID_CH(rdev, ch)	(((rdev)->channel_class >> (ch)) & 0x01)
+
+
+#define RDINDOOR(rdev)		readl((rdev)->baseaddr + 0x20)
+#define RDOUTDOOR(rdev)		readl((rdev)->baseaddr + 0x2C)
+#define WRINDOOR(rdev, value)	writel(value, (rdev)->baseaddr + 0x20)
+#define WROUTDOOR(rdev, value)	writel(value, (rdev)->baseaddr + 0x2C)
+
+#endif // _MEGARAID_H_
+
+/* vim: set ts=8 sw=8 tw=78: */
diff -Naur linux-2.6.6.orig/drivers/scsi/megaraid/megaraid_mm.c linux-2.6.6/drivers/scsi/megaraid/megaraid_mm.c
--- linux-2.6.6.orig/drivers/scsi/megaraid/megaraid_mm.c	Wed Dec 31 19:00:00 1969
+++ linux-2.6.6/drivers/scsi/megaraid/megaraid_mm.c	Sat May 15 13:35:04 2004
@@ -0,0 +1,729 @@
+/*
+ *
+ *			Linux MegaRAID device driver
+ *
+ * Copyright (c) 2003-2004  LSI Logic Corporation.
+ *
+ *	   This program is free software; you can redistribute it and/or
+ *	   modify it under the terms of the GNU General Public License
+ *	   as published by the Free Software Foundation; either version
+ *	   2 of the License, or (at your option) any later version.
+ *
+ * FILE		: megaraid_mm.c
+ * Version	: v1.0.0.0.04.17.2004 (Apr 14 2004)
+ *
+ * Common management module
+ */
+
+#include "megaraid_mm.h"
+
+MODULE_AUTHOR		("LSI Logic Corporation");
+MODULE_DESCRIPTION	("LSI Logic Management Module");
+MODULE_LICENSE		("GPL");
+MODULE_VERSION		(LSI_COMMON_MOD_VERSION);
+static int		dbglevel	= CL_DLEVEL1;
+module_param		(dbglevel, int, 0);
+MODULE_PARM_DESC	(dbglevel, "Debug level (default=0)");
+
+EXPORT_SYMBOL		( mraid_mm_register_adp );
+EXPORT_SYMBOL		( mraid_mm_unregister_adp );
+
+static int		majorno;
+spinlock_t		lc_lock		= SPIN_LOCK_UNLOCKED;
+static uint32_t		drvr_ver	= 0x01000000;
+
+static int		slots_inuse	= 0;
+static mraid_mmadp_t 	adparr[MAX_LSI_CMN_ADAPS];
+
+wait_queue_head_t	wait_q;
+
+static struct file_operations lsi_fops = {
+
+	.ioctl		= megaraid_mm_ioctl,
+	.open		= megaraid_mm_open,
+	.release	= megaraid_mm_close,
+	.owner		= THIS_MODULE,
+};
+
+static int
+megaraid_mm_ioctl( struct inode* inode, struct file* filep, unsigned int cmd,
+							unsigned long arg )
+{
+	uioc_t*		kioc;
+	char		signature[EXT_IOCTL_SIGN_SZ]	= {0};
+	int		rval;
+	mraid_mmadp_t*	adp;
+	int		adp_index;
+	uint8_t		old_ioctl;
+	int		drvrcmd_rval;
+
+	/*
+	 * Make sure only USCSICMD are issued through this interface.
+	 * MIMD application would still fire different command.
+	 */
+
+	if( (_IOC_TYPE(cmd) != MEGAIOC_MAGIC) && (cmd != USCSICMD) ) {
+		return -EINVAL;
+	}
+
+	/*
+	 * Look for signature to see if this is the new or old ioctl format.
+	 */
+	if( copy_from_user(signature, (char *)arg, EXT_IOCTL_SIGN_SZ) ) {
+		con_log(CL_ANN,(KERN_WARNING "cp from usr addr failed\n"));
+		return (-EFAULT);
+	}
+
+	if( memcmp(signature, EXT_IOCTL_SIGN, EXT_IOCTL_SIGN_SZ) == 0 )
+		old_ioctl = MRAID_FALSE;
+	else
+		old_ioctl = MRAID_TRUE;
+
+	/*
+	 * If it is a driver ioctl (as opposed to fw ioctls), then we can
+	 * handle the command locally. rval > 0 means it is not a drvr cmd
+	 */
+	rval = handle_drvrcmd( arg, old_ioctl, &drvrcmd_rval );
+
+	if (rval < 0)
+		return rval;
+	else if (rval == 0)
+		return drvrcmd_rval;
+
+	/*
+	 * Call the approprite converter to convert to kernel space
+	 */
+	if (old_ioctl == MRAID_FALSE) {
+		/*
+		 * User sent the new uioc_t packet. We don't support it yet.
+		 */
+		return (-EINVAL);
+	}
+	else {
+		/*
+		 * User sent the old mimd_t ioctl packet. Convert it to
+		 * uioc. If there is an error, the mutexes and other resources
+		 * would have been released already. So we can just return.
+		 */
+		if ((rval = mimd_to_kioc((mimd_t*)arg, &adp_index))) {
+			return rval;
+		}
+	}
+
+	adp		= &adparr[adp_index];
+	kioc		= &adp->kioc;
+	kioc->done	= ioctl_done;
+
+	/*
+	 * Issue the IOCTL to the low level driver
+	 */
+	if ((rval = lld_ioctl( adp, kioc ))) {
+		up( &adp->kioc_mtx );
+		return rval;
+	}
+
+	/*
+	 * Convert the kioc back to user space
+	 */
+	rval = kioc_to_mimd( kioc, (mimd_t*) arg );
+	up( &adp->kioc_mtx );
+
+	return rval;
+}
+
+/*
+ * handle_drvrcmd()	: This routine checks if the opcode is a driver
+ * 			  cmd and if it is, handles it.
+ *
+ * @arg			: packet sent by the user app
+ * @old_ioctl		: mimd if MRAID_TRUE; uioc otherwise
+ */
+static int
+handle_drvrcmd( ulong arg, uint8_t old_ioctl, int* rval )
+{
+	mimd_t*		umimd;
+	mimd_t		kmimd;
+	uint8_t		opcode;
+	uint8_t		subopcode;
+
+	if (old_ioctl == MRAID_TRUE)
+		goto old_packet;
+	else
+		goto new_packet;
+
+new_packet:
+	return (-ENOTSUPP);
+
+old_packet:
+	*rval = 0;
+	umimd = (mimd_t*) arg;
+
+	if (copy_from_user( &kmimd, umimd, sizeof(mimd_t)))
+		return (-EFAULT);
+
+	opcode		= kmimd.ui.fcs.opcode;
+	subopcode	= kmimd.ui.fcs.subopcode;
+
+	/*
+	 * If the opcode is 0x82 and the subopcode is either GET_DRVRVER or
+	 * GET_NUMADP, then we can handle. Otherwise we should return 1 to
+	 * indicate that we cannot handle this.
+	 */
+	if (opcode != 0x82)
+		return 1;
+
+	switch( subopcode ) {
+
+	case MEGAIOC_QDRVRVER:
+
+		if (copy_to_user(kmimd.data, &drvr_ver, sizeof(uint32_t)))
+			return (-EFAULT);
+
+		return 0;
+
+	case MEGAIOC_QNADAP:
+
+		*rval = slots_inuse;
+
+		if(copy_to_user(kmimd.data, &slots_inuse, sizeof(uint32_t)))
+			return (-EFAULT);
+
+		return 0;
+
+	default:
+		/* cannot handle */
+		return 1;
+	}
+
+	return 0;
+}
+
+/**
+ * mimd_to_kioc	: Converter from old to new ioctl format
+ *
+ * @umimd	: user space old MIMD IOCTL
+ * @kioc	: kernel space new format IOCTL
+ *
+ * Routine to convert MIMD interface IOCTL to new interface IOCTL packet. The
+ * new packet is in kernel space so that driver can perform operations on it
+ * freely.
+ */
+
+static int
+mimd_to_kioc( mimd_t* umimd, int* adp_index )
+{
+	uint64_t		temp;
+	uint32_t		adapno;
+	uint8_t			opcode;
+	uint8_t			subopcode;
+	uint32_t		bufsz = 0;
+	mimd_t			mimd;
+
+	mraid_mmadp_t*		adp;
+	mbox64_t*		mbox64;
+	mraid_passthru_t*	pthru32;
+	uioc_t*			kioc;
+
+	if( copy_from_user( &mimd, umimd, sizeof(mimd_t)) )
+		return (-EFAULT);
+
+	/*
+	 * Applications are not allowed to send extd pthru
+	 */
+	if( mimd.mbox[0] == 0xC3 )
+		return (-EINVAL);
+
+	opcode		= mimd.ui.fcs.opcode;
+	subopcode	= mimd.ui.fcs.subopcode;
+	adapno		= GETADAP(mimd.ui.fcs.adapno);
+
+	if( adapno >= slots_inuse )
+		return (-ENODEV);
+
+	adp = &adparr[ adapno ];
+
+	down( &adp->kioc_mtx );
+
+	kioc		= &adp->kioc;
+	kioc->adapno	= adapno;
+	*adp_index	= adapno;
+
+	kioc->mb_type	= MBOX_LEGACY;
+	kioc->app_type	= APPTYPE_MIMD;
+
+	switch( opcode ) {
+
+	case 0x82:
+
+		if (subopcode == MEGAIOC_QADAPINFO) {
+
+			kioc->opcode	= GET_ADAP_INFO;
+			kioc->data_dir	= UIOC_RD;
+			kioc->xferlen	= sizeof(mraid_hba_info_t);
+			kioc->cmdbuf	= (ulong)adp->memblk;
+			bufsz		= kioc->xferlen;
+		}
+		else {
+			con_log( CL_ANN, ("Invalid subop\n"));
+
+			up( &adp->kioc_mtx );
+			return (-EINVAL);
+		}
+
+		break;
+
+	case 0x81:
+
+		kioc->opcode	= MBOX_CMD;
+		kioc->xferlen	= mimd.ui.fcs.length;
+		bufsz		= sizeof(mbox64_t);
+		kioc->cmdbuf	= (ulong)adp->memblk;
+
+		if( mimd.outlen ) kioc->data_dir  = UIOC_RD;
+		if( mimd.inlen  ) kioc->data_dir |= UIOC_WR;
+
+		break;
+
+	case 0x80:
+
+		bufsz		= sizeof(mbox64_t);
+		kioc->opcode	= MBOX_CMD;
+		kioc->xferlen	= (mimd.outlen > mimd.inlen) ?
+					mimd.outlen : mimd.inlen;
+		kioc->cmdbuf	= (ulong)adp->memblk;
+
+		if( mimd.outlen ) kioc->data_dir  = UIOC_RD;
+		if( mimd.inlen  ) kioc->data_dir |= UIOC_WR;
+
+		break;
+
+	default:
+		up( &adp->kioc_mtx );
+		return (-EINVAL);
+	}
+
+	memset( (void*)((ulong)kioc->cmdbuf), 0, bufsz );
+
+	/*
+	 * If driver command, nothing else to do
+	 */
+	if( opcode == 0x82 )
+		return 0;
+
+	/*
+	 * This is a mailbox cmd; copy the mailbox from mimd
+	 */
+	mbox64 = (mbox64_t*) ((ulong)kioc->cmdbuf);
+	memcpy( &(mbox64->mbox32), mimd.mbox, 18 );
+
+	mbox64->xferaddr_lo	= mbox64->mbox32.xferaddr;
+	mbox64->xferaddr_hi	= 0;
+	mbox64->mbox32.xferaddr	= 0xffffffff;
+
+	if( mbox64->mbox32.cmd != 0x03 ) {	/* Not pthru; regular DCMD */
+
+		/*
+		 * We had allocated 28K for memblk. adp->kioc.cmdbuf is
+		 * is pointing to the beginning for that memory block. Since
+		 * this is a mailbox command, the beginning of the block is
+		 * treated as a mailbox. Now we need the data. We will leave
+		 * the first 1k for mailbox and have int_data point to the
+		 * memblk + 1024
+		 */
+		adp->int_data		= adp->memblk + 1024;
+		adp->int_data_dmah	= (ulong)adp->memblk_dmah + 1024;
+
+		temp			= mbox64->xferaddr_lo;
+		mbox64->xferaddr_lo	= adp->int_data_dmah;
+		adp->int_data_len	= kioc->xferlen;
+		adp->int_data_user	= (caddr_t)(ulong)temp;
+
+		if( kioc->data_dir & UIOC_WR ) {
+			if(copy_from_user(adp->int_data,
+					(void*)(ulong)temp, kioc->xferlen)){
+				up( &adp->kioc_mtx );
+				return (-EFAULT);
+			}
+		}
+
+		return 0;
+	}
+
+	/*
+	 * This is a regular 32-bit pthru cmd; mbox points to pthru struct.
+	 * Just like in above case, the beginning for memblk is treated as
+	 * a mailbox. The passthru will begin at next 1K boundary. And the
+	 * data will start 1K after that.
+	 */
+	mbox64->mbox32.cmd = 0x03;
+
+	adp->int_pthru		= adp->memblk + 1024;
+	adp->int_pthru_dmah	= adp->memblk_dmah + 1024;
+
+	temp			= mbox64->xferaddr_lo;
+	pthru32			= (mraid_passthru_t*)adp->int_pthru;
+	mbox64->xferaddr_lo	= adp->int_pthru_dmah;
+	adp->int_pthru_len	= sizeof(mraid_passthru_t);
+	adp->int_pthru_user	= (caddr_t)(ulong)temp;
+
+	if( copy_from_user( pthru32, (void*)(ulong)temp,
+					sizeof(mraid_passthru_t)) ) {
+		up( &adp->kioc_mtx );
+		return (-EFAULT);
+	}
+
+	adp->int_data			= adp->memblk + 2048;
+	adp->int_data_dmah		= adp->memblk_dmah + 2048;
+
+	temp				= pthru32->dataxferaddr;
+	pthru32->dataxferaddr		= adp->int_data_dmah;
+	adp->int_data_len		= pthru32->dataxferlen;
+	adp->int_data_user		= (caddr_t)(ulong)temp;
+
+	if( copy_from_user(adp->int_data, (void*)(ulong)temp,
+					adp->int_data_len) ) {
+		up( &adp->kioc_mtx );
+		return (-EFAULT);
+	}
+
+	return 0;
+}
+
+/**
+ * lld_ioctl	: Routine to issue ioctl to low level drvr
+ *
+ * @adp		: The adapter entry in adparr
+ * @kioc	: The ioctl packet with kernel addresses
+ */
+static int
+lld_ioctl( mraid_mmadp_t* adp, uioc_t* kioc )
+{
+	int			rval;
+	struct timer_list	timer;
+	struct timer_list*	tp = NULL;
+
+	if (!adp || !kioc)
+		return (-EINVAL);
+
+	kioc->status	= LC_PENDING;
+	rval		= adp->issue_uioc( adp->drvr_data, kioc, IOCTL_ISSUE);
+
+	if( rval )
+		return rval;
+
+	/*
+	 * Start the timer
+	 */
+	if (adp->timeout > 0) {
+		tp		= &timer;
+		init_timer(tp);
+
+		tp->function	= lld_timedout;
+		tp->data	= (ulong) kioc;
+		tp->expires	= jiffies + adp->timeout * HZ;
+
+		add_timer(tp);
+	}
+
+	/*
+	 * Wait till the low level driver completes the ioctl. After this
+	 * call, the ioctl either completed successfully or timedout.
+	 */
+	wait_event( wait_q, (kioc->status != LC_PENDING) );
+	if (tp) {
+		del_timer_sync( tp );
+	}
+
+	return 0;
+}
+
+/*
+ * ioctl_done	: callback from the low level driver
+ *
+ * @kioc	: completed ioctl packet
+ */
+void
+ioctl_done( uioc_t* kioc )
+{
+	/*
+	 * When the kioc returns from driver, make sure it still doesn't
+	 * have LC_PENDING in status. Otherwise, driver will hang on
+	 * wait_event forever
+	 */
+	if( kioc->status == LC_PENDING ){
+		con_log( CL_ANN, ("lld didn't change status!!\n"));
+		kioc->status = LC_UNKNOWN;
+	}
+
+	wake_up( &wait_q );
+}
+
+/*
+ * lld_timedout	: callback from the expired timer
+ *
+ * @ptr		: ioctl packet that timed out
+ */
+void
+lld_timedout( ulong ptr )
+{
+	uioc_t* kioc	= (uioc_t*)ptr;
+	kioc->status 	= LC_ETIME;
+
+	wake_up( &wait_q );
+}
+
+/**
+ * kioc_to_mimd	: Converter from new back to old format
+ *
+ * @kioc	: Kernel space IOCTL packet (successfully issued)
+ * @mimd	: User space MIMD packet
+ */
+static int
+kioc_to_mimd( uioc_t* kioc, mimd_t* mimd )
+{
+	mimd_t			kmimd;
+	uint8_t			opcode;
+	uint8_t			subopcode;
+
+	mbox64_t*		mbox64;
+	mraid_passthru_t*	upthru32;
+	mraid_passthru_t*	kpthru32;
+	mcontroller_t		cinfo;
+	mraid_hba_info_t*	hinfo;
+
+	mraid_mmadp_t*		adp = &adparr[ kioc->adapno ];
+
+	if (kioc->status != LC_SUCCESS)
+		return (-EFAULT);
+
+	if (copy_from_user( &kmimd, mimd, sizeof(mimd_t)))
+		return (-EFAULT);
+
+	opcode		= kmimd.ui.fcs.opcode;
+	subopcode	= kmimd.ui.fcs.subopcode;
+
+	if( opcode == 0x82 ) {
+		switch( subopcode ) {
+
+		case MEGAIOC_QADAPINFO:
+
+			hinfo = (mraid_hba_info_t*)(ulong)kioc->cmdbuf;
+			hinfo_to_cinfo( hinfo, &cinfo );
+
+			if (copy_to_user(kmimd.data, &cinfo, sizeof(cinfo)))
+				return (-EFAULT);
+
+			return 0;
+
+		default:
+			return (-EINVAL);
+		}
+
+		return 0;
+	}
+
+	mbox64 = (mbox64_t*) (ulong)kioc->cmdbuf;
+
+	if( adp->int_pthru_len ) {
+
+		upthru32 = (mraid_passthru_t*)adp->int_pthru_user;
+		kpthru32 = (mraid_passthru_t*)adp->int_pthru;
+
+		if( copy_to_user( (void*) &(upthru32->scsistatus),
+					(void*)&(kpthru32->scsistatus),
+					sizeof( uint8_t )) ) {
+			return (-EFAULT);
+		}
+	}
+
+	if( adp->int_data_len ) {
+		if( copy_to_user(adp->int_data_user, adp->int_data,
+					adp->int_data_len ) ) {
+			return (-EFAULT);
+		}
+	}
+
+	if (copy_to_user((void*)&mimd->mbox[17], (void*)&mbox64->mbox32.status,
+				sizeof(uint8_t))) {
+		return (-EFAULT);
+	}
+
+	adp->int_data		= NULL;
+	adp->int_data_len	= 0;
+	adp->int_data_dmah	= 0;
+	adp->int_data_user	= NULL;
+	adp->int_pthru		= NULL;
+	adp->int_pthru_len	= 0;
+	adp->int_pthru_dmah	= 0;
+	adp->int_pthru_user	= NULL;
+
+	return 0;
+}
+
+static void
+hinfo_to_cinfo( mraid_hba_info_t* hinfo, mcontroller_t* cinfo )
+{
+	if( !hinfo || !cinfo )
+		return;
+
+	cinfo->base		= hinfo->baseport;
+	cinfo->irq		= hinfo->irq;
+	cinfo->numldrv		= hinfo->num_ldrv;
+	cinfo->pcibus		= hinfo->pci_bus;
+	cinfo->pcidev		= hinfo->pci_slot;
+	cinfo->pcifun		= PCI_FUNC(hinfo->pci_dev_fn);
+	cinfo->pciid		= hinfo->pci_device_id;
+	cinfo->pcivendor	= hinfo->pci_vendor_id;
+	cinfo->pcislot		= hinfo->pci_slot;
+	cinfo->uid		= hinfo->unique_id;
+}
+
+/*
+ * mraid_mm_register_adp	: Registration routine for low level drvrs
+ *
+ * @adp				: Adapter objejct
+ */
+uint32_t
+mraid_mm_register_adp( mraid_mmadp_t* adp )
+{
+	int	i;
+	int	cur_slot;
+
+	caddr_t		memblk;
+	dma_addr_t	memblk_dmah;
+
+	if (!adp)
+		return LC_EINVAL;
+
+	if (adp->drvr_type != DRVRTYPE_MBOX)
+		return LC_ENOTSUPP;
+
+	memblk = pci_alloc_consistent(adp->pdev, MEMBLK_SZ, &memblk_dmah);
+
+	if( !memblk )
+		return LC_ENOMEM;
+
+	spin_lock( &lc_lock );
+
+	if (slots_inuse >= MAX_LSI_CMN_ADAPS ) {
+		spin_unlock( &lc_lock );
+		return LC_EFULL;
+	}
+
+	cur_slot = slots_inuse++;
+	spin_unlock( &lc_lock );
+
+	/*
+	 * Return error if it is a duplicate unique_id
+	 */
+	for (i=0; i < MAX_LSI_CMN_ADAPS; i++ ) {
+		if (adparr[i].unique_id == adp->unique_id) {
+			return LC_EEXISTS;
+		}
+	}
+
+	adparr[cur_slot].unique_id	= adp->unique_id;
+	adparr[cur_slot].drvr_type	= adp->drvr_type;
+	adparr[cur_slot].drvr_data	= adp->drvr_data;
+	adparr[cur_slot].pdev		= adp->pdev;
+	adparr[cur_slot].issue_uioc	= adp->issue_uioc;
+	adparr[cur_slot].timeout	= adp->timeout;
+	adparr[cur_slot].memblk		= memblk;
+	adparr[cur_slot].memblk_dmah	= memblk_dmah;
+
+	init_MUTEX( &adparr[cur_slot].kioc_mtx );
+
+	return 0;
+}
+
+/*
+ * mraid_mm_unregister_adp	: Unregister routine for low level drivers
+ *
+ * @unique_id			: UID of the adpater
+ */
+uint32_t
+mraid_mm_unregister_adp( uint32_t unique_id )
+{
+	int i;
+
+	spin_lock( &lc_lock );
+
+	for (i = 0; i < MAX_LSI_CMN_ADAPS; i++ ) {
+		if (adparr[i].unique_id == unique_id) {
+
+			pci_free_consistent( adparr[i].pdev, MEMBLK_SZ,
+				adparr[i].memblk, adparr[i].memblk_dmah );
+
+			memset( &adparr[i], 0, sizeof(mraid_mmadp_t) );
+			spin_unlock( &lc_lock );
+
+			con_log(CL_ANN, (
+				"megaraid_mm: Unregistered one lsi adp\n"));
+
+			return 0;
+		}
+	}
+
+	spin_unlock( &lc_lock );
+	return LC_ENOADP;
+}
+
+static int
+megaraid_mm_open( struct inode *inode, struct file *filep )
+{
+	return 0;
+}
+
+static int
+megaraid_mm_close( struct inode *inode, struct file *filep )
+{
+	return 0;
+}
+
+static int __init
+megaraid_mm_init(void)
+{
+	// Announce the driver version
+	con_log(CL_ANN, (KERN_INFO "megaraid_mm: %s %s\n",
+		LSI_COMMON_MOD_VERSION, LSI_COMMON_MOD_EXT_VERSION));
+
+	majorno = register_chrdev( 0, "megadev", &lsi_fops );
+
+	if (majorno < 0) {
+		con_log( CL_ANN, ("lsi_cmnmod: cannot get major\n"));
+		return majorno;
+	}
+	init_waitqueue_head( &wait_q );
+	memset( adparr, 0, sizeof(mraid_mmadp_t) * MAX_LSI_CMN_ADAPS );
+
+	slots_inuse = 0;
+
+	register_ioctl32_conversion( MEGAIOCCMD, megaraid_mm_compat_ioctl );
+
+	return 0;
+}
+
+#ifdef LSI_CONFIG_COMPAT
+static int
+megaraid_mm_compat_ioctl( unsigned int fd, unsigned int cmd,
+			ulong arg, struct file* filep )
+{
+	struct inode *inode = filep->f_dentry->d_inode;
+
+	return megaraid_mm_ioctl(inode, filep, cmd, arg);
+}
+#endif
+
+static void __exit
+megaraid_mm_exit(void)
+{
+	con_log( CL_ANN, ("exiting common mod \n" ));
+
+	unregister_chrdev( majorno, "megadev" );
+	unregister_ioctl32_conversion( MEGAIOCCMD );
+}
+
+module_init( megaraid_mm_init);
+module_exit( megaraid_mm_exit);
+
+/* vi: set ts=8 sw=8 tw=78: */
diff -Naur linux-2.6.6.orig/drivers/scsi/megaraid/megaraid_mm.h linux-2.6.6/drivers/scsi/megaraid/megaraid_mm.h
--- linux-2.6.6.orig/drivers/scsi/megaraid/megaraid_mm.h	Wed Dec 31 19:00:00 1969
+++ linux-2.6.6/drivers/scsi/megaraid/megaraid_mm.h	Sat May 15 13:35:04 2004
@@ -0,0 +1,145 @@
+/*
+ *
+ *			Linux MegaRAID device driver
+ *
+ * Copyright (c) 2003-2004  LSI Logic Corporation.
+ *
+ *	   This program is free software; you can redistribute it and/or
+ *	   modify it under the terms of the GNU General Public License
+ *	   as published by the Free Software Foundation; either version
+ *	   2 of the License, or (at your option) any later version.
+ *
+ * FILE		: megaraid_mm.h
+ * Version	: v2.20.0 (Apr 14 2004)
+ */
+
+#ifndef MEGARAID_MM_H
+#define MEGARAID_MM_H
+
+#include <linux/spinlock.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/delay.h>
+#include <linux/version.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/proc_fs.h>
+#include <linux/pci.h>
+#include <linux/list.h>
+#include <linux/reboot.h>
+
+#include "mbox_defs.h"
+
+#define LSI_COMMON_MOD_VERSION	"1.0.0.rc1"
+#define LSI_COMMON_MOD_EXT_VERSION	\
+	"(Release Date: Mon May 17 22:18:19 EDT 2004)"
+
+#define LSI_DBGLVL	dbglevel
+/*
+ * Sz of mem allocated for each internal ioctl packet
+ */
+#define MEMBLK_SZ	(28*1024)
+
+/*
+ * Localizing ioctl32 differences
+ */
+
+#if defined (CONFIG_COMPAT) || defined(__x86_64__) || defined(IA32_EMULATION)
+#define LSI_CONFIG_COMPAT
+#endif
+
+#ifdef LSI_CONFIG_COMPAT
+#include <asm/ioctl32.h>
+#else
+#define register_ioctl32_conversion(a,b)	do{}while(0)
+#define unregister_ioctl32_conversion(a)	do{}while(0)
+#endif /* LSI_CONFIG_COMPAT */
+
+/**
+ * mimd_t	: Old style ioctl packet structure (depracated)
+ *
+ * @inlen	:
+ * @outlen	:
+ * @fca		:
+ * @opcode	:
+ * @subopcode	:
+ * @adapno	:
+ * @buffer	:
+ * @pad		:
+ * @length	:
+ * @mbox	:
+ * @pthru	:
+ * @data	:
+ * @pad		:
+ *
+ * Note		: This structure is DEPRACATED. New applications must use
+ *		: uioc_t structure instead. All new hba drivers use the new
+ *		: format. If we get this mimd packet, we will convert it into
+ *		: new uioc_t format and send it to the hba drivers.
+ */
+
+typedef struct mimd {
+
+	uint32_t inlen;
+	uint32_t outlen;
+
+	union {
+		uint8_t fca[16];
+		struct {
+			uint8_t opcode;
+			uint8_t subopcode;
+			uint16_t adapno;
+#if BITS_PER_LONG == 32
+			uint8_t *buffer;
+			uint8_t pad[4];
+#endif
+#if BITS_PER_LONG == 64
+			uint8_t *buffer;
+#endif
+			uint32_t length;
+		} __attribute__ ((packed)) fcs;
+	} __attribute__ ((packed)) ui;
+
+	uint8_t mbox[18];		/* 16 bytes + 2 status bytes */
+	mraid_passthru_t pthru;
+
+#if BITS_PER_LONG == 32
+	char *data;		/* buffer <= 4096 for 0x80 commands */
+	char pad[4];
+#endif
+#if BITS_PER_LONG == 64
+	char *data;
+#endif
+
+} __attribute__ ((packed))mimd_t;
+
+/*
+ * Entry points for char node driver
+ */
+static int	megaraid_mm_open ( struct inode*, struct file* );
+static int	megaraid_mm_close( struct inode*, struct file* );
+static int	megaraid_mm_ioctl( struct inode*, struct file*, uint, ulong );
+
+/*
+ * routines to convert to and from the old the format
+ */
+static int	mimd_to_kioc( mimd_t*, int* );
+static int	kioc_to_mimd( uioc_t*, mimd_t* );
+
+/*
+ * Helper functions
+ */
+static int	handle_drvrcmd( ulong, uint8_t, int* );
+static int	lld_ioctl( mraid_mmadp_t*, uioc_t* );
+void		ioctl_done( uioc_t* );
+void		lld_timedout( ulong );
+static void	hinfo_to_cinfo( mraid_hba_info_t*, mcontroller_t*);
+
+#ifdef LSI_CONFIG_COMPAT
+static int	megaraid_mm_compat_ioctl( unsigned int, unsigned int,
+						ulong, struct file* );
+#endif
+
+#endif /*MEGARAID_MM_H*/
+
diff -Naur linux-2.6.6.orig/drivers/scsi/megaraid/readme linux-2.6.6/drivers/scsi/megaraid/readme
--- linux-2.6.6.orig/drivers/scsi/megaraid/readme	Wed Dec 31 19:00:00 1969
+++ linux-2.6.6/drivers/scsi/megaraid/readme	Sat May 15 13:35:04 2004
@@ -0,0 +1,70 @@
+			Notes on Management Module
+			~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Overview:
+--------
+
+Different classes of controllers from LSI Logic, accept and respond to the
+user applications in a similar way. They understand the same firmware control
+commands. Furthermore, the applications also can treat different classes of
+the controllers uniformly. Hence it is logical to have a single module that
+interefaces with the applications on one side and all the low level drivers
+on the other.
+
+The advantages, though obvious, are listed for completeness:
+
+	i.	Avoid duplicate code from the low level drivers.
+	ii.	Unburden the low level drivers from having to export the
+		character node device and related handling.
+	iii.	Implement any policy mechanisms in one place.
+	iv.	Applications have to interface with only module instead of
+		multiple low level drivers.
+
+Currently this module (called Common Management Module) is used only to issue
+ioctl commands. But this module is envisioned to handle all user space level
+interactions. So any 'proc', 'sysfs' implementations will be localized in this
+common module.
+
+Credits:
+-------
+
+"Shared code in a third module, a "library module", is an acceptable
+solution. modprobe automatically loads dependent modules, so users
+running "modprobe driver1" or "modprobe driver2" would automatically
+load the shared library module."
+
+		- Jeff Garzik (jgarzik@pobox.com), 02.25.2004 LKML
+
+"As Jeff hinted, if your userspace<->driver API is consistent between
+your new MPT-based RAID controllers and your existing megaraid driver,
+then perhaps you need a single small helper module (lsiioctl or some
+better name), loaded by both mptraid and megaraid automatically, which
+handles registering the /dev/megaraid node dynamically. In this case,
+both mptraid and megaraid would register with lsiioctl for each
+adapter discovered, and lsiioctl would essentially be a switch,
+redirecting userspace tool ioctls to the appropriate driver."
+
+		- Matt Domsch, (Matt_Domsch@dell.com), 02.25.2004 LKML
+
+Design:
+------
+
+The Common Management Module is implemented in megaraid_mm.[ch] files. This
+module acts as a registry for low level hba drivers. The low level drivers
+(currently only megaraid) register each controller with the common module.
+
+The applications interface with the common module via the character device
+node exported by the module.
+
+The lower level drivers now understand only a new improved ioctl packet called
+uioc_t. The management module converts the older ioctl packets from the older
+applications into uioc_t. After driver handles the uioc_t, the common module
+will convert that back into the old format before returning to applications.
+
+As new applications evolve and replace the old ones, the old packet format
+will be retired.
+
+Common module dedicates one uioc_t packet to each controller registered. This
+can easily be more than one. But since megaraid is the only low level driver
+today, and it can handle only one ioctl, there is no reason to have more. But
+as new controller classes get added, this will be tuned appropriately.
